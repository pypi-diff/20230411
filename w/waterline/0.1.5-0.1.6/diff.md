# Comparing `tmp/waterline-0.1.5-py3-none-any.whl.zip` & `tmp/waterline-0.1.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 6215066 bytes, number of entries: 66
--rw-rw-r--  2.0 unx      205 b- defN 23-Apr-07 20:48 waterline/__init__.py
+Zip file size: 6216406 bytes, number of entries: 66
+-rw-rw-r--  2.0 unx      223 b- defN 23-Apr-09 20:46 waterline/__init__.py
 -rw-rw-r--  2.0 unx     1805 b- defN 23-Apr-07 00:51 waterline/jobs.py
--rw-rw-r--  2.0 unx      792 b- defN 23-Apr-06 16:35 waterline/pipeline.py
--rw-rw-r--  2.0 unx      290 b- defN 23-Apr-07 20:58 waterline/run.py
+-rw-rw-r--  2.0 unx     2609 b- defN 23-Apr-10 05:15 waterline/pipeline.py
+-rw-rw-r--  2.0 unx     1096 b- defN 23-Apr-10 15:28 waterline/run.py
 -rw-rw-r--  2.0 unx     3382 b- defN 23-Apr-07 20:58 waterline/suite.py
 -rw-rw-r--  2.0 unx     7123 b- defN 23-Apr-06 17:01 waterline/suites.py
--rw-rw-r--  2.0 unx      486 b- defN 23-Apr-06 14:11 waterline/utils.py
--rw-rw-r--  2.0 unx     4958 b- defN 23-Apr-07 20:56 waterline/workspace.py
+-rw-rw-r--  2.0 unx      641 b- defN 23-Apr-10 05:20 waterline/utils.py
+-rw-rw-r--  2.0 unx     6323 b- defN 23-Apr-10 04:50 waterline/workspace.py
 -rw-rw-r--  2.0 unx      135 b- defN 23-Apr-07 15:59 waterline/suites/__init__.py
--rw-rw-r--  2.0 unx     1484 b- defN 23-Apr-06 21:03 waterline/suites/gap.py
--rw-rw-r--  2.0 unx     8637 b- defN 23-Apr-06 21:01 waterline/suites/mibench.py
--rw-rw-r--  2.0 unx     2528 b- defN 23-Apr-06 21:02 waterline/suites/nas.py
--rw-rw-r--  2.0 unx     3478 b- defN 23-Apr-07 18:33 waterline/suites/polybench.py
+-rw-rw-r--  2.0 unx     1593 b- defN 23-Apr-10 04:52 waterline/suites/gap.py
+-rw-rw-r--  2.0 unx     9004 b- defN 23-Apr-10 19:44 waterline/suites/mibench.py
+-rw-rw-r--  2.0 unx     2546 b- defN 23-Apr-09 19:39 waterline/suites/nas.py
+-rw-rw-r--  2.0 unx     3416 b- defN 23-Apr-10 15:08 waterline/suites/polybench.py
 -rw-rw-r--  2.0 unx     2079 b- defN 23-Apr-07 20:36 waterline/suites/spec2017.py
--rw-rw-r--  2.0 unx     1297 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/Makefile
--rw-rw-r--  2.0 unx     2959 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/README
+-rw-rw-r--  2.0 unx     1297 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/Makefile
+-rw-rw-r--  2.0 unx     2959 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/README
 -rw-rw-r--  2.0 unx        0 b- defN 23-Apr-07 16:10 waterline/suites/SPEC2017/test.txt
 -rwxrwxr-x  2.0 unx  4511744 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/benchmarks/omnetpp_s/omnetpp_s
 -rw-rw-r--  2.0 unx  5067012 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/benchmarks/omnetpp_s/omnetpp_s.bc
 -rwxrwxr-x  2.0 unx 12596976 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/benchmarks/xalancbmk_s/xalancbmk_s
 -rw-rw-r--  2.0 unx      446 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/Makefile
 -rwxrwxr-x  2.0 unx      296 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/bin/run.sh
 -rw-rw-r--  2.0 unx     1457 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/doc/README
@@ -36,33 +36,33 @@
 -rw-rw-r--  2.0 unx      864 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/scripts/speedup.con
 -rwxrwxr-x  2.0 unx     2483 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/scripts/speedup.sh
 -rwxrwxr-x  2.0 unx       82 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/condor/scripts/submit.sh
 -rw-rw-r--  2.0 unx     2129 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/makefiles/Makefile
 -rwxrwxr-x  2.0 unx      433 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/makefiles/download.sh
 -rwxrwxr-x  2.0 unx      342 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/makefiles/fetchRuntime.sh
 -rwxrwxr-x  2.0 unx      236 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/makefiles/run.sh
--rw-rw-r--  2.0 unx    17132 b- defN 23-Apr-07 18:26 waterline/suites/SPEC2017/patches/gclang.cfg
--rw-rw-r--  2.0 unx    10360 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/patches/parest_r_patch.tar.xz
--rw-rw-r--  2.0 unx      475 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/patches/pure_c_cpp_rate.bset
--rw-rw-r--  2.0 unx      466 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/patches/pure_c_cpp_speed.bset
--rw-rw-r--  2.0 unx       79 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/patches/SPEC2017/README
+-rw-rw-r--  2.0 unx    17132 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/patches/gclang.cfg
+-rw-rw-r--  2.0 unx    10360 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/patches/parest_r_patch.tar.xz
+-rw-rw-r--  2.0 unx      475 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/patches/pure_c_cpp_rate.bset
+-rw-rw-r--  2.0 unx      466 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/patches/pure_c_cpp_speed.bset
+-rw-rw-r--  2.0 unx       79 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/patches/SPEC2017/README
 -rw-rw-r--  2.0 unx       55 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/plot/Makefile
 -rw-rw-r--  2.0 unx     2201 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/plot/barplot.py
 -rwxrwxr-x  2.0 unx       71 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/plot/barplot.sh
 -rw-rw-r--  2.0 unx       21 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/plot/barplot.txt
 -rwxrwxr-x  2.0 unx      393 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/plot/virtualEnv.sh
--rwxrwxr-x  2.0 unx     1516 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/binary.sh
--rwxrwxr-x  2.0 unx     2323 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/bitcode.sh
--rwxrwxr-x  2.0 unx      650 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/bitcode_copy.sh
--rwxrwxr-x  2.0 unx     2024 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/collect_output.sh
--rwxrwxr-x  2.0 unx      423 b- defN 23-Apr-07 16:50 waterline/suites/SPEC2017/scripts/compile.sh
--rwxrwxr-x  2.0 unx      586 b- defN 23-Apr-07 16:24 waterline/suites/SPEC2017/scripts/install.sh
--rwxrwxr-x  2.0 unx     1410 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/optimization.sh
--rwxrwxr-x  2.0 unx     2626 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/run.sh
--rwxrwxr-x  2.0 unx     2757 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/setup.sh
--rwxrwxr-x  2.0 unx      267 b- defN 23-Apr-07 16:15 waterline/suites/SPEC2017/scripts/uninstall.sh
--rw-rw-r--  2.0 unx     1057 b- defN 23-Apr-07 21:22 waterline-0.1.5.dist-info/LICENSE
--rw-rw-r--  2.0 unx      246 b- defN 23-Apr-07 21:22 waterline-0.1.5.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Apr-07 21:22 waterline-0.1.5.dist-info/WHEEL
--rw-rw-r--  2.0 unx       10 b- defN 23-Apr-07 21:22 waterline-0.1.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6386 b- defN 23-Apr-07 21:22 waterline-0.1.5.dist-info/RECORD
-66 files, 22289108 bytes uncompressed, 6204606 bytes compressed:  72.2%
+-rwxrwxr-x  2.0 unx     1516 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/binary.sh
+-rwxrwxr-x  2.0 unx     2323 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/bitcode.sh
+-rwxrwxr-x  2.0 unx      650 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/bitcode_copy.sh
+-rwxrwxr-x  2.0 unx     2024 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/collect_output.sh
+-rwxrwxr-x  2.0 unx      426 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/compile.sh
+-rwxrwxr-x  2.0 unx      582 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/install.sh
+-rwxrwxr-x  2.0 unx     1410 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/optimization.sh
+-rwxrwxr-x  2.0 unx     2626 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/run.sh
+-rwxrwxr-x  2.0 unx     2757 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/setup.sh
+-rwxrwxr-x  2.0 unx      267 b- defN 23-Apr-09 20:58 waterline/suites/SPEC2017/scripts/uninstall.sh
+-rw-rw-r--  2.0 unx     1057 b- defN 23-Apr-11 21:13 waterline-0.1.6.dist-info/LICENSE
+-rw-rw-r--  2.0 unx      246 b- defN 23-Apr-11 21:13 waterline-0.1.6.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Apr-11 21:13 waterline-0.1.6.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       10 b- defN 23-Apr-11 21:13 waterline-0.1.6.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     6388 b- defN 23-Apr-11 21:13 waterline-0.1.6.dist-info/RECORD
+66 files, 22293702 bytes uncompressed, 6205946 bytes compressed:  72.2%
```

## zipnote {}

```diff
@@ -177,23 +177,23 @@
 
 Filename: waterline/suites/SPEC2017/scripts/setup.sh
 Comment: 
 
 Filename: waterline/suites/SPEC2017/scripts/uninstall.sh
 Comment: 
 
-Filename: waterline-0.1.5.dist-info/LICENSE
+Filename: waterline-0.1.6.dist-info/LICENSE
 Comment: 
 
-Filename: waterline-0.1.5.dist-info/METADATA
+Filename: waterline-0.1.6.dist-info/METADATA
 Comment: 
 
-Filename: waterline-0.1.5.dist-info/WHEEL
+Filename: waterline-0.1.6.dist-info/WHEEL
 Comment: 
 
-Filename: waterline-0.1.5.dist-info/top_level.txt
+Filename: waterline-0.1.6.dist-info/top_level.txt
 Comment: 
 
-Filename: waterline-0.1.5.dist-info/RECORD
+Filename: waterline-0.1.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## waterline/__init__.py

```diff
@@ -1,6 +1,6 @@
 from __future__ import annotations
 from .workspace import Workspace
 from .suite import Suite, Benchmark
-from .run import RunConfiguration
+from .run import RunConfiguration, Runner
 
-__all__ = ["Workspace", "Suite", "Benchmark", "RunConfiguration"]
+__all__ = ["Workspace", "Suite", "Benchmark", "RunConfiguration", "Runner"]
```

## waterline/pipeline.py

```diff
@@ -1,27 +1,85 @@
 from pathlib import Path
 import shutil
+from .utils import shell
 from .suite import Benchmark
 from . import jobs
+from typing import Tuple, List
+
+
+def _should_run(input: Path, output: Path) -> bool:
+    """Given an input and an output, check if the input is newer than the output"""
+    return not output.exists() or output.stat().st_mtime < input.stat().st_mtime
+
+
+class Stage:
+    def run(self, input: Path, output: Path):
+        shutil.copy(input, output)
+
+
+class OptStage(Stage):
+    def __init__(self, passes: List[str] = []):
+        self.passes = passes
+
+    def run(self, input: Path, output: Path):
+        if _should_run(input, output):
+            shell(f'opt {input} -o {output} {" ".join(self.passes)}')
+            shell(f"llvm-dis {output}")
+
+
+class NopStage(Stage):
+    def run(self, input: Path, output: Path):
+        if _should_run(input, output) and input != output:
+            shutil.copy(input, output)
+
+
+class StageJob(jobs.Job):
+    def __init__(self, name: str, stage: Stage, input: Path, output: Path):
+        super().__init__(name)
+        self.stage = stage
+        self.in_bc = input
+        self.out_bc = output
+
+    def run(self):
+        self.stage.run(self.in_bc, self.out_bc)
+
+
+class LinkJob(jobs.Job):
+    def __init__(self, name: str, bench: Benchmark, input: Path, output: Path):
+        super().__init__(name)
+        self.bench = bench
+        self.input = input
+        self.output = output
+
+    def run(self):
+        if _should_run(self.input, self.output):
+            self.bench.link_bitcode(self.input, self.output)
 
 
 class Pipeline:
     def __init__(self, name: str):
         self.name = name
-        self.stages = []
+        self.stages: List[Tuple[Stage, str]] = []
 
-    def add_stage(self, stage, name=None):
+    def add_stage(self, stage: Stage, name=None):
         self.stages.append((stage, name))
 
-    def run(self, input_bc: Path, output_bc: Path, bench: Benchmark):
-        shutil.copy(input_bc, output_bc)
-        dir = output_bc.parent
-        for i, stage in enumerate(self.stages):
-            stage(output_bc)
-
-    def create_jobs(self, input_bc: Path, output_bc: Path, bench: Benchmark):
-        shutil.copy(input_bc, output_bc)
-
-        out = []
+    def jobs(self, input_bc: Path, output_bc: Path, bench: Benchmark) -> List[Stage]:
+        io = []
         for i, (stage, name) in enumerate(self.stages):
-            out.append(jobs.FunctionJob(f"stage {i+1}: {name}", stage, output_bc))
-        return out
+            input = input_bc.parent / f"{self.name}-stage{i - 1}.bc"
+            output = input_bc.parent / f"{self.name}-stage{i}.bc"
+            if i == 0:
+                input = input_bc
+            if i == len(self.stages) - 1:
+                output = output_bc
+            io.append((input, output))
+        for i, ((inp, outp), (stage, name)) in enumerate(zip(io, self.stages)):
+            yield StageJob(f"stage {i+1}: {name}", stage, inp, outp)
+
+        # Create a link job
+        yield LinkJob(
+            f"link {bench.suite.name}/{bench.name}",
+            bench,
+            output_bc,
+            bench.suite.bin / bench.name / self.name,
+        )
```

## waterline/run.py

```diff
@@ -1,13 +1,40 @@
 from dataclasses import dataclass
+from pathlib import Path
+import subprocess
+import time
+import waterline.utils
 
 
 class RunConfiguration:
-    args = []
-
-    def __init__(self, name, **kwargs):
+    def __init__(self, name, args=[], env={}, cwd=None):
         self.name = name
-        # this is gross but I don't really like it :)
-        self.__dict__.update(kwargs)
+        self.args = args
+        self.env = env
+        self.cwd = None
 
     def __repr__(self):
-        return str(self.__dict__)
+        return (
+            f"RunConfiguration({self.name}, args={self.args}, dir={self.working_dir})"
+        )
+
+
+class Runner:
+    name = "time"
+
+    def run(self, workspace, config: RunConfiguration, binary: Path):
+        """Run the benchmark, and return the metric. By default, it returns the execution time"""
+        assert binary.exists()
+
+        with waterline.utils.cd(config.cwd):
+            start = time.time()
+            proc = subprocess.Popen(
+                [binary, *config.args],
+                stdout=subprocess.DEVNULL,
+                # stderr=subprocess.DEVNULL,
+                env=config.env,
+                cwd=config.cwd,
+            )
+            res = proc.wait()
+            print(res)
+            end = time.time()
+        return end - start
```

## waterline/utils.py

```diff
@@ -1,19 +1,31 @@
 from pathlib import Path
 import subprocess
 import requests
+from contextlib import contextmanager
+import os
+
+
+@contextmanager
+def cd(newdir):
+    prevdir = os.getcwd()
+    os.chdir(os.path.expanduser(newdir))
+    try:
+        yield
+    finally:
+        os.chdir(prevdir)
 
 
 def run_command(args: list[str]):
-    print("running command", " ".join(map(str, args)))
-    output = subprocess.check_output(args)
+    proc = subprocess.Popen(args)
+    proc.wait()
 
 
-def shell(commnad: str):
-    run_command(["sh", "-c", commnad])
+def shell(cmd: str):
+    run_command(["sh", "-c", cmd])
 
 
 def git_clone(url: str, destination: Path):
     shell(f"git clone {url} {destination} --depth 1")
 
 
 def download(url: str, output: Path):
```

## waterline/workspace.py

```diff
@@ -1,32 +1,51 @@
 from pathlib import Path
 from .suite import Suite
-from .utils import *
-from .pipeline import *
-from typing import Tuple, List
+from .pipeline import Pipeline, NopStage
+from typing import Tuple, List, Dict, Optional
 from . import jobs
+import waterline.utils
+import subprocess
+from .run import Runner
 
 
 class Workspace:
     suites: List[Suite] = []
 
+    dir: Path
+    src_dir: Path
+    bin_dir: Path
+    ir_dir: Path
+
+    pipelines: Dict[str, Pipeline] = {}
+
     def __init__(self, dir: str):
         self.dir = Path(dir).absolute()
         # make sure the workspace directory exists.
         self.dir.mkdir(exist_ok=True)
 
         self.src_dir = self.dir / "src"
         self.src_dir.mkdir(exist_ok=True)
 
         self.bin_dir = self.dir / "bin"
         self.bin_dir.mkdir(exist_ok=True)
 
         self.ir_dir = self.dir / "ir"
         self.ir_dir.mkdir(exist_ok=True)
 
+        baseline = Pipeline("baseline")
+        baseline.add_stage(NopStage())
+        self.add_pipeline(baseline)
+
+    def benchmarks(self):
+        """iterate over each benchmark"""
+        for suite in self.suites:
+            for bench in suite.benchmarks:
+                yield bench
+
     def add_suite(self, suite, *args, **kwargs):
         s = suite(self)
         s.configure(*args, **kwargs)
         self.suites.append(s)
 
     def dump_benchmarks(self):
         for suite in self.suites:
@@ -34,100 +53,116 @@
             for benchmark in suite.benchmarks:
                 print(f"  {benchmark.name}")
 
     def extract_bitcode(self, input, output):
         self.shell("get-bc", "-o", output, input)
         self.shell("llvm-dis", output)
 
+    def add_pipeline(self, pipeline):
+        self.pipelines[pipeline.name] = pipeline
+
     def prepare(self):
         """Prepare this workspace to have bitcode pipeline applied."""
-        # a list of jobs to work on. This will be appended to and
-        # worked through before a pipeline can run.
-        runner = jobs.JobRunner()
-
-        # first, make sure all the benchmarks are acquired. We just do this by
-        # checking if the directory of the suite exists.
-        for suite in self.suites:
-            if not suite.src.exists():
-                runner.add(jobs.FunctionJob(f"acquire {suite.name}", suite.acquire))
-        runner.title = "acquire suites"
-        runner.run(parallel=True)
-
-        # second, compile the a.out files for each benchmark suite. If the a.out
-        # file doesn't exist, add it to the job list.
-        for suite in self.suites:
-            suite_bin = self.bin_dir / suite.name
-            suite_bin.mkdir(exist_ok=True)
-            for job in suite.compile_jobs():
-                runner.add(job)
-        runner.title = "compile baseline"
-        runner.run(parallel=True)
-
-        # Third, make sure input.bc exists in each ir/<suite>/<benchmark>/ folder
-        for suite in self.suites:
-            suite_ir = self.ir_dir / suite.name
-            suite_ir.mkdir(exist_ok=True)
-            suite_bin = self.bin_dir / suite.name
-            suite_bin.mkdir(exist_ok=True)
-            for benchmark in suite.benchmarks:
-                benchmark_ir_dir = suite_ir / benchmark.name
-                benchmark_ir_dir.mkdir(exist_ok=True)
 
-                input = suite_bin / benchmark.name / "a.out"
-                output = benchmark_ir_dir / "input.bc"
-                if not output.exists():
-                    runner.add(
-                        jobs.FunctionJob(
-                            f"extract {suite.name}/{benchmark.name}",
-                            self.extract_bitcode,
-                            input,
-                            output,
+        with waterline.utils.cd(self.dir):
+            # a list of jobs to work on. This will be appended to and
+            # worked through before a pipeline can run.
+            runner = jobs.JobRunner()
+
+            # first, make sure all the benchmarks are acquired. We just do this by
+            # checking if the directory of the suite exists.
+            for suite in self.suites:
+                if not suite.src.exists():
+                    runner.add(jobs.FunctionJob(f"acquire {suite.name}", suite.acquire))
+            runner.title = "acquire suites"
+            runner.run(parallel=True)
+
+            # second, compile the a.out files for each benchmark suite. If the a.out
+            # file doesn't exist, add it to the job list.
+            for suite in self.suites:
+                suite_bin = self.bin_dir / suite.name
+                suite_bin.mkdir(exist_ok=True)
+                for job in suite.compile_jobs():
+                    runner.add(job)
+            runner.title = "compile baseline"
+            runner.run(parallel=True)
+
+            # Third, make sure input.bc exists in each ir/<suite>/<benchmark>/ folder
+            for suite in self.suites:
+                suite_ir = self.ir_dir / suite.name
+                suite_ir.mkdir(exist_ok=True)
+                suite_bin = self.bin_dir / suite.name
+                suite_bin.mkdir(exist_ok=True)
+                for benchmark in suite.benchmarks:
+                    benchmark_ir_dir = suite_ir / benchmark.name
+                    benchmark_ir_dir.mkdir(exist_ok=True)
+
+                    input = suite_bin / benchmark.name / "a.out"
+                    output = benchmark_ir_dir / "input.bc"
+                    if not output.exists():
+                        runner.add(
+                            jobs.FunctionJob(
+                                f"extract {suite.name}/{benchmark.name}",
+                                self.extract_bitcode,
+                                input,
+                                output,
+                            )
                         )
-                    )
-        runner.title = "extract bitcode"
-        runner.run()
+            runner.title = "extract bitcode"
+            runner.run()
 
     def run_pipeline(self, pipeline: Pipeline):
         """Run a pipeline over the bitcodes of each benchmark in this workspace"""
         # Make sure everything is setup!
         self.prepare()
-        # Now run the pipeline on every benchmark's IR
-        runner = jobs.JobRunner(f"pipeline: {pipeline.name}")
 
-        for suite in self.suites:
-            suite_ir = self.ir_dir / suite.name
-            for benchmark in suite.benchmarks:
-                benchmark_ir_dir = suite_ir / benchmark.name
-                benchmark_ir_input = benchmark_ir_dir / "input.bc"
+        with waterline.utils.cd(self.dir):
+            # Now run the pipeline on every benchmark's IR
+            runner = jobs.JobRunner(f"pipeline: {pipeline.name}")
 
-                output = benchmark_ir_dir / f"{pipeline.name}.bc"
-                runner.add(*pipeline.create_jobs(benchmark_ir_input, output, benchmark))
-                benchmark_link_dest = (
-                    self.bin_dir / suite.name / benchmark.name / pipeline.name
-                )
+            for suite in self.suites:
+                suite_ir = self.ir_dir / suite.name
+                for benchmark in suite.benchmarks:
+                    benchmark_ir_dir = suite_ir / benchmark.name
+                    benchmark_ir_input = benchmark_ir_dir / "input.bc"
 
-                runner.add(
-                    jobs.FunctionJob(
-                        f"link {suite.name}/{benchmark.name}",
-                        benchmark.link_bitcode,
-                        output,
-                        benchmark_link_dest,
-                    )
-                )
+                    output = benchmark_ir_dir / f"{pipeline.name}.bc"
 
-        runner.run(parallel=False)
+                    for job in pipeline.jobs(benchmark_ir_input, output, benchmark):
+                        runner.add(job)
 
-    def run(self):
-        configs = []
-        for suite in self.suites:
-            for benchmark in suite.benchmarks:
-                for config in benchmark.run_configs():
-                    configs.append((benchmark, config))
+            runner.run(parallel=False)
+
+    def run(self, pipeline_names: Optional[List[str]] = None, runs=1, runner=Runner()):
+        if pipeline_names is None:
+            pipeline_names = self.pipelines.keys()
+
+        pipelines: List[Pipeline] = [self.pipelines[name] for name in pipeline_names]
 
-        print(configs)
+        for pl in pipelines:
+            self.run_pipeline(pl)
+
+        configs = []
+        for benchmark in self.benchmarks():
+            for config in benchmark.run_configs():
+                configs.append((benchmark, config))
+        print(f"benchmark,{','.join(map(lambda p: p.name, pipelines))}")
+        for benchmark, config in configs:
+            dir: Path = benchmark.suite.bin / benchmark.name
+            for i in range(runs):
+                times = []
+                for pipeline in pipelines:
+                    binary = dir / pipeline.name
+                    if not binary.exists():
+                        raise RuntimeError("binary does not exist!")
+                    time = runner.run(self, config, binary)
+                    times.append(time)
+                print(
+                    f"{benchmark.suite.name}.{config.name},{','.join(map(str, times))}"
+                )
 
     def shell(self, *args):
         # print('running: ', *args)
         with open(self.dir / "output.txt", "a+") as out:
             out.write("\n\n")
             out.write("$ " + " ".join(map(str, args)) + "\n")
             out.flush()
```

## waterline/suites/gap.py

```diff
@@ -1,8 +1,8 @@
-from waterline import Suite, Benchmark, Workspace
+from waterline import Suite, Benchmark, Workspace, RunConfiguration
 from waterline.utils import run_command
 from pathlib import Path
 
 
 class GAPBenchmark(Benchmark):
     def compile(self, output: Path):
         source_file = self.suite.src / "src" / (self.name + ".cc")
@@ -24,26 +24,29 @@
             "-fopenmp",
             "-std=c++11",
             "-Wall",
             "-o",
             output,
         )
 
+    def run_configs(self):
+        yield RunConfiguration(self.name, args=["-g", "14"])
+
 
 class GAP(Suite):
     name = "GAP"
 
     def configure(self, enable_openmp: bool = True):
         self.enable_openmp = enable_openmp
 
         self.add_benchmark(GAPBenchmark, "bc")
         self.add_benchmark(GAPBenchmark, "bfs")
         self.add_benchmark(GAPBenchmark, "cc")
         self.add_benchmark(GAPBenchmark, "cc_sv")
-        self.add_benchmark(GAPBenchmark, "converter")
+        # self.add_benchmark(GAPBenchmark, "converter")
         self.add_benchmark(GAPBenchmark, "pr")
         self.add_benchmark(GAPBenchmark, "pr_spmv")
         self.add_benchmark(GAPBenchmark, "sssp")
         self.add_benchmark(GAPBenchmark, "tc")
 
     def acquire(self):
         self.workspace.shell(
```

## waterline/suites/mibench.py

```diff
@@ -1,24 +1,27 @@
-from waterline import Suite, Benchmark, Workspace
+from waterline import Suite, Benchmark, Workspace, RunConfiguration
 from waterline.utils import run_command
 from pathlib import Path
 import shutil
+from typing import List
 
 
 class MiBenchSimple(Benchmark):
     linker = "clang"
     linker_flags = []
 
     compiler = "gclang"
     source_files = []
     compile_flags = []
 
-    def __init__(self, suite, name, source, **kwargs):
+    runs: List[RunConfiguration] = []
+
+    def __init__(self, suite, name, source: Path, **kwargs):
         super().__init__(suite, name)
-        self.source = self.suite.src / source
+        self.source: Path = self.suite.src / source
         self.__dict__.update(kwargs)
 
     def compile(self, output: Path):
         print(f"compile {self.name}")
         self.shell(
             "sh",
             "-c",
@@ -31,14 +34,19 @@
             "-lm",
             *self.linker_flags,
             object,
             "-o",
             output,
         )
 
+    def run_configs(self):
+        for run in self.runs:
+            run.cwd = self.source
+            yield run
+
 
 class MiBenchMakefile(Benchmark):
     linker = "clang"
     linker_flags = []
 
     def __init__(self, suite, name, source, bin, **kwargs):
         super().__init__(suite, name)
@@ -62,46 +70,14 @@
             *self.linker_flags,
             object,
             "-o",
             output,
         )
 
 
-mibench_benchmarks = [
-    # automotive/basicmath
-    ("basicmath",),  # has patch
-    # automotive/bincount
-    ("bitcnts",),  # has patch
-    # automotive/susan
-    ("susan_s",),  # has patch
-    ("susan_e",),  # has patch
-    ("susan_c",),  # has patch
-    # consumer/jpeg
-    ("djpeg",),  # has patch
-    ("cjpeg",),  # has patch
-    # telecom/FFT
-    ("fft",),  # has patch
-    ("fft_inv",),  # has patch
-    # telecom/CRC32
-    # security/blowfish
-    ("bf_d",),
-    ("bf_e",),
-    # office/stringsearch
-    ("search",),
-    ("rawdaudio",),
-    ("rawcaudio",),
-    ("untoast",),
-    ("toast",),
-    # working on:
-    # done:
-    ("sha",),  # security/sha
-    ("crc",),  # telecomm/CRC32
-    ("qsort",),  # automotive/qsort
-]
-
 toast_sources = [
     "src/add.c",
     "src/code.c",
     "src/debug.c",
     "src/decode.c",
     "src/long_term.c",
     "src/lpc.c",
@@ -175,19 +151,20 @@
 ]
 
 
 class MiBench(Suite):
     name = "MiBench"
 
     def configure(self):
+        size = "large"
         # AUTOMOTIVE
         self.simple(
             "automotive/basicmath",
             "basicmath",
-            source_files=["basicmath_large.c", "rad2deg.c", "cubic.c", "isqrt.c"],
+            source_files=[f"basicmath_{size}.c", "rad2deg.c", "cubic.c", "isqrt.c"],
         )
 
         self.simple(
             "automotive/bitcount",
             "bitcnts",
             source_files=[
                 "bitcnt_1.c",
@@ -202,45 +179,63 @@
         )
 
         self.simple(
             "automotive/qsort",
             "qsort",
             linker_flags=["-lm"],
             compile_flags=["-lm"],
-            source_files=["qsort_large.c"],
+            source_files=[f"qsort_{size}.c"],
+            runs=[RunConfiguration("qsort", args=[f"input_{size}.dat"])],
+        )
+        self.simple(
+            "automotive/susan",
+            "susan",
+            source_files=["susan.c"],
+            runs=[
+                RunConfiguration(
+                    "susan_s",
+                    args=[f"input_{size}.pgm", f"output_{size}.smoothing.pgm", "-s"],
+                ),
+                RunConfiguration(
+                    "susan_e",
+                    args=[f"input_{size}.pgm", f"output_{size}.edges.pgm", "-e"],
+                ),
+                RunConfiguration(
+                    "susan_c",
+                    args=[f"input_{size}.pgm", f"output_{size}.corners.pgm", "-c"],
+                ),
+            ],
         )
-        self.simple("automotive/susan", "susan", source_files=["susan.c"])
-
         # CONSUMER
         # TODO: jpeg
         # TODO: lame
         # TODO: mad
         # TODO: tiff2bw
         # TODO: tiff2rgba
         # TODO: tiff-data
         # TODO: tiffdither
         # TODO: tiffmedian
         # TODO: tiff-v3.5.4
         # TODO: typeset
-        self.simple(
-            "consumer/jpeg/jpeg-6a",
-            "cjpeg",
-            source_files=[
-                *jpeg_core,
-                # sources for the app
-                "cjpeg.c",
-                "rdppm.c",
-                "rdgif.c",
-                "rdtarga.c",
-                "rdrle.c",
-                "rdbmp.c",
-                "rdswitch.c",
-                "cdjpeg.c",
-            ],
-        )
+        # self.simple(
+        #     "consumer/jpeg/jpeg-6a",
+        #     "cjpeg",
+        #     source_files=[
+        #         *jpeg_core,
+        #         # sources for the app
+        #         "cjpeg.c",
+        #         "rdppm.c",
+        #         "rdgif.c",
+        #         "rdtarga.c",
+        #         "rdrle.c",
+        #         "rdbmp.c",
+        #         "rdswitch.c",
+        #         "cdjpeg.c",
+        #     ],
+        # )
         # self.simple(
         #     "consumer/jpeg/jpeg-6a",
         #     "djpeg",
         #     source_files=[
         #         *jpeg_core,
         #         # sources for the app
         #         "djpeg.c",
@@ -342,12 +337,14 @@
         self.add_benchmark(MiBenchMakefile, name, dir, outbin, **kwargs)
 
     def acquire(self):
         print("get mibench")
         self.workspace.shell(
             "git",
             "clone",
-            "https://github.com/embecosm/mibench.git",
+            # Clone from my version of mibench, as it has patches to make the benchmarks run longer.
+            # It also has patches to fix various bugs in this suite.
+            "https://github.com/nickwanninger/mibench.git",
             self.src,
             "--depth",
             "1",
         )
```

## waterline/suites/nas.py

```diff
@@ -1,8 +1,8 @@
-from waterline import Suite, Benchmark, Workspace
+from waterline import Suite, Benchmark, Workspace, RunConfiguration
 from waterline.utils import run_command
 from pathlib import Path
 import waterline.utils
 import shutil
 from typing import Tuple
```

## waterline/suites/polybench.py

```diff
@@ -54,15 +54,15 @@
         super().__init__(suite, name)
         self.source = source
 
     def compile(self, output: Path):
         source_file = self.suite.src / self.source
         self.shell(
             "gclang",
-            "-DLARGE_DATASET",
+            f"-D{self.suite.size}_DATASET",
             "-DPOLYBENCH_TIME",
             *baseline_flags,
             f"-I{self.suite.src}/utilities",
             f"-I{source_file.parent}",
             self.suite.src / "utilities" / "polybench.c",
             source_file,
             "-lm",
@@ -74,23 +74,21 @@
     def link(self, object: Path, output: Path):
         self.shell("clang", object, "-lm", "-o", output)
 
 
 class PolyBench(Suite):
     name = "PolyBench"
 
-    def configure(self):
+    def configure(self, size="LARGE"):
+        self.size = size
         for source, name in polybench_benchmarks:
             self.add_benchmark(PolyBenchBenchmark, name, source)
 
     def acquire(self):
         tarball = self.src.parent / "polybench-3.1.tar.gz"
         waterline.utils.download(
             "http://web.cse.ohio-state.edu/~pouchet.2/software/polybench/download/polybench-3.1.tar.gz",
             tarball,
         )
 
         shutil.unpack_archive(tarball, self.src.parent, "gztar")
         shutil.move(self.src.parent / "polybench-3.1", self.src)
-        # waterline.utils.shell(f'tar xf {out} -C {path.parent}')
-
-        # shutil.(out / 'polybench-3.1', path)
```

## waterline/suites/SPEC2017/scripts/compile.sh

```diff
@@ -9,9 +9,9 @@
 
 if [ ! -d "${BUILD_DIR}/SPEC2017" ]; then
 	echo "Error: Please run \"./scripts/install.sh\"  first to install SPEC2017."
 	exit
 fi
 cd SPEC2017
 source shrc
-runcpu --loose --size test --tune peak -a setup --config gclang $1
+runcpu -D --loose --size test --tune peak -a setup --config gclang $1
 echo "DONE installing SPEC2017 at \"${BUILD_DIR}/SPEC2017\""
```

## waterline/suites/SPEC2017/scripts/install.sh

```diff
@@ -3,15 +3,14 @@
 PWD_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )/.." ;
 
 if [ -d "${PWD_PATH}/benchmarks/" ]; then
   rm -rf ${PWD_PATH}/benchmarks ;
 fi
 
 cd SPEC2017 ;
-pwd
 printf 'yes' | ./install.sh ;
 cp ${PWD_PATH}/patches/gclang.cfg ${PWD_PATH}/SPEC2017/config/ ;
 cp ${PWD_PATH}/patches/pure_c_cpp_speed.bset ${PWD_PATH}/SPEC2017/benchspec/CPU/ ;
 cp ${PWD_PATH}/patches/pure_c_cpp_rate.bset ${PWD_PATH}/SPEC2017/benchspec/CPU/ ;
 
 cd ${PWD_PATH}/SPEC2017 ;
 tar xf ${PWD_PATH}/patches/parest_r_patch.tar.xz ;
```

## Comparing `waterline-0.1.5.dist-info/LICENSE` & `waterline-0.1.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `waterline-0.1.5.dist-info/RECORD` & `waterline-0.1.6.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-waterline/__init__.py,sha256=QcfO8-lVU4fV3M9xhvPDnDFZzmR8QCGVOmIVLqZmP-k,205
+waterline/__init__.py,sha256=4UwrTIE53TLXgBtiS8bm9QI3FH75W1AZM4e9XcpCRfo,223
 waterline/jobs.py,sha256=0yYmMT-BK_TzrGRzBbZBmLIjwxxHddCSPHVKn8ZUjXU,1805
-waterline/pipeline.py,sha256=cXqvwewdluB8cOMe-wdOnYPH7n2FDtyYsA3QElnGZ1c,792
-waterline/run.py,sha256=h-Qhi40W-6q1FxQ9w5LtMOaBRjuS8WKz0HSk9K-OOaM,290
+waterline/pipeline.py,sha256=A-9hqHRtpKrIGo2iEFfv9Cw0CdNF6NqihuAXhHNM-RU,2609
+waterline/run.py,sha256=1Wjh5cd9DqHqF_megqYjYbeoMjwS3w0XpIMV8_vMv70,1096
 waterline/suite.py,sha256=HAfny2WJoxOUTcfcHI3MwN_PXiFL5MCOED39RjpA5C8,3382
 waterline/suites.py,sha256=cBJ3KU1Mzzq5LkuCisuvCwcnU9xjPontHEFYYxCtsz0,7123
-waterline/utils.py,sha256=9qPgNEzXr4fDVOT6dHkAfUErsld4l63GBclXZu0Vdr8,486
-waterline/workspace.py,sha256=vLD_XxK5NfnCDrfOmdpYvzsjgnnpL25mZq2jYBf913w,4958
+waterline/utils.py,sha256=G7a0Bqt8ibml4o7airQ5vL6fkdtFWpnZ8-AocHlk7mA,641
+waterline/workspace.py,sha256=KRIwQEqpmCcHxJgcPWZ_bYKm_1HpMFH7igGUxMJg1UA,6323
 waterline/suites/__init__.py,sha256=ETK4N7n6M9dzDASROaNAthTPdUl97qw2lbW_q5sIgrQ,135
-waterline/suites/gap.py,sha256=YEj9KlCdlULIXomJsFirFdlzA6LIEtOD3MJsNwhvvuM,1484
-waterline/suites/mibench.py,sha256=QGpkqfLHjM_lOkZGA4p5SGm01N-P2km4CvhuLcDfs9o,8637
-waterline/suites/nas.py,sha256=TqXs9EmRU63scD1lQ_aVspzQhVyMmbTLDt7TyshtGFY,2528
-waterline/suites/polybench.py,sha256=9Ji0e01t6uaMTlXyqu4p0S6TyYfLNigPkokuh9BMDY8,3478
+waterline/suites/gap.py,sha256=XbLPn0mMb0JxzH1yVT3J98Y-cCJa_06wu55ABmL1_nY,1593
+waterline/suites/mibench.py,sha256=zX0u-rcmYbtEww2n01ElUEICqn-bl-hiWd_M8w0ac7I,9004
+waterline/suites/nas.py,sha256=WLqeP3CPqUFhZt5ECEpjDGYJA61MOSK2-cn7Vx1suzU,2546
+waterline/suites/polybench.py,sha256=sHG-0twmJlp5f3_zi5A_0oekdVR_IuRvF7PDDjM1HLM,3416
 waterline/suites/spec2017.py,sha256=14AcdlXKvtdwbL0RAQ0_LmCdONNJr1e7W4rPnBMi9pc,2079
 waterline/suites/SPEC2017/Makefile,sha256=kHw3DC6XA1_KnWp0hcoaAhRnsIVugk4J04ZBM2-p7pA,1297
 waterline/suites/SPEC2017/README,sha256=EMM5XiYQ_Dy36WvBw-fIS7bnYpStx2tQms5igraom88,2959
 waterline/suites/SPEC2017/test.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 waterline/suites/SPEC2017/benchmarks/omnetpp_s/omnetpp_s,sha256=NtLDubIsdpLwv-Cn3ey-D7SE0u2SxejhxJPrSSbPYTE,4511744
 waterline/suites/SPEC2017/benchmarks/omnetpp_s/omnetpp_s.bc,sha256=3cyAGbCI5989qQf2XNdTcb5_HePciJhf05lZYMMLMsU,5067012
 waterline/suites/SPEC2017/benchmarks/xalancbmk_s/xalancbmk_s,sha256=3RXpLkRrIsXlYEwoeGZUAv3x-W7YPA-42wMDoFoQeII,12596976
@@ -49,18 +49,18 @@
 waterline/suites/SPEC2017/plot/barplot.sh,sha256=peOD5qKLi38P1Wt8kU_KUTeTddR5Wq9Sk3bpImb-_PY,71
 waterline/suites/SPEC2017/plot/barplot.txt,sha256=GpMLIiqDuxfU4WLKG-nVUcGnVGTTbpatmWpB6hsNgL4,21
 waterline/suites/SPEC2017/plot/virtualEnv.sh,sha256=Bh6t3dmxV_gNeVX-iFN7Y3fplTkXPm7T9wAgNxuUVRk,393
 waterline/suites/SPEC2017/scripts/binary.sh,sha256=Xx98-J4RjA7_9w6GvP9ARUZdVJ_cNEDkIXhhJUk5jNQ,1516
 waterline/suites/SPEC2017/scripts/bitcode.sh,sha256=0rbV7Nwf68cGb8x0lxAMn2kWIjnrTQr-1dVNWsn_Y5s,2323
 waterline/suites/SPEC2017/scripts/bitcode_copy.sh,sha256=mZjUkZwBnfU-afyw0BVdsBZfGYO30Vj1oeWgOg6kgyA,650
 waterline/suites/SPEC2017/scripts/collect_output.sh,sha256=ggAiKroVgHC5rq26J3eVa0fW4FFaeiLsG6BUfWZ2weY,2024
-waterline/suites/SPEC2017/scripts/compile.sh,sha256=P4Bkq6Pnr7DBAcl1f39aubWViB1PDrdzGS9su8LpLQg,423
-waterline/suites/SPEC2017/scripts/install.sh,sha256=boL4dKlTY3JwBNfvnBZvVfyre-TkA4sNybBlrI85_vc,586
+waterline/suites/SPEC2017/scripts/compile.sh,sha256=9VpgIqHmLgfKjjibS0i4xFkNh6dgEgrWqKyyK-MiceI,426
+waterline/suites/SPEC2017/scripts/install.sh,sha256=3fQeOYVldVYHHfh6WgQLJeKot3J0ijMUQ7nz8YUE1Vw,582
 waterline/suites/SPEC2017/scripts/optimization.sh,sha256=6qHL1B3J-M5M80RJp2E7W9FB_jmNS6grcRYKOgOo5jk,1410
 waterline/suites/SPEC2017/scripts/run.sh,sha256=zWKgeZ_pteRG3Quks7e8KKbkQbz38CWHBBWTVUzOR68,2626
 waterline/suites/SPEC2017/scripts/setup.sh,sha256=FnVDLvabQm6CVwxl0y0rA5g6V5j5VXLm2ZZVIO2xZI8,2757
 waterline/suites/SPEC2017/scripts/uninstall.sh,sha256=0szAcj1MraRZ0QjGdL6aLq8QkxKdFm9qoTAaKdhOeUY,267
-waterline-0.1.5.dist-info/LICENSE,sha256=UveJQplGBXBAOAqKBm_4SQ2XE2VBHPRJDIuVa9829uc,1057
-waterline-0.1.5.dist-info/METADATA,sha256=6JsTlUAbnfI1PGr0axY7GjrujOsCqaDaPkNHTUI8teY,246
-waterline-0.1.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-waterline-0.1.5.dist-info/top_level.txt,sha256=ptFfPeDDWWfu4ZroUwKjceRrASyf4j3zXvL1UxLuLTk,10
-waterline-0.1.5.dist-info/RECORD,,
+waterline-0.1.6.dist-info/LICENSE,sha256=UveJQplGBXBAOAqKBm_4SQ2XE2VBHPRJDIuVa9829uc,1057
+waterline-0.1.6.dist-info/METADATA,sha256=upsltlAyPFUcI0Lfd1898wONgsqkt_fsqUCgdccphxY,246
+waterline-0.1.6.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+waterline-0.1.6.dist-info/top_level.txt,sha256=ptFfPeDDWWfu4ZroUwKjceRrASyf4j3zXvL1UxLuLTk,10
+waterline-0.1.6.dist-info/RECORD,,
```


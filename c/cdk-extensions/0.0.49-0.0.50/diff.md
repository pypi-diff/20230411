# Comparing `tmp/cdk-extensions-0.0.49.tar.gz` & `tmp/cdk-extensions-0.0.50.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "cdk-extensions-0.0.49.tar", last modified: Fri Mar 31 19:47:12 2023, max compression
+gzip compressed data, was "cdk-extensions-0.0.50.tar", last modified: Tue Apr 11 13:58:45 2023, max compression
```

## Comparing `cdk-extensions-0.0.49.tar` & `cdk-extensions-0.0.50.tar`

### file list

```diff
@@ -1,63 +1,65 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/
--rw-r--r--   0 runner    (1001) docker     (123)    11358 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)       23 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     4632 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     3711 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      234 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     2509 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.980309 cdk-extensions-0.0.49/src/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.984309 cdk-extensions-0.0.49/src/cdk_extensions/
--rw-r--r--   0 runner    (1001) docker     (123)     4781 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.984309 cdk-extensions-0.0.49/src/cdk_extensions/_jsii/
--rw-r--r--   0 runner    (1001) docker     (123)      397 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/_jsii/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.984309 cdk-extensions-0.0.49/src/cdk_extensions/_jsii/bin/
--rw-r--r--   0 runner    (1001) docker     (123)      292 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/_jsii/bin/init-aws.sh
--rw-r--r--   0 runner    (1001) docker     (123)  1379515 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/_jsii/cdk-extensions@0.0.49.jsii.tgz
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.984309 cdk-extensions-0.0.49/src/cdk_extensions/aps/
--rw-r--r--   0 runner    (1001) docker     (123)   277230 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/aps/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/asserts/
--rw-r--r--   0 runner    (1001) docker     (123)     3167 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/asserts/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/athena/
--rw-r--r--   0 runner    (1001) docker     (123)    19844 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/athena/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/core/
--rw-r--r--   0 runner    (1001) docker     (123)    20196 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/core/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/ec2/
--rw-r--r--   0 runner    (1001) docker     (123)   366258 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/ec2/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/ec2_patterns/
--rw-r--r--   0 runner    (1001) docker     (123)   110588 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/ec2_patterns/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.988309 cdk-extensions-0.0.49/src/cdk_extensions/eks_patterns/
--rw-r--r--   0 runner    (1001) docker     (123)    95667 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/eks_patterns/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/glue/
--rw-r--r--   0 runner    (1001) docker     (123)   507583 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/glue/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/glue_tables/
--rw-r--r--   0 runner    (1001) docker     (123)   129986 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/glue_tables/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/k8s_aws/
--rw-r--r--   0 runner    (1001) docker     (123)   692448 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/k8s_aws/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/k8s_fargate/
--rw-r--r--   0 runner    (1001) docker     (123)    25868 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/k8s_fargate/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/kinesis_firehose/
--rw-r--r--   0 runner    (1001) docker     (123)   271406 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/kinesis_firehose/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/lambda_/
--rw-r--r--   0 runner    (1001) docker     (123)    22981 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/lambda_/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/ram/
--rw-r--r--   0 runner    (1001) docker     (123)    42370 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/ram/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/ram_resources/
--rw-r--r--   0 runner    (1001) docker     (123)     4420 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/ram_resources/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.992309 cdk-extensions-0.0.49/src/cdk_extensions/rds/
--rw-r--r--   0 runner    (1001) docker     (123)    18474 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/rds/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/src/cdk_extensions/route53/
--rw-r--r--   0 runner    (1001) docker     (123)    11199 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/route53/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/src/cdk_extensions/s3_buckets/
--rw-r--r--   0 runner    (1001) docker     (123)   208106 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/s3_buckets/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/src/cdk_extensions/sso/
--rw-r--r--   0 runner    (1001) docker     (123)   130481 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/sso/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.996310 cdk-extensions-0.0.49/src/cdk_extensions/stacks/
--rw-r--r--   0 runner    (1001) docker     (123)    53437 2023-03-31 19:46:57.000000 cdk-extensions-0.0.49/src/cdk_extensions/stacks/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-31 19:47:11.984309 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     4632 2023-03-31 19:47:11.000000 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     1243 2023-03-31 19:47:11.000000 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-31 19:47:11.000000 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      111 2023-03-31 19:47:11.000000 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       15 2023-03-31 19:47:11.000000 cdk-extensions-0.0.49/src/cdk_extensions.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/
+-rw-r--r--   0 runner    (1001) docker     (123)    11358 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)       23 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     4632 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     3711 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      234 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.113065 cdk-extensions-0.0.50/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.117065 cdk-extensions-0.0.50/src/cdk_extensions/
+-rw-r--r--   0 runner    (1001) docker     (123)     4832 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions/_jsii/
+-rw-r--r--   0 runner    (1001) docker     (123)      397 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/_jsii/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions/_jsii/bin/
+-rw-r--r--   0 runner    (1001) docker     (123)      292 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/_jsii/bin/init-aws.sh
+-rw-r--r--   0 runner    (1001) docker     (123)  1483078 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/_jsii/cdk-extensions@0.0.50.jsii.tgz
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions/aps/
+-rw-r--r--   0 runner    (1001) docker     (123)   277230 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/aps/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions/asserts/
+-rw-r--r--   0 runner    (1001) docker     (123)     3167 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/asserts/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions/athena/
+-rw-r--r--   0 runner    (1001) docker     (123)    19844 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/athena/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/core/
+-rw-r--r--   0 runner    (1001) docker     (123)    20196 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/core/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/ec2/
+-rw-r--r--   0 runner    (1001) docker     (123)   621775 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/ec2/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/ec2_patterns/
+-rw-r--r--   0 runner    (1001) docker     (123)   138026 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/ec2_patterns/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/eks_patterns/
+-rw-r--r--   0 runner    (1001) docker     (123)    95667 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/eks_patterns/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/glue/
+-rw-r--r--   0 runner    (1001) docker     (123)   507583 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/glue/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/glue_tables/
+-rw-r--r--   0 runner    (1001) docker     (123)   129986 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/glue_tables/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/k8s_aws/
+-rw-r--r--   0 runner    (1001) docker     (123)   692448 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/k8s_aws/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/k8s_fargate/
+-rw-r--r--   0 runner    (1001) docker     (123)    25868 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/k8s_fargate/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.125065 cdk-extensions-0.0.50/src/cdk_extensions/kinesis_firehose/
+-rw-r--r--   0 runner    (1001) docker     (123)   271406 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/kinesis_firehose/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/lambda_/
+-rw-r--r--   0 runner    (1001) docker     (123)    22981 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/lambda_/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/networkmanager/
+-rw-r--r--   0 runner    (1001) docker     (123)    40858 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/networkmanager/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/ram/
+-rw-r--r--   0 runner    (1001) docker     (123)    42370 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/ram/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/ram_resources/
+-rw-r--r--   0 runner    (1001) docker     (123)     5162 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/ram_resources/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/rds/
+-rw-r--r--   0 runner    (1001) docker     (123)    18474 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/rds/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/route53/
+-rw-r--r--   0 runner    (1001) docker     (123)    11199 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/route53/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/s3_buckets/
+-rw-r--r--   0 runner    (1001) docker     (123)   208106 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/s3_buckets/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/sso/
+-rw-r--r--   0 runner    (1001) docker     (123)   130481 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/sso/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.129065 cdk-extensions-0.0.50/src/cdk_extensions/stacks/
+-rw-r--r--   0 runner    (1001) docker     (123)    53437 2023-04-11 13:58:30.000000 cdk-extensions-0.0.50/src/cdk_extensions/stacks/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-11 13:58:45.121065 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     4632 2023-04-11 13:58:45.000000 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-04-11 13:58:45.000000 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-11 13:58:45.000000 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      111 2023-04-11 13:58:45.000000 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       15 2023-04-11 13:58:45.000000 cdk-extensions-0.0.50/src/cdk_extensions.egg-info/top_level.txt
```

### Comparing `cdk-extensions-0.0.49/LICENSE` & `cdk-extensions-0.0.50/LICENSE`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/PKG-INFO` & `cdk-extensions-0.0.50/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cdk-extensions
-Version: 0.0.49
+Version: 0.0.50
 Summary: cdk-extensions
 Home-page: https://github.com/vibe-io/cdk-extensions.git
 Author: Kevin Lucas<kevinluc08@gmail.com>
 License: Apache-2.0
 Project-URL: Source, https://github.com/vibe-io/cdk-extensions.git
 Classifier: Intended Audience :: Developers
 Classifier: Operating System :: OS Independent
```

### Comparing `cdk-extensions-0.0.49/README.md` & `cdk-extensions-0.0.50/README.md`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/setup.py` & `cdk-extensions-0.0.50/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import json
 import setuptools
 
 kwargs = json.loads(
     """
 {
     "name": "cdk-extensions",
-    "version": "0.0.49",
+    "version": "0.0.50",
     "description": "cdk-extensions",
     "license": "Apache-2.0",
     "url": "https://github.com/vibe-io/cdk-extensions.git",
     "long_description_content_type": "text/markdown",
     "author": "Kevin Lucas<kevinluc08@gmail.com>",
     "bdist_wheel": {
         "universal": true
@@ -32,25 +32,26 @@
         "cdk_extensions.eks_patterns",
         "cdk_extensions.glue",
         "cdk_extensions.glue_tables",
         "cdk_extensions.k8s_aws",
         "cdk_extensions.k8s_fargate",
         "cdk_extensions.kinesis_firehose",
         "cdk_extensions.lambda_",
+        "cdk_extensions.networkmanager",
         "cdk_extensions.ram",
         "cdk_extensions.ram_resources",
         "cdk_extensions.rds",
         "cdk_extensions.route53",
         "cdk_extensions.s3_buckets",
         "cdk_extensions.sso",
         "cdk_extensions.stacks"
     ],
     "package_data": {
         "cdk_extensions._jsii": [
-            "cdk-extensions@0.0.49.jsii.tgz"
+            "cdk-extensions@0.0.50.jsii.tgz"
         ],
         "cdk_extensions": [
             "py.typed"
         ]
     },
     "python_requires": "~=3.7",
     "install_requires": [
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -115,14 +115,15 @@
     "eks_patterns",
     "glue",
     "glue_tables",
     "k8s_aws",
     "k8s_fargate",
     "kinesis_firehose",
     "lambda_",
+    "networkmanager",
     "ram",
     "ram_resources",
     "rds",
     "route53",
     "s3_buckets",
     "sso",
     "stacks",
@@ -140,14 +141,15 @@
 from . import eks_patterns
 from . import glue
 from . import glue_tables
 from . import k8s_aws
 from . import k8s_fargate
 from . import kinesis_firehose
 from . import lambda_
+from . import networkmanager
 from . import ram
 from . import ram_resources
 from . import rds
 from . import route53
 from . import s3_buckets
 from . import sso
 from . import stacks
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/aps/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/aps/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/asserts/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/asserts/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/athena/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/athena/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/core/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/core/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/ec2/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/glue/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,106 +1,47 @@
 '''
-# Vibe-io CDK-Extensions EC2 Construct Library
+# AWS Glue Library
 
-The @cdk-extensions/ec2 package contains advanced constructs and patterns for
-setting up networking and instances. The constructs presented here are intended
-to be replacements for equivalent AWS constructs in the CDK EC2 module, but with
-additional features included.
-
-[AWS CDK EC2 API Reference](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2-readme.html)
-
-To import and use this module within your CDK project:
+The `@cdk-extensions/glue` module contains configurations for AWS Glue.
 
 ```python
-import * as ec2 from 'cdk-extensions/ec2';
+import * as glue from 'cdk-extensions/glue';
 ```
 
-## VPC Flow Logs
+## Objective
 
-VPC Flow Logs is a feature that enables you to capture information about the IP
-traffic going to and from network interfaces in your VPC. Flow log data can be
-published to Amazon CloudWatch Logs and Amazon S3. After you've created a flow
-log, you can retrieve and view its data in the chosen destination.
-[AWS VPC Flow Logs User Guide](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)
-[AWS VPC Flow Logs CFN Documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html)
-
-For this construct, by default a S3 bucket will be created as the Flow Logs
-destination. It will also include a Glue table with the same schema as the
-configured FlowLogFormat, as well as prepared Athena queries.
+The Glue module is used to consolidate data from multiple different sources into a single location to simplify analysis and review. It provides the ability to discover and organize data from a wide variety of sources; tranform, prepare and clean that data for analysis; and the creation of data pipelines to deliver the prepared data for storage and analysis and monitor the process.
 
-### Usage
+The AWS Glue Catalog is used to orchestrate the operation based on using metadata stored in its tables which define the sources and targets it should operate on. Crawlers are added to the Glue Catalog which allow access to the data sources and target, providing information on data changes which need to be acted upon. Jobs are then configured to perform the transformation of that data for delivery to its target location. Scheduling of these jobs can then be configured to either run at specific times, based off of triggering events or performed manually.
 
-You can create a flow log like this:
-
-```python
-new ec2.FlowLog(this, 'FlowLog', {
-  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc)
-})
-```
+## Important Constructs
 
-You can also add multiple flow logs with different destinations.
+### Catalog
 
-```python
-const bucket = new s3.Bucket(this, 'MyCustomBucket');
+The Catalog construct defines the Glue Catalog that will hold metadata and act as the source for orchestrating all Glue Jobs
 
-new ec2.FlowLog(this, 'FlowLog', {
-  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
-  destination: ec2.FlowLogDestination.toS3(bucket)
-});
-
-new ec2.FlowLog(this, 'FlowLogCloudWatch', {
-  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
-  trafficType: ec2.FlowLogTrafficType.REJECT,
-  maxAggregationInterval: FlowLogMaxAggregationInterval.ONE_MINUTE,
-});
-```
+### Table
 
-### Additional Features
+The Table construct holds the table definition within the Glue Catalog which contains the necessary metadata for performing Glue jobs
 
-The main advantage that this module has over the official AWS CDK module is that
-you can specific the log format at the time of FlowLog creation like this:
+### Crawler
 
-```python
-new ec2.FlowLog(this, 'FlowLog', {
-  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
-  format: ec2.FlowLogFormat.V3,
-})
-```
+The Crawler construct contains the information defining a source of data, including the necessary information or credentials to reach and access it.
 
-There are several formats that are included as part of the module, and each one
-will define the fields included in the flow log records. Each one acts similarly
-to a log level (Info, Debug, etc), with each level providing increasingly more
-detail in the logs (like region or AZ details, or AWS service details).
-
-The formats and descriptions are as follows:
-
-* ec2.FlowLogFormat.V2: The default format if none is specified. Includes common
-  basic details like log status, account ID, source and
-  destination.
-* ec2.FlowLogFormat.V3: Includes all fields from V2, as well as information on
-  the specific AWS resources associated with the traffic
-  like Vpc, subnet and instance IDs.
-* ec2.FlowLogFormat.V4: Includes all fields from V3, as well as information about
-  the region and AZ associated with the traffic.
-* ec2.FlowLogFormat.V5: Includes all fields from V4, as well as information that
-  provides visibility on packet routing.
+### Jobs
 
-### Caveats
+The Jobs construct contains the instructions to perform transformation and delivery of the crawled data.
 
-With the offical AWS CDK VPC construct, you can normally add a Flow Log to a VPC
-by using the addFlowLog() method like this:
+### Trigger
 
-```python
-const vpc = new ec2.Vpc(this, 'Vpc');
+The Trigger construct defines what triggers should be used to run a particular job.
 
-vpc.addFlowLog('FlowLog');
-```
+### Workflow
 
-However, this will not include the additional FlowLogFormat functionality
-provided by the FlowLog construct in this module.
+The Workflow construct contains a collection of Triggers and Jobs to link together a set of processes into a complete data pipeline.
 '''
 import abc
 import builtins
 import datetime
 import enum
 import typing
 
@@ -109,155 +50,797 @@
 import typing_extensions
 
 from typeguard import check_type
 
 from .._jsii import *
 
 import aws_cdk as _aws_cdk_ceddda9d
-import aws_cdk.aws_cloudwatch as _aws_cdk_aws_cloudwatch_ceddda9d
 import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
+import aws_cdk.aws_events as _aws_cdk_aws_events_ceddda9d
+import aws_cdk.aws_glue as _aws_cdk_aws_glue_ceddda9d
 import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
+import aws_cdk.aws_kms as _aws_cdk_aws_kms_ceddda9d
 import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
 import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
 import constructs as _constructs_77d1e7e8
-from ..ram import (
-    ISharedPrincipal as _ISharedPrincipal_9cde791b,
-    ResourceShare as _ResourceShare_f0180713,
+
+
+class BookmarkConfiguration(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.BookmarkConfiguration",
+):
+    '''Controls the bookmark state of a Glue job.
+
+    :see: `Using job bookmarks in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html#monitor-continuations-implement>`_
+    '''
+
+    @jsii.member(jsii_name="disable")
+    @builtins.classmethod
+    def disable(cls) -> "BookmarkConfiguration":
+        '''Job bookmarks are not used, and the job always processes the entire dataset.
+
+        You are responsible for managing the output from previous job
+        runs.
+
+        :return: A configuration object that disabled job bookmarks.
+        '''
+        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "disable", []))
+
+    @jsii.member(jsii_name="enable")
+    @builtins.classmethod
+    def enable(cls) -> "BookmarkConfiguration":
+        '''Causes the job to update the state after a run to keep track of previously processed data.
+
+        If your job has a source with job bookmark support, it
+        will keep track of processed data, and when a job runs, it processes new
+        data since the last checkpoint.
+
+        :return: A configuration object that enables job bookmarks.
+        '''
+        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "enable", []))
+
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(
+        cls,
+        value: builtins.str,
+        *,
+        from_: builtins.str,
+        to: builtins.str,
+    ) -> "BookmarkConfiguration":
+        '''An escape hatch method that allows specifying arbitrary values for the ``job-bookmark-option`` argument of a Glue job.
+
+        :param value: The value to pass to the ``job-bookmark-option`` argument.
+        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
+        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+
+        :return:
+
+        A configuration object that represents the provided bookmark
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b04343485dce8549add35ec976d45544630deb5d79090df76b4018e3f8074592)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        range = BookmarkRange(from_=from_, to=to)
+
+        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "of", [value, range]))
+
+    @jsii.member(jsii_name="pause")
+    @builtins.classmethod
+    def pause(cls, *, from_: builtins.str, to: builtins.str) -> "BookmarkConfiguration":
+        '''Process incremental data since the last successful run or the data in a specified range, without updating the state of last bookmark.
+
+        You are
+        responsible for managing the output from previous job runs.
+
+        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
+        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+
+        :return: A configuration object that pauses job bookmarks.
+        '''
+        range = BookmarkRange(from_=from_, to=to)
+
+        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "pause", [range]))
+
+    @builtins.property
+    @jsii.member(jsii_name="value")
+    def value(self) -> builtins.str:
+        '''The value to pass to the ``job-bookmark-option`` argument.'''
+        return typing.cast(builtins.str, jsii.get(self, "value"))
+
+    @builtins.property
+    @jsii.member(jsii_name="range")
+    def range(self) -> typing.Optional["BookmarkRange"]:
+        '''An optional range of job ID's that will correspond to the ``job-bookmark-from`` and ``job-bookmark-to`` arguments.'''
+        return typing.cast(typing.Optional["BookmarkRange"], jsii.get(self, "range"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.BookmarkRange",
+    jsii_struct_bases=[],
+    name_mapping={"from_": "from", "to": "to"},
 )
+class BookmarkRange:
+    def __init__(self, *, from_: builtins.str, to: builtins.str) -> None:
+        '''A range of job run ID's that specify the job bookmark state of a Glue job which has had its bookmark state set to paused.
+
+        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
+        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+
+        :see: `Using job bookmarks in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html#monitor-continuations-implement>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2301b86dad3c792d837e86052ee0890dc5b59ce6914adc7fa3fd599e7ab75ccd)
+            check_type(argname="argument from_", value=from_, expected_type=type_hints["from_"])
+            check_type(argname="argument to", value=to, expected_type=type_hints["to"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "from_": from_,
+            "to": to,
+        }
+
+    @builtins.property
+    def from_(self) -> builtins.str:
+        '''The run ID which represents all the input that was processed until the last successful run before and including the specified run ID.
+
+        The
+        corresponding input is ignored.
+        '''
+        result = self._values.get("from_")
+        assert result is not None, "Required property 'from_' is missing"
+        return typing.cast(builtins.str, result)
+
+    @builtins.property
+    def to(self) -> builtins.str:
+        '''The run ID which represents all the input that was processed until the last successful run before and including the specified run ID.
+
+        The
+        corresponding input excluding the input identified by the
+        {@link BookmarkRange.from | from} is processed by the job. Any input later
+        than this input is also excluded for processing.
+        '''
+        result = self._values.get("to")
+        assert result is not None, "Required property 'to' is missing"
+        return typing.cast(builtins.str, result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "BookmarkRange(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class ClassificationString(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.ClassificationString",
+):
+    '''Classification string given to tables with this data format.
+
+    :see: https://docs.aws.amazon.com/glue/latest/dg/add-classifier.html#classifier-built-in
+    '''
+
+    def __init__(self, value: builtins.str) -> None:
+        '''
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0751f5d6215bb74e22139fe2149a7f9ee7de61eb00daa8638767d444fd2006ff)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        jsii.create(self.__class__, self, [value])
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="AVRO")
+    def AVRO(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-avro
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "AVRO"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="CSV")
+    def CSV(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-csv
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "CSV"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="JSON")
+    def JSON(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-json
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "JSON"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ORC")
+    def ORC(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-orc
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "ORC"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PARQUET")
+    def PARQUET(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-parquet
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "PARQUET"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="XML")
+    def XML(cls) -> "ClassificationString":
+        '''
+        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-xml
+        '''
+        return typing.cast("ClassificationString", jsii.sget(cls, "XML"))
+
+    @builtins.property
+    @jsii.member(jsii_name="value")
+    def value(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "value"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.CustomerGatewayAttributes",
+    jsii_type="cdk-extensions.glue.CloudWatchEncryption",
     jsii_struct_bases=[],
-    name_mapping={
-        "customer_gateway_id": "customerGatewayId",
-        "bgp_asn": "bgpAsn",
-        "ip_address": "ipAddress",
-    },
+    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
 )
-class CustomerGatewayAttributes:
+class CloudWatchEncryption:
     def __init__(
         self,
         *,
-        customer_gateway_id: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        ip_address: typing.Optional[builtins.str] = None,
+        mode: "CloudWatchEncryptionMode",
+        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
     ) -> None:
-        '''Attributes used to import an existing customer gateway.
+        '''CloudWatch Logs encryption configuration.
 
-        :param customer_gateway_id: The ID of the existing customer gateway being imported.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param mode: Encryption mode.
+        :param kms_key: The KMS key to be used to encrypt the data. Default: A key will be created if one is not provided.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__35eab003d889c662b910b407f8e02c5f1e0c594802680266f3389251bf5ac9d3)
-            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
-            check_type(argname="argument bgp_asn", value=bgp_asn, expected_type=type_hints["bgp_asn"])
-            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
+            type_hints = typing.get_type_hints(_typecheckingstub__057163656b87fc4eb457b7ce6af51ebca528e50d7d1d66f6c8cb0392e039ac1a)
+            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
+            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "customer_gateway_id": customer_gateway_id,
+            "mode": mode,
         }
-        if bgp_asn is not None:
-            self._values["bgp_asn"] = bgp_asn
-        if ip_address is not None:
-            self._values["ip_address"] = ip_address
+        if kms_key is not None:
+            self._values["kms_key"] = kms_key
 
     @builtins.property
-    def customer_gateway_id(self) -> builtins.str:
-        '''The ID of the existing customer gateway being imported.'''
-        result = self._values.get("customer_gateway_id")
-        assert result is not None, "Required property 'customer_gateway_id' is missing"
-        return typing.cast(builtins.str, result)
+    def mode(self) -> "CloudWatchEncryptionMode":
+        '''Encryption mode.'''
+        result = self._values.get("mode")
+        assert result is not None, "Required property 'mode' is missing"
+        return typing.cast("CloudWatchEncryptionMode", result)
 
     @builtins.property
-    def bgp_asn(self) -> typing.Optional[jsii.Number]:
-        '''For devices that support BGP, the customer gateway's BGP ASN.'''
-        result = self._values.get("bgp_asn")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
+        '''The KMS key to be used to encrypt the data.
+
+        :default: A key will be created if one is not provided.
+        '''
+        result = self._values.get("kms_key")
+        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "CloudWatchEncryption(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.CloudWatchEncryptionMode")
+class CloudWatchEncryptionMode(enum.Enum):
+    '''Encryption mode for CloudWatch Logs.
+
+    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_CloudWatchEncryption.html#Glue-Type-CloudWatchEncryption-CloudWatchEncryptionMode
+    '''
+
+    KMS = "KMS"
+    '''Server-side encryption (SSE) with an AWS KMS key managed by the account owner.
+
+    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
+    '''
+
+
+class Code(metaclass=jsii.JSIIAbstractClass, jsii_type="cdk-extensions.glue.Code"):
+    '''Represents a Glue Job's Code assets (an asset can be a scripts, a jar, a python file or any other file).'''
+
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="fromAsset")
+    @builtins.classmethod
+    def from_asset(
+        cls,
+        path: builtins.str,
+        *,
+        asset_hash: typing.Optional[builtins.str] = None,
+        asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
+        bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> "AssetCode":
+        '''Job code from a local disk path.
+
+        :param path: Code file (not a directory).
+        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
+        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
+        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fe5f72a2d529dee4e5a4fd60ab73c3651fdb154cc1ac378fcf8a4c6cc14f7f47)
+            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
+        options = _aws_cdk_ceddda9d.AssetOptions(
+            asset_hash=asset_hash, asset_hash_type=asset_hash_type, bundling=bundling
+        )
+
+        return typing.cast("AssetCode", jsii.sinvoke(cls, "fromAsset", [path, options]))
+
+    @jsii.member(jsii_name="fromBucket")
+    @builtins.classmethod
+    def from_bucket(
+        cls,
+        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+        key: builtins.str,
+    ) -> "S3Code":
+        '''Job code as an S3 object.
+
+        :param bucket: The S3 bucket.
+        :param key: The object key.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0ae28ae94ca6a7f468c50a4d7ca53e509947843d875b01df05b54a3d3035fe76)
+            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("S3Code", jsii.sinvoke(cls, "fromBucket", [bucket, key]))
+
+    @jsii.member(jsii_name="bind")
+    @abc.abstractmethod
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+    ) -> "CodeConfig":
+        '''Called when the Job is initialized to allow this object to bind.
+
+        :param scope: -
+        :param grantable: -
+        '''
+        ...
+
+
+class _CodeProxy(Code):
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+    ) -> "CodeConfig":
+        '''Called when the Job is initialized to allow this object to bind.
+
+        :param scope: -
+        :param grantable: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__29827b2153002e81b9ff9677022a59a77e67b7c0083100827663e2e422bda0db)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
+        return typing.cast("CodeConfig", jsii.invoke(self, "bind", [scope, grantable]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, Code).__jsii_proxy_class__ = lambda : _CodeProxy
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.CodeConfig",
+    jsii_struct_bases=[],
+    name_mapping={"s3_location": "s3Location"},
+)
+class CodeConfig:
+    def __init__(
+        self,
+        *,
+        s3_location: typing.Union[_aws_cdk_aws_s3_ceddda9d.Location, typing.Dict[builtins.str, typing.Any]],
+    ) -> None:
+        '''Result of binding ``Code`` into a ``Job``.
+
+        :param s3_location: The location of the code in S3.
+        '''
+        if isinstance(s3_location, dict):
+            s3_location = _aws_cdk_aws_s3_ceddda9d.Location(**s3_location)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f929a25191cf84849ac8dc0774c3d7cb58e7913b1ffa7fc2fbca5cb55667291c)
+            check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "s3_location": s3_location,
+        }
+
+    @builtins.property
+    def s3_location(self) -> _aws_cdk_aws_s3_ceddda9d.Location:
+        '''The location of the code in S3.'''
+        result = self._values.get("s3_location")
+        assert result is not None, "Required property 's3_location' is missing"
+        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Location, result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "CodeConfig(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class Column(metaclass=jsii.JSIIAbstractClass, jsii_type="cdk-extensions.glue.Column"):
+    def __init__(
+        self,
+        *,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param comment: 
+        :param name: 
+        '''
+        props = ColumnProps(comment=comment, name=name)
+
+        jsii.create(self.__class__, self, [props])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTable.ColumnProperty:
+        '''
+        :param scope: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__444e4405d6fa32714b3fa80c1a990dc679108d516ba2f551601636ba37108c5e)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTable.ColumnProperty, jsii.invoke(self, "bind", [scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="typeString")
+    @abc.abstractmethod
+    def type_string(self) -> builtins.str:
+        ...
 
     @builtins.property
-    def ip_address(self) -> typing.Optional[builtins.str]:
-        '''The Internet-routable IP address for the customer gateway's outside interface.
+    @jsii.member(jsii_name="comment")
+    def comment(self) -> typing.Optional[builtins.str]:
+        '''A free-form text comment.
 
-        The address must be static.
+        :see: `AWS::Glue::Table Column <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-column.html#cfn-glue-table-column-comment>`_
         '''
-        result = self._values.get("ip_address")
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "comment"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Column.
+
+        :see: `AWS::Glue::Table Column <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-column.html#cfn-glue-table-column-name>`_
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+
+
+class _ColumnProxy(Column):
+    @builtins.property
+    @jsii.member(jsii_name="typeString")
+    def type_string(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "typeString"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, Column).__jsii_proxy_class__ = lambda : _ColumnProxy
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.ColumnProps",
+    jsii_struct_bases=[],
+    name_mapping={"comment": "comment", "name": "name"},
+)
+class ColumnProps:
+    def __init__(
+        self,
+        *,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param comment: 
+        :param name: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2acc8cf451159a8d67a7210893d3fff8ebd56626ab3a55b71a5a7d60b58fa6f2)
+            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if comment is not None:
+            self._values["comment"] = comment
+        if name is not None:
+            self._values["name"] = name
+
+    @builtins.property
+    def comment(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("comment")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "CustomerGatewayAttributes(%s)" % ", ".join(
+        return "ColumnProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+@jsii.enum(jsii_type="cdk-extensions.glue.ConfigurationVersion")
+class ConfigurationVersion(enum.Enum):
+    V1_0 = "V1_0"
+
+
+@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IConnectable)
+class Connection(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.Connection",
+):
+    '''Creates a resource specifying a Glue Connection to a data source.
+
+    :see: `AWS::Glue::Connection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html>`_
+    '''
+
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        connection_type: "ConnectionType",
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the Connection class.
+
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param connection_type: The type of the connection.
+        :param description: A description for the Connection.
+        :param name: The name of the connection. Connection will not function as expected without a name.
+        :param properties: List of Key/Value pairs defining the properties of the Connection.
+        :param security_groups: Existing Security Group to assign to the Connection. If none is provided a new Security Group will be created.
+        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
+        :param vpc: VPC to attach to the Connection.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__023b7dc3d20f72ca57c6c81f464fce932d96d952762ad3a3710109c3be2e676c)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = ConnectionProps(
+            connection_type=connection_type,
+            description=description,
+            name=name,
+            properties=properties,
+            security_groups=security_groups,
+            subnets=subnets,
+            vpc=vpc,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="addMatchCriteria")
+    def add_match_criteria(self, value: builtins.str) -> None:
+        '''
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a45f2c7f57ece25b2ed1a81fd7f6d3d5c0fe1afcbef8310db8d03a698c138480)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addMatchCriteria", [value]))
+
+    @jsii.member(jsii_name="addProperty")
+    def add_property(self, key: builtins.str, value: builtins.str) -> None:
+        '''
+        :param key: -
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1eee3a4bfe7ee7514d7510a9f817a30f05617f0049f9d10ada9cc135e1b8ab26)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addProperty", [key, value]))
+
+    @builtins.property
+    @jsii.member(jsii_name="connectionArn")
+    def connection_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "connectionArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="connectionName")
+    def connection_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "connectionName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="connections")
+    def connections(self) -> _aws_cdk_aws_ec2_ceddda9d.Connections:
+        '''The network connections associated with this resource.'''
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Connections, jsii.get(self, "connections"))
+
+    @builtins.property
+    @jsii.member(jsii_name="connectionType")
+    def connection_type(self) -> "ConnectionType":
+        '''{@link ConnectionProps.connectionType:}.'''
+        return typing.cast("ConnectionType", jsii.get(self, "connectionType"))
+
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnConnection:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnConnection, jsii.get(self, "resource"))
+
+    @builtins.property
+    @jsii.member(jsii_name="securityGroups")
+    def security_groups(self) -> typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]:
+        '''{@link ConnectionProps.securityGroups:}.'''
+        return typing.cast(typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup], jsii.get(self, "securityGroups"))
+
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link ConnectionProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link ConnectionProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+
+    @builtins.property
+    @jsii.member(jsii_name="securityGroup")
+    def security_group(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SecurityGroup]:
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SecurityGroup], jsii.get(self, "securityGroup"))
+
+    @builtins.property
+    @jsii.member(jsii_name="subnets")
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''{@link ConnectionProps.subnets}.'''
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], jsii.get(self, "subnets"))
+
+    @builtins.property
+    @jsii.member(jsii_name="vpc")
+    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
+        '''{@link ConnectionProps.vpc}.'''
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], jsii.get(self, "vpc"))
+
+
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.CustomerGatewayProps",
+    jsii_type="cdk-extensions.glue.ConnectionProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "ip_address": "ipAddress",
-        "bgp_asn": "bgpAsn",
         "connection_type": "connectionType",
+        "description": "description",
+        "name": "name",
+        "properties": "properties",
+        "security_groups": "securityGroups",
+        "subnets": "subnets",
+        "vpc": "vpc",
     },
 )
-class CustomerGatewayProps(_aws_cdk_ceddda9d.ResourceProps):
+class ConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        ip_address: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
+        connection_type: "ConnectionType",
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
     ) -> None:
-        '''Configuration for the CustomerGateway resource.
+        '''Configuration for the Glue Workflow resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param connection_type: The type of the connection.
+        :param description: A description for the Connection.
+        :param name: The name of the connection. Connection will not function as expected without a name.
+        :param properties: List of Key/Value pairs defining the properties of the Connection.
+        :param security_groups: Existing Security Group to assign to the Connection. If none is provided a new Security Group will be created.
+        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
+        :param vpc: VPC to attach to the Connection.
         '''
+        if isinstance(subnets, dict):
+            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e250ab0ff20773956eb3b2131200a7ee56b455ba85d22729b69f588d369a8193)
+            type_hints = typing.get_type_hints(_typecheckingstub__0af32a3c84c0678710e524ede720205f2f84097eea14da00eb58b5d5f043557b)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
-            check_type(argname="argument bgp_asn", value=bgp_asn, expected_type=type_hints["bgp_asn"])
             check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
+            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
+            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "ip_address": ip_address,
+            "connection_type": connection_type,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if bgp_asn is not None:
-            self._values["bgp_asn"] = bgp_asn
-        if connection_type is not None:
-            self._values["connection_type"] = connection_type
+        if description is not None:
+            self._values["description"] = description
+        if name is not None:
+            self._values["name"] = name
+        if properties is not None:
+            self._values["properties"] = properties
+        if security_groups is not None:
+            self._values["security_groups"] = security_groups
+        if subnets is not None:
+            self._values["subnets"] = subnets
+        if vpc is not None:
+            self._values["vpc"] = vpc
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -299,902 +882,1632 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def ip_address(self) -> builtins.str:
-        '''The Internet-routable IP address for the customer gateway's outside interface.
+    def connection_type(self) -> "ConnectionType":
+        '''The type of the connection.
+
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
+        '''
+        result = self._values.get("connection_type")
+        assert result is not None, "Required property 'connection_type' is missing"
+        return typing.cast("ConnectionType", result)
+
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description for the Connection.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the connection.
 
-        The address must be static.
+        Connection will not function as expected without a name.
 
-        :see: `CustomerGateway IpAddress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress>`_
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-name>`_
         '''
-        result = self._values.get("ip_address")
-        assert result is not None, "Required property 'ip_address' is missing"
-        return typing.cast(builtins.str, result)
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def bgp_asn(self) -> typing.Optional[jsii.Number]:
-        '''For devices that support BGP, the customer gateway's BGP ASN.
+    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''List of Key/Value pairs defining the properties of the Connection.
 
-        :see: `CustomerGateway BgpAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn>`_
+        :see: `AWS::Glue::Connection Properties <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html#Properties>`_
         '''
-        result = self._values.get("bgp_asn")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        result = self._values.get("properties")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     @builtins.property
-    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
-        '''The type of VPN connection that this customer gateway supports.
+    def security_groups(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
+        '''Existing Security Group to assign to the Connection.
 
-        :see: `CustomerGateway Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type>`_
+        If none is provided a new Security Group will be created.
         '''
-        result = self._values.get("connection_type")
-        return typing.cast(typing.Optional["VpnConnectionType"], result)
+        result = self._values.get("security_groups")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
+
+    @builtins.property
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''Options for selection of subnets from the VPC to attach to the Connection.
+
+        :see: `CDK SubnetSelection <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.SubnetSelection.html>`_
+        '''
+        result = self._values.get("subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
+
+    @builtins.property
+    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
+        '''VPC to attach to the Connection.
+
+        :see: `IVpc Interface <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.IVpc.html>`_
+        '''
+        result = self._values.get("vpc")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "CustomerGatewayProps(%s)" % ", ".join(
+        return "ConnectionProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class FlowLog(
-    _aws_cdk_aws_ec2_ceddda9d.FlowLog,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.FlowLog",
-):
+@jsii.enum(jsii_type="cdk-extensions.glue.ConnectionType")
+class ConnectionType(enum.Enum):
+    JDBC = "JDBC"
+    '''JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).'''
+    KAFKA = "KAFKA"
+    '''KAFKA - Designates a connection to an Apache Kafka streaming platform.'''
+    MONGODB = "MONGODB"
+    '''MONGODB - Designates a connection to a MongoDB document database.'''
+    NETWORK = "NETWORK"
+    '''NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).'''
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.ContinuousLoggingProps",
+    jsii_struct_bases=[],
+    name_mapping={
+        "enabled": "enabled",
+        "conversion_pattern": "conversionPattern",
+        "log_group": "logGroup",
+        "log_stream_prefix": "logStreamPrefix",
+        "quiet": "quiet",
+    },
+)
+class ContinuousLoggingProps:
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
         *,
-        resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
-        destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
-        flow_log_name: typing.Optional[builtins.str] = None,
-        log_format: typing.Optional["FlowLogFormat"] = None,
-        max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
-        traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        enabled: builtins.bool,
+        conversion_pattern: typing.Optional[builtins.str] = None,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        log_stream_prefix: typing.Optional[builtins.str] = None,
+        quiet: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Creates a new instance of the FlowLog class.
-
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param resource_type: Details for the resource from which flow logs will be captured.
-        :param destination: The location where flow logs should be delivered.
-        :param flow_log_name: The name of the FlowLog.
-        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see {@link FlowLogField}.
-        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
-        :param traffic_type: The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        :param enabled: Enable continouous logging.
+        :param conversion_pattern: Apply the provided conversion pattern. This is a Log4j Conversion Pattern to customize driver and executor logs. Default: ``%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n``
+        :param log_group: Specify a custom CloudWatch log group name. Default: - a log group is created with name ``/aws-glue/jobs/logs-v2/``.
+        :param log_stream_prefix: Specify a custom CloudWatch log stream prefix. Default: - the job run ID.
+        :param quiet: Filter out non-useful Apache Spark driver/executor and Apache Hadoop YARN heartbeat log messages. Default: true
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__685f60b23d7e8e561b55bc9dca121799b9d63919b8e78b372a1fa549c234455e)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = FlowLogProps(
-            resource_type=resource_type,
-            destination=destination,
-            flow_log_name=flow_log_name,
-            log_format=log_format,
-            max_aggregation_interval=max_aggregation_interval,
-            traffic_type=traffic_type,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__c8560efd79afaf7b7778442a94c024de5f4c8f79564e4c191018f7871c34b5e6)
+            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
+            check_type(argname="argument conversion_pattern", value=conversion_pattern, expected_type=type_hints["conversion_pattern"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument log_stream_prefix", value=log_stream_prefix, expected_type=type_hints["log_stream_prefix"])
+            check_type(argname="argument quiet", value=quiet, expected_type=type_hints["quiet"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "enabled": enabled,
+        }
+        if conversion_pattern is not None:
+            self._values["conversion_pattern"] = conversion_pattern
+        if log_group is not None:
+            self._values["log_group"] = log_group
+        if log_stream_prefix is not None:
+            self._values["log_stream_prefix"] = log_stream_prefix
+        if quiet is not None:
+            self._values["quiet"] = quiet
 
-        jsii.create(self.__class__, self, [scope, id, props])
+    @builtins.property
+    def enabled(self) -> builtins.bool:
+        '''Enable continouous logging.'''
+        result = self._values.get("enabled")
+        assert result is not None, "Required property 'enabled' is missing"
+        return typing.cast(builtins.bool, result)
 
     @builtins.property
-    @jsii.member(jsii_name="destination")
-    def destination(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogDestination:
-        '''The location where flow logs should be delivered.
+    def conversion_pattern(self) -> typing.Optional[builtins.str]:
+        '''Apply the provided conversion pattern.
 
-        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
-        :group: Inputs
+        This is a Log4j Conversion Pattern to customize driver and executor logs.
+
+        :default: ``%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n``
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination, jsii.get(self, "destination"))
+        result = self._values.get("conversion_pattern")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="logFormat")
-    def log_format(self) -> "FlowLogFormat":
-        '''The fields to include in the flow log record, in the order in which they should appear.
-
-        For a list of available fields, see {@link FlowLogField}.
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        '''Specify a custom CloudWatch log group name.
 
-        :see: `FlowLog LogFormat <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat>`_
-        :group: Inputs
+        :default: - a log group is created with name ``/aws-glue/jobs/logs-v2/``.
         '''
-        return typing.cast("FlowLogFormat", jsii.get(self, "logFormat"))
+        result = self._values.get("log_group")
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnFlowLog:
-        '''The underlying FlowLog CloudFormation resource.
+    def log_stream_prefix(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom CloudWatch log stream prefix.
 
-        :see: `AWS::EC2::FlowLog <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html>`_
-        :group: Resources
+        :default: - the job run ID.
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnFlowLog, jsii.get(self, "resource"))
+        result = self._values.get("log_stream_prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="resourceType")
-    def resource_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType:
-        '''Details for the resource from which flow logs will be captured.
+    def quiet(self) -> typing.Optional[builtins.bool]:
+        '''Filter out non-useful Apache Spark driver/executor and Apache Hadoop YARN heartbeat log messages.
 
-        :see: `FlowLog ResourceType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype>`_
-        :group: Inputs
+        :default: true
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType, jsii.get(self, "resourceType"))
+        result = self._values.get("quiet")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-    @builtins.property
-    @jsii.member(jsii_name="trafficType")
-    def traffic_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType:
-        '''The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :see: `FlowLog TrafficType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype>`_
-        :group: Inputs
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ContinuousLoggingProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.CrawlerConfiguration",
+    jsii_struct_bases=[],
+    name_mapping={
+        "partition_update_behavior": "partitionUpdateBehavior",
+        "table_grouping_policy": "tableGroupingPolicy",
+        "table_level": "tableLevel",
+        "table_update_behavior": "tableUpdateBehavior",
+        "version": "version",
+    },
+)
+class CrawlerConfiguration:
+    def __init__(
+        self,
+        *,
+        partition_update_behavior: typing.Optional["PartitionUpdateBehavior"] = None,
+        table_grouping_policy: typing.Optional["TableGroupingPolicy"] = None,
+        table_level: typing.Optional[jsii.Number] = None,
+        table_update_behavior: typing.Optional["TableUpdateBehavior"] = None,
+        version: typing.Optional[ConfigurationVersion] = None,
+    ) -> None:
+        '''
+        :param partition_update_behavior: 
+        :param table_grouping_policy: 
+        :param table_level: 
+        :param table_update_behavior: 
+        :param version: 
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType, jsii.get(self, "trafficType"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__51a7512576b1965463466002ce33610505de95eb6d8629c5243e563c30f4f20f)
+            check_type(argname="argument partition_update_behavior", value=partition_update_behavior, expected_type=type_hints["partition_update_behavior"])
+            check_type(argname="argument table_grouping_policy", value=table_grouping_policy, expected_type=type_hints["table_grouping_policy"])
+            check_type(argname="argument table_level", value=table_level, expected_type=type_hints["table_level"])
+            check_type(argname="argument table_update_behavior", value=table_update_behavior, expected_type=type_hints["table_update_behavior"])
+            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if partition_update_behavior is not None:
+            self._values["partition_update_behavior"] = partition_update_behavior
+        if table_grouping_policy is not None:
+            self._values["table_grouping_policy"] = table_grouping_policy
+        if table_level is not None:
+            self._values["table_level"] = table_level
+        if table_update_behavior is not None:
+            self._values["table_update_behavior"] = table_update_behavior
+        if version is not None:
+            self._values["version"] = version
+
+    @builtins.property
+    def partition_update_behavior(self) -> typing.Optional["PartitionUpdateBehavior"]:
+        result = self._values.get("partition_update_behavior")
+        return typing.cast(typing.Optional["PartitionUpdateBehavior"], result)
+
+    @builtins.property
+    def table_grouping_policy(self) -> typing.Optional["TableGroupingPolicy"]:
+        result = self._values.get("table_grouping_policy")
+        return typing.cast(typing.Optional["TableGroupingPolicy"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="flowLogName")
-    def flow_log_name(self) -> typing.Optional[builtins.str]:
-        '''The name of the FlowLog.
+    def table_level(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("table_level")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "flowLogName"))
+    @builtins.property
+    def table_update_behavior(self) -> typing.Optional["TableUpdateBehavior"]:
+        result = self._values.get("table_update_behavior")
+        return typing.cast(typing.Optional["TableUpdateBehavior"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="maxAggregationInterval")
-    def max_aggregation_interval(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval]:
-        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
+    def version(self) -> typing.Optional[ConfigurationVersion]:
+        result = self._values.get("version")
+        return typing.cast(typing.Optional[ConfigurationVersion], result)
 
-        :see: `FlowLog MaxAggregationInterval <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval], jsii.get(self, "maxAggregationInterval"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-@jsii.enum(jsii_type="cdk-extensions.ec2.FlowLogDataType")
-class FlowLogDataType(enum.Enum):
-    INT_32 = "INT_32"
-    '''32 bit signed int.'''
-    INT_64 = "INT_64"
-    '''64 bit signed int.'''
-    STRING = "STRING"
-    '''UTF-8 encoded character string.'''
+    def __repr__(self) -> str:
+        return "CrawlerConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.FlowLogDestinationConfig",
-    jsii_struct_bases=[],
+    jsii_type="cdk-extensions.glue.CrawlerProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
-        "destination_type": "destinationType",
-        "bucket": "bucket",
-        "destination_options": "destinationOptions",
-        "log_group": "logGroup",
-        "role": "role",
-        "s3_path": "s3Path",
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "classifiers": "classifiers",
+        "configuration": "configuration",
+        "database": "database",
+        "delete_behavior": "deleteBehavior",
+        "description": "description",
+        "name": "name",
+        "recrawl_behavior": "recrawlBehavior",
+        "schedule_expression": "scheduleExpression",
+        "security_configuration": "securityConfiguration",
+        "table_prefix": "tablePrefix",
+        "targets": "targets",
+        "update_behavior": "updateBehavior",
     },
 )
-class FlowLogDestinationConfig:
+class CrawlerProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        destination_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType,
-        bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
-        destination_options: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        s3_path: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
+        configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
+        database: typing.Optional["Database"] = None,
+        delete_behavior: typing.Optional["DeleteBehavior"] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        recrawl_behavior: typing.Optional["RecrawlBehavior"] = None,
+        schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        security_configuration: typing.Optional["SecurityConfiguration"] = None,
+        table_prefix: typing.Optional[builtins.str] = None,
+        targets: typing.Optional[typing.Sequence["ICrawlerTarget"]] = None,
+        update_behavior: typing.Optional["UpdateBehavior"] = None,
     ) -> None:
-        '''A configuration object providing the details necessary to set up log delivery to a given destination.
+        '''Configuration for Crawler.
 
-        :param destination_type: The type of destination for the flow log data.
-        :param bucket: An S3 bucket where logs should be delivered.
-        :param destination_options: Additional options that control the format and behavior of logs delivered to the destination.
-        :param log_group: A CloudWatch LogGroup where logs should be delivered.
-        :param role: The ARN of the IAM role that allows Amazon EC2 to publish flow logs in your account.
-        :param s3_path: An Amazon Resource Name (ARN) for the S3 destination where log files are to be delivered. If a custom prefix is being added the ARN should reflect that prefix.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param classifiers: A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
+        :param configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
+        :param database: The {@link aws-glue.Database | Database } object in which the crawler's output is stored.
+        :param delete_behavior: The deletion behavior when the crawler finds a deleted object.
+        :param description: Description of the Crawler.
+        :param name: Name of the Crawler.
+        :param recrawl_behavior: When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
+        :param schedule_expression: For scheduled crawlers, the schedule when the crawler runs.
+        :param security_configuration: A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.
+        :param table_prefix: The prefix added to the names of tables that are created.
+        :param targets: A collection of targets to crawl.
+        :param update_behavior: The update behavior when the crawler finds a changed schema.
         '''
+        if isinstance(configuration, dict):
+            configuration = CrawlerConfiguration(**configuration)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__11b243acaaaa5840cda314f12b7b4d009805f9002ef9847296dedc4c734cfaa8)
-            check_type(argname="argument destination_type", value=destination_type, expected_type=type_hints["destination_type"])
-            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
-            check_type(argname="argument destination_options", value=destination_options, expected_type=type_hints["destination_options"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-            check_type(argname="argument s3_path", value=s3_path, expected_type=type_hints["s3_path"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "destination_type": destination_type,
-        }
-        if bucket is not None:
-            self._values["bucket"] = bucket
-        if destination_options is not None:
-            self._values["destination_options"] = destination_options
-        if log_group is not None:
-            self._values["log_group"] = log_group
-        if role is not None:
-            self._values["role"] = role
-        if s3_path is not None:
-            self._values["s3_path"] = s3_path
+            type_hints = typing.get_type_hints(_typecheckingstub__2280b17fb14a2d4a9a875511f4dcee118bd04236b81ae5e543e8502074f74f5c)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument classifiers", value=classifiers, expected_type=type_hints["classifiers"])
+            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
+            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
+            check_type(argname="argument delete_behavior", value=delete_behavior, expected_type=type_hints["delete_behavior"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument recrawl_behavior", value=recrawl_behavior, expected_type=type_hints["recrawl_behavior"])
+            check_type(argname="argument schedule_expression", value=schedule_expression, expected_type=type_hints["schedule_expression"])
+            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
+            check_type(argname="argument table_prefix", value=table_prefix, expected_type=type_hints["table_prefix"])
+            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
+            check_type(argname="argument update_behavior", value=update_behavior, expected_type=type_hints["update_behavior"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if classifiers is not None:
+            self._values["classifiers"] = classifiers
+        if configuration is not None:
+            self._values["configuration"] = configuration
+        if database is not None:
+            self._values["database"] = database
+        if delete_behavior is not None:
+            self._values["delete_behavior"] = delete_behavior
+        if description is not None:
+            self._values["description"] = description
+        if name is not None:
+            self._values["name"] = name
+        if recrawl_behavior is not None:
+            self._values["recrawl_behavior"] = recrawl_behavior
+        if schedule_expression is not None:
+            self._values["schedule_expression"] = schedule_expression
+        if security_configuration is not None:
+            self._values["security_configuration"] = security_configuration
+        if table_prefix is not None:
+            self._values["table_prefix"] = table_prefix
+        if targets is not None:
+            self._values["targets"] = targets
+        if update_behavior is not None:
+            self._values["update_behavior"] = update_behavior
+
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
+
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
+
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
+
+        Cannot be supplied together with either ``account`` or ``region``.
+
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def destination_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType:
-        '''The type of destination for the flow log data.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        result = self._values.get("destination_type")
-        assert result is not None, "Required property 'destination_type' is missing"
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType, result)
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def bucket(self) -> typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket]:
-        '''An S3 bucket where logs should be delivered.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("bucket")
-        return typing.cast(typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket], result)
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def destination_options(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
-        '''Additional options that control the format and behavior of logs delivered to the destination.'''
-        result = self._values.get("destination_options")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)
+    def classifiers(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
+
+        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-classifiers>`_
+        '''
+        result = self._values.get("classifiers")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        '''A CloudWatch LogGroup where logs should be delivered.
+    def configuration(self) -> typing.Optional[CrawlerConfiguration]:
+        '''Crawler configuration information.
 
-        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
+        This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
+
+        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-configuration>`_
         '''
-        result = self._values.get("log_group")
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
+        result = self._values.get("configuration")
+        return typing.cast(typing.Optional[CrawlerConfiguration], result)
 
     @builtins.property
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''The ARN of the IAM role that allows Amazon EC2 to publish flow logs in your account.
+    def database(self) -> typing.Optional["Database"]:
+        '''The {@link aws-glue.Database | Database } object in which the crawler's output is stored.'''
+        result = self._values.get("database")
+        return typing.cast(typing.Optional["Database"], result)
+
+    @builtins.property
+    def delete_behavior(self) -> typing.Optional["DeleteBehavior"]:
+        '''The deletion behavior when the crawler finds a deleted object.
 
-        :see: `FlowLog DeliverLogsPermissionArn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn>`_
+        :see: `AWS::Glue::Crawler SchemaChangePolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schemachangepolicy.html#cfn-glue-crawler-schemachangepolicy-deletebehavior>`_
         '''
-        result = self._values.get("role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+        result = self._values.get("delete_behavior")
+        return typing.cast(typing.Optional["DeleteBehavior"], result)
 
     @builtins.property
-    def s3_path(self) -> typing.Optional[builtins.str]:
-        '''An Amazon Resource Name (ARN) for the S3 destination where log files are to be delivered.
+    def description(self) -> typing.Optional[builtins.str]:
+        '''Description of the Crawler.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        If a custom prefix is being added the ARN should reflect that prefix.
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''Name of the Crawler.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def recrawl_behavior(self) -> typing.Optional["RecrawlBehavior"]:
+        '''When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
+
+        :see: `AWS::Glue::Crawler RecrawlPolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-recrawlpolicy.html>`_
+        '''
+        result = self._values.get("recrawl_behavior")
+        return typing.cast(typing.Optional["RecrawlBehavior"], result)
+
+    @builtins.property
+    def schedule_expression(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
+        '''For scheduled crawlers, the schedule when the crawler runs.
 
-        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
+        :see: `AWS::Glue::Crawler Schedule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schedule.html>`_
         '''
-        result = self._values.get("s3_path")
+        result = self._values.get("schedule_expression")
+        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
+
+    @builtins.property
+    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
+        '''A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.'''
+        result = self._values.get("security_configuration")
+        return typing.cast(typing.Optional["SecurityConfiguration"], result)
+
+    @builtins.property
+    def table_prefix(self) -> typing.Optional[builtins.str]:
+        '''The prefix added to the names of tables that are created.
+
+        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-tableprefix>`_
+        '''
+        result = self._values.get("table_prefix")
         return typing.cast(typing.Optional[builtins.str], result)
 
+    @builtins.property
+    def targets(self) -> typing.Optional[typing.List["ICrawlerTarget"]]:
+        '''A collection of targets to crawl.
+
+        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-targets>`_
+        '''
+        result = self._values.get("targets")
+        return typing.cast(typing.Optional[typing.List["ICrawlerTarget"]], result)
+
+    @builtins.property
+    def update_behavior(self) -> typing.Optional["UpdateBehavior"]:
+        '''The update behavior when the crawler finds a changed schema.
+
+        :see: `AWS::Glue::Crawler SchemaChangePolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schemachangepolicy.html#cfn-glue-crawler-schemachangepolicy-updatebehavior>`_
+        '''
+        result = self._values.get("update_behavior")
+        return typing.cast(typing.Optional["UpdateBehavior"], result)
+
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FlowLogDestinationConfig(%s)" % ", ".join(
+        return "CrawlerProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class FlowLogField(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.FlowLogField",
-):
-    def __init__(self, name: builtins.str, type: FlowLogDataType) -> None:
-        '''Creates a new instance of the FlowLogField class.
+@jsii.enum(jsii_type="cdk-extensions.glue.CrawlerState")
+class CrawlerState(enum.Enum):
+    '''State a Glue crawler must be in in order to satisfy a predicate condition to trigger a part of a workflow.'''
+
+    CANCELLED = "CANCELLED"
+    '''A crawler execution was cancelled before it could finish.'''
+    FAILED = "FAILED"
+    '''A crawler that has finished and ended in an error.'''
+    SUCCEEDED = "SUCCEEDED"
+    '''A crawler which has finished successfully.'''
+
 
-        :param name: The name of the Flow Log field, as it should be used when building a format string.
-        :param type: The data type of the field as it would appear in Parquet. For information on the type for various files, see documentation on the `available fields <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-logs-fields>`_.
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.CrawlerTargetCollection",
+    jsii_struct_bases=[],
+    name_mapping={
+        "catalog_targets": "catalogTargets",
+        "dynamo_db_targets": "dynamoDbTargets",
+        "jdbc_targets": "jdbcTargets",
+        "s3_targets": "s3Targets",
+    },
+)
+class CrawlerTargetCollection:
+    def __init__(
+        self,
+        *,
+        catalog_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+        dynamo_db_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+        jdbc_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+        s3_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''
+        :param catalog_targets: 
+        :param dynamo_db_targets: 
+        :param jdbc_targets: 
+        :param s3_targets: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__52a7eb2a067a774b7223df31becb41f1517c9aa30eb3b326b26ad7504939a991)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-        jsii.create(self.__class__, self, [name, type])
+            type_hints = typing.get_type_hints(_typecheckingstub__a8896893a8fc4935daa0226b1e3669e65b536c6438cba018169f71f1a6aed7e3)
+            check_type(argname="argument catalog_targets", value=catalog_targets, expected_type=type_hints["catalog_targets"])
+            check_type(argname="argument dynamo_db_targets", value=dynamo_db_targets, expected_type=type_hints["dynamo_db_targets"])
+            check_type(argname="argument jdbc_targets", value=jdbc_targets, expected_type=type_hints["jdbc_targets"])
+            check_type(argname="argument s3_targets", value=s3_targets, expected_type=type_hints["s3_targets"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if catalog_targets is not None:
+            self._values["catalog_targets"] = catalog_targets
+        if dynamo_db_targets is not None:
+            self._values["dynamo_db_targets"] = dynamo_db_targets
+        if jdbc_targets is not None:
+            self._values["jdbc_targets"] = jdbc_targets
+        if s3_targets is not None:
+            self._values["s3_targets"] = s3_targets
 
-    @jsii.member(jsii_name="lookupField")
-    @builtins.classmethod
-    def lookup_field(cls, name: builtins.str) -> typing.Optional["FlowLogField"]:
-        '''Tries to retieve full flow log field data for a log field based on name.
+    @builtins.property
+    def catalog_targets(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty]]:
+        result = self._values.get("catalog_targets")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty]], result)
 
-        Returns undefined if the field name is not recognized.
+    @builtins.property
+    def dynamo_db_targets(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty]]:
+        result = self._values.get("dynamo_db_targets")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty]], result)
 
-        :param name: The name of the FlowLogField to look up.
+    @builtins.property
+    def jdbc_targets(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty]]:
+        result = self._values.get("jdbc_targets")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty]], result)
 
-        :return:
+    @builtins.property
+    def s3_targets(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty]]:
+        result = self._values.get("s3_targets")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        The FlowLogField data for a field with the given name if one is
-        found.
+    def __repr__(self) -> str:
+        return "CrawlerTargetCollection(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class DataFormat(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.DataFormat"):
+    '''Defines the input/output formats and ser/de for a single DataFormat.'''
+
+    def __init__(
+        self,
+        *,
+        input_format: "InputFormat",
+        output_format: "OutputFormat",
+        serialization_library: "SerializationLibrary",
+        classification_string: typing.Optional[ClassificationString] = None,
+    ) -> None:
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__186041c191f59ab5a16d388d89fb358a9ce5c7c993bd90eb9e6479e368341acd)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast(typing.Optional["FlowLogField"], jsii.sinvoke(cls, "lookupField", [name]))
+        :param input_format: ``InputFormat`` for this data format.
+        :param output_format: ``OutputFormat`` for this data format.
+        :param serialization_library: Serialization library for this data format.
+        :param classification_string: Classification string given to tables with this data format. Default: - No classification is specified.
+        '''
+        props = DataFormatProps(
+            input_format=input_format,
+            output_format=output_format,
+            serialization_library=serialization_library,
+            classification_string=classification_string,
+        )
+
+        jsii.create(self.__class__, self, [props])
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="ACCOUNT_ID")
-    def ACCOUNT_ID(cls) -> "FlowLogField":
-        '''The AWS account ID of the owner of the source network interface for which traffic is recorded.
+    @jsii.member(jsii_name="APACHE_LOGS")
+    def APACHE_LOGS(cls) -> "DataFormat":
+        '''DataFormat for Apache Web Server Logs.
 
-        If the network interface is created by an
-        AWS service, for example when creating a VPC endpoint or Network Load
-        Balancer, the record might display unknown for this field.
+        Also works for CloudFront logs
+
+        :see: https://docs.aws.amazon.com/athena/latest/ug/apache.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "ACCOUNT_ID"))
+        return typing.cast("DataFormat", jsii.sget(cls, "APACHE_LOGS"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="ACTION")
-    def ACTION(cls) -> "FlowLogField":
-        '''The action that is associated with the traffic:.
+    @jsii.member(jsii_name="AVRO")
+    def AVRO(cls) -> "DataFormat":
+        '''DataFormat for Apache Avro.
 
-        ACCEPT: The recorded traffic was permitted by the security groups and
-        network ACLs.
-        REJECT: The recorded traffic was not permitted by the security groups
-        or network ACLs.
+        :see: https://docs.aws.amazon.com/athena/latest/ug/avro.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "ACTION"))
+        return typing.cast("DataFormat", jsii.sget(cls, "AVRO"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="AZ_ID")
-    def AZ_ID(cls) -> "FlowLogField":
-        '''The ID of the Availability Zone that contains the network interface for which traffic is recorded.
+    @jsii.member(jsii_name="CLOUDTRAIL_LOGS")
+    def CLOUDTRAIL_LOGS(cls) -> "DataFormat":
+        '''DataFormat for CloudTrail logs stored on S3.
 
-        If the traffic is from a sublocation, the
-        record displays a '-' symbol for this field.
+        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "AZ_ID"))
+        return typing.cast("DataFormat", jsii.sget(cls, "CLOUDTRAIL_LOGS"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="BYTES")
-    def BYTES(cls) -> "FlowLogField":
-        '''The number of bytes transferred during the flow.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "BYTES"))
+    @jsii.member(jsii_name="CSV")
+    def CSV(cls) -> "DataFormat":
+        '''DataFormat for CSV Files.
+
+        :see: https://docs.aws.amazon.com/athena/latest/ug/csv.html
+        '''
+        return typing.cast("DataFormat", jsii.sget(cls, "CSV"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="DSTADDR")
-    def DSTADDR(cls) -> "FlowLogField":
-        '''The destination address for outgoing traffic, or the IPv4 or IPv6 address of the network interface for incoming traffic on the network interface.
+    @jsii.member(jsii_name="JSON")
+    def JSON(cls) -> "DataFormat":
+        '''Stored as plain text files in JSON format.
 
-        The IPv4 address of the network interface is always its
-        private IPv4 address.
+        Uses OpenX Json SerDe for serialization and deseralization.
 
-        See also:
-        {@link FlowLogField.PKT_DSTADDR | PKT_DSTADDR}
+        :see: https://docs.aws.amazon.com/athena/latest/ug/json.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "DSTADDR"))
+        return typing.cast("DataFormat", jsii.sget(cls, "JSON"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="DSTPORT")
-    def DSTPORT(cls) -> "FlowLogField":
-        '''The destination port of the traffic.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "DSTPORT"))
+    @jsii.member(jsii_name="LOGSTASH")
+    def LOGSTASH(cls) -> "DataFormat":
+        '''DataFormat for Logstash Logs, using the GROK SerDe.
+
+        :see: https://docs.aws.amazon.com/athena/latest/ug/grok.html
+        '''
+        return typing.cast("DataFormat", jsii.sget(cls, "LOGSTASH"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="END")
-    def END(cls) -> "FlowLogField":
-        '''The time, in Unix seconds, when the last packet of the flow was received within the aggregation interval.
+    @jsii.member(jsii_name="ORC")
+    def ORC(cls) -> "DataFormat":
+        '''DataFormat for Apache ORC (Optimized Row Columnar).
 
-        This might be up to 60
-        seconds after the packet was transmitted or received on the network
-        interface.
+        :see: https://docs.aws.amazon.com/athena/latest/ug/orc.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "END"))
+        return typing.cast("DataFormat", jsii.sget(cls, "ORC"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="FLOW_DIRECTION")
-    def FLOW_DIRECTION(cls) -> "FlowLogField":
-        '''The direction of the flow with respect to the interface where traffic is captured.
+    @jsii.member(jsii_name="PARQUET")
+    def PARQUET(cls) -> "DataFormat":
+        '''DataFormat for Apache Parquet.
 
-        The possible values are: ingress | egress.
+        :see: https://docs.aws.amazon.com/athena/latest/ug/parquet.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "FLOW_DIRECTION"))
+        return typing.cast("DataFormat", jsii.sget(cls, "PARQUET"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="INSTANCE_ID")
-    def INSTANCE_ID(cls) -> "FlowLogField":
-        '''The ID of the instance that's associated with network interface for which the traffic is recorded, if the instance is owned by you.
-
-        Returns
-        a '-' symbol for a requester-managed network interface; for example,
-        the network interface for a NAT gateway.
+    @jsii.member(jsii_name="TSV")
+    def TSV(cls) -> "DataFormat":
+        '''DataFormat for TSV (Tab-Separated Values).
 
-        See also:
-        `Request-managed ENI <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/requester-managed-eni.html>`_
+        :see: https://docs.aws.amazon.com/athena/latest/ug/lazy-simple-serde.html
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "INSTANCE_ID"))
+        return typing.cast("DataFormat", jsii.sget(cls, "TSV"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="INTERFACE_ID")
-    def INTERFACE_ID(cls) -> "FlowLogField":
-        '''The ID of the network interface for which the traffic is recorded.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "INTERFACE_ID"))
+    @builtins.property
+    @jsii.member(jsii_name="inputFormat")
+    def input_format(self) -> "InputFormat":
+        '''``InputFormat`` for this data format.'''
+        return typing.cast("InputFormat", jsii.get(self, "inputFormat"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="LOG_STATUS")
-    def LOG_STATUS(cls) -> "FlowLogField":
-        '''The logging status of the flow log:.
+    @builtins.property
+    @jsii.member(jsii_name="outputFormat")
+    def output_format(self) -> "OutputFormat":
+        '''``OutputFormat`` for this data format.'''
+        return typing.cast("OutputFormat", jsii.get(self, "outputFormat"))
 
-        OK: Data is logging normally to the chosen destinations.
-        NODATA: There was no network traffic to or from the network interface
-        during the aggregation interval.
-        SKIPDATA — Some flow log records were skipped during the aggregation
-        interval. This might be because of an internal capacity constraint, or
-        an internal error.
-        '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "LOG_STATUS"))
+    @builtins.property
+    @jsii.member(jsii_name="serializationLibrary")
+    def serialization_library(self) -> "SerializationLibrary":
+        '''Serialization library for this data format.'''
+        return typing.cast("SerializationLibrary", jsii.get(self, "serializationLibrary"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PACKETS")
-    def PACKETS(cls) -> "FlowLogField":
-        '''The number of packets transferred during the flow.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PACKETS"))
+    @builtins.property
+    @jsii.member(jsii_name="classificationString")
+    def classification_string(self) -> typing.Optional[ClassificationString]:
+        '''Classification string given to tables with this data format.'''
+        return typing.cast(typing.Optional[ClassificationString], jsii.get(self, "classificationString"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PKT_DST_AWS_SERVICE")
-    def PKT_DST_AWS_SERVICE(cls) -> "FlowLogField":
-        '''The name of the subset of IP address ranges for the pkt-dstaddr field, if the destination IP address is for an AWS service.
 
-        For a list of
-        possible values, see the {@link FlowLogField.PKT_SRC_AWS_SERVICE | PKT_SRC_AWS_SERVICE} field.
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.DataFormatProps",
+    jsii_struct_bases=[],
+    name_mapping={
+        "input_format": "inputFormat",
+        "output_format": "outputFormat",
+        "serialization_library": "serializationLibrary",
+        "classification_string": "classificationString",
+    },
+)
+class DataFormatProps:
+    def __init__(
+        self,
+        *,
+        input_format: "InputFormat",
+        output_format: "OutputFormat",
+        serialization_library: "SerializationLibrary",
+        classification_string: typing.Optional[ClassificationString] = None,
+    ) -> None:
+        '''Properties of a DataFormat instance.
+
+        :param input_format: ``InputFormat`` for this data format.
+        :param output_format: ``OutputFormat`` for this data format.
+        :param serialization_library: Serialization library for this data format.
+        :param classification_string: Classification string given to tables with this data format. Default: - No classification is specified.
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_DST_AWS_SERVICE"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dbf6d8049cc8299102bda3d0f4fcaafe4f62969715f5334320a23b3330bfc2e5)
+            check_type(argname="argument input_format", value=input_format, expected_type=type_hints["input_format"])
+            check_type(argname="argument output_format", value=output_format, expected_type=type_hints["output_format"])
+            check_type(argname="argument serialization_library", value=serialization_library, expected_type=type_hints["serialization_library"])
+            check_type(argname="argument classification_string", value=classification_string, expected_type=type_hints["classification_string"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "input_format": input_format,
+            "output_format": output_format,
+            "serialization_library": serialization_library,
+        }
+        if classification_string is not None:
+            self._values["classification_string"] = classification_string
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PKT_DSTADDR")
-    def PKT_DSTADDR(cls) -> "FlowLogField":
-        '''The packet-level (original) destination IP address for the traffic.
+    @builtins.property
+    def input_format(self) -> "InputFormat":
+        '''``InputFormat`` for this data format.'''
+        result = self._values.get("input_format")
+        assert result is not None, "Required property 'input_format' is missing"
+        return typing.cast("InputFormat", result)
+
+    @builtins.property
+    def output_format(self) -> "OutputFormat":
+        '''``OutputFormat`` for this data format.'''
+        result = self._values.get("output_format")
+        assert result is not None, "Required property 'output_format' is missing"
+        return typing.cast("OutputFormat", result)
 
-        Use
-        this field with the dstaddr field to distinguish between the IP address
-        of an intermediate layer through which traffic flows, and the final
-        destination IP address of the traffic. For example, when traffic flows
-        through a network interface for a NAT gateway, or where the IP address
-        of a pod in Amazon EKS is different from the IP address of the network
-        interface of the instance node on which the pod is running (for
-        communication within a VPC).
+    @builtins.property
+    def serialization_library(self) -> "SerializationLibrary":
+        '''Serialization library for this data format.'''
+        result = self._values.get("serialization_library")
+        assert result is not None, "Required property 'serialization_library' is missing"
+        return typing.cast("SerializationLibrary", result)
 
-        See also:
-        `Flow Log Example NAT <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-nat>`_
+    @builtins.property
+    def classification_string(self) -> typing.Optional[ClassificationString]:
+        '''Classification string given to tables with this data format.
+
+        :default: - No classification is specified.
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_DSTADDR"))
+        result = self._values.get("classification_string")
+        return typing.cast(typing.Optional[ClassificationString], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PKT_SRC_AWS_SERVICE")
-    def PKT_SRC_AWS_SERVICE(cls) -> "FlowLogField":
-        '''The name of the subset of IP address ranges for the pkt-srcaddr field, if the source IP address is for an AWS service.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "DataFormatProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class Database(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.Database",
+):
+    '''Creates a Glue Database resource to contain a collection of metadata Tables.
+
+    :see: [AWS::Glue::Database](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-database.html
+    '''
 
-        The possible values
-        are: AMAZON | AMAZON_APPFLOW | AMAZON_CONNECT | API_GATEWAY |
-        CHIME_MEETINGS | CHIME_VOICECONNECTOR | CLOUD9 | CLOUDFRONT |
-        CODEBUILD | DYNAMODB | EBS | EC2 | EC2_INSTANCE_CONNECT |
-        GLOBALACCELERATOR | KINESIS_VIDEO_STREAMS | ROUTE53 |
-        ROUTE53_HEALTHCHECKS | ROUTE53_HEALTHCHECKS_PUBLISHING |
-        ROUTE53_RESOLVER | S3 | WORKSPACES_GATEWAYS.
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+        location_uri: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the Database class.
+
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param description: A description of the database.
+        :param location_uri: The location of the database (for example, an HDFS path).
+        :param name: The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_SRC_AWS_SERVICE"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__45c3b158089c46e13d9c49f0ca36070229ef0a94859ba845783419cef5407fba)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = DatabaseProps(
+            description=description,
+            location_uri=location_uri,
+            name=name,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PKT_SRCADDR")
-    def PKT_SRCADDR(cls) -> "FlowLogField":
-        '''The packet-level (original) source IP address of the traffic.
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @builtins.property
+    @jsii.member(jsii_name="catalogArn")
+    def catalog_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "catalogArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="catalogId")
+    def catalog_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "catalogId"))
+
+    @builtins.property
+    @jsii.member(jsii_name="databaseArn")
+    def database_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "databaseArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="databaseName")
+    def database_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "databaseName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''{@link DatabaseProps.name:}.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
+
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnDatabase:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnDatabase, jsii.get(self, "resource"))
+
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link DatabaseProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+
+    @builtins.property
+    @jsii.member(jsii_name="locationUri")
+    def location_uri(self) -> typing.Optional[builtins.str]:
+        '''{@link DatabaseProps.locationUri}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locationUri"))
 
-        Use this
-        field with the srcaddr field to distinguish between the IP address of
-        an intermediate layer through which traffic flows, and the original
-        source IP address of the traffic. For example, when traffic flows
-        through a network interface for a NAT gateway, or where the IP address
-        of a pod in Amazon EKS is different from the IP address of the network
-        interface of the instance node on which the pod is running (for
-        communication within a VPC).
 
-        See also:
-        `Flow Log Example NAT <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-nat>`_
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.DatabaseProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "description": "description",
+        "location_uri": "locationUri",
+        "name": "name",
+    },
+)
+class DatabaseProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        description: typing.Optional[builtins.str] = None,
+        location_uri: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration for Database.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param description: A description of the database.
+        :param location_uri: The location of the database (for example, an HDFS path).
+        :param name: The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_SRCADDR"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0d611ab4143e7ce164987eed2bc3acb7d2232995b6cb14a3be53384f6c67d983)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument location_uri", value=location_uri, expected_type=type_hints["location_uri"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if description is not None:
+            self._values["description"] = description
+        if location_uri is not None:
+            self._values["location_uri"] = location_uri
+        if name is not None:
+            self._values["name"] = name
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PROTOCOL")
-    def PROTOCOL(cls) -> "FlowLogField":
-        '''The IANA protocol number of the traffic.
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        See also:
-        `Assigned Internet Protocol Numbers <http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_.
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "PROTOCOL"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="REGION")
-    def REGION(cls) -> "FlowLogField":
-        '''The Region that contains the network interface for which traffic is recorded.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "REGION"))
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="SRCADDR")
-    def SRCADDR(cls) -> "FlowLogField":
-        '''The source address for incoming traffic, or the IPv4 or IPv6 address of the network interface for outgoing traffic on the network interface.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        The IPv4 address of the network interface is always its private IPv4
-        address.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        See also:
-        {@link FlowLogField.PKT_SRCADDR | PKT_SRCADDR}
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "SRCADDR"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="SRCPORT")
-    def SRCPORT(cls) -> "FlowLogField":
-        '''The source port of the traffic.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "SRCPORT"))
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="START")
-    def START(cls) -> "FlowLogField":
-        '''The time, in Unix seconds, when the first packet of the flow was received within the aggregation interval.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        This might be up to 60
-        seconds after the packet was transmitted or received on the network
-        interface.
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "START"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="SUBLOCATION_ID")
-    def SUBLOCATION_ID(cls) -> "FlowLogField":
-        '''The ID of the sublocation that contains the network interface for which traffic is recorded.
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        If the traffic is not from a sublocation, the
-        record displays a '-' symbol for this field.
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "SUBLOCATION_ID"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="SUBLOCATION_TYPE")
-    def SUBLOCATION_TYPE(cls) -> "FlowLogField":
-        '''The type of sublocation that's returned in the sublocation-id field.
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description of the database.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        The possible values are: wavelength | outpost | localzone. If the
-        traffic is not from a sublocation, the record displays a '-' symbol
-        for this field.
+    @builtins.property
+    def location_uri(self) -> typing.Optional[builtins.str]:
+        '''The location of the database (for example, an HDFS path).
 
-        See also:
-        `Wavelength <https://aws.amazon.com/wavelength/>`_
-        `Outposts <https://docs.aws.amazon.com/outposts/latest/userguide/>`_
-        `Local Zones <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-local-zones>`_
+        :see: `AWS::Glue::Database DatabaseInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-databaseinput.html#cfn-glue-database-databaseinput-locationuri>`_
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "SUBLOCATION_TYPE"))
+        result = self._values.get("location_uri")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="SUBNET_ID")
-    def SUBNET_ID(cls) -> "FlowLogField":
-        '''The ID of the subnet that contains the network interface for which the traffic is recorded.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "SUBNET_ID"))
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the database.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="TCP_FLAGS")
-    def TCP_FLAGS(cls) -> "FlowLogField":
-        '''The bitmask value for the following TCP flags:.
+        For Hive compatibility, this is folded to lowercase when it is stored.
+        '''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        FIN: 1
-        SYN: 2
-        RST: 4
-        PSH: 8
-        ACK: 16
-        SYN-ACK: 18
-        URG: 32
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        When a flow log entry consists of only ACK packets, the flag value is
-        0, not 16.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        TCP flags can be OR-ed during the aggregation interval. For short
-        connections, the flags might be set on the same line in the flow log
-        record, for example, 19 for SYN-ACK and FIN, and 3 for SYN and FIN.
+    def __repr__(self) -> str:
+        return "DatabaseProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        See also:
-        `TCP Segment Structure <https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure>`_
-        `TCP Flag Sequence <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-tcp-flag>`_
-        '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "TCP_FLAGS"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="TRAFFIC_PATH")
-    def TRAFFIC_PATH(cls) -> "FlowLogField":
-        '''The path that egress traffic takes to the destination.
+@jsii.enum(jsii_type="cdk-extensions.glue.DeleteBehavior")
+class DeleteBehavior(enum.Enum):
+    DELETE_FROM_DATABASE = "DELETE_FROM_DATABASE"
+    DEPRECATE_IN_DATABASE = "DEPRECATE_IN_DATABASE"
+    LOG = "LOG"
+
 
-        To determine
-        whether the traffic is egress traffic, check the flow-direction field.
-        The possible values are as follows. If none of the values apply, the
-        field is set to -.
+class GlueVersion(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.GlueVersion"):
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, version: builtins.str) -> "GlueVersion":
+        '''Custom Glue version.
 
-        1: Through another resource in the same VPC
-        2: Through an internet gateway or a gateway VPC endpoint
-        3: Through a virtual private gateway
-        4: Through an intra-region VPC peering connection
-        5: Through an inter-region VPC peering connection
-        6: Through a local gateway
-        7: Through a gateway VPC endpoint (Nitro-based instances only)
-        8: Through an internet gateway (Nitro-based instances only)
+        :param version: custom version.
         '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "TRAFFIC_PATH"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__afef4db7c413ec6c4abe2a7c38e51c3df056fd2eba5fcd9b37a75a1490334595)
+            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
+        return typing.cast("GlueVersion", jsii.sinvoke(cls, "of", [version]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="TYPE")
-    def TYPE(cls) -> "FlowLogField":
-        '''The type of traffic. The possible values are: IPv4 | IPv6 | EFA.
-
-        See also:
-        `Elastic Fabric Adapter <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_
-        '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "TYPE"))
+    @jsii.member(jsii_name="V0_9")
+    def V0_9(cls) -> "GlueVersion":
+        '''Glue version using Spark 2.2.1 and Python 2.7.'''
+        return typing.cast("GlueVersion", jsii.sget(cls, "V0_9"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="VERSION")
-    def VERSION(cls) -> "FlowLogField":
-        '''The VPC Flow Logs version.
+    @jsii.member(jsii_name="V1_0")
+    def V1_0(cls) -> "GlueVersion":
+        '''Glue version using Spark 2.4.3, Python 2.7 and Python 3.6.'''
+        return typing.cast("GlueVersion", jsii.sget(cls, "V1_0"))
 
-        If you use the default format, the version
-        is 2. If you use a custom format, the version is the highest version
-        among the specified fields. For example, if you specify only fields
-        from version 2, the version is 2. If you specify a mixture of fields
-        from versions 2, 3, and 4, the version is 4.
-        '''
-        return typing.cast("FlowLogField", jsii.sget(cls, "VERSION"))
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="V2_0")
+    def V2_0(cls) -> "GlueVersion":
+        '''Glue version using Spark 2.4.3 and Python 3.7.'''
+        return typing.cast("GlueVersion", jsii.sget(cls, "V2_0"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="VPC_ID")
-    def VPC_ID(cls) -> "FlowLogField":
-        '''The ID of the VPC that contains the network interface for which the traffic is recorded.'''
-        return typing.cast("FlowLogField", jsii.sget(cls, "VPC_ID"))
+    @jsii.member(jsii_name="V3_0")
+    def V3_0(cls) -> "GlueVersion":
+        '''Glue version using Spark 3.1.1 and Python 3.7.'''
+        return typing.cast("GlueVersion", jsii.sget(cls, "V3_0"))
 
     @builtins.property
     @jsii.member(jsii_name="name")
     def name(self) -> builtins.str:
-        '''The name of the Flow Log field, as it should be used when building a format string.'''
+        '''The name of this GlueVersion, as expected by Job resource.'''
         return typing.cast(builtins.str, jsii.get(self, "name"))
 
+
+@jsii.interface(jsii_type="cdk-extensions.glue.ICrawler")
+class ICrawler(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
     @builtins.property
-    @jsii.member(jsii_name="type")
-    def type(self) -> FlowLogDataType:
-        '''The data type of the field as it would appear in Parquet.
+    @jsii.member(jsii_name="crawlerArn")
+    def crawler_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the crawler.'''
+        ...
+
+    @builtins.property
+    @jsii.member(jsii_name="crawlerName")
+    def crawler_name(self) -> builtins.str:
+        '''The name of the crawler.'''
+        ...
+
+
+class _ICrawlerProxy(
+    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
+):
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ICrawler"
+
+    @builtins.property
+    @jsii.member(jsii_name="crawlerArn")
+    def crawler_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the crawler.'''
+        return typing.cast(builtins.str, jsii.get(self, "crawlerArn"))
 
-        For
-        information on the type for various files, see documentation on the
-        `available fields <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-logs-fields>`_.
+    @builtins.property
+    @jsii.member(jsii_name="crawlerName")
+    def crawler_name(self) -> builtins.str:
+        '''The name of the crawler.'''
+        return typing.cast(builtins.str, jsii.get(self, "crawlerName"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ICrawler).__jsii_proxy_class__ = lambda : _ICrawlerProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.glue.ICrawlerTarget")
+class ICrawlerTarget(typing_extensions.Protocol):
+    @jsii.member(jsii_name="bind")
+    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
         '''
-        return typing.cast(FlowLogDataType, jsii.get(self, "type"))
+        :param crawler: -
+        '''
+        ...
 
 
-@jsii.enum(jsii_type="cdk-extensions.ec2.FlowLogFileFormat")
-class FlowLogFileFormat(enum.Enum):
-    '''The file format options for flow log files delivered to S3.
+class _ICrawlerTargetProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ICrawlerTarget"
 
-    :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
-    '''
+    @jsii.member(jsii_name="bind")
+    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
+        '''
+        :param crawler: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dd0bd4dee65916002df8546350cf43116d55f03d0052a252943557ca270bb18b)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [crawler]))
 
-    PARQUET = "PARQUET"
-    '''Apache Parquet is a columnar data format.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ICrawlerTarget).__jsii_proxy_class__ = lambda : _ICrawlerTargetProxy
 
-    Queries on data in Parquet
-    format are 10 to 100 times faster compared to queries on data in plain
-    text. Data in Parquet format with Gzip compression takes 20 percent less
-    storage space than plain text with Gzip compression.
-    '''
-    PLAIN_TEXT = "PLAIN_TEXT"
-    '''Plain text.
 
-    This is the default format.
-    '''
+@jsii.interface(jsii_type="cdk-extensions.glue.IJob")
+class IJob(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
+    '''Represnets a Glue Job in AWS.'''
 
+    @builtins.property
+    @jsii.member(jsii_name="jobArn")
+    def job_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the job.'''
+        ...
 
-class FlowLogFormat(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.FlowLogFormat",
+    @builtins.property
+    @jsii.member(jsii_name="jobName")
+    def job_name(self) -> builtins.str:
+        '''The name of the job.'''
+        ...
+
+
+class _IJobProxy(
+    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
 ):
-    def __init__(self, *fields: FlowLogField) -> None:
-        '''Creates a new instance of the FlowLogFormat class.
+    '''Represnets a Glue Job in AWS.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.IJob"
+
+    @builtins.property
+    @jsii.member(jsii_name="jobArn")
+    def job_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the job.'''
+        return typing.cast(builtins.str, jsii.get(self, "jobArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="jobName")
+    def job_name(self) -> builtins.str:
+        '''The name of the job.'''
+        return typing.cast(builtins.str, jsii.get(self, "jobName"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IJob).__jsii_proxy_class__ = lambda : _IJobProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.glue.ITrigger")
+class ITrigger(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
+    '''Represents a Glue Trigger in AWS.'''
+
+    @builtins.property
+    @jsii.member(jsii_name="triggerArn")
+    def trigger_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the trigger.'''
+        ...
+
+    @builtins.property
+    @jsii.member(jsii_name="triggerName")
+    def trigger_name(self) -> builtins.str:
+        '''The name of the trigger.'''
+        ...
 
-        :param fields: The fields that should be included in the flow log output.
+
+class _ITriggerProxy(
+    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
+):
+    '''Represents a Glue Trigger in AWS.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITrigger"
+
+    @builtins.property
+    @jsii.member(jsii_name="triggerArn")
+    def trigger_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the trigger.'''
+        return typing.cast(builtins.str, jsii.get(self, "triggerArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="triggerName")
+    def trigger_name(self) -> builtins.str:
+        '''The name of the trigger.'''
+        return typing.cast(builtins.str, jsii.get(self, "triggerName"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITrigger).__jsii_proxy_class__ = lambda : _ITriggerProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.glue.ITriggerAction")
+class ITriggerAction(typing_extensions.Protocol):
+    '''Represents an action that should be taken when a trigger is executed.'''
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
+        '''
+        :param scope: -
+        '''
+        ...
+
+
+class _ITriggerActionProxy:
+    '''Represents an action that should be taken when a trigger is executed.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITriggerAction"
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
+        '''
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__011095d32393e36e81237f11a84f5543e965a7ff361a20975a530a17197f4a8e)
-            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        jsii.create(self.__class__, self, [*fields])
+            type_hints = typing.get_type_hints(_typecheckingstub__ee93cfcd69490826c39480651b7eb34877d0667604b0e14daf995218173ee126)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
 
-    @jsii.member(jsii_name="fromTemplate")
-    @builtins.classmethod
-    def from_template(cls, template: builtins.str) -> "FlowLogFormat":
-        '''Parses a flow log format template string to create a new FlowLogFormat object.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITriggerAction).__jsii_proxy_class__ = lambda : _ITriggerActionProxy
 
-        :param template: A flow log template string to parse.
 
-        :return: A FlowLogFormat object representing the passed template.
+@jsii.interface(jsii_type="cdk-extensions.glue.ITriggerPredicate")
+class ITriggerPredicate(typing_extensions.Protocol):
+    '''Represents a precondition that must be satisfied in order for a trigger to be executed.'''
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+        '''
+        :param scope: -
+        '''
+        ...
+
+
+class _ITriggerPredicateProxy:
+    '''Represents a precondition that must be satisfied in order for a trigger to be executed.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITriggerPredicate"
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+        '''
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5cb1f7019aee739ea8276bab9a93a7e6f40b4ebf40d15497239b2c6b1676033e)
-            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
-        return typing.cast("FlowLogFormat", jsii.sinvoke(cls, "fromTemplate", [template]))
+            type_hints = typing.get_type_hints(_typecheckingstub__2c73437c9e4d3b35bea065e54ce75f4a15077ddc17412786ea8a173cc1fadd1c)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITriggerPredicate).__jsii_proxy_class__ = lambda : _ITriggerPredicateProxy
 
-    @jsii.member(jsii_name="addField")
-    def add_field(self, field: FlowLogField) -> None:
-        '''Adds a new field to the flow log output.
 
-        New fields are added at the
-        end of a log entry after all the other fields that came before it.
+class InputFormat(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.InputFormat"):
+    '''Absolute class name of the Hadoop ``InputFormat`` to use when reading table files.'''
 
-        :param field: The field to add to the FlowLogFormat.
+    def __init__(self, class_name: builtins.str) -> None:
+        '''
+        :param class_name: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__79cf487bf8fa03e8840d7c2097f578bf3849b50872d93bdad4cc33d93380f5cd)
-            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
-        return typing.cast(None, jsii.invoke(self, "addField", [field]))
+            type_hints = typing.get_type_hints(_typecheckingstub__f47e29abee492d68598cef1aaeaafad27d809225eb3fede0aba56962510025d0)
+            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
+        jsii.create(self.__class__, self, [class_name])
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V2")
-    def V2(cls) -> "FlowLogFormat":
-        '''The basic set of fields included in most flow logs.
+    @jsii.member(jsii_name="AVRO")
+    def AVRO(cls) -> "InputFormat":
+        '''InputFormat for Avro files.
 
-        This is the default
-        format that is used when new flow logs are created without specifying a
-        custom format.
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/avro/AvroContainerInputFormat.html
         '''
-        return typing.cast("FlowLogFormat", jsii.sget(cls, "V2"))
+        return typing.cast("InputFormat", jsii.sget(cls, "AVRO"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V3")
-    def V3(cls) -> "FlowLogFormat":
-        '''Includes all the fields available in V2.
+    @jsii.member(jsii_name="CLOUDTRAIL")
+    def CLOUDTRAIL(cls) -> "InputFormat":
+        '''InputFormat for Cloudtrail Logs.
 
-        Adds fields to help identify
-        AWS resources associated with traffic as well as fields that give
-        greater visibility into protocol specific details.
+        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
         '''
-        return typing.cast("FlowLogFormat", jsii.sget(cls, "V3"))
+        return typing.cast("InputFormat", jsii.sget(cls, "CLOUDTRAIL"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V4")
-    def V4(cls) -> "FlowLogFormat":
-        '''Includes all the fields available in V3.
+    @jsii.member(jsii_name="ORC")
+    def ORC(cls) -> "InputFormat":
+        '''InputFormat for Orc files.
 
-        Adds fields for identifying
-        the region and availabilty zone associated with flows, as well as
-        details related to extended zones such as Wavelength, Outputs, and
-        Local Zones.
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcInputFormat.html
         '''
-        return typing.cast("FlowLogFormat", jsii.sget(cls, "V4"))
+        return typing.cast("InputFormat", jsii.sget(cls, "ORC"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V5")
-    def V5(cls) -> "FlowLogFormat":
-        '''Includes all the fields available in V4.
+    @jsii.member(jsii_name="PARQUET")
+    def PARQUET(cls) -> "InputFormat":
+        '''InputFormat for Parquet files.
 
-        Adds fields to help identify
-        related AWS services and improve visibility into packet routing.
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/MapredParquetInputFormat.html
         '''
-        return typing.cast("FlowLogFormat", jsii.sget(cls, "V5"))
+        return typing.cast("InputFormat", jsii.sget(cls, "PARQUET"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="TEXT")
+    def TEXT(cls) -> "InputFormat":
+        '''An InputFormat for plain text files.
+
+        Files are broken into lines. Either linefeed or
+        carriage-return are used to signal end of line. Keys are the position in the file, and
+        values are the line of text.
+        JSON & CSV files are examples of this InputFormat
+
+        :see: https://hadoop.apache.org/docs/stable/api/org/apache/hadoop/mapred/TextInputFormat.html
+        '''
+        return typing.cast("InputFormat", jsii.sget(cls, "TEXT"))
 
     @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.List[FlowLogField]:
-        '''The fields that make up the flow log format, in the order that they should appear in the log entries.'''
-        return typing.cast(typing.List[FlowLogField], jsii.get(self, "fields"))
+    @jsii.member(jsii_name="className")
+    def class_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "className"))
+
+
+class JdbcConnection(
+    Connection,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.JdbcConnection",
+):
+    '''Creates a Connection resource to a Java Database.
+
+    :see: `AWS::Glue::Connection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html>`_
+    '''
+
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        password: _aws_cdk_ceddda9d.SecretValue,
+        url: builtins.str,
+        username: builtins.str,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        description: typing.Optional[builtins.str] = None,
+        enforce_ssl: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the JdbcConnection class.
+
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param password: A SecretValue providing the password for the Connection to authenticate to the source with.
+        :param url: The URL to the source for the Connection.
+        :param username: The username for the Connection to authenticate to the source with.
+        :param vpc: VPC to attach to the Connection.
+        :param description: A description of the Connection.
+        :param enforce_ssl: Boolean value on whether to require encryption on the Connection.
+        :param name: A name for the Connection.
+        :param security_groups: A list of Security Groups to apply to the Connection.
+        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ea4b4cdb8cc43abef69d5aa672a86888b62abf53d134ac73a8ae113ee5f35600)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = JdbcConnectionProps(
+            password=password,
+            url=url,
+            username=username,
+            vpc=vpc,
+            description=description,
+            enforce_ssl=enforce_ssl,
+            name=name,
+            security_groups=security_groups,
+            subnets=subnets,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [scope, id, props])
 
     @builtins.property
-    @jsii.member(jsii_name="template")
-    def template(self) -> builtins.str:
-        '''The rendered format string in the format expected by AWS when creating a new Flow Log.'''
-        return typing.cast(builtins.str, jsii.get(self, "template"))
+    @jsii.member(jsii_name="password")
+    def password(self) -> _aws_cdk_ceddda9d.SecretValue:
+        '''{@link JdbcConnectionProps.password:}.'''
+        return typing.cast(_aws_cdk_ceddda9d.SecretValue, jsii.get(self, "password"))
+
+    @builtins.property
+    @jsii.member(jsii_name="url")
+    def url(self) -> builtins.str:
+        '''{@link JdbcConnectionProps.url:}.'''
+        return typing.cast(builtins.str, jsii.get(self, "url"))
+
+    @builtins.property
+    @jsii.member(jsii_name="username")
+    def username(self) -> builtins.str:
+        '''{@link JdbcConnectionProps.username:}.'''
+        return typing.cast(builtins.str, jsii.get(self, "username"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.FlowLogProps",
+    jsii_type="cdk-extensions.glue.JdbcConnectionProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "resource_type": "resourceType",
-        "destination": "destination",
-        "flow_log_name": "flowLogName",
-        "log_format": "logFormat",
-        "max_aggregation_interval": "maxAggregationInterval",
-        "traffic_type": "trafficType",
+        "password": "password",
+        "url": "url",
+        "username": "username",
+        "vpc": "vpc",
+        "description": "description",
+        "enforce_ssl": "enforceSsl",
+        "name": "name",
+        "security_groups": "securityGroups",
+        "subnets": "subnets",
     },
 )
-class FlowLogProps(_aws_cdk_ceddda9d.ResourceProps):
+class JdbcConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
-        destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
-        flow_log_name: typing.Optional[builtins.str] = None,
-        log_format: typing.Optional[FlowLogFormat] = None,
-        max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
-        traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
+        password: _aws_cdk_ceddda9d.SecretValue,
+        url: builtins.str,
+        username: builtins.str,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        description: typing.Optional[builtins.str] = None,
+        enforce_ssl: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
     ) -> None:
-        '''Configuration for the FlowLog class.
+        '''Configuration for the Glue Workflow resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param resource_type: Details for the resource from which flow logs will be captured.
-        :param destination: The location where flow logs should be delivered.
-        :param flow_log_name: The name of the FlowLog.
-        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see {@link FlowLogField}.
-        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
-        :param traffic_type: The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
+        :param password: A SecretValue providing the password for the Connection to authenticate to the source with.
+        :param url: The URL to the source for the Connection.
+        :param username: The username for the Connection to authenticate to the source with.
+        :param vpc: VPC to attach to the Connection.
+        :param description: A description of the Connection.
+        :param enforce_ssl: Boolean value on whether to require encryption on the Connection.
+        :param name: A name for the Connection.
+        :param security_groups: A list of Security Groups to apply to the Connection.
+        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
         '''
+        if isinstance(subnets, dict):
+            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ab60db00df2ad42cfdeb4bac9052956c6ceecbdc94e94e83e7a5b1a8d4db724f)
+            type_hints = typing.get_type_hints(_typecheckingstub__63235443ef95630aeef4ec6db0d062a07b1671eb3853e7158c18ed47070ed58a)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
-            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
-            check_type(argname="argument flow_log_name", value=flow_log_name, expected_type=type_hints["flow_log_name"])
-            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
-            check_type(argname="argument max_aggregation_interval", value=max_aggregation_interval, expected_type=type_hints["max_aggregation_interval"])
-            check_type(argname="argument traffic_type", value=traffic_type, expected_type=type_hints["traffic_type"])
+            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
+            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
+            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument enforce_ssl", value=enforce_ssl, expected_type=type_hints["enforce_ssl"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
+            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "resource_type": resource_type,
+            "password": password,
+            "url": url,
+            "username": username,
+            "vpc": vpc,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if destination is not None:
-            self._values["destination"] = destination
-        if flow_log_name is not None:
-            self._values["flow_log_name"] = flow_log_name
-        if log_format is not None:
-            self._values["log_format"] = log_format
-        if max_aggregation_interval is not None:
-            self._values["max_aggregation_interval"] = max_aggregation_interval
-        if traffic_type is not None:
-            self._values["traffic_type"] = traffic_type
+        if description is not None:
+            self._values["description"] = description
+        if enforce_ssl is not None:
+            self._values["enforce_ssl"] = enforce_ssl
+        if name is not None:
+            self._values["name"] = name
+        if security_groups is not None:
+            self._values["security_groups"] = security_groups
+        if subnets is not None:
+            self._values["subnets"] = subnets
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -1236,1866 +2549,3002 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def resource_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType:
-        '''Details for the resource from which flow logs will be captured.
+    def password(self) -> _aws_cdk_ceddda9d.SecretValue:
+        '''A SecretValue providing the password for the Connection to authenticate to the source with.
 
-        :see: `FlowLog ResourceType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype>`_
-        :group: Inputs
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
         '''
-        result = self._values.get("resource_type")
-        assert result is not None, "Required property 'resource_type' is missing"
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType, result)
+        result = self._values.get("password")
+        assert result is not None, "Required property 'password' is missing"
+        return typing.cast(_aws_cdk_ceddda9d.SecretValue, result)
 
     @builtins.property
-    def destination(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination]:
-        '''The location where flow logs should be delivered.
+    def url(self) -> builtins.str:
+        '''The URL to the source for the Connection.
 
-        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
-        :group: Inputs
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
         '''
-        result = self._values.get("destination")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination], result)
+        result = self._values.get("url")
+        assert result is not None, "Required property 'url' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def flow_log_name(self) -> typing.Optional[builtins.str]:
-        '''The name of the FlowLog.
+    def username(self) -> builtins.str:
+        '''The username for the Connection to authenticate to the source with.
 
-        :group: Inputs
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
         '''
-        result = self._values.get("flow_log_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("username")
+        assert result is not None, "Required property 'username' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def log_format(self) -> typing.Optional[FlowLogFormat]:
-        '''The fields to include in the flow log record, in the order in which they should appear.
-
-        For a list of available fields, see {@link FlowLogField}.
+    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
+        '''VPC to attach to the Connection.
 
-        :see: `FlowLog LogFormat <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat>`_
-        :group: Inputs
+        :see: `IVpc Interface <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.IVpc.html>`_
         '''
-        result = self._values.get("log_format")
-        return typing.cast(typing.Optional[FlowLogFormat], result)
+        result = self._values.get("vpc")
+        assert result is not None, "Required property 'vpc' is missing"
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
 
     @builtins.property
-    def max_aggregation_interval(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval]:
-        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description of the Connection.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: `FlowLog MaxAggregationInterval <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval>`_
-        :group: Inputs
+    @builtins.property
+    def enforce_ssl(self) -> typing.Optional[builtins.bool]:
+        '''Boolean value on whether to require encryption on the Connection.
+
+        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
         '''
-        result = self._values.get("max_aggregation_interval")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval], result)
+        result = self._values.get("enforce_ssl")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A name for the Connection.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def traffic_type(
+    def security_groups(
         self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType]:
-        '''The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
+        '''A list of Security Groups to apply to the Connection.'''
+        result = self._values.get("security_groups")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
 
-        :see: `FlowLog TrafficType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype>`_
-        :group: Inputs
+    @builtins.property
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''Options for selection of subnets from the VPC to attach to the Connection.
+
+        :see: `CDK SubnetSelection <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.SubnetSelection.html>`_
         '''
-        result = self._values.get("traffic_type")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType], result)
+        result = self._values.get("subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FlowLogProps(%s)" % ", ".join(
+        return "JdbcConnectionProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+@jsii.implements(ICrawlerTarget)
+class JdbcTarget(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.JdbcTarget"):
+    def __init__(
+        self,
+        connection: Connection,
+        *,
+        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        paths: typing.Optional[typing.Sequence[builtins.str]] = None,
+    ) -> None:
+        '''Creates a new instance of the JdbcTarget class.
+
+        :param connection: -
+        :param exclusions: A list of glob patterns used to exclude from the crawl. For more information
+        :param paths: The path of the JDBC target.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a5d7f10fe829e301eed5ff500477960d3c29565777d9d18780f32c7d84b383d7)
+            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
+        options = JdbcTargetOptions(exclusions=exclusions, paths=paths)
+
+        jsii.create(self.__class__, self, [connection, options])
+
+    @jsii.member(jsii_name="addExclusion")
+    def add_exclusion(self, exclusion: builtins.str) -> None:
+        '''
+        :param exclusion: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__da7fc3d4ccd69b3e6ec79ea8dc2f9c31784d1adaa1616006b1c552d243329288)
+            check_type(argname="argument exclusion", value=exclusion, expected_type=type_hints["exclusion"])
+        return typing.cast(None, jsii.invoke(self, "addExclusion", [exclusion]))
+
+    @jsii.member(jsii_name="addPath")
+    def add_path(self, path: builtins.str) -> None:
+        '''
+        :param path: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__92e89a811419b69c0f51822e3f45ff0bdd0ce6940b3afb1a59f04b14e85deab7)
+            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
+        return typing.cast(None, jsii.invoke(self, "addPath", [path]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(self, _crawler: "Crawler") -> CrawlerTargetCollection:
+        '''
+        :param _crawler: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__519dc5422365574c38b31da5db0adb61aaeabbe542682317cab78a331d1d6b96)
+            check_type(argname="argument _crawler", value=_crawler, expected_type=type_hints["_crawler"])
+        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [_crawler]))
+
+    @builtins.property
+    @jsii.member(jsii_name="connection")
+    def connection(self) -> Connection:
+        return typing.cast(Connection, jsii.get(self, "connection"))
+
+
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.FlowLogS3Options",
+    jsii_type="cdk-extensions.glue.JdbcTargetOptions",
     jsii_struct_bases=[],
-    name_mapping={
-        "file_format": "fileFormat",
-        "hive_compatible_partitions": "hiveCompatiblePartitions",
-        "key_prefix": "keyPrefix",
-        "per_hour_partition": "perHourPartition",
-    },
+    name_mapping={"exclusions": "exclusions", "paths": "paths"},
 )
-class FlowLogS3Options:
+class JdbcTargetOptions:
     def __init__(
         self,
         *,
-        file_format: typing.Optional[FlowLogFileFormat] = None,
-        hive_compatible_partitions: typing.Optional[builtins.bool] = None,
-        key_prefix: typing.Optional[builtins.str] = None,
-        per_hour_partition: typing.Optional[builtins.bool] = None,
+        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        paths: typing.Optional[typing.Sequence[builtins.str]] = None,
     ) -> None:
-        '''
-        :param file_format: The file format in which flow logs should be delivered to S3.
-        :param hive_compatible_partitions: Controls the format of partitions ("folders") when the flow logs are delivered to S3. By default, flow logs are delivered partitioned such that each part of the S3 path represents a values pertaining to details of the log. When hive compatible partitions are enabled, partitions will be structured such that keys declaring the partition name are added at each level. An example of standard partitioning:: /us-east-1/2020/03/08/log.tar.gz An example with Hive compatible partitions:: /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
-        :param key_prefix: An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
-        :param per_hour_partition: Indicates whether to partition the flow log per hour. By default, flow logs are partitioned (organized into S3 "folders") by day. Setting this to true will add an extra layer of directories splitting flow log files by the hour in which they were delivered.
+        '''Configuration for Crawler JDBC target.
+
+        :param exclusions: A list of glob patterns used to exclude from the crawl. For more information
+        :param paths: The path of the JDBC target.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7e005d34fc5ab0b60e83479b723ba4e2e86a135e05fd16b18daaac30743245ed)
-            check_type(argname="argument file_format", value=file_format, expected_type=type_hints["file_format"])
-            check_type(argname="argument hive_compatible_partitions", value=hive_compatible_partitions, expected_type=type_hints["hive_compatible_partitions"])
-            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
-            check_type(argname="argument per_hour_partition", value=per_hour_partition, expected_type=type_hints["per_hour_partition"])
+            type_hints = typing.get_type_hints(_typecheckingstub__b92268978767ce15062df3f1f0b702e354d0abf8d764ee0dbedb1952ccd5b8f7)
+            check_type(argname="argument exclusions", value=exclusions, expected_type=type_hints["exclusions"])
+            check_type(argname="argument paths", value=paths, expected_type=type_hints["paths"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if file_format is not None:
-            self._values["file_format"] = file_format
-        if hive_compatible_partitions is not None:
-            self._values["hive_compatible_partitions"] = hive_compatible_partitions
-        if key_prefix is not None:
-            self._values["key_prefix"] = key_prefix
-        if per_hour_partition is not None:
-            self._values["per_hour_partition"] = per_hour_partition
+        if exclusions is not None:
+            self._values["exclusions"] = exclusions
+        if paths is not None:
+            self._values["paths"] = paths
 
     @builtins.property
-    def file_format(self) -> typing.Optional[FlowLogFileFormat]:
-        '''The file format in which flow logs should be delivered to S3.
+    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''A list of glob patterns used to exclude from the crawl.
+
+        For more information
 
-        :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
+        :see: `Catalog Tables with a Crawler <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_
         '''
-        result = self._values.get("file_format")
-        return typing.cast(typing.Optional[FlowLogFileFormat], result)
+        result = self._values.get("exclusions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def hive_compatible_partitions(self) -> typing.Optional[builtins.bool]:
-        '''Controls the format of partitions ("folders") when the flow logs are delivered to S3.
+    def paths(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''The path of the JDBC target.
+
+        :see: `AWS::Glue::Crawler JdbcTarget <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-jdbctarget.html#cfn-glue-crawler-jdbctarget-path>`_
+        '''
+        result = self._values.get("paths")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        By default, flow logs are delivered partitioned such that each part of
-        the S3 path represents a values pertaining to details of the log.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        When hive compatible partitions are enabled, partitions will be
-        structured such that keys declaring the partition name are added at
-        each level.
+    def __repr__(self) -> str:
+        return "JdbcTargetOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        An example of standard partitioning::
 
-           /us-east-1/2020/03/08/log.tar.gz
+@jsii.implements(IJob)
+class Job(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.Job",
+):
+    '''Creates a Glue Job.
 
-        An example with Hive compatible partitions::
+    :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html>`_
+    '''
 
-           /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        executable: "JobExecutable",
+        allocated_capacity: typing.Optional[jsii.Number] = None,
+        connections: typing.Optional[typing.Sequence[Connection]] = None,
+        continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+        default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        description: typing.Optional[builtins.str] = None,
+        enable_profiling_metrics: typing.Optional[builtins.bool] = None,
+        max_capacity: typing.Optional[jsii.Number] = None,
+        max_concurrent_runs: typing.Optional[jsii.Number] = None,
+        max_retries: typing.Optional[jsii.Number] = None,
+        name: typing.Optional[builtins.str] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        security_configuration: typing.Optional["SecurityConfiguration"] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        worker_count: typing.Optional[jsii.Number] = None,
+        worker_type: typing.Optional["WorkerType"] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the Job class.
 
-        :see: `AWS Big Data Blog <https://aws.amazon.com/blogs/big-data/optimize-performance-and-reduce-costs-for-network-analytics-with-vpc-flow-logs-in-apache-parquet-format/>`_
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param executable: Executable properties for the Job.
+        :param allocated_capacity: The number of capacity units that are allocated to this job.
+        :param connections: List of Connections for use with this job.
+        :param continuous_logging: Set of properties for configuration of Continuous Logging.
+        :param default_arguments: The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param description: A description of the job.
+        :param enable_profiling_metrics: Boolean value for whether to enable Profiling Metrics.
+        :param max_capacity: The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:: - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
+        :param max_concurrent_runs: Maximum number of concurrent executions.
+        :param max_retries: The maximum number of times to retry this job after a JobRun fails.
+        :param name: A name for the Job.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param role: The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
+        :param security_configuration: The Security Configuration object to be applied to the Job.
+        :param timeout: The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
+        :param worker_count: The number of worker available the Job.
+        :param worker_type: The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("hive_compatible_partitions")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dfd3e838082701af10fa1c63f23e3acc6bf12935d1a61850f26bc4a6088bfcd6)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = JobProps(
+            executable=executable,
+            allocated_capacity=allocated_capacity,
+            connections=connections,
+            continuous_logging=continuous_logging,
+            default_arguments=default_arguments,
+            description=description,
+            enable_profiling_metrics=enable_profiling_metrics,
+            max_capacity=max_capacity,
+            max_concurrent_runs=max_concurrent_runs,
+            max_retries=max_retries,
+            name=name,
+            notify_delay_after=notify_delay_after,
+            role=role,
+            security_configuration=security_configuration,
+            timeout=timeout,
+            worker_count=worker_count,
+            worker_type=worker_type,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    def key_prefix(self) -> typing.Optional[builtins.str]:
-        '''An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="fromJobArn")
+    @builtins.classmethod
+    def from_job_arn(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        job_arn: builtins.str,
+    ) -> IJob:
+        '''Imports an existing job using its Amazon Resource Name (ARN).
 
-        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param job_arn: The ARN of the job to import.
+
+        :return: An object representing the job that was imported.
         '''
-        result = self._values.get("key_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6ad00a49f903b8ff296c1040af14b52c5c710377bccb726a03b7db29113abd37)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument job_arn", value=job_arn, expected_type=type_hints["job_arn"])
+        return typing.cast(IJob, jsii.sinvoke(cls, "fromJobArn", [scope, id, job_arn]))
 
-    @builtins.property
-    def per_hour_partition(self) -> typing.Optional[builtins.bool]:
-        '''Indicates whether to partition the flow log per hour.
+    @jsii.member(jsii_name="fromJobName")
+    @builtins.classmethod
+    def from_job_name(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        job_name: builtins.str,
+    ) -> IJob:
+        '''Imports an existing job using its name.
 
-        By default, flow logs are partitioned (organized into S3 "folders") by
-        day.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param job_name: The name of the job to import.
 
-        Setting this to true will add an extra layer of directories splitting
-        flow log files by the hour in which they were delivered.
+        :return: An object representing the job that was imported.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4b9945957a7dfb3942132fbf1eea0248c28d8f65d0f02d1af6fdcecafa689b66)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
+        return typing.cast(IJob, jsii.sinvoke(cls, "fromJobName", [scope, id, job_name]))
 
-        :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
+    @jsii.member(jsii_name="addArgument")
+    def add_argument(self, key: builtins.str, value: builtins.str) -> None:
         '''
-        result = self._values.get("per_hour_partition")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :param key: -
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__35613a54fa94475a1d6f92b6c0df6312b31ea05071004c65f6f6d6c38b3540b2)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addArgument", [key, value]))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="addConnection")
+    def add_connection(self, connection: Connection) -> None:
+        '''
+        :param connection: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9d6f7c32eed0df35efff9f38d209a916c1ac797af98a30c7d4b12c9945e72399)
+            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
+        return typing.cast(None, jsii.invoke(self, "addConnection", [connection]))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="executable")
+    def executable(self) -> "JobExecutable":
+        '''{@link JobProps.executable:}.'''
+        return typing.cast("JobExecutable", jsii.get(self, "executable"))
 
-    def __repr__(self) -> str:
-        return "FlowLogS3Options(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="jobArn")
+    def job_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the job.'''
+        return typing.cast(builtins.str, jsii.get(self, "jobArn"))
 
+    @builtins.property
+    @jsii.member(jsii_name="jobName")
+    def job_name(self) -> builtins.str:
+        '''The name of the job.'''
+        return typing.cast(builtins.str, jsii.get(self, "jobName"))
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ICustomerGateway")
-class ICustomerGateway(typing_extensions.Protocol):
-    '''Represents a customer gateway in AWS.'''
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnJob:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnJob, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayAsn")
-    def customer_gateway_asn(self) -> jsii.Number:
-        '''The BGP ASN of the customer gateway.'''
-        ...
+    @jsii.member(jsii_name="role")
+    def role(self) -> _aws_cdk_aws_iam_ceddda9d.IRole:
+        return typing.cast(_aws_cdk_aws_iam_ceddda9d.IRole, jsii.get(self, "role"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayId")
-    def customer_gateway_id(self) -> builtins.str:
-        '''The ID of the customer gateway.'''
-        ...
+    @jsii.member(jsii_name="allocatedCapacity")
+    def allocated_capacity(self) -> typing.Optional[jsii.Number]:
+        '''{@link JobProps.allocatedCapacity }.'''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocatedCapacity"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayIp")
-    def customer_gateway_ip(self) -> builtins.str:
-        '''The IP address of the customer gateway.'''
-        ...
+    @jsii.member(jsii_name="connections")
+    def connections(self) -> typing.Optional[typing.List[Connection]]:
+        '''{@link JobProps.connections}.'''
+        return typing.cast(typing.Optional[typing.List[Connection]], jsii.get(self, "connections"))
 
+    @builtins.property
+    @jsii.member(jsii_name="continuousLogging")
+    def continuous_logging(self) -> typing.Optional[ContinuousLoggingProps]:
+        '''{@link JobProps.continuousLogging}.'''
+        return typing.cast(typing.Optional[ContinuousLoggingProps], jsii.get(self, "continuousLogging"))
 
-class _ICustomerGatewayProxy:
-    '''Represents a customer gateway in AWS.'''
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link JobProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ICustomerGateway"
+    @builtins.property
+    @jsii.member(jsii_name="logGroup")
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], jsii.get(self, "logGroup"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayAsn")
-    def customer_gateway_asn(self) -> jsii.Number:
-        '''The BGP ASN of the customer gateway.'''
-        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
+    @jsii.member(jsii_name="maxCapacity")
+    def max_capacity(self) -> typing.Optional[jsii.Number]:
+        '''{@link JobProps.maxCapacity}.'''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxCapacity"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayId")
-    def customer_gateway_id(self) -> builtins.str:
-        '''The ID of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
+    @jsii.member(jsii_name="maxConcurrentRuns")
+    def max_concurrent_runs(self) -> typing.Optional[jsii.Number]:
+        '''{@link JobProps.maxConcurrentRuns}.'''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxConcurrentRuns"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayIp")
-    def customer_gateway_ip(self) -> builtins.str:
-        '''The IP address of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
+    @jsii.member(jsii_name="maxRetries")
+    def max_retries(self) -> typing.Optional[jsii.Number]:
+        '''{@link JobProps.maxRetries}.'''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxRetries"))
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ICustomerGateway).__jsii_proxy_class__ = lambda : _ICustomerGatewayProxy
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link JobProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
+    @builtins.property
+    @jsii.member(jsii_name="notifyDelayAfter")
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''{@link JobProps.notifyDelayAfter}.'''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "notifyDelayAfter"))
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ILocalVpnEndpoint")
-class ILocalVpnEndpoint(typing_extensions.Protocol):
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "LocalVpnEndpointConfiguration":
-        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+    @builtins.property
+    @jsii.member(jsii_name="securityConfiguration")
+    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
+        '''{@link JobProps.securityConfiguration}.'''
+        return typing.cast(typing.Optional["SecurityConfiguration"], jsii.get(self, "securityConfiguration"))
 
-        :param scope: The construct configuring the VPN connection that will be referencing the local endpoint.
-        '''
-        ...
+    @builtins.property
+    @jsii.member(jsii_name="timeout")
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''{@link JobProps.timeout}.'''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "timeout"))
 
+    @builtins.property
+    @jsii.member(jsii_name="workerCount")
+    def worker_count(self) -> typing.Optional[jsii.Number]:
+        '''{@link JobProps.workerCount}.'''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workerCount"))
 
-class _ILocalVpnEndpointProxy:
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ILocalVpnEndpoint"
+    @builtins.property
+    @jsii.member(jsii_name="workerType")
+    def worker_type(self) -> typing.Optional["WorkerType"]:
+        '''{@link JobProps.workerType}.'''
+        return typing.cast(typing.Optional["WorkerType"], jsii.get(self, "workerType"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.JobBookmarksEncryption",
+    jsii_struct_bases=[],
+    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
+)
+class JobBookmarksEncryption:
+    def __init__(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "LocalVpnEndpointConfiguration":
-        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+        *,
+        mode: "JobBookmarksEncryptionMode",
+        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+    ) -> None:
+        '''Job bookmarks encryption configuration.
 
-        :param scope: The construct configuring the VPN connection that will be referencing the local endpoint.
+        :param mode: Encryption mode.
+        :param kms_key: The KMS key to be used to encrypt the data. Default: A key will be created if one is not provided.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5f7fbf7fd0e305a60cc72790e4c2e467542eeb749b6ca114948036c7e283f4e3)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast("LocalVpnEndpointConfiguration", jsii.invoke(self, "bind", [scope]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ILocalVpnEndpoint).__jsii_proxy_class__ = lambda : _ILocalVpnEndpointProxy
+            type_hints = typing.get_type_hints(_typecheckingstub__de865e59b5a9d704335fa3900bcc2d054fc4bd594443f79fb978f7aecce4d7a2)
+            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
+            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "mode": mode,
+        }
+        if kms_key is not None:
+            self._values["kms_key"] = kms_key
 
+    @builtins.property
+    def mode(self) -> "JobBookmarksEncryptionMode":
+        '''Encryption mode.'''
+        result = self._values.get("mode")
+        assert result is not None, "Required property 'mode' is missing"
+        return typing.cast("JobBookmarksEncryptionMode", result)
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ILogDestination")
-class ILogDestination(typing_extensions.Protocol):
-    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
+    @builtins.property
+    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
+        '''The KMS key to be used to encrypt the data.
 
-    @jsii.member(jsii_name="bind")
-    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
+        :default: A key will be created if one is not provided.
         '''
-        :param scope: -
-        '''
-        ...
-
+        result = self._values.get("kms_key")
+        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
 
-class _ILogDestinationProxy:
-    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ILogDestination"
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @jsii.member(jsii_name="bind")
-    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
-        '''
-        :param scope: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__31e7dac1ec2cefa56a83155a4b3ff82206bfe5b1607d5af572c5d16cf98aba7a)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(FlowLogDestinationConfig, jsii.invoke(self, "bind", [scope]))
+    def __repr__(self) -> str:
+        return "JobBookmarksEncryption(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ILogDestination).__jsii_proxy_class__ = lambda : _ILogDestinationProxy
 
+@jsii.enum(jsii_type="cdk-extensions.glue.JobBookmarksEncryptionMode")
+class JobBookmarksEncryptionMode(enum.Enum):
+    '''Encryption mode for Job Bookmarks.
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.IRemoteVpnEndpoint")
-class IRemoteVpnEndpoint(typing_extensions.Protocol):
-    '''An object that can be used to retrieve the details for the remote end of a VPN connection.'''
+    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_JobBookmarksEncryption.html#Glue-Type-JobBookmarksEncryption-JobBookmarksEncryptionMode
+    '''
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "RemoteVpnEndpointConfiguration":
-        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
+    CLIENT_SIDE_KMS = "CLIENT_SIDE_KMS"
+    '''Client-side encryption (CSE) with an AWS KMS key managed by the account owner.
 
-        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
-        '''
-        ...
+    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingClientSideEncryption.html
+    '''
 
 
-class _IRemoteVpnEndpointProxy:
-    '''An object that can be used to retrieve the details for the remote end of a VPN connection.'''
+class JobExecutable(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.JobExecutable",
+):
+    '''The executable properties related to the Glue job's GlueVersion, JobType and code.'''
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IRemoteVpnEndpoint"
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(
+        cls,
+        *,
+        glue_version: GlueVersion,
+        language: "JobLanguage",
+        script: Code,
+        type: "JobType",
+        class_name: typing.Optional[builtins.str] = None,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+        python_version: typing.Optional["PythonVersion"] = None,
+    ) -> "JobExecutable":
+        '''Create a custom JobExecutable.
+
+        :param glue_version: Glue version.
+        :param language: The language of the job (Scala or Python).
+        :param script: The script that is executed by a job.
+        :param type: Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.
+        :param class_name: The Scala class that serves as the entry point for the job. This applies only if your the job langauage is Scala. Default: - no scala className specified
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Default: - no extra files specified.
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Default: - no extra jars specified.
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: - extra jars are not prioritized.
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Default: - no extra python files specified.
+        :param python_version: The Python version to use. Default: - no python version specified
+        '''
+        config = JobExecutableConfig(
+            glue_version=glue_version,
+            language=language,
+            script=script,
+            type=type,
+            class_name=class_name,
+            extra_files=extra_files,
+            extra_jars=extra_jars,
+            extra_jars_first=extra_jars_first,
+            extra_python_files=extra_python_files,
+            python_version=python_version,
+        )
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "RemoteVpnEndpointConfiguration":
-        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "of", [config]))
 
-        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f1c8cc16017de426ad6eb532d21e5db4c058f7a279485763c47026f54ff6b02a)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast("RemoteVpnEndpointConfiguration", jsii.invoke(self, "bind", [scope]))
+    @jsii.member(jsii_name="pythonEtl")
+    @builtins.classmethod
+    def python_etl(
+        cls,
+        *,
+        glue_version: GlueVersion,
+        python_version: "PythonVersion",
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+    ) -> "JobExecutable":
+        '''Create Python executable props for Apache Spark ETL job.
+
+        :param glue_version: Glue version.
+        :param python_version: The Python version to use.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
+        '''
+        props = PythonSparkJobExecutableProps(
+            glue_version=glue_version,
+            python_version=python_version,
+            script=script,
+            extra_files=extra_files,
+            extra_jars=extra_jars,
+            extra_jars_first=extra_jars_first,
+            extra_python_files=extra_python_files,
+        )
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IRemoteVpnEndpoint).__jsii_proxy_class__ = lambda : _IRemoteVpnEndpointProxy
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonEtl", [props]))
 
+    @jsii.member(jsii_name="pythonShell")
+    @builtins.classmethod
+    def python_shell(
+        cls,
+        *,
+        glue_version: GlueVersion,
+        python_version: "PythonVersion",
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+    ) -> "JobExecutable":
+        '''Create Python executable props for python shell jobs.
+
+        :param glue_version: Glue version.
+        :param python_version: The Python version to use.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
+        '''
+        props = PythonShellExecutableProps(
+            glue_version=glue_version,
+            python_version=python_version,
+            script=script,
+            extra_files=extra_files,
+            extra_python_files=extra_python_files,
+        )
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGateway")
-class ITransitGateway(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
-    '''Represents a transit gateway in AWS.'''
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonShell", [props]))
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayArn")
-    def transit_gateway_arn(self) -> builtins.str:
-        ...
+    @jsii.member(jsii_name="pythonStreaming")
+    @builtins.classmethod
+    def python_streaming(
+        cls,
+        *,
+        glue_version: GlueVersion,
+        python_version: "PythonVersion",
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+    ) -> "JobExecutable":
+        '''Create Python executable props for Apache Spark Streaming job.
+
+        :param glue_version: Glue version.
+        :param python_version: The Python version to use.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
+        '''
+        props = PythonSparkJobExecutableProps(
+            glue_version=glue_version,
+            python_version=python_version,
+            script=script,
+            extra_files=extra_files,
+            extra_jars=extra_jars,
+            extra_jars_first=extra_jars_first,
+            extra_python_files=extra_python_files,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayId")
-    def transit_gateway_id(self) -> builtins.str:
-        ...
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonStreaming", [props]))
 
-    @jsii.member(jsii_name="addRouteTable")
-    def add_route_table(
-        self,
+    @jsii.member(jsii_name="scalaEtl")
+    @builtins.classmethod
+    def scala_etl(
+        cls,
         *,
-        name: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayRouteTable":
-        '''
-        :param name: 
-        '''
-        ...
+        class_name: builtins.str,
+        glue_version: GlueVersion,
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+    ) -> "JobExecutable":
+        '''Create Scala executable props for Apache Spark ETL job.
+
+        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
+        :param glue_version: Glue version.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        '''
+        props = ScalaJobExecutableProps(
+            class_name=class_name,
+            glue_version=glue_version,
+            script=script,
+            extra_files=extra_files,
+            extra_jars=extra_jars,
+            extra_jars_first=extra_jars_first,
+        )
 
-    @jsii.member(jsii_name="addVpn")
-    def add_vpn(
-        self,
-        id: builtins.str,
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "scalaEtl", [props]))
+
+    @jsii.member(jsii_name="scalaStreaming")
+    @builtins.classmethod
+    def scala_streaming(
+        cls,
         *,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> "VpnConnection":
-        '''
-        :param id: -
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
-        '''
-        ...
+        class_name: builtins.str,
+        glue_version: GlueVersion,
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+    ) -> "JobExecutable":
+        '''Create Scala executable props for Apache Spark Streaming job.
+
+        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
+        :param glue_version: Glue version.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        '''
+        props = ScalaJobExecutableProps(
+            class_name=class_name,
+            glue_version=glue_version,
+            script=script,
+            extra_files=extra_files,
+            extra_jars=extra_jars,
+            extra_jars_first=extra_jars_first,
+        )
+
+        return typing.cast("JobExecutable", jsii.sinvoke(cls, "scalaStreaming", [props]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(self) -> "JobExecutableConfig":
+        '''Called during Job initialization to get JobExecutableConfig.'''
+        return typing.cast("JobExecutableConfig", jsii.invoke(self, "bind", []))
+
 
-    @jsii.member(jsii_name="attachVpc")
-    def attach_vpc(
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.JobExecutableConfig",
+    jsii_struct_bases=[],
+    name_mapping={
+        "glue_version": "glueVersion",
+        "language": "language",
+        "script": "script",
+        "type": "type",
+        "class_name": "className",
+        "extra_files": "extraFiles",
+        "extra_jars": "extraJars",
+        "extra_jars_first": "extraJarsFirst",
+        "extra_python_files": "extraPythonFiles",
+        "python_version": "pythonVersion",
+    },
+)
+class JobExecutableConfig:
+    def __init__(
         self,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
         *,
-        name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    ) -> "TransitGatewayAttachment":
+        glue_version: GlueVersion,
+        language: "JobLanguage",
+        script: Code,
+        type: "JobType",
+        class_name: typing.Optional[builtins.str] = None,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+        python_version: typing.Optional["PythonVersion"] = None,
+    ) -> None:
+        '''Result of binding a ``JobExecutable`` into a ``Job``.
+
+        :param glue_version: Glue version.
+        :param language: The language of the job (Scala or Python).
+        :param script: The script that is executed by a job.
+        :param type: Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.
+        :param class_name: The Scala class that serves as the entry point for the job. This applies only if your the job langauage is Scala. Default: - no scala className specified
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Default: - no extra files specified.
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Default: - no extra jars specified.
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: - extra jars are not prioritized.
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Default: - no extra python files specified.
+        :param python_version: The Python version to use. Default: - no python version specified
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__af760e5b293fa34ac6b256f1e0f627632acc4c0dd5000a33d11b6c7858e250ec)
+            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
+            check_type(argname="argument language", value=language, expected_type=type_hints["language"])
+            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
+            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
+            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
+            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
+            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
+            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "glue_version": glue_version,
+            "language": language,
+            "script": script,
+            "type": type,
+        }
+        if class_name is not None:
+            self._values["class_name"] = class_name
+        if extra_files is not None:
+            self._values["extra_files"] = extra_files
+        if extra_jars is not None:
+            self._values["extra_jars"] = extra_jars
+        if extra_jars_first is not None:
+            self._values["extra_jars_first"] = extra_jars_first
+        if extra_python_files is not None:
+            self._values["extra_python_files"] = extra_python_files
+        if python_version is not None:
+            self._values["python_version"] = python_version
+
+    @builtins.property
+    def glue_version(self) -> GlueVersion:
+        '''Glue version.
+
+        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
         '''
-        :param vpc: -
-        :param name: 
-        :param subnets: 
+        result = self._values.get("glue_version")
+        assert result is not None, "Required property 'glue_version' is missing"
+        return typing.cast(GlueVersion, result)
+
+    @builtins.property
+    def language(self) -> "JobLanguage":
+        '''The language of the job (Scala or Python).
+
+        :see: ``--job-language`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        ...
+        result = self._values.get("language")
+        assert result is not None, "Required property 'language' is missing"
+        return typing.cast("JobLanguage", result)
 
+    @builtins.property
+    def script(self) -> Code:
+        '''The script that is executed by a job.'''
+        result = self._values.get("script")
+        assert result is not None, "Required property 'script' is missing"
+        return typing.cast(Code, result)
 
-class _ITransitGatewayProxy(
-    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
-):
-    '''Represents a transit gateway in AWS.'''
+    @builtins.property
+    def type(self) -> "JobType":
+        '''Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.'''
+        result = self._values.get("type")
+        assert result is not None, "Required property 'type' is missing"
+        return typing.cast("JobType", result)
+
+    @builtins.property
+    def class_name(self) -> typing.Optional[builtins.str]:
+        '''The Scala class that serves as the entry point for the job.
+
+        This applies only if your the job langauage is Scala.
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGateway"
+        :default: - no scala className specified
+
+        :see: ``--class`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("class_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayArn")
-    def transit_gateway_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayArn"))
+    def extra_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+
+        :default: - no extra files specified.
+
+        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayId")
-    def transit_gateway_id(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))
+    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script.
 
-    @jsii.member(jsii_name="addRouteTable")
-    def add_route_table(
-        self,
-        *,
-        name: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayRouteTable":
+        :default: - no extra jars specified.
+
+        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        :param name: 
+        result = self._values.get("extra_jars")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
+
+    @builtins.property
+    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
+        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+
+        :default: - extra jars are not prioritized.
+
+        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        options = TransitGatewayRouteTableOptions(name=name)
+        result = self._values.get("extra_jars_first")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        return typing.cast("TransitGatewayRouteTable", jsii.invoke(self, "addRouteTable", [options]))
+    @builtins.property
+    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
 
-    @jsii.member(jsii_name="addVpn")
-    def add_vpn(
-        self,
-        id: builtins.str,
-        *,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> "VpnConnection":
+        :default: - no extra python files specified.
+
+        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        :param id: -
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
+        result = self._values.get("extra_python_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
+
+    @builtins.property
+    def python_version(self) -> typing.Optional["PythonVersion"]:
+        '''The Python version to use.
+
+        :default: - no python version specified
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3c530d4e033cb58d409cbdec91a29a99e796c6b5949a8fe0b776e9a57ebda677)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        options = VpnAttachmentOptions(
-            remote_endpoint=remote_endpoint,
-            connection_type=connection_type,
-            static_routes_only=static_routes_only,
-            tunnel_configurations=tunnel_configurations,
+        result = self._values.get("python_version")
+        return typing.cast(typing.Optional["PythonVersion"], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "JobExecutableConfig(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
         )
 
-        return typing.cast("VpnConnection", jsii.invoke(self, "addVpn", [id, options]))
 
-    @jsii.member(jsii_name="attachVpc")
-    def attach_vpc(
+@jsii.enum(jsii_type="cdk-extensions.glue.JobLanguage")
+class JobLanguage(enum.Enum):
+    PYTHON = "PYTHON"
+    '''Python.'''
+    SCALA = "SCALA"
+    '''Scala.'''
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.JobProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "executable": "executable",
+        "allocated_capacity": "allocatedCapacity",
+        "connections": "connections",
+        "continuous_logging": "continuousLogging",
+        "default_arguments": "defaultArguments",
+        "description": "description",
+        "enable_profiling_metrics": "enableProfilingMetrics",
+        "max_capacity": "maxCapacity",
+        "max_concurrent_runs": "maxConcurrentRuns",
+        "max_retries": "maxRetries",
+        "name": "name",
+        "notify_delay_after": "notifyDelayAfter",
+        "role": "role",
+        "security_configuration": "securityConfiguration",
+        "timeout": "timeout",
+        "worker_count": "workerCount",
+        "worker_type": "workerType",
+    },
+)
+class JobProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
         self,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
         *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        executable: JobExecutable,
+        allocated_capacity: typing.Optional[jsii.Number] = None,
+        connections: typing.Optional[typing.Sequence[Connection]] = None,
+        continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+        default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        description: typing.Optional[builtins.str] = None,
+        enable_profiling_metrics: typing.Optional[builtins.bool] = None,
+        max_capacity: typing.Optional[jsii.Number] = None,
+        max_concurrent_runs: typing.Optional[jsii.Number] = None,
+        max_retries: typing.Optional[jsii.Number] = None,
         name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    ) -> "TransitGatewayAttachment":
-        '''
-        :param vpc: -
-        :param name: 
-        :param subnets: 
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        security_configuration: typing.Optional["SecurityConfiguration"] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        worker_count: typing.Optional[jsii.Number] = None,
+        worker_type: typing.Optional["WorkerType"] = None,
+    ) -> None:
+        '''Configuration for the Glue Job resource.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param executable: Executable properties for the Job.
+        :param allocated_capacity: The number of capacity units that are allocated to this job.
+        :param connections: List of Connections for use with this job.
+        :param continuous_logging: Set of properties for configuration of Continuous Logging.
+        :param default_arguments: The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param description: A description of the job.
+        :param enable_profiling_metrics: Boolean value for whether to enable Profiling Metrics.
+        :param max_capacity: The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:: - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
+        :param max_concurrent_runs: Maximum number of concurrent executions.
+        :param max_retries: The maximum number of times to retry this job after a JobRun fails.
+        :param name: A name for the Job.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param role: The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
+        :param security_configuration: The Security Configuration object to be applied to the Job.
+        :param timeout: The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
+        :param worker_count: The number of worker available the Job.
+        :param worker_type: The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
         '''
+        if isinstance(continuous_logging, dict):
+            continuous_logging = ContinuousLoggingProps(**continuous_logging)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7e51602274287d74df7ba0b1c9462a003ef4081742f553f9fccc7d78f9e0f591)
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
-        options = VpcAttachmentOptions(name=name, subnets=subnets)
+            type_hints = typing.get_type_hints(_typecheckingstub__1a4f1e1b4bab338b9f8725cb2a2bdc60103a0fa9e50e731a94e0a34914c85e6e)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument executable", value=executable, expected_type=type_hints["executable"])
+            check_type(argname="argument allocated_capacity", value=allocated_capacity, expected_type=type_hints["allocated_capacity"])
+            check_type(argname="argument connections", value=connections, expected_type=type_hints["connections"])
+            check_type(argname="argument continuous_logging", value=continuous_logging, expected_type=type_hints["continuous_logging"])
+            check_type(argname="argument default_arguments", value=default_arguments, expected_type=type_hints["default_arguments"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument enable_profiling_metrics", value=enable_profiling_metrics, expected_type=type_hints["enable_profiling_metrics"])
+            check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
+            check_type(argname="argument max_concurrent_runs", value=max_concurrent_runs, expected_type=type_hints["max_concurrent_runs"])
+            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
+            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
+            check_type(argname="argument worker_count", value=worker_count, expected_type=type_hints["worker_count"])
+            check_type(argname="argument worker_type", value=worker_type, expected_type=type_hints["worker_type"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "executable": executable,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if allocated_capacity is not None:
+            self._values["allocated_capacity"] = allocated_capacity
+        if connections is not None:
+            self._values["connections"] = connections
+        if continuous_logging is not None:
+            self._values["continuous_logging"] = continuous_logging
+        if default_arguments is not None:
+            self._values["default_arguments"] = default_arguments
+        if description is not None:
+            self._values["description"] = description
+        if enable_profiling_metrics is not None:
+            self._values["enable_profiling_metrics"] = enable_profiling_metrics
+        if max_capacity is not None:
+            self._values["max_capacity"] = max_capacity
+        if max_concurrent_runs is not None:
+            self._values["max_concurrent_runs"] = max_concurrent_runs
+        if max_retries is not None:
+            self._values["max_retries"] = max_retries
+        if name is not None:
+            self._values["name"] = name
+        if notify_delay_after is not None:
+            self._values["notify_delay_after"] = notify_delay_after
+        if role is not None:
+            self._values["role"] = role
+        if security_configuration is not None:
+            self._values["security_configuration"] = security_configuration
+        if timeout is not None:
+            self._values["timeout"] = timeout
+        if worker_count is not None:
+            self._values["worker_count"] = worker_count
+        if worker_type is not None:
+            self._values["worker_type"] = worker_type
 
-        return typing.cast("TransitGatewayAttachment", jsii.invoke(self, "attachVpc", [vpc, options]))
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITransitGateway).__jsii_proxy_class__ = lambda : _ITransitGatewayProxy
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayAttachment")
-class ITransitGatewayAttachment(typing_extensions.Protocol):
-    '''Represents a Transit Gateway Attachment in AWS.'''
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of the transit gateway attachment.'''
-        ...
+        Cannot be supplied together with either ``account`` or ``region``.
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of the transit gateway attachment.'''
-        ...
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        cidr: builtins.str,
-        route_table: "ITransitGatewayRouteTable",
-    ) -> "ITransitGatewayRoute":
-        '''Adds a route that directs traffic to this transit gateway attachment.
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :param cidr: CIDR range that should be routed to this attachment.
-        :param route_table: The transit gateway route table where the route should be added.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :return: The TransitGatewayRoute that was added.
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        ...
-
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-class _ITransitGatewayAttachmentProxy:
-    '''Represents a Transit Gateway Attachment in AWS.'''
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayAttachment"
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of the transit gateway attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+    def executable(self) -> JobExecutable:
+        '''Executable properties for the Job.'''
+        result = self._values.get("executable")
+        assert result is not None, "Required property 'executable' is missing"
+        return typing.cast(JobExecutable, result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of the transit gateway attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
+    def allocated_capacity(self) -> typing.Optional[jsii.Number]:
+        '''The number of capacity units that are allocated to this job.
 
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        cidr: builtins.str,
-        route_table: "ITransitGatewayRouteTable",
-    ) -> "ITransitGatewayRoute":
-        '''Adds a route that directs traffic to this transit gateway attachment.
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-allocatedcapacity>`_
+        '''
+        result = self._values.get("allocated_capacity")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :param cidr: CIDR range that should be routed to this attachment.
-        :param route_table: The transit gateway route table where the route should be added.
+    @builtins.property
+    def connections(self) -> typing.Optional[typing.List[Connection]]:
+        '''List of Connections for use with this job.
 
-        :return: The TransitGatewayRoute that was added.
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-connections>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7b44f941842017d2d4c6c21860f08701108fc8a70636475b6b9ab6eb37332692)
-            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
-            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
-        return typing.cast("ITransitGatewayRoute", jsii.invoke(self, "addRoute", [cidr, route_table]))
+        result = self._values.get("connections")
+        return typing.cast(typing.Optional[typing.List[Connection]], result)
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITransitGatewayAttachment).__jsii_proxy_class__ = lambda : _ITransitGatewayAttachmentProxy
+    @builtins.property
+    def continuous_logging(self) -> typing.Optional[ContinuousLoggingProps]:
+        '''Set of properties for configuration of Continuous Logging.'''
+        result = self._values.get("continuous_logging")
+        return typing.cast(typing.Optional[ContinuousLoggingProps], result)
 
+    @builtins.property
+    def default_arguments(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''The default arguments for this job, specified as name-value pairs.
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayPeeringAttachment")
-class ITransitGatewayPeeringAttachment(
-    ITransitGatewayAttachment,
-    typing_extensions.Protocol,
-):
-    '''Represents a transit gateway route table in AWS.'''
+        You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
-    def transit_gateway_attachment_creation_time(self) -> builtins.str:
-        '''The time the transit gateway peering attachment was created.'''
-        ...
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-defaultarguments>`_
+        '''
+        result = self._values.get("default_arguments")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentState")
-    def transit_gateway_attachment_state(self) -> builtins.str:
-        '''The state of the transit gateway peering attachment.'''
-        ...
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description of the job.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
-    def transit_gateway_attachment_status(self) -> builtins.str:
-        '''The status of the transit gateway peering attachment.'''
-        ...
+    def enable_profiling_metrics(self) -> typing.Optional[builtins.bool]:
+        '''Boolean value for whether to enable Profiling Metrics.'''
+        result = self._values.get("enable_profiling_metrics")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
-    def transit_gateway_attachment_status_code(self) -> builtins.str:
-        '''The status code for the current status of the attachment.'''
-        ...
+    def max_capacity(self) -> typing.Optional[jsii.Number]:
+        '''The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs.
+
+        A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
+
+        Do not set Max Capacity if using WorkerType and NumberOfWorkers.
+
+        The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job::
+
+           - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
+
+           - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
+        '''
+        result = self._values.get("max_capacity")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
-    def transit_gateway_attachment_status_message(self) -> builtins.str:
-        '''The status message for the current status of the attachment.'''
-        ...
+    def max_concurrent_runs(self) -> typing.Optional[jsii.Number]:
+        '''Maximum number of concurrent executions.
 
+        :see: `AWS::Glue::Job ExecutionProperty <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-executionproperty.html>`_
+        '''
+        result = self._values.get("max_concurrent_runs")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-class _ITransitGatewayPeeringAttachmentProxy(
-    jsii.proxy_for(ITransitGatewayAttachment), # type: ignore[misc]
-):
-    '''Represents a transit gateway route table in AWS.'''
+    @builtins.property
+    def max_retries(self) -> typing.Optional[jsii.Number]:
+        '''The maximum number of times to retry this job after a JobRun fails.
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayPeeringAttachment"
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-maxretries>`_
+        '''
+        result = self._values.get("max_retries")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
-    def transit_gateway_attachment_creation_time(self) -> builtins.str:
-        '''The time the transit gateway peering attachment was created.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentCreationTime"))
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A name for the Job.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentState")
-    def transit_gateway_attachment_state(self) -> builtins.str:
-        '''The state of the transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentState"))
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+
+        :see: `AWS::Glue::Job NotificationProperty <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-notificationproperty.html>`_
+        '''
+        result = self._values.get("notify_delay_after")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
-    def transit_gateway_attachment_status(self) -> builtins.str:
-        '''The status of the transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatus"))
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''The name or Amazon Resource Name (ARN) of the IAM role associated with this job.'''
+        result = self._values.get("role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
-    def transit_gateway_attachment_status_code(self) -> builtins.str:
-        '''The status code for the current status of the attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusCode"))
+    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
+        '''The Security Configuration object to be applied to the Job.'''
+        result = self._values.get("security_configuration")
+        return typing.cast(typing.Optional["SecurityConfiguration"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
-    def transit_gateway_attachment_status_message(self) -> builtins.str:
-        '''The status message for the current status of the attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusMessage"))
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The job timeout in minutes.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITransitGatewayPeeringAttachment).__jsii_proxy_class__ = lambda : _ITransitGatewayPeeringAttachmentProxy
+        This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
 
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-timeout>`_
+        '''
+        result = self._values.get("timeout")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayRoute")
-class ITransitGatewayRoute(typing_extensions.Protocol):
-    '''Represents a Transit Gateway Route in AWS.'''
+    @builtins.property
+    def worker_count(self) -> typing.Optional[jsii.Number]:
+        '''The number of worker available the Job.'''
+        result = self._values.get("worker_count")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteId")
-    def transit_gateway_route_id(self) -> builtins.str:
-        '''The ID of the Transit Gateway Route.'''
-        ...
+    def worker_type(self) -> typing.Optional["WorkerType"]:
+        '''The type of predefined worker that is allocated when a job runs.
 
+        Accepts a value of Standard, G.1X, or G.2X.
 
-class _ITransitGatewayRouteProxy:
-    '''Represents a Transit Gateway Route in AWS.'''
+        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-workertype>`_
+        '''
+        result = self._values.get("worker_type")
+        return typing.cast(typing.Optional["WorkerType"], result)
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayRoute"
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteId")
-    def transit_gateway_route_id(self) -> builtins.str:
-        '''The ID of the Transit Gateway Route.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteId"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITransitGatewayRoute).__jsii_proxy_class__ = lambda : _ITransitGatewayRouteProxy
+    def __repr__(self) -> str:
+        return "JobProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayRouteTable")
-class ITransitGatewayRouteTable(typing_extensions.Protocol):
-    '''Represents a transit gateway route table in AWS.'''
+@jsii.enum(jsii_type="cdk-extensions.glue.JobState")
+class JobState(enum.Enum):
+    '''State a Glue job must be in in order to satisfy a predicate condition to trigger a part of a workflow.'''
+
+    FAILED = "FAILED"
+    '''A job that has finished and ended with an error.'''
+    STOPPED = "STOPPED"
+    '''A job which was stopped before completion.'''
+    SUCCEEDED = "SUCCEEDED"
+    '''A job which has finished successfully.'''
+    TIMEOUT = "TIMEOUT"
+    '''A job which timed out without completing.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableArn")
-    def transit_gateway_route_table_arn(self) -> builtins.str:
-        '''The ARN of the transit gateway route table.'''
-        ...
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableId")
-    def transit_gateway_route_table_id(self) -> builtins.str:
-        '''The ID of the transit gateway route table.'''
-        ...
+class JobType(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.JobType"):
+    '''The job type.
 
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        *,
-        cidr: builtins.str,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayRoute":
-        '''Adds a route to this transit gateway route table.
+    If you need to use a JobType that doesn't exist as a static member, you
+    can instantiate a ``JobType`` object, e.g: ``JobType.of('other name')``.
+    '''
 
-        :param cidr: The CIDR range to match for the route.
-        :param attachment: The transit gateway attachment where matched traffic should be routed.
-        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "JobType":
+        '''Custom type name.
+
+        :param name: type name.
         '''
-        ...
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2bde216e427f277dd4ae0752c5cd28002b668b82f2864e2962977e5314f9ec83)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("JobType", jsii.sinvoke(cls, "of", [name]))
 
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ETL")
+    def ETL(cls) -> "JobType":
+        '''Command for running a Glue ETL job.'''
+        return typing.cast("JobType", jsii.sget(cls, "ETL"))
 
-class _ITransitGatewayRouteTableProxy:
-    '''Represents a transit gateway route table in AWS.'''
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PYTHON_SHELL")
+    def PYTHON_SHELL(cls) -> "JobType":
+        '''Command for running a Glue python shell job.'''
+        return typing.cast("JobType", jsii.sget(cls, "PYTHON_SHELL"))
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayRouteTable"
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="STREAMING")
+    def STREAMING(cls) -> "JobType":
+        '''Command for running a Glue streaming job.'''
+        return typing.cast("JobType", jsii.sget(cls, "STREAMING"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableArn")
-    def transit_gateway_route_table_arn(self) -> builtins.str:
-        '''The ARN of the transit gateway route table.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableArn"))
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of this JobType, as expected by Job resource.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableId")
-    def transit_gateway_route_table_id(self) -> builtins.str:
-        '''The ID of the transit gateway route table.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))
 
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        *,
-        cidr: builtins.str,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayRoute":
-        '''Adds a route to this transit gateway route table.
+class OutputFormat(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.OutputFormat",
+):
+    '''Absolute class name of the Hadoop ``OutputFormat`` to use when writing table files.'''
 
-        :param cidr: The CIDR range to match for the route.
-        :param attachment: The transit gateway attachment where matched traffic should be routed.
-        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+    def __init__(self, class_name: builtins.str) -> None:
         '''
-        options = TransitGatewayRouteOptions(
-            cidr=cidr,
-            attachment=attachment,
-            blackhole=blackhole,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        :param class_name: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7922f5b0f22bd94cc964cabe57f17f7d870707d5d26e8c51a8683ee4a13f69f2)
+            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
+        jsii.create(self.__class__, self, [class_name])
 
-        return typing.cast("TransitGatewayRoute", jsii.invoke(self, "addRoute", [options]))
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="AVRO")
+    def AVRO(cls) -> InputFormat:
+        '''OutputFormat for Avro files.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITransitGatewayRouteTable).__jsii_proxy_class__ = lambda : _ITransitGatewayRouteTableProxy
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/avro/AvroContainerOutputFormat.html
+        '''
+        return typing.cast(InputFormat, jsii.sget(cls, "AVRO"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="HIVE_IGNORE_KEY_TEXT")
+    def HIVE_IGNORE_KEY_TEXT(cls) -> "OutputFormat":
+        '''Writes text data with a null key (value only).
+
+        :see: https://hive.apache.org/javadocs/r2.2.0/api/org/apache/hadoop/hive/ql/io/HiveIgnoreKeyTextOutputFormat.html
+        '''
+        return typing.cast("OutputFormat", jsii.sget(cls, "HIVE_IGNORE_KEY_TEXT"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ORC")
+    def ORC(cls) -> InputFormat:
+        '''OutputFormat for Orc files.
+
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcOutputFormat.html
+        '''
+        return typing.cast(InputFormat, jsii.sget(cls, "ORC"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PARQUET")
+    def PARQUET(cls) -> "OutputFormat":
+        '''OutputFormat for Parquet files.
+
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/MapredParquetOutputFormat.html
+        '''
+        return typing.cast("OutputFormat", jsii.sget(cls, "PARQUET"))
+
+    @builtins.property
+    @jsii.member(jsii_name="className")
+    def class_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "className"))
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.PartitionUpdateBehavior")
+class PartitionUpdateBehavior(enum.Enum):
+    INHERIT_FROM_TABLE = "INHERIT_FROM_TABLE"
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.PredicateLogicalOperator")
+class PredicateLogicalOperator(enum.Enum):
+    '''Logical operator that specifies how the conditions of a predicate should be evaluated.'''
+
+    EQUALS = "EQUALS"
+    '''State equals specified value.'''
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.PredicateOperator")
+class PredicateOperator(enum.Enum):
+    AND = "AND"
+    OR = "OR"
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.LocalVpnEndpointConfiguration",
+    jsii_type="cdk-extensions.glue.PythonShellExecutableProps",
     jsii_struct_bases=[],
     name_mapping={
-        "transit_gateway_id": "transitGatewayId",
-        "vpn_gateway_id": "vpnGatewayId",
+        "glue_version": "glueVersion",
+        "python_version": "pythonVersion",
+        "script": "script",
+        "extra_files": "extraFiles",
+        "extra_python_files": "extraPythonFiles",
     },
 )
-class LocalVpnEndpointConfiguration:
+class PythonShellExecutableProps:
     def __init__(
         self,
         *,
-        transit_gateway_id: typing.Optional[builtins.str] = None,
-        vpn_gateway_id: typing.Optional[builtins.str] = None,
+        glue_version: GlueVersion,
+        python_version: "PythonVersion",
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
     ) -> None:
-        '''Configuration object containing the vlues needed to configure the local end of a VPN connection.
+        '''Props for creating a Python shell job executable.
 
-        :param transit_gateway_id: The ID of the transit gateway that serves as the local end of the VPN connection.
-        :param vpn_gateway_id: The ID of the VPN gateway that serves as the local end of the VPN connection.
+        :param glue_version: Glue version.
+        :param python_version: The Python version to use.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c283c95ccb48c40fb03d7fffd4f63ce7927ef657d47052d65ed9aa32cbd6609a)
-            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
-            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if transit_gateway_id is not None:
-            self._values["transit_gateway_id"] = transit_gateway_id
-        if vpn_gateway_id is not None:
-            self._values["vpn_gateway_id"] = vpn_gateway_id
+            type_hints = typing.get_type_hints(_typecheckingstub__0770316fdacec7ca35ca6177329d14996aea7b6acb0fd95618ead49ef0b5ad06)
+            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
+            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
+            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
+            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
+            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "glue_version": glue_version,
+            "python_version": python_version,
+            "script": script,
+        }
+        if extra_files is not None:
+            self._values["extra_files"] = extra_files
+        if extra_python_files is not None:
+            self._values["extra_python_files"] = extra_python_files
 
     @builtins.property
-    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
-        '''The ID of the transit gateway that serves as the local end of the VPN connection.'''
-        result = self._values.get("transit_gateway_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def glue_version(self) -> GlueVersion:
+        '''Glue version.
+
+        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        '''
+        result = self._values.get("glue_version")
+        assert result is not None, "Required property 'glue_version' is missing"
+        return typing.cast(GlueVersion, result)
 
     @builtins.property
-    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
-        '''The ID of the VPN gateway that serves as the local end of the VPN connection.'''
-        result = self._values.get("vpn_gateway_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def python_version(self) -> "PythonVersion":
+        '''The Python version to use.'''
+        result = self._values.get("python_version")
+        assert result is not None, "Required property 'python_version' is missing"
+        return typing.cast("PythonVersion", result)
+
+    @builtins.property
+    def script(self) -> Code:
+        '''The script that executes a job.'''
+        result = self._values.get("script")
+        assert result is not None, "Required property 'script' is missing"
+        return typing.cast(Code, result)
+
+    @builtins.property
+    def extra_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+
+        Only individual files are supported, directories are not supported.
+
+        :default: [] - no extra files are copied to the working directory
+
+        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
+
+    @builtins.property
+    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
+
+        Only individual files are supported, directories are not supported.
+
+        :default: - no extra python files and argument is not set
+
+        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_python_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "LocalVpnEndpointConfiguration(%s)" % ", ".join(
+        return "PythonShellExecutableProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class NatProvider(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.ec2.NatProvider"):
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
-
-    @jsii.member(jsii_name="gateway")
-    @builtins.classmethod
-    def gateway(
-        cls,
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.PythonSparkJobExecutableProps",
+    jsii_struct_bases=[],
+    name_mapping={
+        "glue_version": "glueVersion",
+        "python_version": "pythonVersion",
+        "script": "script",
+        "extra_files": "extraFiles",
+        "extra_jars": "extraJars",
+        "extra_jars_first": "extraJarsFirst",
+        "extra_python_files": "extraPythonFiles",
+    },
+)
+class PythonSparkJobExecutableProps:
+    def __init__(
+        self,
         *,
-        eip_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
-    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
+        glue_version: GlueVersion,
+        python_version: "PythonVersion",
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+    ) -> None:
+        '''Props for creating a Python Spark (ETL or Streaming) job executable.
+
+        :param glue_version: Glue version.
+        :param python_version: The Python version to use.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__abf13ee589f12cebe2bcd432fdc04c1c56ddab0d41ec2223ea1e51e77d10b532)
+            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
+            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
+            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
+            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
+            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
+            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
+            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "glue_version": glue_version,
+            "python_version": python_version,
+            "script": script,
+        }
+        if extra_files is not None:
+            self._values["extra_files"] = extra_files
+        if extra_jars is not None:
+            self._values["extra_jars"] = extra_jars
+        if extra_jars_first is not None:
+            self._values["extra_jars_first"] = extra_jars_first
+        if extra_python_files is not None:
+            self._values["extra_python_files"] = extra_python_files
+
+    @builtins.property
+    def glue_version(self) -> GlueVersion:
+        '''Glue version.
+
+        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
         '''
-        :param eip_allocation_ids: EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways
+        result = self._values.get("glue_version")
+        assert result is not None, "Required property 'glue_version' is missing"
+        return typing.cast(GlueVersion, result)
+
+    @builtins.property
+    def python_version(self) -> "PythonVersion":
+        '''The Python version to use.'''
+        result = self._values.get("python_version")
+        assert result is not None, "Required property 'python_version' is missing"
+        return typing.cast("PythonVersion", result)
+
+    @builtins.property
+    def script(self) -> Code:
+        '''The script that executes a job.'''
+        result = self._values.get("script")
+        assert result is not None, "Required property 'script' is missing"
+        return typing.cast(Code, result)
+
+    @builtins.property
+    def extra_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+
+        Only individual files are supported, directories are not supported.
+
+        :default: [] - no extra files are copied to the working directory
+
+        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        props = _aws_cdk_aws_ec2_ceddda9d.NatGatewayProps(
-            eip_allocation_ids=eip_allocation_ids
-        )
+        result = self._values.get("extra_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
 
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "gateway", [props]))
+    @builtins.property
+    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported.
 
-    @jsii.member(jsii_name="instance")
-    @builtins.classmethod
-    def instance(
-        cls,
-        *,
-        instance_type: _aws_cdk_aws_ec2_ceddda9d.InstanceType,
-        default_allowed_traffic: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatTrafficDirection] = None,
-        key_name: typing.Optional[builtins.str] = None,
-        machine_image: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IMachineImage] = None,
-        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
-    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
-        '''
-        :param instance_type: Instance type of the NAT instance.
-        :param default_allowed_traffic: Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND
-        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
-        :param machine_image: The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image
-        :param security_group: Security Group for NAT instances. Default: - A new security group will be created
-        '''
-        props = _aws_cdk_aws_ec2_ceddda9d.NatInstanceProps(
-            instance_type=instance_type,
-            default_allowed_traffic=default_allowed_traffic,
-            key_name=key_name,
-            machine_image=machine_image,
-            security_group=security_group,
+        :default: [] - no extra jars are added to the classpath
+
+        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_jars")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
+
+    @builtins.property
+    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
+        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+
+        :default: false - priority is not given to user-provided jars
+
+        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_jars_first")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
+
+        Only individual files are supported, directories are not supported.
+
+        :default: - no extra python files and argument is not set
+
+        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_python_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "PythonSparkJobExecutableProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
         )
 
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "instance", [props]))
 
-    @jsii.member(jsii_name="transitGateway")
-    @builtins.classmethod
-    def transit_gateway(
-        cls,
-        *,
-        transit_gateway: ITransitGateway,
-    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
+@jsii.enum(jsii_type="cdk-extensions.glue.PythonVersion")
+class PythonVersion(enum.Enum):
+    THREE = "THREE"
+    '''Python 3 (the exact version depends on GlueVersion and JobCommand used).'''
+    TWO = "TWO"
+    '''Python 2 (the exact version depends on GlueVersion and JobCommand used).'''
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.RecrawlBehavior")
+class RecrawlBehavior(enum.Enum):
+    EVENT_MODE = "EVENT_MODE"
+    EVERYTHING = "EVERYTHING"
+    NEW_FOLDERS_ONLY = "NEW_FOLDERS_ONLY"
+
+
+class S3Code(Code, metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.S3Code"):
+    '''Glue job Code from an S3 bucket.'''
+
+    def __init__(
+        self,
+        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+        key: builtins.str,
+    ) -> None:
         '''
-        :param transit_gateway: 
+        :param bucket: -
+        :param key: -
         '''
-        props = TransitGatewayNatProviderOptions(transit_gateway=transit_gateway)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__de8f54c722e452ed2da0b9a8775cdf6f8a22de4bab55c4b0f779954c84a2b2e6)
+            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        jsii.create(self.__class__, self, [bucket, key])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.Construct,
+        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+    ) -> CodeConfig:
+        '''Called when the Job is initialized to allow this object to bind.
 
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "transitGateway", [props]))
+        :param _scope: -
+        :param grantable: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__07939ad3e69a9dd6cae1fdc4f6dec96a067b631307222f1d771e21ef5b555288)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
+        return typing.cast(CodeConfig, jsii.invoke(self, "bind", [_scope, grantable]))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.RemoteVpnEndpointConfiguration",
+    jsii_type="cdk-extensions.glue.S3Encryption",
     jsii_struct_bases=[],
-    name_mapping={
-        "customer_gateway_asn": "customerGatewayAsn",
-        "customer_gateway_id": "customerGatewayId",
-        "customer_gateway_ip": "customerGatewayIp",
-    },
+    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
 )
-class RemoteVpnEndpointConfiguration:
+class S3Encryption:
     def __init__(
         self,
         *,
-        customer_gateway_asn: jsii.Number,
-        customer_gateway_id: builtins.str,
-        customer_gateway_ip: builtins.str,
+        mode: "S3EncryptionMode",
+        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
     ) -> None:
-        '''Configuration object containing the vlues needed to configure the remote end of a VPN connection.
+        '''S3 encryption configuration.
 
-        :param customer_gateway_asn: The BGP ASN of the customer gateway which is configured with the details of the remote endpoint device.
-        :param customer_gateway_id: The ID of the customer gateway which is configured with the details of the remote endpoint device.
-        :param customer_gateway_ip: The IP address of the customer gateway which is configured with the details of the remote endpoint device.
+        :param mode: Encryption mode.
+        :param kms_key: The KMS key to be used to encrypt the data. Default: no kms key if mode = S3_MANAGED. A key will be created if one is not provided and mode = KMS.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8914f39fbdc8cc3e17d3f0de803ae8f59bb0822173529944b495b0fe17106662)
-            check_type(argname="argument customer_gateway_asn", value=customer_gateway_asn, expected_type=type_hints["customer_gateway_asn"])
-            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
-            check_type(argname="argument customer_gateway_ip", value=customer_gateway_ip, expected_type=type_hints["customer_gateway_ip"])
+            type_hints = typing.get_type_hints(_typecheckingstub__34af5cf7f823d326ebb18b6676a7f173278a47afe08c3b06bf179d11c994e2f8)
+            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
+            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "customer_gateway_asn": customer_gateway_asn,
-            "customer_gateway_id": customer_gateway_id,
-            "customer_gateway_ip": customer_gateway_ip,
+            "mode": mode,
         }
+        if kms_key is not None:
+            self._values["kms_key"] = kms_key
 
     @builtins.property
-    def customer_gateway_asn(self) -> jsii.Number:
-        '''The BGP ASN of the customer gateway which is configured with the details of the remote endpoint device.'''
-        result = self._values.get("customer_gateway_asn")
-        assert result is not None, "Required property 'customer_gateway_asn' is missing"
-        return typing.cast(jsii.Number, result)
+    def mode(self) -> "S3EncryptionMode":
+        '''Encryption mode.'''
+        result = self._values.get("mode")
+        assert result is not None, "Required property 'mode' is missing"
+        return typing.cast("S3EncryptionMode", result)
 
     @builtins.property
-    def customer_gateway_id(self) -> builtins.str:
-        '''The ID of the customer gateway which is configured with the details of the remote endpoint device.'''
-        result = self._values.get("customer_gateway_id")
-        assert result is not None, "Required property 'customer_gateway_id' is missing"
-        return typing.cast(builtins.str, result)
+    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
+        '''The KMS key to be used to encrypt the data.
 
-    @builtins.property
-    def customer_gateway_ip(self) -> builtins.str:
-        '''The IP address of the customer gateway which is configured with the details of the remote endpoint device.'''
-        result = self._values.get("customer_gateway_ip")
-        assert result is not None, "Required property 'customer_gateway_ip' is missing"
-        return typing.cast(builtins.str, result)
+        :default: no kms key if mode = S3_MANAGED. A key will be created if one is not provided and mode = KMS.
+        '''
+        result = self._values.get("kms_key")
+        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "RemoteVpnEndpointConfiguration(%s)" % ", ".join(
+        return "S3Encryption(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+@jsii.enum(jsii_type="cdk-extensions.glue.S3EncryptionMode")
+class S3EncryptionMode(enum.Enum):
+    '''Encryption mode for S3.
+
+    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_S3Encryption.html#Glue-Type-S3Encryption-S3EncryptionMode
+    '''
+
+    KMS = "KMS"
+    '''Server-side encryption (SSE) with an AWS KMS key managed by the account owner.
+
+    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
+    '''
+    S3_MANAGED = "S3_MANAGED"
+    '''Server side encryption (SSE) with an Amazon S3-managed key.
+
+    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html
+    '''
+
+
+@jsii.implements(ICrawlerTarget)
+class S3Target(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.S3Target"):
+    def __init__(
+        self,
+        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+        *,
+        connection: typing.Optional[Connection] = None,
+        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        key_prefix: typing.Optional[builtins.str] = None,
+        sample_size: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param bucket: -
+        :param connection: A {@link aws-glue.Connection | "Connection" } object to connect to the target with.
+        :param exclusions: A list of glob patterns used to exclude from the crawl.
+        :param key_prefix: A Prefix Key for identification and organization of objects in the bucket.
+        :param sample_size: Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fcaa86377de60481d78b8e386ba15f4ae63207cee2ee1e03d6a84890c5303f9f)
+            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
+        options = S3TargetOptions(
+            connection=connection,
+            exclusions=exclusions,
+            key_prefix=key_prefix,
+            sample_size=sample_size,
+        )
+
+        jsii.create(self.__class__, self, [bucket, options])
+
+    @jsii.member(jsii_name="addExclusion")
+    def add_exclusion(self, exclusion: builtins.str) -> None:
+        '''
+        :param exclusion: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__78064b8f21836a6ba333208adc1772c480fd7d08c026c1f0523ba1b519e1ec92)
+            check_type(argname="argument exclusion", value=exclusion, expected_type=type_hints["exclusion"])
+        return typing.cast(None, jsii.invoke(self, "addExclusion", [exclusion]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
+        '''
+        :param crawler: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b1ac6ccbc65917f26861da97319cead930d0dbf8fcf49a83e9e71e57ccef2986)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [crawler]))
+
+    @builtins.property
+    @jsii.member(jsii_name="bucket")
+    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.IBucket:
+        '''Bucket to use as the Target.'''
+        return typing.cast(_aws_cdk_aws_s3_ceddda9d.IBucket, jsii.get(self, "bucket"))
+
+    @builtins.property
+    @jsii.member(jsii_name="connection")
+    def connection(self) -> typing.Optional[Connection]:
+        '''{@link S3TargetOptions.connection}.'''
+        return typing.cast(typing.Optional[Connection], jsii.get(self, "connection"))
+
+    @builtins.property
+    @jsii.member(jsii_name="exclusions")
+    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''{@link S3TargetOptions.exclusions}.'''
+        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exclusions"))
+
+    @builtins.property
+    @jsii.member(jsii_name="keyPrefix")
+    def key_prefix(self) -> typing.Optional[builtins.str]:
+        '''{@link S3TargetOptions.keyPrefix}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyPrefix"))
+
+    @builtins.property
+    @jsii.member(jsii_name="sampleSize")
+    def sample_size(self) -> typing.Optional[builtins.str]:
+        '''{@link S3TargetOptions.sampleSize}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sampleSize"))
+
+
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.SharingOptions",
+    jsii_type="cdk-extensions.glue.S3TargetOptions",
     jsii_struct_bases=[],
     name_mapping={
-        "allow_external_principals": "allowExternalPrincipals",
-        "auto_discover_accounts": "autoDiscoverAccounts",
-        "principals": "principals",
+        "connection": "connection",
+        "exclusions": "exclusions",
+        "key_prefix": "keyPrefix",
+        "sample_size": "sampleSize",
     },
 )
-class SharingOptions:
+class S3TargetOptions:
     def __init__(
         self,
         *,
-        allow_external_principals: typing.Optional[builtins.bool] = None,
-        auto_discover_accounts: typing.Optional[builtins.bool] = None,
-        principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
+        connection: typing.Optional[Connection] = None,
+        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        key_prefix: typing.Optional[builtins.str] = None,
+        sample_size: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''
-        :param allow_external_principals: 
-        :param auto_discover_accounts: 
-        :param principals: 
+        '''Configuration for Crawler S3 target.
+
+        :param connection: A {@link aws-glue.Connection | "Connection" } object to connect to the target with.
+        :param exclusions: A list of glob patterns used to exclude from the crawl.
+        :param key_prefix: A Prefix Key for identification and organization of objects in the bucket.
+        :param sample_size: Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5d7430c10280f3e429f967b91e374da316928ba959b852656888cb4465f871ab)
-            check_type(argname="argument allow_external_principals", value=allow_external_principals, expected_type=type_hints["allow_external_principals"])
-            check_type(argname="argument auto_discover_accounts", value=auto_discover_accounts, expected_type=type_hints["auto_discover_accounts"])
-            check_type(argname="argument principals", value=principals, expected_type=type_hints["principals"])
+            type_hints = typing.get_type_hints(_typecheckingstub__adead1dc5fcd2fa7014bdfa551e765a45e7e34612c1c8ffd300d3b8edefe00b4)
+            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
+            check_type(argname="argument exclusions", value=exclusions, expected_type=type_hints["exclusions"])
+            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
+            check_type(argname="argument sample_size", value=sample_size, expected_type=type_hints["sample_size"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if allow_external_principals is not None:
-            self._values["allow_external_principals"] = allow_external_principals
-        if auto_discover_accounts is not None:
-            self._values["auto_discover_accounts"] = auto_discover_accounts
-        if principals is not None:
-            self._values["principals"] = principals
+        if connection is not None:
+            self._values["connection"] = connection
+        if exclusions is not None:
+            self._values["exclusions"] = exclusions
+        if key_prefix is not None:
+            self._values["key_prefix"] = key_prefix
+        if sample_size is not None:
+            self._values["sample_size"] = sample_size
 
     @builtins.property
-    def allow_external_principals(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("allow_external_principals")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def connection(self) -> typing.Optional[Connection]:
+        '''A {@link aws-glue.Connection | "Connection" } object to connect to the target with.'''
+        result = self._values.get("connection")
+        return typing.cast(typing.Optional[Connection], result)
 
     @builtins.property
-    def auto_discover_accounts(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("auto_discover_accounts")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''A list of glob patterns used to exclude from the crawl.
+
+        :see: `For More Information <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_
+        '''
+        result = self._values.get("exclusions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    @builtins.property
+    def key_prefix(self) -> typing.Optional[builtins.str]:
+        '''A Prefix Key for identification and organization of objects in the bucket.'''
+        result = self._values.get("key_prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def principals(self) -> typing.Optional[typing.List[_ISharedPrincipal_9cde791b]]:
-        result = self._values.get("principals")
-        return typing.cast(typing.Optional[typing.List[_ISharedPrincipal_9cde791b]], result)
+    def sample_size(self) -> typing.Optional[builtins.str]:
+        '''Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset.
+
+        If not set, all the files are crawled. A valid value is an integer between 1 and 249.
+
+        :see: `AWS::Glue::Crawler S3Target <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-s3target.html#cfn-glue-crawler-s3target-samplesize>`_
+        '''
+        result = self._values.get("sample_size")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "SharingOptions(%s)" % ", ".join(
+        return "S3TargetOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IIpAddresses)
-class TieredSubnets(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TieredSubnets",
-):
-    def __init__(self, options: "TieredSubnetsOptions") -> None:
-        '''
-        :param options: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c8e89adfc6dfc2ac55a0bed117d1dc5d9b5bc0bcf75bb19367a28bd1c914be4e)
-            check_type(argname="argument options", value=options, expected_type=type_hints["options"])
-        jsii.create(self.__class__, self, [options])
-
-    @jsii.member(jsii_name="allocateSubnetsCidr")
-    def allocate_subnets_cidr(
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.ScalaJobExecutableProps",
+    jsii_struct_bases=[],
+    name_mapping={
+        "class_name": "className",
+        "glue_version": "glueVersion",
+        "script": "script",
+        "extra_files": "extraFiles",
+        "extra_jars": "extraJars",
+        "extra_jars_first": "extraJarsFirst",
+    },
+)
+class ScalaJobExecutableProps:
+    def __init__(
         self,
         *,
-        requested_subnets: typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.RequestedSubnet, typing.Dict[builtins.str, typing.Any]]],
-        vpc_cidr: builtins.str,
-    ) -> _aws_cdk_aws_ec2_ceddda9d.SubnetIpamOptions:
-        '''Called by the VPC to retrieve Subnet options from the Ipam
+        class_name: builtins.str,
+        glue_version: GlueVersion,
+        script: Code,
+        extra_files: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+        extra_jars_first: typing.Optional[builtins.bool] = None,
+    ) -> None:
+        '''Props for creating a Scala Spark (ETL or Streaming) job executable.
+
+        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
+        :param glue_version: Glue version.
+        :param script: The script that executes a job.
+        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
+        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
+        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5a58d9a628f0769075f9be892e1815f81d167b0a10411ee63316264981cf0120)
+            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
+            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
+            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
+            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
+            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
+            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "class_name": class_name,
+            "glue_version": glue_version,
+            "script": script,
+        }
+        if extra_files is not None:
+            self._values["extra_files"] = extra_files
+        if extra_jars is not None:
+            self._values["extra_jars"] = extra_jars
+        if extra_jars_first is not None:
+            self._values["extra_jars_first"] = extra_jars_first
 
-Don't call this directly, the VPC will call it automatically.
+    @builtins.property
+    def class_name(self) -> builtins.str:
+        '''The fully qualified Scala class name that serves as the entry point for the job.
 
-        :param requested_subnets: The Subnets to be allocated.
-        :param vpc_cidr: The IPv4 CIDR block for this Vpc.
+        :see: ``--class`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
         '''
-        input = _aws_cdk_aws_ec2_ceddda9d.AllocateCidrRequest(
-            requested_subnets=requested_subnets, vpc_cidr=vpc_cidr
-        )
-
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetIpamOptions, jsii.invoke(self, "allocateSubnetsCidr", [input]))
+        result = self._values.get("class_name")
+        assert result is not None, "Required property 'class_name' is missing"
+        return typing.cast(builtins.str, result)
 
-    @jsii.member(jsii_name="allocateVpcCidr")
-    def allocate_vpc_cidr(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions:
-        '''Called by the VPC to retrieve VPC options from the Ipam
+    @builtins.property
+    def glue_version(self) -> GlueVersion:
+        '''Glue version.
 
-Don't call this directly, the VPC will call it automatically.'''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions, jsii.invoke(self, "allocateVpcCidr", []))
+        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        '''
+        result = self._values.get("glue_version")
+        assert result is not None, "Required property 'glue_version' is missing"
+        return typing.cast(GlueVersion, result)
 
     @builtins.property
-    @jsii.member(jsii_name="cidr")
-    def cidr(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "cidr"))
+    def script(self) -> Code:
+        '''The script that executes a job.'''
+        result = self._values.get("script")
+        assert result is not None, "Required property 'script' is missing"
+        return typing.cast(Code, result)
 
     @builtins.property
-    @jsii.member(jsii_name="tierMask")
-    def tier_mask(self) -> typing.Optional[jsii.Number]:
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "tierMask"))
+    def extra_files(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
 
+        Only individual files are supported, directories are not supported.
 
-class TieredSubnetsOptions(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TieredSubnetsOptions",
-):
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+        :default: [] - no extra files are copied to the working directory
+
+        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_files")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="cidr")
-    def cidr(self) -> typing.Optional[builtins.str]:
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidr"))
+    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
+        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported.
+
+        :default: [] - no extra jars are added to the classpath
+
+        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_jars")
+        return typing.cast(typing.Optional[typing.List[Code]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="tierMask")
-    def tier_mask(self) -> typing.Optional[jsii.Number]:
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "tierMask"))
+    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
+        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+
+        :default: false - priority is not given to user-provided jars
+
+        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        '''
+        result = self._values.get("extra_jars_first")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ScalaJobExecutableProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-@jsii.implements(ITransitGateway)
-class TransitGateway(
+class SecurityConfiguration(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGateway",
+    jsii_type="cdk-extensions.glue.SecurityConfiguration",
 ):
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        amazon_side_asn: typing.Optional[jsii.Number] = None,
-        auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
-        cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
-        default_route_table_association: typing.Optional[builtins.bool] = None,
-        default_route_table_id: typing.Optional[builtins.str] = None,
-        default_route_table_propagation: typing.Optional[builtins.bool] = None,
-        description: typing.Optional[builtins.str] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        multicast_support: typing.Optional[builtins.bool] = None,
+        cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+        job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
         name: typing.Optional[builtins.str] = None,
-        vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+        s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the Database class.
-
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param amazon_side_asn: 
-        :param auto_accept_shared_attachments: 
-        :param cidr_blocks: 
-        :param default_route_table_association: 
-        :param default_route_table_id: 
-        :param default_route_table_propagation: 
-        :param description: 
-        :param dns_support: 
-        :param multicast_support: 
-        :param name: 
-        :param vpn_ecmp_support: 
+        '''
+        :param scope: -
+        :param id: -
+        :param cloud_watch_encryption: Cloudwatch Encryption Settings.
+        :param job_bookmarks_encryption: The encryption configuration for job bookmarks.
+        :param name: Name for the Security Configuration.
+        :param s3_encryption: The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__66b0aca7557ca99e67ff904b7cb9edf704abd3cf24b45ecad18d9ccffdb7fcdc)
+            type_hints = typing.get_type_hints(_typecheckingstub__8bb80a9d0f83fcd376c282d063d76d6be646365fd7ea4850397fc1cf26b72038)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayProps(
-            amazon_side_asn=amazon_side_asn,
-            auto_accept_shared_attachments=auto_accept_shared_attachments,
-            cidr_blocks=cidr_blocks,
-            default_route_table_association=default_route_table_association,
-            default_route_table_id=default_route_table_id,
-            default_route_table_propagation=default_route_table_propagation,
-            description=description,
-            dns_support=dns_support,
-            multicast_support=multicast_support,
+        props = SecurityConfigurationProps(
+            cloud_watch_encryption=cloud_watch_encryption,
+            job_bookmarks_encryption=job_bookmarks_encryption,
             name=name,
-            vpn_ecmp_support=vpn_ecmp_support,
+            s3_encryption=s3_encryption,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="fromTransitGatewayId")
-    @builtins.classmethod
-    def from_transit_gateway_id(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        transit_gateway_id: builtins.str,
-    ) -> ITransitGateway:
-        '''
-        :param scope: -
-        :param id: -
-        :param transit_gateway_id: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__46c3cc263035d23bc511197c75afb01d4a672fd46f5af176fbea6a400bccd00b)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
-        return typing.cast(ITransitGateway, jsii.sinvoke(cls, "fromTransitGatewayId", [scope, id, transit_gateway_id]))
-
-    @jsii.member(jsii_name="addCidrBlock")
-    def add_cidr_block(self, cidr: builtins.str) -> None:
-        '''
-        :param cidr: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2efd1666acd64cb987a354787ffd07add5920ed5de7e64ad3a01aa00619b7310)
-            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
-        return typing.cast(None, jsii.invoke(self, "addCidrBlock", [cidr]))
-
-    @jsii.member(jsii_name="addRouteTable")
-    def add_route_table(
-        self,
-        *,
-        name: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayRouteTable":
-        '''Creates a new Transit Gateway Route Table for this Transit Gateway.
-
-        :param name: 
-
-        :return: The newly created Transit Gateway Route Table.
-        '''
-        options = TransitGatewayRouteTableOptions(name=name)
-
-        return typing.cast("TransitGatewayRouteTable", jsii.invoke(self, "addRouteTable", [options]))
+    @builtins.property
+    @jsii.member(jsii_name="key")
+    def key(self) -> _aws_cdk_aws_kms_ceddda9d.Key:
+        return typing.cast(_aws_cdk_aws_kms_ceddda9d.Key, jsii.get(self, "key"))
 
-    @jsii.member(jsii_name="addVpn")
-    def add_vpn(
-        self,
-        id: builtins.str,
-        *,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> "VpnConnection":
-        '''Creates a new VPN connection that terminates on the AWS side at this Transit Gateway.
-
-        :param id: A unique identifier for this VPN connection. Must be unique within the context of scope.
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnSecurityConfiguration:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnSecurityConfiguration, jsii.get(self, "resource"))
 
-        :return: The VPN connection that was created.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9989ffc3141ccddce9a6e8246aa4b31bd76f3ad0a11bbc1cbee86d607e50200d)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        options = VpnAttachmentOptions(
-            remote_endpoint=remote_endpoint,
-            connection_type=connection_type,
-            static_routes_only=static_routes_only,
-            tunnel_configurations=tunnel_configurations,
-        )
+    @builtins.property
+    @jsii.member(jsii_name="securityConfigurationName")
+    def security_configuration_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "securityConfigurationName"))
 
-        return typing.cast("VpnConnection", jsii.invoke(self, "addVpn", [id, options]))
+    @builtins.property
+    @jsii.member(jsii_name="cloudWatchEncryption")
+    def cloud_watch_encryption(self) -> typing.Optional[CloudWatchEncryption]:
+        '''{@link SecurityConfigurationProps.cloudWatchEncryption}.'''
+        return typing.cast(typing.Optional[CloudWatchEncryption], jsii.get(self, "cloudWatchEncryption"))
 
-    @jsii.member(jsii_name="attachPeer")
-    def attach_peer(
-        self,
-        peer: ITransitGateway,
-        *,
-        name: typing.Optional[builtins.str] = None,
-        peer_account_id: typing.Optional[builtins.str] = None,
-        peer_region: typing.Optional[builtins.str] = None,
-    ) -> "TransitGatewayPeeringAttachment":
-        '''Creates a new transit gateway peering attachment for this transit gateway.
+    @builtins.property
+    @jsii.member(jsii_name="jobBookmarksEncryption")
+    def job_bookmarks_encryption(self) -> typing.Optional[JobBookmarksEncryption]:
+        '''{@link SecurityConfigurationProps.jobBookmarksEncryption}.'''
+        return typing.cast(typing.Optional[JobBookmarksEncryption], jsii.get(self, "jobBookmarksEncryption"))
 
-        :param peer: The remote transit gateway to create the peering connection with.
-        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param peer_account_id: The account that contains the transit gateway being peered with.
-        :param peer_region: The region that contains the transit gateway being peered with.
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link SecurityConfigurationProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
-        :return: The newly created TransitGatewayPeeringAttachment.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3fca635a725c4277e8db84123074663ecf20e88af86d11cb8f03c6390d8b7bc8)
-            check_type(argname="argument peer", value=peer, expected_type=type_hints["peer"])
-        options = TransitGatewayPeeringAttachmentOptions(
-            name=name, peer_account_id=peer_account_id, peer_region=peer_region
-        )
+    @builtins.property
+    @jsii.member(jsii_name="s3Encryption")
+    def s3_encryption(self) -> typing.Optional[S3Encryption]:
+        '''{@link SecurityConfigurationProps.s3Encryption}.'''
+        return typing.cast(typing.Optional[S3Encryption], jsii.get(self, "s3Encryption"))
 
-        return typing.cast("TransitGatewayPeeringAttachment", jsii.invoke(self, "attachPeer", [peer, options]))
 
-    @jsii.member(jsii_name="attachVpc")
-    def attach_vpc(
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.SecurityConfigurationProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "cloud_watch_encryption": "cloudWatchEncryption",
+        "job_bookmarks_encryption": "jobBookmarksEncryption",
+        "name": "name",
+        "s3_encryption": "s3Encryption",
+    },
+)
+class SecurityConfigurationProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
         self,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
         *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+        job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
         name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    ) -> "TransitGatewayAttachment":
-        '''Creates a new VPC transit gateway attachment for this transit gateway.
-
-        :param vpc: The VPC to connect to this Transit Gateway.
-        :param name: 
-        :param subnets: 
+        s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
+        '''Configuration for the Glue SecurityConfiguration resource.
 
-        :return: The newly created TransitGatewayAttachment.
-        '''
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param cloud_watch_encryption: Cloudwatch Encryption Settings.
+        :param job_bookmarks_encryption: The encryption configuration for job bookmarks.
+        :param name: Name for the Security Configuration.
+        :param s3_encryption: The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
+        '''
+        if isinstance(cloud_watch_encryption, dict):
+            cloud_watch_encryption = CloudWatchEncryption(**cloud_watch_encryption)
+        if isinstance(job_bookmarks_encryption, dict):
+            job_bookmarks_encryption = JobBookmarksEncryption(**job_bookmarks_encryption)
+        if isinstance(s3_encryption, dict):
+            s3_encryption = S3Encryption(**s3_encryption)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ac3f5d6f3de4328a56c1673d48d7168afe72b9b6c52725fb46ee3d5121211524)
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
-        options = VpcAttachmentOptions(name=name, subnets=subnets)
+            type_hints = typing.get_type_hints(_typecheckingstub__d27a4bece3fbfe787de85bd302d080942572f3712552688c636b696a9d85fa70)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument cloud_watch_encryption", value=cloud_watch_encryption, expected_type=type_hints["cloud_watch_encryption"])
+            check_type(argname="argument job_bookmarks_encryption", value=job_bookmarks_encryption, expected_type=type_hints["job_bookmarks_encryption"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument s3_encryption", value=s3_encryption, expected_type=type_hints["s3_encryption"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if cloud_watch_encryption is not None:
+            self._values["cloud_watch_encryption"] = cloud_watch_encryption
+        if job_bookmarks_encryption is not None:
+            self._values["job_bookmarks_encryption"] = job_bookmarks_encryption
+        if name is not None:
+            self._values["name"] = name
+        if s3_encryption is not None:
+            self._values["s3_encryption"] = s3_encryption
 
-        return typing.cast("TransitGatewayAttachment", jsii.invoke(self, "attachVpc", [vpc, options]))
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-    @jsii.member(jsii_name="enableSharing")
-    def enable_sharing(
-        self,
-        *,
-        allow_external_principals: typing.Optional[builtins.bool] = None,
-        auto_discover_accounts: typing.Optional[builtins.bool] = None,
-        principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
-    ) -> _ResourceShare_f0180713:
-        '''
-        :param allow_external_principals: 
-        :param auto_discover_accounts: 
-        :param principals: 
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        options = SharingOptions(
-            allow_external_principals=allow_external_principals,
-            auto_discover_accounts=auto_discover_accounts,
-            principals=principals,
-        )
-
-        return typing.cast(_ResourceShare_f0180713, jsii.invoke(self, "enableSharing", [options]))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="autoAcceptSharedAttachments")
-    def auto_accept_shared_attachments(self) -> builtins.bool:
-        '''Enable or disable automatic acceptance of attachment requests.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        When enabled any new transit gateway attachments that are created in other
-        accounts via a resource share will be accepted automatically. Otherwise,
-        manual intervention will be required to approve all new attachments.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        This is disabled by default to maintain the highest levels of security,
-        however enabling should be strongly considered as without this full
-        automation of infrastructure will not be possible for cross account
-        setups.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :see: `Accept a shared attachment <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#tgw-accept-shared-attachment>`_
-        :group: Inputs
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(builtins.bool, jsii.get(self, "autoAcceptSharedAttachments"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="defaultRouteTableAssociation")
-    def default_route_table_association(self) -> builtins.bool:
-        '''Enable or disable automatic association with the default association route table.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        When enabled, all new attachments that are accepted will be automatically
-        associated with the default association route table. By default this is
-        the route table that is created automatically when the transit gateway is
-        created.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :see: `TransitGateway.DefaultRouteTableAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation>`_
-        :group: Inputs
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(builtins.bool, jsii.get(self, "defaultRouteTableAssociation"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="defaultRouteTablePropagation")
-    def default_route_table_propagation(self) -> builtins.bool:
-        '''Enable or disable automatic propagation of routes to the default propagation route table.
-
-        When a new attachment is accepted, the routes associated with that
-        attachment will automatically be added to the default propagation route
-        table. By default this is the route table that is created automatically
-        when the transit gateway is created.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :see: `Route propagation <https://docs.aws.amazon.com/vpc/latest/tgw/how-transit-gateways-work.html#tgw-route-propagation-overview>`_
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(builtins.bool, jsii.get(self, "defaultRouteTablePropagation"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="dnsSupport")
-    def dns_support(self) -> builtins.bool:
-        '''Enable or disable DNS support.
-
-        When DNS support is enabled on a transit gateway, VPC DNS resolution in
-        attached VPC's will automatically resolve public IP addresses from other
-        VPC's to their provate IP address equivalent.
+    def cloud_watch_encryption(self) -> typing.Optional[CloudWatchEncryption]:
+        '''Cloudwatch Encryption Settings.
 
-        :see: `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_
-        :group: Inputs
+        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-cloudwatchencryption>`_
         '''
-        return typing.cast(builtins.bool, jsii.get(self, "dnsSupport"))
+        result = self._values.get("cloud_watch_encryption")
+        return typing.cast(typing.Optional[CloudWatchEncryption], result)
 
     @builtins.property
-    @jsii.member(jsii_name="multicastSupport")
-    def multicast_support(self) -> builtins.bool:
-        '''Indicates whether multicast is enabled on the transit gateway.
+    def job_bookmarks_encryption(self) -> typing.Optional[JobBookmarksEncryption]:
+        '''The encryption configuration for job bookmarks.
 
-        :see: `Multicast reference architectures <https://d1.awsstatic.com/architecture-diagrams/ArchitectureDiagrams/transitgateway_multicast_ra.pdf?did=wp_card&trk=wp_card>`_
-        :group: Inputs
+        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-jobbookmarksencryption>`_
         '''
-        return typing.cast(builtins.bool, jsii.get(self, "multicastSupport"))
+        result = self._values.get("job_bookmarks_encryption")
+        return typing.cast(typing.Optional[JobBookmarksEncryption], result)
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGateway:
-        '''The underlying TransitGateway CloudFormation resource.
-
-        :see: `AWS::EC2::TransitGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html>`_
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGateway, jsii.get(self, "resource"))
+    def name(self) -> typing.Optional[builtins.str]:
+        '''Name for the Security Configuration.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayArn")
-    def transit_gateway_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayArn"))
+    def s3_encryption(self) -> typing.Optional[S3Encryption]:
+        '''The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayId")
-    def transit_gateway_id(self) -> builtins.str:
-        '''The ID of this Transit Gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))
+        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-s3encryptions>`_
+        '''
+        result = self._values.get("s3_encryption")
+        return typing.cast(typing.Optional[S3Encryption], result)
 
-    @builtins.property
-    @jsii.member(jsii_name="amazonSideAsn")
-    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
-        '''A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        The range is 64512 to 65534 for 16-bit ASNs.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :see: `TransitGateway.AmazonSideAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "amazonSideAsn"))
+    def __repr__(self) -> str:
+        return "SecurityConfigurationProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="defaultRouteTable")
-    def default_route_table(self) -> typing.Optional[ITransitGatewayRouteTable]:
-        '''The default route table that got created along with the Transit Gateway.
 
-        This information is not exposed by CloudFormation. As such, this resource
-        will only be available if the default reoute table ID is passed in.
+class SerializationLibrary(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.SerializationLibrary",
+):
+    '''Serialization library to use when serializing/deserializing (SerDe) table records.
 
-        :group: Resources
-        '''
-        return typing.cast(typing.Optional[ITransitGatewayRouteTable], jsii.get(self, "defaultRouteTable"))
+    :see: https://cwiki.apache.org/confluence/display/Hive/SerDe
+    '''
 
-    @builtins.property
-    @jsii.member(jsii_name="defaultRouteTableId")
-    def default_route_table_id(self) -> typing.Optional[builtins.str]:
-        '''The ID of the default route table that was created with the transit gateway.
+    def __init__(self, class_name: builtins.str) -> None:
+        '''
+        :param class_name: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5be42ef34b8183a16c487d39be9e50f07bb069442ea235835d889d6c915c0fd9)
+            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
+        jsii.create(self.__class__, self, [class_name])
 
-        This route table is critical to some transit gateway architectures and is
-        not exposed by CloudFormation.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="AVRO")
+    def AVRO(cls) -> "SerializationLibrary":
+        '''
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/avro/AvroSerDe.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "AVRO"))
 
-        Passing in the ID of the default route table will make an object available
-        that represents it and can be used for further operations.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="CLOUDTRAIL")
+    def CLOUDTRAIL(cls) -> "SerializationLibrary":
+        '''
+        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "CLOUDTRAIL"))
 
-        :group: Inputs
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="GROK")
+    def GROK(cls) -> "SerializationLibrary":
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultRouteTableId"))
+        :see: https://docs.aws.amazon.com/athena/latest/ug/grok.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "GROK"))
 
-    @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''The description of the transit gateway.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="HIVE_JSON")
+    def HIVE_JSON(cls) -> "SerializationLibrary":
+        '''
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hive/hcatalog/data/JsonSerDe.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "HIVE_JSON"))
 
-        :see: `TransitGateway.Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description>`_
-        :group: Inputs
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="LAZY_SIMPLE")
+    def LAZY_SIMPLE(cls) -> "SerializationLibrary":
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "LAZY_SIMPLE"))
 
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="OPEN_CSV")
+    def OPEN_CSV(cls) -> "SerializationLibrary":
+        '''
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/OpenCSVSerde.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "OPEN_CSV"))
 
-        Used to tag the transit gateway with a name that will be displayed in the
-        AWS VPC console.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="OPENX_JSON")
+    def OPENX_JSON(cls) -> "SerializationLibrary":
+        '''
+        :see: https://github.com/rcongiu/Hive-JSON-Serde
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "OPENX_JSON"))
 
-        :see: `TransitGateway.Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags>`_
-        :group: Inputs
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ORC")
+    def ORC(cls) -> "SerializationLibrary":
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcSerde.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "ORC"))
 
-    @builtins.property
-    @jsii.member(jsii_name="resourceShare")
-    def resource_share(self) -> typing.Optional[_ResourceShare_f0180713]:
-        '''The RAM resource share that is used for sharing the transit gateway with other accounts.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PARQUET")
+    def PARQUET(cls) -> "SerializationLibrary":
+        '''
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/serde/ParquetHiveSerDe.html
+        '''
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "PARQUET"))
 
-        :group: Resources
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="REGEXP")
+    def REGEXP(cls) -> "SerializationLibrary":
+        '''
+        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/RegexSerDe.html
         '''
-        return typing.cast(typing.Optional[_ResourceShare_f0180713], jsii.get(self, "resourceShare"))
+        return typing.cast("SerializationLibrary", jsii.sget(cls, "REGEXP"))
 
     @builtins.property
-    @jsii.member(jsii_name="vpnEcmpSupport")
-    def vpn_ecmp_support(self) -> typing.Optional[builtins.bool]:
-        '''Enable or disable Equal Cost Multipath Protocol support.
+    @jsii.member(jsii_name="className")
+    def class_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "className"))
 
-        :see: `Achieve ECMP with multiple VPN tunnels <https://aws.amazon.com/premiumsupport/knowledge-center/transit-gateway-ecmp-multiple-tunnels/>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "vpnEcmpSupport"))
 
-
-@jsii.implements(ITransitGatewayAttachment)
-class TransitGatewayAttachmentBase(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentBase",
+class StructColumn(
+    Column,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.StructColumn",
 ):
-    '''A base class providing common functionality between created and imported Transit Gateway Attachments.'''
-
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        data: typing.Optional[typing.Sequence[Column]] = None,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
     ) -> None:
         '''
-        :param scope: -
-        :param id: -
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param data: 
+        :param comment: 
+        :param name: 
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b49d47ed81c7ffb2a1650ef26c6a7262dbfbe5b02d6a33f4521aaba40facd96b)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = _aws_cdk_ceddda9d.ResourceProps(
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        props = StructColumnProps(data=data, comment=comment, name=name)
 
-        jsii.create(self.__class__, self, [scope, id, props])
+        jsii.create(self.__class__, self, [props])
 
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        cidr: builtins.str,
-        route_table: ITransitGatewayRouteTable,
-    ) -> ITransitGatewayRoute:
-        '''Adds a route that directs traffic to this transit gateway attachment.
+    @jsii.member(jsii_name="addColumn")
+    def add_column(self, column: Column) -> None:
+        '''
+        :param column: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f6397af3f7e2865b94205ae66351b5049b1e24eddfccbee733dc294c875d1e29)
+            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
+        return typing.cast(None, jsii.invoke(self, "addColumn", [column]))
+
+    @builtins.property
+    @jsii.member(jsii_name="typeString")
+    def type_string(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "typeString"))
 
-        :param cidr: CIDR range that should be routed to this attachment.
-        :param route_table: The transit gateway route table where the route should be added.
 
-        :return: The TransitGatewayRoute that was added.
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.StructColumnProps",
+    jsii_struct_bases=[ColumnProps],
+    name_mapping={"comment": "comment", "name": "name", "data": "data"},
+)
+class StructColumnProps(ColumnProps):
+    def __init__(
+        self,
+        *,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        data: typing.Optional[typing.Sequence[Column]] = None,
+    ) -> None:
+        '''
+        :param comment: 
+        :param name: 
+        :param data: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3c4b8aae9fc7113caa263f0a78c3a90cd7457571433a27e89da36b0ae99fc4c6)
-            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
-            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
-        return typing.cast(ITransitGatewayRoute, jsii.invoke(self, "addRoute", [cidr, route_table]))
+            type_hints = typing.get_type_hints(_typecheckingstub__be752f0e2780faa753092d75b32484d8113fe2d5f788daa3dfd242fa215de246)
+            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if comment is not None:
+            self._values["comment"] = comment
+        if name is not None:
+            self._values["name"] = name
+        if data is not None:
+            self._values["data"] = data
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    @abc.abstractmethod
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway Attachment.'''
-        ...
+    def comment(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("comment")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    @abc.abstractmethod
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The name of this Transit Gateway Attachment.'''
-        ...
-
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-class _TransitGatewayAttachmentBaseProxy(
-    TransitGatewayAttachmentBase,
-    jsii.proxy_for(_aws_cdk_ceddda9d.Resource), # type: ignore[misc]
-):
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+    def data(self) -> typing.Optional[typing.List[Column]]:
+        result = self._values.get("data")
+        return typing.cast(typing.Optional[typing.List[Column]], result)
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The name of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, TransitGatewayAttachmentBase).__jsii_proxy_class__ = lambda : _TransitGatewayAttachmentBaseProxy
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "StructColumnProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class TransitGatewayAttachmentResource(
-    TransitGatewayAttachmentBase,
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentResource",
+class Table(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.Table",
 ):
-    '''Attaches a VPC to a transit gateway.
+    '''Creates a Table resource specifying tabular data in the Glue Database.
 
-    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC
-    that is already attached, the new VPC CIDR range is not propagated to the
-    default propagation route table.
+    :see: `AWS::Glue::Table <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-table.html>`_
     '''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        transit_gateway: ITransitGateway,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        appliance_mode_support: typing.Optional[builtins.bool] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        ipv6_support: typing.Optional[builtins.bool] = None,
+        database: Database,
+        columns: typing.Optional[typing.Sequence[Column]] = None,
+        compressed: typing.Optional[builtins.bool] = None,
+        data_format: typing.Optional[DataFormat] = None,
+        description: typing.Optional[builtins.str] = None,
+        location: typing.Optional[builtins.str] = None,
         name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        owner: typing.Optional[builtins.str] = None,
+        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        partition_keys: typing.Optional[typing.Sequence[Column]] = None,
+        retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        serde_name: typing.Optional[builtins.str] = None,
+        serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        stored_as_sub_directories: typing.Optional[builtins.bool] = None,
+        table_type: typing.Optional["TableType"] = None,
+        target_table: typing.Optional["Table"] = None,
+        view_expanded_text: typing.Optional[builtins.str] = None,
+        view_original_text: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the TransitGatewayAttachment class.
+        '''Creates a new instance of the Table class.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway: The transit gateway for which the attachment should be created.
-        :param vpc: The VPC where the attachment should be created.
-        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
-        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
+        :param database: Database object to add Table to.
+        :param columns: A list of the Columns in the table.
+        :param compressed: True if the data in the table is compressed, or False if not.
+        :param data_format: DataFormat object indicating the expected input/output format.
+        :param description: A description for the Table.
+        :param location: The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
+        :param name: A name for the Table.
+        :param owner: The table owner. Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
+        :param parameters: These key-value pairs define properties associated with the table.
+        :param partition_keys: A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
+        :param retention: The retention time for this table.
+        :param serde_name: Name of the SerDe.
+        :param serde_parameters: These key-value pairs define initialization parameters for the SerDe.
+        :param storage_parameters: The user-supplied properties in key-value form.
+        :param stored_as_sub_directories: True if the table data is stored in subdirectories, or False if not.
+        :param table_type: The type of this table. AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
+        :param target_table: A TableIdentifier structure that describes a target table for resource linking.
+        :param view_expanded_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
+        :param view_original_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__06c53aa420590eceea4fb9b075681a4977d93106ad928386f59f565ada883d5b)
+            type_hints = typing.get_type_hints(_typecheckingstub__2eec6dbec86f7128ae48e38b1289cfeaade58e92058db1f726cfe7935a152444)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayAttachmentResourceProps(
-            transit_gateway=transit_gateway,
-            vpc=vpc,
-            appliance_mode_support=appliance_mode_support,
-            dns_support=dns_support,
-            ipv6_support=ipv6_support,
+        props = TableProps(
+            database=database,
+            columns=columns,
+            compressed=compressed,
+            data_format=data_format,
+            description=description,
+            location=location,
             name=name,
-            subnets=subnets,
+            owner=owner,
+            parameters=parameters,
+            partition_keys=partition_keys,
+            retention=retention,
+            serde_name=serde_name,
+            serde_parameters=serde_parameters,
+            storage_parameters=storage_parameters,
+            stored_as_sub_directories=stored_as_sub_directories,
+            table_type=table_type,
+            target_table=target_table,
+            view_expanded_text=view_expanded_text,
+            view_original_text=view_original_text,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="translateBoolean")
-    def _translate_boolean(
-        self,
-        val: typing.Optional[builtins.bool] = None,
-    ) -> typing.Optional[builtins.str]:
-        '''Translates a boolean input into the strings used by the transit gateway attachment resource to implement boolean values.
-
-        :param val: The input value to translate.
-
-        :return:
-
-        The string used to reprersent the input boolean or undefined if
-        the input boolean is undefined.
+    @jsii.member(jsii_name="addColumn")
+    def add_column(self, column: Column) -> None:
+        '''
+        :param column: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d9616ce11448deda7c7f7a6abcc3dc7343fd9d23bf7197f988d750a4ed8ab7b9)
-            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
-        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "translateBoolean", [val]))
+            type_hints = typing.get_type_hints(_typecheckingstub__7e19c0d356c0722d5d2e88f68d65807d5bf7af6ed343ef572db7c40d331591b4)
+            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
+        return typing.cast(None, jsii.invoke(self, "addColumn", [column]))
 
-    @builtins.property
-    @jsii.member(jsii_name="subnets")
-    def subnets(self) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
-        '''The subnets where the attachment should be created.
-
-        Can select up to one subnet per Availability Zone.
+    @jsii.member(jsii_name="addParameter")
+    def add_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        '''
+        :param key: -
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__32c8dcc447fc94c914aa9117344531cb4adafbbd95e95f5e533aa4ec40ff0b07)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addParameter", [key, value]))
 
-        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
-        :group: Inputs
+    @jsii.member(jsii_name="addPartitionKey")
+    def add_partition_key(self, column: Column) -> None:
+        '''
+        :param column: -
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.get(self, "subnets"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__45a820867b3372f968d0356f688bd57f2fabd57b9a6f1d007bfef4a653dc0d7d)
+            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
+        return typing.cast(None, jsii.invoke(self, "addPartitionKey", [column]))
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGateway")
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway for which the attachment should be created.
+    @jsii.member(jsii_name="addSerdeParameter")
+    def add_serde_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        '''
+        :param key: -
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f39ac55f4ec3d384f9e5cb679d42b04bee73ebfeeb4e4ef12d7f135353860879)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addSerdeParameter", [key, value]))
 
-        :group: Inputs
+    @jsii.member(jsii_name="addStorageParameter")
+    def add_storage_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        '''
+        :param key: -
+        :param value: -
         '''
-        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dbe94e982d260f87bd2f2b4bdd58ff506d9e25d5fad5f73ce4d04443585752c0)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addStorageParameter", [key, value]))
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    @abc.abstractmethod
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway Attachment.'''
-        ...
+    @jsii.member(jsii_name="renderStorageDescriptor")
+    def _render_storage_descriptor(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_glue_ceddda9d.CfnTable.StorageDescriptorProperty]:
+        return typing.cast(typing.Optional[_aws_cdk_aws_glue_ceddda9d.CfnTable.StorageDescriptorProperty], jsii.invoke(self, "renderStorageDescriptor", []))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    @abc.abstractmethod
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of this Transit Gateway Attachment.'''
-        ...
+    @jsii.member(jsii_name="database")
+    def database(self) -> Database:
+        '''{@link TableProps.database:}.'''
+        return typing.cast(Database, jsii.get(self, "database"))
 
     @builtins.property
-    @jsii.member(jsii_name="vpc")
-    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
-        '''The VPC where the attachment should be created.
-
-        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
-        :group: Inputs
-        '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, jsii.get(self, "vpc"))
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnTable:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTable, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="applianceModeSupport")
-    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables appliance mode on the attachment.
+    @jsii.member(jsii_name="tableArn")
+    def table_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "tableArn"))
 
-        When appliance mode is enabled, all traffic flowing between attachments is
-        forwarded to an appliance in a shared VPC to be inspected and processed.
+    @builtins.property
+    @jsii.member(jsii_name="tableName")
+    def table_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "tableName"))
 
-        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "applianceModeSupport"))
+    @builtins.property
+    @jsii.member(jsii_name="compressed")
+    def compressed(self) -> typing.Optional[builtins.bool]:
+        '''{@link TableProps.compressed}.'''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "compressed"))
 
     @builtins.property
-    @jsii.member(jsii_name="dnsSupport")
-    def dns_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
+    @jsii.member(jsii_name="dataFormat")
+    def data_format(self) -> typing.Optional[DataFormat]:
+        '''{@link TableProps.dataFormat}.'''
+        return typing.cast(typing.Optional[DataFormat], jsii.get(self, "dataFormat"))
 
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
-        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "dnsSupport"))
+    @builtins.property
+    @jsii.member(jsii_name="location")
+    def location(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.location}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "location"))
 
     @builtins.property
-    @jsii.member(jsii_name="ipv6Support")
-    def ipv6_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
+    @builtins.property
+    @jsii.member(jsii_name="owner")
+    def owner(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.owner}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "owner"))
 
-        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "ipv6Support"))
+    @builtins.property
+    @jsii.member(jsii_name="retention")
+    def retention(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''{@link TableProps.retention}.'''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "retention"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Transit Gateway Attachment.
+    @jsii.member(jsii_name="serdeName")
+    def serde_name(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.serdeName}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serdeName"))
 
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
+    @builtins.property
+    @jsii.member(jsii_name="storedAsSubDirectories")
+    def stored_as_sub_directories(self) -> typing.Optional[builtins.bool]:
+        '''{@link TableProps.storedAsSubDirectories}.'''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "storedAsSubDirectories"))
 
-        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    @builtins.property
+    @jsii.member(jsii_name="tableType")
+    def table_type(self) -> typing.Optional["TableType"]:
+        '''{@link TableProps.tableType}.'''
+        return typing.cast(typing.Optional["TableType"], jsii.get(self, "tableType"))
 
+    @builtins.property
+    @jsii.member(jsii_name="targetTable")
+    def target_table(self) -> typing.Optional["Table"]:
+        '''{@link TableProps.targetTable}.'''
+        return typing.cast(typing.Optional["Table"], jsii.get(self, "targetTable"))
 
-class _TransitGatewayAttachmentResourceProxy(
-    TransitGatewayAttachmentResource,
-    jsii.proxy_for(TransitGatewayAttachmentBase), # type: ignore[misc]
-):
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+    @jsii.member(jsii_name="viewExpandedText")
+    def view_expanded_text(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.viewExpandedText}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "viewExpandedText"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
+    @jsii.member(jsii_name="viewOriginalText")
+    def view_original_text(self) -> typing.Optional[builtins.str]:
+        '''{@link TableProps.viewOriginalText}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "viewOriginalText"))
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, TransitGatewayAttachmentResource).__jsii_proxy_class__ = lambda : _TransitGatewayAttachmentResourceProxy
+
+@jsii.enum(jsii_type="cdk-extensions.glue.TableGroupingPolicy")
+class TableGroupingPolicy(enum.Enum):
+    COMBINE_COMPATIBLE_SCHEMAS = "COMBINE_COMPATIBLE_SCHEMAS"
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentResourceProps",
+    jsii_type="cdk-extensions.glue.TableProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "transit_gateway": "transitGateway",
-        "vpc": "vpc",
-        "appliance_mode_support": "applianceModeSupport",
-        "dns_support": "dnsSupport",
-        "ipv6_support": "ipv6Support",
+        "database": "database",
+        "columns": "columns",
+        "compressed": "compressed",
+        "data_format": "dataFormat",
+        "description": "description",
+        "location": "location",
         "name": "name",
-        "subnets": "subnets",
+        "owner": "owner",
+        "parameters": "parameters",
+        "partition_keys": "partitionKeys",
+        "retention": "retention",
+        "serde_name": "serdeName",
+        "serde_parameters": "serdeParameters",
+        "storage_parameters": "storageParameters",
+        "stored_as_sub_directories": "storedAsSubDirectories",
+        "table_type": "tableType",
+        "target_table": "targetTable",
+        "view_expanded_text": "viewExpandedText",
+        "view_original_text": "viewOriginalText",
     },
 )
-class TransitGatewayAttachmentResourceProps(_aws_cdk_ceddda9d.ResourceProps):
+class TableProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        transit_gateway: ITransitGateway,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        appliance_mode_support: typing.Optional[builtins.bool] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        ipv6_support: typing.Optional[builtins.bool] = None,
+        database: Database,
+        columns: typing.Optional[typing.Sequence[Column]] = None,
+        compressed: typing.Optional[builtins.bool] = None,
+        data_format: typing.Optional[DataFormat] = None,
+        description: typing.Optional[builtins.str] = None,
+        location: typing.Optional[builtins.str] = None,
         name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        owner: typing.Optional[builtins.str] = None,
+        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        partition_keys: typing.Optional[typing.Sequence[Column]] = None,
+        retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        serde_name: typing.Optional[builtins.str] = None,
+        serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        stored_as_sub_directories: typing.Optional[builtins.bool] = None,
+        table_type: typing.Optional["TableType"] = None,
+        target_table: typing.Optional[Table] = None,
+        view_expanded_text: typing.Optional[builtins.str] = None,
+        view_original_text: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for TransitGatewayAttachmentResource resource.
+        '''Configuration for Table.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param transit_gateway: The transit gateway for which the attachment should be created.
-        :param vpc: The VPC where the attachment should be created.
-        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
-        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
+        :param database: Database object to add Table to.
+        :param columns: A list of the Columns in the table.
+        :param compressed: True if the data in the table is compressed, or False if not.
+        :param data_format: DataFormat object indicating the expected input/output format.
+        :param description: A description for the Table.
+        :param location: The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
+        :param name: A name for the Table.
+        :param owner: The table owner. Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
+        :param parameters: These key-value pairs define properties associated with the table.
+        :param partition_keys: A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
+        :param retention: The retention time for this table.
+        :param serde_name: Name of the SerDe.
+        :param serde_parameters: These key-value pairs define initialization parameters for the SerDe.
+        :param storage_parameters: The user-supplied properties in key-value form.
+        :param stored_as_sub_directories: True if the table data is stored in subdirectories, or False if not.
+        :param table_type: The type of this table. AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
+        :param target_table: A TableIdentifier structure that describes a target table for resource linking.
+        :param view_expanded_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
+        :param view_original_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
         '''
-        if isinstance(subnets, dict):
-            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3d1c15189bbc90871ac0f1cb7928d7a06dc7a543bed65a3917a78189021d8767)
+            type_hints = typing.get_type_hints(_typecheckingstub__c47a2c9840f823b7524821e05bdf6ea2222940a7cf7b637b2dae2f91266503ee)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
-            check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
-            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
-            check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
+            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
+            check_type(argname="argument columns", value=columns, expected_type=type_hints["columns"])
+            check_type(argname="argument compressed", value=compressed, expected_type=type_hints["compressed"])
+            check_type(argname="argument data_format", value=data_format, expected_type=type_hints["data_format"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+            check_type(argname="argument owner", value=owner, expected_type=type_hints["owner"])
+            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
+            check_type(argname="argument partition_keys", value=partition_keys, expected_type=type_hints["partition_keys"])
+            check_type(argname="argument retention", value=retention, expected_type=type_hints["retention"])
+            check_type(argname="argument serde_name", value=serde_name, expected_type=type_hints["serde_name"])
+            check_type(argname="argument serde_parameters", value=serde_parameters, expected_type=type_hints["serde_parameters"])
+            check_type(argname="argument storage_parameters", value=storage_parameters, expected_type=type_hints["storage_parameters"])
+            check_type(argname="argument stored_as_sub_directories", value=stored_as_sub_directories, expected_type=type_hints["stored_as_sub_directories"])
+            check_type(argname="argument table_type", value=table_type, expected_type=type_hints["table_type"])
+            check_type(argname="argument target_table", value=target_table, expected_type=type_hints["target_table"])
+            check_type(argname="argument view_expanded_text", value=view_expanded_text, expected_type=type_hints["view_expanded_text"])
+            check_type(argname="argument view_original_text", value=view_original_text, expected_type=type_hints["view_original_text"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "transit_gateway": transit_gateway,
-            "vpc": vpc,
+            "database": database,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if appliance_mode_support is not None:
-            self._values["appliance_mode_support"] = appliance_mode_support
-        if dns_support is not None:
-            self._values["dns_support"] = dns_support
-        if ipv6_support is not None:
-            self._values["ipv6_support"] = ipv6_support
+        if columns is not None:
+            self._values["columns"] = columns
+        if compressed is not None:
+            self._values["compressed"] = compressed
+        if data_format is not None:
+            self._values["data_format"] = data_format
+        if description is not None:
+            self._values["description"] = description
+        if location is not None:
+            self._values["location"] = location
         if name is not None:
             self._values["name"] = name
-        if subnets is not None:
-            self._values["subnets"] = subnets
+        if owner is not None:
+            self._values["owner"] = owner
+        if parameters is not None:
+            self._values["parameters"] = parameters
+        if partition_keys is not None:
+            self._values["partition_keys"] = partition_keys
+        if retention is not None:
+            self._values["retention"] = retention
+        if serde_name is not None:
+            self._values["serde_name"] = serde_name
+        if serde_parameters is not None:
+            self._values["serde_parameters"] = serde_parameters
+        if storage_parameters is not None:
+            self._values["storage_parameters"] = storage_parameters
+        if stored_as_sub_directories is not None:
+            self._values["stored_as_sub_directories"] = stored_as_sub_directories
+        if table_type is not None:
+            self._values["table_type"] = table_type
+        if target_table is not None:
+            self._values["target_table"] = target_table
+        if view_expanded_text is not None:
+            self._values["view_expanded_text"] = view_expanded_text
+        if view_original_text is not None:
+            self._values["view_original_text"] = view_original_text
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -3137,814 +5586,539 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway for which the attachment should be created.
-
-        :see: `TransitGatewayVpcAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid>`_
-        '''
-        result = self._values.get("transit_gateway")
-        assert result is not None, "Required property 'transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
+    def database(self) -> Database:
+        '''Database object to add Table to.'''
+        result = self._values.get("database")
+        assert result is not None, "Required property 'database' is missing"
+        return typing.cast(Database, result)
 
     @builtins.property
-    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
-        '''The VPC where the attachment should be created.
+    def columns(self) -> typing.Optional[typing.List[Column]]:
+        '''A list of the Columns in the table.
 
-        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
+        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-columns>`_
         '''
-        result = self._values.get("vpc")
-        assert result is not None, "Required property 'vpc' is missing"
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
+        result = self._values.get("columns")
+        return typing.cast(typing.Optional[typing.List[Column]], result)
 
     @builtins.property
-    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables appliance mode on the attachment.
+    def compressed(self) -> typing.Optional[builtins.bool]:
+        '''True if the data in the table is compressed, or False if not.
 
-        When appliance mode is enabled, all traffic flowing between attachments is
-        forwarded to an appliance in a shared VPC to be inspected and processed.
-
-        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
+        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-compressed>`_
         '''
-        result = self._values.get("appliance_mode_support")
+        result = self._values.get("compressed")
         return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def dns_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
-
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
+    def data_format(self) -> typing.Optional[DataFormat]:
+        '''DataFormat object indicating the expected input/output format.'''
+        result = self._values.get("data_format")
+        return typing.cast(typing.Optional[DataFormat], result)
 
-        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
-        '''
-        result = self._values.get("dns_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description for the Table.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def ipv6_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
+    def location(self) -> typing.Optional[builtins.str]:
+        '''The physical location of the table.
 
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
+        By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
 
-        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
+        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-location>`_
         '''
-        result = self._values.get("ipv6_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("location")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
     def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Transit Gateway Attachment.
-
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
-
-        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
-        '''
+        '''A name for the Table.'''
         result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''The subnets where the attachment should be created.
+    def owner(self) -> typing.Optional[builtins.str]:
+        '''The table owner.
 
-        Can select up to one subnet per Availability Zone.
+        Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
 
-        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-owner>`_
         '''
-        result = self._values.get("subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        result = self._values.get("owner")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    def __repr__(self) -> str:
-        return "TransitGatewayAttachmentResourceProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''These key-value pairs define properties associated with the table.
 
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-parameters>`_
+        '''
+        result = self._values.get("parameters")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
-@jsii.implements(ILocalVpnEndpoint)
-class TransitGatewayLocalVpnEndpoint(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayLocalVpnEndpoint",
-):
-    '''Specifies a VPN connection endpoint which routes to a transit gateway on the AWS side.'''
+    @builtins.property
+    def partition_keys(self) -> typing.Optional[typing.List[Column]]:
+        '''A list of columns by which the table is partitioned.
 
-    def __init__(self, transit_gateway: ITransitGateway) -> None:
-        '''Creates a new instance of the TransitGatewayLocalVpnEndpoint class.
+        Only primitive types are supported as partition keys.
 
-        :param transit_gateway: The transit gateway that serves as the local end of a VPN connection.
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-parameterskeys>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__085d2039b0a4b4caf19e1943608efeb5e97be1be7d732ad9e6c87845449f8c0e)
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-        jsii.create(self.__class__, self, [transit_gateway])
+        result = self._values.get("partition_keys")
+        return typing.cast(typing.Optional[typing.List[Column]], result)
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> LocalVpnEndpointConfiguration:
-        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+    @builtins.property
+    def retention(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The retention time for this table.
 
-        :param _scope: The construct configuring the VPN connection that will be referencing the local endpoint.
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-retention>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1649477704b8d5959bab11d00a58a0814e904ca0755f79fc92c902b7548831e8)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(LocalVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
+        result = self._values.get("retention")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGateway")
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway that serves as the local end of a VPN connection.
+    def serde_name(self) -> typing.Optional[builtins.str]:
+        '''Name of the SerDe.
 
-        :group: Inputs
+        :see: `AWS::Glue::Table SerdeInfo <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-serdeinfo.html#cfn-glue-table-serdeinfo-name>`_
         '''
-        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
+        result = self._values.get("serde_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    @builtins.property
+    def serde_parameters(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''These key-value pairs define initialization parameters for the SerDe.
 
-class TransitGatewayNatProvider(
-    _aws_cdk_aws_ec2_ceddda9d.NatProvider,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayNatProvider",
-):
-    def __init__(self, *, transit_gateway: ITransitGateway) -> None:
-        '''
-        :param transit_gateway: 
+        :see: `AWS::Glue::Table SerdeInfo <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-serdeinfo.html#cfn-glue-table-serdeinfo-parameters>`_
         '''
-        options = TransitGatewayNatProviderOptions(transit_gateway=transit_gateway)
+        result = self._values.get("serde_parameters")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
-        jsii.create(self.__class__, self, [options])
-
-    @jsii.member(jsii_name="configureNat")
-    def configure_nat(
+    @builtins.property
+    def storage_parameters(
         self,
-        *,
-        nat_subnets: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.PublicSubnet],
-        private_subnets: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.PrivateSubnet],
-        vpc: _aws_cdk_aws_ec2_ceddda9d.Vpc,
-    ) -> None:
-        '''Called by the VPC to configure NAT
-
-Don't call this directly, the VPC will call it automatically.
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''The user-supplied properties in key-value form.
 
-        :param nat_subnets: The public subnets where the NAT providers need to be placed.
-        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
-        :param vpc: The VPC we're configuring NAT for.
+        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-parameters>`_
         '''
-        options = _aws_cdk_aws_ec2_ceddda9d.ConfigureNatOptions(
-            nat_subnets=nat_subnets, private_subnets=private_subnets, vpc=vpc
-        )
+        result = self._values.get("storage_parameters")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
-        return typing.cast(None, jsii.invoke(self, "configureNat", [options]))
+    @builtins.property
+    def stored_as_sub_directories(self) -> typing.Optional[builtins.bool]:
+        '''True if the table data is stored in subdirectories, or False if not.
 
-    @jsii.member(jsii_name="configureSubnet")
-    def configure_subnet(self, subnet: _aws_cdk_aws_ec2_ceddda9d.PrivateSubnet) -> None:
-        '''Configures subnet with the gateway
+        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-storedassubdirectories>`_
+        '''
+        result = self._values.get("stored_as_sub_directories")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def table_type(self) -> typing.Optional["TableType"]:
+        '''The type of this table.
 
-Don't call this directly, the VPC will call it automatically.
+        AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
 
-        :param subnet: -
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-tabletype>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2ce5b6c12f42e572c0fd8116f08202bd45321782d0dface0d78758e8ae4afce0)
-            check_type(argname="argument subnet", value=subnet, expected_type=type_hints["subnet"])
-        return typing.cast(None, jsii.invoke(self, "configureSubnet", [subnet]))
+        result = self._values.get("table_type")
+        return typing.cast(typing.Optional["TableType"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="configuredGateways")
-    def configured_gateways(
-        self,
-    ) -> typing.List[_aws_cdk_aws_ec2_ceddda9d.GatewayConfig]:
-        '''Return list of gateways spawned by the provider.'''
-        return typing.cast(typing.List[_aws_cdk_aws_ec2_ceddda9d.GatewayConfig], jsii.get(self, "configuredGateways"))
+    def target_table(self) -> typing.Optional[Table]:
+        '''A TableIdentifier structure that describes a target table for resource linking.
 
-    @builtins.property
-    @jsii.member(jsii_name="transitGateway")
-    def transit_gateway(self) -> ITransitGateway:
-        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-targettable>`_
+        '''
+        result = self._values.get("target_table")
+        return typing.cast(typing.Optional[Table], result)
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachment")
-    def transit_gateway_attachment(self) -> typing.Optional["TransitGatewayAttachment"]:
-        return typing.cast(typing.Optional["TransitGatewayAttachment"], jsii.get(self, "transitGatewayAttachment"))
+    def view_expanded_text(self) -> typing.Optional[builtins.str]:
+        '''Included for Apache Hive compatibility.
 
+        Not used in the normal course of AWS Glue operations.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayNatProviderOptions",
-    jsii_struct_bases=[],
-    name_mapping={"transit_gateway": "transitGateway"},
-)
-class TransitGatewayNatProviderOptions:
-    def __init__(self, *, transit_gateway: ITransitGateway) -> None:
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-viewexpandedtext>`_
         '''
-        :param transit_gateway: 
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3d866260e3cfdb20c411a4b77ce2ef5ed9046a68ea0356988681824395af2b48)
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "transit_gateway": transit_gateway,
-        }
+        result = self._values.get("view_expanded_text")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def transit_gateway(self) -> ITransitGateway:
-        result = self._values.get("transit_gateway")
-        assert result is not None, "Required property 'transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
+    def view_original_text(self) -> typing.Optional[builtins.str]:
+        '''Included for Apache Hive compatibility.
+
+        Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
+
+        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-vieworiginaltext>`_
+        '''
+        result = self._values.get("view_original_text")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayNatProviderOptions(%s)" % ", ".join(
+        return "TableProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(ITransitGatewayPeeringAttachment)
-class TransitGatewayPeeringAttachment(
-    TransitGatewayAttachmentBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachment",
-):
-    '''Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).
+@jsii.enum(jsii_type="cdk-extensions.glue.TableType")
+class TableType(enum.Enum):
+    EXTERNAL_TABLE = "EXTERNAL_TABLE"
+    VIRTUAL_VIEW = "VIRTUAL_VIEW"
 
-    The peer transit
-    gateway can be in your account or a different AWS account.
 
-    After you create the peering attachment, the owner of the accepter transit
-    gateway must accept the attachment request.
+@jsii.enum(jsii_type="cdk-extensions.glue.TableUpdateBehavior")
+class TableUpdateBehavior(enum.Enum):
+    MERGE_NEW_COLUMNS = "MERGE_NEW_COLUMNS"
 
-    :see: `AWS::EC2::TransitGatewayPeeringAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html>`_
-    '''
 
+@jsii.implements(ITrigger)
+class Trigger(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.Trigger",
+):
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        local_transit_gateway: ITransitGateway,
-        peer_transit_gateway: ITransitGateway,
+        type: "TriggerType",
+        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+        description: typing.Optional[builtins.str] = None,
         name: typing.Optional[builtins.str] = None,
-        peer_account_id: typing.Optional[builtins.str] = None,
-        peer_region: typing.Optional[builtins.str] = None,
+        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+        predicate_operator: typing.Optional[PredicateOperator] = None,
+        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        start_on_creation: typing.Optional[builtins.bool] = None,
+        workflow: typing.Optional["Workflow"] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the TransitGatewayPeeringAttachment class.
+        '''Creates a new instance of the Trigger class.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param local_transit_gateway: The local side of the transit gateway peering connection.
-        :param peer_transit_gateway: The remote transit gateway being peered with.
-        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param peer_account_id: The account that contains the transit gateway being peered with.
-        :param peer_region: The region that contains the transit gateway being peered with.
+        :param type: The type of trigger that this is.
+        :param actions: A list of actions initiated by this trigger.
+        :param description: A description for the trigger.
+        :param name: A name for the trigger.
+        :param predicate_conditions: A list of the conditions that determine when the trigger will fire.
+        :param predicate_operator: Operator for chaining predicate conditions if multiple are given.
+        :param schedule: A cron expression used to specify the schedule.
+        :param start_on_creation: Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
+        :param workflow: The name of the workflow associated with the trigger.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__094bd3c738b0a006e2a59600942e6cb57ce41b066d2acabef2f32729f9b6c14c)
+            type_hints = typing.get_type_hints(_typecheckingstub__9a79049a428bd5941424b4e094c84a859a725f32c171d87ac2126a1685ef641f)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayPeeringAttachmentProps(
-            local_transit_gateway=local_transit_gateway,
-            peer_transit_gateway=peer_transit_gateway,
+        props = TriggerProps(
+            type=type,
+            actions=actions,
+            description=description,
             name=name,
-            peer_account_id=peer_account_id,
-            peer_region=peer_region,
+            predicate_conditions=predicate_conditions,
+            predicate_operator=predicate_operator,
+            schedule=schedule,
+            start_on_creation=start_on_creation,
+            workflow=workflow,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentArn")
+    @jsii.member(jsii_name="fromTriggerArn")
     @builtins.classmethod
-    def from_transit_gateway_peering_attachment_arn(
+    def from_trigger_arn(
         cls,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
-        arn: builtins.str,
-    ) -> ITransitGatewayPeeringAttachment:
-        '''Imports an existing transit gateway peering attachment using its ARN.
+        trigger_arn: builtins.str,
+    ) -> ITrigger:
+        '''Imports an existing trigger using its Amazon Resource Name (ARN).
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param arn: The Amazon Resource Name (ARN) of the resource being imported.
+        :param trigger_arn: The ARN of the trigger to import.
 
-        :return:
-
-        An object representing the imported transit gateway peering
-        attachment.
+        :return: An object representing the trigger that was imported.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d64bc0ce43e9c832901d2f4073f54276e12b588a41c623026825482bf1d43c63)
+            type_hints = typing.get_type_hints(_typecheckingstub__d29de485fa07fbea64e912490718223776c3ab360b719de644012a94fb6434f7)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
-        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentArn", [scope, id, arn]))
+            check_type(argname="argument trigger_arn", value=trigger_arn, expected_type=type_hints["trigger_arn"])
+        return typing.cast(ITrigger, jsii.sinvoke(cls, "fromTriggerArn", [scope, id, trigger_arn]))
 
-    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentAttributes")
+    @jsii.member(jsii_name="fromTriggerName")
     @builtins.classmethod
-    def from_transit_gateway_peering_attachment_attributes(
+    def from_trigger_name(
         cls,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
-        *,
-        arn: typing.Optional[builtins.str] = None,
-        attachment_id: typing.Optional[builtins.str] = None,
-        creation_time: typing.Optional[builtins.str] = None,
-        state: typing.Optional[builtins.str] = None,
-        status: typing.Optional[builtins.str] = None,
-        status_code: typing.Optional[builtins.str] = None,
-        status_message: typing.Optional[builtins.str] = None,
-    ) -> ITransitGatewayPeeringAttachment:
-        '''Imports an existing transit gateway peering attachment by defining its components.
+        trigger_name: builtins.str,
+    ) -> ITrigger:
+        '''Imports an existing trigger using its name.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param arn: The ARN of this Transit Gateway Attachment.
-        :param attachment_id: The ID of this Transit Gateway Attachment.
-        :param creation_time: The time the transit gateway peering attachment was created.
-        :param state: The state of the transit gateway peering attachment.
-        :param status: The status of the transit gateway peering attachment.
-        :param status_code: The status code for the current status of the attachment.
-        :param status_message: The status message for the current status of the attachment.
+        :param trigger_name: The name of the trigger to import.
 
-        :return:
-
-        An object representing the imported transit gateway peering
-        attachment.
+        :return: An object representing the trigger that was imported.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9b9ddfaf131e6a5091a636a0dad2dd2579ae4140b68c99fe5fee2e2506d45105)
+            type_hints = typing.get_type_hints(_typecheckingstub__f3434fb8f553f52f60a3e025608013104918640090d3d63398c7aa99c372b20d)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        attrs = TransitGatewayPeeringAttachmentImportAttributes(
-            arn=arn,
-            attachment_id=attachment_id,
-            creation_time=creation_time,
-            state=state,
-            status=status,
-            status_code=status_code,
-            status_message=status_message,
-        )
-
-        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentAttributes", [scope, id, attrs]))
+            check_type(argname="argument trigger_name", value=trigger_name, expected_type=type_hints["trigger_name"])
+        return typing.cast(ITrigger, jsii.sinvoke(cls, "fromTriggerName", [scope, id, trigger_name]))
 
-    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentId")
-    @builtins.classmethod
-    def from_transit_gateway_peering_attachment_id(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        attachment_id: builtins.str,
-    ) -> ITransitGatewayPeeringAttachment:
-        '''Imports an existing transit gateway peering attachment using its attachment ID.
+    @jsii.member(jsii_name="addAction")
+    def add_action(self, action: ITriggerAction) -> "Trigger":
+        '''Registers an action with the trigger.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param attachment_id: The ID of the resource being imported.
+        All actions associated with the
+        trigger are run when the conditions to trigger the trigger are met.
 
-        :return:
+        :param action: The action to be run by this trigger.
 
-        An object representing the imported transit gateway peering
-        attachment.
+        :return: The trigger to which the action was added.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__fe35553be2f81ae71d207839c426c22b6542d57d2604a744dec33a748b8631f6)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument attachment_id", value=attachment_id, expected_type=type_hints["attachment_id"])
-        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentId", [scope, id, attachment_id]))
+            type_hints = typing.get_type_hints(_typecheckingstub__bc007dfc129810a05403a45fc2edb04eac2ac69328ffffbe932ae17113d5f057)
+            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
+        return typing.cast("Trigger", jsii.invoke(self, "addAction", [action]))
 
-    @builtins.property
-    @jsii.member(jsii_name="localTransitGateway")
-    def local_transit_gateway(self) -> ITransitGateway:
-        '''The local side of the transit gateway peering connection.
+    @jsii.member(jsii_name="addPredicate")
+    def add_predicate(self, predicate: ITriggerPredicate) -> "Trigger":
+        '''Registers a predicate with the trigger.
 
-        :see: `TransitGatewayPeeringAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid>`_
-        :group: Inputs
+        Triggers with predicates must meet
+        the conditions they specify in order to run.
+
+        :param predicate: The predicate to be added to the trigger.
+
+        :return: The trigger to which the predicate was added.
         '''
-        return typing.cast(ITransitGateway, jsii.get(self, "localTransitGateway"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2b67da5af6c648e853764f371b481f132349181516847a12a28a673bc51a3fe4)
+            check_type(argname="argument predicate", value=predicate, expected_type=type_hints["predicate"])
+        return typing.cast("Trigger", jsii.invoke(self, "addPredicate", [predicate]))
 
     @builtins.property
-    @jsii.member(jsii_name="peerTransitGateway")
-    def peer_transit_gateway(self) -> ITransitGateway:
-        '''The remote transit gateway being peered with.
+    @jsii.member(jsii_name="predicateOperator")
+    def predicate_operator(self) -> PredicateOperator:
+        '''Operator for chaining predicate conditions if multiple are given.
 
-        :see: `TransitGatewayPeeringAttachment PeerTransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid>`_
+        :see: `Trigger Predicate.Logical <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html#cfn-glue-trigger-predicate-logical>`_
         :group: Inputs
         '''
-        return typing.cast(ITransitGateway, jsii.get(self, "peerTransitGateway"))
+        return typing.cast(PredicateOperator, jsii.get(self, "predicateOperator"))
 
     @builtins.property
     @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayPeeringAttachment:
-        '''The underlying TransitGatewayRouteTable CloudFormation resource.
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger:
+        '''The underlying Trigger CloudFormation resource.
 
-        :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
+        :see: `AWS::Glue::Trigger <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html>`_
         :group: Resources
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayPeeringAttachment, jsii.get(self, "resource"))
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+    @jsii.member(jsii_name="triggerArn")
+    def trigger_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the trigger.'''
+        return typing.cast(builtins.str, jsii.get(self, "triggerArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
-    def transit_gateway_attachment_creation_time(self) -> builtins.str:
-        '''The time the transit gateway peering attachment was created.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentCreationTime"))
+    @jsii.member(jsii_name="triggerName")
+    def trigger_name(self) -> builtins.str:
+        '''The name of the trigger.'''
+        return typing.cast(builtins.str, jsii.get(self, "triggerName"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of this transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentState")
-    def transit_gateway_attachment_state(self) -> builtins.str:
-        '''The state of the transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentState"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
-    def transit_gateway_attachment_status(self) -> builtins.str:
-        '''The status of the transit gateway peering attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatus"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
-    def transit_gateway_attachment_status_code(self) -> builtins.str:
-        '''The status code for the current status of the attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusCode"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
-    def transit_gateway_attachment_status_message(self) -> builtins.str:
-        '''The status message for the current status of the attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusMessage"))
-
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway peering attachment.
-
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
+    @jsii.member(jsii_name="type")
+    def type(self) -> "TriggerType":
+        '''The type of trigger that this is.
 
-        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
+        :see: `Trigger Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-type>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+        return typing.cast("TriggerType", jsii.get(self, "type"))
 
     @builtins.property
-    @jsii.member(jsii_name="peerAccountId")
-    def peer_account_id(self) -> typing.Optional[builtins.str]:
-        '''The account that contains the transit gateway being peered with.
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description for the trigger.
 
-        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
+        :see: `Trigger Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-description>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerAccountId"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
     @builtins.property
-    @jsii.member(jsii_name="peerRegion")
-    def peer_region(self) -> typing.Optional[builtins.str]:
-        '''The region that contains the transit gateway being peered with.
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A name for the trigger.
 
-        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
+        :see: `Trigger Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-name>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerRegion"))
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentImportAttributes",
-    jsii_struct_bases=[],
-    name_mapping={
-        "arn": "arn",
-        "attachment_id": "attachmentId",
-        "creation_time": "creationTime",
-        "state": "state",
-        "status": "status",
-        "status_code": "statusCode",
-        "status_message": "statusMessage",
-    },
-)
-class TransitGatewayPeeringAttachmentImportAttributes:
-    def __init__(
-        self,
-        *,
-        arn: typing.Optional[builtins.str] = None,
-        attachment_id: typing.Optional[builtins.str] = None,
-        creation_time: typing.Optional[builtins.str] = None,
-        state: typing.Optional[builtins.str] = None,
-        status: typing.Optional[builtins.str] = None,
-        status_code: typing.Optional[builtins.str] = None,
-        status_message: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Configuration options for importing a transit gateway peering attachment.
-
-        :param arn: The ARN of this Transit Gateway Attachment.
-        :param attachment_id: The ID of this Transit Gateway Attachment.
-        :param creation_time: The time the transit gateway peering attachment was created.
-        :param state: The state of the transit gateway peering attachment.
-        :param status: The status of the transit gateway peering attachment.
-        :param status_code: The status code for the current status of the attachment.
-        :param status_message: The status message for the current status of the attachment.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__17eab9c1c0483a81bcbc3cfb19dfc9cd1902962956a39306a77b2b041a6f2182)
-            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
-            check_type(argname="argument attachment_id", value=attachment_id, expected_type=type_hints["attachment_id"])
-            check_type(argname="argument creation_time", value=creation_time, expected_type=type_hints["creation_time"])
-            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
-            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
-            check_type(argname="argument status_code", value=status_code, expected_type=type_hints["status_code"])
-            check_type(argname="argument status_message", value=status_message, expected_type=type_hints["status_message"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if arn is not None:
-            self._values["arn"] = arn
-        if attachment_id is not None:
-            self._values["attachment_id"] = attachment_id
-        if creation_time is not None:
-            self._values["creation_time"] = creation_time
-        if state is not None:
-            self._values["state"] = state
-        if status is not None:
-            self._values["status"] = status
-        if status_code is not None:
-            self._values["status_code"] = status_code
-        if status_message is not None:
-            self._values["status_message"] = status_message
-
-    @builtins.property
-    def arn(self) -> typing.Optional[builtins.str]:
-        '''The ARN of this Transit Gateway Attachment.'''
-        result = self._values.get("arn")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def attachment_id(self) -> typing.Optional[builtins.str]:
-        '''The ID of this Transit Gateway Attachment.'''
-        result = self._values.get("attachment_id")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def creation_time(self) -> typing.Optional[builtins.str]:
-        '''The time the transit gateway peering attachment was created.'''
-        result = self._values.get("creation_time")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def state(self) -> typing.Optional[builtins.str]:
-        '''The state of the transit gateway peering attachment.'''
-        result = self._values.get("state")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def status(self) -> typing.Optional[builtins.str]:
-        '''The status of the transit gateway peering attachment.'''
-        result = self._values.get("status")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def status_code(self) -> typing.Optional[builtins.str]:
-        '''The status code for the current status of the attachment.'''
-        result = self._values.get("status_code")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
     @builtins.property
-    def status_message(self) -> typing.Optional[builtins.str]:
-        '''The status message for the current status of the attachment.'''
-        result = self._values.get("status_message")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="schedule")
+    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
+        '''A cron expression used to specify the schedule.
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "TransitGatewayPeeringAttachmentImportAttributes(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentOptions",
-    jsii_struct_bases=[],
-    name_mapping={
-        "name": "name",
-        "peer_account_id": "peerAccountId",
-        "peer_region": "peerRegion",
-    },
-)
-class TransitGatewayPeeringAttachmentOptions:
-    def __init__(
-        self,
-        *,
-        name: typing.Optional[builtins.str] = None,
-        peer_account_id: typing.Optional[builtins.str] = None,
-        peer_region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Optional configuration for TransitGatewayPeeringAttachment resource.
-
-        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param peer_account_id: The account that contains the transit gateway being peered with.
-        :param peer_region: The region that contains the transit gateway being peered with.
+        :see: `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__25aee8c8ebebcfa519a0f5706458a5669157c84f5af528e93a86402ac7c50aae)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument peer_account_id", value=peer_account_id, expected_type=type_hints["peer_account_id"])
-            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if name is not None:
-            self._values["name"] = name
-        if peer_account_id is not None:
-            self._values["peer_account_id"] = peer_account_id
-        if peer_region is not None:
-            self._values["peer_region"] = peer_region
+        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], jsii.get(self, "schedule"))
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway peering attachment.
+    @jsii.member(jsii_name="startOnCreation")
+    def start_on_creation(self) -> typing.Optional[builtins.bool]:
+        '''Set to true to start SCHEDULED and CONDITIONAL triggers when created.
 
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
-
-        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        True
+        is not supported for ON_DEMAND triggers.
 
-    @builtins.property
-    def peer_account_id(self) -> typing.Optional[builtins.str]:
-        '''The account that contains the transit gateway being peered with.
-
-        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
+        :see: `Trigger StartOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-startoncreation>`_
+        :group: Inputs
         '''
-        result = self._values.get("peer_account_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "startOnCreation"))
 
     @builtins.property
-    def peer_region(self) -> typing.Optional[builtins.str]:
-        '''The region that contains the transit gateway being peered with.
+    @jsii.member(jsii_name="workflow")
+    def workflow(self) -> typing.Optional["Workflow"]:
+        '''The name of the workflow associated with the trigger.
 
-        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
+        :see: `Trigger WorkflowName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-workflowname>`_
+        :group: Inputs
         '''
-        result = self._values.get("peer_region")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "TransitGatewayPeeringAttachmentOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        return typing.cast(typing.Optional["Workflow"], jsii.get(self, "workflow"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentProps",
-    jsii_struct_bases=[
-        TransitGatewayPeeringAttachmentOptions, _aws_cdk_ceddda9d.ResourceProps
-    ],
+    jsii_type="cdk-extensions.glue.TriggerOptions",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
-        "name": "name",
-        "peer_account_id": "peerAccountId",
-        "peer_region": "peerRegion",
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "local_transit_gateway": "localTransitGateway",
-        "peer_transit_gateway": "peerTransitGateway",
+        "type": "type",
+        "actions": "actions",
+        "description": "description",
+        "name": "name",
+        "predicate_conditions": "predicateConditions",
+        "predicate_operator": "predicateOperator",
+        "schedule": "schedule",
+        "start_on_creation": "startOnCreation",
     },
 )
-class TransitGatewayPeeringAttachmentProps(
-    TransitGatewayPeeringAttachmentOptions,
-    _aws_cdk_ceddda9d.ResourceProps,
-):
+class TriggerOptions(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        name: typing.Optional[builtins.str] = None,
-        peer_account_id: typing.Optional[builtins.str] = None,
-        peer_region: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        local_transit_gateway: ITransitGateway,
-        peer_transit_gateway: ITransitGateway,
+        type: "TriggerType",
+        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+        predicate_operator: typing.Optional[PredicateOperator] = None,
+        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        start_on_creation: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Configuration for TransitGatewayPeeringAttachment resource.
-
-        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param peer_account_id: The account that contains the transit gateway being peered with.
-        :param peer_region: The region that contains the transit gateway being peered with.
+        '''
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param local_transit_gateway: The local side of the transit gateway peering connection.
-        :param peer_transit_gateway: The remote transit gateway being peered with.
+        :param type: 
+        :param actions: 
+        :param description: 
+        :param name: 
+        :param predicate_conditions: 
+        :param predicate_operator: 
+        :param schedule: 
+        :param start_on_creation: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1b477916bc8b985cd2d6731bf57489e1a7c94f20fccf7711617cdf0d1bd25beb)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument peer_account_id", value=peer_account_id, expected_type=type_hints["peer_account_id"])
-            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
+            type_hints = typing.get_type_hints(_typecheckingstub__01145ca757e10f8e94b4c175dd3a267a5df9030339f6e4feb49750e5ff03ac64)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument local_transit_gateway", value=local_transit_gateway, expected_type=type_hints["local_transit_gateway"])
-            check_type(argname="argument peer_transit_gateway", value=peer_transit_gateway, expected_type=type_hints["peer_transit_gateway"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument predicate_conditions", value=predicate_conditions, expected_type=type_hints["predicate_conditions"])
+            check_type(argname="argument predicate_operator", value=predicate_operator, expected_type=type_hints["predicate_operator"])
+            check_type(argname="argument schedule", value=schedule, expected_type=type_hints["schedule"])
+            check_type(argname="argument start_on_creation", value=start_on_creation, expected_type=type_hints["start_on_creation"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "local_transit_gateway": local_transit_gateway,
-            "peer_transit_gateway": peer_transit_gateway,
+            "type": type,
         }
-        if name is not None:
-            self._values["name"] = name
-        if peer_account_id is not None:
-            self._values["peer_account_id"] = peer_account_id
-        if peer_region is not None:
-            self._values["peer_region"] = peer_region
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway peering attachment.
-
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
-
-        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def peer_account_id(self) -> typing.Optional[builtins.str]:
-        '''The account that contains the transit gateway being peered with.
-
-        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
-        '''
-        result = self._values.get("peer_account_id")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def peer_region(self) -> typing.Optional[builtins.str]:
-        '''The region that contains the transit gateway being peered with.
-
-        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
-        '''
-        result = self._values.get("peer_region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if actions is not None:
+            self._values["actions"] = actions
+        if description is not None:
+            self._values["description"] = description
+        if name is not None:
+            self._values["name"] = name
+        if predicate_conditions is not None:
+            self._values["predicate_conditions"] = predicate_conditions
+        if predicate_operator is not None:
+            self._values["predicate_operator"] = predicate_operator
+        if schedule is not None:
+            self._values["schedule"] = schedule
+        if start_on_creation is not None:
+            self._values["start_on_creation"] = start_on_creation
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -3986,152 +6160,161 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def local_transit_gateway(self) -> ITransitGateway:
-        '''The local side of the transit gateway peering connection.
+    def type(self) -> "TriggerType":
+        result = self._values.get("type")
+        assert result is not None, "Required property 'type' is missing"
+        return typing.cast("TriggerType", result)
 
-        :see: `TransitGatewayPeeringAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid>`_
-        '''
-        result = self._values.get("local_transit_gateway")
-        assert result is not None, "Required property 'local_transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
+    @builtins.property
+    def actions(self) -> typing.Optional[typing.List[ITriggerAction]]:
+        result = self._values.get("actions")
+        return typing.cast(typing.Optional[typing.List[ITriggerAction]], result)
 
     @builtins.property
-    def peer_transit_gateway(self) -> ITransitGateway:
-        '''The remote transit gateway being peered with.
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: `TransitGatewayPeeringAttachment PeerTransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid>`_
-        '''
-        result = self._values.get("peer_transit_gateway")
-        assert result is not None, "Required property 'peer_transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def predicate_conditions(self) -> typing.Optional[typing.List[ITriggerPredicate]]:
+        result = self._values.get("predicate_conditions")
+        return typing.cast(typing.Optional[typing.List[ITriggerPredicate]], result)
+
+    @builtins.property
+    def predicate_operator(self) -> typing.Optional[PredicateOperator]:
+        result = self._values.get("predicate_operator")
+        return typing.cast(typing.Optional[PredicateOperator], result)
+
+    @builtins.property
+    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
+        result = self._values.get("schedule")
+        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
+
+    @builtins.property
+    def start_on_creation(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("start_on_creation")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayPeeringAttachmentProps(%s)" % ", ".join(
+        return "TriggerOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayProps",
+    jsii_type="cdk-extensions.glue.TriggerProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "amazon_side_asn": "amazonSideAsn",
-        "auto_accept_shared_attachments": "autoAcceptSharedAttachments",
-        "cidr_blocks": "cidrBlocks",
-        "default_route_table_association": "defaultRouteTableAssociation",
-        "default_route_table_id": "defaultRouteTableId",
-        "default_route_table_propagation": "defaultRouteTablePropagation",
+        "type": "type",
+        "actions": "actions",
         "description": "description",
-        "dns_support": "dnsSupport",
-        "multicast_support": "multicastSupport",
         "name": "name",
-        "vpn_ecmp_support": "vpnEcmpSupport",
+        "predicate_conditions": "predicateConditions",
+        "predicate_operator": "predicateOperator",
+        "schedule": "schedule",
+        "start_on_creation": "startOnCreation",
+        "workflow": "workflow",
     },
 )
-class TransitGatewayProps(_aws_cdk_ceddda9d.ResourceProps):
+class TriggerProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        amazon_side_asn: typing.Optional[jsii.Number] = None,
-        auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
-        cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
-        default_route_table_association: typing.Optional[builtins.bool] = None,
-        default_route_table_id: typing.Optional[builtins.str] = None,
-        default_route_table_propagation: typing.Optional[builtins.bool] = None,
+        type: "TriggerType",
+        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
         description: typing.Optional[builtins.str] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        multicast_support: typing.Optional[builtins.bool] = None,
         name: typing.Optional[builtins.str] = None,
-        vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+        predicate_operator: typing.Optional[PredicateOperator] = None,
+        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        start_on_creation: typing.Optional[builtins.bool] = None,
+        workflow: typing.Optional["Workflow"] = None,
     ) -> None:
-        '''Configuration for TransitGateway resource.
+        '''Configuration for the GlueTrigger resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param amazon_side_asn: 
-        :param auto_accept_shared_attachments: 
-        :param cidr_blocks: 
-        :param default_route_table_association: 
-        :param default_route_table_id: 
-        :param default_route_table_propagation: 
-        :param description: 
-        :param dns_support: 
-        :param multicast_support: 
-        :param name: 
-        :param vpn_ecmp_support: 
+        :param type: The type of trigger that this is.
+        :param actions: A list of actions initiated by this trigger.
+        :param description: A description for the trigger.
+        :param name: A name for the trigger.
+        :param predicate_conditions: A list of the conditions that determine when the trigger will fire.
+        :param predicate_operator: Operator for chaining predicate conditions if multiple are given.
+        :param schedule: A cron expression used to specify the schedule.
+        :param start_on_creation: Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
+        :param workflow: The name of the workflow associated with the trigger.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__34be88b6da81fce37f3376e8b1fd1aff7e222c4b2fb4ab8e879c634868d58a81)
+            type_hints = typing.get_type_hints(_typecheckingstub__ad020c3099533ac828ee3b7bc94f977e7beb54ccf917b0d37f088b52a7110039)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument amazon_side_asn", value=amazon_side_asn, expected_type=type_hints["amazon_side_asn"])
-            check_type(argname="argument auto_accept_shared_attachments", value=auto_accept_shared_attachments, expected_type=type_hints["auto_accept_shared_attachments"])
-            check_type(argname="argument cidr_blocks", value=cidr_blocks, expected_type=type_hints["cidr_blocks"])
-            check_type(argname="argument default_route_table_association", value=default_route_table_association, expected_type=type_hints["default_route_table_association"])
-            check_type(argname="argument default_route_table_id", value=default_route_table_id, expected_type=type_hints["default_route_table_id"])
-            check_type(argname="argument default_route_table_propagation", value=default_route_table_propagation, expected_type=type_hints["default_route_table_propagation"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
             check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
-            check_type(argname="argument multicast_support", value=multicast_support, expected_type=type_hints["multicast_support"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument vpn_ecmp_support", value=vpn_ecmp_support, expected_type=type_hints["vpn_ecmp_support"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
+            check_type(argname="argument predicate_conditions", value=predicate_conditions, expected_type=type_hints["predicate_conditions"])
+            check_type(argname="argument predicate_operator", value=predicate_operator, expected_type=type_hints["predicate_operator"])
+            check_type(argname="argument schedule", value=schedule, expected_type=type_hints["schedule"])
+            check_type(argname="argument start_on_creation", value=start_on_creation, expected_type=type_hints["start_on_creation"])
+            check_type(argname="argument workflow", value=workflow, expected_type=type_hints["workflow"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "type": type,
+        }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if amazon_side_asn is not None:
-            self._values["amazon_side_asn"] = amazon_side_asn
-        if auto_accept_shared_attachments is not None:
-            self._values["auto_accept_shared_attachments"] = auto_accept_shared_attachments
-        if cidr_blocks is not None:
-            self._values["cidr_blocks"] = cidr_blocks
-        if default_route_table_association is not None:
-            self._values["default_route_table_association"] = default_route_table_association
-        if default_route_table_id is not None:
-            self._values["default_route_table_id"] = default_route_table_id
-        if default_route_table_propagation is not None:
-            self._values["default_route_table_propagation"] = default_route_table_propagation
+        if actions is not None:
+            self._values["actions"] = actions
         if description is not None:
             self._values["description"] = description
-        if dns_support is not None:
-            self._values["dns_support"] = dns_support
-        if multicast_support is not None:
-            self._values["multicast_support"] = multicast_support
         if name is not None:
             self._values["name"] = name
-        if vpn_ecmp_support is not None:
-            self._values["vpn_ecmp_support"] = vpn_ecmp_support
+        if predicate_conditions is not None:
+            self._values["predicate_conditions"] = predicate_conditions
+        if predicate_operator is not None:
+            self._values["predicate_operator"] = predicate_operator
+        if schedule is not None:
+            self._values["schedule"] = schedule
+        if start_on_creation is not None:
+            self._values["start_on_creation"] = start_on_creation
+        if workflow is not None:
+            self._values["workflow"] = workflow
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -4173,244 +6356,576 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
-        result = self._values.get("amazon_side_asn")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    def type(self) -> "TriggerType":
+        '''The type of trigger that this is.
 
-    @builtins.property
-    def auto_accept_shared_attachments(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("auto_accept_shared_attachments")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :see: `Trigger Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-type>`_
+        '''
+        result = self._values.get("type")
+        assert result is not None, "Required property 'type' is missing"
+        return typing.cast("TriggerType", result)
 
     @builtins.property
-    def cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
-        result = self._values.get("cidr_blocks")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+    def actions(self) -> typing.Optional[typing.List[ITriggerAction]]:
+        '''A list of actions initiated by this trigger.
 
-    @builtins.property
-    def default_route_table_association(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("default_route_table_association")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :see: `Trigger Actions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-actions>`_
+        '''
+        result = self._values.get("actions")
+        return typing.cast(typing.Optional[typing.List[ITriggerAction]], result)
 
     @builtins.property
-    def default_route_table_id(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("default_route_table_id")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description for the trigger.
+
+        :see: `Trigger Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-description>`_
+        '''
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def default_route_table_propagation(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("default_route_table_propagation")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A name for the trigger.
 
-    @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("description")
+        :see: `Trigger Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-name>`_
+        '''
+        result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def dns_support(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("dns_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def predicate_conditions(self) -> typing.Optional[typing.List[ITriggerPredicate]]:
+        '''A list of the conditions that determine when the trigger will fire.
+
+        :see: `Trigger Predicate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html>`_
+        '''
+        result = self._values.get("predicate_conditions")
+        return typing.cast(typing.Optional[typing.List[ITriggerPredicate]], result)
 
     @builtins.property
-    def multicast_support(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("multicast_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def predicate_operator(self) -> typing.Optional[PredicateOperator]:
+        '''Operator for chaining predicate conditions if multiple are given.
+
+        :see: `Trigger Predicate.Logical <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html#cfn-glue-trigger-predicate-logical>`_
+        '''
+        result = self._values.get("predicate_operator")
+        return typing.cast(typing.Optional[PredicateOperator], result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
+        '''A cron expression used to specify the schedule.
+
+        :see: `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_
+        '''
+        result = self._values.get("schedule")
+        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
 
     @builtins.property
-    def vpn_ecmp_support(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("vpn_ecmp_support")
+    def start_on_creation(self) -> typing.Optional[builtins.bool]:
+        '''Set to true to start SCHEDULED and CONDITIONAL triggers when created.
+
+        True
+        is not supported for ON_DEMAND triggers.
+
+        :see: `Trigger StartOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-startoncreation>`_
+        '''
+        result = self._values.get("start_on_creation")
         return typing.cast(typing.Optional[builtins.bool], result)
 
+    @builtins.property
+    def workflow(self) -> typing.Optional["Workflow"]:
+        '''The name of the workflow associated with the trigger.
+
+        :see: `Trigger WorkflowName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-workflowname>`_
+        '''
+        result = self._values.get("workflow")
+        return typing.cast(typing.Optional["Workflow"], result)
+
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayProps(%s)" % ", ".join(
+        return "TriggerProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class TransitGatewayRoute(
+@jsii.enum(jsii_type="cdk-extensions.glue.TriggerType")
+class TriggerType(enum.Enum):
+    CONDITIONAL = "CONDITIONAL"
+    EVENT = "EVENT"
+    ON_DEMAND = "ON_DEMAND"
+    SCHEDULED = "SCHEDULED"
+
+
+@jsii.enum(jsii_type="cdk-extensions.glue.UpdateBehavior")
+class UpdateBehavior(enum.Enum):
+    UPDATE_IN_DATABASE = "UPDATE_IN_DATABASE"
+    LOG = "LOG"
+
+
+class WorkerType(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.WorkerType"):
+    '''The type of predefined worker that is allocated when a job runs.
+
+    If you need to use a WorkerType that doesn't exist as a static member, you
+    can instantiate a ``WorkerType`` object, e.g: ``WorkerType.of('other type')``.
+    '''
+
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, worker_type: builtins.str) -> "WorkerType":
+        '''Custom worker type.
+
+        :param worker_type: custom worker type.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4a01940e29d3d0fd83d19b9c7547e8ccfdc7c8f60414ad61defd54707cde2f02)
+            check_type(argname="argument worker_type", value=worker_type, expected_type=type_hints["worker_type"])
+        return typing.cast("WorkerType", jsii.sinvoke(cls, "of", [worker_type]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="G_1X")
+    def G_1_X(cls) -> "WorkerType":
+        '''Each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker.
+
+        Suitable for memory-intensive jobs.
+        '''
+        return typing.cast("WorkerType", jsii.sget(cls, "G_1X"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="G_2X")
+    def G_2_X(cls) -> "WorkerType":
+        '''Each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker.
+
+        Suitable for memory-intensive jobs.
+        '''
+        return typing.cast("WorkerType", jsii.sget(cls, "G_2X"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="STANDARD")
+    def STANDARD(cls) -> "WorkerType":
+        '''Each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.'''
+        return typing.cast("WorkerType", jsii.sget(cls, "STANDARD"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of this WorkerType, as expected by Job resource.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
+
+
+class Workflow(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayRoute",
+    jsii_type="cdk-extensions.glue.Workflow",
 ):
-    '''Adds a routing rule for a transit gateway route table.'''
-
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        cidr: builtins.str,
-        route_table: ITransitGatewayRouteTable,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the TransitGatewayAttachment class.
+        '''Creates a new instance of the Workflow class.
 
         :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param cidr: 
-        :param route_table: 
-        :param attachment: 
-        :param blackhole: 
+        :param description: A description of the Workflow.
+        :param name: A name of the Workflow.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__472f0a715c24828891d913514782594fd48e540d0192f96901c525a6f2c9845f)
+            type_hints = typing.get_type_hints(_typecheckingstub__30858062db0892690086e05db3017264c21574c51cfe419ae83dc373da11b661)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayRouteProps(
-            cidr=cidr,
-            route_table=route_table,
-            attachment=attachment,
-            blackhole=blackhole,
+        props = WorkflowProps(
+            description=description,
+            name=name,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="fromTransitGatewayRouteId")
-    @builtins.classmethod
-    def from_transit_gateway_route_id(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
+    @jsii.member(jsii_name="addTrigger")
+    def add_trigger(
+        self,
         id: builtins.str,
-        transit_gateway_route_id: builtins.str,
-    ) -> ITransitGatewayRoute:
-        '''Imports an existing Transit Gateway Route using its route ID.
-
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway_route_id: The ID of the Transit Gateway route being imported.
-
-        :return: An object representing the imported Transit Gateway route.
+        *,
+        type: TriggerType,
+        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+        predicate_operator: typing.Optional[PredicateOperator] = None,
+        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        start_on_creation: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> ITrigger:
+        '''
+        :param id: -
+        :param type: 
+        :param actions: 
+        :param description: 
+        :param name: 
+        :param predicate_conditions: 
+        :param predicate_operator: 
+        :param schedule: 
+        :param start_on_creation: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e915393403cdd527b11e940ce216647c74d6e6b709f726e821e12fa1b470873d)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            type_hints = typing.get_type_hints(_typecheckingstub__ce55118dcfd5ce84c7d138d41de38e7579d11282f1f109403fe376a28709ebf9)
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument transit_gateway_route_id", value=transit_gateway_route_id, expected_type=type_hints["transit_gateway_route_id"])
-        return typing.cast(ITransitGatewayRoute, jsii.sinvoke(cls, "fromTransitGatewayRouteId", [scope, id, transit_gateway_route_id]))
+        options = TriggerOptions(
+            type=type,
+            actions=actions,
+            description=description,
+            name=name,
+            predicate_conditions=predicate_conditions,
+            predicate_operator=predicate_operator,
+            schedule=schedule,
+            start_on_creation=start_on_creation,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="cidr")
-    def cidr(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "cidr"))
+        return typing.cast(ITrigger, jsii.invoke(self, "addTrigger", [id, options]))
 
     @builtins.property
     @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRoute:
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRoute, jsii.get(self, "resource"))
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnWorkflow:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnWorkflow, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="routeTable")
-    def route_table(self) -> ITransitGatewayRouteTable:
-        return typing.cast(ITransitGatewayRouteTable, jsii.get(self, "routeTable"))
+    @jsii.member(jsii_name="workflowArn")
+    def workflow_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "workflowArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteId")
-    def transit_gateway_route_id(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteId"))
+    @jsii.member(jsii_name="workflowName")
+    def workflow_name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "workflowName"))
 
     @builtins.property
-    @jsii.member(jsii_name="attachment")
-    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
-        return typing.cast(typing.Optional[ITransitGatewayAttachment], jsii.get(self, "attachment"))
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link WorkflowProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
     @builtins.property
-    @jsii.member(jsii_name="blackhole")
-    def blackhole(self) -> typing.Optional[builtins.bool]:
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "blackhole"))
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link WorkflowProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+
+
+class WorkflowAction(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.WorkflowAction",
+):
+    '''Actions to be started by a Glue workflow trigger when it is activated.'''
+
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="crawler")
+    @builtins.classmethod
+    def crawler(
+        cls,
+        crawler: ICrawler,
+        *,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> "WorkflowCrawlerAction":
+        '''An action that runs a crawler as part of a Glue workflow.
+
+        :param crawler: The crawler to run as part of the workflow.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+
+        :return: A workflow action that runs the crawler with the given options.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1e1780b54c3d5134781210aa5dcce6cc5585326dcffdae0be9004a975c463191)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        options = WorkflowCrawlerActionOptions(
+            arguments=arguments,
+            notify_delay_after=notify_delay_after,
+            security_configuration=security_configuration,
+            timeout=timeout,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        return typing.cast("WorkflowCrawlerAction", jsii.sinvoke(cls, "crawler", [crawler, options]))
+
+    @jsii.member(jsii_name="job")
+    @builtins.classmethod
+    def job(
+        cls,
+        job: IJob,
+        *,
+        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> "WorkflowJobAction":
+        '''An action that runs a Glue job as part of a workflow.
+
+        :param job: The job to run as part of the workflow.
+        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+
+        :return: A workflow action that runs the job with the given options.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3a94d581f860b13a89641b07de3a6dff7bb35902a5e740ce1b0305d078a71a88)
+            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
+        options = WorkflowJobActionOptions(
+            bookmark_configuration=bookmark_configuration,
+            arguments=arguments,
+            notify_delay_after=notify_delay_after,
+            security_configuration=security_configuration,
+            timeout=timeout,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        return typing.cast("WorkflowJobAction", jsii.sinvoke(cls, "job", [job, options]))
+
+
+class WorkflowActionBase(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.WorkflowActionBase",
+):
+    '''Base class providing common functionality for workflow trigger actions.'''
+
+    def __init__(
+        self,
+        *,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the WorkflowActionBase class.
+
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        options = WorkflowActionOptions(
+            arguments=arguments,
+            notify_delay_after=notify_delay_after,
+            security_configuration=security_configuration,
+            timeout=timeout,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="addArgument")
+    def add_argument(self, key: builtins.str, value: builtins.str) -> None:
+        '''Adds an argument that will be passed to the specified action when triggered as part of a workflow.
+
+        :param key: The name of the argument being set.
+        :param value: The value to pass for the specified argument.
+
+        :see: `AWS Glue job parameters <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__05b16d8f0e42dabc8d5b35b3da8eefd18876b6a5a59a4f740c34c94379a3a823)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(None, jsii.invoke(self, "addArgument", [key, value]))
+
+    @jsii.member(jsii_name="bindOptions")
+    def _bind_options(self, _scope: _constructs_77d1e7e8.IConstruct) -> typing.Any:
+        '''Associates the action with a construct that is configuring a trigger for a Glue workflow.
+
+        :param _scope: The construct configuring the Glue trigger.
+
+        :return:
+
+        A configuration object that can be used to configure a triggered
+        workflow action.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__99f5b49f9607b05a4e188e075be9ce415c7b6b085607cb3e0f90e94cc8453feb)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(typing.Any, jsii.invoke(self, "bindOptions", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="notifyDelayAfter")
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+
+        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "notifyDelayAfter"))
+
+    @builtins.property
+    @jsii.member(jsii_name="securityConfiguration")
+    def security_configuration(self) -> typing.Optional[builtins.str]:
+        '''The name of the SecurityConfiguration structure to be used with this action.
+
+        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
+        :alpha: true
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "securityConfiguration"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeout")
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The ``JobRun`` timeout in minutes.
+
+        This is the maximum time that a job run
+        can consume resources before it is terminated and enters TIMEOUT status.
+        The default is 48 hours. This overrides the timeout value set in the
+        parent job.
+
+        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "timeout"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayRouteOptions",
+    jsii_type="cdk-extensions.glue.WorkflowActionOptions",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cidr": "cidr",
-        "attachment": "attachment",
-        "blackhole": "blackhole",
+        "arguments": "arguments",
+        "notify_delay_after": "notifyDelayAfter",
+        "security_configuration": "securityConfiguration",
+        "timeout": "timeout",
     },
 )
-class TransitGatewayRouteOptions(_aws_cdk_ceddda9d.ResourceProps):
+class WorkflowActionOptions(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cidr: builtins.str,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     ) -> None:
-        '''Options for adding a route to a transit gateway route table.
+        '''Configuration for the Workflow Action resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cidr: The CIDR range to match for the route.
-        :param attachment: The transit gateway attachment where matched traffic should be routed.
-        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__eac305487ec828686fdbbd312914a754c55ca742068c194f48ac724cf9aef071)
+            type_hints = typing.get_type_hints(_typecheckingstub__7005e62847fa5591337705760979f2e03a39c841c84835a874bcebaca8a59289)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
-            check_type(argname="argument attachment", value=attachment, expected_type=type_hints["attachment"])
-            check_type(argname="argument blackhole", value=blackhole, expected_type=type_hints["blackhole"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cidr": cidr,
-        }
+            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
+            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
+            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
+            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if attachment is not None:
-            self._values["attachment"] = attachment
-        if blackhole is not None:
-            self._values["blackhole"] = blackhole
+        if arguments is not None:
+            self._values["arguments"] = arguments
+        if notify_delay_after is not None:
+            self._values["notify_delay_after"] = notify_delay_after
+        if security_configuration is not None:
+            self._values["security_configuration"] = security_configuration
+        if timeout is not None:
+            self._values["timeout"] = timeout
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -4452,108 +6967,216 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cidr(self) -> builtins.str:
-        '''The CIDR range to match for the route.'''
-        result = self._values.get("cidr")
-        assert result is not None, "Required property 'cidr' is missing"
-        return typing.cast(builtins.str, result)
+    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''The arguments to use when the associated trigger fires.
+
+        Jobs run via the associated trigger will have their default arguments
+        replaced with the arguments specified.
+
+        You can specify arguments here that your own job-execution script
+        consumes, in addition to arguments that AWS Glue itself consumes.
+
+        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
+        '''
+        result = self._values.get("arguments")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     @builtins.property
-    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
-        '''The transit gateway attachment where matched traffic should be routed.'''
-        result = self._values.get("attachment")
-        return typing.cast(typing.Optional[ITransitGatewayAttachment], result)
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+
+        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        '''
+        result = self._values.get("notify_delay_after")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    def blackhole(self) -> typing.Optional[builtins.bool]:
-        '''Whether the traffic should be black holed (discarded) rather than being routed to an attachment.'''
-        result = self._values.get("blackhole")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def security_configuration(self) -> typing.Optional[builtins.str]:
+        '''The name of the SecurityConfiguration structure to be used with this action.
+
+        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
+        :alpha: true
+        '''
+        result = self._values.get("security_configuration")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The ``JobRun`` timeout in minutes.
+
+        This is the maximum time that a job run
+        can consume resources before it is terminated and enters TIMEOUT status.
+        The default is 48 hours. This overrides the timeout value set in the
+        parent job.
+
+        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+        '''
+        result = self._values.get("timeout")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayRouteOptions(%s)" % ", ".join(
+        return "WorkflowActionOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+@jsii.implements(ITriggerAction)
+class WorkflowCrawlerAction(
+    WorkflowActionBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.WorkflowCrawlerAction",
+):
+    '''Configuration options for the WorkflowCrawlerAction class.'''
+
+    def __init__(
+        self,
+        crawler: ICrawler,
+        *,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the WorkflowCrawlerAction class.
+
+        :param crawler: The crawler that should be triggered as part of the workflow.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ad3c134eb8a9a38db762359e9966bbb7beb44688976d988804ba557fa266ff4b)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        options = WorkflowCrawlerActionOptions(
+            arguments=arguments,
+            notify_delay_after=notify_delay_after,
+            security_configuration=security_configuration,
+            timeout=timeout,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [crawler, options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
+        '''Associates this action with a resource that is configuring a Glue trigger.
+
+        :param scope: The construct configuring the trigger that this action will be used in.
+
+        :return:
+
+        The configuration that can be used to configure the underlying
+        trigger resource.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9bd574ee7e851b6cdc8e7da335779c92cb91aac7d1685e0748769e6e4e944682)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="crawler")
+    def crawler(self) -> ICrawler:
+        '''The Glue crawler to be triggered as part of the workflow.
+
+        :group: Inputs
+        '''
+        return typing.cast(ICrawler, jsii.get(self, "crawler"))
+
+
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayRouteProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.glue.WorkflowCrawlerActionOptions",
+    jsii_struct_bases=[WorkflowActionOptions],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cidr": "cidr",
-        "route_table": "routeTable",
-        "attachment": "attachment",
-        "blackhole": "blackhole",
+        "arguments": "arguments",
+        "notify_delay_after": "notifyDelayAfter",
+        "security_configuration": "securityConfiguration",
+        "timeout": "timeout",
     },
 )
-class TransitGatewayRouteProps(_aws_cdk_ceddda9d.ResourceProps):
+class WorkflowCrawlerActionOptions(WorkflowActionOptions):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cidr: builtins.str,
-        route_table: ITransitGatewayRouteTable,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     ) -> None:
-        '''Configuration for TransitGatewayRoute resource.
+        '''Configuration options for the WorkflowCrawlerAction class.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cidr: 
-        :param route_table: 
-        :param attachment: 
-        :param blackhole: 
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__36f603e48c36f0aabd623aee3c75f3f94dcd322957a71fb2d3539585045d2c00)
+            type_hints = typing.get_type_hints(_typecheckingstub__2234879c337e543d2848372b9e2ea82f341e9425395819d4c59814e46dfb3233)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
-            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
-            check_type(argname="argument attachment", value=attachment, expected_type=type_hints["attachment"])
-            check_type(argname="argument blackhole", value=blackhole, expected_type=type_hints["blackhole"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cidr": cidr,
-            "route_table": route_table,
-        }
+            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
+            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
+            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
+            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if attachment is not None:
-            self._values["attachment"] = attachment
-        if blackhole is not None:
-            self._values["blackhole"] = blackhole
+        if arguments is not None:
+            self._values["arguments"] = arguments
+        if notify_delay_after is not None:
+            self._values["notify_delay_after"] = notify_delay_after
+        if security_configuration is not None:
+            self._values["security_configuration"] = security_configuration
+        if timeout is not None:
+            self._values["timeout"] = timeout
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -4595,292 +7218,225 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cidr(self) -> builtins.str:
-        result = self._values.get("cidr")
-        assert result is not None, "Required property 'cidr' is missing"
-        return typing.cast(builtins.str, result)
+    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''The arguments to use when the associated trigger fires.
+
+        Jobs run via the associated trigger will have their default arguments
+        replaced with the arguments specified.
+
+        You can specify arguments here that your own job-execution script
+        consumes, in addition to arguments that AWS Glue itself consumes.
+
+        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
+        '''
+        result = self._values.get("arguments")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     @builtins.property
-    def route_table(self) -> ITransitGatewayRouteTable:
-        result = self._values.get("route_table")
-        assert result is not None, "Required property 'route_table' is missing"
-        return typing.cast(ITransitGatewayRouteTable, result)
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+
+        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        '''
+        result = self._values.get("notify_delay_after")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
-        result = self._values.get("attachment")
-        return typing.cast(typing.Optional[ITransitGatewayAttachment], result)
+    def security_configuration(self) -> typing.Optional[builtins.str]:
+        '''The name of the SecurityConfiguration structure to be used with this action.
+
+        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
+        :alpha: true
+        '''
+        result = self._values.get("security_configuration")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def blackhole(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("blackhole")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The ``JobRun`` timeout in minutes.
+
+        This is the maximum time that a job run
+        can consume resources before it is terminated and enters TIMEOUT status.
+        The default is 48 hours. This overrides the timeout value set in the
+        parent job.
+
+        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+        '''
+        result = self._values.get("timeout")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayRouteProps(%s)" % ", ".join(
+        return "WorkflowCrawlerActionOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(ITransitGatewayRouteTable)
-class TransitGatewayRouteTable(
-    _aws_cdk_ceddda9d.Resource,
+@jsii.implements(ITriggerAction)
+class WorkflowJobAction(
+    WorkflowActionBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTable",
+    jsii_type="cdk-extensions.glue.WorkflowJobAction",
 ):
-    '''Creates a route table for traffic being processed by a transit gateway.
-
-    When traffic is routed to a transit gateway via an attachment, the route
-    table associated with that attachment is used when evaluating how the
-    inbound traffic should be routed.
-
-    :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
-    '''
+    '''Represents the configuration for a job that will be triggered as part of a workflow.'''
 
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
+        job: IJob,
         *,
-        transit_gateway: ITransitGateway,
-        name: typing.Optional[builtins.str] = None,
+        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the TransitGatewayRouteTable class.
+        '''Creates a new instance of the WorkflowJobAction class.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway: The transit gateway for which the route table should be created.
-        :param name: The name of the transit gateway route table. Used to tag the route table with a name that will be displayed in the AWS VPC console.
+        :param job: The job that should be triggered as part of the workflow.
+        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bf9f0e3a9c51ac3498209cf81371557e5b56db1c03ff409740d882fde1cacda7)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayRouteTableProps(
-            transit_gateway=transit_gateway,
-            name=name,
+            type_hints = typing.get_type_hints(_typecheckingstub__4b35e7b4cd1b6215af9417101fd148d7cff1bdbaa7e82f113dafee00863f0e8b)
+            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
+        options = WorkflowJobActionOptions(
+            bookmark_configuration=bookmark_configuration,
+            arguments=arguments,
+            notify_delay_after=notify_delay_after,
+            security_configuration=security_configuration,
+            timeout=timeout,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        jsii.create(self.__class__, self, [scope, id, props])
+        jsii.create(self.__class__, self, [job, options])
 
-    @jsii.member(jsii_name="fromTransitGatewayRouteTableId")
-    @builtins.classmethod
-    def from_transit_gateway_route_table_id(
-        cls,
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
         scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        transit_gateway_route_table_id: builtins.str,
-    ) -> ITransitGatewayRouteTable:
-        '''Imports an existing transit gateway route table using its route table ID.
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
+        '''Associates this action with a resource that is configuring a Glue trigger.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway_route_table_id: The attachment ID of the transit gateway route table being imported.
+        :param scope: The construct configuring the trigger that this action will be used in.
+
+        :return:
 
-        :return: An object representing the imported transit gateway route table.
+        The configuration that can be used to configure the underlying
+        trigger resource.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7ddc972512f9b73360cad75e0fd028f815d92130c441ed49e42d40f77ebd8fff)
+            type_hints = typing.get_type_hints(_typecheckingstub__a7515c04a94a863fad2bee1122daa43d9a40018fd2904b2aa74a621938706702)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument transit_gateway_route_table_id", value=transit_gateway_route_table_id, expected_type=type_hints["transit_gateway_route_table_id"])
-        return typing.cast(ITransitGatewayRouteTable, jsii.sinvoke(cls, "fromTransitGatewayRouteTableId", [scope, id, transit_gateway_route_table_id]))
-
-    @jsii.member(jsii_name="addRoute")
-    def add_route(
-        self,
-        *,
-        cidr: builtins.str,
-        attachment: typing.Optional[ITransitGatewayAttachment] = None,
-        blackhole: typing.Optional[builtins.bool] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> TransitGatewayRoute:
-        '''Adds a route to this transit gateway route table.
-
-        :param cidr: The CIDR range to match for the route.
-        :param attachment: The transit gateway attachment where matched traffic should be routed.
-        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-
-        :return: The TransitGatewayRoute that was added.
-        '''
-        options = TransitGatewayRouteOptions(
-            cidr=cidr,
-            attachment=attachment,
-            blackhole=blackhole,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        return typing.cast(TransitGatewayRoute, jsii.invoke(self, "addRoute", [options]))
-
-    @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRouteTable:
-        '''The underlying TransitGatewayRouteTable CloudFormation resource.
-
-        :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRouteTable, jsii.get(self, "resource"))
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGateway")
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway for which the route table should be created.
+    @jsii.member(jsii_name="job")
+    def job(self) -> IJob:
+        '''The Glue job to be triggered as part of the workflow.
 
-        :see: `TransitGatewayRouteTable TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid>`_
         :group: Inputs
         '''
-        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableArn")
-    def transit_gateway_route_table_arn(self) -> builtins.str:
-        '''The ARN of this transit gateway route table.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableArn"))
-
-    @builtins.property
-    @jsii.member(jsii_name="transitGatewayRouteTableId")
-    def transit_gateway_route_table_id(self) -> builtins.str:
-        '''The ID of this transit gateway route table.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))
-
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway route table.
-
-        Used to tag the route table with a name that will be displayed in the AWS
-        EC2 console.
-
-        :see: `TransitGatewayRouteTable Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTableOptions",
-    jsii_struct_bases=[],
-    name_mapping={"name": "name"},
-)
-class TransitGatewayRouteTableOptions:
-    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
-        '''
-        :param name: 
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ba42798c9102c3419b7c375a3d8ce27fef028001fb7cc17a2798c1aad61854ff)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if name is not None:
-            self._values["name"] = name
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "TransitGatewayRouteTableOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        return typing.cast(IJob, jsii.get(self, "job"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTableProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.glue.WorkflowJobActionOptions",
+    jsii_struct_bases=[WorkflowActionOptions],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "transit_gateway": "transitGateway",
-        "name": "name",
+        "arguments": "arguments",
+        "notify_delay_after": "notifyDelayAfter",
+        "security_configuration": "securityConfiguration",
+        "timeout": "timeout",
+        "bookmark_configuration": "bookmarkConfiguration",
     },
 )
-class TransitGatewayRouteTableProps(_aws_cdk_ceddda9d.ResourceProps):
+class WorkflowJobActionOptions(WorkflowActionOptions):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        transit_gateway: ITransitGateway,
-        name: typing.Optional[builtins.str] = None,
+        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        security_configuration: typing.Optional[builtins.str] = None,
+        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
     ) -> None:
-        '''Configuration for TransitGatewayRouteTable resource.
+        '''Configuration options for the WorkflowJobAction class.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param transit_gateway: The transit gateway for which the route table should be created.
-        :param name: The name of the transit gateway route table. Used to tag the route table with a name that will be displayed in the AWS VPC console.
+        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
+        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8ae02cfe78ce98fb4f7880816162efbcf405d70470d3f4d83605632beeb8a6f7)
+            type_hints = typing.get_type_hints(_typecheckingstub__bf2bd2d4a47064faaa01d005f9c67d6010a4760a0856334853b9d2c9c03d73b3)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "transit_gateway": transit_gateway,
-        }
+            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
+            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
+            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
+            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
+            check_type(argname="argument bookmark_configuration", value=bookmark_configuration, expected_type=type_hints["bookmark_configuration"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if name is not None:
-            self._values["name"] = name
+        if arguments is not None:
+            self._values["arguments"] = arguments
+        if notify_delay_after is not None:
+            self._values["notify_delay_after"] = notify_delay_after
+        if security_configuration is not None:
+            self._values["security_configuration"] = security_configuration
+        if timeout is not None:
+            self._values["timeout"] = timeout
+        if bookmark_configuration is not None:
+            self._values["bookmark_configuration"] = bookmark_configuration
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -4922,613 +7478,374 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway for which the route table should be created.
+    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        '''The arguments to use when the associated trigger fires.
 
-        :see: `TransitGatewayRouteTable TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid>`_
-        '''
-        result = self._values.get("transit_gateway")
-        assert result is not None, "Required property 'transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the transit gateway route table.
+        Jobs run via the associated trigger will have their default arguments
+        replaced with the arguments specified.
 
-        Used to tag the route table with a name that will be displayed in the AWS
-        VPC console.
+        You can specify arguments here that your own job-execution script
+        consumes, in addition to arguments that AWS Glue itself consumes.
 
-        :see: `TransitGatewayRouteTable Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags>`_
+        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
         '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "TransitGatewayRouteTableProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        result = self._values.get("arguments")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
+    @builtins.property
+    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TunnelOptions",
-    jsii_struct_bases=[],
-    name_mapping={"inside_cidr": "insideCidr", "pre_shared_key": "preSharedKey"},
-)
-class TunnelOptions:
-    def __init__(
-        self,
-        *,
-        inside_cidr: typing.Optional[builtins.str] = None,
-        pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
-    ) -> None:
+        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
         '''
-        :param inside_cidr: 
-        :param pre_shared_key: 
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4312d41d9a05862a91818a278fa16d6a73ff75dcd46ad08d731c98c54086e195)
-            check_type(argname="argument inside_cidr", value=inside_cidr, expected_type=type_hints["inside_cidr"])
-            check_type(argname="argument pre_shared_key", value=pre_shared_key, expected_type=type_hints["pre_shared_key"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if inside_cidr is not None:
-            self._values["inside_cidr"] = inside_cidr
-        if pre_shared_key is not None:
-            self._values["pre_shared_key"] = pre_shared_key
+        result = self._values.get("notify_delay_after")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    def inside_cidr(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("inside_cidr")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def security_configuration(self) -> typing.Optional[builtins.str]:
+        '''The name of the SecurityConfiguration structure to be used with this action.
 
-    @builtins.property
-    def pre_shared_key(self) -> typing.Optional[_aws_cdk_ceddda9d.SecretValue]:
-        result = self._values.get("pre_shared_key")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.SecretValue], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "TunnelOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.VpcAttachmentOptions",
-    jsii_struct_bases=[],
-    name_mapping={"name": "name", "subnets": "subnets"},
-)
-class VpcAttachmentOptions:
-    def __init__(
-        self,
-        *,
-        name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    ) -> None:
+        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
+        :alpha: true
         '''
-        :param name: 
-        :param subnets: 
-        '''
-        if isinstance(subnets, dict):
-            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3dff1261f60aa49a2037d280e97af162d26181faeabf698640e4139891619042)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if name is not None:
-            self._values["name"] = name
-        if subnets is not None:
-            self._values["subnets"] = subnets
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
+        result = self._values.get("security_configuration")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        result = self._values.get("subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "VpcAttachmentOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The ``JobRun`` timeout in minutes.
 
+        This is the maximum time that a job run
+        can consume resources before it is terminated and enters TIMEOUT status.
+        The default is 48 hours. This overrides the timeout value set in the
+        parent job.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.ec2.VpnAttachmentOptions",
-    jsii_struct_bases=[],
-    name_mapping={
-        "remote_endpoint": "remoteEndpoint",
-        "connection_type": "connectionType",
-        "static_routes_only": "staticRoutesOnly",
-        "tunnel_configurations": "tunnelConfigurations",
-    },
-)
-class VpnAttachmentOptions:
-    def __init__(
-        self,
-        *,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
+        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
         '''
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c68fcd54ad9cdc22e3838841971cc60da339a1c6b65f45abf9839c71f80a1ad8)
-            check_type(argname="argument remote_endpoint", value=remote_endpoint, expected_type=type_hints["remote_endpoint"])
-            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
-            check_type(argname="argument static_routes_only", value=static_routes_only, expected_type=type_hints["static_routes_only"])
-            check_type(argname="argument tunnel_configurations", value=tunnel_configurations, expected_type=type_hints["tunnel_configurations"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "remote_endpoint": remote_endpoint,
-        }
-        if connection_type is not None:
-            self._values["connection_type"] = connection_type
-        if static_routes_only is not None:
-            self._values["static_routes_only"] = static_routes_only
-        if tunnel_configurations is not None:
-            self._values["tunnel_configurations"] = tunnel_configurations
-
-    @builtins.property
-    def remote_endpoint(self) -> IRemoteVpnEndpoint:
-        result = self._values.get("remote_endpoint")
-        assert result is not None, "Required property 'remote_endpoint' is missing"
-        return typing.cast(IRemoteVpnEndpoint, result)
+        result = self._values.get("timeout")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
-        result = self._values.get("connection_type")
-        return typing.cast(typing.Optional["VpnConnectionType"], result)
-
-    @builtins.property
-    def static_routes_only(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("static_routes_only")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def tunnel_configurations(self) -> typing.Optional[typing.List[TunnelOptions]]:
-        result = self._values.get("tunnel_configurations")
-        return typing.cast(typing.Optional[typing.List[TunnelOptions]], result)
+    def bookmark_configuration(self) -> typing.Optional[BookmarkConfiguration]:
+        '''The bookmark configuration override to use for the Glue job that is being triggered.'''
+        result = self._values.get("bookmark_configuration")
+        return typing.cast(typing.Optional[BookmarkConfiguration], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "VpnAttachmentOptions(%s)" % ", ".join(
+        return "WorkflowJobActionOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IVpnConnection)
-class VpnConnection(
-    _aws_cdk_ceddda9d.Resource,
+class WorkflowPredicate(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.VpnConnection",
+    jsii_type="cdk-extensions.glue.WorkflowPredicate",
 ):
-    '''Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.'''
+    '''Predicate conditions for controlling trigger activation in a Glue workflow.'''
 
-    def __init__(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="crawler")
+    @builtins.classmethod
+    def crawler(
+        cls,
+        crawler: ICrawler,
         *,
-        local_endpoint: ILocalVpnEndpoint,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[CrawlerState] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the TransitGatewayAttachment class.
+    ) -> "WorkflowCrawlerPredicate":
+        '''A predicate condition dependent on the completion of a Glue crawler.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param local_endpoint: 
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
+        :param crawler: The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
+        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+
+        :return:
+
+        A workflow condition that is predicated on the completion of the
+        specified Glue crawler.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__db1711f2c24c8b7a52cb1e23aa7c00f2ee31a53d068176d8b694ba413b49c85e)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = VpnConnectionProps(
-            local_endpoint=local_endpoint,
-            remote_endpoint=remote_endpoint,
-            connection_type=connection_type,
-            static_routes_only=static_routes_only,
-            tunnel_configurations=tunnel_configurations,
+            type_hints = typing.get_type_hints(_typecheckingstub__ffa264c859c1bcdd41fda254d289bc185e36ff404ad7901a6b7d63d92cddf8ee)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        options = WorkflowCrawlerPredicateOptions(
+            logical_operator=logical_operator,
+            state=state,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        jsii.create(self.__class__, self, [scope, id, props])
-
-    @jsii.member(jsii_name="addTunnelConfiguration")
-    def add_tunnel_configuration(
-        self,
-        *,
-        inside_cidr: typing.Optional[builtins.str] = None,
-        pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
-    ) -> None:
-        '''
-        :param inside_cidr: 
-        :param pre_shared_key: 
-        '''
-        options = TunnelOptions(inside_cidr=inside_cidr, pre_shared_key=pre_shared_key)
-
-        return typing.cast(None, jsii.invoke(self, "addTunnelConfiguration", [options]))
+        return typing.cast("WorkflowCrawlerPredicate", jsii.sinvoke(cls, "crawler", [crawler, options]))
 
-    @jsii.member(jsii_name="metric")
-    def metric(
-        self,
-        metric_name: builtins.str,
+    @jsii.member(jsii_name="job")
+    @builtins.classmethod
+    def job(
+        cls,
+        job: IJob,
         *,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[JobState] = None,
         account: typing.Optional[builtins.str] = None,
-        color: typing.Optional[builtins.str] = None,
-        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        label: typing.Optional[builtins.str] = None,
-        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        statistic: typing.Optional[builtins.str] = None,
-        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
-    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
-        '''Return the given named metric for this VPNConnection.
-
-        :param metric_name: -
-        :param account: Account which this metric comes from. Default: - Deployment account.
-        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
-        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
-        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
-        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
-        :param region: Region which this metric comes from. Default: - Deployment region.
-        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
-        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3b1943d41246b0671229072a9d9650d8d0f9f66aaf7b458b59f96ab84ad35da3)
-            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
-        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
-            account=account,
-            color=color,
-            dimensions_map=dimensions_map,
-            label=label,
-            period=period,
-            region=region,
-            statistic=statistic,
-            unit=unit,
-        )
+    ) -> "WorkflowJobPredicate":
+        '''A predicate condition dependent on the completion of a Glue job.
 
-        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metric", [metric_name, props]))
+        :param job: The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
+        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
 
-    @jsii.member(jsii_name="metricTunnelDataIn")
-    def metric_tunnel_data_in(
-        self,
-        *,
-        account: typing.Optional[builtins.str] = None,
-        color: typing.Optional[builtins.str] = None,
-        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        label: typing.Optional[builtins.str] = None,
-        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        region: typing.Optional[builtins.str] = None,
-        statistic: typing.Optional[builtins.str] = None,
-        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
-    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
-        '''The bytes received through the VPN tunnel.
-
-        Sum over 5 minutes
-
-        :param account: Account which this metric comes from. Default: - Deployment account.
-        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
-        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
-        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
-        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
-        :param region: Region which this metric comes from. Default: - Deployment region.
-        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
-        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
+        :return:
+
+        A workflow condition that is predicated on the completion of the
+        specified Glue crawler.
         '''
-        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca6546c9bc55323e0c4cb2c970aba51c478d9a3067002ee323e9093850759207)
+            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
+        options = WorkflowJobPredicateOptions(
+            logical_operator=logical_operator,
+            state=state,
             account=account,
-            color=color,
-            dimensions_map=dimensions_map,
-            label=label,
-            period=period,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
             region=region,
-            statistic=statistic,
-            unit=unit,
         )
 
-        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelDataIn", [props]))
+        return typing.cast("WorkflowJobPredicate", jsii.sinvoke(cls, "job", [job, options]))
+
 
-    @jsii.member(jsii_name="metricTunnelDataOut")
-    def metric_tunnel_data_out(
+class WorkflowPredicateBase(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.WorkflowPredicateBase",
+):
+    '''Base class providing common functionality for trigger predicate conditions.'''
+
+    def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
-        color: typing.Optional[builtins.str] = None,
-        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        label: typing.Optional[builtins.str] = None,
-        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        statistic: typing.Optional[builtins.str] = None,
-        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
-    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
-        '''The bytes sent through the VPN tunnel.
-
-        Sum over 5 minutes
-
-        :param account: Account which this metric comes from. Default: - Deployment account.
-        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
-        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
-        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
-        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
-        :param region: Region which this metric comes from. Default: - Deployment region.
-        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
-        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
+    ) -> None:
+        '''Create a new instance of the WorkflowPredicateBase class.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+        _options = WorkflowPredicateOptions(
             account=account,
-            color=color,
-            dimensions_map=dimensions_map,
-            label=label,
-            period=period,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
             region=region,
-            statistic=statistic,
-            unit=unit,
         )
 
-        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelDataOut", [props]))
+        jsii.create(self.__class__, self, [_options])
+
+    @jsii.member(jsii_name="bindOptions")
+    def _bind_options(self, _scope: _constructs_77d1e7e8.IConstruct) -> typing.Any:
+        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
+
+        :param _scope: The construct configuring the Glue trigger.
+
+        :return:
 
-    @jsii.member(jsii_name="metricTunnelState")
-    def metric_tunnel_state(
+        A configuration object that can be used to configure a predicate
+        condition for the Glue trigger.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__532fa291e748d01f44fced9f7933021be1f8ac049d19d07677702e64c2e226cc)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(typing.Any, jsii.invoke(self, "bindOptions", [_scope]))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.WorkflowPredicateOptions",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+    },
+)
+class WorkflowPredicateOptions(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
-        color: typing.Optional[builtins.str] = None,
-        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        label: typing.Optional[builtins.str] = None,
-        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        statistic: typing.Optional[builtins.str] = None,
-        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
-    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
-        '''The state of the tunnel.
-
-        0 indicates DOWN and 1 indicates UP.
-
-        Average over 5 minutes
-
-        :param account: Account which this metric comes from. Default: - Deployment account.
-        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
-        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
-        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
-        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
-        :param region: Region which this metric comes from. Default: - Deployment region.
-        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
-        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
-        '''
-        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
-            account=account,
-            color=color,
-            dimensions_map=dimensions_map,
-            label=label,
-            period=period,
-            region=region,
-            statistic=statistic,
-            unit=unit,
-        )
+    ) -> None:
+        '''Options for a generic Glue Trigger predicate.
 
-        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelState", [props]))
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0105e31834c9b424b25ba556e15b0668eb70bf912898e00b880d88fa39017523)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
 
     @builtins.property
-    @jsii.member(jsii_name="connectionType")
-    def connection_type(self) -> "VpnConnectionType":
-        return typing.cast("VpnConnectionType", jsii.get(self, "connectionType"))
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-    @builtins.property
-    @jsii.member(jsii_name="customerGatewayAsn")
-    def customer_gateway_asn(self) -> jsii.Number:
-        '''The ASN of the customer gateway.'''
-        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayId")
-    def customer_gateway_id(self) -> builtins.str:
-        '''The id of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-    @builtins.property
-    @jsii.member(jsii_name="customerGatewayIp")
-    def customer_gateway_ip(self) -> builtins.str:
-        '''The ip address of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @builtins.property
-    @jsii.member(jsii_name="localEndpoint")
-    def local_endpoint(self) -> ILocalVpnEndpoint:
-        return typing.cast(ILocalVpnEndpoint, jsii.get(self, "localEndpoint"))
+        Cannot be supplied together with either ``account`` or ``region``.
 
-    @builtins.property
-    @jsii.member(jsii_name="remoteEndpoint")
-    def remote_endpoint(self) -> IRemoteVpnEndpoint:
-        return typing.cast(IRemoteVpnEndpoint, jsii.get(self, "remoteEndpoint"))
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection:
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection, jsii.get(self, "resource"))
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @builtins.property
-    @jsii.member(jsii_name="tunnelConfigurations")
-    def tunnel_configurations(self) -> typing.List[TunnelOptions]:
-        return typing.cast(typing.List[TunnelOptions], jsii.get(self, "tunnelConfigurations"))
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-    @builtins.property
-    @jsii.member(jsii_name="vpnId")
-    def vpn_id(self) -> builtins.str:
-        '''The id of the VPN connection.'''
-        return typing.cast(builtins.str, jsii.get(self, "vpnId"))
+        :default: - The physical name will be allocated by CloudFormation at deployment time
+        '''
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="staticRoutesOnly")
-    def static_routes_only(self) -> typing.Optional[builtins.bool]:
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "staticRoutesOnly"))
-
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-class VpnConnectionLocalEndpoint(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.VpnConnectionLocalEndpoint",
-):
-    '''Provides options for specifying the local side of a VPN connection.'''
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @jsii.member(jsii_name="fromTransitGateway")
-    @builtins.classmethod
-    def from_transit_gateway(
-        cls,
-        transit_gateway: ITransitGateway,
-    ) -> TransitGatewayLocalVpnEndpoint:
-        '''
-        :param transit_gateway: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b7ddda611ef5d00d1dbfb980664aaf365a9109585805083204f9dd201f73b937)
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-        return typing.cast(TransitGatewayLocalVpnEndpoint, jsii.sinvoke(cls, "fromTransitGateway", [transit_gateway]))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @jsii.member(jsii_name="fromVpnGateway")
-    @builtins.classmethod
-    def from_vpn_gateway(
-        cls,
-        vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
-    ) -> "VpnGatewayLocalVpnEndpoint":
-        '''
-        :param vpn_gateway: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__255c4f2f88d39694addb3404e05f43b66d5900dda0a83d02497e7579af1e9f87)
-            check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
-        return typing.cast("VpnGatewayLocalVpnEndpoint", jsii.sinvoke(cls, "fromVpnGateway", [vpn_gateway]))
+    def __repr__(self) -> str:
+        return "WorkflowPredicateOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.VpnConnectionProps",
+    jsii_type="cdk-extensions.glue.WorkflowProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "local_endpoint": "localEndpoint",
-        "remote_endpoint": "remoteEndpoint",
-        "connection_type": "connectionType",
-        "static_routes_only": "staticRoutesOnly",
-        "tunnel_configurations": "tunnelConfigurations",
+        "description": "description",
+        "name": "name",
     },
 )
-class VpnConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
+class WorkflowProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        local_endpoint: ILocalVpnEndpoint,
-        remote_endpoint: IRemoteVpnEndpoint,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        static_routes_only: typing.Optional[builtins.bool] = None,
-        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the VpnConnection resource.
+        '''Configuration for the Glue Workflow resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param local_endpoint: 
-        :param remote_endpoint: 
-        :param connection_type: 
-        :param static_routes_only: 
-        :param tunnel_configurations: 
+        :param description: A description of the Workflow.
+        :param name: A name of the Workflow.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e9f1ecffd701acc1acc5674e16c0bca0e65f2e2327e74bfb0fe4021722919ad1)
+            type_hints = typing.get_type_hints(_typecheckingstub__2ce544c2156b20e8e19b70a1531a61d42db72f6b0e812f45f7bc7bfbeead5f0b)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument local_endpoint", value=local_endpoint, expected_type=type_hints["local_endpoint"])
-            check_type(argname="argument remote_endpoint", value=remote_endpoint, expected_type=type_hints["remote_endpoint"])
-            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
-            check_type(argname="argument static_routes_only", value=static_routes_only, expected_type=type_hints["static_routes_only"])
-            check_type(argname="argument tunnel_configurations", value=tunnel_configurations, expected_type=type_hints["tunnel_configurations"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "local_endpoint": local_endpoint,
-            "remote_endpoint": remote_endpoint,
-        }
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if connection_type is not None:
-            self._values["connection_type"] = connection_type
-        if static_routes_only is not None:
-            self._values["static_routes_only"] = static_routes_only
-        if tunnel_configurations is not None:
-            self._values["tunnel_configurations"] = tunnel_configurations
+        if description is not None:
+            self._values["description"] = description
+        if name is not None:
+            self._values["name"] = name
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -5570,764 +7887,869 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def local_endpoint(self) -> ILocalVpnEndpoint:
-        result = self._values.get("local_endpoint")
-        assert result is not None, "Required property 'local_endpoint' is missing"
-        return typing.cast(ILocalVpnEndpoint, result)
-
-    @builtins.property
-    def remote_endpoint(self) -> IRemoteVpnEndpoint:
-        result = self._values.get("remote_endpoint")
-        assert result is not None, "Required property 'remote_endpoint' is missing"
-        return typing.cast(IRemoteVpnEndpoint, result)
-
-    @builtins.property
-    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
-        result = self._values.get("connection_type")
-        return typing.cast(typing.Optional["VpnConnectionType"], result)
-
-    @builtins.property
-    def static_routes_only(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("static_routes_only")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def description(self) -> typing.Optional[builtins.str]:
+        '''A description of the Workflow.'''
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def tunnel_configurations(self) -> typing.Optional[typing.List[TunnelOptions]]:
-        result = self._values.get("tunnel_configurations")
-        return typing.cast(typing.Optional[typing.List[TunnelOptions]], result)
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A name of the Workflow.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "VpnConnectionProps(%s)" % ", ".join(
+        return "WorkflowProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class VpnConnectionRemoteEndpoint(
+class ArrayColumn(
+    Column,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.VpnConnectionRemoteEndpoint",
+    jsii_type="cdk-extensions.glue.ArrayColumn",
 ):
-    '''Provides options for specifying the remote side of a VPN connection.'''
-
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
-
-    @jsii.member(jsii_name="fromConfiguration")
-    @builtins.classmethod
-    def from_configuration(
-        cls,
+    def __init__(
+        self,
         *,
-        ip_address: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        connection_type: typing.Optional["VpnConnectionType"] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> "CustomerGatewayConfigurationRemoteVpnEndpoint":
-        '''Creates a remote connection using the configuration details provided.
-
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param connection_type: The type of VPN connection that this customer gateway supports.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-
-        :return: A configuration object representing a remote VPN destination.
+        data: Column,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
         '''
-        configuration = CustomerGatewayProps(
-            ip_address=ip_address,
-            bgp_asn=bgp_asn,
-            connection_type=connection_type,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        :param data: 
+        :param comment: 
+        :param name: 
+        '''
+        props = ArrayColumnProps(data=data, comment=comment, name=name)
 
-        return typing.cast("CustomerGatewayConfigurationRemoteVpnEndpoint", jsii.sinvoke(cls, "fromConfiguration", [configuration]))
+        jsii.create(self.__class__, self, [props])
 
-    @jsii.member(jsii_name="fromCustomerGateway")
-    @builtins.classmethod
-    def from_customer_gateway(
-        cls,
-        customer_gateway: ICustomerGateway,
-    ) -> "CustomerGatewayRemoteVpnEndpoint":
-        '''Creates a remote connection using a customer gateway.
+    @builtins.property
+    @jsii.member(jsii_name="typeString")
+    def type_string(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "typeString"))
 
-        :param customer_gateway: The customer gateway that is configured for the remote endpoint device.
 
-        :return: A configuration object representing a remote VPN destination.
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.ArrayColumnProps",
+    jsii_struct_bases=[ColumnProps],
+    name_mapping={"comment": "comment", "name": "name", "data": "data"},
+)
+class ArrayColumnProps(ColumnProps):
+    def __init__(
+        self,
+        *,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        data: Column,
+    ) -> None:
+        '''
+        :param comment: 
+        :param name: 
+        :param data: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0ec3ce1dacbcb72f74a7ad181d5838d1e71517bb5fc661cee673e3d13cf35dbe)
-            check_type(argname="argument customer_gateway", value=customer_gateway, expected_type=type_hints["customer_gateway"])
-        return typing.cast("CustomerGatewayRemoteVpnEndpoint", jsii.sinvoke(cls, "fromCustomerGateway", [customer_gateway]))
-
+            type_hints = typing.get_type_hints(_typecheckingstub__e98ee73549e5bf2df4bd363c5ccef46d94100d1940e7c591367826866bb56b21)
+            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "data": data,
+        }
+        if comment is not None:
+            self._values["comment"] = comment
+        if name is not None:
+            self._values["name"] = name
 
-class VpnConnectionType(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.VpnConnectionType",
-):
-    '''Represents a VPN protocol that can be used to establish a connection.'''
+    @builtins.property
+    def comment(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("comment")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, name: builtins.str) -> "VpnConnectionType":
-        '''An escape hatch method that allows defining custom VPN protocols.
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :param name: The name of the VPN protocol.
+    @builtins.property
+    def data(self) -> Column:
+        result = self._values.get("data")
+        assert result is not None, "Required property 'data' is missing"
+        return typing.cast(Column, result)
 
-        :return: A VpnConnectionType object representing the specified protocol.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__19c531bfa20e4b82501cd1840a34d989b2593246657ad35703dfdd6156ae409b)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("VpnConnectionType", jsii.sinvoke(cls, "of", [name]))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="IPSEC_1")
-    def IPSEC_1(cls) -> "VpnConnectionType":
-        '''The ipsec.1 VPN protocol.'''
-        return typing.cast("VpnConnectionType", jsii.sget(cls, "IPSEC_1"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the VPN protocol.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+    def __repr__(self) -> str:
+        return "ArrayColumnProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-@jsii.implements(ILocalVpnEndpoint)
-class VpnGatewayLocalVpnEndpoint(
+class AssetCode(
+    Code,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.VpnGatewayLocalVpnEndpoint",
+    jsii_type="cdk-extensions.glue.AssetCode",
 ):
-    '''Specifies a VPN connection endpoint which routes to a VPN gateway on the AWS side.'''
+    '''Job Code from a local file.'''
 
-    def __init__(self, vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway) -> None:
-        '''Creates a new instance of the VpnGatewayLocalVpnEndpoint class.
-
-        :param vpn_gateway: The VPN gateway that serves as the local end of a VPN connection.
+    def __init__(
+        self,
+        path: builtins.str,
+        *,
+        asset_hash: typing.Optional[builtins.str] = None,
+        asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
+        bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
+        '''
+        :param path: The path to the Code file.
+        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
+        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
+        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a4c9d0488d52533eda0e8e013c7c8dc98375bf35fbfb4d0119edfc6dafc3add2)
-            check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
-        jsii.create(self.__class__, self, [vpn_gateway])
+            type_hints = typing.get_type_hints(_typecheckingstub__7e088280d8611751a4dd67d784a7813fe0d71f491155a45dfd938dcbbf43714d)
+            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
+        options = _aws_cdk_ceddda9d.AssetOptions(
+            asset_hash=asset_hash, asset_hash_type=asset_hash_type, bundling=bundling
+        )
+
+        jsii.create(self.__class__, self, [path, options])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> LocalVpnEndpointConfiguration:
-        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+        scope: _constructs_77d1e7e8.Construct,
+        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+    ) -> CodeConfig:
+        '''Called when the Job is initialized to allow this object to bind.
 
-        :param _scope: The construct configuring the VPN connection that will be referencing the local endpoint.
+        :param scope: -
+        :param grantable: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b034f4493a7f4e0ef9f3e966d78f68321b168b61b98dda5c4dace5477a2b5d5e)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(LocalVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__ec027c50ac516e8170beed01cb13e2ead3adfe45e782c6b378a332ada31736c0)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
+        return typing.cast(CodeConfig, jsii.invoke(self, "bind", [scope, grantable]))
+
+
+class BasicColumn(
+    Column,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.glue.BasicColumn",
+):
+    def __init__(
+        self,
+        *,
+        type: builtins.str,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param type: 
+        :param comment: 
+        :param name: 
+        '''
+        props = BasicColumnProps(type=type, comment=comment, name=name)
+
+        jsii.create(self.__class__, self, [props])
 
     @builtins.property
-    @jsii.member(jsii_name="vpnGateway")
-    def vpn_gateway(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpnGateway:
-        '''The VPN gateway that serves as the local end of a VPN connection.
+    @jsii.member(jsii_name="typeString")
+    def type_string(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "typeString"))
 
-        :group: Inputs
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.BasicColumnProps",
+    jsii_struct_bases=[ColumnProps],
+    name_mapping={"comment": "comment", "name": "name", "type": "type"},
+)
+class BasicColumnProps(ColumnProps):
+    def __init__(
+        self,
+        *,
+        comment: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        type: builtins.str,
+    ) -> None:
+        '''
+        :param comment: 
+        :param name: 
+        :param type: 
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpnGateway, jsii.get(self, "vpnGateway"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0ae472b6c02750d1961d7f516ba02f642a1ea26bb6902239beb46998e097aaf9)
+            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "type": type,
+        }
+        if comment is not None:
+            self._values["comment"] = comment
+        if name is not None:
+            self._values["name"] = name
 
+    @builtins.property
+    def comment(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("comment")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-@jsii.implements(ICustomerGateway)
-class CustomerGateway(
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def type(self) -> builtins.str:
+        result = self._values.get("type")
+        assert result is not None, "Required property 'type' is missing"
+        return typing.cast(builtins.str, result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "BasicColumnProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.implements(ICrawler)
+class Crawler(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.CustomerGateway",
+    jsii_type="cdk-extensions.glue.Crawler",
 ):
-    '''Specifies thje details of a remote endpoint that can serve as an endpoint for connections to AWS.'''
+    '''Create a Crawler resource to pull information from the provided resource.
+
+    :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html>`_
+    '''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        ip_address: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        connection_type: typing.Optional[VpnConnectionType] = None,
+        classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
+        configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
+        database: typing.Optional[Database] = None,
+        delete_behavior: typing.Optional[DeleteBehavior] = None,
+        description: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
+        schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+        security_configuration: typing.Optional[SecurityConfiguration] = None,
+        table_prefix: typing.Optional[builtins.str] = None,
+        targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
+        update_behavior: typing.Optional[UpdateBehavior] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the CustomerGateway class.
+        '''Creates a new instance of the Crawler class.
 
         :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param classifiers: A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
+        :param configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
+        :param database: The {@link aws-glue.Database | Database } object in which the crawler's output is stored.
+        :param delete_behavior: The deletion behavior when the crawler finds a deleted object.
+        :param description: Description of the Crawler.
+        :param name: Name of the Crawler.
+        :param recrawl_behavior: When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
+        :param schedule_expression: For scheduled crawlers, the schedule when the crawler runs.
+        :param security_configuration: A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.
+        :param table_prefix: The prefix added to the names of tables that are created.
+        :param targets: A collection of targets to crawl.
+        :param update_behavior: The update behavior when the crawler finds a changed schema.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7814523b269d29ae5e2e42aa21c1f81bdc5a471fe5e300b0768c03a21b6a6f91)
+            type_hints = typing.get_type_hints(_typecheckingstub__5211274cd7116e3c396417e594ecadcc53088dd8ee26c4e810934deac308acc2)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = CustomerGatewayProps(
-            ip_address=ip_address,
-            bgp_asn=bgp_asn,
-            connection_type=connection_type,
+        props = CrawlerProps(
+            classifiers=classifiers,
+            configuration=configuration,
+            database=database,
+            delete_behavior=delete_behavior,
+            description=description,
+            name=name,
+            recrawl_behavior=recrawl_behavior,
+            schedule_expression=schedule_expression,
+            security_configuration=security_configuration,
+            table_prefix=table_prefix,
+            targets=targets,
+            update_behavior=update_behavior,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="fromCustomerGatewayAttributes")
+    @jsii.member(jsii_name="fromCrawlerArn")
     @builtins.classmethod
-    def from_customer_gateway_attributes(
+    def from_crawler_arn(
         cls,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
-        *,
-        customer_gateway_id: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        ip_address: typing.Optional[builtins.str] = None,
-    ) -> ICustomerGateway:
-        '''Imports an existing custom gateway by specifying its details.
+        crawler_arn: builtins.str,
+    ) -> ICrawler:
+        '''Imports an existing crawler using its Amazon Resource Name (ARN).
 
         :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param customer_gateway_id: The ID of the existing customer gateway being imported.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param crawler_arn: The ARN of the crawler to import.
 
-        :return: An object representing the imported customer gateway.
+        :return: An object representing the crawler that was imported.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9cee3aaa3f8d41d377b44df84c1bd31404fc3c74c1f3d4d50f41733f5ceaeaba)
+            type_hints = typing.get_type_hints(_typecheckingstub__d145d23256eb2d35c1a9bf019e04dff25bc109fef47efc90d6d6f6882fdb4815)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        attributes = CustomerGatewayAttributes(
-            customer_gateway_id=customer_gateway_id,
-            bgp_asn=bgp_asn,
-            ip_address=ip_address,
-        )
-
-        return typing.cast(ICustomerGateway, jsii.sinvoke(cls, "fromCustomerGatewayAttributes", [scope, id, attributes]))
+            check_type(argname="argument crawler_arn", value=crawler_arn, expected_type=type_hints["crawler_arn"])
+        return typing.cast(ICrawler, jsii.sinvoke(cls, "fromCrawlerArn", [scope, id, crawler_arn]))
 
-    @jsii.member(jsii_name="fromCustomerGatewayId")
+    @jsii.member(jsii_name="fromCrawlerName")
     @builtins.classmethod
-    def from_customer_gateway_id(
+    def from_crawler_name(
         cls,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
-        customer_gateway_id: builtins.str,
-    ) -> ICustomerGateway:
-        '''Imports an existing custom gateway using its CustomerGatewayId.
+        crawler_name: builtins.str,
+    ) -> ICrawler:
+        '''Imports an existing crawler using its name.
 
         :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
         :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param customer_gateway_id: The ID of the existing customer gateway being imported.
+        :param crawler_name: The name of the crawler to import.
 
-        :return: An object representing the imported customer gateway.
+        :return: An object representing the crawler that was imported.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__745b377e3c9abac41a861ca1050cfc8012b832cecc7ce152fed229d86ee5e4ae)
+            type_hints = typing.get_type_hints(_typecheckingstub__d539939596ad8ddfe1a7db54e1c33868e19ed805abf7d2eef859c4a90be77941)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
-        return typing.cast(ICustomerGateway, jsii.sinvoke(cls, "fromCustomerGatewayId", [scope, id, customer_gateway_id]))
+            check_type(argname="argument crawler_name", value=crawler_name, expected_type=type_hints["crawler_name"])
+        return typing.cast(ICrawler, jsii.sinvoke(cls, "fromCrawlerName", [scope, id, crawler_name]))
 
-    @builtins.property
-    @jsii.member(jsii_name="bgpAsn")
-    def bgp_asn(self) -> jsii.Number:
-        '''For devices that support BGP, the customer gateway's BGP ASN.
+    @jsii.member(jsii_name="addClassifier")
+    def add_classifier(self, classifier: builtins.str) -> None:
+        '''
+        :param classifier: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__96016694c1f44cc04af86f8b769bd0adb927352bc79ad9603516897998bec7b0)
+            check_type(argname="argument classifier", value=classifier, expected_type=type_hints["classifier"])
+        return typing.cast(None, jsii.invoke(self, "addClassifier", [classifier]))
 
-        :see: `CustomerGateway BgpAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn>`_
-        :group: Inputs
+    @jsii.member(jsii_name="addTarget")
+    def add_target(self, target: ICrawlerTarget) -> None:
+        '''
+        :param target: -
         '''
-        return typing.cast(jsii.Number, jsii.get(self, "bgpAsn"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dc8dd7ffc643cb691f77d16e095c4e42f8ad2f09ba25c30724c84c18b23eefac)
+            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
+        return typing.cast(None, jsii.invoke(self, "addTarget", [target]))
 
     @builtins.property
-    @jsii.member(jsii_name="connectionType")
-    def connection_type(self) -> VpnConnectionType:
-        '''The type of VPN connection that this customer gateway supports.
+    @jsii.member(jsii_name="crawlerArn")
+    def crawler_arn(self) -> builtins.str:
+        '''The Amazon Resource Name (ARN) of the crawler.'''
+        return typing.cast(builtins.str, jsii.get(self, "crawlerArn"))
 
-        :see: `CustomerGateway Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type>`_
-        :group: Inputs
-        '''
-        return typing.cast(VpnConnectionType, jsii.get(self, "connectionType"))
+    @builtins.property
+    @jsii.member(jsii_name="crawlerName")
+    def crawler_name(self) -> builtins.str:
+        '''The name of the crawler.'''
+        return typing.cast(builtins.str, jsii.get(self, "crawlerName"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayAsn")
-    def customer_gateway_asn(self) -> jsii.Number:
-        '''The BGP ASN of the customer gateway.'''
-        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnCrawler:
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnCrawler, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayId")
-    def customer_gateway_id(self) -> builtins.str:
-        '''The ID of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
+    @jsii.member(jsii_name="role")
+    def role(self) -> _aws_cdk_aws_iam_ceddda9d.Role:
+        return typing.cast(_aws_cdk_aws_iam_ceddda9d.Role, jsii.get(self, "role"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGatewayIp")
-    def customer_gateway_ip(self) -> builtins.str:
-        '''The IP address of the customer gateway.'''
-        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
+    @jsii.member(jsii_name="configuration")
+    def configuration(self) -> typing.Optional[CrawlerConfiguration]:
+        '''{@link CrawlerProps.configuration}.'''
+        return typing.cast(typing.Optional[CrawlerConfiguration], jsii.get(self, "configuration"))
 
     @builtins.property
-    @jsii.member(jsii_name="ipAddress")
-    def ip_address(self) -> builtins.str:
-        '''The Internet-routable IP address for the customer gateway's outside interface.
+    @jsii.member(jsii_name="database")
+    def database(self) -> typing.Optional[Database]:
+        '''{@link CrawlerProps.database}.'''
+        return typing.cast(typing.Optional[Database], jsii.get(self, "database"))
 
-        The address must be static.
+    @builtins.property
+    @jsii.member(jsii_name="deleteBehavior")
+    def delete_behavior(self) -> typing.Optional[DeleteBehavior]:
+        '''{@link CrawlerProps.deleteBehavior}.'''
+        return typing.cast(typing.Optional[DeleteBehavior], jsii.get(self, "deleteBehavior"))
 
-        :see: `CustomerGateway IpAddress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress>`_
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "ipAddress"))
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''{@link CrawlerProps.description}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnCustomerGateway:
-        '''The underlying CustomerGateway CloudFormation resource.
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''{@link CrawlerProps.name}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
-        :see: `AWS::EC2::CustomerGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html>`_
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnCustomerGateway, jsii.get(self, "resource"))
+    @builtins.property
+    @jsii.member(jsii_name="recrawlBehavior")
+    def recrawl_behavior(self) -> typing.Optional[RecrawlBehavior]:
+        '''{@link CrawlerProps.recrawlBehavior}.'''
+        return typing.cast(typing.Optional[RecrawlBehavior], jsii.get(self, "recrawlBehavior"))
 
+    @builtins.property
+    @jsii.member(jsii_name="scheduleExpression")
+    def schedule_expression(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
+        '''{@link CrawlerProps.scheduleExpression}.'''
+        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], jsii.get(self, "scheduleExpression"))
+
+    @builtins.property
+    @jsii.member(jsii_name="securityConfiguration")
+    def security_configuration(self) -> typing.Optional[SecurityConfiguration]:
+        '''{@link CrawlerProps.securityConfiguration}.'''
+        return typing.cast(typing.Optional[SecurityConfiguration], jsii.get(self, "securityConfiguration"))
+
+    @builtins.property
+    @jsii.member(jsii_name="tablePrefix")
+    def table_prefix(self) -> typing.Optional[builtins.str]:
+        '''{@link CrawlerProps.tablePrefix}.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tablePrefix"))
+
+    @builtins.property
+    @jsii.member(jsii_name="updateBehavior")
+    def update_behavior(self) -> typing.Optional[UpdateBehavior]:
+        '''{@link CrawlerProps.updateBehavior}.'''
+        return typing.cast(typing.Optional[UpdateBehavior], jsii.get(self, "updateBehavior"))
 
-@jsii.implements(IRemoteVpnEndpoint)
-class CustomerGatewayConfigurationRemoteVpnEndpoint(
+
+@jsii.implements(ITriggerPredicate)
+class WorkflowCrawlerPredicate(
+    WorkflowPredicateBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.CustomerGatewayConfigurationRemoteVpnEndpoint",
+    jsii_type="cdk-extensions.glue.WorkflowCrawlerPredicate",
 ):
-    '''Specifies a remote VPN endpoint device by directly specifyingits details.'''
+    '''Represents a condition that is predicated on a Glue crawler completion.
+
+    The condition can be used to create a trigger that controls the execution of
+    downstream tasks in a workflow.
+    '''
 
     def __init__(
         self,
+        crawler: ICrawler,
         *,
-        ip_address: builtins.str,
-        bgp_asn: typing.Optional[jsii.Number] = None,
-        connection_type: typing.Optional[VpnConnectionType] = None,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[CrawlerState] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the CustomerGatewayConfigurationRemoteVpnEndpoint class.
+        '''Creates a new instance of the WorkflowCrawlerPredicate class.
 
-        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
-        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
-        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param crawler: The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
+        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        configuration = CustomerGatewayProps(
-            ip_address=ip_address,
-            bgp_asn=bgp_asn,
-            connection_type=connection_type,
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a18ab964f00a29725095bfb40c5b43949ff4de4430650c9d95b535e4941cfc7a)
+            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
+        options = WorkflowCrawlerPredicateOptions(
+            logical_operator=logical_operator,
+            state=state,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        jsii.create(self.__class__, self, [configuration])
+        jsii.create(self.__class__, self, [crawler, options])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> RemoteVpnEndpointConfiguration:
-        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
 
-        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
+        :param scope: The construct configuring the Glue trigger.
+
+        :return:
+
+        A configuration object that can be used to configure a predicate
+        condition for the Glue trigger.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__376ae140d941de56c115f01c627b230e0ffb07b7247eb9a061e389e071218f36)
+            type_hints = typing.get_type_hints(_typecheckingstub__ab6c6045286c50786550fc825f10c79429ddaf99441ba9be931f3575ea02ea64)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(RemoteVpnEndpointConfiguration, jsii.invoke(self, "bind", [scope]))
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="configuration")
-    def configuration(self) -> CustomerGatewayProps:
-        '''The details of the device on the remote end of the VPN connection.
+    @jsii.member(jsii_name="crawler")
+    def crawler(self) -> ICrawler:
+        '''The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
 
+        :see: `Trigger Predicate.Conditions.CrawlerName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlername>`_
         :group: Inputs
         '''
-        return typing.cast(CustomerGatewayProps, jsii.get(self, "configuration"))
+        return typing.cast(ICrawler, jsii.get(self, "crawler"))
 
     @builtins.property
-    @jsii.member(jsii_name="customerGateway")
-    def customer_gateway(self) -> typing.Optional[CustomerGateway]:
-        '''The customer gateway that was created to represent the device on the remote end of the VPN connection.
+    @jsii.member(jsii_name="logicalOperator")
+    def logical_operator(self) -> PredicateLogicalOperator:
+        '''The logical operator which should be applied in determining whether a crawler meets the requested conditions.
 
-        :group: Resources
-        '''
-        return typing.cast(typing.Optional[CustomerGateway], jsii.get(self, "customerGateway"))
+        At the moment, the only supported operator is ``EQUALS``.
 
+        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
+        '''
+        return typing.cast(PredicateLogicalOperator, jsii.get(self, "logicalOperator"))
 
-@jsii.implements(IRemoteVpnEndpoint)
-class CustomerGatewayRemoteVpnEndpoint(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.CustomerGatewayRemoteVpnEndpoint",
-):
-    '''Specifies a remote VPN endpoint device that has its details configured in an existing customer gateway.'''
-
-    def __init__(self, customer_gateway: ICustomerGateway) -> None:
-        '''Creates a new instance of the CustomerGatewayRemoteVpnEndpoint class.
+    @builtins.property
+    @jsii.member(jsii_name="state")
+    def state(self) -> CrawlerState:
+        '''The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
 
-        :param customer_gateway: The customer gateway that is configured with the details of the remote endpoint device.
+        :see: `Trigger Predicate.Conditions.CrawlState <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlstate>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__39f263303ec59ccc7954f0b56dc5825a43956cfa48fc4648959c032c858f8a2f)
-            check_type(argname="argument customer_gateway", value=customer_gateway, expected_type=type_hints["customer_gateway"])
-        jsii.create(self.__class__, self, [customer_gateway])
+        return typing.cast(CrawlerState, jsii.get(self, "state"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.glue.WorkflowCrawlerPredicateOptions",
+    jsii_struct_bases=[WorkflowPredicateOptions],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "logical_operator": "logicalOperator",
+        "state": "state",
+    },
+)
+class WorkflowCrawlerPredicateOptions(WorkflowPredicateOptions):
+    def __init__(
         self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> RemoteVpnEndpointConfiguration:
-        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[CrawlerState] = None,
+    ) -> None:
+        '''Configuration options that specify the state a crawler must meet in order to satisfy the conditions of the predicate.
 
-        :param _scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bd8797d122fda919f703e603d2c593c1fe151dbc800704673ccc25360cdf5d3e)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(RemoteVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__b34c0d221b3673906a9840fa8262a73d533de41c6c0f80b688d92ba11c4e20a1)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument logical_operator", value=logical_operator, expected_type=type_hints["logical_operator"])
+            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if logical_operator is not None:
+            self._values["logical_operator"] = logical_operator
+        if state is not None:
+            self._values["state"] = state
 
     @builtins.property
-    @jsii.member(jsii_name="customerGateway")
-    def customer_gateway(self) -> ICustomerGateway:
-        '''The customer gateway that is configured with the details of the remote endpoint device.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(ICustomerGateway, jsii.get(self, "customerGateway"))
-
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-@jsii.implements(ILogDestination)
-class FlowLogDestination(
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.ec2.FlowLogDestination",
-):
-    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @jsii.member(jsii_name="toCloudWatchLogs")
-    @builtins.classmethod
-    def to_cloud_watch_logs(
-        cls,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    ) -> "FlowLogDestination":
-        '''Represents a CloudWatch log group that will serve as the endpoint where flow logs should be delivered.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :param log_group: The CloudWatch LogGroup where flow logs should be delivered.
-        :param role: An IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        A configuration object containing details on how to set up
-        logging to the log group.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :see: `Publish flow logs to CloudWatch Logs <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-cwl.html>`_
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5daa8ff9c63f8f6617139a25d0c2042756ce3ab0da13e5f5a51634e4b9f7ab0c)
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toCloudWatchLogs", [log_group, role]))
-
-    @jsii.member(jsii_name="toS3")
-    @builtins.classmethod
-    def to_s3(
-        cls,
-        bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
-        *,
-        file_format: typing.Optional[FlowLogFileFormat] = None,
-        hive_compatible_partitions: typing.Optional[builtins.bool] = None,
-        key_prefix: typing.Optional[builtins.str] = None,
-        per_hour_partition: typing.Optional[builtins.bool] = None,
-    ) -> "FlowLogDestination":
-        '''Represents a CloudWatch log group that will serve as the endpoint where flow logs should be delivered.
-
-        :param bucket: The S3 Bucket where flow logs should be delivered.
-        :param file_format: The file format in which flow logs should be delivered to S3.
-        :param hive_compatible_partitions: Controls the format of partitions ("folders") when the flow logs are delivered to S3. By default, flow logs are delivered partitioned such that each part of the S3 path represents a values pertaining to details of the log. When hive compatible partitions are enabled, partitions will be structured such that keys declaring the partition name are added at each level. An example of standard partitioning:: /us-east-1/2020/03/08/log.tar.gz An example with Hive compatible partitions:: /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
-        :param key_prefix: An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
-        :param per_hour_partition: Indicates whether to partition the flow log per hour. By default, flow logs are partitioned (organized into S3 "folders") by day. Setting this to true will add an extra layer of directories splitting flow log files by the hour in which they were delivered.
-
-        :return:
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        A configuration object containing details on how to set up
-        logging to the bucket.
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :see: `Publish flow logs to Amazon S3 <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-s3.html>`_
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8d11b43c926a884fe3a73d0b44332cd0342bba0c0e2d7bcac16489f068e1191b)
-            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
-        options = FlowLogS3Options(
-            file_format=file_format,
-            hive_compatible_partitions=hive_compatible_partitions,
-            key_prefix=key_prefix,
-            per_hour_partition=per_hour_partition,
-        )
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toS3", [bucket, options]))
+    @builtins.property
+    def logical_operator(self) -> typing.Optional[PredicateLogicalOperator]:
+        '''The logical operator which should be applied in determining whether a crawler meets the requested conditions.
 
-    @jsii.member(jsii_name="bind")
-    @abc.abstractmethod
-    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
-        '''Returns a configuration object with all the fields and resources needed to configure a flow log to write to the destination.
+        At the moment, the only supported operator is ``EQUALS``.
 
-        :param scope: The CDK Construct that will be consuming the configuration and using it to configure a flow log.
+        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
         '''
-        ...
-
+        result = self._values.get("logical_operator")
+        return typing.cast(typing.Optional[PredicateLogicalOperator], result)
 
-class _FlowLogDestinationProxy(FlowLogDestination):
-    @jsii.member(jsii_name="bind")
-    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
-        '''Returns a configuration object with all the fields and resources needed to configure a flow log to write to the destination.
+    @builtins.property
+    def state(self) -> typing.Optional[CrawlerState]:
+        '''The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
 
-        :param scope: The CDK Construct that will be consuming the configuration and using it to configure a flow log.
+        :see: `Trigger Predicate.Conditions.CrawlState <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlstate>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e6be248e60a194fe1d0bcf9dc9398b94b088ef8e6ca462c0c85ef25246e79057)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(FlowLogDestinationConfig, jsii.invoke(self, "bind", [scope]))
+        result = self._values.get("state")
+        return typing.cast(typing.Optional[CrawlerState], result)
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, FlowLogDestination).__jsii_proxy_class__ = lambda : _FlowLogDestinationProxy
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-class TransitGatewayAttachment(
-    TransitGatewayAttachmentResource,
+    def __repr__(self) -> str:
+        return "WorkflowCrawlerPredicateOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.implements(ITriggerPredicate)
+class WorkflowJobPredicate(
+    WorkflowPredicateBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.ec2.TransitGatewayAttachment",
+    jsii_type="cdk-extensions.glue.WorkflowJobPredicate",
 ):
-    '''Attaches a VPC to a transit gateway.
+    '''Represents a condition that is predicated on a Glue job completion.
 
-    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC
-    that is already attached, the new VPC CIDR range is not propagated to the
-    default propagation route table.
+    The condition can be used to create a trigger that controls the execution of
+    downstream tasks in a workflow.
     '''
 
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
+        job: IJob,
         *,
-        transit_gateway: ITransitGateway,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        appliance_mode_support: typing.Optional[builtins.bool] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        ipv6_support: typing.Optional[builtins.bool] = None,
-        name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[JobState] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the TransitGatewayAttachment class.
+        '''Creates a new instance of the WorkflowJobPredicate class.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway: The transit gateway for which the attachment should be created.
-        :param vpc: The VPC where the attachment should be created.
-        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
-        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
+        :param job: The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
+        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e27ee6909fddcfad51f5ddc3aee4e522d6f5fdeab0a0272e67e7d62c063924d6)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TransitGatewayAttachmentProps(
-            transit_gateway=transit_gateway,
-            vpc=vpc,
-            appliance_mode_support=appliance_mode_support,
-            dns_support=dns_support,
-            ipv6_support=ipv6_support,
-            name=name,
-            subnets=subnets,
+            type_hints = typing.get_type_hints(_typecheckingstub__f4c02ff62824c53aba142c5763845ac4a5e58a9cb8f54ede31043c8dba475d26)
+            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
+        options = WorkflowJobPredicateOptions(
+            logical_operator=logical_operator,
+            state=state,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        jsii.create(self.__class__, self, [scope, id, props])
+        jsii.create(self.__class__, self, [job, options])
 
-    @jsii.member(jsii_name="fromTransitGatewayAttachmentId")
-    @builtins.classmethod
-    def from_transit_gateway_attachment_id(
-        cls,
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
         scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        transit_gateway_attachment_id: builtins.str,
-    ) -> ITransitGatewayAttachment:
-        '''Imports an existing Transit Gateway Attachment using its attachment ID.
+    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
 
-        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param transit_gateway_attachment_id: The attachment ID of the Transit Gateway attachment being imported.
+        :param scope: The construct configuring the Glue trigger.
 
-        :return: An object representing the imported transit gateway attachment.
+        :return:
+
+        A configuration object that can be used to configure a predicate
+        condition for the Glue trigger.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__135a7b7bec5b4b7974ff32ebff887b94cc20f2b37d6736525ec2c4e7c4b5c542)
+            type_hints = typing.get_type_hints(_typecheckingstub__052b1ed2cea96b32b65c6bcbd0903b2b8d644c2532b12858e569decfda630d36)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
-        return typing.cast(ITransitGatewayAttachment, jsii.sinvoke(cls, "fromTransitGatewayAttachmentId", [scope, id, transit_gateway_attachment_id]))
+        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayAttachment:
-        '''The underlying NamedQuery CloudFormation resource.
+    @jsii.member(jsii_name="job")
+    def job(self) -> IJob:
+        '''The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
 
-        :see: `AWS::EC2::TransitGatewayVpcAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html>`_
-        :group: Resources
+        :see: `Trigger Predicate.Conditions.JobName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-jobname>`_
+        :group: Inputs
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayAttachment, jsii.get(self, "resource"))
+        return typing.cast(IJob, jsii.get(self, "job"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentArn")
-    def transit_gateway_attachment_arn(self) -> builtins.str:
-        '''The ARN of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+    @jsii.member(jsii_name="logicalOperator")
+    def logical_operator(self) -> PredicateLogicalOperator:
+        '''The logical operator which should be applied in determining whether a job meets the requested conditions.
+
+        At the moment, the only supported operator is ``EQUALS``.
+
+        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
+        :group: Inputs
+        '''
+        return typing.cast(PredicateLogicalOperator, jsii.get(self, "logicalOperator"))
 
     @builtins.property
-    @jsii.member(jsii_name="transitGatewayAttachmentId")
-    def transit_gateway_attachment_id(self) -> builtins.str:
-        '''The ID of this Transit Gateway Attachment.'''
-        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
+    @jsii.member(jsii_name="state")
+    def state(self) -> JobState:
+        '''The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+
+        :see: `Trigger Predicate.Conditions.State <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-state>`_
+        :group: Inputs
+        '''
+        return typing.cast(JobState, jsii.get(self, "state"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentProps",
-    jsii_struct_bases=[TransitGatewayAttachmentResourceProps],
+    jsii_type="cdk-extensions.glue.WorkflowJobPredicateOptions",
+    jsii_struct_bases=[WorkflowPredicateOptions],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "transit_gateway": "transitGateway",
-        "vpc": "vpc",
-        "appliance_mode_support": "applianceModeSupport",
-        "dns_support": "dnsSupport",
-        "ipv6_support": "ipv6Support",
-        "name": "name",
-        "subnets": "subnets",
+        "logical_operator": "logicalOperator",
+        "state": "state",
     },
 )
-class TransitGatewayAttachmentProps(TransitGatewayAttachmentResourceProps):
+class WorkflowJobPredicateOptions(WorkflowPredicateOptions):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        transit_gateway: ITransitGateway,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        appliance_mode_support: typing.Optional[builtins.bool] = None,
-        dns_support: typing.Optional[builtins.bool] = None,
-        ipv6_support: typing.Optional[builtins.bool] = None,
-        name: typing.Optional[builtins.str] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+        state: typing.Optional[JobState] = None,
     ) -> None:
-        '''Configuration for TransitGatewayAttachment resource.
+        '''Configuration options that specify the state a job must meet in order to satisfy the conditions of the predicate.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param transit_gateway: The transit gateway for which the attachment should be created.
-        :param vpc: The VPC where the attachment should be created.
-        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
-        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
-        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
-        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
+        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
+        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
         '''
-        if isinstance(subnets, dict):
-            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4d1defbd3f98b5d681f7a4e30d69288e6cdc5223fef0fed304547c78510a96e2)
+            type_hints = typing.get_type_hints(_typecheckingstub__72482740085b262df0b54ed41b3b29c654ded6f27c0575af036d20ebf4fff046)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
-            check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
-            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
-            check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "transit_gateway": transit_gateway,
-            "vpc": vpc,
-        }
+            check_type(argname="argument logical_operator", value=logical_operator, expected_type=type_hints["logical_operator"])
+            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if appliance_mode_support is not None:
-            self._values["appliance_mode_support"] = appliance_mode_support
-        if dns_support is not None:
-            self._values["dns_support"] = dns_support
-        if ipv6_support is not None:
-            self._values["ipv6_support"] = ipv6_support
-        if name is not None:
-            self._values["name"] = name
-        if subnets is not None:
-            self._values["subnets"] = subnets
+        if logical_operator is not None:
+            self._values["logical_operator"] = logical_operator
+        if state is not None:
+            self._values["state"] = state
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -6369,925 +8791,1274 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def transit_gateway(self) -> ITransitGateway:
-        '''The transit gateway for which the attachment should be created.
+    def logical_operator(self) -> typing.Optional[PredicateLogicalOperator]:
+        '''The logical operator which should be applied in determining whether a job meets the requested conditions.
 
-        :see: `TransitGatewayVpcAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid>`_
-        '''
-        result = self._values.get("transit_gateway")
-        assert result is not None, "Required property 'transit_gateway' is missing"
-        return typing.cast(ITransitGateway, result)
+        At the moment, the only supported operator is ``EQUALS``.
 
-    @builtins.property
-    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
-        '''The VPC where the attachment should be created.
-
-        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
+        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
         '''
-        result = self._values.get("vpc")
-        assert result is not None, "Required property 'vpc' is missing"
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
+        result = self._values.get("logical_operator")
+        return typing.cast(typing.Optional[PredicateLogicalOperator], result)
 
     @builtins.property
-    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables appliance mode on the attachment.
+    def state(self) -> typing.Optional[JobState]:
+        '''The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
 
-        When appliance mode is enabled, all traffic flowing between attachments is
-        forwarded to an appliance in a shared VPC to be inspected and processed.
-
-        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
+        :see: `Trigger Predicate.Conditions.State <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-state>`_
         '''
-        result = self._values.get("appliance_mode_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def dns_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
-
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
-
-        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
-        '''
-        result = self._values.get("dns_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def ipv6_support(self) -> typing.Optional[builtins.bool]:
-        '''Enables DNS support for the attachment.
-
-        With DNS Support enabled public DNS names that resolve to a connected VPC
-        will be translated to private IP addresses when resolved in a connected VPC.
-
-        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
-        '''
-        result = self._values.get("ipv6_support")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Transit Gateway Attachment.
-
-        Used to tag the attachment with a name that will be displayed in the AWS
-        EC2 console.
-
-        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''The subnets where the attachment should be created.
-
-        Can select up to one subnet per Availability Zone.
-
-        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
-        '''
-        result = self._values.get("subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
+        result = self._values.get("state")
+        return typing.cast(typing.Optional[JobState], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TransitGatewayAttachmentProps(%s)" % ", ".join(
+        return "WorkflowJobPredicateOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 __all__ = [
-    "CustomerGateway",
-    "CustomerGatewayAttributes",
-    "CustomerGatewayConfigurationRemoteVpnEndpoint",
-    "CustomerGatewayProps",
-    "CustomerGatewayRemoteVpnEndpoint",
-    "FlowLog",
-    "FlowLogDataType",
-    "FlowLogDestination",
-    "FlowLogDestinationConfig",
-    "FlowLogField",
-    "FlowLogFileFormat",
-    "FlowLogFormat",
-    "FlowLogProps",
-    "FlowLogS3Options",
-    "ICustomerGateway",
-    "ILocalVpnEndpoint",
-    "ILogDestination",
-    "IRemoteVpnEndpoint",
-    "ITransitGateway",
-    "ITransitGatewayAttachment",
-    "ITransitGatewayPeeringAttachment",
-    "ITransitGatewayRoute",
-    "ITransitGatewayRouteTable",
-    "LocalVpnEndpointConfiguration",
-    "NatProvider",
-    "RemoteVpnEndpointConfiguration",
-    "SharingOptions",
-    "TieredSubnets",
-    "TieredSubnetsOptions",
-    "TransitGateway",
-    "TransitGatewayAttachment",
-    "TransitGatewayAttachmentBase",
-    "TransitGatewayAttachmentProps",
-    "TransitGatewayAttachmentResource",
-    "TransitGatewayAttachmentResourceProps",
-    "TransitGatewayLocalVpnEndpoint",
-    "TransitGatewayNatProvider",
-    "TransitGatewayNatProviderOptions",
-    "TransitGatewayPeeringAttachment",
-    "TransitGatewayPeeringAttachmentImportAttributes",
-    "TransitGatewayPeeringAttachmentOptions",
-    "TransitGatewayPeeringAttachmentProps",
-    "TransitGatewayProps",
-    "TransitGatewayRoute",
-    "TransitGatewayRouteOptions",
-    "TransitGatewayRouteProps",
-    "TransitGatewayRouteTable",
-    "TransitGatewayRouteTableOptions",
-    "TransitGatewayRouteTableProps",
-    "TunnelOptions",
-    "VpcAttachmentOptions",
-    "VpnAttachmentOptions",
-    "VpnConnection",
-    "VpnConnectionLocalEndpoint",
-    "VpnConnectionProps",
-    "VpnConnectionRemoteEndpoint",
-    "VpnConnectionType",
-    "VpnGatewayLocalVpnEndpoint",
+    "ArrayColumn",
+    "ArrayColumnProps",
+    "AssetCode",
+    "BasicColumn",
+    "BasicColumnProps",
+    "BookmarkConfiguration",
+    "BookmarkRange",
+    "ClassificationString",
+    "CloudWatchEncryption",
+    "CloudWatchEncryptionMode",
+    "Code",
+    "CodeConfig",
+    "Column",
+    "ColumnProps",
+    "ConfigurationVersion",
+    "Connection",
+    "ConnectionProps",
+    "ConnectionType",
+    "ContinuousLoggingProps",
+    "Crawler",
+    "CrawlerConfiguration",
+    "CrawlerProps",
+    "CrawlerState",
+    "CrawlerTargetCollection",
+    "DataFormat",
+    "DataFormatProps",
+    "Database",
+    "DatabaseProps",
+    "DeleteBehavior",
+    "GlueVersion",
+    "ICrawler",
+    "ICrawlerTarget",
+    "IJob",
+    "ITrigger",
+    "ITriggerAction",
+    "ITriggerPredicate",
+    "InputFormat",
+    "JdbcConnection",
+    "JdbcConnectionProps",
+    "JdbcTarget",
+    "JdbcTargetOptions",
+    "Job",
+    "JobBookmarksEncryption",
+    "JobBookmarksEncryptionMode",
+    "JobExecutable",
+    "JobExecutableConfig",
+    "JobLanguage",
+    "JobProps",
+    "JobState",
+    "JobType",
+    "OutputFormat",
+    "PartitionUpdateBehavior",
+    "PredicateLogicalOperator",
+    "PredicateOperator",
+    "PythonShellExecutableProps",
+    "PythonSparkJobExecutableProps",
+    "PythonVersion",
+    "RecrawlBehavior",
+    "S3Code",
+    "S3Encryption",
+    "S3EncryptionMode",
+    "S3Target",
+    "S3TargetOptions",
+    "ScalaJobExecutableProps",
+    "SecurityConfiguration",
+    "SecurityConfigurationProps",
+    "SerializationLibrary",
+    "StructColumn",
+    "StructColumnProps",
+    "Table",
+    "TableGroupingPolicy",
+    "TableProps",
+    "TableType",
+    "TableUpdateBehavior",
+    "Trigger",
+    "TriggerOptions",
+    "TriggerProps",
+    "TriggerType",
+    "UpdateBehavior",
+    "WorkerType",
+    "Workflow",
+    "WorkflowAction",
+    "WorkflowActionBase",
+    "WorkflowActionOptions",
+    "WorkflowCrawlerAction",
+    "WorkflowCrawlerActionOptions",
+    "WorkflowCrawlerPredicate",
+    "WorkflowCrawlerPredicateOptions",
+    "WorkflowJobAction",
+    "WorkflowJobActionOptions",
+    "WorkflowJobPredicate",
+    "WorkflowJobPredicateOptions",
+    "WorkflowPredicate",
+    "WorkflowPredicateBase",
+    "WorkflowPredicateOptions",
+    "WorkflowProps",
 ]
 
 publication.publish()
 
-def _typecheckingstub__35eab003d889c662b910b407f8e02c5f1e0c594802680266f3389251bf5ac9d3(
+def _typecheckingstub__b04343485dce8549add35ec976d45544630deb5d79090df76b4018e3f8074592(
+    value: builtins.str,
+    *,
+    from_: builtins.str,
+    to: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2301b86dad3c792d837e86052ee0890dc5b59ce6914adc7fa3fd599e7ab75ccd(
+    *,
+    from_: builtins.str,
+    to: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0751f5d6215bb74e22139fe2149a7f9ee7de61eb00daa8638767d444fd2006ff(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__057163656b87fc4eb457b7ce6af51ebca528e50d7d1d66f6c8cb0392e039ac1a(
     *,
-    customer_gateway_id: builtins.str,
-    bgp_asn: typing.Optional[jsii.Number] = None,
-    ip_address: typing.Optional[builtins.str] = None,
+    mode: CloudWatchEncryptionMode,
+    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e250ab0ff20773956eb3b2131200a7ee56b455ba85d22729b69f588d369a8193(
+def _typecheckingstub__fe5f72a2d529dee4e5a4fd60ab73c3651fdb154cc1ac378fcf8a4c6cc14f7f47(
+    path: builtins.str,
     *,
+    asset_hash: typing.Optional[builtins.str] = None,
+    asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
+    bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0ae28ae94ca6a7f468c50a4d7ca53e509947843d875b01df05b54a3d3035fe76(
+    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__29827b2153002e81b9ff9677022a59a77e67b7c0083100827663e2e422bda0db(
+    scope: _constructs_77d1e7e8.Construct,
+    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f929a25191cf84849ac8dc0774c3d7cb58e7913b1ffa7fc2fbca5cb55667291c(
+    *,
+    s3_location: typing.Union[_aws_cdk_aws_s3_ceddda9d.Location, typing.Dict[builtins.str, typing.Any]],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__444e4405d6fa32714b3fa80c1a990dc679108d516ba2f551601636ba37108c5e(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2acc8cf451159a8d67a7210893d3fff8ebd56626ab3a55b71a5a7d60b58fa6f2(
+    *,
+    comment: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__023b7dc3d20f72ca57c6c81f464fce932d96d952762ad3a3710109c3be2e676c(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    connection_type: ConnectionType,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    ip_address: builtins.str,
-    bgp_asn: typing.Optional[jsii.Number] = None,
-    connection_type: typing.Optional[VpnConnectionType] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__685f60b23d7e8e561b55bc9dca121799b9d63919b8e78b372a1fa549c234455e(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
+def _typecheckingstub__a45f2c7f57ece25b2ed1a81fd7f6d3d5c0fe1afcbef8310db8d03a698c138480(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1eee3a4bfe7ee7514d7510a9f817a30f05617f0049f9d10ada9cc135e1b8ab26(
+    key: builtins.str,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0af32a3c84c0678710e524ede720205f2f84097eea14da00eb58b5d5f043557b(
     *,
-    resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
-    destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
-    flow_log_name: typing.Optional[builtins.str] = None,
-    log_format: typing.Optional[FlowLogFormat] = None,
-    max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
-    traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    connection_type: ConnectionType,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__11b243acaaaa5840cda314f12b7b4d009805f9002ef9847296dedc4c734cfaa8(
+def _typecheckingstub__c8560efd79afaf7b7778442a94c024de5f4c8f79564e4c191018f7871c34b5e6(
     *,
-    destination_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType,
-    bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
-    destination_options: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
+    enabled: builtins.bool,
+    conversion_pattern: typing.Optional[builtins.str] = None,
     log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    s3_path: typing.Optional[builtins.str] = None,
+    log_stream_prefix: typing.Optional[builtins.str] = None,
+    quiet: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__52a7eb2a067a774b7223df31becb41f1517c9aa30eb3b326b26ad7504939a991(
-    name: builtins.str,
-    type: FlowLogDataType,
+def _typecheckingstub__51a7512576b1965463466002ce33610505de95eb6d8629c5243e563c30f4f20f(
+    *,
+    partition_update_behavior: typing.Optional[PartitionUpdateBehavior] = None,
+    table_grouping_policy: typing.Optional[TableGroupingPolicy] = None,
+    table_level: typing.Optional[jsii.Number] = None,
+    table_update_behavior: typing.Optional[TableUpdateBehavior] = None,
+    version: typing.Optional[ConfigurationVersion] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__186041c191f59ab5a16d388d89fb358a9ce5c7c993bd90eb9e6479e368341acd(
-    name: builtins.str,
+def _typecheckingstub__2280b17fb14a2d4a9a875511f4dcee118bd04236b81ae5e543e8502074f74f5c(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
+    configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
+    database: typing.Optional[Database] = None,
+    delete_behavior: typing.Optional[DeleteBehavior] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
+    schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    security_configuration: typing.Optional[SecurityConfiguration] = None,
+    table_prefix: typing.Optional[builtins.str] = None,
+    targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
+    update_behavior: typing.Optional[UpdateBehavior] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__011095d32393e36e81237f11a84f5543e965a7ff361a20975a530a17197f4a8e(
-    *fields: FlowLogField,
+def _typecheckingstub__a8896893a8fc4935daa0226b1e3669e65b536c6438cba018169f71f1a6aed7e3(
+    *,
+    catalog_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+    dynamo_db_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+    jdbc_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+    s3_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5cb1f7019aee739ea8276bab9a93a7e6f40b4ebf40d15497239b2c6b1676033e(
-    template: builtins.str,
+def _typecheckingstub__dbf6d8049cc8299102bda3d0f4fcaafe4f62969715f5334320a23b3330bfc2e5(
+    *,
+    input_format: InputFormat,
+    output_format: OutputFormat,
+    serialization_library: SerializationLibrary,
+    classification_string: typing.Optional[ClassificationString] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__79cf487bf8fa03e8840d7c2097f578bf3849b50872d93bdad4cc33d93380f5cd(
-    field: FlowLogField,
+def _typecheckingstub__45c3b158089c46e13d9c49f0ca36070229ef0a94859ba845783419cef5407fba(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    description: typing.Optional[builtins.str] = None,
+    location_uri: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ab60db00df2ad42cfdeb4bac9052956c6ceecbdc94e94e83e7a5b1a8d4db724f(
+def _typecheckingstub__0d611ab4143e7ce164987eed2bc3acb7d2232995b6cb14a3be53384f6c67d983(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
-    destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
-    flow_log_name: typing.Optional[builtins.str] = None,
-    log_format: typing.Optional[FlowLogFormat] = None,
-    max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
-    traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
+    description: typing.Optional[builtins.str] = None,
+    location_uri: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7e005d34fc5ab0b60e83479b723ba4e2e86a135e05fd16b18daaac30743245ed(
-    *,
-    file_format: typing.Optional[FlowLogFileFormat] = None,
-    hive_compatible_partitions: typing.Optional[builtins.bool] = None,
-    key_prefix: typing.Optional[builtins.str] = None,
-    per_hour_partition: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__afef4db7c413ec6c4abe2a7c38e51c3df056fd2eba5fcd9b37a75a1490334595(
+    version: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5f7fbf7fd0e305a60cc72790e4c2e467542eeb749b6ca114948036c7e283f4e3(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__dd0bd4dee65916002df8546350cf43116d55f03d0052a252943557ca270bb18b(
+    crawler: Crawler,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__31e7dac1ec2cefa56a83155a4b3ff82206bfe5b1607d5af572c5d16cf98aba7a(
+def _typecheckingstub__ee93cfcd69490826c39480651b7eb34877d0667604b0e14daf995218173ee126(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f1c8cc16017de426ad6eb532d21e5db4c058f7a279485763c47026f54ff6b02a(
+def _typecheckingstub__2c73437c9e4d3b35bea065e54ce75f4a15077ddc17412786ea8a173cc1fadd1c(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3c530d4e033cb58d409cbdec91a29a99e796c6b5949a8fe0b776e9a57ebda677(
+def _typecheckingstub__f47e29abee492d68598cef1aaeaafad27d809225eb3fede0aba56962510025d0(
+    class_name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ea4b4cdb8cc43abef69d5aa672a86888b62abf53d134ac73a8ae113ee5f35600(
+    scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    remote_endpoint: IRemoteVpnEndpoint,
-    connection_type: typing.Optional[VpnConnectionType] = None,
-    static_routes_only: typing.Optional[builtins.bool] = None,
-    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    password: _aws_cdk_ceddda9d.SecretValue,
+    url: builtins.str,
+    username: builtins.str,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    description: typing.Optional[builtins.str] = None,
+    enforce_ssl: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7e51602274287d74df7ba0b1c9462a003ef4081742f553f9fccc7d78f9e0f591(
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+def _typecheckingstub__63235443ef95630aeef4ec6db0d062a07b1671eb3853e7158c18ed47070ed58a(
     *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    password: _aws_cdk_ceddda9d.SecretValue,
+    url: builtins.str,
+    username: builtins.str,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    description: typing.Optional[builtins.str] = None,
+    enforce_ssl: typing.Optional[builtins.bool] = None,
     name: typing.Optional[builtins.str] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
     subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7b44f941842017d2d4c6c21860f08701108fc8a70636475b6b9ab6eb37332692(
-    cidr: builtins.str,
-    route_table: ITransitGatewayRouteTable,
+def _typecheckingstub__a5d7f10fe829e301eed5ff500477960d3c29565777d9d18780f32c7d84b383d7(
+    connection: Connection,
+    *,
+    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    paths: typing.Optional[typing.Sequence[builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c283c95ccb48c40fb03d7fffd4f63ce7927ef657d47052d65ed9aa32cbd6609a(
-    *,
-    transit_gateway_id: typing.Optional[builtins.str] = None,
-    vpn_gateway_id: typing.Optional[builtins.str] = None,
+def _typecheckingstub__da7fc3d4ccd69b3e6ec79ea8dc2f9c31784d1adaa1616006b1c552d243329288(
+    exclusion: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8914f39fbdc8cc3e17d3f0de803ae8f59bb0822173529944b495b0fe17106662(
-    *,
-    customer_gateway_asn: jsii.Number,
-    customer_gateway_id: builtins.str,
-    customer_gateway_ip: builtins.str,
+def _typecheckingstub__92e89a811419b69c0f51822e3f45ff0bdd0ce6940b3afb1a59f04b14e85deab7(
+    path: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5d7430c10280f3e429f967b91e374da316928ba959b852656888cb4465f871ab(
-    *,
-    allow_external_principals: typing.Optional[builtins.bool] = None,
-    auto_discover_accounts: typing.Optional[builtins.bool] = None,
-    principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
+def _typecheckingstub__519dc5422365574c38b31da5db0adb61aaeabbe542682317cab78a331d1d6b96(
+    _crawler: Crawler,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c8e89adfc6dfc2ac55a0bed117d1dc5d9b5bc0bcf75bb19367a28bd1c914be4e(
-    options: TieredSubnetsOptions,
+def _typecheckingstub__b92268978767ce15062df3f1f0b702e354d0abf8d764ee0dbedb1952ccd5b8f7(
+    *,
+    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    paths: typing.Optional[typing.Sequence[builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__66b0aca7557ca99e67ff904b7cb9edf704abd3cf24b45ecad18d9ccffdb7fcdc(
+def _typecheckingstub__dfd3e838082701af10fa1c63f23e3acc6bf12935d1a61850f26bc4a6088bfcd6(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    amazon_side_asn: typing.Optional[jsii.Number] = None,
-    auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
-    cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
-    default_route_table_association: typing.Optional[builtins.bool] = None,
-    default_route_table_id: typing.Optional[builtins.str] = None,
-    default_route_table_propagation: typing.Optional[builtins.bool] = None,
+    executable: JobExecutable,
+    allocated_capacity: typing.Optional[jsii.Number] = None,
+    connections: typing.Optional[typing.Sequence[Connection]] = None,
+    continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+    default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
     description: typing.Optional[builtins.str] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    multicast_support: typing.Optional[builtins.bool] = None,
+    enable_profiling_metrics: typing.Optional[builtins.bool] = None,
+    max_capacity: typing.Optional[jsii.Number] = None,
+    max_concurrent_runs: typing.Optional[jsii.Number] = None,
+    max_retries: typing.Optional[jsii.Number] = None,
     name: typing.Optional[builtins.str] = None,
-    vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    security_configuration: typing.Optional[SecurityConfiguration] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    worker_count: typing.Optional[jsii.Number] = None,
+    worker_type: typing.Optional[WorkerType] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__46c3cc263035d23bc511197c75afb01d4a672fd46f5af176fbea6a400bccd00b(
+def _typecheckingstub__6ad00a49f903b8ff296c1040af14b52c5c710377bccb726a03b7db29113abd37(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    transit_gateway_id: builtins.str,
+    job_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2efd1666acd64cb987a354787ffd07add5920ed5de7e64ad3a01aa00619b7310(
-    cidr: builtins.str,
+def _typecheckingstub__4b9945957a7dfb3942132fbf1eea0248c28d8f65d0f02d1af6fdcecafa689b66(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    job_name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9989ffc3141ccddce9a6e8246aa4b31bd76f3ad0a11bbc1cbee86d607e50200d(
-    id: builtins.str,
-    *,
-    remote_endpoint: IRemoteVpnEndpoint,
-    connection_type: typing.Optional[VpnConnectionType] = None,
-    static_routes_only: typing.Optional[builtins.bool] = None,
-    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+def _typecheckingstub__35613a54fa94475a1d6f92b6c0df6312b31ea05071004c65f6f6d6c38b3540b2(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3fca635a725c4277e8db84123074663ecf20e88af86d11cb8f03c6390d8b7bc8(
-    peer: ITransitGateway,
+def _typecheckingstub__9d6f7c32eed0df35efff9f38d209a916c1ac797af98a30c7d4b12c9945e72399(
+    connection: Connection,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__de865e59b5a9d704335fa3900bcc2d054fc4bd594443f79fb978f7aecce4d7a2(
     *,
-    name: typing.Optional[builtins.str] = None,
-    peer_account_id: typing.Optional[builtins.str] = None,
-    peer_region: typing.Optional[builtins.str] = None,
+    mode: JobBookmarksEncryptionMode,
+    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ac3f5d6f3de4328a56c1673d48d7168afe72b9b6c52725fb46ee3d5121211524(
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+def _typecheckingstub__af760e5b293fa34ac6b256f1e0f627632acc4c0dd5000a33d11b6c7858e250ec(
     *,
-    name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    glue_version: GlueVersion,
+    language: JobLanguage,
+    script: Code,
+    type: JobType,
+    class_name: typing.Optional[builtins.str] = None,
+    extra_files: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars_first: typing.Optional[builtins.bool] = None,
+    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+    python_version: typing.Optional[PythonVersion] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b49d47ed81c7ffb2a1650ef26c6a7262dbfbe5b02d6a33f4521aaba40facd96b(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__1a4f1e1b4bab338b9f8725cb2a2bdc60103a0fa9e50e731a94e0a34914c85e6e(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    executable: JobExecutable,
+    allocated_capacity: typing.Optional[jsii.Number] = None,
+    connections: typing.Optional[typing.Sequence[Connection]] = None,
+    continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+    default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    description: typing.Optional[builtins.str] = None,
+    enable_profiling_metrics: typing.Optional[builtins.bool] = None,
+    max_capacity: typing.Optional[jsii.Number] = None,
+    max_concurrent_runs: typing.Optional[jsii.Number] = None,
+    max_retries: typing.Optional[jsii.Number] = None,
+    name: typing.Optional[builtins.str] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    security_configuration: typing.Optional[SecurityConfiguration] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    worker_count: typing.Optional[jsii.Number] = None,
+    worker_type: typing.Optional[WorkerType] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2bde216e427f277dd4ae0752c5cd28002b668b82f2864e2962977e5314f9ec83(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7922f5b0f22bd94cc964cabe57f17f7d870707d5d26e8c51a8683ee4a13f69f2(
+    class_name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0770316fdacec7ca35ca6177329d14996aea7b6acb0fd95618ead49ef0b5ad06(
+    *,
+    glue_version: GlueVersion,
+    python_version: PythonVersion,
+    script: Code,
+    extra_files: typing.Optional[typing.Sequence[Code]] = None,
+    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__abf13ee589f12cebe2bcd432fdc04c1c56ddab0d41ec2223ea1e51e77d10b532(
+    *,
+    glue_version: GlueVersion,
+    python_version: PythonVersion,
+    script: Code,
+    extra_files: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars_first: typing.Optional[builtins.bool] = None,
+    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__de8f54c722e452ed2da0b9a8775cdf6f8a22de4bab55c4b0f779954c84a2b2e6(
+    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__07939ad3e69a9dd6cae1fdc4f6dec96a067b631307222f1d771e21ef5b555288(
+    _scope: _constructs_77d1e7e8.Construct,
+    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__34af5cf7f823d326ebb18b6676a7f173278a47afe08c3b06bf179d11c994e2f8(
+    *,
+    mode: S3EncryptionMode,
+    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__fcaa86377de60481d78b8e386ba15f4ae63207cee2ee1e03d6a84890c5303f9f(
+    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+    *,
+    connection: typing.Optional[Connection] = None,
+    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    key_prefix: typing.Optional[builtins.str] = None,
+    sample_size: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3c4b8aae9fc7113caa263f0a78c3a90cd7457571433a27e89da36b0ae99fc4c6(
-    cidr: builtins.str,
-    route_table: ITransitGatewayRouteTable,
+def _typecheckingstub__78064b8f21836a6ba333208adc1772c480fd7d08c026c1f0523ba1b519e1ec92(
+    exclusion: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__06c53aa420590eceea4fb9b075681a4977d93106ad928386f59f565ada883d5b(
+def _typecheckingstub__b1ac6ccbc65917f26861da97319cead930d0dbf8fcf49a83e9e71e57ccef2986(
+    crawler: Crawler,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__adead1dc5fcd2fa7014bdfa551e765a45e7e34612c1c8ffd300d3b8edefe00b4(
+    *,
+    connection: typing.Optional[Connection] = None,
+    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    key_prefix: typing.Optional[builtins.str] = None,
+    sample_size: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5a58d9a628f0769075f9be892e1815f81d167b0a10411ee63316264981cf0120(
+    *,
+    class_name: builtins.str,
+    glue_version: GlueVersion,
+    script: Code,
+    extra_files: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
+    extra_jars_first: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8bb80a9d0f83fcd376c282d063d76d6be646365fd7ea4850397fc1cf26b72038(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    transit_gateway: ITransitGateway,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    appliance_mode_support: typing.Optional[builtins.bool] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    ipv6_support: typing.Optional[builtins.bool] = None,
+    cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
     name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d27a4bece3fbfe787de85bd302d080942572f3712552688c636b696a9d85fa70(
+    *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    name: typing.Optional[builtins.str] = None,
+    s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5be42ef34b8183a16c487d39be9e50f07bb069442ea235835d889d6c915c0fd9(
+    class_name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d9616ce11448deda7c7f7a6abcc3dc7343fd9d23bf7197f988d750a4ed8ab7b9(
-    val: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__f6397af3f7e2865b94205ae66351b5049b1e24eddfccbee733dc294c875d1e29(
+    column: Column,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3d1c15189bbc90871ac0f1cb7928d7a06dc7a543bed65a3917a78189021d8767(
+def _typecheckingstub__be752f0e2780faa753092d75b32484d8113fe2d5f788daa3dfd242fa215de246(
     *,
+    comment: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    data: typing.Optional[typing.Sequence[Column]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2eec6dbec86f7128ae48e38b1289cfeaade58e92058db1f726cfe7935a152444(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    database: Database,
+    columns: typing.Optional[typing.Sequence[Column]] = None,
+    compressed: typing.Optional[builtins.bool] = None,
+    data_format: typing.Optional[DataFormat] = None,
+    description: typing.Optional[builtins.str] = None,
+    location: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    owner: typing.Optional[builtins.str] = None,
+    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    partition_keys: typing.Optional[typing.Sequence[Column]] = None,
+    retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    serde_name: typing.Optional[builtins.str] = None,
+    serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    stored_as_sub_directories: typing.Optional[builtins.bool] = None,
+    table_type: typing.Optional[TableType] = None,
+    target_table: typing.Optional[Table] = None,
+    view_expanded_text: typing.Optional[builtins.str] = None,
+    view_original_text: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    transit_gateway: ITransitGateway,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    appliance_mode_support: typing.Optional[builtins.bool] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    ipv6_support: typing.Optional[builtins.bool] = None,
-    name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__085d2039b0a4b4caf19e1943608efeb5e97be1be7d732ad9e6c87845449f8c0e(
-    transit_gateway: ITransitGateway,
+def _typecheckingstub__7e19c0d356c0722d5d2e88f68d65807d5bf7af6ed343ef572db7c40d331591b4(
+    column: Column,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1649477704b8d5959bab11d00a58a0814e904ca0755f79fc92c902b7548831e8(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__32c8dcc447fc94c914aa9117344531cb4adafbbd95e95f5e533aa4ec40ff0b07(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2ce5b6c12f42e572c0fd8116f08202bd45321782d0dface0d78758e8ae4afce0(
-    subnet: _aws_cdk_aws_ec2_ceddda9d.PrivateSubnet,
+def _typecheckingstub__45a820867b3372f968d0356f688bd57f2fabd57b9a6f1d007bfef4a653dc0d7d(
+    column: Column,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3d866260e3cfdb20c411a4b77ce2ef5ed9046a68ea0356988681824395af2b48(
-    *,
-    transit_gateway: ITransitGateway,
+def _typecheckingstub__f39ac55f4ec3d384f9e5cb679d42b04bee73ebfeeb4e4ef12d7f135353860879(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__094bd3c738b0a006e2a59600942e6cb57ce41b066d2acabef2f32729f9b6c14c(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__dbe94e982d260f87bd2f2b4bdd58ff506d9e25d5fad5f73ce4d04443585752c0(
+    key: builtins.str,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c47a2c9840f823b7524821e05bdf6ea2222940a7cf7b637b2dae2f91266503ee(
     *,
-    local_transit_gateway: ITransitGateway,
-    peer_transit_gateway: ITransitGateway,
-    name: typing.Optional[builtins.str] = None,
-    peer_account_id: typing.Optional[builtins.str] = None,
-    peer_region: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    database: Database,
+    columns: typing.Optional[typing.Sequence[Column]] = None,
+    compressed: typing.Optional[builtins.bool] = None,
+    data_format: typing.Optional[DataFormat] = None,
+    description: typing.Optional[builtins.str] = None,
+    location: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    owner: typing.Optional[builtins.str] = None,
+    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    partition_keys: typing.Optional[typing.Sequence[Column]] = None,
+    retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    serde_name: typing.Optional[builtins.str] = None,
+    serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    stored_as_sub_directories: typing.Optional[builtins.bool] = None,
+    table_type: typing.Optional[TableType] = None,
+    target_table: typing.Optional[Table] = None,
+    view_expanded_text: typing.Optional[builtins.str] = None,
+    view_original_text: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d64bc0ce43e9c832901d2f4073f54276e12b588a41c623026825482bf1d43c63(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__9a79049a428bd5941424b4e094c84a859a725f32c171d87ac2126a1685ef641f(
+    scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
-    arn: builtins.str,
+    *,
+    type: TriggerType,
+    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+    predicate_operator: typing.Optional[PredicateOperator] = None,
+    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    start_on_creation: typing.Optional[builtins.bool] = None,
+    workflow: typing.Optional[Workflow] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9b9ddfaf131e6a5091a636a0dad2dd2579ae4140b68c99fe5fee2e2506d45105(
+def _typecheckingstub__d29de485fa07fbea64e912490718223776c3ab360b719de644012a94fb6434f7(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    *,
-    arn: typing.Optional[builtins.str] = None,
-    attachment_id: typing.Optional[builtins.str] = None,
-    creation_time: typing.Optional[builtins.str] = None,
-    state: typing.Optional[builtins.str] = None,
-    status: typing.Optional[builtins.str] = None,
-    status_code: typing.Optional[builtins.str] = None,
-    status_message: typing.Optional[builtins.str] = None,
+    trigger_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__fe35553be2f81ae71d207839c426c22b6542d57d2604a744dec33a748b8631f6(
+def _typecheckingstub__f3434fb8f553f52f60a3e025608013104918640090d3d63398c7aa99c372b20d(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    attachment_id: builtins.str,
+    trigger_name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__17eab9c1c0483a81bcbc3cfb19dfc9cd1902962956a39306a77b2b041a6f2182(
-    *,
-    arn: typing.Optional[builtins.str] = None,
-    attachment_id: typing.Optional[builtins.str] = None,
-    creation_time: typing.Optional[builtins.str] = None,
-    state: typing.Optional[builtins.str] = None,
-    status: typing.Optional[builtins.str] = None,
-    status_code: typing.Optional[builtins.str] = None,
-    status_message: typing.Optional[builtins.str] = None,
+def _typecheckingstub__bc007dfc129810a05403a45fc2edb04eac2ac69328ffffbe932ae17113d5f057(
+    action: ITriggerAction,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__25aee8c8ebebcfa519a0f5706458a5669157c84f5af528e93a86402ac7c50aae(
-    *,
-    name: typing.Optional[builtins.str] = None,
-    peer_account_id: typing.Optional[builtins.str] = None,
-    peer_region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__2b67da5af6c648e853764f371b481f132349181516847a12a28a673bc51a3fe4(
+    predicate: ITriggerPredicate,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1b477916bc8b985cd2d6731bf57489e1a7c94f20fccf7711617cdf0d1bd25beb(
+def _typecheckingstub__01145ca757e10f8e94b4c175dd3a267a5df9030339f6e4feb49750e5ff03ac64(
     *,
-    name: typing.Optional[builtins.str] = None,
-    peer_account_id: typing.Optional[builtins.str] = None,
-    peer_region: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    local_transit_gateway: ITransitGateway,
-    peer_transit_gateway: ITransitGateway,
+    type: TriggerType,
+    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+    predicate_operator: typing.Optional[PredicateOperator] = None,
+    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    start_on_creation: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__34be88b6da81fce37f3376e8b1fd1aff7e222c4b2fb4ab8e879c634868d58a81(
+def _typecheckingstub__ad020c3099533ac828ee3b7bc94f977e7beb54ccf917b0d37f088b52a7110039(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    amazon_side_asn: typing.Optional[jsii.Number] = None,
-    auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
-    cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
-    default_route_table_association: typing.Optional[builtins.bool] = None,
-    default_route_table_id: typing.Optional[builtins.str] = None,
-    default_route_table_propagation: typing.Optional[builtins.bool] = None,
+    type: TriggerType,
+    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
     description: typing.Optional[builtins.str] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    multicast_support: typing.Optional[builtins.bool] = None,
     name: typing.Optional[builtins.str] = None,
-    vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+    predicate_operator: typing.Optional[PredicateOperator] = None,
+    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    start_on_creation: typing.Optional[builtins.bool] = None,
+    workflow: typing.Optional[Workflow] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__472f0a715c24828891d913514782594fd48e540d0192f96901c525a6f2c9845f(
+def _typecheckingstub__4a01940e29d3d0fd83d19b9c7547e8ccfdc7c8f60414ad61defd54707cde2f02(
+    worker_type: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__30858062db0892690086e05db3017264c21574c51cfe419ae83dc373da11b661(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    cidr: builtins.str,
-    route_table: ITransitGatewayRouteTable,
-    attachment: typing.Optional[ITransitGatewayAttachment] = None,
-    blackhole: typing.Optional[builtins.bool] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e915393403cdd527b11e940ce216647c74d6e6b709f726e821e12fa1b470873d(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__ce55118dcfd5ce84c7d138d41de38e7579d11282f1f109403fe376a28709ebf9(
     id: builtins.str,
-    transit_gateway_route_id: builtins.str,
+    *,
+    type: TriggerType,
+    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
+    predicate_operator: typing.Optional[PredicateOperator] = None,
+    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    start_on_creation: typing.Optional[builtins.bool] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__eac305487ec828686fdbbd312914a754c55ca742068c194f48ac724cf9aef071(
+def _typecheckingstub__1e1780b54c3d5134781210aa5dcce6cc5585326dcffdae0be9004a975c463191(
+    crawler: ICrawler,
     *,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cidr: builtins.str,
-    attachment: typing.Optional[ITransitGatewayAttachment] = None,
-    blackhole: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__36f603e48c36f0aabd623aee3c75f3f94dcd322957a71fb2d3539585045d2c00(
+def _typecheckingstub__3a94d581f860b13a89641b07de3a6dff7bb35902a5e740ce1b0305d078a71a88(
+    job: IJob,
     *,
+    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cidr: builtins.str,
-    route_table: ITransitGatewayRouteTable,
-    attachment: typing.Optional[ITransitGatewayAttachment] = None,
-    blackhole: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bf9f0e3a9c51ac3498209cf81371557e5b56db1c03ff409740d882fde1cacda7(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__05b16d8f0e42dabc8d5b35b3da8eefd18876b6a5a59a4f740c34c94379a3a823(
+    key: builtins.str,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__99f5b49f9607b05a4e188e075be9ce415c7b6b085607cb3e0f90e94cc8453feb(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7005e62847fa5591337705760979f2e03a39c841c84835a874bcebaca8a59289(
     *,
-    transit_gateway: ITransitGateway,
-    name: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7ddc972512f9b73360cad75e0fd028f815d92130c441ed49e42d40f77ebd8fff(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    transit_gateway_route_table_id: builtins.str,
+def _typecheckingstub__ad3c134eb8a9a38db762359e9966bbb7beb44688976d988804ba557fa266ff4b(
+    crawler: ICrawler,
+    *,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ba42798c9102c3419b7c375a3d8ce27fef028001fb7cc17a2798c1aad61854ff(
-    *,
-    name: typing.Optional[builtins.str] = None,
+def _typecheckingstub__9bd574ee7e851b6cdc8e7da335779c92cb91aac7d1685e0748769e6e4e944682(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8ae02cfe78ce98fb4f7880816162efbcf405d70470d3f4d83605632beeb8a6f7(
+def _typecheckingstub__2234879c337e543d2848372b9e2ea82f341e9425395819d4c59814e46dfb3233(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    transit_gateway: ITransitGateway,
-    name: typing.Optional[builtins.str] = None,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4312d41d9a05862a91818a278fa16d6a73ff75dcd46ad08d731c98c54086e195(
+def _typecheckingstub__4b35e7b4cd1b6215af9417101fd148d7cff1bdbaa7e82f113dafee00863f0e8b(
+    job: IJob,
     *,
-    inside_cidr: typing.Optional[builtins.str] = None,
-    pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
+    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3dff1261f60aa49a2037d280e97af162d26181faeabf698640e4139891619042(
-    *,
-    name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+def _typecheckingstub__a7515c04a94a863fad2bee1122daa43d9a40018fd2904b2aa74a621938706702(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c68fcd54ad9cdc22e3838841971cc60da339a1c6b65f45abf9839c71f80a1ad8(
+def _typecheckingstub__bf2bd2d4a47064faaa01d005f9c67d6010a4760a0856334853b9d2c9c03d73b3(
     *,
-    remote_endpoint: IRemoteVpnEndpoint,
-    connection_type: typing.Optional[VpnConnectionType] = None,
-    static_routes_only: typing.Optional[builtins.bool] = None,
-    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    security_configuration: typing.Optional[builtins.str] = None,
+    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__db1711f2c24c8b7a52cb1e23aa7c00f2ee31a53d068176d8b694ba413b49c85e(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__ffa264c859c1bcdd41fda254d289bc185e36ff404ad7901a6b7d63d92cddf8ee(
+    crawler: ICrawler,
     *,
-    local_endpoint: ILocalVpnEndpoint,
-    remote_endpoint: IRemoteVpnEndpoint,
-    connection_type: typing.Optional[VpnConnectionType] = None,
-    static_routes_only: typing.Optional[builtins.bool] = None,
-    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[CrawlerState] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3b1943d41246b0671229072a9d9650d8d0f9f66aaf7b458b59f96ab84ad35da3(
-    metric_name: builtins.str,
+def _typecheckingstub__ca6546c9bc55323e0c4cb2c970aba51c478d9a3067002ee323e9093850759207(
+    job: IJob,
     *,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[JobState] = None,
     account: typing.Optional[builtins.str] = None,
-    color: typing.Optional[builtins.str] = None,
-    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    label: typing.Optional[builtins.str] = None,
-    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    statistic: typing.Optional[builtins.str] = None,
-    unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b7ddda611ef5d00d1dbfb980664aaf365a9109585805083204f9dd201f73b937(
-    transit_gateway: ITransitGateway,
+def _typecheckingstub__532fa291e748d01f44fced9f7933021be1f8ac049d19d07677702e64c2e226cc(
+    _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__255c4f2f88d39694addb3404e05f43b66d5900dda0a83d02497e7579af1e9f87(
-    vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
+def _typecheckingstub__0105e31834c9b424b25ba556e15b0668eb70bf912898e00b880d88fa39017523(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e9f1ecffd701acc1acc5674e16c0bca0e65f2e2327e74bfb0fe4021722919ad1(
+def _typecheckingstub__2ce544c2156b20e8e19b70a1531a61d42db72f6b0e812f45f7bc7bfbeead5f0b(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    local_endpoint: ILocalVpnEndpoint,
-    remote_endpoint: IRemoteVpnEndpoint,
-    connection_type: typing.Optional[VpnConnectionType] = None,
-    static_routes_only: typing.Optional[builtins.bool] = None,
-    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0ec3ce1dacbcb72f74a7ad181d5838d1e71517bb5fc661cee673e3d13cf35dbe(
-    customer_gateway: ICustomerGateway,
+def _typecheckingstub__e98ee73549e5bf2df4bd363c5ccef46d94100d1940e7c591367826866bb56b21(
+    *,
+    comment: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    data: Column,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__19c531bfa20e4b82501cd1840a34d989b2593246657ad35703dfdd6156ae409b(
-    name: builtins.str,
+def _typecheckingstub__7e088280d8611751a4dd67d784a7813fe0d71f491155a45dfd938dcbbf43714d(
+    path: builtins.str,
+    *,
+    asset_hash: typing.Optional[builtins.str] = None,
+    asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
+    bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a4c9d0488d52533eda0e8e013c7c8dc98375bf35fbfb4d0119edfc6dafc3add2(
-    vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
+def _typecheckingstub__ec027c50ac516e8170beed01cb13e2ead3adfe45e782c6b378a332ada31736c0(
+    scope: _constructs_77d1e7e8.Construct,
+    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b034f4493a7f4e0ef9f3e966d78f68321b168b61b98dda5c4dace5477a2b5d5e(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__0ae472b6c02750d1961d7f516ba02f642a1ea26bb6902239beb46998e097aaf9(
+    *,
+    comment: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    type: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7814523b269d29ae5e2e42aa21c1f81bdc5a471fe5e300b0768c03a21b6a6f91(
+def _typecheckingstub__5211274cd7116e3c396417e594ecadcc53088dd8ee26c4e810934deac308acc2(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    ip_address: builtins.str,
-    bgp_asn: typing.Optional[jsii.Number] = None,
-    connection_type: typing.Optional[VpnConnectionType] = None,
+    classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
+    configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
+    database: typing.Optional[Database] = None,
+    delete_behavior: typing.Optional[DeleteBehavior] = None,
+    description: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
+    schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
+    security_configuration: typing.Optional[SecurityConfiguration] = None,
+    table_prefix: typing.Optional[builtins.str] = None,
+    targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
+    update_behavior: typing.Optional[UpdateBehavior] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9cee3aaa3f8d41d377b44df84c1bd31404fc3c74c1f3d4d50f41733f5ceaeaba(
+def _typecheckingstub__d145d23256eb2d35c1a9bf019e04dff25bc109fef47efc90d6d6f6882fdb4815(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    *,
-    customer_gateway_id: builtins.str,
-    bgp_asn: typing.Optional[jsii.Number] = None,
-    ip_address: typing.Optional[builtins.str] = None,
+    crawler_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__745b377e3c9abac41a861ca1050cfc8012b832cecc7ce152fed229d86ee5e4ae(
+def _typecheckingstub__d539939596ad8ddfe1a7db54e1c33868e19ed805abf7d2eef859c4a90be77941(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    customer_gateway_id: builtins.str,
+    crawler_name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__376ae140d941de56c115f01c627b230e0ffb07b7247eb9a061e389e071218f36(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__96016694c1f44cc04af86f8b769bd0adb927352bc79ad9603516897998bec7b0(
+    classifier: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__39f263303ec59ccc7954f0b56dc5825a43956cfa48fc4648959c032c858f8a2f(
-    customer_gateway: ICustomerGateway,
+def _typecheckingstub__dc8dd7ffc643cb691f77d16e095c4e42f8ad2f09ba25c30724c84c18b23eefac(
+    target: ICrawlerTarget,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bd8797d122fda919f703e603d2c593c1fe151dbc800704673ccc25360cdf5d3e(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__a18ab964f00a29725095bfb40c5b43949ff4de4430650c9d95b535e4941cfc7a(
+    crawler: ICrawler,
+    *,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[CrawlerState] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5daa8ff9c63f8f6617139a25d0c2042756ce3ab0da13e5f5a51634e4b9f7ab0c(
-    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+def _typecheckingstub__ab6c6045286c50786550fc825f10c79429ddaf99441ba9be931f3575ea02ea64(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8d11b43c926a884fe3a73d0b44332cd0342bba0c0e2d7bcac16489f068e1191b(
-    bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
+def _typecheckingstub__b34c0d221b3673906a9840fa8262a73d533de41c6c0f80b688d92ba11c4e20a1(
     *,
-    file_format: typing.Optional[FlowLogFileFormat] = None,
-    hive_compatible_partitions: typing.Optional[builtins.bool] = None,
-    key_prefix: typing.Optional[builtins.str] = None,
-    per_hour_partition: typing.Optional[builtins.bool] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__e6be248e60a194fe1d0bcf9dc9398b94b088ef8e6ca462c0c85ef25246e79057(
-    scope: _constructs_77d1e7e8.IConstruct,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[CrawlerState] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e27ee6909fddcfad51f5ddc3aee4e522d6f5fdeab0a0272e67e7d62c063924d6(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__f4c02ff62824c53aba142c5763845ac4a5e58a9cb8f54ede31043c8dba475d26(
+    job: IJob,
     *,
-    transit_gateway: ITransitGateway,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    appliance_mode_support: typing.Optional[builtins.bool] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    ipv6_support: typing.Optional[builtins.bool] = None,
-    name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[JobState] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__135a7b7bec5b4b7974ff32ebff887b94cc20f2b37d6736525ec2c4e7c4b5c542(
+def _typecheckingstub__052b1ed2cea96b32b65c6bcbd0903b2b8d644c2532b12858e569decfda630d36(
     scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    transit_gateway_attachment_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4d1defbd3f98b5d681f7a4e30d69288e6cdc5223fef0fed304547c78510a96e2(
+def _typecheckingstub__72482740085b262df0b54ed41b3b29c654ded6f27c0575af036d20ebf4fff046(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    transit_gateway: ITransitGateway,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    appliance_mode_support: typing.Optional[builtins.bool] = None,
-    dns_support: typing.Optional[builtins.bool] = None,
-    ipv6_support: typing.Optional[builtins.bool] = None,
-    name: typing.Optional[builtins.str] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
+    state: typing.Optional[JobState] = None,
 ) -> None:
     """Type checking stubs"""
     pass
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/ec2_patterns/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/ec2_patterns/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,19 +13,75 @@
 from .._jsii import *
 
 import aws_cdk as _aws_cdk_ceddda9d
 import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
 import constructs as _constructs_77d1e7e8
 from ..ec2 import (
     FlowLogFormat as _FlowLogFormat_b7c2ba34,
+    ICidrProvider as _ICidrProvider_28ddf5b0,
+    IIpamPool as _IIpamPool_511f311d,
     ITransitGateway as _ITransitGateway_25936657,
     ITransitGatewayAttachment as _ITransitGatewayAttachment_64da8ffd,
+    Ipam as _Ipam_1ad3c981,
+    IpamPool as _IpamPool_a6f43771,
     TransitGatewayProps as _TransitGatewayProps_10a60d21,
 )
-from ..ram import ISharedPrincipal as _ISharedPrincipal_9cde791b
+from ..networkmanager import GlobalNetwork as _GlobalNetwork_79ec647c
+from ..ram import (
+    ISharedPrincipal as _ISharedPrincipal_9cde791b,
+    ResourceShare as _ResourceShare_f0180713,
+)
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2_patterns.AddPoolOptions",
+    jsii_struct_bases=[],
+    name_mapping={"cidrs": "cidrs", "default_netmask_length": "defaultNetmaskLength"},
+)
+class AddPoolOptions:
+    def __init__(
+        self,
+        *,
+        cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> None:
+        '''
+        :param cidrs: 
+        :param default_netmask_length: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bafe93fe5666e81af7b6555c6e0b02d696c2267310d93ce406cc5b16333a1449)
+            check_type(argname="argument cidrs", value=cidrs, expected_type=type_hints["cidrs"])
+            check_type(argname="argument default_netmask_length", value=default_netmask_length, expected_type=type_hints["default_netmask_length"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if cidrs is not None:
+            self._values["cidrs"] = cidrs
+        if default_netmask_length is not None:
+            self._values["default_netmask_length"] = default_netmask_length
+
+    @builtins.property
+    def cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("cidrs")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    @builtins.property
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "AddPoolOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
     jsii_type="cdk-extensions.ec2_patterns.AddSpokeNetworkProps",
     jsii_struct_bases=[],
     name_mapping={
         "availability_zones": "availabilityZones",
@@ -44,15 +100,15 @@
     },
 )
 class AddSpokeNetworkProps:
     def __init__(
         self,
         *,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union["FlowLogOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         vpc_name: typing.Optional[builtins.str] = None,
@@ -121,17 +177,17 @@
 
     @builtins.property
     def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
         result = self._values.get("availability_zones")
         return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def cidr(self) -> typing.Optional[builtins.str]:
+    def cidr(self) -> typing.Optional[_ICidrProvider_28ddf5b0]:
         result = self._values.get("cidr")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_ICidrProvider_28ddf5b0], result)
 
     @builtins.property
     def default_instance_tenancy(
         self,
     ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy]:
         result = self._values.get("default_instance_tenancy")
         return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy], result)
@@ -203,14 +259,62 @@
     def __repr__(self) -> str:
         return "AddSpokeNetworkProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
+    jsii_type="cdk-extensions.ec2_patterns.AllocatePrivateNetworkOptions",
+    jsii_struct_bases=[],
+    name_mapping={"netmask": "netmask", "pool": "pool"},
+)
+class AllocatePrivateNetworkOptions:
+    def __init__(
+        self,
+        *,
+        netmask: typing.Optional[jsii.Number] = None,
+        pool: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param netmask: 
+        :param pool: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1edcf1c081b844711051faa1818771b547c90031be28d3b0f04a24516485f5eb)
+            check_type(argname="argument netmask", value=netmask, expected_type=type_hints["netmask"])
+            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if netmask is not None:
+            self._values["netmask"] = netmask
+        if pool is not None:
+            self._values["pool"] = pool
+
+    @builtins.property
+    def netmask(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("netmask")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def pool(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("pool")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "AllocatePrivateNetworkOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
     jsii_type="cdk-extensions.ec2_patterns.FlowLogOptions",
     jsii_struct_bases=[_aws_cdk_aws_ec2_ceddda9d.FlowLogOptions],
     name_mapping={
         "destination": "destination",
         "log_format": "logFormat",
         "max_aggregation_interval": "maxAggregationInterval",
         "traffic_type": "trafficType",
@@ -330,15 +434,15 @@
 ):
     def __init__(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         nat_gateway_provider: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatProvider] = None,
@@ -424,14 +528,19 @@
             max_aggregation_interval=max_aggregation_interval,
             traffic_type=traffic_type,
         )
 
         return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLog, jsii.invoke(self, "addVpcFlowLog", [id, options]))
 
     @builtins.property
+    @jsii.member(jsii_name="netmask")
+    def netmask(self) -> jsii.Number:
+        return typing.cast(jsii.Number, jsii.get(self, "netmask"))
+
+    @builtins.property
     @jsii.member(jsii_name="defaultInstanceTenancy")
     def default_instance_tenancy(
         self,
     ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy]:
         return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy], jsii.get(self, "defaultInstanceTenancy"))
 
     @builtins.property
@@ -441,14 +550,19 @@
 
     @builtins.property
     @jsii.member(jsii_name="enableDnsSupport")
     def enable_dns_support(self) -> typing.Optional[builtins.bool]:
         return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "enableDnsSupport"))
 
     @builtins.property
+    @jsii.member(jsii_name="ipamPool")
+    def ipam_pool(self) -> typing.Optional[_IIpamPool_511f311d]:
+        return typing.cast(typing.Optional[_IIpamPool_511f311d], jsii.get(self, "ipamPool"))
+
+    @builtins.property
     @jsii.member(jsii_name="maxAzs")
     def max_azs(self) -> typing.Optional[jsii.Number]:
         return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxAzs"))
 
     @builtins.property
     @jsii.member(jsii_name="vpcName")
     def vpc_name(self) -> typing.Optional[builtins.str]:
@@ -462,20 +576,21 @@
 ):
     def __init__(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+        global_network: typing.Optional[_GlobalNetwork_79ec647c] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         sharing: typing.Optional[typing.Union["FourTierNetworkShareProperties", typing.Dict[builtins.str, typing.Any]]] = None,
         vpc_name: typing.Optional[builtins.str] = None,
         vpn_connections: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.VpnConnectionOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         vpn_gateway: typing.Optional[builtins.bool] = None,
         vpn_gateway_asn: typing.Optional[jsii.Number] = None,
         vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
@@ -490,14 +605,15 @@
         :param availability_zones: 
         :param cidr: 
         :param default_instance_tenancy: 
         :param enable_dns_hostnames: 
         :param enable_dns_support: 
         :param flow_logs: 
         :param gateway_endpoints: 
+        :param global_network: 
         :param max_azs: 
         :param sharing: 
         :param vpc_name: 
         :param vpn_connections: 
         :param vpn_gateway: 
         :param vpn_gateway_asn: 
         :param vpn_route_propagation: 
@@ -514,14 +630,15 @@
             availability_zones=availability_zones,
             cidr=cidr,
             default_instance_tenancy=default_instance_tenancy,
             enable_dns_hostnames=enable_dns_hostnames,
             enable_dns_support=enable_dns_support,
             flow_logs=flow_logs,
             gateway_endpoints=gateway_endpoints,
+            global_network=global_network,
             max_azs=max_azs,
             sharing=sharing,
             vpc_name=vpc_name,
             vpn_connections=vpn_connections,
             vpn_gateway=vpn_gateway,
             vpn_gateway_asn=vpn_gateway_asn,
             vpn_route_propagation=vpn_route_propagation,
@@ -536,15 +653,15 @@
     @jsii.member(jsii_name="addSpoke")
     def add_spoke(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         vpc_name: typing.Optional[builtins.str] = None,
@@ -651,14 +768,19 @@
 
     @builtins.property
     @jsii.member(jsii_name="sharing")
     def sharing(self) -> "FourTierNetworkShareProperties":
         return typing.cast("FourTierNetworkShareProperties", jsii.get(self, "sharing"))
 
     @builtins.property
+    @jsii.member(jsii_name="globalNetwork")
+    def global_network(self) -> typing.Optional[_GlobalNetwork_79ec647c]:
+        return typing.cast(typing.Optional[_GlobalNetwork_79ec647c], jsii.get(self, "globalNetwork"))
+
+    @builtins.property
     @jsii.member(jsii_name="transitGateway")
     def transit_gateway(self) -> typing.Optional[_ITransitGateway_25936657]:
         return typing.cast(typing.Optional[_ITransitGateway_25936657], jsii.get(self, "transitGateway"))
 
 
 @jsii.data_type(
     jsii_type="cdk-extensions.ec2_patterns.FourTierNetworkHubProps",
@@ -671,14 +793,15 @@
         "availability_zones": "availabilityZones",
         "cidr": "cidr",
         "default_instance_tenancy": "defaultInstanceTenancy",
         "enable_dns_hostnames": "enableDnsHostnames",
         "enable_dns_support": "enableDnsSupport",
         "flow_logs": "flowLogs",
         "gateway_endpoints": "gatewayEndpoints",
+        "global_network": "globalNetwork",
         "max_azs": "maxAzs",
         "sharing": "sharing",
         "vpc_name": "vpcName",
         "vpn_connections": "vpnConnections",
         "vpn_gateway": "vpnGateway",
         "vpn_gateway_asn": "vpnGatewayAsn",
         "vpn_route_propagation": "vpnRoutePropagation",
@@ -689,20 +812,21 @@
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+        global_network: typing.Optional[_GlobalNetwork_79ec647c] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         sharing: typing.Optional[typing.Union["FourTierNetworkShareProperties", typing.Dict[builtins.str, typing.Any]]] = None,
         vpc_name: typing.Optional[builtins.str] = None,
         vpn_connections: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.VpnConnectionOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         vpn_gateway: typing.Optional[builtins.bool] = None,
         vpn_gateway_asn: typing.Optional[jsii.Number] = None,
         vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
@@ -715,14 +839,15 @@
         :param availability_zones: 
         :param cidr: 
         :param default_instance_tenancy: 
         :param enable_dns_hostnames: 
         :param enable_dns_support: 
         :param flow_logs: 
         :param gateway_endpoints: 
+        :param global_network: 
         :param max_azs: 
         :param sharing: 
         :param vpc_name: 
         :param vpn_connections: 
         :param vpn_gateway: 
         :param vpn_gateway_asn: 
         :param vpn_route_propagation: 
@@ -738,14 +863,15 @@
             check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
             check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
             check_type(argname="argument default_instance_tenancy", value=default_instance_tenancy, expected_type=type_hints["default_instance_tenancy"])
             check_type(argname="argument enable_dns_hostnames", value=enable_dns_hostnames, expected_type=type_hints["enable_dns_hostnames"])
             check_type(argname="argument enable_dns_support", value=enable_dns_support, expected_type=type_hints["enable_dns_support"])
             check_type(argname="argument flow_logs", value=flow_logs, expected_type=type_hints["flow_logs"])
             check_type(argname="argument gateway_endpoints", value=gateway_endpoints, expected_type=type_hints["gateway_endpoints"])
+            check_type(argname="argument global_network", value=global_network, expected_type=type_hints["global_network"])
             check_type(argname="argument max_azs", value=max_azs, expected_type=type_hints["max_azs"])
             check_type(argname="argument sharing", value=sharing, expected_type=type_hints["sharing"])
             check_type(argname="argument vpc_name", value=vpc_name, expected_type=type_hints["vpc_name"])
             check_type(argname="argument vpn_connections", value=vpn_connections, expected_type=type_hints["vpn_connections"])
             check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
             check_type(argname="argument vpn_gateway_asn", value=vpn_gateway_asn, expected_type=type_hints["vpn_gateway_asn"])
             check_type(argname="argument vpn_route_propagation", value=vpn_route_propagation, expected_type=type_hints["vpn_route_propagation"])
@@ -768,14 +894,16 @@
             self._values["enable_dns_hostnames"] = enable_dns_hostnames
         if enable_dns_support is not None:
             self._values["enable_dns_support"] = enable_dns_support
         if flow_logs is not None:
             self._values["flow_logs"] = flow_logs
         if gateway_endpoints is not None:
             self._values["gateway_endpoints"] = gateway_endpoints
+        if global_network is not None:
+            self._values["global_network"] = global_network
         if max_azs is not None:
             self._values["max_azs"] = max_azs
         if sharing is not None:
             self._values["sharing"] = sharing
         if vpc_name is not None:
             self._values["vpc_name"] = vpc_name
         if vpn_connections is not None:
@@ -836,17 +964,17 @@
 
     @builtins.property
     def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
         result = self._values.get("availability_zones")
         return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def cidr(self) -> typing.Optional[builtins.str]:
+    def cidr(self) -> typing.Optional[_ICidrProvider_28ddf5b0]:
         result = self._values.get("cidr")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_ICidrProvider_28ddf5b0], result)
 
     @builtins.property
     def default_instance_tenancy(
         self,
     ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy]:
         result = self._values.get("default_instance_tenancy")
         return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy], result)
@@ -872,14 +1000,19 @@
     def gateway_endpoints(
         self,
     ) -> typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions]]:
         result = self._values.get("gateway_endpoints")
         return typing.cast(typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions]], result)
 
     @builtins.property
+    def global_network(self) -> typing.Optional[_GlobalNetwork_79ec647c]:
+        result = self._values.get("global_network")
+        return typing.cast(typing.Optional[_GlobalNetwork_79ec647c], result)
+
+    @builtins.property
     def max_azs(self) -> typing.Optional[jsii.Number]:
         result = self._values.get("max_azs")
         return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
     def sharing(self) -> typing.Optional["FourTierNetworkShareProperties"]:
         result = self._values.get("sharing")
@@ -949,15 +1082,15 @@
     },
 )
 class FourTierNetworkProps:
     def __init__(
         self,
         *,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         nat_gateway_provider: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatProvider] = None,
@@ -1043,17 +1176,17 @@
 
     @builtins.property
     def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
         result = self._values.get("availability_zones")
         return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def cidr(self) -> typing.Optional[builtins.str]:
+    def cidr(self) -> typing.Optional[_ICidrProvider_28ddf5b0]:
         result = self._values.get("cidr")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_ICidrProvider_28ddf5b0], result)
 
     @builtins.property
     def default_instance_tenancy(
         self,
     ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy]:
         result = self._values.get("default_instance_tenancy")
         return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy], result)
@@ -1215,17 +1348,17 @@
     jsii_type="cdk-extensions.ec2_patterns.FourTierNetworkSpoke",
 ):
     def __init__(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
-        transit_gateway: _ITransitGateway_25936657,
+        hub: FourTierNetworkHub,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         vpc_name: typing.Optional[builtins.str] = None,
@@ -1237,15 +1370,15 @@
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
         '''
         :param scope: -
         :param id: -
-        :param transit_gateway: 
+        :param hub: 
         :param availability_zones: 
         :param cidr: 
         :param default_instance_tenancy: 
         :param enable_dns_hostnames: 
         :param enable_dns_support: 
         :param flow_logs: 
         :param gateway_endpoints: 
@@ -1261,15 +1394,15 @@
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
             type_hints = typing.get_type_hints(_typecheckingstub__b7fc919bd6ebf5b551769cb4313098a0e49891c0d5e533cf159dc7f303b04473)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
         props = FourTierNetworkSpokeProps(
-            transit_gateway=transit_gateway,
+            hub=hub,
             availability_zones=availability_zones,
             cidr=cidr,
             default_instance_tenancy=default_instance_tenancy,
             enable_dns_hostnames=enable_dns_hostnames,
             enable_dns_support=enable_dns_support,
             flow_logs=flow_logs,
             gateway_endpoints=gateway_endpoints,
@@ -1284,28 +1417,33 @@
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
     @builtins.property
+    @jsii.member(jsii_name="transitGateway")
+    def transit_gateway(self) -> _ITransitGateway_25936657:
+        return typing.cast(_ITransitGateway_25936657, jsii.get(self, "transitGateway"))
+
+    @builtins.property
     @jsii.member(jsii_name="transitGatewayAttachment")
     def transit_gateway_attachment(self) -> _ITransitGatewayAttachment_64da8ffd:
         return typing.cast(_ITransitGatewayAttachment_64da8ffd, jsii.get(self, "transitGatewayAttachment"))
 
 
 @jsii.data_type(
     jsii_type="cdk-extensions.ec2_patterns.FourTierNetworkSpokeProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "transit_gateway": "transitGateway",
+        "hub": "hub",
         "availability_zones": "availabilityZones",
         "cidr": "cidr",
         "default_instance_tenancy": "defaultInstanceTenancy",
         "enable_dns_hostnames": "enableDnsHostnames",
         "enable_dns_support": "enableDnsSupport",
         "flow_logs": "flowLogs",
         "gateway_endpoints": "gatewayEndpoints",
@@ -1321,17 +1459,17 @@
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        transit_gateway: _ITransitGateway_25936657,
+        hub: FourTierNetworkHub,
         availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-        cidr: typing.Optional[builtins.str] = None,
+        cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
         default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
         enable_dns_hostnames: typing.Optional[builtins.bool] = None,
         enable_dns_support: typing.Optional[builtins.bool] = None,
         flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
         max_azs: typing.Optional[jsii.Number] = None,
         vpc_name: typing.Optional[builtins.str] = None,
@@ -1341,15 +1479,15 @@
         vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
     ) -> None:
         '''
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param transit_gateway: 
+        :param hub: 
         :param availability_zones: 
         :param cidr: 
         :param default_instance_tenancy: 
         :param enable_dns_hostnames: 
         :param enable_dns_support: 
         :param flow_logs: 
         :param gateway_endpoints: 
@@ -1362,30 +1500,30 @@
         '''
         if __debug__:
             type_hints = typing.get_type_hints(_typecheckingstub__0f20b71c01dce683a9711971685bfd423a84bb51b3ae70144ed170d14b6b7721)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+            check_type(argname="argument hub", value=hub, expected_type=type_hints["hub"])
             check_type(argname="argument availability_zones", value=availability_zones, expected_type=type_hints["availability_zones"])
             check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
             check_type(argname="argument default_instance_tenancy", value=default_instance_tenancy, expected_type=type_hints["default_instance_tenancy"])
             check_type(argname="argument enable_dns_hostnames", value=enable_dns_hostnames, expected_type=type_hints["enable_dns_hostnames"])
             check_type(argname="argument enable_dns_support", value=enable_dns_support, expected_type=type_hints["enable_dns_support"])
             check_type(argname="argument flow_logs", value=flow_logs, expected_type=type_hints["flow_logs"])
             check_type(argname="argument gateway_endpoints", value=gateway_endpoints, expected_type=type_hints["gateway_endpoints"])
             check_type(argname="argument max_azs", value=max_azs, expected_type=type_hints["max_azs"])
             check_type(argname="argument vpc_name", value=vpc_name, expected_type=type_hints["vpc_name"])
             check_type(argname="argument vpn_connections", value=vpn_connections, expected_type=type_hints["vpn_connections"])
             check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
             check_type(argname="argument vpn_gateway_asn", value=vpn_gateway_asn, expected_type=type_hints["vpn_gateway_asn"])
             check_type(argname="argument vpn_route_propagation", value=vpn_route_propagation, expected_type=type_hints["vpn_route_propagation"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "transit_gateway": transit_gateway,
+            "hub": hub,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
@@ -1462,28 +1600,28 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def transit_gateway(self) -> _ITransitGateway_25936657:
-        result = self._values.get("transit_gateway")
-        assert result is not None, "Required property 'transit_gateway' is missing"
-        return typing.cast(_ITransitGateway_25936657, result)
+    def hub(self) -> FourTierNetworkHub:
+        result = self._values.get("hub")
+        assert result is not None, "Required property 'hub' is missing"
+        return typing.cast(FourTierNetworkHub, result)
 
     @builtins.property
     def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
         result = self._values.get("availability_zones")
         return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def cidr(self) -> typing.Optional[builtins.str]:
+    def cidr(self) -> typing.Optional[_ICidrProvider_28ddf5b0]:
         result = self._values.get("cidr")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_ICidrProvider_28ddf5b0], result)
 
     @builtins.property
     def default_instance_tenancy(
         self,
     ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy]:
         result = self._values.get("default_instance_tenancy")
         return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy], result)
@@ -1554,14 +1692,377 @@
 
     def __repr__(self) -> str:
         return "FourTierNetworkSpokeProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+class IpAddressManager(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2_patterns.IpAddressManager",
+):
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        default_pool_allocation_mask: typing.Optional[jsii.Number] = None,
+        default_pool_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        sharing: typing.Optional[typing.Union["IpAddressManagerSharingProps", typing.Dict[builtins.str, typing.Any]]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''
+        :param scope: -
+        :param id: -
+        :param default_pool_allocation_mask: 
+        :param default_pool_cidrs: 
+        :param regions: 
+        :param sharing: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f5bbc27e214643b7b9d138ec1be6d1c8d83e4ff65e813ac16c1afea0a01c0aed)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpAddressManagerProps(
+            default_pool_allocation_mask=default_pool_allocation_mask,
+            default_pool_cidrs=default_pool_cidrs,
+            regions=regions,
+            sharing=sharing,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="addPrivatePool")
+    def add_private_pool(
+        self,
+        name: builtins.str,
+        *,
+        cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> _IIpamPool_511f311d:
+        '''
+        :param name: -
+        :param cidrs: 
+        :param default_netmask_length: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3e624c1c33944a39ff018b0e365d361e197609bc7efb5d41db257e8d7fbb5ac3)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = AddPoolOptions(
+            cidrs=cidrs, default_netmask_length=default_netmask_length
+        )
+
+        return typing.cast(_IIpamPool_511f311d, jsii.invoke(self, "addPrivatePool", [name, options]))
+
+    @jsii.member(jsii_name="addRegion")
+    def add_region(self, region: builtins.str) -> None:
+        '''
+        :param region: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a4d1ee3c61abc8dc1d2e619121864558a6a5427f0f16c5d8a598cb68d7ab3a3f)
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+        return typing.cast(None, jsii.invoke(self, "addRegion", [region]))
+
+    @jsii.member(jsii_name="addStagePool")
+    def _add_stage_pool(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        parent: _IIpamPool_511f311d,
+    ) -> _IpamPool_a6f43771:
+        '''
+        :param scope: -
+        :param parent: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8351763cbc2fc41c8b0d7e2aaa7647da164bdeaebee102597747cddcc0105199)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument parent", value=parent, expected_type=type_hints["parent"])
+        return typing.cast(_IpamPool_a6f43771, jsii.invoke(self, "addStagePool", [scope, parent]))
+
+    @jsii.member(jsii_name="allocatePrivateNetwork")
+    def allocate_private_network(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        netmask: typing.Optional[jsii.Number] = None,
+        pool: typing.Optional[builtins.str] = None,
+    ) -> _IpamPool_a6f43771:
+        '''
+        :param scope: -
+        :param id: -
+        :param netmask: 
+        :param pool: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__82fd5f0403186614f9952c77f056557e26140d7bf698ba66b0635cfbbb5b2b0f)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AllocatePrivateNetworkOptions(netmask=netmask, pool=pool)
+
+        return typing.cast(_IpamPool_a6f43771, jsii.invoke(self, "allocatePrivateNetwork", [scope, id, options]))
+
+    @jsii.member(jsii_name="registerAccount")
+    def _register_account(
+        self,
+        account: builtins.str,
+        pool: _IIpamPool_511f311d,
+    ) -> None:
+        '''
+        :param account: -
+        :param pool: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c82b599c8d1db4dca2c0b4ea748776ad7c5f35028ef3d218517ae47d9e5906d7)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
+        return typing.cast(None, jsii.invoke(self, "registerAccount", [account, pool]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_CIDR")
+    def DEFAULT_CIDR(cls) -> builtins.str:
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_CIDR"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_POOL_ALLOCATION_MASK")
+    def DEFAULT_POOL_ALLOCATION_MASK(cls) -> jsii.Number:
+        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_POOL_ALLOCATION_MASK"))
+
+    @builtins.property
+    @jsii.member(jsii_name="allowExternalPricipals")
+    def allow_external_pricipals(self) -> builtins.bool:
+        return typing.cast(builtins.bool, jsii.get(self, "allowExternalPricipals"))
+
+    @builtins.property
+    @jsii.member(jsii_name="ipam")
+    def ipam(self) -> _Ipam_1ad3c981:
+        return typing.cast(_Ipam_1ad3c981, jsii.get(self, "ipam"))
+
+    @builtins.property
+    @jsii.member(jsii_name="sharingEnabled")
+    def sharing_enabled(self) -> builtins.bool:
+        return typing.cast(builtins.bool, jsii.get(self, "sharingEnabled"))
+
+    @builtins.property
+    @jsii.member(jsii_name="resourceShare")
+    def resource_share(self) -> typing.Optional[_ResourceShare_f0180713]:
+        return typing.cast(typing.Optional[_ResourceShare_f0180713], jsii.get(self, "resourceShare"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2_patterns.IpAddressManagerProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "default_pool_allocation_mask": "defaultPoolAllocationMask",
+        "default_pool_cidrs": "defaultPoolCidrs",
+        "regions": "regions",
+        "sharing": "sharing",
+    },
+)
+class IpAddressManagerProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        default_pool_allocation_mask: typing.Optional[jsii.Number] = None,
+        default_pool_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        sharing: typing.Optional[typing.Union["IpAddressManagerSharingProps", typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
+        '''
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param default_pool_allocation_mask: 
+        :param default_pool_cidrs: 
+        :param regions: 
+        :param sharing: 
+        '''
+        if isinstance(sharing, dict):
+            sharing = IpAddressManagerSharingProps(**sharing)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ba6a3618628a126f74720a6e6078d9d69aab82d46ddf292343434ce66bb23af2)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument default_pool_allocation_mask", value=default_pool_allocation_mask, expected_type=type_hints["default_pool_allocation_mask"])
+            check_type(argname="argument default_pool_cidrs", value=default_pool_cidrs, expected_type=type_hints["default_pool_cidrs"])
+            check_type(argname="argument regions", value=regions, expected_type=type_hints["regions"])
+            check_type(argname="argument sharing", value=sharing, expected_type=type_hints["sharing"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if default_pool_allocation_mask is not None:
+            self._values["default_pool_allocation_mask"] = default_pool_allocation_mask
+        if default_pool_cidrs is not None:
+            self._values["default_pool_cidrs"] = default_pool_cidrs
+        if regions is not None:
+            self._values["regions"] = regions
+        if sharing is not None:
+            self._values["sharing"] = sharing
+
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
+
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
+
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
+
+        Cannot be supplied together with either ``account`` or ``region``.
+
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
+
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
+        '''
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
+
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def default_pool_allocation_mask(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_pool_allocation_mask")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def default_pool_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("default_pool_cidrs")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    @builtins.property
+    def regions(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("regions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    @builtins.property
+    def sharing(self) -> typing.Optional["IpAddressManagerSharingProps"]:
+        result = self._values.get("sharing")
+        return typing.cast(typing.Optional["IpAddressManagerSharingProps"], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "IpAddressManagerProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2_patterns.IpAddressManagerSharingProps",
+    jsii_struct_bases=[],
+    name_mapping={
+        "allow_external_pricipals": "allowExternalPricipals",
+        "enabled": "enabled",
+    },
+)
+class IpAddressManagerSharingProps:
+    def __init__(
+        self,
+        *,
+        allow_external_pricipals: typing.Optional[builtins.bool] = None,
+        enabled: typing.Optional[builtins.bool] = None,
+    ) -> None:
+        '''
+        :param allow_external_pricipals: 
+        :param enabled: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__625f9f8c0a5d69c3e4b2374c91d8e564230c3262a5c1305b19ec565ab3ffed26)
+            check_type(argname="argument allow_external_pricipals", value=allow_external_pricipals, expected_type=type_hints["allow_external_pricipals"])
+            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if allow_external_pricipals is not None:
+            self._values["allow_external_pricipals"] = allow_external_pricipals
+        if enabled is not None:
+            self._values["enabled"] = enabled
+
+    @builtins.property
+    def allow_external_pricipals(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("allow_external_pricipals")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def enabled(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("enabled")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "IpAddressManagerSharingProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
 @jsii.data_type(
     jsii_type="cdk-extensions.ec2_patterns.TransitGatewayHubConfiguration",
     jsii_struct_bases=[],
     name_mapping={
         "allow_external": "allowExternal",
         "auto_accept_shared_attachments": "autoAcceptSharedAttachments",
         "auto_discovery": "autoDiscovery",
@@ -1729,33 +2230,46 @@
     def __repr__(self) -> str:
         return "TransitGatewaySpokeConfiguration(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 __all__ = [
+    "AddPoolOptions",
     "AddSpokeNetworkProps",
+    "AllocatePrivateNetworkOptions",
     "FlowLogOptions",
     "FourTierNetwork",
     "FourTierNetworkHub",
     "FourTierNetworkHubProps",
     "FourTierNetworkProps",
     "FourTierNetworkShareProperties",
     "FourTierNetworkSpoke",
     "FourTierNetworkSpokeProps",
+    "IpAddressManager",
+    "IpAddressManagerProps",
+    "IpAddressManagerSharingProps",
     "TransitGatewayHubConfiguration",
     "TransitGatewaySpokeConfiguration",
 ]
 
 publication.publish()
 
+def _typecheckingstub__bafe93fe5666e81af7b6555c6e0b02d696c2267310d93ce406cc5b16333a1449(
+    *,
+    cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
 def _typecheckingstub__048409c4bedb08ed8edc9dda9cec65cb4087822a3dcae95d57c194d4e0613116(
     *,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     vpc_name: typing.Optional[builtins.str] = None,
@@ -1763,14 +2277,22 @@
     vpn_gateway: typing.Optional[builtins.bool] = None,
     vpn_gateway_asn: typing.Optional[jsii.Number] = None,
     vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
+def _typecheckingstub__1edcf1c081b844711051faa1818771b547c90031be28d3b0f04a24516485f5eb(
+    *,
+    netmask: typing.Optional[jsii.Number] = None,
+    pool: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
 def _typecheckingstub__61356c6c988a747170b0fff518aeff55bb37140b2f2bb3a8395a7676df11d939(
     *,
     destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
     log_format: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.LogFormat]] = None,
     max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
     traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
     log_format_definition: typing.Optional[_FlowLogFormat_b7c2ba34] = None,
@@ -1779,15 +2301,15 @@
     pass
 
 def _typecheckingstub__01b54dda1f6044b8b90a294f4af2c53fd512620a5e619adafd6d687a35f35dc3(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
     *,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     nat_gateway_provider: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatProvider] = None,
@@ -1815,20 +2337,21 @@
     pass
 
 def _typecheckingstub__32ace25eaf0b1bdeb7c9833547b92ca28254092d01db9ebc9696fce2260b43d9(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
     *,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    global_network: typing.Optional[_GlobalNetwork_79ec647c] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     sharing: typing.Optional[typing.Union[FourTierNetworkShareProperties, typing.Dict[builtins.str, typing.Any]]] = None,
     vpc_name: typing.Optional[builtins.str] = None,
     vpn_connections: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.VpnConnectionOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     vpn_gateway: typing.Optional[builtins.bool] = None,
     vpn_gateway_asn: typing.Optional[jsii.Number] = None,
     vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
@@ -1841,15 +2364,15 @@
     pass
 
 def _typecheckingstub__b427eb756711b9be0d1724b92283f7b8b658149d02d0860ddfaae4ca009451a6(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
     *,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     vpc_name: typing.Optional[builtins.str] = None,
@@ -1864,35 +2387,36 @@
 def _typecheckingstub__b1e120a9a594264d414d234533b6a6694a2e18b423a355c83676f0931ec9be90(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    global_network: typing.Optional[_GlobalNetwork_79ec647c] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     sharing: typing.Optional[typing.Union[FourTierNetworkShareProperties, typing.Dict[builtins.str, typing.Any]]] = None,
     vpc_name: typing.Optional[builtins.str] = None,
     vpn_connections: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.VpnConnectionOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     vpn_gateway: typing.Optional[builtins.bool] = None,
     vpn_gateway_asn: typing.Optional[jsii.Number] = None,
     vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
 def _typecheckingstub__ce9f1c80c97704155becd995a7614b98797ff3dcfedcb6c14a3c861d8ffa5d99(
     *,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     nat_gateway_provider: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatProvider] = None,
@@ -1916,17 +2440,17 @@
     """Type checking stubs"""
     pass
 
 def _typecheckingstub__b7fc919bd6ebf5b551769cb4313098a0e49891c0d5e533cf159dc7f303b04473(
     scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
     *,
-    transit_gateway: _ITransitGateway_25936657,
+    hub: FourTierNetworkHub,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     vpc_name: typing.Optional[builtins.str] = None,
@@ -1944,17 +2468,17 @@
 
 def _typecheckingstub__0f20b71c01dce683a9711971685bfd423a84bb51b3ae70144ed170d14b6b7721(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    transit_gateway: _ITransitGateway_25936657,
+    hub: FourTierNetworkHub,
     availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
-    cidr: typing.Optional[builtins.str] = None,
+    cidr: typing.Optional[_ICidrProvider_28ddf5b0] = None,
     default_instance_tenancy: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.DefaultInstanceTenancy] = None,
     enable_dns_hostnames: typing.Optional[builtins.bool] = None,
     enable_dns_support: typing.Optional[builtins.bool] = None,
     flow_logs: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.FlowLogOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_ec2_ceddda9d.GatewayVpcEndpointOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
     max_azs: typing.Optional[jsii.Number] = None,
     vpc_name: typing.Optional[builtins.str] = None,
@@ -1962,14 +2486,91 @@
     vpn_gateway: typing.Optional[builtins.bool] = None,
     vpn_gateway_asn: typing.Optional[jsii.Number] = None,
     vpn_route_propagation: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
+def _typecheckingstub__f5bbc27e214643b7b9d138ec1be6d1c8d83e4ff65e813ac16c1afea0a01c0aed(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    default_pool_allocation_mask: typing.Optional[jsii.Number] = None,
+    default_pool_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    sharing: typing.Optional[typing.Union[IpAddressManagerSharingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3e624c1c33944a39ff018b0e365d361e197609bc7efb5d41db257e8d7fbb5ac3(
+    name: builtins.str,
+    *,
+    cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a4d1ee3c61abc8dc1d2e619121864558a6a5427f0f16c5d8a598cb68d7ab3a3f(
+    region: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8351763cbc2fc41c8b0d7e2aaa7647da164bdeaebee102597747cddcc0105199(
+    scope: _constructs_77d1e7e8.IConstruct,
+    parent: _IIpamPool_511f311d,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__82fd5f0403186614f9952c77f056557e26140d7bf698ba66b0635cfbbb5b2b0f(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    netmask: typing.Optional[jsii.Number] = None,
+    pool: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c82b599c8d1db4dca2c0b4ea748776ad7c5f35028ef3d218517ae47d9e5906d7(
+    account: builtins.str,
+    pool: _IIpamPool_511f311d,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__ba6a3618628a126f74720a6e6078d9d69aab82d46ddf292343434ce66bb23af2(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    default_pool_allocation_mask: typing.Optional[jsii.Number] = None,
+    default_pool_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    sharing: typing.Optional[typing.Union[IpAddressManagerSharingProps, typing.Dict[builtins.str, typing.Any]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__625f9f8c0a5d69c3e4b2374c91d8e564230c3262a5c1305b19ec565ab3ffed26(
+    *,
+    allow_external_pricipals: typing.Optional[builtins.bool] = None,
+    enabled: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
 def _typecheckingstub__6667797cf749d298a257c6c716db23d22c81c5c28b1dbf19334ef2de80ebcba5(
     *,
     allow_external: typing.Optional[builtins.bool] = None,
     auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
     auto_discovery: typing.Optional[builtins.bool] = None,
     default_route_table_id: typing.Optional[builtins.str] = None,
     principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/eks_patterns/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/eks_patterns/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/glue/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/k8s_aws/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,846 +1,631 @@
 '''
-# AWS Glue Library
+# K8S AWS Construct Library
 
-The `@cdk-extensions/glue` module contains configurations for AWS Glue.
+Provides Kubernetes resources for integrating with AWS services.
 
-```python
-import * as glue from 'cdk-extensions/glue';
-```
+## Fargate Logging
 
-## Objective
+Fargate logging causes the output of pods running on EKS Farget to be sent to a logging service for storage and review.
 
-The Glue module is used to consolidate data from multiple different sources into a single location to simplify analysis and review. It provides the ability to discover and organize data from a wide variety of sources; tranform, prepare and clean that data for analysis; and the creation of data pipelines to deliver the prepared data for storage and analysis and monitor the process.
+By default, logs are written to CloudWatch Logs.
 
-The AWS Glue Catalog is used to orchestrate the operation based on using metadata stored in its tables which define the sources and targets it should operate on. Crawlers are added to the Glue Catalog which allow access to the data sources and target, providing information on data changes which need to be acted upon. Jobs are then configured to perform the transformation of that data for delivery to its target location. Scheduling of these jobs can then be configured to either run at specific times, based off of triggering events or performed manually.
+Enable Fargate logging on an EKS cluster:
 
-## Important Constructs
+```
+declare const cluster: eks.FargateCluster;
 
-### Catalog
+const logger = new k8s_aws.FargateLogger(this, 'logger', {
+    cluster: cluster,
+    fargateProfiles: [
+        cluster.defaultProfile
+    ]
+});
+```
 
-The Catalog construct defines the Glue Catalog that will hold metadata and act as the source for orchestrating all Glue Jobs
+Permissions for sending logs to their configured destination are added to the Fargate profiles associated with the logger.
 
-### Table
+When adding new Fargate Profiles be sure to associate them with the logger to ensure they have sufficient permissions to write logs.
 
-The Table construct holds the table definition within the Glue Catalog which contains the necessary metadata for performing Glue jobs
+```
+declare const profile: eks.FargateProfile;
+declare const logger: k8s_aws.FargateLogger;
 
-### Crawler
+logger.addFargateProfile(profile);
+```
 
-The Crawler construct contains the information defining a source of data, including the necessary information or credentials to reach and access it.
+Configure logging to write to a Kinesis Firehose delivery stream:
 
-### Jobs
+```
+declare const cluster: eks.FargateCluster;
+declare const deliveryStream: kinesis_hirehose.DeliveryStream;
 
-The Jobs construct contains the instructions to perform transformation and delivery of the crawled data.
+const logger = new k8s_aws.FargateLogger(this, 'logger', {
+    cluster: cluster,
+    fargateProfiles: [
+        cluster.defaultProfile
+    ],
+    outputs: [
+        k8s_aws.FluentBitOutput.kinesisFirehose(k8s_aws.FluentBitMatch.ALL, deliveryStream);
+    ]
+});
+```
 
-### Trigger
+Configure logging to write to a Kinesis data stream:
 
-The Trigger construct defines what triggers should be used to run a particular job.
+```
+declare const cluster: eks.FargateCluster;
+declare const stream: kinesis.Stream;
 
-### Workflow
+const logger = new k8s_aws.FargateLogger(this, 'logger', {
+    cluster: cluster,
+    fargateProfiles: [
+        cluster.defaultProfile
+    ],
+    outputs: [
+        k8s_aws.FluentBitOutput.kinesis(k8s_aws.FluentBitMatch.ALL, stream);
+    ]
+});
+```
 
-The Workflow construct contains a collection of Triggers and Jobs to link together a set of processes into a complete data pipeline.
-'''
-import abc
-import builtins
-import datetime
-import enum
-import typing
+Configure logging to write to an OpenSearch domain:
 
-import jsii
-import publication
-import typing_extensions
+```
+declare const cluster: eks.FargateCluster;
+declare const domain: opensearch.Domain;
 
-from typeguard import check_type
+const logger = new k8s_aws.FargateLogger(this, 'logger', {
+    cluster: cluster,
+    fargateProfiles: [
+        cluster.defaultProfile
+    ],
+    outputs: [
+        k8s_aws.FluentBitOutput.opensearch(k8s_aws.FluentBitMatch.ALL, domain);
+    ]
+});
+```
 
-from .._jsii import *
+Filter out log messages matching the AWS load balancer health check user agent:
 
-import aws_cdk as _aws_cdk_ceddda9d
-import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
-import aws_cdk.aws_events as _aws_cdk_aws_events_ceddda9d
-import aws_cdk.aws_glue as _aws_cdk_aws_glue_ceddda9d
-import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
-import aws_cdk.aws_kms as _aws_cdk_aws_kms_ceddda9d
-import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
-import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
-import constructs as _constructs_77d1e7e8
+```
+declare const logger: k8s_aws.FargateLogger;
 
+logger.addFilter(k8s_aws.FluentBitFilter.grep(k8s_aws.FluentBitMatch.ALL, {
+    exclude: true,
+    key: 'log',
+    regex: 'ELB-HealthChecker'
+}));
+```
 
-class BookmarkConfiguration(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.BookmarkConfiguration",
-):
-    '''Controls the bookmark state of a Glue job.
+## Container Insights
 
-    :see: `Using job bookmarks in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html#monitor-continuations-implement>`_
-    '''
+[AWS Container Insights](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html) provides advanced diagnostic and performance metrics for your containerized applications running on AWS. For EKS cluster, Container Insights is provided by using [AWS Distro for OpenTelemetry](https://aws.amazon.com/blogs/containers/introducing-amazon-cloudwatch-container-insights-for-amazon-eks-fargate-using-aws-distro-for-opentelemetry/).
 
-    @jsii.member(jsii_name="disable")
-    @builtins.classmethod
-    def disable(cls) -> "BookmarkConfiguration":
-        '''Job bookmarks are not used, and the job always processes the entire dataset.
+To enable Container Insights for pods running on your EKS cluster:
 
-        You are responsible for managing the output from previous job
-        runs.
+```
+declare const cluster: eks.Cluster;
 
-        :return: A configuration object that disabled job bookmarks.
-        '''
-        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "disable", []))
+const collector = new k8s_aws.AdotCollector(this, 'adot-collector', {
+    cluster: cluster
+});
+```
 
-    @jsii.member(jsii_name="enable")
-    @builtins.classmethod
-    def enable(cls) -> "BookmarkConfiguration":
-        '''Causes the job to update the state after a run to keep track of previously processed data.
+## Route 53
 
-        If your job has a source with job bookmark support, it
-        will keep track of processed data, and when a job runs, it processes new
-        data since the last checkpoint.
+Enable management of Route 53 hosted zones for ingress and service hosts:
 
-        :return: A configuration object that enables job bookmarks.
-        '''
-        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "enable", []))
+```
+declare const cluster: eks.Cluster;
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(
-        cls,
-        value: builtins.str,
-        *,
-        from_: builtins.str,
-        to: builtins.str,
-    ) -> "BookmarkConfiguration":
-        '''An escape hatch method that allows specifying arbitrary values for the ``job-bookmark-option`` argument of a Glue job.
+const manager = new k8s_aws.Route53Dns(this, 'route53-dns', {
+    cluster: cluster
+});
+```
 
-        :param value: The value to pass to the ``job-bookmark-option`` argument.
-        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
-        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+Only enable managment of Route 53 DNS to only records that end with `example.com`:
 
-        :return:
+```
+declare const manager: k8s_aws.Route53Dns;
 
-        A configuration object that represents the provided bookmark
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b04343485dce8549add35ec976d45544630deb5d79090df76b4018e3f8074592)
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        range = BookmarkRange(from_=from_, to=to)
+manager.addDomainFilter('example.com');
+```
 
-        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "of", [value, range]))
+Only allow management for hosted zones that are tagged with `managed-dns=enabled`:
 
-    @jsii.member(jsii_name="pause")
-    @builtins.classmethod
-    def pause(cls, *, from_: builtins.str, to: builtins.str) -> "BookmarkConfiguration":
-        '''Process incremental data since the last successful run or the data in a specified range, without updating the state of last bookmark.
+```
+declare const manager: k8s_aws.Route53Dns;
 
-        You are
-        responsible for managing the output from previous job runs.
+manager.addZoneTag({
+    key: 'managed-dns',
+    value: 'enabled'
+});
+```
 
-        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
-        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+Only allow creates and updates of DNS records and not deletes:
 
-        :return: A configuration object that pauses job bookmarks.
-        '''
-        range = BookmarkRange(from_=from_, to=to)
+```
+declare const cluster: eks.Cluster;
 
-        return typing.cast("BookmarkConfiguration", jsii.sinvoke(cls, "pause", [range]))
+const manager = new k8s_aws.Route53Dns(this, 'route53-dns', {
+    cluster: cluster,
+    syncPolicy: ExternalDnsSyncPolicy.UPSERT_ONLY
+});
+```
 
-    @builtins.property
-    @jsii.member(jsii_name="value")
-    def value(self) -> builtins.str:
-        '''The value to pass to the ``job-bookmark-option`` argument.'''
-        return typing.cast(builtins.str, jsii.get(self, "value"))
+## Secrets Manager
 
-    @builtins.property
-    @jsii.member(jsii_name="range")
-    def range(self) -> typing.Optional["BookmarkRange"]:
-        '''An optional range of job ID's that will correspond to the ``job-bookmark-from`` and ``job-bookmark-to`` arguments.'''
-        return typing.cast(typing.Optional["BookmarkRange"], jsii.get(self, "range"))
+Enable synchronization of specific secret between Secrets Manager and Kubernetes:
 
+```
+declare const cluster: eks.Cluster;
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.BookmarkRange",
-    jsii_struct_bases=[],
-    name_mapping={"from_": "from", "to": "to"},
-)
-class BookmarkRange:
-    def __init__(self, *, from_: builtins.str, to: builtins.str) -> None:
-        '''A range of job run ID's that specify the job bookmark state of a Glue job which has had its bookmark state set to paused.
+const operator = new k8s_aws.ExternalSecretsOperator(this, 'external-secrets', {
+    cluster: cluster
+});
+```
 
-        :param from_: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input is ignored.
-        :param to: The run ID which represents all the input that was processed until the last successful run before and including the specified run ID. The corresponding input excluding the input identified by the {@link BookmarkRange.from | from} is processed by the job. Any input later than this input is also excluded for processing.
+To tell the external secrets operator to synchronise a secret:
 
-        :see: `Using job bookmarks in AWS Glue <https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html#monitor-continuations-implement>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2301b86dad3c792d837e86052ee0890dc5b59ce6914adc7fa3fd599e7ab75ccd)
-            check_type(argname="argument from_", value=from_, expected_type=type_hints["from_"])
-            check_type(argname="argument to", value=to, expected_type=type_hints["to"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "from_": from_,
-            "to": to,
-        }
+```
+declase const operator: k8s_aws.ExternalSecretsOperator;
+declare const secret: secretsmanager.Secret;
 
-    @builtins.property
-    def from_(self) -> builtins.str:
-        '''The run ID which represents all the input that was processed until the last successful run before and including the specified run ID.
+operator.registerSecretsManagerSecret('sychronized-secret', secret);
+```
 
-        The
-        corresponding input is ignored.
-        '''
-        result = self._values.get("from_")
-        assert result is not None, "Required property 'from_' is missing"
-        return typing.cast(builtins.str, result)
+Give the secret a human friendly name in Kubernetes:
 
-    @builtins.property
-    def to(self) -> builtins.str:
-        '''The run ID which represents all the input that was processed until the last successful run before and including the specified run ID.
+```
+declase const operator: k8s_aws.ExternalSecretsOperator;
+declare const secret: secretsmanager.Secret;
 
-        The
-        corresponding input excluding the input identified by the
-        {@link BookmarkRange.from | from} is processed by the job. Any input later
-        than this input is also excluded for processing.
-        '''
-        result = self._values.get("to")
-        assert result is not None, "Required property 'to' is missing"
-        return typing.cast(builtins.str, result)
+operator.registerSecretsManagerSecret('sychronized-secret', secret, {
+    name: 'database-secret'
+});
+```
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+Only import specific JSON keys from a secret:
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+```
+declase const operator: k8s_aws.ExternalSecretsOperator;
+declare const secret: secretsmanager.Secret;
 
-    def __repr__(self) -> str:
-        return "BookmarkRange(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+operator.registerSecretsManagerSecret('sychronized-secret', secret, {
+    fields: [
+        { kubernetesKey: 'username' },
+        { kubernetesKey: 'password' },
+    ]
+});
+```
 
+Map secret fields that need to be different between Secrets Manager and Kubernetes.
 
-class ClassificationString(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.ClassificationString",
-):
-    '''Classification string given to tables with this data format.
+```
+declase const operator: k8s_aws.ExternalSecretsOperator;
+declare const secret: secretsmanager.Secret;
 
-    :see: https://docs.aws.amazon.com/glue/latest/dg/add-classifier.html#classifier-built-in
-    '''
+operator.registerSecretsManagerSecret('sychronized-secret', secret, {
+    fields: [
+        {
+            kubernetesKey: 'user',
+            remoteKey: 'username',
+        },
+        {
+            kubernetesKey: 'pass',
+            remoteKey: 'password'
+        },
+    ]
+});
+```
 
-    def __init__(self, value: builtins.str) -> None:
-        '''
-        :param value: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0751f5d6215bb74e22139fe2149a7f9ee7de61eb00daa8638767d444fd2006ff)
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        jsii.create(self.__class__, self, [value])
+## Echoserver
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="AVRO")
-    def AVRO(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-avro
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "AVRO"))
+A basic Kubernetes test service that can be used for testing Kubernetes cluster integrations.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CSV")
-    def CSV(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-csv
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "CSV"))
+This is a simple HTTP service that listens for incoming requests and echo details of requests back to the user.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="JSON")
-    def JSON(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-json
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "JSON"))
+Log messages are produced for each request and provide a convenient way to test logging filter and output configurations.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ORC")
-    def ORC(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-orc
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "ORC"))
+To create an echoserver service:
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PARQUET")
-    def PARQUET(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-parquet
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "PARQUET"))
+```
+declare const cluster: eks.Cluster;
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="XML")
-    def XML(cls) -> "ClassificationString":
-        '''
-        :see: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-format.html#aws-glue-programming-etl-format-xml
-        '''
-        return typing.cast("ClassificationString", jsii.sget(cls, "XML"))
+const echoserver = new k8s_aws.Echoserver(this, 'echoserver', {
+    cluster: cluster
+});
+```
+'''
+import abc
+import builtins
+import datetime
+import enum
+import typing
 
-    @builtins.property
-    @jsii.member(jsii_name="value")
-    def value(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "value"))
+import jsii
+import publication
+import typing_extensions
 
+from typeguard import check_type
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.CloudWatchEncryption",
-    jsii_struct_bases=[],
-    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
+from .._jsii import *
+
+import aws_cdk as _aws_cdk_ceddda9d
+import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
+import aws_cdk.aws_eks as _aws_cdk_aws_eks_ceddda9d
+import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
+import aws_cdk.aws_kinesis as _aws_cdk_aws_kinesis_ceddda9d
+import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
+import aws_cdk.aws_opensearchservice as _aws_cdk_aws_opensearchservice_ceddda9d
+import aws_cdk.aws_secretsmanager as _aws_cdk_aws_secretsmanager_ceddda9d
+import aws_cdk.aws_ssm as _aws_cdk_aws_ssm_ceddda9d
+import constructs as _constructs_77d1e7e8
+from ..core import DataSize as _DataSize_d20aaece
+from ..kinesis_firehose import IDeliveryStream as _IDeliveryStream_cf5feed7
+from ..route53 import (
+    Domain as _Domain_165656f2,
+    DomainDiscovery as _DomainDiscovery_440eb9b9,
+    IDnsResolvable as _IDnsResolvable_adf49001,
 )
-class CloudWatchEncryption:
+
+
+class AdotCollector(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.AdotCollector",
+):
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        mode: "CloudWatchEncryptionMode",
-        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        create_namespace: typing.Optional[builtins.bool] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''CloudWatch Logs encryption configuration.
+        '''Creates a new instance of the AdotCollector class.
 
-        :param mode: Encryption mode.
-        :param kms_key: The KMS key to be used to encrypt the data. Default: A key will be created if one is not provided.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the ADOT Collector will be deployed.
+        :param create_namespace: Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to. Default: true
+        :param namespace: The Kubernetes namespace where resources related to the ADOT collector will be created. Default: {@link AdotCollector.DEFAULT_NAMESPACE}
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__057163656b87fc4eb457b7ce6af51ebca528e50d7d1d66f6c8cb0392e039ac1a)
-            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
-            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "mode": mode,
-        }
-        if kms_key is not None:
-            self._values["kms_key"] = kms_key
-
-    @builtins.property
-    def mode(self) -> "CloudWatchEncryptionMode":
-        '''Encryption mode.'''
-        result = self._values.get("mode")
-        assert result is not None, "Required property 'mode' is missing"
-        return typing.cast("CloudWatchEncryptionMode", result)
-
-    @builtins.property
-    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
-        '''The KMS key to be used to encrypt the data.
-
-        :default: A key will be created if one is not provided.
-        '''
-        result = self._values.get("kms_key")
-        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "CloudWatchEncryption(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
+            type_hints = typing.get_type_hints(_typecheckingstub__f74f3540f9b92e5b04d00972307fd2234b5b3488c35a04325788dc39ab7af1c1)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = AdotCollectorProps(
+            cluster=cluster,
+            create_namespace=create_namespace,
+            namespace=namespace,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
         )
 
+        jsii.create(self.__class__, self, [scope, id, props])
 
-@jsii.enum(jsii_type="cdk-extensions.glue.CloudWatchEncryptionMode")
-class CloudWatchEncryptionMode(enum.Enum):
-    '''Encryption mode for CloudWatch Logs.
-
-    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_CloudWatchEncryption.html#Glue-Type-CloudWatchEncryption-CloudWatchEncryptionMode
-    '''
-
-    KMS = "KMS"
-    '''Server-side encryption (SSE) with an AWS KMS key managed by the account owner.
-
-    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
-    '''
-
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
+    def DEFAULT_NAMESPACE(cls) -> builtins.str:
+        '''The default Kubernetes namespace where resources related to the ADOT collector will be created if no overriding input is provided.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
 
-class Code(metaclass=jsii.JSIIAbstractClass, jsii_type="cdk-extensions.glue.Code"):
-    '''Represents a Glue Job's Code assets (an asset can be a scripts, a jar, a python file or any other file).'''
+    @builtins.property
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the ADOT Collector will be deployed.
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
 
-    @jsii.member(jsii_name="fromAsset")
-    @builtins.classmethod
-    def from_asset(
-        cls,
-        path: builtins.str,
-        *,
-        asset_hash: typing.Optional[builtins.str] = None,
-        asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
-        bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
-    ) -> "AssetCode":
-        '''Job code from a local disk path.
+    @builtins.property
+    @jsii.member(jsii_name="createNamespace")
+    def create_namespace(self) -> builtins.bool:
+        '''Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to.
 
-        :param path: Code file (not a directory).
-        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
-        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
-        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__fe5f72a2d529dee4e5a4fd60ab73c3651fdb154cc1ac378fcf8a4c6cc14f7f47)
-            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
-        options = _aws_cdk_ceddda9d.AssetOptions(
-            asset_hash=asset_hash, asset_hash_type=asset_hash_type, bundling=bundling
-        )
-
-        return typing.cast("AssetCode", jsii.sinvoke(cls, "fromAsset", [path, options]))
+        return typing.cast(builtins.bool, jsii.get(self, "createNamespace"))
 
-    @jsii.member(jsii_name="fromBucket")
-    @builtins.classmethod
-    def from_bucket(
-        cls,
-        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
-        key: builtins.str,
-    ) -> "S3Code":
-        '''Job code as an S3 object.
+    @builtins.property
+    @jsii.member(jsii_name="manifest")
+    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
+        '''The Kubernetes manifest used to deploy the ADOT Collector.
 
-        :param bucket: The S3 bucket.
-        :param key: The object key.
+        :group: Resources
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0ae28ae94ca6a7f468c50a4d7ca53e509947843d875b01df05b54a3d3035fe76)
-            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("S3Code", jsii.sinvoke(cls, "fromBucket", [bucket, key]))
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
 
-    @jsii.member(jsii_name="bind")
-    @abc.abstractmethod
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
-    ) -> "CodeConfig":
-        '''Called when the Job is initialized to allow this object to bind.
+    @builtins.property
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> builtins.str:
+        '''The Kubernetes namespace where resources related to the ADOT collector will be created.
 
-        :param scope: -
-        :param grantable: -
+        :group: Inputs
         '''
-        ...
+        return typing.cast(builtins.str, jsii.get(self, "namespace"))
 
+    @builtins.property
+    @jsii.member(jsii_name="serviceAccount")
+    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
+        '''The Kubernetes service account that allows the ADOT collector to gather metric information and publish it to CloudWatch.
 
-class _CodeProxy(Code):
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
-    ) -> "CodeConfig":
-        '''Called when the Job is initialized to allow this object to bind.
-
-        :param scope: -
-        :param grantable: -
+        :group: Resources
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__29827b2153002e81b9ff9677022a59a77e67b7c0083100827663e2e422bda0db)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
-        return typing.cast("CodeConfig", jsii.invoke(self, "bind", [scope, grantable]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, Code).__jsii_proxy_class__ = lambda : _CodeProxy
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.CodeConfig",
-    jsii_struct_bases=[],
-    name_mapping={"s3_location": "s3Location"},
+    jsii_type="cdk-extensions.k8s_aws.AdotCollectorProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "cluster": "cluster",
+        "create_namespace": "createNamespace",
+        "namespace": "namespace",
+    },
 )
-class CodeConfig:
+class AdotCollectorProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        s3_location: typing.Union[_aws_cdk_aws_s3_ceddda9d.Location, typing.Dict[builtins.str, typing.Any]],
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        create_namespace: typing.Optional[builtins.bool] = None,
+        namespace: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Result of binding ``Code`` into a ``Job``.
+        '''Condifuration for the AdorCollector resource.
 
-        :param s3_location: The location of the code in S3.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param cluster: The EKS cluster where the ADOT Collector will be deployed.
+        :param create_namespace: Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to. Default: true
+        :param namespace: The Kubernetes namespace where resources related to the ADOT collector will be created. Default: {@link AdotCollector.DEFAULT_NAMESPACE}
         '''
-        if isinstance(s3_location, dict):
-            s3_location = _aws_cdk_aws_s3_ceddda9d.Location(**s3_location)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f929a25191cf84849ac8dc0774c3d7cb58e7913b1ffa7fc2fbca5cb55667291c)
-            check_type(argname="argument s3_location", value=s3_location, expected_type=type_hints["s3_location"])
+            type_hints = typing.get_type_hints(_typecheckingstub__83410ce825ec752c0effc192594680947acd69763ae265765f04ad25b86fed2c)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument create_namespace", value=create_namespace, expected_type=type_hints["create_namespace"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "s3_location": s3_location,
+            "cluster": cluster,
         }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if create_namespace is not None:
+            self._values["create_namespace"] = create_namespace
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
-    def s3_location(self) -> _aws_cdk_aws_s3_ceddda9d.Location:
-        '''The location of the code in S3.'''
-        result = self._values.get("s3_location")
-        assert result is not None, "Required property 's3_location' is missing"
-        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Location, result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-    def __repr__(self) -> str:
-        return "CodeConfig(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-class Column(metaclass=jsii.JSIIAbstractClass, jsii_type="cdk-extensions.glue.Column"):
-    def __init__(
-        self,
-        *,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''
-        :param comment: 
-        :param name: 
-        '''
-        props = ColumnProps(comment=comment, name=name)
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        jsii.create(self.__class__, self, [props])
+        Cannot be supplied together with either ``account`` or ``region``.
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTable.ColumnProperty:
-        '''
-        :param scope: -
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__444e4405d6fa32714b3fa80c1a990dc679108d516ba2f551601636ba37108c5e)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTable.ColumnProperty, jsii.invoke(self, "bind", [scope]))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="typeString")
-    @abc.abstractmethod
-    def type_string(self) -> builtins.str:
-        ...
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @builtins.property
-    @jsii.member(jsii_name="comment")
-    def comment(self) -> typing.Optional[builtins.str]:
-        '''A free-form text comment.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :see: `AWS::Glue::Table Column <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-column.html#cfn-glue-table-column-comment>`_
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "comment"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Column.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :see: `AWS::Glue::Table Column <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-column.html#cfn-glue-table-column-name>`_
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
-
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-class _ColumnProxy(Column):
     @builtins.property
-    @jsii.member(jsii_name="typeString")
-    def type_string(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "typeString"))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, Column).__jsii_proxy_class__ = lambda : _ColumnProxy
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the ADOT Collector will be deployed.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
+    @builtins.property
+    def create_namespace(self) -> typing.Optional[builtins.bool]:
+        '''Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.ColumnProps",
-    jsii_struct_bases=[],
-    name_mapping={"comment": "comment", "name": "name"},
-)
-class ColumnProps:
-    def __init__(
-        self,
-        *,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''
-        :param comment: 
-        :param name: 
+        :default: true
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2acc8cf451159a8d67a7210893d3fff8ebd56626ab3a55b71a5a7d60b58fa6f2)
-            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if comment is not None:
-            self._values["comment"] = comment
-        if name is not None:
-            self._values["name"] = name
+        result = self._values.get("create_namespace")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def comment(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("comment")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where resources related to the ADOT collector will be created.
 
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
+        :default: {@link AdotCollector.DEFAULT_NAMESPACE}
+        '''
+        result = self._values.get("namespace")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "ColumnProps(%s)" % ", ".join(
+        return "AdotCollectorProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.ConfigurationVersion")
-class ConfigurationVersion(enum.Enum):
-    V1_0 = "V1_0"
-
-
-@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IConnectable)
-class Connection(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Connection",
-):
-    '''Creates a resource specifying a Glue Connection to a data source.
-
-    :see: `AWS::Glue::Connection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html>`_
-    '''
-
-    def __init__(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
-        *,
-        connection_type: "ConnectionType",
-        description: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the Connection class.
-
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param connection_type: The type of the connection.
-        :param description: A description for the Connection.
-        :param name: The name of the connection. Connection will not function as expected without a name.
-        :param properties: List of Key/Value pairs defining the properties of the Connection.
-        :param security_groups: Existing Security Group to assign to the Connection. If none is provided a new Security Group will be created.
-        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
-        :param vpc: VPC to attach to the Connection.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__023b7dc3d20f72ca57c6c81f464fce932d96d952762ad3a3710109c3be2e676c)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = ConnectionProps(
-            connection_type=connection_type,
-            description=description,
-            name=name,
-            properties=properties,
-            security_groups=security_groups,
-            subnets=subnets,
-            vpc=vpc,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        jsii.create(self.__class__, self, [scope, id, props])
-
-    @jsii.member(jsii_name="addMatchCriteria")
-    def add_match_criteria(self, value: builtins.str) -> None:
-        '''
-        :param value: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a45f2c7f57ece25b2ed1a81fd7f6d3d5c0fe1afcbef8310db8d03a698c138480)
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addMatchCriteria", [value]))
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.AppendedRecord",
+    jsii_struct_bases=[],
+    name_mapping={"field_name": "fieldName", "value": "value"},
+)
+class AppendedRecord:
+    def __init__(self, *, field_name: builtins.str, value: builtins.str) -> None:
+        '''Represents a record field to be added by the record modifier Fluent Bit filter plugin.
 
-    @jsii.member(jsii_name="addProperty")
-    def add_property(self, key: builtins.str, value: builtins.str) -> None:
-        '''
-        :param key: -
-        :param value: -
+        :param field_name: The name of the field to be added.
+        :param value: The value that the added field should be set to.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1eee3a4bfe7ee7514d7510a9f817a30f05617f0049f9d10ada9cc135e1b8ab26)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            type_hints = typing.get_type_hints(_typecheckingstub__136b7ffe7a51d2c8e1beb7845cc437b6f9c909db4c6852bf9306bb992440df64)
+            check_type(argname="argument field_name", value=field_name, expected_type=type_hints["field_name"])
             check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addProperty", [key, value]))
-
-    @builtins.property
-    @jsii.member(jsii_name="connectionArn")
-    def connection_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "connectionArn"))
-
-    @builtins.property
-    @jsii.member(jsii_name="connectionName")
-    def connection_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "connectionName"))
-
-    @builtins.property
-    @jsii.member(jsii_name="connections")
-    def connections(self) -> _aws_cdk_aws_ec2_ceddda9d.Connections:
-        '''The network connections associated with this resource.'''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Connections, jsii.get(self, "connections"))
-
-    @builtins.property
-    @jsii.member(jsii_name="connectionType")
-    def connection_type(self) -> "ConnectionType":
-        '''{@link ConnectionProps.connectionType:}.'''
-        return typing.cast("ConnectionType", jsii.get(self, "connectionType"))
-
-    @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnConnection:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnConnection, jsii.get(self, "resource"))
-
-    @builtins.property
-    @jsii.member(jsii_name="securityGroups")
-    def security_groups(self) -> typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]:
-        '''{@link ConnectionProps.securityGroups:}.'''
-        return typing.cast(typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup], jsii.get(self, "securityGroups"))
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "field_name": field_name,
+            "value": value,
+        }
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link ConnectionProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    def field_name(self) -> builtins.str:
+        '''The name of the field to be added.'''
+        result = self._values.get("field_name")
+        assert result is not None, "Required property 'field_name' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link ConnectionProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    def value(self) -> builtins.str:
+        '''The value that the added field should be set to.'''
+        result = self._values.get("value")
+        assert result is not None, "Required property 'value' is missing"
+        return typing.cast(builtins.str, result)
 
-    @builtins.property
-    @jsii.member(jsii_name="securityGroup")
-    def security_group(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SecurityGroup]:
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SecurityGroup], jsii.get(self, "securityGroup"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="subnets")
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''{@link ConnectionProps.subnets}.'''
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], jsii.get(self, "subnets"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="vpc")
-    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
-        '''{@link ConnectionProps.vpc}.'''
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], jsii.get(self, "vpc"))
+    def __repr__(self) -> str:
+        return "AppendedRecord(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.ConnectionProps",
+    jsii_type="cdk-extensions.k8s_aws.AwsSecretStoreProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "connection_type": "connectionType",
-        "description": "description",
+        "cluster": "cluster",
+        "service": "service",
         "name": "name",
-        "properties": "properties",
-        "security_groups": "securityGroups",
-        "subnets": "subnets",
-        "vpc": "vpc",
+        "namespace": "namespace",
     },
 )
-class ConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
+class AwsSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        connection_type: "ConnectionType",
-        description: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        service: builtins.str,
         name: typing.Optional[builtins.str] = None,
-        properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
+        namespace: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the Glue Workflow resource.
+        '''Configuration options for adding a new secret store resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param connection_type: The type of the connection.
-        :param description: A description for the Connection.
-        :param name: The name of the connection. Connection will not function as expected without a name.
-        :param properties: List of Key/Value pairs defining the properties of the Connection.
-        :param security_groups: Existing Security Group to assign to the Connection. If none is provided a new Security Group will be created.
-        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
-        :param vpc: VPC to attach to the Connection.
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param service: The name of the service provider backing the secret store.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         '''
-        if isinstance(subnets, dict):
-            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0af32a3c84c0678710e524ede720205f2f84097eea14da00eb58b5d5f043557b)
+            type_hints = typing.get_type_hints(_typecheckingstub__47bd0514e52ab251753fed926ac3aec8ea7a2344e24eb13a2eeacbcf646482c3)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
-            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
-            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "connection_type": connection_type,
+            "cluster": cluster,
+            "service": service,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if description is not None:
-            self._values["description"] = description
         if name is not None:
             self._values["name"] = name
-        if properties is not None:
-            self._values["properties"] = properties
-        if security_groups is not None:
-            self._values["security_groups"] = security_groups
-        if subnets is not None:
-            self._values["subnets"] = subnets
-        if vpc is not None:
-            self._values["vpc"] = vpc
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -882,405 +667,387 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def connection_type(self) -> "ConnectionType":
-        '''The type of the connection.
-
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
-        '''
-        result = self._values.get("connection_type")
-        assert result is not None, "Required property 'connection_type' is missing"
-        return typing.cast("ConnectionType", result)
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret store should be created.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
     @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description for the Connection.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def service(self) -> builtins.str:
+        '''The name of the service provider backing the secret store.'''
+        result = self._values.get("service")
+        assert result is not None, "Required property 'service' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
     def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the connection.
-
-        Connection will not function as expected without a name.
-
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-name>`_
-        '''
+        '''A human friendly name for the secret store.'''
         result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''List of Key/Value pairs defining the properties of the Connection.
-
-        :see: `AWS::Glue::Connection Properties <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html#Properties>`_
-        '''
-        result = self._values.get("properties")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
-
-    @builtins.property
-    def security_groups(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
-        '''Existing Security Group to assign to the Connection.
-
-        If none is provided a new Security Group will be created.
-        '''
-        result = self._values.get("security_groups")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
-
-    @builtins.property
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''Options for selection of subnets from the VPC to attach to the Connection.
-
-        :see: `CDK SubnetSelection <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.SubnetSelection.html>`_
-        '''
-        result = self._values.get("subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
-
-    @builtins.property
-    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
-        '''VPC to attach to the Connection.
-
-        :see: `IVpc Interface <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.IVpc.html>`_
-        '''
-        result = self._values.get("vpc")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], result)
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the secret store should be created.'''
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "ConnectionProps(%s)" % ", ".join(
+        return "AwsSecretStoreProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.ConnectionType")
-class ConnectionType(enum.Enum):
-    JDBC = "JDBC"
-    '''JDBC - Designates a connection to a database through Java Database Connectivity (JDBC).'''
-    KAFKA = "KAFKA"
-    '''KAFKA - Designates a connection to an Apache Kafka streaming platform.'''
-    MONGODB = "MONGODB"
-    '''MONGODB - Designates a connection to a MongoDB document database.'''
-    NETWORK = "NETWORK"
-    '''NETWORK - Designates a network connection to a data source within an Amazon Virtual Private Cloud environment (Amazon VPC).'''
+@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IConnectable, _IDnsResolvable_adf49001)
+class Echoserver(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.Echoserver",
+):
+    '''Creates a simple Kubernetes test service using the Google echoserver test image.
 
+    The server listens for incoming web requests and echos the details of the
+    request back to the user. Each request results in output being written to
+    the Docker log providing a convenient way to test logging setup.
+
+    :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
+    '''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.ContinuousLoggingProps",
-    jsii_struct_bases=[],
-    name_mapping={
-        "enabled": "enabled",
-        "conversion_pattern": "conversionPattern",
-        "log_group": "logGroup",
-        "log_stream_prefix": "logStreamPrefix",
-        "quiet": "quiet",
-    },
-)
-class ContinuousLoggingProps:
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        enabled: builtins.bool,
-        conversion_pattern: typing.Optional[builtins.str] = None,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        log_stream_prefix: typing.Optional[builtins.str] = None,
-        quiet: typing.Optional[builtins.bool] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
+        load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replicas: typing.Optional[jsii.Number] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subdomain: typing.Optional[builtins.str] = None,
+        tag: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
     ) -> None:
+        '''Creates a new instance of the Echoserver class.
+
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS Cluster where the service should be deployed.
+        :param domain_discovery: Determines the behavior of automatic DNS discovery and configuration. Default: DomainDiscovery.PUBLIC
+        :param load_balancer_subnets: The subnets where the load balancer should be created.
+        :param name: The name of the Kubernetes service to be created. Default: 'echoserver'
+        :param namespace: The Kubernetes namespace where the service should be created. Default: 'default'
+        :param port: The port which netcat should listen on. Default: 80
+        :param replicas: The number of replicas that should exist. Default: 1
+        :param security_groups: The Security groups which should be applied to the service.
+        :param subdomain: A subdomain that should be prefixed to the beginning of all registered domains.
+        :param tag: The Docker tag specifying the version of echoserver to use.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        :param enabled: Enable continouous logging.
-        :param conversion_pattern: Apply the provided conversion pattern. This is a Log4j Conversion Pattern to customize driver and executor logs. Default: ``%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n``
-        :param log_group: Specify a custom CloudWatch log group name. Default: - a log group is created with name ``/aws-glue/jobs/logs-v2/``.
-        :param log_stream_prefix: Specify a custom CloudWatch log stream prefix. Default: - the job run ID.
-        :param quiet: Filter out non-useful Apache Spark driver/executor and Apache Hadoop YARN heartbeat log messages. Default: true
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__60e02c2df9c0996603c08992bffb8b230ed1d150d3db1a8f557f6056710b9fda)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = EchoserverProps(
+            cluster=cluster,
+            domain_discovery=domain_discovery,
+            load_balancer_subnets=load_balancer_subnets,
+            name=name,
+            namespace=namespace,
+            port=port,
+            replicas=replicas,
+            security_groups=security_groups,
+            subdomain=subdomain,
+            tag=tag,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="registerDomain")
+    def register_domain(self, domain: _Domain_165656f2) -> None:
+        '''
+        :param domain: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c8560efd79afaf7b7778442a94c024de5f4c8f79564e4c191018f7871c34b5e6)
-            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
-            check_type(argname="argument conversion_pattern", value=conversion_pattern, expected_type=type_hints["conversion_pattern"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument log_stream_prefix", value=log_stream_prefix, expected_type=type_hints["log_stream_prefix"])
-            check_type(argname="argument quiet", value=quiet, expected_type=type_hints["quiet"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "enabled": enabled,
-        }
-        if conversion_pattern is not None:
-            self._values["conversion_pattern"] = conversion_pattern
-        if log_group is not None:
-            self._values["log_group"] = log_group
-        if log_stream_prefix is not None:
-            self._values["log_stream_prefix"] = log_stream_prefix
-        if quiet is not None:
-            self._values["quiet"] = quiet
+            type_hints = typing.get_type_hints(_typecheckingstub__03259ca27e67ce6d4b989554c5fe17209a196689cf650ff94b81215ab7406124)
+            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
+        return typing.cast(None, jsii.invoke(self, "registerDomain", [domain]))
 
-    @builtins.property
-    def enabled(self) -> builtins.bool:
-        '''Enable continouous logging.'''
-        result = self._values.get("enabled")
-        assert result is not None, "Required property 'enabled' is missing"
-        return typing.cast(builtins.bool, result)
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_DOMAIN_DISCOVERY")
+    def DEFAULT_DOMAIN_DISCOVERY(cls) -> _DomainDiscovery_440eb9b9:
+        '''The default setting controlling how automatic DNS configuration should behave if none is provided as input.'''
+        return typing.cast(_DomainDiscovery_440eb9b9, jsii.sget(cls, "DEFAULT_DOMAIN_DISCOVERY"))
 
-    @builtins.property
-    def conversion_pattern(self) -> typing.Optional[builtins.str]:
-        '''Apply the provided conversion pattern.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_LOAD_BALANCER_SUBNETS")
+    def DEFAULT_LOAD_BALANCER_SUBNETS(cls) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
+        '''Default subnet selection that will be used if none is provided as input.'''
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.sget(cls, "DEFAULT_LOAD_BALANCER_SUBNETS"))
 
-        This is a Log4j Conversion Pattern to customize driver and executor logs.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_NAME")
+    def DEFAULT_NAME(cls) -> builtins.str:
+        '''Default name of the Kubernetes service that will be created if none is provided as input.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAME"))
 
-        :default: ``%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n``
-        '''
-        result = self._values.get("conversion_pattern")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
+    def DEFAULT_NAMESPACE(cls) -> builtins.str:
+        '''Default Kubernetes namespace where the service will be created if none is provided as input.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_PORT")
+    def DEFAULT_PORT(cls) -> jsii.Number:
+        '''Default port where the service will be accessible if none is provided as input.'''
+        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_PORT"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_REPLICAS")
+    def DEFAULT_REPLICAS(cls) -> jsii.Number:
+        '''Default number of replicas that should be running is none is provided as input.'''
+        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_REPLICAS"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_REPOSITORY")
+    def DEFAULT_REPOSITORY(cls) -> builtins.str:
+        '''The Docker repository where the echoserver image will be pulled from.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_REPOSITORY"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_TAG")
+    def DEFAULT_TAG(cls) -> builtins.str:
+        '''The default Docker tag of the image to use if none is provided as input.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_TAG"))
 
     @builtins.property
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        '''Specify a custom CloudWatch log group name.
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS Cluster where the service should be deployed.
 
-        :default: - a log group is created with name ``/aws-glue/jobs/logs-v2/``.
+        :group: Inputs
         '''
-        result = self._values.get("log_group")
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
 
     @builtins.property
-    def log_stream_prefix(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom CloudWatch log stream prefix.
+    @jsii.member(jsii_name="connections")
+    def connections(self) -> _aws_cdk_aws_ec2_ceddda9d.Connections:
+        '''Access for network connections.
 
-        :default: - the job run ID.
+        :group: IConnectable
         '''
-        result = self._values.get("log_stream_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Connections, jsii.get(self, "connections"))
 
     @builtins.property
-    def quiet(self) -> typing.Optional[builtins.bool]:
-        '''Filter out non-useful Apache Spark driver/executor and Apache Hadoop YARN heartbeat log messages.
+    @jsii.member(jsii_name="domainDiscovery")
+    def domain_discovery(self) -> _DomainDiscovery_440eb9b9:
+        '''Determines the behavior of automatic DNS discovery and configuration.
 
-        :default: true
+        :group: IDnsResolvable
         '''
-        result = self._values.get("quiet")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+        return typing.cast(_DomainDiscovery_440eb9b9, jsii.get(self, "domainDiscovery"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="loadBalancerSubnets")
+    def load_balancer_subnets(self) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
+        '''The subnets where the load balancer should be created..
 
-    def __repr__(self) -> str:
-        return "ContinuousLoggingProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.get(self, "loadBalancerSubnets"))
 
+    @builtins.property
+    @jsii.member(jsii_name="manifest")
+    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
+        '''The Kubernetes manifest that creates the ConfigMap that Fargate uses to configure logging.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.CrawlerConfiguration",
-    jsii_struct_bases=[],
-    name_mapping={
-        "partition_update_behavior": "partitionUpdateBehavior",
-        "table_grouping_policy": "tableGroupingPolicy",
-        "table_level": "tableLevel",
-        "table_update_behavior": "tableUpdateBehavior",
-        "version": "version",
-    },
-)
-class CrawlerConfiguration:
-    def __init__(
-        self,
-        *,
-        partition_update_behavior: typing.Optional["PartitionUpdateBehavior"] = None,
-        table_grouping_policy: typing.Optional["TableGroupingPolicy"] = None,
-        table_level: typing.Optional[jsii.Number] = None,
-        table_update_behavior: typing.Optional["TableUpdateBehavior"] = None,
-        version: typing.Optional[ConfigurationVersion] = None,
-    ) -> None:
+        :group: Resources
         '''
-        :param partition_update_behavior: 
-        :param table_grouping_policy: 
-        :param table_level: 
-        :param table_update_behavior: 
-        :param version: 
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the Kubernetes service to be created.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__51a7512576b1965463466002ce33610505de95eb6d8629c5243e563c30f4f20f)
-            check_type(argname="argument partition_update_behavior", value=partition_update_behavior, expected_type=type_hints["partition_update_behavior"])
-            check_type(argname="argument table_grouping_policy", value=table_grouping_policy, expected_type=type_hints["table_grouping_policy"])
-            check_type(argname="argument table_level", value=table_level, expected_type=type_hints["table_level"])
-            check_type(argname="argument table_update_behavior", value=table_update_behavior, expected_type=type_hints["table_update_behavior"])
-            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if partition_update_behavior is not None:
-            self._values["partition_update_behavior"] = partition_update_behavior
-        if table_grouping_policy is not None:
-            self._values["table_grouping_policy"] = table_grouping_policy
-        if table_level is not None:
-            self._values["table_level"] = table_level
-        if table_update_behavior is not None:
-            self._values["table_update_behavior"] = table_update_behavior
-        if version is not None:
-            self._values["version"] = version
-
-    @builtins.property
-    def partition_update_behavior(self) -> typing.Optional["PartitionUpdateBehavior"]:
-        result = self._values.get("partition_update_behavior")
-        return typing.cast(typing.Optional["PartitionUpdateBehavior"], result)
-
-    @builtins.property
-    def table_grouping_policy(self) -> typing.Optional["TableGroupingPolicy"]:
-        result = self._values.get("table_grouping_policy")
-        return typing.cast(typing.Optional["TableGroupingPolicy"], result)
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
     @builtins.property
-    def table_level(self) -> typing.Optional[jsii.Number]:
-        result = self._values.get("table_level")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> builtins.str:
+        '''The Kubernetes namespace where the service should be created.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "namespace"))
 
     @builtins.property
-    def table_update_behavior(self) -> typing.Optional["TableUpdateBehavior"]:
-        result = self._values.get("table_update_behavior")
-        return typing.cast(typing.Optional["TableUpdateBehavior"], result)
+    @jsii.member(jsii_name="port")
+    def port(self) -> jsii.Number:
+        '''The port which netcat should listen on.
+
+        :group: Inputs
+        '''
+        return typing.cast(jsii.Number, jsii.get(self, "port"))
 
     @builtins.property
-    def version(self) -> typing.Optional[ConfigurationVersion]:
-        result = self._values.get("version")
-        return typing.cast(typing.Optional[ConfigurationVersion], result)
+    @jsii.member(jsii_name="replicas")
+    def replicas(self) -> jsii.Number:
+        '''The number of replicas that should exist.
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+        :group: Inputs
+        '''
+        return typing.cast(jsii.Number, jsii.get(self, "replicas"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="tag")
+    def tag(self) -> builtins.str:
+        '''The Docker tag specifying the version of echoserver to use.
 
-    def __repr__(self) -> str:
-        return "CrawlerConfiguration(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "tag"))
+
+    @builtins.property
+    @jsii.member(jsii_name="subdomain")
+    def subdomain(self) -> typing.Optional[builtins.str]:
+        '''A subdomain that should be prefixed to the beginning of all registered domains.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subdomain"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.CrawlerProps",
+    jsii_type="cdk-extensions.k8s_aws.EchoserverProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "classifiers": "classifiers",
-        "configuration": "configuration",
-        "database": "database",
-        "delete_behavior": "deleteBehavior",
-        "description": "description",
+        "cluster": "cluster",
+        "domain_discovery": "domainDiscovery",
+        "load_balancer_subnets": "loadBalancerSubnets",
         "name": "name",
-        "recrawl_behavior": "recrawlBehavior",
-        "schedule_expression": "scheduleExpression",
-        "security_configuration": "securityConfiguration",
-        "table_prefix": "tablePrefix",
-        "targets": "targets",
-        "update_behavior": "updateBehavior",
+        "namespace": "namespace",
+        "port": "port",
+        "replicas": "replicas",
+        "security_groups": "securityGroups",
+        "subdomain": "subdomain",
+        "tag": "tag",
     },
 )
-class CrawlerProps(_aws_cdk_ceddda9d.ResourceProps):
+class EchoserverProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
-        configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
-        database: typing.Optional["Database"] = None,
-        delete_behavior: typing.Optional["DeleteBehavior"] = None,
-        description: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
+        load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
         name: typing.Optional[builtins.str] = None,
-        recrawl_behavior: typing.Optional["RecrawlBehavior"] = None,
-        schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        security_configuration: typing.Optional["SecurityConfiguration"] = None,
-        table_prefix: typing.Optional[builtins.str] = None,
-        targets: typing.Optional[typing.Sequence["ICrawlerTarget"]] = None,
-        update_behavior: typing.Optional["UpdateBehavior"] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replicas: typing.Optional[jsii.Number] = None,
+        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+        subdomain: typing.Optional[builtins.str] = None,
+        tag: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for Crawler.
+        '''Configuration for the Echoserver resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param classifiers: A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
-        :param configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
-        :param database: The {@link aws-glue.Database | Database } object in which the crawler's output is stored.
-        :param delete_behavior: The deletion behavior when the crawler finds a deleted object.
-        :param description: Description of the Crawler.
-        :param name: Name of the Crawler.
-        :param recrawl_behavior: When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
-        :param schedule_expression: For scheduled crawlers, the schedule when the crawler runs.
-        :param security_configuration: A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.
-        :param table_prefix: The prefix added to the names of tables that are created.
-        :param targets: A collection of targets to crawl.
-        :param update_behavior: The update behavior when the crawler finds a changed schema.
+        :param cluster: The EKS Cluster where the service should be deployed.
+        :param domain_discovery: Determines the behavior of automatic DNS discovery and configuration. Default: DomainDiscovery.PUBLIC
+        :param load_balancer_subnets: The subnets where the load balancer should be created.
+        :param name: The name of the Kubernetes service to be created. Default: 'echoserver'
+        :param namespace: The Kubernetes namespace where the service should be created. Default: 'default'
+        :param port: The port which netcat should listen on. Default: 80
+        :param replicas: The number of replicas that should exist. Default: 1
+        :param security_groups: The Security groups which should be applied to the service.
+        :param subdomain: A subdomain that should be prefixed to the beginning of all registered domains.
+        :param tag: The Docker tag specifying the version of echoserver to use.
         '''
-        if isinstance(configuration, dict):
-            configuration = CrawlerConfiguration(**configuration)
+        if isinstance(load_balancer_subnets, dict):
+            load_balancer_subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**load_balancer_subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2280b17fb14a2d4a9a875511f4dcee118bd04236b81ae5e543e8502074f74f5c)
+            type_hints = typing.get_type_hints(_typecheckingstub__cabc692f43b347b0dcc6dbe743c4a7fac3e1c95cc035ff3ff3ef2509fdef86f5)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument classifiers", value=classifiers, expected_type=type_hints["classifiers"])
-            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
-            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
-            check_type(argname="argument delete_behavior", value=delete_behavior, expected_type=type_hints["delete_behavior"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument domain_discovery", value=domain_discovery, expected_type=type_hints["domain_discovery"])
+            check_type(argname="argument load_balancer_subnets", value=load_balancer_subnets, expected_type=type_hints["load_balancer_subnets"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument recrawl_behavior", value=recrawl_behavior, expected_type=type_hints["recrawl_behavior"])
-            check_type(argname="argument schedule_expression", value=schedule_expression, expected_type=type_hints["schedule_expression"])
-            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
-            check_type(argname="argument table_prefix", value=table_prefix, expected_type=type_hints["table_prefix"])
-            check_type(argname="argument targets", value=targets, expected_type=type_hints["targets"])
-            check_type(argname="argument update_behavior", value=update_behavior, expected_type=type_hints["update_behavior"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
+            check_type(argname="argument replicas", value=replicas, expected_type=type_hints["replicas"])
+            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
+            check_type(argname="argument subdomain", value=subdomain, expected_type=type_hints["subdomain"])
+            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "cluster": cluster,
+        }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if classifiers is not None:
-            self._values["classifiers"] = classifiers
-        if configuration is not None:
-            self._values["configuration"] = configuration
-        if database is not None:
-            self._values["database"] = database
-        if delete_behavior is not None:
-            self._values["delete_behavior"] = delete_behavior
-        if description is not None:
-            self._values["description"] = description
+        if domain_discovery is not None:
+            self._values["domain_discovery"] = domain_discovery
+        if load_balancer_subnets is not None:
+            self._values["load_balancer_subnets"] = load_balancer_subnets
         if name is not None:
             self._values["name"] = name
-        if recrawl_behavior is not None:
-            self._values["recrawl_behavior"] = recrawl_behavior
-        if schedule_expression is not None:
-            self._values["schedule_expression"] = schedule_expression
-        if security_configuration is not None:
-            self._values["security_configuration"] = security_configuration
-        if table_prefix is not None:
-            self._values["table_prefix"] = table_prefix
-        if targets is not None:
-            self._values["targets"] = targets
-        if update_behavior is not None:
-            self._values["update_behavior"] = update_behavior
+        if namespace is not None:
+            self._values["namespace"] = namespace
+        if port is not None:
+            self._values["port"] = port
+        if replicas is not None:
+            self._values["replicas"] = replicas
+        if security_groups is not None:
+            self._values["security_groups"] = security_groups
+        if subdomain is not None:
+            self._values["subdomain"] = subdomain
+        if tag is not None:
+            self._values["tag"] = tag
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -1322,590 +1089,735 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def classifiers(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
-
-        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-classifiers>`_
-        '''
-        result = self._values.get("classifiers")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS Cluster where the service should be deployed.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
     @builtins.property
-    def configuration(self) -> typing.Optional[CrawlerConfiguration]:
-        '''Crawler configuration information.
-
-        This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
+    def domain_discovery(self) -> typing.Optional[_DomainDiscovery_440eb9b9]:
+        '''Determines the behavior of automatic DNS discovery and configuration.
 
-        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-configuration>`_
+        :default: DomainDiscovery.PUBLIC
         '''
-        result = self._values.get("configuration")
-        return typing.cast(typing.Optional[CrawlerConfiguration], result)
+        result = self._values.get("domain_discovery")
+        return typing.cast(typing.Optional[_DomainDiscovery_440eb9b9], result)
 
     @builtins.property
-    def database(self) -> typing.Optional["Database"]:
-        '''The {@link aws-glue.Database | Database } object in which the crawler's output is stored.'''
-        result = self._values.get("database")
-        return typing.cast(typing.Optional["Database"], result)
+    def load_balancer_subnets(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''The subnets where the load balancer should be created.'''
+        result = self._values.get("load_balancer_subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
 
     @builtins.property
-    def delete_behavior(self) -> typing.Optional["DeleteBehavior"]:
-        '''The deletion behavior when the crawler finds a deleted object.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Kubernetes service to be created.
 
-        :see: `AWS::Glue::Crawler SchemaChangePolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schemachangepolicy.html#cfn-glue-crawler-schemachangepolicy-deletebehavior>`_
+        :default: 'echoserver'
         '''
-        result = self._values.get("delete_behavior")
-        return typing.cast(typing.Optional["DeleteBehavior"], result)
-
-    @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''Description of the Crawler.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''Name of the Crawler.'''
         result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def recrawl_behavior(self) -> typing.Optional["RecrawlBehavior"]:
-        '''When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the service should be created.
 
-        :see: `AWS::Glue::Crawler RecrawlPolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-recrawlpolicy.html>`_
+        :default: 'default'
         '''
-        result = self._values.get("recrawl_behavior")
-        return typing.cast(typing.Optional["RecrawlBehavior"], result)
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def schedule_expression(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
-        '''For scheduled crawlers, the schedule when the crawler runs.
+    def port(self) -> typing.Optional[jsii.Number]:
+        '''The port which netcat should listen on.
 
-        :see: `AWS::Glue::Crawler Schedule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schedule.html>`_
+        :default: 80
         '''
-        result = self._values.get("schedule_expression")
-        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
-
-    @builtins.property
-    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
-        '''A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.'''
-        result = self._values.get("security_configuration")
-        return typing.cast(typing.Optional["SecurityConfiguration"], result)
+        result = self._values.get("port")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def table_prefix(self) -> typing.Optional[builtins.str]:
-        '''The prefix added to the names of tables that are created.
+    def replicas(self) -> typing.Optional[jsii.Number]:
+        '''The number of replicas that should exist.
 
-        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-tableprefix>`_
+        :default: 1
         '''
-        result = self._values.get("table_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("replicas")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def targets(self) -> typing.Optional[typing.List["ICrawlerTarget"]]:
-        '''A collection of targets to crawl.
+    def security_groups(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
+        '''The Security groups which should be applied to the service.'''
+        result = self._values.get("security_groups")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
 
-        :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html#cfn-glue-crawler-targets>`_
-        '''
-        result = self._values.get("targets")
-        return typing.cast(typing.Optional[typing.List["ICrawlerTarget"]], result)
+    @builtins.property
+    def subdomain(self) -> typing.Optional[builtins.str]:
+        '''A subdomain that should be prefixed to the beginning of all registered domains.'''
+        result = self._values.get("subdomain")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def update_behavior(self) -> typing.Optional["UpdateBehavior"]:
-        '''The update behavior when the crawler finds a changed schema.
+    def tag(self) -> typing.Optional[builtins.str]:
+        '''The Docker tag specifying the version of echoserver to use.
 
-        :see: `AWS::Glue::Crawler SchemaChangePolicy <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-schemachangepolicy.html#cfn-glue-crawler-schemachangepolicy-updatebehavior>`_
+        :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
         '''
-        result = self._values.get("update_behavior")
-        return typing.cast(typing.Optional["UpdateBehavior"], result)
+        result = self._values.get("tag")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "CrawlerProps(%s)" % ", ".join(
+        return "EchoserverProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.CrawlerState")
-class CrawlerState(enum.Enum):
-    '''State a Glue crawler must be in in order to satisfy a predicate condition to trigger a part of a workflow.'''
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ElasticsearchCompressionFormat")
+class ElasticsearchCompressionFormat(enum.Enum):
+    GZIP = "GZIP"
+    '''Gzip compression format.'''
 
-    CANCELLED = "CANCELLED"
-    '''A crawler execution was cancelled before it could finish.'''
-    FAILED = "FAILED"
-    '''A crawler that has finished and ended in an error.'''
-    SUCCEEDED = "SUCCEEDED"
-    '''A crawler which has finished successfully.'''
 
+class ElasticsearchOutputBufferSize(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ElasticsearchOutputBufferSize",
+):
+    '''Represents the size of the Elasticsearch output buffer to be used by Fluent Bit.'''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.CrawlerTargetCollection",
-    jsii_struct_bases=[],
-    name_mapping={
-        "catalog_targets": "catalogTargets",
-        "dynamo_db_targets": "dynamoDbTargets",
-        "jdbc_targets": "jdbcTargets",
-        "s3_targets": "s3Targets",
-    },
-)
-class CrawlerTargetCollection:
-    def __init__(
-        self,
-        *,
-        catalog_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-        dynamo_db_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-        jdbc_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-        s3_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''
-        :param catalog_targets: 
-        :param dynamo_db_targets: 
-        :param jdbc_targets: 
-        :param s3_targets: 
+    @jsii.member(jsii_name="bytes")
+    @builtins.classmethod
+    def bytes(cls, size: _DataSize_d20aaece) -> "ElasticsearchOutputBufferSize":
+        '''Set the output buffer to a specified data size.
+
+        :param size: The size of the output buffer.
+
+        :return:
+
+        An output buffer size object representing the specified buffer
+        size.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a8896893a8fc4935daa0226b1e3669e65b536c6438cba018169f71f1a6aed7e3)
-            check_type(argname="argument catalog_targets", value=catalog_targets, expected_type=type_hints["catalog_targets"])
-            check_type(argname="argument dynamo_db_targets", value=dynamo_db_targets, expected_type=type_hints["dynamo_db_targets"])
-            check_type(argname="argument jdbc_targets", value=jdbc_targets, expected_type=type_hints["jdbc_targets"])
-            check_type(argname="argument s3_targets", value=s3_targets, expected_type=type_hints["s3_targets"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if catalog_targets is not None:
-            self._values["catalog_targets"] = catalog_targets
-        if dynamo_db_targets is not None:
-            self._values["dynamo_db_targets"] = dynamo_db_targets
-        if jdbc_targets is not None:
-            self._values["jdbc_targets"] = jdbc_targets
-        if s3_targets is not None:
-            self._values["s3_targets"] = s3_targets
+            type_hints = typing.get_type_hints(_typecheckingstub__91e43731ac6990c08b0792ace3a0c1b48a1f889b6e8d07aca71215174e81ac73)
+            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
+        return typing.cast("ElasticsearchOutputBufferSize", jsii.sinvoke(cls, "bytes", [size]))
 
-    @builtins.property
-    def catalog_targets(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty]]:
-        result = self._values.get("catalog_targets")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty]], result)
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, value: builtins.str) -> "ElasticsearchOutputBufferSize":
+        '''An escape hatch that allows an arbitrary value to be set for the Elasticsearch buffer output property.
 
-    @builtins.property
-    def dynamo_db_targets(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty]]:
-        result = self._values.get("dynamo_db_targets")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty]], result)
+        :param value: The value to use for the Elasticsearch buffer output property.
 
-    @builtins.property
-    def jdbc_targets(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty]]:
-        result = self._values.get("jdbc_targets")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty]], result)
+        :return:
 
-    @builtins.property
-    def s3_targets(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty]]:
-        result = self._values.get("s3_targets")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty]], result)
+        A ``ElasticsearchOutputBufferSize`` object representing the
+        passed value.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9124585821a9391bca778d97002afbc3198cbd561399fa87a8e71b45d6ce6eb5)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ElasticsearchOutputBufferSize", jsii.sinvoke(cls, "of", [value]))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="UNLIMITED")
+    def UNLIMITED(cls) -> "ElasticsearchOutputBufferSize":
+        '''Set the output buffer size to unlimited.'''
+        return typing.cast("ElasticsearchOutputBufferSize", jsii.sget(cls, "UNLIMITED"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="value")
+    def value(self) -> builtins.str:
+        '''The value to use for the Elasticsearch buffer output property.'''
+        return typing.cast(builtins.str, jsii.get(self, "value"))
 
-    def __repr__(self) -> str:
-        return "CrawlerTargetCollection(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
 
+class EmitterStorageType(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.EmitterStorageType",
+):
+    '''Define a buffering mechanism for the new records created by the rewrite tag Fluent Bit filter plugin.'''
 
-class DataFormat(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.DataFormat"):
-    '''Defines the input/output formats and ser/de for a single DataFormat.'''
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "EmitterStorageType":
+        '''An escape hatch that allows for specifying a custom value for the rewrite tag plugin's ``Emitter_Storage.type`` field.
 
-    def __init__(
-        self,
-        *,
-        input_format: "InputFormat",
-        output_format: "OutputFormat",
-        serialization_library: "SerializationLibrary",
-        classification_string: typing.Optional[ClassificationString] = None,
-    ) -> None:
+        :param name: The name of the buffering type to use.
         '''
-        :param input_format: ``InputFormat`` for this data format.
-        :param output_format: ``OutputFormat`` for this data format.
-        :param serialization_library: Serialization library for this data format.
-        :param classification_string: Classification string given to tables with this data format. Default: - No classification is specified.
-        '''
-        props = DataFormatProps(
-            input_format=input_format,
-            output_format=output_format,
-            serialization_library=serialization_library,
-            classification_string=classification_string,
-        )
-
-        jsii.create(self.__class__, self, [props])
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__30778af9523211391b3ca0fed378de136c18bf69752f8852717af5a49e4655da)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("EmitterStorageType", jsii.sinvoke(cls, "of", [name]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="APACHE_LOGS")
-    def APACHE_LOGS(cls) -> "DataFormat":
-        '''DataFormat for Apache Web Server Logs.
-
-        Also works for CloudFront logs
+    @jsii.member(jsii_name="FILESYSTEM")
+    def FILESYSTEM(cls) -> "EmitterStorageType":
+        '''Buffer records on the filesystem.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/apache.html
+        This is recommended if the destination for new records generated might
+        face backpressure due to latency or slow network speeds.
         '''
-        return typing.cast("DataFormat", jsii.sget(cls, "APACHE_LOGS"))
+        return typing.cast("EmitterStorageType", jsii.sget(cls, "FILESYSTEM"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="AVRO")
-    def AVRO(cls) -> "DataFormat":
-        '''DataFormat for Apache Avro.
+    @jsii.member(jsii_name="MEMORY")
+    def MEMORY(cls) -> "EmitterStorageType":
+        '''Buffer records in memory.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/avro.html
+        This is the default behavior.
         '''
-        return typing.cast("DataFormat", jsii.sget(cls, "AVRO"))
+        return typing.cast("EmitterStorageType", jsii.sget(cls, "MEMORY"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CLOUDTRAIL_LOGS")
-    def CLOUDTRAIL_LOGS(cls) -> "DataFormat":
-        '''DataFormat for CloudTrail logs stored on S3.
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the emitter storage type as it should appear in the plugin configuration file.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
-        '''
-        return typing.cast("DataFormat", jsii.sget(cls, "CLOUDTRAIL_LOGS"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CSV")
-    def CSV(cls) -> "DataFormat":
-        '''DataFormat for CSV Files.
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsLogFormat")
+class ExternalDnsLogFormat(enum.Enum):
+    '''The format external dns should use to output logs.'''
+
+    JSON = "JSON"
+    '''Output logs will be written as JSON objects.'''
+    TEXT = "TEXT"
+    '''Output logs will be written in plain text.'''
+
+
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsLogLevel")
+class ExternalDnsLogLevel(enum.Enum):
+    '''Verbosity of the logs generated by the external-dns service.'''
+
+    PANIC = "PANIC"
+    '''Set log level to 'panic'.'''
+    DEBUG = "DEBUG"
+    '''Set log level to 'debug'.'''
+    INFO = "INFO"
+    '''Set log level to 'info'.'''
+    WARNING = "WARNING"
+    '''Set log level to 'warning'.'''
+    ERROR = "ERROR"
+    '''Set log level to 'error'.'''
+    FATAL = "FATAL"
+    '''Set log level to 'fatal'.'''
+    TRACE = "TRACE"
+    '''Set log level to 'trace'.'''
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/csv.html
-        '''
-        return typing.cast("DataFormat", jsii.sget(cls, "CSV"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="JSON")
-    def JSON(cls) -> "DataFormat":
-        '''Stored as plain text files in JSON format.
+class ExternalDnsRegistry(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ExternalDnsRegistry",
+):
+    '''Helper class that provides access to the available ExternalDns registry options.'''
 
-        Uses OpenX Json SerDe for serialization and deseralization.
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/json.html
-        '''
-        return typing.cast("DataFormat", jsii.sget(cls, "JSON"))
+    @jsii.member(jsii_name="awsServiceDiscovery")
+    @builtins.classmethod
+    def aws_service_discovery(cls) -> "AwsServiceDiscoveryRegistry":
+        '''An ExternalDNS registry that tracks DNS record ownership information using AWS Service Discovery.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="LOGSTASH")
-    def LOGSTASH(cls) -> "DataFormat":
-        '''DataFormat for Logstash Logs, using the GROK SerDe.
+        :return:
+
+        A ExternalDNS registry object configured to use AWS Cloud Map
+        for ownership information.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/grok.html
+        :see: `AWS Cloud Map <https://docs.aws.amazon.com/cloud-map/latest/dg/what-is-cloud-map.html>`_
         '''
-        return typing.cast("DataFormat", jsii.sget(cls, "LOGSTASH"))
+        return typing.cast("AwsServiceDiscoveryRegistry", jsii.sinvoke(cls, "awsServiceDiscovery", []))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ORC")
-    def ORC(cls) -> "DataFormat":
-        '''DataFormat for Apache ORC (Optimized Row Columnar).
+    @jsii.member(jsii_name="noop")
+    @builtins.classmethod
+    def noop(cls) -> "NoopRegistry":
+        '''A placeholder ExternalDNS registry that says ExternalDNS should use not use a registry.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/orc.html
-        '''
-        return typing.cast("DataFormat", jsii.sget(cls, "ORC"))
+        When configuring ExternalDNS without a registry, the service has no idea
+        the original creator and maintainer of DNS records. This means that
+        there are likely to be conflicts if there are multiple services that
+        could create or change DNS records in the same zone.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PARQUET")
-    def PARQUET(cls) -> "DataFormat":
-        '''DataFormat for Apache Parquet.
+        :return:
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/parquet.html
+        An object that instructs ExternalDNS to not store record
+        ownership information and will perform record updates without
+        validation.
         '''
-        return typing.cast("DataFormat", jsii.sget(cls, "PARQUET"))
+        return typing.cast("NoopRegistry", jsii.sinvoke(cls, "noop", []))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="TSV")
-    def TSV(cls) -> "DataFormat":
-        '''DataFormat for TSV (Tab-Separated Values).
+    @jsii.member(jsii_name="txt")
+    @builtins.classmethod
+    def txt(
+        cls,
+        *,
+        owner_id: typing.Optional[builtins.str] = None,
+        prefix: typing.Optional[builtins.str] = None,
+    ) -> "TxtRegistry":
+        '''An ExternalDNS registry that tracks DNS record ownership information using DNS TXT records.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/lazy-simple-serde.html
-        '''
-        return typing.cast("DataFormat", jsii.sget(cls, "TSV"))
+        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
+        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
 
-    @builtins.property
-    @jsii.member(jsii_name="inputFormat")
-    def input_format(self) -> "InputFormat":
-        '''``InputFormat`` for this data format.'''
-        return typing.cast("InputFormat", jsii.get(self, "inputFormat"))
+        :return:
 
-    @builtins.property
-    @jsii.member(jsii_name="outputFormat")
-    def output_format(self) -> "OutputFormat":
-        '''``OutputFormat`` for this data format.'''
-        return typing.cast("OutputFormat", jsii.get(self, "outputFormat"))
+        A ExternalDNS registry object configured to use DNS TXT records
+        for ownership information.
 
-    @builtins.property
-    @jsii.member(jsii_name="serializationLibrary")
-    def serialization_library(self) -> "SerializationLibrary":
-        '''Serialization library for this data format.'''
-        return typing.cast("SerializationLibrary", jsii.get(self, "serializationLibrary"))
+        :see: `About TXT records <https://support.google.com/a/answer/2716800?hl=en>`_
+        '''
+        options = TxtRegistryOptions(owner_id=owner_id, prefix=prefix)
 
-    @builtins.property
-    @jsii.member(jsii_name="classificationString")
-    def classification_string(self) -> typing.Optional[ClassificationString]:
-        '''Classification string given to tables with this data format.'''
-        return typing.cast(typing.Optional[ClassificationString], jsii.get(self, "classificationString"))
+        return typing.cast("TxtRegistry", jsii.sinvoke(cls, "txt", [options]))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.DataFormatProps",
+    jsii_type="cdk-extensions.k8s_aws.ExternalDnsRegistryConfiguration",
     jsii_struct_bases=[],
     name_mapping={
-        "input_format": "inputFormat",
-        "output_format": "outputFormat",
-        "serialization_library": "serializationLibrary",
-        "classification_string": "classificationString",
+        "registry_type": "registryType",
+        "permissions": "permissions",
+        "properties": "properties",
     },
 )
-class DataFormatProps:
+class ExternalDnsRegistryConfiguration:
     def __init__(
         self,
         *,
-        input_format: "InputFormat",
-        output_format: "OutputFormat",
-        serialization_library: "SerializationLibrary",
-        classification_string: typing.Optional[ClassificationString] = None,
+        registry_type: builtins.str,
+        permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
+        properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
     ) -> None:
-        '''Properties of a DataFormat instance.
-
-        :param input_format: ``InputFormat`` for this data format.
-        :param output_format: ``OutputFormat`` for this data format.
-        :param serialization_library: Serialization library for this data format.
-        :param classification_string: Classification string given to tables with this data format. Default: - No classification is specified.
+        '''
+        :param registry_type: 
+        :param permissions: 
+        :param properties: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dbf6d8049cc8299102bda3d0f4fcaafe4f62969715f5334320a23b3330bfc2e5)
-            check_type(argname="argument input_format", value=input_format, expected_type=type_hints["input_format"])
-            check_type(argname="argument output_format", value=output_format, expected_type=type_hints["output_format"])
-            check_type(argname="argument serialization_library", value=serialization_library, expected_type=type_hints["serialization_library"])
-            check_type(argname="argument classification_string", value=classification_string, expected_type=type_hints["classification_string"])
+            type_hints = typing.get_type_hints(_typecheckingstub__5f7c8fd432fc4f5005a0f643a18e84adbdbe3cd99f8b0197a9c3b88356ab4c36)
+            check_type(argname="argument registry_type", value=registry_type, expected_type=type_hints["registry_type"])
+            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
+            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "input_format": input_format,
-            "output_format": output_format,
-            "serialization_library": serialization_library,
+            "registry_type": registry_type,
         }
-        if classification_string is not None:
-            self._values["classification_string"] = classification_string
+        if permissions is not None:
+            self._values["permissions"] = permissions
+        if properties is not None:
+            self._values["properties"] = properties
 
     @builtins.property
-    def input_format(self) -> "InputFormat":
-        '''``InputFormat`` for this data format.'''
-        result = self._values.get("input_format")
-        assert result is not None, "Required property 'input_format' is missing"
-        return typing.cast("InputFormat", result)
+    def registry_type(self) -> builtins.str:
+        result = self._values.get("registry_type")
+        assert result is not None, "Required property 'registry_type' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def output_format(self) -> "OutputFormat":
-        '''``OutputFormat`` for this data format.'''
-        result = self._values.get("output_format")
-        assert result is not None, "Required property 'output_format' is missing"
-        return typing.cast("OutputFormat", result)
+    def permissions(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]]:
+        result = self._values.get("permissions")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]], result)
 
     @builtins.property
-    def serialization_library(self) -> "SerializationLibrary":
-        '''Serialization library for this data format.'''
-        result = self._values.get("serialization_library")
-        assert result is not None, "Required property 'serialization_library' is missing"
-        return typing.cast("SerializationLibrary", result)
+    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
+        result = self._values.get("properties")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)
 
-    @builtins.property
-    def classification_string(self) -> typing.Optional[ClassificationString]:
-        '''Classification string given to tables with this data format.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ExternalDnsRegistryConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsSyncPolicy")
+class ExternalDnsSyncPolicy(enum.Enum):
+    '''Controls the operations ExternalDNS will perform on the records it manages.'''
 
-        :default: - No classification is specified.
+    SYNC = "SYNC"
+    '''Full sync mode.
+
+    Records will be created, updated, and deleted based on the
+    statis of their backing resources on the Kubernetes cluster.
+    '''
+    UPSERT_ONLY = "UPSERT_ONLY"
+    '''Only allow create and update operations.
+
+    Records will have their values
+    set based on the status of their backing Kubernetes resources, however if
+    those resources are removed the DNS records will be retained, set to their
+    last configured value.
+    '''
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.ExternalDnsZoneTag",
+    jsii_struct_bases=[],
+    name_mapping={"key": "key", "value": "value"},
+)
+class ExternalDnsZoneTag:
+    def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
+        '''Specifies a tag that can be used to restrict which Hosted Zone external-dns will have access to.
+
+        :param key: The name of the tag to filter on.
+        :param value: The value of the tag to filter on.
         '''
-        result = self._values.get("classification_string")
-        return typing.cast(typing.Optional[ClassificationString], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__575b91a9d80cdb1a92d59c32aa69e6b72bae0ee5d1b726d04016341d1d05ce2b)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "key": key,
+            "value": value,
+        }
+
+    @builtins.property
+    def key(self) -> builtins.str:
+        '''The name of the tag to filter on.'''
+        result = self._values.get("key")
+        assert result is not None, "Required property 'key' is missing"
+        return typing.cast(builtins.str, result)
+
+    @builtins.property
+    def value(self) -> builtins.str:
+        '''The value of the tag to filter on.'''
+        result = self._values.get("value")
+        assert result is not None, "Required property 'value' is missing"
+        return typing.cast(builtins.str, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "DataFormatProps(%s)" % ", ".join(
+        return "ExternalDnsZoneTag(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class Database(
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsZoneType")
+class ExternalDnsZoneType(enum.Enum):
+    '''Controls the types of Hosted Zones external DNS will create records for.'''
+
+    ALL = "ALL"
+    '''Create DNS records for both public and private hosted zones.'''
+    PRIVATE = "PRIVATE"
+    '''Only create DNS records for private hosted zones.'''
+    PUBLIC = "PUBLIC"
+    '''Only create DNS records for public hosted zones.'''
+
+
+class ExternalSecret(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Database",
+    jsii_type="cdk-extensions.k8s_aws.ExternalSecret",
 ):
-    '''Creates a Glue Database resource to contain a collection of metadata Tables.
+    '''Represents a Kubernetes secret that is being synchronized from an external provider.
 
-    :see: [AWS::Glue::Database](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-database.html
+    On a technical level, provides the configuration for how the external
+    secrets operator service should manage the synchronization of the Kubernetes
+    secret.
     '''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        description: typing.Optional[builtins.str] = None,
-        location_uri: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        secret_store: "ISecretStore",
         name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the Database class.
+        '''Creates a new instance of the ExternalSecret class.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param description: A description of the database.
-        :param location_uri: The location of the database (for example, an HDFS path).
-        :param name: The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the secret should be created.
+        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
+        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
+        :param namespace: The name where the synchronized secret should be created.
+        :param refresh_interval: The frequency at which synchronization should occur.
+        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__45c3b158089c46e13d9c49f0ca36070229ef0a94859ba845783419cef5407fba)
+            type_hints = typing.get_type_hints(_typecheckingstub__49513e201186ba37d9ef6756fce415cce3648eed2fa385f3e5f55eb6a5fa9de3)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = DatabaseProps(
-            description=description,
-            location_uri=location_uri,
+        props = ExternalSecretProps(
+            cluster=cluster,
+            secret_store=secret_store,
             name=name,
+            namespace=namespace,
+            refresh_interval=refresh_interval,
+            secrets=secrets,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @builtins.property
-    @jsii.member(jsii_name="catalogArn")
-    def catalog_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "catalogArn"))
+    @jsii.member(jsii_name="addSecret")
+    def add_secret(self, secret: "ISecretReference") -> "ExternalSecret":
+        '''Adds a provider secret reference to the synchronized Kubernetes secret.
 
-    @builtins.property
-    @jsii.member(jsii_name="catalogId")
-    def catalog_id(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "catalogId"))
+        For external secrets that reference multiple provider secrets the keys of
+        all provider secrets will be merged into the single Kubernetes secret.
+
+        :param secret: The provider secret to reference.
+
+        :return: The external secret resoiurce where the reference was added.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__19eb3b7d91a4e74eaaed7fe7ee26f9301db18656d2c4d7d673df35310e1e67f9)
+            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
+        return typing.cast("ExternalSecret", jsii.invoke(self, "addSecret", [secret]))
 
     @builtins.property
-    @jsii.member(jsii_name="databaseArn")
-    def database_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "databaseArn"))
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret should be created.
+
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
 
     @builtins.property
-    @jsii.member(jsii_name="databaseName")
-    def database_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "databaseName"))
+    @jsii.member(jsii_name="manifest")
+    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
+        '''The Kubernetes manifest defining the configuration of how to synchronize the Kubernetes secret from the provider secrets.
+
+        :group: Resources
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
 
     @builtins.property
     @jsii.member(jsii_name="name")
     def name(self) -> builtins.str:
-        '''{@link DatabaseProps.name:}.'''
+        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
+
+        :group: Inputs
+        '''
         return typing.cast(builtins.str, jsii.get(self, "name"))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnDatabase:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnDatabase, jsii.get(self, "resource"))
+    @jsii.member(jsii_name="secretName")
+    def secret_name(self) -> builtins.str:
+        '''The name of the Kubernetes secret.'''
+        return typing.cast(builtins.str, jsii.get(self, "secretName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="secrets")
+    def secrets(self) -> typing.List["ISecretReference"]:
+        '''The collection of referenced provider secrets that are referenced in the Kubernetes secret.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.List["ISecretReference"], jsii.get(self, "secrets"))
+
+    @builtins.property
+    @jsii.member(jsii_name="secretStore")
+    def secret_store(self) -> "ISecretStore":
+        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
+
+        :group: Inputs
+        '''
+        return typing.cast("ISecretStore", jsii.get(self, "secretStore"))
+
+    @builtins.property
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The name where the synchronized secret should be created.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namespace"))
+
+    @builtins.property
+    @jsii.member(jsii_name="refreshInterval")
+    def refresh_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The frequency at which synchronization should occur.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "refreshInterval"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.ExternalSecretOptions",
+    jsii_struct_bases=[],
+    name_mapping={"fields": "fields", "name": "name"},
+)
+class ExternalSecretOptions:
+    def __init__(
+        self,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration options for adding a Kubernetes secret synced from an external provider to Kubernetes.
+
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9c48bcfa2d2f0d5e393569b187f9c8953494e5941b2210c23840aa29af16ef83)
+            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if fields is not None:
+            self._values["fields"] = fields
+        if name is not None:
+            self._values["name"] = name
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link DatabaseProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
+        '''A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider.
+
+        :default:
+
+        The Kubernetes secret will mirror the fields from the secret in
+        the external provider.
+        '''
+        result = self._values.get("fields")
+        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="locationUri")
-    def location_uri(self) -> typing.Optional[builtins.str]:
-        '''{@link DatabaseProps.locationUri}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locationUri"))
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster.
+
+        :default: A name will be auto-generated.
+        '''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ExternalSecretOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.DatabaseProps",
+    jsii_type="cdk-extensions.k8s_aws.ExternalSecretProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "description": "description",
-        "location_uri": "locationUri",
+        "cluster": "cluster",
+        "secret_store": "secretStore",
         "name": "name",
+        "namespace": "namespace",
+        "refresh_interval": "refreshInterval",
+        "secrets": "secrets",
     },
 )
-class DatabaseProps(_aws_cdk_ceddda9d.ResourceProps):
+class ExternalSecretProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        description: typing.Optional[builtins.str] = None,
-        location_uri: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        secret_store: "ISecretStore",
         name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
     ) -> None:
-        '''Configuration for Database.
+        '''Configuration for the ExternalSecret resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param description: A description of the database.
-        :param location_uri: The location of the database (for example, an HDFS path).
-        :param name: The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.
+        :param cluster: The EKS cluster where the secret should be created.
+        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
+        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
+        :param namespace: The name where the synchronized secret should be created.
+        :param refresh_interval: The frequency at which synchronization should occur.
+        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0d611ab4143e7ce164987eed2bc3acb7d2232995b6cb14a3be53384f6c67d983)
+            type_hints = typing.get_type_hints(_typecheckingstub__d11fa008f8a05b0740f0561849e56b56d7a687389f3927a388801e0c2089baa9)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument location_uri", value=location_uri, expected_type=type_hints["location_uri"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument secret_store", value=secret_store, expected_type=type_hints["secret_store"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
+            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "cluster": cluster,
+            "secret_store": secret_store,
+        }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if description is not None:
-            self._values["description"] = description
-        if location_uri is not None:
-            self._values["location_uri"] = location_uri
         if name is not None:
             self._values["name"] = name
+        if namespace is not None:
+            self._values["namespace"] = namespace
+        if refresh_interval is not None:
+            self._values["refresh_interval"] = refresh_interval
+        if secrets is not None:
+            self._values["secrets"] = secrets
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -1947,567 +1859,747 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description of the database.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret should be created.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
     @builtins.property
-    def location_uri(self) -> typing.Optional[builtins.str]:
-        '''The location of the database (for example, an HDFS path).
+    def secret_store(self) -> "ISecretStore":
+        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.'''
+        result = self._values.get("secret_store")
+        assert result is not None, "Required property 'secret_store' is missing"
+        return typing.cast("ISecretStore", result)
 
-        :see: `AWS::Glue::Database DatabaseInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-database-databaseinput.html#cfn-glue-database-databaseinput-locationuri>`_
-        '''
-        result = self._values.get("location_uri")
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.'''
+        result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the database.
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The name where the synchronized secret should be created.'''
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        For Hive compatibility, this is folded to lowercase when it is stored.
+    @builtins.property
+    def refresh_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''The frequency at which synchronization should occur.'''
+        result = self._values.get("refresh_interval")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+
+    @builtins.property
+    def secrets(self) -> typing.Optional[typing.List["ISecretReference"]]:
+        '''The secrets to synchronize into this Kubernetes secret.
+
+        If multiple secrets are provided their fields will be merged.
         '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("secrets")
+        return typing.cast(typing.Optional[typing.List["ISecretReference"]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "DatabaseProps(%s)" % ", ".join(
+        return "ExternalSecretProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.DeleteBehavior")
-class DeleteBehavior(enum.Enum):
-    DELETE_FROM_DATABASE = "DELETE_FROM_DATABASE"
-    DEPRECATE_IN_DATABASE = "DEPRECATE_IN_DATABASE"
-    LOG = "LOG"
+class ExternalSecretsOperator(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperator",
+):
+    '''External Secrets Operator is a Kubernetes operator that integrates external secret management systems like AWS Secrets Manager, HashiCorp Vault, Google Secrets Manager, Azure Key Vault and many more.
 
+    The operator reads
+    information from external APIs and automatically injects the values into a
+    Kubernetes Secret.
 
-class GlueVersion(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.GlueVersion"):
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, version: builtins.str) -> "GlueVersion":
-        '''Custom Glue version.
+    :see: `External Secrets Website <https://external-secrets.io/>`_
+    '''
+
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
+        create_namespace: typing.Optional[builtins.bool] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the ExternalSecretsOperator class.
 
-        :param version: custom version.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the external secrets operator should be installed.
+        :param create_namespace: Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster. When this flag is ``true`` and the namespace doesn't exist, the namespace will be created automatically. When this flag is ``false`` and the namespace doesn't exist, an error will occur and resource creation will fail. Default: true
+        :param namespace: The Kubernetes namespace where the external secrets operator service should be installed and configured. Default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__afef4db7c413ec6c4abe2a7c38e51c3df056fd2eba5fcd9b37a75a1490334595)
-            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
-        return typing.cast("GlueVersion", jsii.sinvoke(cls, "of", [version]))
+            type_hints = typing.get_type_hints(_typecheckingstub__92e0a4c21b4ba5a2e251aa667f38097598f22ba362cbd427dd404bbdc22ab5f6)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = ExternalSecretsOperatorProps(
+            cluster=cluster,
+            create_namespace=create_namespace,
+            namespace=namespace,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="V0_9")
-    def V0_9(cls) -> "GlueVersion":
-        '''Glue version using Spark 2.2.1 and Python 2.7.'''
-        return typing.cast("GlueVersion", jsii.sget(cls, "V0_9"))
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="registerSecretsManagerSecret")
+    def register_secrets_manager_secret(
+        self,
+        id: builtins.str,
+        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
+        *,
+        namespace: typing.Optional[builtins.str] = None,
+        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> ExternalSecret:
+        '''Registers a Secrets Manager secret with the external secrets operator, enabling syncing from the Secrets Manager secret into Kubernetes.
+
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within for each secrets manager secret within a Kubernetes namespace.
+        :param secret: The Secrets Manager secret to enable syncing for.
+        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+
+        :return: The external secret object that was created.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__90685b99b2a2f337bfa2d47df40412c9b581b614b6fbaa7d3c94b067a6d562f9)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
+        options = NamespacedExternalSecretOptions(
+            namespace=namespace, fields=fields, name=name
+        )
+
+        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSecretsManagerSecret", [id, secret, options]))
+
+    @jsii.member(jsii_name="registerSsmParameterSecret")
+    def register_ssm_parameter_secret(
+        self,
+        id: builtins.str,
+        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
+        *,
+        namespace: typing.Optional[builtins.str] = None,
+        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> ExternalSecret:
+        '''Registers a Systems Manager parameter with the external secrets operator, enabling syncing from the Systems Manager parameter into Kubernetes.
+
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within for each Systems Manager parameter within a Kubernetes namespace.
+        :param parameter: The Systems Manager parameter to enable syncing for.
+        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+
+        :return: The external secret object that was created.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bb968a0fa40a926483b03cb5417298b5375e8cd4b95be82c6d873ca8dc69a994)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
+        options = NamespacedExternalSecretOptions(
+            namespace=namespace, fields=fields, name=name
+        )
+
+        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSsmParameterSecret", [id, parameter, options]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V1_0")
-    def V1_0(cls) -> "GlueVersion":
-        '''Glue version using Spark 2.4.3, Python 2.7 and Python 3.6.'''
-        return typing.cast("GlueVersion", jsii.sget(cls, "V1_0"))
+    @jsii.member(jsii_name="CHART_NAME")
+    def CHART_NAME(cls) -> builtins.str:
+        '''The name of the Helm chart to install from the Helm repository.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "CHART_NAME"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V2_0")
-    def V2_0(cls) -> "GlueVersion":
-        '''Glue version using Spark 2.4.3 and Python 3.7.'''
-        return typing.cast("GlueVersion", jsii.sget(cls, "V2_0"))
+    @jsii.member(jsii_name="CHART_REPOSITORY")
+    def CHART_REPOSITORY(cls) -> builtins.str:
+        '''The URL of the Helm repository that hostys the Helm charts used to install the externalk secrets operator service.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "CHART_REPOSITORY"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="V3_0")
-    def V3_0(cls) -> "GlueVersion":
-        '''Glue version using Spark 3.1.1 and Python 3.7.'''
-        return typing.cast("GlueVersion", jsii.sget(cls, "V3_0"))
+    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
+    def DEFAULT_NAMESPACE(cls) -> builtins.str:
+        '''The default Kubernetes namespace where the external secrets operator service should be installed and configured if no overriding input is provided.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of this GlueVersion, as expected by Job resource.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
+        '''The EKS cluster where the external secrets operator service should be installed and configured.
 
-
-@jsii.interface(jsii_type="cdk-extensions.glue.ICrawler")
-class ICrawler(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
-    @builtins.property
-    @jsii.member(jsii_name="crawlerArn")
-    def crawler_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the crawler.'''
-        ...
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, jsii.get(self, "cluster"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawlerName")
-    def crawler_name(self) -> builtins.str:
-        '''The name of the crawler.'''
-        ...
+    @jsii.member(jsii_name="helmChart")
+    def helm_chart(self) -> _aws_cdk_aws_eks_ceddda9d.HelmChart:
+        '''The Helm chart the manages the installation and configuration of the external secrets operator service.
 
-
-class _ICrawlerProxy(
-    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
-):
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ICrawler"
+        :group: Resources
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.HelmChart, jsii.get(self, "helmChart"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawlerArn")
-    def crawler_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the crawler.'''
-        return typing.cast(builtins.str, jsii.get(self, "crawlerArn"))
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> builtins.str:
+        '''The Kubernetes namespace where the external secrets operator service should be installed and configured.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "namespace"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawlerName")
-    def crawler_name(self) -> builtins.str:
-        '''The name of the crawler.'''
-        return typing.cast(builtins.str, jsii.get(self, "crawlerName"))
+    @jsii.member(jsii_name="createNamespace")
+    def create_namespace(self) -> typing.Optional[builtins.bool]:
+        '''Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ICrawler).__jsii_proxy_class__ = lambda : _ICrawlerProxy
+        When this flag is ``true`` and the namespace doesn't exist, the namespace
+        will be created automatically.
 
+        When this flag is ``false`` and the namespace doesn't exist, an error will
+        occur and resource creation will fail.
 
-@jsii.interface(jsii_type="cdk-extensions.glue.ICrawlerTarget")
-class ICrawlerTarget(typing_extensions.Protocol):
-    @jsii.member(jsii_name="bind")
-    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
-        '''
-        :param crawler: -
+        :group: Inputs
         '''
-        ...
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "createNamespace"))
 
 
-class _ICrawlerTargetProxy:
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ICrawlerTarget"
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperatorProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "cluster": "cluster",
+        "create_namespace": "createNamespace",
+        "namespace": "namespace",
+    },
+)
+class ExternalSecretsOperatorProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
+        create_namespace: typing.Optional[builtins.bool] = None,
+        namespace: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration for the ExternalSecretsOperator resource.
 
-    @jsii.member(jsii_name="bind")
-    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
-        '''
-        :param crawler: -
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param cluster: The EKS cluster where the external secrets operator should be installed.
+        :param create_namespace: Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster. When this flag is ``true`` and the namespace doesn't exist, the namespace will be created automatically. When this flag is ``false`` and the namespace doesn't exist, an error will occur and resource creation will fail. Default: true
+        :param namespace: The Kubernetes namespace where the external secrets operator service should be installed and configured. Default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dd0bd4dee65916002df8546350cf43116d55f03d0052a252943557ca270bb18b)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [crawler]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ICrawlerTarget).__jsii_proxy_class__ = lambda : _ICrawlerTargetProxy
-
-
-@jsii.interface(jsii_type="cdk-extensions.glue.IJob")
-class IJob(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
-    '''Represnets a Glue Job in AWS.'''
+            type_hints = typing.get_type_hints(_typecheckingstub__a77b0078ad516d66ca8ca0d633ac0257b13a89e52152799cdfab2d5f1bd3e906)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument create_namespace", value=create_namespace, expected_type=type_hints["create_namespace"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "cluster": cluster,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if create_namespace is not None:
+            self._values["create_namespace"] = create_namespace
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
-    @jsii.member(jsii_name="jobArn")
-    def job_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the job.'''
-        ...
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
+
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="jobName")
-    def job_name(self) -> builtins.str:
-        '''The name of the job.'''
-        ...
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-class _IJobProxy(
-    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
-):
-    '''Represnets a Glue Job in AWS.'''
+        Cannot be supplied together with either ``account`` or ``region``.
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.IJob"
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="jobArn")
-    def job_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the job.'''
-        return typing.cast(builtins.str, jsii.get(self, "jobArn"))
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @builtins.property
-    @jsii.member(jsii_name="jobName")
-    def job_name(self) -> builtins.str:
-        '''The name of the job.'''
-        return typing.cast(builtins.str, jsii.get(self, "jobName"))
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IJob).__jsii_proxy_class__ = lambda : _IJobProxy
+        :default: - The physical name will be allocated by CloudFormation at deployment time
+        '''
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-@jsii.interface(jsii_type="cdk-extensions.glue.ITrigger")
-class ITrigger(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
-    '''Represents a Glue Trigger in AWS.'''
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="triggerArn")
-    def trigger_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the trigger.'''
-        ...
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
+        '''The EKS cluster where the external secrets operator should be installed.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, result)
 
     @builtins.property
-    @jsii.member(jsii_name="triggerName")
-    def trigger_name(self) -> builtins.str:
-        '''The name of the trigger.'''
-        ...
+    def create_namespace(self) -> typing.Optional[builtins.bool]:
+        '''Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster.
 
+        When this flag is ``true`` and the namespace doesn't exist, the namespace
+        will be created automatically.
 
-class _ITriggerProxy(
-    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
-):
-    '''Represents a Glue Trigger in AWS.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITrigger"
+        When this flag is ``false`` and the namespace doesn't exist, an error will
+        occur and resource creation will fail.
 
-    @builtins.property
-    @jsii.member(jsii_name="triggerArn")
-    def trigger_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the trigger.'''
-        return typing.cast(builtins.str, jsii.get(self, "triggerArn"))
+        :default: true
+        '''
+        result = self._values.get("create_namespace")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="triggerName")
-    def trigger_name(self) -> builtins.str:
-        '''The name of the trigger.'''
-        return typing.cast(builtins.str, jsii.get(self, "triggerName"))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITrigger).__jsii_proxy_class__ = lambda : _ITriggerProxy
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the external secrets operator service should be installed and configured.
 
+        :default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
+        '''
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-@jsii.interface(jsii_type="cdk-extensions.glue.ITriggerAction")
-class ITriggerAction(typing_extensions.Protocol):
-    '''Represents an action that should be taken when a trigger is executed.'''
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
-        '''
-        :param scope: -
-        '''
-        ...
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
+    def __repr__(self) -> str:
+        return "ExternalSecretsOperatorProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-class _ITriggerActionProxy:
-    '''Represents an action that should be taken when a trigger is executed.'''
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITriggerAction"
+class FargateLogger(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FargateLogger",
+):
+    '''Creates a ConfigMap that configures logging for containers running in EKS on Fargate.'''
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+    def __init__(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
-        '''
-        :param scope: -
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
+        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the FargateLogger class.
+
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS Cluster to configure Fargate logging for.
+        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
+        :param filters: The filters that should be applied to logs being processed.
+        :param log_group: The CloudWatch log group where Farget container logs will be sent.
+        :param outputs: The output destinations where logs should be written.
+        :param parsers: The parsers to be used when reading log files.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ee93cfcd69490826c39480651b7eb34877d0667604b0e14daf995218173ee126)
+            type_hints = typing.get_type_hints(_typecheckingstub__76dae8c2dfe10754d7c019d5c1c2151516afb99c60c1df33bb81b24d3b938dd3)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITriggerAction).__jsii_proxy_class__ = lambda : _ITriggerActionProxy
-
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = FargateLoggerProps(
+            cluster=cluster,
+            fargate_profiles=fargate_profiles,
+            filters=filters,
+            log_group=log_group,
+            outputs=outputs,
+            parsers=parsers,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-@jsii.interface(jsii_type="cdk-extensions.glue.ITriggerPredicate")
-class ITriggerPredicate(typing_extensions.Protocol):
-    '''Represents a precondition that must be satisfied in order for a trigger to be executed.'''
+        jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+    @jsii.member(jsii_name="addFargateProfile")
+    def add_fargate_profile(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+        profile: _aws_cdk_aws_eks_ceddda9d.FargateProfile,
+    ) -> "FargateLogger":
         '''
-        :param scope: -
+        :param profile: -
         '''
-        ...
-
-
-class _ITriggerPredicateProxy:
-    '''Represents a precondition that must be satisfied in order for a trigger to be executed.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.glue.ITriggerPredicate"
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b703c0764bfdf16eb126c71eab2089fc0d5d0baedeb889a2ab4b2d0a6b49f59d)
+            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
+        return typing.cast("FargateLogger", jsii.invoke(self, "addFargateProfile", [profile]))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
+    @jsii.member(jsii_name="addFilter")
+    def add_filter(self, filter: "IFluentBitFilterPlugin") -> "FargateLogger":
         '''
-        :param scope: -
+        :param filter: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2c73437c9e4d3b35bea065e54ce75f4a15077ddc17412786ea8a173cc1fadd1c)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ITriggerPredicate).__jsii_proxy_class__ = lambda : _ITriggerPredicateProxy
+            type_hints = typing.get_type_hints(_typecheckingstub__441c970215922062a245380ac8d1e04123624212c517def39ade49d9091b4c23)
+            check_type(argname="argument filter", value=filter, expected_type=type_hints["filter"])
+        return typing.cast("FargateLogger", jsii.invoke(self, "addFilter", [filter]))
 
-
-class InputFormat(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.InputFormat"):
-    '''Absolute class name of the Hadoop ``InputFormat`` to use when reading table files.'''
-
-    def __init__(self, class_name: builtins.str) -> None:
+    @jsii.member(jsii_name="addOutput")
+    def add_output(self, output: "IFluentBitOutputPlugin") -> "FargateLogger":
         '''
-        :param class_name: -
+        :param output: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f47e29abee492d68598cef1aaeaafad27d809225eb3fede0aba56962510025d0)
-            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
-        jsii.create(self.__class__, self, [class_name])
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="AVRO")
-    def AVRO(cls) -> "InputFormat":
-        '''InputFormat for Avro files.
+            type_hints = typing.get_type_hints(_typecheckingstub__a329165d7991851e4ec8fd63a4b82083aef71de6826a3ef2e264518b24051f2b)
+            check_type(argname="argument output", value=output, expected_type=type_hints["output"])
+        return typing.cast("FargateLogger", jsii.invoke(self, "addOutput", [output]))
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/avro/AvroContainerInputFormat.html
+    @jsii.member(jsii_name="addParser")
+    def add_parser(self, parser: "IFluentBitParserPlugin") -> "FargateLogger":
+        '''
+        :param parser: -
         '''
-        return typing.cast("InputFormat", jsii.sget(cls, "AVRO"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f61de38bcda89dc454156432b185bbdfe377f7811aa2270afad6e3f3d5d7e4fe)
+            check_type(argname="argument parser", value=parser, expected_type=type_hints["parser"])
+        return typing.cast("FargateLogger", jsii.invoke(self, "addParser", [parser]))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CLOUDTRAIL")
-    def CLOUDTRAIL(cls) -> "InputFormat":
-        '''InputFormat for Cloudtrail Logs.
+    @builtins.property
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where Fargate logging is being configured.
 
-        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
+        :group: Inputs
         '''
-        return typing.cast("InputFormat", jsii.sget(cls, "CLOUDTRAIL"))
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ORC")
-    def ORC(cls) -> "InputFormat":
-        '''InputFormat for Orc files.
+    @builtins.property
+    @jsii.member(jsii_name="filters")
+    def filters(self) -> typing.List["IFluentBitFilterPlugin"]:
+        '''Collection of Fluent Bit filter plugins being configured for logging.
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcInputFormat.html
+        :group: Inputs
         '''
-        return typing.cast("InputFormat", jsii.sget(cls, "ORC"))
+        return typing.cast(typing.List["IFluentBitFilterPlugin"], jsii.get(self, "filters"))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PARQUET")
-    def PARQUET(cls) -> "InputFormat":
-        '''InputFormat for Parquet files.
+    @builtins.property
+    @jsii.member(jsii_name="manifest")
+    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
+        '''The Kubernetes manifest that creates the ConfigMap that Fargate uses to configure logging.
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/MapredParquetInputFormat.html
+        :group: Resources
         '''
-        return typing.cast("InputFormat", jsii.sget(cls, "PARQUET"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="TEXT")
-    def TEXT(cls) -> "InputFormat":
-        '''An InputFormat for plain text files.
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
 
-        Files are broken into lines. Either linefeed or
-        carriage-return are used to signal end of line. Keys are the position in the file, and
-        values are the line of text.
-        JSON & CSV files are examples of this InputFormat
+    @builtins.property
+    @jsii.member(jsii_name="outputs")
+    def outputs(self) -> typing.List["IFluentBitOutputPlugin"]:
+        '''Collection of Fluent Bit output plugins being configured for logging.
 
-        :see: https://hadoop.apache.org/docs/stable/api/org/apache/hadoop/mapred/TextInputFormat.html
+        :group: Inputs
         '''
-        return typing.cast("InputFormat", jsii.sget(cls, "TEXT"))
+        return typing.cast(typing.List["IFluentBitOutputPlugin"], jsii.get(self, "outputs"))
 
     @builtins.property
-    @jsii.member(jsii_name="className")
-    def class_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "className"))
-
+    @jsii.member(jsii_name="parsers")
+    def parsers(self) -> typing.List["IFluentBitParserPlugin"]:
+        '''Collection of Fluent Bit parser plugins being configured for logging.
 
-class JdbcConnection(
-    Connection,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.JdbcConnection",
-):
-    '''Creates a Connection resource to a Java Database.
+        :group: Inputs
+        '''
+        return typing.cast(typing.List["IFluentBitParserPlugin"], jsii.get(self, "parsers"))
 
-    :see: `AWS::Glue::Connection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-connection.html>`_
-    '''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FargateLoggerOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "fargate_profiles": "fargateProfiles",
+        "filters": "filters",
+        "log_group": "logGroup",
+        "outputs": "outputs",
+        "parsers": "parsers",
+    },
+)
+class FargateLoggerOptions:
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        password: _aws_cdk_ceddda9d.SecretValue,
-        url: builtins.str,
-        username: builtins.str,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        description: typing.Optional[builtins.str] = None,
-        enforce_ssl: typing.Optional[builtins.bool] = None,
-        name: typing.Optional[builtins.str] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
+        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
     ) -> None:
-        '''Creates a new instance of the JdbcConnection class.
+        '''Optional configuration for the FargateLogger resource.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param password: A SecretValue providing the password for the Connection to authenticate to the source with.
-        :param url: The URL to the source for the Connection.
-        :param username: The username for the Connection to authenticate to the source with.
-        :param vpc: VPC to attach to the Connection.
-        :param description: A description of the Connection.
-        :param enforce_ssl: Boolean value on whether to require encryption on the Connection.
-        :param name: A name for the Connection.
-        :param security_groups: A list of Security Groups to apply to the Connection.
-        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
+        :param filters: The filters that should be applied to logs being processed.
+        :param log_group: The CloudWatch log group where Farget container logs will be sent.
+        :param outputs: The output destinations where logs should be written.
+        :param parsers: The parsers to be used when reading log files.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ea4b4cdb8cc43abef69d5aa672a86888b62abf53d134ac73a8ae113ee5f35600)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = JdbcConnectionProps(
-            password=password,
-            url=url,
-            username=username,
-            vpc=vpc,
-            description=description,
-            enforce_ssl=enforce_ssl,
-            name=name,
-            security_groups=security_groups,
-            subnets=subnets,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__5d9fa1ba40c2be86a241bebc6f8b6cc03215924d98659a18e99df90fd7eef185)
+            check_type(argname="argument fargate_profiles", value=fargate_profiles, expected_type=type_hints["fargate_profiles"])
+            check_type(argname="argument filters", value=filters, expected_type=type_hints["filters"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
+            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if fargate_profiles is not None:
+            self._values["fargate_profiles"] = fargate_profiles
+        if filters is not None:
+            self._values["filters"] = filters
+        if log_group is not None:
+            self._values["log_group"] = log_group
+        if outputs is not None:
+            self._values["outputs"] = outputs
+        if parsers is not None:
+            self._values["parsers"] = parsers
 
-        jsii.create(self.__class__, self, [scope, id, props])
+    @builtins.property
+    def fargate_profiles(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]]:
+        '''A default list of Fargate profiles that should have permissions configured.
+
+        Alternatively profiles can be added at any time by calling
+        ``addProfile``.
+        '''
+        result = self._values.get("fargate_profiles")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="password")
-    def password(self) -> _aws_cdk_ceddda9d.SecretValue:
-        '''{@link JdbcConnectionProps.password:}.'''
-        return typing.cast(_aws_cdk_ceddda9d.SecretValue, jsii.get(self, "password"))
+    def filters(self) -> typing.Optional[typing.List["IFluentBitFilterPlugin"]]:
+        '''The filters that should be applied to logs being processed.'''
+        result = self._values.get("filters")
+        return typing.cast(typing.Optional[typing.List["IFluentBitFilterPlugin"]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="url")
-    def url(self) -> builtins.str:
-        '''{@link JdbcConnectionProps.url:}.'''
-        return typing.cast(builtins.str, jsii.get(self, "url"))
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        '''The CloudWatch log group where Farget container logs will be sent.'''
+        result = self._values.get("log_group")
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
+
+    @builtins.property
+    def outputs(self) -> typing.Optional[typing.List["IFluentBitOutputPlugin"]]:
+        '''The output destinations where logs should be written.'''
+        result = self._values.get("outputs")
+        return typing.cast(typing.Optional[typing.List["IFluentBitOutputPlugin"]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="username")
-    def username(self) -> builtins.str:
-        '''{@link JdbcConnectionProps.username:}.'''
-        return typing.cast(builtins.str, jsii.get(self, "username"))
+    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
+        '''The parsers to be used when reading log files.'''
+        result = self._values.get("parsers")
+        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "FargateLoggerOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.JdbcConnectionProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.k8s_aws.FargateLoggerProps",
+    jsii_struct_bases=[FargateLoggerOptions, _aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
+        "fargate_profiles": "fargateProfiles",
+        "filters": "filters",
+        "log_group": "logGroup",
+        "outputs": "outputs",
+        "parsers": "parsers",
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "password": "password",
-        "url": "url",
-        "username": "username",
-        "vpc": "vpc",
-        "description": "description",
-        "enforce_ssl": "enforceSsl",
-        "name": "name",
-        "security_groups": "securityGroups",
-        "subnets": "subnets",
+        "cluster": "cluster",
     },
 )
-class JdbcConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
+class FargateLoggerProps(FargateLoggerOptions, _aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
+        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
+        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        password: _aws_cdk_ceddda9d.SecretValue,
-        url: builtins.str,
-        username: builtins.str,
-        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-        description: typing.Optional[builtins.str] = None,
-        enforce_ssl: typing.Optional[builtins.bool] = None,
-        name: typing.Optional[builtins.str] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
     ) -> None:
-        '''Configuration for the Glue Workflow resource.
+        '''Required configuration for the Fargate logger resource.
 
+        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
+        :param filters: The filters that should be applied to logs being processed.
+        :param log_group: The CloudWatch log group where Farget container logs will be sent.
+        :param outputs: The output destinations where logs should be written.
+        :param parsers: The parsers to be used when reading log files.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param password: A SecretValue providing the password for the Connection to authenticate to the source with.
-        :param url: The URL to the source for the Connection.
-        :param username: The username for the Connection to authenticate to the source with.
-        :param vpc: VPC to attach to the Connection.
-        :param description: A description of the Connection.
-        :param enforce_ssl: Boolean value on whether to require encryption on the Connection.
-        :param name: A name for the Connection.
-        :param security_groups: A list of Security Groups to apply to the Connection.
-        :param subnets: Options for selection of subnets from the VPC to attach to the Connection.
+        :param cluster: The EKS Cluster to configure Fargate logging for.
         '''
-        if isinstance(subnets, dict):
-            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__63235443ef95630aeef4ec6db0d062a07b1671eb3853e7158c18ed47070ed58a)
+            type_hints = typing.get_type_hints(_typecheckingstub__331f0ef39a4852c171fb3378d45e752361c5aa7515c6965a4852b6f54a58f900)
+            check_type(argname="argument fargate_profiles", value=fargate_profiles, expected_type=type_hints["fargate_profiles"])
+            check_type(argname="argument filters", value=filters, expected_type=type_hints["filters"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
+            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
-            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
-            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
-            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument enforce_ssl", value=enforce_ssl, expected_type=type_hints["enforce_ssl"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
-            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "password": password,
-            "url": url,
-            "username": username,
-            "vpc": vpc,
+            "cluster": cluster,
         }
+        if fargate_profiles is not None:
+            self._values["fargate_profiles"] = fargate_profiles
+        if filters is not None:
+            self._values["filters"] = filters
+        if log_group is not None:
+            self._values["log_group"] = log_group
+        if outputs is not None:
+            self._values["outputs"] = outputs
+        if parsers is not None:
+            self._values["parsers"] = parsers
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if description is not None:
-            self._values["description"] = description
-        if enforce_ssl is not None:
-            self._values["enforce_ssl"] = enforce_ssl
-        if name is not None:
-            self._values["name"] = name
-        if security_groups is not None:
-            self._values["security_groups"] = security_groups
-        if subnets is not None:
-            self._values["subnets"] = subnets
+
+    @builtins.property
+    def fargate_profiles(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]]:
+        '''A default list of Fargate profiles that should have permissions configured.
+
+        Alternatively profiles can be added at any time by calling
+        ``addProfile``.
+        '''
+        result = self._values.get("fargate_profiles")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]], result)
+
+    @builtins.property
+    def filters(self) -> typing.Optional[typing.List["IFluentBitFilterPlugin"]]:
+        '''The filters that should be applied to logs being processed.'''
+        result = self._values.get("filters")
+        return typing.cast(typing.Optional[typing.List["IFluentBitFilterPlugin"]], result)
+
+    @builtins.property
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        '''The CloudWatch log group where Farget container logs will be sent.'''
+        result = self._values.get("log_group")
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
+
+    @builtins.property
+    def outputs(self) -> typing.Optional[typing.List["IFluentBitOutputPlugin"]]:
+        '''The output destinations where logs should be written.'''
+        result = self._values.get("outputs")
+        return typing.cast(typing.Optional[typing.List["IFluentBitOutputPlugin"]], result)
+
+    @builtins.property
+    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
+        '''The parsers to be used when reading log files.'''
+        result = self._values.get("parsers")
+        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -2549,3002 +2641,4111 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def password(self) -> _aws_cdk_ceddda9d.SecretValue:
-        '''A SecretValue providing the password for the Connection to authenticate to the source with.
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS Cluster to configure Fargate logging for.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "FargateLoggerProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class FluentBitFilter(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitFilter",
+):
+    '''Standard filter options which can be applied to Fluent Bit to control the output and formatting of logs.
+
+    Filters change the structure of log records by doing things like adding
+    metadata to a record, restructuring a record, or adding and removing fields.
+    '''
+
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="appendFields")
+    @builtins.classmethod
+    def append_fields(
+        cls,
+        match: "FluentBitMatch",
+        *records: AppendedRecord,
+    ) -> "IFluentBitFilterPlugin":
+        '''Creates a filter that adds fields to a record that matches the given pattern.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param records: The fields to be added to matched records.
+
+        :return:
 
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("password")
-        assert result is not None, "Required property 'password' is missing"
-        return typing.cast(_aws_cdk_ceddda9d.SecretValue, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__004c6d6190020d8cdc3eea6ba900d6bb6b67d1b06e5b2c7a8650568795e29ce3)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument records", value=records, expected_type=typing.Tuple[type_hints["records"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "appendFields", [match, *records]))
 
-    @builtins.property
-    def url(self) -> builtins.str:
-        '''The URL to the source for the Connection.
+    @jsii.member(jsii_name="blacklistFields")
+    @builtins.classmethod
+    def blacklist_fields(
+        cls,
+        match: "FluentBitMatch",
+        *fields: builtins.str,
+    ) -> "IFluentBitFilterPlugin":
+        '''Creates a filter that removes a set of fields from any records that match a given pattern.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param fields: The fields which should be removed from the record if they are present.
 
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("url")
-        assert result is not None, "Required property 'url' is missing"
-        return typing.cast(builtins.str, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1e4fc805a8f96657a4f0acdced48b0a0ff8f731cc5e58787975d1636d9bea432)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "blacklistFields", [match, *fields]))
 
-    @builtins.property
-    def username(self) -> builtins.str:
-        '''The username for the Connection to authenticate to the source with.
+    @jsii.member(jsii_name="grep")
+    @builtins.classmethod
+    def grep(
+        cls,
+        match: "FluentBitMatch",
+        *,
+        key: builtins.str,
+        regex: builtins.str,
+        exclude: typing.Optional[builtins.bool] = None,
+    ) -> "IFluentBitFilterPlugin":
+        '''Filters log entries based on a pattern.
+
+        Log entries can be removed and
+        not forwarded based on whether they match or do not match the given
+        pattern.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param key: The key of the fields which you want to filter using the regex.
+        :param regex: The regular expression to apply to the specified field.
+        :param exclude: Whether the matched expression should exclude or include records from being output. When this is true, only records that match the given expression will be output. When this is false, only records that do not match the given expression will be output. Default: false
+
+        :return:
 
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("username")
-        assert result is not None, "Required property 'username' is missing"
-        return typing.cast(builtins.str, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ca125ae790631ee65913aa6e968ed7113cdb3174739710fcb3e049ee05e1225b)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+        pattern = FluentBitGrepRegex(key=key, regex=regex, exclude=exclude)
 
-    @builtins.property
-    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
-        '''VPC to attach to the Connection.
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "grep", [match, pattern]))
+
+    @jsii.member(jsii_name="kubernetes")
+    @builtins.classmethod
+    def kubernetes(cls, match: "FluentBitMatch") -> "IFluentBitFilterPlugin":
+        '''Adds Kubernetes metadata to output records including pod information, labels, etc..
 
-        :see: `IVpc Interface <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.IVpc.html>`_
+        :param match: A pattern filtering to which records the filter should be applied.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("vpc")
-        assert result is not None, "Required property 'vpc' is missing"
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e62ff1da65acb39396b806ce64d2c933f7f3b043f0f4ab5b9bcfde68b282300e)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "kubernetes", [match]))
 
-    @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description of the Connection.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="lift")
+    @builtins.classmethod
+    def lift(
+        cls,
+        match: "FluentBitMatch",
+        nested_under: builtins.str,
+    ) -> "IFluentBitFilterPlugin":
+        '''Lifts nested fields in a record up to their parent object.
 
-    @builtins.property
-    def enforce_ssl(self) -> typing.Optional[builtins.bool]:
-        '''Boolean value on whether to require encryption on the Connection.
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param nested_under: The record object under which you want to lift fields.
+
+        :return:
 
-        :see: `AWS::Glue::Connection ConnectionInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-connection-connectioninput.html#cfn-glue-connection-connectioninput-connectiontype>`_
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("enforce_ssl")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b7921055d17cd6ec5863079beb06bda4bbc0aba18764be3ca76b587d53f6a90c)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument nested_under", value=nested_under, expected_type=type_hints["nested_under"])
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "lift", [match, nested_under]))
 
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name for the Connection.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="modify")
+    @builtins.classmethod
+    def modify(
+        cls,
+        match: "FluentBitMatch",
+        *operations: "ModifyOperation",
+    ) -> "IFluentBitFilterPlugin":
+        '''Applies various transformations to matched records including adding, removing, copying, and renaming fields.
 
-    @builtins.property
-    def security_groups(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
-        '''A list of Security Groups to apply to the Connection.'''
-        result = self._values.get("security_groups")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param operations: The operations to apply to the matched records.
 
-    @builtins.property
-    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''Options for selection of subnets from the VPC to attach to the Connection.
+        :return:
 
-        :see: `CDK SubnetSelection <https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2.SubnetSelection.html>`_
+        A filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__70f785929f2989cc94f847423b39a2b6cda43109191a9c78fc4a821025615e83)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument operations", value=operations, expected_type=typing.Tuple[type_hints["operations"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "modify", [match, *operations]))
+
+    @jsii.member(jsii_name="nest")
+    @builtins.classmethod
+    def nest(
+        cls,
+        match: "FluentBitMatch",
+        nest_under: builtins.str,
+        *fields: builtins.str,
+    ) -> "IFluentBitFilterPlugin":
+        '''Nests a set of fields in a record under into a specified object.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param nest_under: The record object under which you want to nest matched fields.
+        :param fields: The fields to nest under the specified object.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0c44cc88268e3e2218cb706dfe1efc0b47f7a1d76b49addf6866c4a59ff82f54)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument nest_under", value=nest_under, expected_type=type_hints["nest_under"])
+            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "nest", [match, nest_under, *fields]))
+
+    @jsii.member(jsii_name="parser")
+    @builtins.classmethod
+    def parser(
+        cls,
+        match: "FluentBitMatch",
+        key: builtins.str,
+        *parsers: "IFluentBitParserPlugin",
+    ) -> "IFluentBitFilterPlugin":
+        '''Applies a set of parsers to matched records.
+
+        The parser is used to read the input record and set structured fields in
+        the output.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param key: The key of the field to be parsed.
+        :param parsers: The parser plugins to use to read matched records.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__10af575b9dbec2cd8ea9604aee8e29ee517e60f747a39b4910b6f4da1f217b83)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument parsers", value=parsers, expected_type=typing.Tuple[type_hints["parsers"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "parser", [match, key, *parsers]))
+
+    @jsii.member(jsii_name="rewriteTag")
+    @builtins.classmethod
+    def rewrite_tag(
+        cls,
+        match: "FluentBitMatch",
+        *rules: "RewriteTagRule",
+    ) -> "IFluentBitFilterPlugin":
+        '''Allows modification of tags set by the input configuration to affect the routing of when records are output.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param rules: The rules that define the matching criteria of format of the tag for the matching record.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7771595b84c711392921d6ddf6f6d52281f9711dd09522a93a530883167a8e3c)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument rules", value=rules, expected_type=typing.Tuple[type_hints["rules"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "rewriteTag", [match, *rules]))
+
+    @jsii.member(jsii_name="throttle")
+    @builtins.classmethod
+    def throttle(
+        cls,
+        match: "FluentBitMatch",
+        interval: _aws_cdk_ceddda9d.Duration,
+        rate: jsii.Number,
+        window: jsii.Number,
+    ) -> "IFluentBitFilterPlugin":
+        '''Sets an average rate of messages that are allowed to be output over a configured period of time.
+
+        When the rate of messages surpasses the configured limits messages will
+        be dropped.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param interval: The interval of time over rate should be sampled to calculate an average.
+        :param rate: The average amount of messages over a given period.
+        :param window: Amount of intervals to calculate average over.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c398af7ef351b52ad40eb09a1a0fcc6ae44187a82c5709af8cc8ea2d361cb61e)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
+            check_type(argname="argument rate", value=rate, expected_type=type_hints["rate"])
+            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "throttle", [match, interval, rate, window]))
+
+    @jsii.member(jsii_name="whitelistFields")
+    @builtins.classmethod
+    def whitelist_fields(
+        cls,
+        match: "FluentBitMatch",
+        *fields: builtins.str,
+    ) -> "IFluentBitFilterPlugin":
+        '''Creates a filter that removes all fields in a record that are not approved.
+
+        :param match: A pattern filtering to which records the filter should be applied.
+        :param fields: The fields which are allowed to appear in the output record.
+
+        :return:
+
+        A filter object that can be applied to the Fluent Bit
+        configuration.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4a171efbee53101c625ce2956a002515e474ab45a4b74604ffee5889c1053dd3)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "whitelistFields", [match, *fields]))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitFilterPluginCommonOptions",
+    jsii_struct_bases=[],
+    name_mapping={"match": "match"},
+)
+class FluentBitFilterPluginCommonOptions:
+    def __init__(self, *, match: typing.Optional["FluentBitMatch"] = None) -> None:
+        '''Configuration options that apply to all Fluent Bit output plugins.
+
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0a232fab3d929b1e9cdb75a64a4f3eec377e0983c1b4e4ffd68fc95cf216ee9d)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+
+    @builtins.property
+    def match(self) -> typing.Optional["FluentBitMatch"]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional["FluentBitMatch"], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "JdbcConnectionProps(%s)" % ", ".join(
+        return "FluentBitFilterPluginCommonOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(ICrawlerTarget)
-class JdbcTarget(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.JdbcTarget"):
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={"match": "match", "pattern": "pattern"},
+)
+class FluentBitGrepFilterOptions(FluentBitFilterPluginCommonOptions):
     def __init__(
         self,
-        connection: Connection,
         *,
-        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        paths: typing.Optional[typing.Sequence[builtins.str]] = None,
+        match: typing.Optional["FluentBitMatch"] = None,
+        pattern: typing.Union["FluentBitGrepRegex", typing.Dict[builtins.str, typing.Any]],
     ) -> None:
-        '''Creates a new instance of the JdbcTarget class.
+        '''Options for configuring the Grep Fluent Bit filter plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param pattern: The pattern to use for filtering records processed by the plugin.
 
-        :param connection: -
-        :param exclusions: A list of glob patterns used to exclude from the crawl. For more information
-        :param paths: The path of the JDBC target.
+        :see: `Grep Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/grep>`_
         '''
+        if isinstance(pattern, dict):
+            pattern = FluentBitGrepRegex(**pattern)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a5d7f10fe829e301eed5ff500477960d3c29565777d9d18780f32c7d84b383d7)
-            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
-        options = JdbcTargetOptions(exclusions=exclusions, paths=paths)
+            type_hints = typing.get_type_hints(_typecheckingstub__0367bee62bb2658dda6a19b32e999c85a7a98303ad453009919555866534b235)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "pattern": pattern,
+        }
+        if match is not None:
+            self._values["match"] = match
 
-        jsii.create(self.__class__, self, [connection, options])
+    @builtins.property
+    def match(self) -> typing.Optional["FluentBitMatch"]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional["FluentBitMatch"], result)
 
-    @jsii.member(jsii_name="addExclusion")
-    def add_exclusion(self, exclusion: builtins.str) -> None:
-        '''
-        :param exclusion: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__da7fc3d4ccd69b3e6ec79ea8dc2f9c31784d1adaa1616006b1c552d243329288)
-            check_type(argname="argument exclusion", value=exclusion, expected_type=type_hints["exclusion"])
-        return typing.cast(None, jsii.invoke(self, "addExclusion", [exclusion]))
+    @builtins.property
+    def pattern(self) -> "FluentBitGrepRegex":
+        '''The pattern to use for filtering records processed by the plugin.'''
+        result = self._values.get("pattern")
+        assert result is not None, "Required property 'pattern' is missing"
+        return typing.cast("FluentBitGrepRegex", result)
 
-    @jsii.member(jsii_name="addPath")
-    def add_path(self, path: builtins.str) -> None:
-        '''
-        :param path: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__92e89a811419b69c0f51822e3f45ff0bdd0ce6940b3afb1a59f04b14e85deab7)
-            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
-        return typing.cast(None, jsii.invoke(self, "addPath", [path]))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @jsii.member(jsii_name="bind")
-    def bind(self, _crawler: "Crawler") -> CrawlerTargetCollection:
-        '''
-        :param _crawler: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__519dc5422365574c38b31da5db0adb61aaeabbe542682317cab78a331d1d6b96)
-            check_type(argname="argument _crawler", value=_crawler, expected_type=type_hints["_crawler"])
-        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [_crawler]))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="connection")
-    def connection(self) -> Connection:
-        return typing.cast(Connection, jsii.get(self, "connection"))
+    def __repr__(self) -> str:
+        return "FluentBitGrepFilterOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.JdbcTargetOptions",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepRegex",
     jsii_struct_bases=[],
-    name_mapping={"exclusions": "exclusions", "paths": "paths"},
+    name_mapping={"key": "key", "regex": "regex", "exclude": "exclude"},
 )
-class JdbcTargetOptions:
+class FluentBitGrepRegex:
     def __init__(
         self,
         *,
-        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        paths: typing.Optional[typing.Sequence[builtins.str]] = None,
+        key: builtins.str,
+        regex: builtins.str,
+        exclude: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Configuration for Crawler JDBC target.
+        '''Configures a pattern to match against a Fluent Bit record.
 
-        :param exclusions: A list of glob patterns used to exclude from the crawl. For more information
-        :param paths: The path of the JDBC target.
+        :param key: The key of the fields which you want to filter using the regex.
+        :param regex: The regular expression to apply to the specified field.
+        :param exclude: Whether the matched expression should exclude or include records from being output. When this is true, only records that match the given expression will be output. When this is false, only records that do not match the given expression will be output. Default: false
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b92268978767ce15062df3f1f0b702e354d0abf8d764ee0dbedb1952ccd5b8f7)
-            check_type(argname="argument exclusions", value=exclusions, expected_type=type_hints["exclusions"])
-            check_type(argname="argument paths", value=paths, expected_type=type_hints["paths"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if exclusions is not None:
-            self._values["exclusions"] = exclusions
-        if paths is not None:
-            self._values["paths"] = paths
+            type_hints = typing.get_type_hints(_typecheckingstub__7d5213db46ae4f43816c9caa03cf901d34224d6f6abfb3d42513921dd5cdbb98)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+            check_type(argname="argument exclude", value=exclude, expected_type=type_hints["exclude"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "key": key,
+            "regex": regex,
+        }
+        if exclude is not None:
+            self._values["exclude"] = exclude
 
     @builtins.property
-    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''A list of glob patterns used to exclude from the crawl.
-
-        For more information
+    def key(self) -> builtins.str:
+        '''The key of the fields which you want to filter using the regex.'''
+        result = self._values.get("key")
+        assert result is not None, "Required property 'key' is missing"
+        return typing.cast(builtins.str, result)
 
-        :see: `Catalog Tables with a Crawler <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_
-        '''
-        result = self._values.get("exclusions")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+    @builtins.property
+    def regex(self) -> builtins.str:
+        '''The regular expression to apply to the specified field.'''
+        result = self._values.get("regex")
+        assert result is not None, "Required property 'regex' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def paths(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''The path of the JDBC target.
+    def exclude(self) -> typing.Optional[builtins.bool]:
+        '''Whether the matched expression should exclude or include records from being output.
+
+        When this is true, only records that match the given expression will be
+        output.
+
+        When this is false, only records that do not match the given expression
+        will be output.
 
-        :see: `AWS::Glue::Crawler JdbcTarget <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-jdbctarget.html#cfn-glue-crawler-jdbctarget-path>`_
+        :default: false
         '''
-        result = self._values.get("paths")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+        result = self._values.get("exclude")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "JdbcTargetOptions(%s)" % ", ".join(
+        return "FluentBitGrepRegex(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(IJob)
-class Job(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Job",
-):
-    '''Creates a Glue Job.
-
-    :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html>`_
-    '''
-
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKubernetesFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "annotations": "annotations",
+        "buffer_size": "bufferSize",
+        "cache_use_docker_id": "cacheUseDockerId",
+        "dns_retries": "dnsRetries",
+        "dns_wait_time": "dnsWaitTime",
+        "dummy_meta": "dummyMeta",
+        "k8s_logging_exclude": "k8sLoggingExclude",
+        "k8s_logging_parser": "k8sLoggingParser",
+        "keep_log": "keepLog",
+        "kube_ca_file": "kubeCaFile",
+        "kube_ca_path": "kubeCaPath",
+        "kubelet_host": "kubeletHost",
+        "kubelet_port": "kubeletPort",
+        "kube_meta_cache_ttl": "kubeMetaCacheTtl",
+        "kube_meta_preload_cache_dir": "kubeMetaPreloadCacheDir",
+        "kube_tag_prefix": "kubeTagPrefix",
+        "kube_token_command": "kubeTokenCommand",
+        "kube_token_file": "kubeTokenFile",
+        "kube_token_ttl": "kubeTokenTtl",
+        "kube_url": "kubeUrl",
+        "labels": "labels",
+        "merge_log": "mergeLog",
+        "merge_log_key": "mergeLogKey",
+        "merge_log_trim": "mergeLogTrim",
+        "merge_parser": "mergeParser",
+        "regex_parser": "regexParser",
+        "tls_debug": "tlsDebug",
+        "tls_verify": "tlsVerify",
+        "use_journal": "useJournal",
+        "use_kubelet": "useKubelet",
+    },
+)
+class FluentBitKubernetesFilterOptions(FluentBitFilterPluginCommonOptions):
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        executable: "JobExecutable",
-        allocated_capacity: typing.Optional[jsii.Number] = None,
-        connections: typing.Optional[typing.Sequence[Connection]] = None,
-        continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
-        default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        description: typing.Optional[builtins.str] = None,
-        enable_profiling_metrics: typing.Optional[builtins.bool] = None,
-        max_capacity: typing.Optional[jsii.Number] = None,
-        max_concurrent_runs: typing.Optional[jsii.Number] = None,
-        max_retries: typing.Optional[jsii.Number] = None,
-        name: typing.Optional[builtins.str] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        security_configuration: typing.Optional["SecurityConfiguration"] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        worker_count: typing.Optional[jsii.Number] = None,
-        worker_type: typing.Optional["WorkerType"] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the Job class.
+        match: typing.Optional["FluentBitMatch"] = None,
+        annotations: typing.Optional[builtins.bool] = None,
+        buffer_size: typing.Optional[_DataSize_d20aaece] = None,
+        cache_use_docker_id: typing.Optional[builtins.bool] = None,
+        dns_retries: typing.Optional[jsii.Number] = None,
+        dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        dummy_meta: typing.Optional[builtins.bool] = None,
+        k8s_logging_exclude: typing.Optional[builtins.bool] = None,
+        k8s_logging_parser: typing.Optional[builtins.bool] = None,
+        keep_log: typing.Optional[builtins.bool] = None,
+        kube_ca_file: typing.Optional[builtins.str] = None,
+        kube_ca_path: typing.Optional[builtins.str] = None,
+        kubelet_host: typing.Optional[builtins.str] = None,
+        kubelet_port: typing.Optional[jsii.Number] = None,
+        kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
+        kube_tag_prefix: typing.Optional[builtins.str] = None,
+        kube_token_command: typing.Optional[builtins.str] = None,
+        kube_token_file: typing.Optional[builtins.str] = None,
+        kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        kube_url: typing.Optional[builtins.str] = None,
+        labels: typing.Optional[builtins.bool] = None,
+        merge_log: typing.Optional[builtins.bool] = None,
+        merge_log_key: typing.Optional[builtins.str] = None,
+        merge_log_trim: typing.Optional[builtins.bool] = None,
+        merge_parser: typing.Optional[builtins.str] = None,
+        regex_parser: typing.Optional[builtins.str] = None,
+        tls_debug: typing.Optional[jsii.Number] = None,
+        tls_verify: typing.Optional[builtins.bool] = None,
+        use_journal: typing.Optional[builtins.bool] = None,
+        use_kubelet: typing.Optional[builtins.bool] = None,
+    ) -> None:
+        '''Options for configuring the Kubernetes Fluent Bit filter plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param annotations: Include Kubernetes resource annotations in the extra metadata. Default: true
+        :param buffer_size: Set the buffer size for HTTP client when reading responses from Kubernetes API server. A value of 0 results in no limit, and the buffer will expand as-needed. Note that if pod specifications exceed the buffer limit, the API response will be discarded when retrieving metadata, and some kubernetes metadata will fail to be injected to the logs. Default: 32k
+        :param cache_use_docker_id: When enabled, metadata will be fetched from K8s when docker_id is changed. Default: false
+        :param dns_retries: DNS lookup retries N times until the network starts working. Default: 6
+        :param dns_wait_time: DNS lookup interval between network status checks. Default: 30 seconds
+        :param dummy_meta: If set, use dummy-meta data (for test/dev purposes). Default: false
+        :param k8s_logging_exclude: Allow Kubernetes Pods to exclude their logs from the log processor. Default: false
+        :param k8s_logging_parser: Allow Kubernetes Pods to suggest a pre-defined Parser. Default: false
+        :param keep_log: When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well). Default: true
+        :param kube_ca_file: CA certificate file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
+        :param kube_ca_path: Absolute path to scan for certificate files.
+        :param kubelet_host: Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
+        :param kubelet_port: Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled. Default: 10250
+        :param kube_meta_cache_ttl: Configurable TTL for K8s cached metadata. By default, it is set to 0 which means TTL for cache entries is disabled and cache entries are evicted at random when capacity is reached. In order to enable this option, you should set the number to a time interval. Default: 0
+        :param kube_meta_preload_cache_dir: If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
+        :param kube_tag_prefix: When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration. Default: 'kube.var.log.containers.'
+        :param kube_token_command: Command to get Kubernetes authorization token. If you want to manually choose a command to get it, you can set the command here. For example, run running the following to get the token using aws-cli:: aws-iam-authenticator -i your-cluster-name token --token-only This option is currently Linux-only.
+        :param kube_token_file: Token file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
+        :param kube_token_ttl: Configurable 'time to live' for the K8s token. After this time, the token is reloaded from ``kubeTokenFile`` or the ``kubeTokenCommand``. Default: 10 minutes
+        :param kube_url: API Server end-point. Default: 'https://kubernetes.default.svc/'
+        :param labels: Include Kubernetes resource labels in the extra metadata. Default: true
+        :param merge_log: When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure. Default: false
+        :param merge_log_key: When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map. Now if ``mergeLogKey`` is set (a string name), all the new structured fields taken from the original ``log`` content are inserted under the new key.
+        :param merge_log_trim: When Merge_Log is enabled, trim (remove possible \\n or \\r) field values. Default: true
+        :param merge_parser: Optional parser name to specify how to parse the data contained in the log key. Recommended use is for developers or testing only.
+        :param regex_parser: Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id. The parser must be registered in a parsers file.
+        :param tls_debug: Debug level between 0 (nothing) and 4 (every detail). Default: -1
+        :param tls_verify: When enabled, turns on certificate validation when connecting to the Kubernetes API server. Default: true
+        :param use_journal: When enabled, the filter reads logs coming in Journald format. Default: false
+        :param use_kubelet: This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log. Default: false
+
+        :see: `Kubernetes Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__491341e10d39ab453cf8cb9ce79aa79883683ad1bef71b12d50956da0005ed71)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
+            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
+            check_type(argname="argument cache_use_docker_id", value=cache_use_docker_id, expected_type=type_hints["cache_use_docker_id"])
+            check_type(argname="argument dns_retries", value=dns_retries, expected_type=type_hints["dns_retries"])
+            check_type(argname="argument dns_wait_time", value=dns_wait_time, expected_type=type_hints["dns_wait_time"])
+            check_type(argname="argument dummy_meta", value=dummy_meta, expected_type=type_hints["dummy_meta"])
+            check_type(argname="argument k8s_logging_exclude", value=k8s_logging_exclude, expected_type=type_hints["k8s_logging_exclude"])
+            check_type(argname="argument k8s_logging_parser", value=k8s_logging_parser, expected_type=type_hints["k8s_logging_parser"])
+            check_type(argname="argument keep_log", value=keep_log, expected_type=type_hints["keep_log"])
+            check_type(argname="argument kube_ca_file", value=kube_ca_file, expected_type=type_hints["kube_ca_file"])
+            check_type(argname="argument kube_ca_path", value=kube_ca_path, expected_type=type_hints["kube_ca_path"])
+            check_type(argname="argument kubelet_host", value=kubelet_host, expected_type=type_hints["kubelet_host"])
+            check_type(argname="argument kubelet_port", value=kubelet_port, expected_type=type_hints["kubelet_port"])
+            check_type(argname="argument kube_meta_cache_ttl", value=kube_meta_cache_ttl, expected_type=type_hints["kube_meta_cache_ttl"])
+            check_type(argname="argument kube_meta_preload_cache_dir", value=kube_meta_preload_cache_dir, expected_type=type_hints["kube_meta_preload_cache_dir"])
+            check_type(argname="argument kube_tag_prefix", value=kube_tag_prefix, expected_type=type_hints["kube_tag_prefix"])
+            check_type(argname="argument kube_token_command", value=kube_token_command, expected_type=type_hints["kube_token_command"])
+            check_type(argname="argument kube_token_file", value=kube_token_file, expected_type=type_hints["kube_token_file"])
+            check_type(argname="argument kube_token_ttl", value=kube_token_ttl, expected_type=type_hints["kube_token_ttl"])
+            check_type(argname="argument kube_url", value=kube_url, expected_type=type_hints["kube_url"])
+            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
+            check_type(argname="argument merge_log", value=merge_log, expected_type=type_hints["merge_log"])
+            check_type(argname="argument merge_log_key", value=merge_log_key, expected_type=type_hints["merge_log_key"])
+            check_type(argname="argument merge_log_trim", value=merge_log_trim, expected_type=type_hints["merge_log_trim"])
+            check_type(argname="argument merge_parser", value=merge_parser, expected_type=type_hints["merge_parser"])
+            check_type(argname="argument regex_parser", value=regex_parser, expected_type=type_hints["regex_parser"])
+            check_type(argname="argument tls_debug", value=tls_debug, expected_type=type_hints["tls_debug"])
+            check_type(argname="argument tls_verify", value=tls_verify, expected_type=type_hints["tls_verify"])
+            check_type(argname="argument use_journal", value=use_journal, expected_type=type_hints["use_journal"])
+            check_type(argname="argument use_kubelet", value=use_kubelet, expected_type=type_hints["use_kubelet"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if annotations is not None:
+            self._values["annotations"] = annotations
+        if buffer_size is not None:
+            self._values["buffer_size"] = buffer_size
+        if cache_use_docker_id is not None:
+            self._values["cache_use_docker_id"] = cache_use_docker_id
+        if dns_retries is not None:
+            self._values["dns_retries"] = dns_retries
+        if dns_wait_time is not None:
+            self._values["dns_wait_time"] = dns_wait_time
+        if dummy_meta is not None:
+            self._values["dummy_meta"] = dummy_meta
+        if k8s_logging_exclude is not None:
+            self._values["k8s_logging_exclude"] = k8s_logging_exclude
+        if k8s_logging_parser is not None:
+            self._values["k8s_logging_parser"] = k8s_logging_parser
+        if keep_log is not None:
+            self._values["keep_log"] = keep_log
+        if kube_ca_file is not None:
+            self._values["kube_ca_file"] = kube_ca_file
+        if kube_ca_path is not None:
+            self._values["kube_ca_path"] = kube_ca_path
+        if kubelet_host is not None:
+            self._values["kubelet_host"] = kubelet_host
+        if kubelet_port is not None:
+            self._values["kubelet_port"] = kubelet_port
+        if kube_meta_cache_ttl is not None:
+            self._values["kube_meta_cache_ttl"] = kube_meta_cache_ttl
+        if kube_meta_preload_cache_dir is not None:
+            self._values["kube_meta_preload_cache_dir"] = kube_meta_preload_cache_dir
+        if kube_tag_prefix is not None:
+            self._values["kube_tag_prefix"] = kube_tag_prefix
+        if kube_token_command is not None:
+            self._values["kube_token_command"] = kube_token_command
+        if kube_token_file is not None:
+            self._values["kube_token_file"] = kube_token_file
+        if kube_token_ttl is not None:
+            self._values["kube_token_ttl"] = kube_token_ttl
+        if kube_url is not None:
+            self._values["kube_url"] = kube_url
+        if labels is not None:
+            self._values["labels"] = labels
+        if merge_log is not None:
+            self._values["merge_log"] = merge_log
+        if merge_log_key is not None:
+            self._values["merge_log_key"] = merge_log_key
+        if merge_log_trim is not None:
+            self._values["merge_log_trim"] = merge_log_trim
+        if merge_parser is not None:
+            self._values["merge_parser"] = merge_parser
+        if regex_parser is not None:
+            self._values["regex_parser"] = regex_parser
+        if tls_debug is not None:
+            self._values["tls_debug"] = tls_debug
+        if tls_verify is not None:
+            self._values["tls_verify"] = tls_verify
+        if use_journal is not None:
+            self._values["use_journal"] = use_journal
+        if use_kubelet is not None:
+            self._values["use_kubelet"] = use_kubelet
+
+    @builtins.property
+    def match(self) -> typing.Optional["FluentBitMatch"]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional["FluentBitMatch"], result)
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param executable: Executable properties for the Job.
-        :param allocated_capacity: The number of capacity units that are allocated to this job.
-        :param connections: List of Connections for use with this job.
-        :param continuous_logging: Set of properties for configuration of Continuous Logging.
-        :param default_arguments: The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param description: A description of the job.
-        :param enable_profiling_metrics: Boolean value for whether to enable Profiling Metrics.
-        :param max_capacity: The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:: - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
-        :param max_concurrent_runs: Maximum number of concurrent executions.
-        :param max_retries: The maximum number of times to retry this job after a JobRun fails.
-        :param name: A name for the Job.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param role: The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
-        :param security_configuration: The Security Configuration object to be applied to the Job.
-        :param timeout: The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
-        :param worker_count: The number of worker available the Job.
-        :param worker_type: The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+    @builtins.property
+    def annotations(self) -> typing.Optional[builtins.bool]:
+        '''Include Kubernetes resource annotations in the extra metadata.
+
+        :default: true
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dfd3e838082701af10fa1c63f23e3acc6bf12935d1a61850f26bc4a6088bfcd6)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = JobProps(
-            executable=executable,
-            allocated_capacity=allocated_capacity,
-            connections=connections,
-            continuous_logging=continuous_logging,
-            default_arguments=default_arguments,
-            description=description,
-            enable_profiling_metrics=enable_profiling_metrics,
-            max_capacity=max_capacity,
-            max_concurrent_runs=max_concurrent_runs,
-            max_retries=max_retries,
-            name=name,
-            notify_delay_after=notify_delay_after,
-            role=role,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            worker_count=worker_count,
-            worker_type=worker_type,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        result = self._values.get("annotations")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        jsii.create(self.__class__, self, [scope, id, props])
+    @builtins.property
+    def buffer_size(self) -> typing.Optional[_DataSize_d20aaece]:
+        '''Set the buffer size for HTTP client when reading responses from Kubernetes API server.
 
-    @jsii.member(jsii_name="fromJobArn")
-    @builtins.classmethod
-    def from_job_arn(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        job_arn: builtins.str,
-    ) -> IJob:
-        '''Imports an existing job using its Amazon Resource Name (ARN).
+        A value of 0 results in no limit, and the buffer will expand as-needed.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param job_arn: The ARN of the job to import.
+        Note that if pod specifications exceed the buffer limit, the API
+        response will be discarded when retrieving metadata, and some kubernetes
+        metadata will fail to be injected to the logs.
 
-        :return: An object representing the job that was imported.
+        :default: 32k
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__6ad00a49f903b8ff296c1040af14b52c5c710377bccb726a03b7db29113abd37)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument job_arn", value=job_arn, expected_type=type_hints["job_arn"])
-        return typing.cast(IJob, jsii.sinvoke(cls, "fromJobArn", [scope, id, job_arn]))
+        result = self._values.get("buffer_size")
+        return typing.cast(typing.Optional[_DataSize_d20aaece], result)
 
-    @jsii.member(jsii_name="fromJobName")
-    @builtins.classmethod
-    def from_job_name(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        job_name: builtins.str,
-    ) -> IJob:
-        '''Imports an existing job using its name.
+    @builtins.property
+    def cache_use_docker_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, metadata will be fetched from K8s when docker_id is changed.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param job_name: The name of the job to import.
+        :default: false
+        '''
+        result = self._values.get("cache_use_docker_id")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def dns_retries(self) -> typing.Optional[jsii.Number]:
+        '''DNS lookup retries N times until the network starts working.
 
-        :return: An object representing the job that was imported.
+        :default: 6
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4b9945957a7dfb3942132fbf1eea0248c28d8f65d0f02d1af6fdcecafa689b66)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
-        return typing.cast(IJob, jsii.sinvoke(cls, "fromJobName", [scope, id, job_name]))
+        result = self._values.get("dns_retries")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def dns_wait_time(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''DNS lookup interval between network status checks.
 
-    @jsii.member(jsii_name="addArgument")
-    def add_argument(self, key: builtins.str, value: builtins.str) -> None:
+        :default: 30 seconds
         '''
-        :param key: -
-        :param value: -
+        result = self._values.get("dns_wait_time")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+
+    @builtins.property
+    def dummy_meta(self) -> typing.Optional[builtins.bool]:
+        '''If set, use dummy-meta data (for test/dev purposes).
+
+        :default: false
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__35613a54fa94475a1d6f92b6c0df6312b31ea05071004c65f6f6d6c38b3540b2)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addArgument", [key, value]))
+        result = self._values.get("dummy_meta")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-    @jsii.member(jsii_name="addConnection")
-    def add_connection(self, connection: Connection) -> None:
+    @builtins.property
+    def k8s_logging_exclude(self) -> typing.Optional[builtins.bool]:
+        '''Allow Kubernetes Pods to exclude their logs from the log processor.
+
+        :default: false
         '''
-        :param connection: -
+        result = self._values.get("k8s_logging_exclude")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def k8s_logging_parser(self) -> typing.Optional[builtins.bool]:
+        '''Allow Kubernetes Pods to suggest a pre-defined Parser.
+
+        :default: false
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9d6f7c32eed0df35efff9f38d209a916c1ac797af98a30c7d4b12c9945e72399)
-            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
-        return typing.cast(None, jsii.invoke(self, "addConnection", [connection]))
+        result = self._values.get("k8s_logging_parser")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="executable")
-    def executable(self) -> "JobExecutable":
-        '''{@link JobProps.executable:}.'''
-        return typing.cast("JobExecutable", jsii.get(self, "executable"))
+    def keep_log(self) -> typing.Optional[builtins.bool]:
+        '''When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well).
+
+        :default: true
+        '''
+        result = self._values.get("keep_log")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="jobArn")
-    def job_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the job.'''
-        return typing.cast(builtins.str, jsii.get(self, "jobArn"))
+    def kube_ca_file(self) -> typing.Optional[builtins.str]:
+        '''CA certificate file.
+
+        :default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
+        '''
+        result = self._values.get("kube_ca_file")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="jobName")
-    def job_name(self) -> builtins.str:
-        '''The name of the job.'''
-        return typing.cast(builtins.str, jsii.get(self, "jobName"))
+    def kube_ca_path(self) -> typing.Optional[builtins.str]:
+        '''Absolute path to scan for certificate files.'''
+        result = self._values.get("kube_ca_path")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnJob:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnJob, jsii.get(self, "resource"))
+    def kubelet_host(self) -> typing.Optional[builtins.str]:
+        '''Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.'''
+        result = self._values.get("kubelet_host")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="role")
-    def role(self) -> _aws_cdk_aws_iam_ceddda9d.IRole:
-        return typing.cast(_aws_cdk_aws_iam_ceddda9d.IRole, jsii.get(self, "role"))
+    def kubelet_port(self) -> typing.Optional[jsii.Number]:
+        '''Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled.
+
+        :default: 10250
+        '''
+        result = self._values.get("kubelet_port")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="allocatedCapacity")
-    def allocated_capacity(self) -> typing.Optional[jsii.Number]:
-        '''{@link JobProps.allocatedCapacity }.'''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocatedCapacity"))
+    def kube_meta_cache_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''Configurable TTL for K8s cached metadata.
+
+        By default, it is set to 0 which means TTL for cache entries is disabled
+        and cache entries are evicted at random when capacity is reached.
+
+        In order to enable this option, you should set the number to a time
+        interval.
+
+        :default: 0
+        '''
+        result = self._values.get("kube_meta_cache_ttl")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    @jsii.member(jsii_name="connections")
-    def connections(self) -> typing.Optional[typing.List[Connection]]:
-        '''{@link JobProps.connections}.'''
-        return typing.cast(typing.Optional[typing.List[Connection]], jsii.get(self, "connections"))
+    def kube_meta_preload_cache_dir(self) -> typing.Optional[builtins.str]:
+        '''If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.'''
+        result = self._values.get("kube_meta_preload_cache_dir")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="continuousLogging")
-    def continuous_logging(self) -> typing.Optional[ContinuousLoggingProps]:
-        '''{@link JobProps.continuousLogging}.'''
-        return typing.cast(typing.Optional[ContinuousLoggingProps], jsii.get(self, "continuousLogging"))
+    def kube_tag_prefix(self) -> typing.Optional[builtins.str]:
+        '''When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration.
+
+        :default: 'kube.var.log.containers.'
+        '''
+        result = self._values.get("kube_tag_prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link JobProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    def kube_token_command(self) -> typing.Optional[builtins.str]:
+        '''Command to get Kubernetes authorization token.
+
+        If you want to manually choose a command to get it, you can set the
+        command here.
+
+        For example, run running the following to get the token using aws-cli::
+
+           aws-iam-authenticator -i your-cluster-name token --token-only
+
+        This option is currently Linux-only.
+        '''
+        result = self._values.get("kube_token_command")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="logGroup")
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], jsii.get(self, "logGroup"))
+    def kube_token_file(self) -> typing.Optional[builtins.str]:
+        '''Token file.
+
+        :default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
+        '''
+        result = self._values.get("kube_token_file")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="maxCapacity")
-    def max_capacity(self) -> typing.Optional[jsii.Number]:
-        '''{@link JobProps.maxCapacity}.'''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxCapacity"))
-
-    @builtins.property
-    @jsii.member(jsii_name="maxConcurrentRuns")
-    def max_concurrent_runs(self) -> typing.Optional[jsii.Number]:
-        '''{@link JobProps.maxConcurrentRuns}.'''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxConcurrentRuns"))
-
-    @builtins.property
-    @jsii.member(jsii_name="maxRetries")
-    def max_retries(self) -> typing.Optional[jsii.Number]:
-        '''{@link JobProps.maxRetries}.'''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxRetries"))
+    def kube_token_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''Configurable 'time to live' for the K8s token.
+
+        After this time, the token is reloaded from ``kubeTokenFile`` or the
+        ``kubeTokenCommand``.
+
+        :default: 10 minutes
+        '''
+        result = self._values.get("kube_token_ttl")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link JobProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    def kube_url(self) -> typing.Optional[builtins.str]:
+        '''API Server end-point.
+
+        :default: 'https://kubernetes.default.svc/'
+        '''
+        result = self._values.get("kube_url")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="notifyDelayAfter")
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''{@link JobProps.notifyDelayAfter}.'''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "notifyDelayAfter"))
+    def labels(self) -> typing.Optional[builtins.bool]:
+        '''Include Kubernetes resource labels in the extra metadata.
+
+        :default: true
+        '''
+        result = self._values.get("labels")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="securityConfiguration")
-    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
-        '''{@link JobProps.securityConfiguration}.'''
-        return typing.cast(typing.Optional["SecurityConfiguration"], jsii.get(self, "securityConfiguration"))
+    def merge_log(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure.
+
+        :default: false
+        '''
+        result = self._values.get("merge_log")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeout")
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''{@link JobProps.timeout}.'''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "timeout"))
+    def merge_log_key(self) -> typing.Optional[builtins.str]:
+        '''When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map.
+
+        Now if ``mergeLogKey`` is set (a string name), all the new structured
+        fields taken from the original ``log`` content are inserted under the new
+        key.
+        '''
+        result = self._values.get("merge_log_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="workerCount")
-    def worker_count(self) -> typing.Optional[jsii.Number]:
-        '''{@link JobProps.workerCount}.'''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workerCount"))
+    def merge_log_trim(self) -> typing.Optional[builtins.bool]:
+        '''When Merge_Log is enabled, trim (remove possible \\n or \\r) field values.
+
+        :default: true
+        '''
+        result = self._values.get("merge_log_trim")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="workerType")
-    def worker_type(self) -> typing.Optional["WorkerType"]:
-        '''{@link JobProps.workerType}.'''
-        return typing.cast(typing.Optional["WorkerType"], jsii.get(self, "workerType"))
+    def merge_parser(self) -> typing.Optional[builtins.str]:
+        '''Optional parser name to specify how to parse the data contained in the log key.
 
+        Recommended use is for developers or testing only.
+        '''
+        result = self._values.get("merge_parser")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.JobBookmarksEncryption",
-    jsii_struct_bases=[],
-    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
-)
-class JobBookmarksEncryption:
-    def __init__(
-        self,
-        *,
-        mode: "JobBookmarksEncryptionMode",
-        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
-    ) -> None:
-        '''Job bookmarks encryption configuration.
+    @builtins.property
+    def regex_parser(self) -> typing.Optional[builtins.str]:
+        '''Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id.
+
+        The parser must be registered in a parsers file.
 
-        :param mode: Encryption mode.
-        :param kms_key: The KMS key to be used to encrypt the data. Default: A key will be created if one is not provided.
+        :see: `Parsers File <https://github.com/fluent/fluent-bit/blob/master/conf/parsers.conf>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__de865e59b5a9d704335fa3900bcc2d054fc4bd594443f79fb978f7aecce4d7a2)
-            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
-            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "mode": mode,
-        }
-        if kms_key is not None:
-            self._values["kms_key"] = kms_key
+        result = self._values.get("regex_parser")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def mode(self) -> "JobBookmarksEncryptionMode":
-        '''Encryption mode.'''
-        result = self._values.get("mode")
-        assert result is not None, "Required property 'mode' is missing"
-        return typing.cast("JobBookmarksEncryptionMode", result)
+    def tls_debug(self) -> typing.Optional[jsii.Number]:
+        '''Debug level between 0 (nothing) and 4 (every detail).
+
+        :default: -1
+        '''
+        result = self._values.get("tls_debug")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
-        '''The KMS key to be used to encrypt the data.
+    def tls_verify(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, turns on certificate validation when connecting to the Kubernetes API server.
 
-        :default: A key will be created if one is not provided.
+        :default: true
         '''
-        result = self._values.get("kms_key")
-        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
+        result = self._values.get("tls_verify")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def use_journal(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, the filter reads logs coming in Journald format.
+
+        :default: false
+        '''
+        result = self._values.get("use_journal")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def use_kubelet(self) -> typing.Optional[builtins.bool]:
+        '''This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log.
+
+        :default: false
+
+        :see: `Kube API heavy traffic issue for large cluster <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes#optional-feature-using-kubelet-to-get-metadata>`_
+        '''
+        result = self._values.get("use_kubelet")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "JobBookmarksEncryption(%s)" % ", ".join(
+        return "FluentBitKubernetesFilterOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.JobBookmarksEncryptionMode")
-class JobBookmarksEncryptionMode(enum.Enum):
-    '''Encryption mode for Job Bookmarks.
-
-    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_JobBookmarksEncryption.html#Glue-Type-JobBookmarksEncryption-JobBookmarksEncryptionMode
-    '''
+class FluentBitLogGroupOutput(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLogGroupOutput",
+):
+    '''Represents valid log group output configuration options to be used by Fluent Bit when writing to CloudWatch Logs.'''
 
-    CLIENT_SIDE_KMS = "CLIENT_SIDE_KMS"
-    '''Client-side encryption (CSE) with an AWS KMS key managed by the account owner.
+    @jsii.member(jsii_name="create")
+    @builtins.classmethod
+    def create(cls) -> "FluentBitLogGroupOutput":
+        '''Sets a flag saying that a log group should be created automatically.
 
-    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingClientSideEncryption.html
-    '''
+        Depending on the configuration of the plugin, this flag will either cause
+        permissions to be granted for Fluent Bit to create the log group itself or
+        the plugin CDK resource will create a Log Group and use that as the
+        destination.
 
+        :return:
 
-class JobExecutable(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.JobExecutable",
-):
-    '''The executable properties related to the Glue job's GlueVersion, JobType and code.'''
+        A FluentBitLogGroupOutput object representing the configured log
+        group destination.
+        '''
+        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "create", []))
 
-    @jsii.member(jsii_name="of")
+    @jsii.member(jsii_name="fromLogGroup")
     @builtins.classmethod
-    def of(
+    def from_log_group(
         cls,
-        *,
-        glue_version: GlueVersion,
-        language: "JobLanguage",
-        script: Code,
-        type: "JobType",
-        class_name: typing.Optional[builtins.str] = None,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-        python_version: typing.Optional["PythonVersion"] = None,
-    ) -> "JobExecutable":
-        '''Create a custom JobExecutable.
-
-        :param glue_version: Glue version.
-        :param language: The language of the job (Scala or Python).
-        :param script: The script that is executed by a job.
-        :param type: Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.
-        :param class_name: The Scala class that serves as the entry point for the job. This applies only if your the job langauage is Scala. Default: - no scala className specified
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Default: - no extra files specified.
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Default: - no extra jars specified.
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: - extra jars are not prioritized.
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Default: - no extra python files specified.
-        :param python_version: The Python version to use. Default: - no python version specified
-        '''
-        config = JobExecutableConfig(
-            glue_version=glue_version,
-            language=language,
-            script=script,
-            type=type,
-            class_name=class_name,
-            extra_files=extra_files,
-            extra_jars=extra_jars,
-            extra_jars_first=extra_jars_first,
-            extra_python_files=extra_python_files,
-            python_version=python_version,
-        )
+        log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
+    ) -> "FluentBitLogGroupOutput":
+        '''Sets the destination log group to a LogGroup CDK resource.
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "of", [config]))
+        :param log_group: The log group where output records should be written.
 
-    @jsii.member(jsii_name="pythonEtl")
-    @builtins.classmethod
-    def python_etl(
-        cls,
-        *,
-        glue_version: GlueVersion,
-        python_version: "PythonVersion",
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-    ) -> "JobExecutable":
-        '''Create Python executable props for Apache Spark ETL job.
-
-        :param glue_version: Glue version.
-        :param python_version: The Python version to use.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
-        '''
-        props = PythonSparkJobExecutableProps(
-            glue_version=glue_version,
-            python_version=python_version,
-            script=script,
-            extra_files=extra_files,
-            extra_jars=extra_jars,
-            extra_jars_first=extra_jars_first,
-            extra_python_files=extra_python_files,
-        )
+        :return:
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonEtl", [props]))
+        A FluentBitLogGroupOutput object representing the configured log
+        group destination.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9e5f787f6c53b83309ad3224ae7cbd397dc281f463e865210fadeede93199ea7)
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "fromLogGroup", [log_group]))
 
-    @jsii.member(jsii_name="pythonShell")
+    @jsii.member(jsii_name="fromName")
     @builtins.classmethod
-    def python_shell(
+    def from_name(
         cls,
-        *,
-        glue_version: GlueVersion,
-        python_version: "PythonVersion",
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-    ) -> "JobExecutable":
-        '''Create Python executable props for python shell jobs.
-
-        :param glue_version: Glue version.
-        :param python_version: The Python version to use.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
-        '''
-        props = PythonShellExecutableProps(
-            glue_version=glue_version,
-            python_version=python_version,
-            script=script,
-            extra_files=extra_files,
-            extra_python_files=extra_python_files,
-        )
+        name: builtins.str,
+        create: typing.Optional[builtins.bool] = None,
+    ) -> "FluentBitLogGroupOutput":
+        '''Sets the destination for logs to the named log group.
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonShell", [props]))
+        :param name: The name of the log group where output records should be written.
+        :param create: -
 
-    @jsii.member(jsii_name="pythonStreaming")
-    @builtins.classmethod
-    def python_streaming(
-        cls,
-        *,
-        glue_version: GlueVersion,
-        python_version: "PythonVersion",
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-    ) -> "JobExecutable":
-        '''Create Python executable props for Apache Spark Streaming job.
-
-        :param glue_version: Glue version.
-        :param python_version: The Python version to use.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
-        '''
-        props = PythonSparkJobExecutableProps(
-            glue_version=glue_version,
-            python_version=python_version,
-            script=script,
-            extra_files=extra_files,
-            extra_jars=extra_jars,
-            extra_jars_first=extra_jars_first,
-            extra_python_files=extra_python_files,
-        )
+        :return:
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "pythonStreaming", [props]))
+        A FluentBitLogGroupOutput object representing the configured log
+        group destination.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__67456e5d91f4ffd1bec1ee1e4391d0f4f5ae2b0b2d8f9151cd8a758ce8565c1d)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
+        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "fromName", [name, create]))
 
-    @jsii.member(jsii_name="scalaEtl")
-    @builtins.classmethod
-    def scala_etl(
-        cls,
-        *,
-        class_name: builtins.str,
-        glue_version: GlueVersion,
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-    ) -> "JobExecutable":
-        '''Create Scala executable props for Apache Spark ETL job.
-
-        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
-        :param glue_version: Glue version.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        '''
-        props = ScalaJobExecutableProps(
-            class_name=class_name,
-            glue_version=glue_version,
-            script=script,
-            extra_files=extra_files,
-            extra_jars=extra_jars,
-            extra_jars_first=extra_jars_first,
-        )
+    @builtins.property
+    @jsii.member(jsii_name="autoCreate")
+    def auto_create(self) -> typing.Optional[builtins.bool]:
+        '''Flag that determines whether or not a log group should be automatically created.'''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoCreate"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logGroup")
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        '''A log group resource object to use as the destination.'''
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], jsii.get(self, "logGroup"))
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "scalaEtl", [props]))
+    @builtins.property
+    @jsii.member(jsii_name="logGroupName")
+    def log_group_name(self) -> typing.Optional[builtins.str]:
+        '''The name for the log group that should be used for output records.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupName"))
+
+
+class FluentBitLogStreamOutput(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLogStreamOutput",
+):
+    '''Represents valid log stream output configuration options to be used by Fluent Bit when writing to CloudWatch Logs.'''
 
-    @jsii.member(jsii_name="scalaStreaming")
+    @jsii.member(jsii_name="fromLogStream")
     @builtins.classmethod
-    def scala_streaming(
+    def from_log_stream(
         cls,
-        *,
-        class_name: builtins.str,
-        glue_version: GlueVersion,
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-    ) -> "JobExecutable":
-        '''Create Scala executable props for Apache Spark Streaming job.
-
-        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
-        :param glue_version: Glue version.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        '''
-        props = ScalaJobExecutableProps(
-            class_name=class_name,
-            glue_version=glue_version,
-            script=script,
-            extra_files=extra_files,
-            extra_jars=extra_jars,
-            extra_jars_first=extra_jars_first,
-        )
+        log_stream: _aws_cdk_aws_logs_ceddda9d.ILogStream,
+    ) -> "FluentBitLogStreamOutput":
+        '''Sets output to be a log stream resource object.
 
-        return typing.cast("JobExecutable", jsii.sinvoke(cls, "scalaStreaming", [props]))
+        :param log_stream: The log stream where records should be written.
 
-    @jsii.member(jsii_name="bind")
-    def bind(self) -> "JobExecutableConfig":
-        '''Called during Job initialization to get JobExecutableConfig.'''
-        return typing.cast("JobExecutableConfig", jsii.invoke(self, "bind", []))
+        :return:
 
+        A FluentBitLogStreamOutput object representing the configured
+        log stream destination.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bf36bc82a5087381a1e00eedb991062da3fb86e1b1b2dc82f40a25d98c830a03)
+            check_type(argname="argument log_stream", value=log_stream, expected_type=type_hints["log_stream"])
+        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromLogStream", [log_stream]))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.JobExecutableConfig",
-    jsii_struct_bases=[],
-    name_mapping={
-        "glue_version": "glueVersion",
-        "language": "language",
-        "script": "script",
-        "type": "type",
-        "class_name": "className",
-        "extra_files": "extraFiles",
-        "extra_jars": "extraJars",
-        "extra_jars_first": "extraJarsFirst",
-        "extra_python_files": "extraPythonFiles",
-        "python_version": "pythonVersion",
-    },
-)
-class JobExecutableConfig:
-    def __init__(
-        self,
-        *,
-        glue_version: GlueVersion,
-        language: "JobLanguage",
-        script: Code,
-        type: "JobType",
-        class_name: typing.Optional[builtins.str] = None,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-        python_version: typing.Optional["PythonVersion"] = None,
-    ) -> None:
-        '''Result of binding a ``JobExecutable`` into a ``Job``.
-
-        :param glue_version: Glue version.
-        :param language: The language of the job (Scala or Python).
-        :param script: The script that is executed by a job.
-        :param type: Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.
-        :param class_name: The Scala class that serves as the entry point for the job. This applies only if your the job langauage is Scala. Default: - no scala className specified
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Default: - no extra files specified.
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Default: - no extra jars specified.
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: - extra jars are not prioritized.
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Default: - no extra python files specified.
-        :param python_version: The Python version to use. Default: - no python version specified
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__af760e5b293fa34ac6b256f1e0f627632acc4c0dd5000a33d11b6c7858e250ec)
-            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
-            check_type(argname="argument language", value=language, expected_type=type_hints["language"])
-            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
-            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
-            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
-            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
-            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
-            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "glue_version": glue_version,
-            "language": language,
-            "script": script,
-            "type": type,
-        }
-        if class_name is not None:
-            self._values["class_name"] = class_name
-        if extra_files is not None:
-            self._values["extra_files"] = extra_files
-        if extra_jars is not None:
-            self._values["extra_jars"] = extra_jars
-        if extra_jars_first is not None:
-            self._values["extra_jars_first"] = extra_jars_first
-        if extra_python_files is not None:
-            self._values["extra_python_files"] = extra_python_files
-        if python_version is not None:
-            self._values["python_version"] = python_version
+    @jsii.member(jsii_name="fromName")
+    @builtins.classmethod
+    def from_name(cls, name: builtins.str) -> "FluentBitLogStreamOutput":
+        '''Sets output to a named log stream.
 
-    @builtins.property
-    def glue_version(self) -> GlueVersion:
-        '''Glue version.
+        If a log stream with the given name doesn't exist in the configured log
+        group a log stream with the given name will be created.
+
+        :param name: The name of the log stream where records should be written.
 
-        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        :return:
+
+        A FluentBitLogStreamOutput object representing the configured
+        log stream destination.
         '''
-        result = self._values.get("glue_version")
-        assert result is not None, "Required property 'glue_version' is missing"
-        return typing.cast(GlueVersion, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d2d24583ddfcc8876ab533165130d5b3607247d011b36995e13163c253b6e718)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromName", [name]))
 
-    @builtins.property
-    def language(self) -> "JobLanguage":
-        '''The language of the job (Scala or Python).
+    @jsii.member(jsii_name="fromPrefix")
+    @builtins.classmethod
+    def from_prefix(cls, prefix: builtins.str) -> "FluentBitLogStreamOutput":
+        '''Sets output to a prefixed log stream.
+
+        Log streams will be created on a per-pod basis with the name oof the log
+        streams starting with the provided prefix.
+
+        :param prefix: The prefix for log streams which will be created.
+
+        :return:
 
-        :see: ``--job-language`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        A FluentBitLogStreamOutput object representing the configured
+        log stream destination.
         '''
-        result = self._values.get("language")
-        assert result is not None, "Required property 'language' is missing"
-        return typing.cast("JobLanguage", result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f2176a9e11225cfa29051ee0166fd6151266cf8a3753905e128f0cb83df80178)
+            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
+        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromPrefix", [prefix]))
 
     @builtins.property
-    def script(self) -> Code:
-        '''The script that is executed by a job.'''
-        result = self._values.get("script")
-        assert result is not None, "Required property 'script' is missing"
-        return typing.cast(Code, result)
+    @jsii.member(jsii_name="logStreamName")
+    def log_stream_name(self) -> typing.Optional[builtins.str]:
+        '''The name of the log stream where records should be created.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamName"))
 
     @builtins.property
-    def type(self) -> "JobType":
-        '''Specify the type of the job whether it's an Apache Spark ETL or streaming one or if it's a Python shell job.'''
-        result = self._values.get("type")
-        assert result is not None, "Required property 'type' is missing"
-        return typing.cast("JobType", result)
+    @jsii.member(jsii_name="logStreamPrefix")
+    def log_stream_prefix(self) -> typing.Optional[builtins.str]:
+        '''The prefix for log streams that will be created on a per-pod basis.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamPrefix"))
 
-    @builtins.property
-    def class_name(self) -> typing.Optional[builtins.str]:
-        '''The Scala class that serves as the entry point for the job.
 
-        This applies only if your the job langauage is Scala.
+class FluentBitMatch(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitMatch",
+):
+    '''Represents a filter that can be applied to Filter and Output plugins that scopes down what records the given filter should apply to.'''
+
+    @jsii.member(jsii_name="glob")
+    @builtins.classmethod
+    def glob(cls, pattern: builtins.str) -> "FluentBitMatch":
+        '''Creates a match pattern that supports basic wildcard matching using the star character (``*``).
 
-        :default: - no scala className specified
+        :param pattern: The pattern to use to match against the tags of an incoming record. It's case sensitive and support the star (``*``) character as a wildcard.
 
-        :see: ``--class`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A match object representing the given pattern.
         '''
-        result = self._values.get("class_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__42632d6e6d5ce15103cf294740e757e5f3a4db926970743e6ab114f398dea1d3)
+            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
+        return typing.cast("FluentBitMatch", jsii.sinvoke(cls, "glob", [pattern]))
 
-    @builtins.property
-    def extra_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+    @jsii.member(jsii_name="regex")
+    @builtins.classmethod
+    def regex(cls, pattern: builtins.str) -> "FluentBitMatch":
+        '''Creates a match pattern that supports full regex matching.
 
-        :default: - no extra files specified.
+        :param pattern: A regular expression to match against the tags of incoming records.
 
-        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A match object representing the given pattern.
         '''
-        result = self._values.get("extra_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__03245bf7bb94a21d38ca01a84e1768b7dae976c76ea7c6d0c9ea4c23cb4b5063)
+            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
+        return typing.cast("FluentBitMatch", jsii.sinvoke(cls, "regex", [pattern]))
 
-    @builtins.property
-    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script.
+    @jsii.member(jsii_name="toObject")
+    def to_object(self) -> typing.Mapping[builtins.str, builtins.str]:
+        '''Creates a record object that can be used to represent the match in Fluent Bit configuration files.
+
+        :return: The object that can be used to represent this match object.
+        '''
+        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "toObject", []))
 
-        :default: - no extra jars specified.
+    @jsii.member(jsii_name="toString")
+    def to_string(self) -> builtins.str:
+        '''Creates a string representation of this match object that reflects how it will appear in a Fluent Bit configuration file.
 
-        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A string representation of this match.
         '''
-        result = self._values.get("extra_jars")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
 
-    @builtins.property
-    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
-        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ALL")
+    def ALL(cls) -> "FluentBitMatch":
+        '''Represents a pattern that will match all log entries.'''
+        return typing.cast("FluentBitMatch", jsii.sget(cls, "ALL"))
 
-        :default: - extra jars are not prioritized.
+    @builtins.property
+    @jsii.member(jsii_name="evaluator")
+    def evaluator(self) -> "FluentBitMatchEvaluator":
+        '''The pattern matching syntax to use when evaluating incoming tags.
 
-        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :group: Inputs
         '''
-        result = self._values.get("extra_jars_first")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast("FluentBitMatchEvaluator", jsii.get(self, "evaluator"))
 
     @builtins.property
-    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
+    @jsii.member(jsii_name="pattern")
+    def pattern(self) -> builtins.str:
+        '''The pattern to compare against the tags of incoming records.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "pattern"))
+
+
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.FluentBitMatchEvaluator")
+class FluentBitMatchEvaluator(enum.Enum):
+    '''Matching patterns supported by Fluent Bit plugins for scoping down incoming records.'''
+
+    GLOB = "GLOB"
+    '''A basic pattern match supporting the star (``*``) character as a wildcard.'''
+    REGEX = "REGEX"
+    '''Full pattern matching using regular expressions.'''
+
 
-        :default: - no extra python files specified.
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitModifyFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "conditions": "conditions",
+        "operations": "operations",
+    },
+)
+class FluentBitModifyFilterOptions(FluentBitFilterPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+        conditions: typing.Optional[typing.Sequence["ModifyCondition"]] = None,
+        operations: typing.Optional[typing.Sequence["ModifyOperation"]] = None,
+    ) -> None:
+        '''Options for configuring the Modify Fluent Bit filter plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param conditions: 
+        :param operations: 
 
-        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :see: `Modify Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/modify>`_
         '''
-        result = self._values.get("extra_python_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__477fb867f089070fa5d35c4c569a7ef1cc68825359200bc94957a309491b389b)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
+            check_type(argname="argument operations", value=operations, expected_type=type_hints["operations"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if conditions is not None:
+            self._values["conditions"] = conditions
+        if operations is not None:
+            self._values["operations"] = operations
 
     @builtins.property
-    def python_version(self) -> typing.Optional["PythonVersion"]:
-        '''The Python version to use.
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
 
-        :default: - no python version specified
-        '''
-        result = self._values.get("python_version")
-        return typing.cast(typing.Optional["PythonVersion"], result)
+    @builtins.property
+    def conditions(self) -> typing.Optional[typing.List["ModifyCondition"]]:
+        result = self._values.get("conditions")
+        return typing.cast(typing.Optional[typing.List["ModifyCondition"]], result)
+
+    @builtins.property
+    def operations(self) -> typing.Optional[typing.List["ModifyOperation"]]:
+        result = self._values.get("operations")
+        return typing.cast(typing.Optional[typing.List["ModifyOperation"]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "JobExecutableConfig(%s)" % ", ".join(
+        return "FluentBitModifyFilterOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.JobLanguage")
-class JobLanguage(enum.Enum):
-    PYTHON = "PYTHON"
-    '''Python.'''
-    SCALA = "SCALA"
-    '''Scala.'''
-
-
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.JobProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitNestFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
     name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "executable": "executable",
-        "allocated_capacity": "allocatedCapacity",
-        "connections": "connections",
-        "continuous_logging": "continuousLogging",
-        "default_arguments": "defaultArguments",
-        "description": "description",
-        "enable_profiling_metrics": "enableProfilingMetrics",
-        "max_capacity": "maxCapacity",
-        "max_concurrent_runs": "maxConcurrentRuns",
-        "max_retries": "maxRetries",
-        "name": "name",
-        "notify_delay_after": "notifyDelayAfter",
-        "role": "role",
-        "security_configuration": "securityConfiguration",
-        "timeout": "timeout",
-        "worker_count": "workerCount",
-        "worker_type": "workerType",
+        "match": "match",
+        "operation": "operation",
+        "add_prefix": "addPrefix",
+        "remove_prefix": "removePrefix",
     },
 )
-class JobProps(_aws_cdk_ceddda9d.ResourceProps):
+class FluentBitNestFilterOptions(FluentBitFilterPluginCommonOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        executable: JobExecutable,
-        allocated_capacity: typing.Optional[jsii.Number] = None,
-        connections: typing.Optional[typing.Sequence[Connection]] = None,
-        continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
-        default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        description: typing.Optional[builtins.str] = None,
-        enable_profiling_metrics: typing.Optional[builtins.bool] = None,
-        max_capacity: typing.Optional[jsii.Number] = None,
-        max_concurrent_runs: typing.Optional[jsii.Number] = None,
-        max_retries: typing.Optional[jsii.Number] = None,
-        name: typing.Optional[builtins.str] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        security_configuration: typing.Optional["SecurityConfiguration"] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        worker_count: typing.Optional[jsii.Number] = None,
-        worker_type: typing.Optional["WorkerType"] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+        operation: "NestFilterOperation",
+        add_prefix: typing.Optional[builtins.str] = None,
+        remove_prefix: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the Glue Job resource.
+        '''Options for configuring the Nest Fluent Bit filter plugin.
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param executable: Executable properties for the Job.
-        :param allocated_capacity: The number of capacity units that are allocated to this job.
-        :param connections: List of Connections for use with this job.
-        :param continuous_logging: Set of properties for configuration of Continuous Logging.
-        :param default_arguments: The default arguments for this job, specified as name-value pairs. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param description: A description of the job.
-        :param enable_profiling_metrics: Boolean value for whether to enable Profiling Metrics.
-        :param max_capacity: The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. Do not set Max Capacity if using WorkerType and NumberOfWorkers. The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job:: - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
-        :param max_concurrent_runs: Maximum number of concurrent executions.
-        :param max_retries: The maximum number of times to retry this job after a JobRun fails.
-        :param name: A name for the Job.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param role: The name or Amazon Resource Name (ARN) of the IAM role associated with this job.
-        :param security_configuration: The Security Configuration object to be applied to the Job.
-        :param timeout: The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
-        :param worker_count: The number of worker available the Job.
-        :param worker_type: The type of predefined worker that is allocated when a job runs. Accepts a value of Standard, G.1X, or G.2X.
+        :param match: The pattern to match for records that this output should apply to.
+        :param operation: The operation the filter will perform.
+        :param add_prefix: Prefix affected keys with this string.
+        :param remove_prefix: Remove prefix from affected keys if it matches this string.
+
+        :see: `Nest Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/nest>`_
         '''
-        if isinstance(continuous_logging, dict):
-            continuous_logging = ContinuousLoggingProps(**continuous_logging)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1a4f1e1b4bab338b9f8725cb2a2bdc60103a0fa9e50e731a94e0a34914c85e6e)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument executable", value=executable, expected_type=type_hints["executable"])
-            check_type(argname="argument allocated_capacity", value=allocated_capacity, expected_type=type_hints["allocated_capacity"])
-            check_type(argname="argument connections", value=connections, expected_type=type_hints["connections"])
-            check_type(argname="argument continuous_logging", value=continuous_logging, expected_type=type_hints["continuous_logging"])
-            check_type(argname="argument default_arguments", value=default_arguments, expected_type=type_hints["default_arguments"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument enable_profiling_metrics", value=enable_profiling_metrics, expected_type=type_hints["enable_profiling_metrics"])
-            check_type(argname="argument max_capacity", value=max_capacity, expected_type=type_hints["max_capacity"])
-            check_type(argname="argument max_concurrent_runs", value=max_concurrent_runs, expected_type=type_hints["max_concurrent_runs"])
-            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
-            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
-            check_type(argname="argument worker_count", value=worker_count, expected_type=type_hints["worker_count"])
-            check_type(argname="argument worker_type", value=worker_type, expected_type=type_hints["worker_type"])
+            type_hints = typing.get_type_hints(_typecheckingstub__6baa844d691b01fb5358a6c2b04f16a51e81d297fb8c56fa7ba4e803056db09a)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
+            check_type(argname="argument add_prefix", value=add_prefix, expected_type=type_hints["add_prefix"])
+            check_type(argname="argument remove_prefix", value=remove_prefix, expected_type=type_hints["remove_prefix"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "executable": executable,
+            "operation": operation,
         }
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if allocated_capacity is not None:
-            self._values["allocated_capacity"] = allocated_capacity
-        if connections is not None:
-            self._values["connections"] = connections
-        if continuous_logging is not None:
-            self._values["continuous_logging"] = continuous_logging
-        if default_arguments is not None:
-            self._values["default_arguments"] = default_arguments
-        if description is not None:
-            self._values["description"] = description
-        if enable_profiling_metrics is not None:
-            self._values["enable_profiling_metrics"] = enable_profiling_metrics
-        if max_capacity is not None:
-            self._values["max_capacity"] = max_capacity
-        if max_concurrent_runs is not None:
-            self._values["max_concurrent_runs"] = max_concurrent_runs
-        if max_retries is not None:
-            self._values["max_retries"] = max_retries
-        if name is not None:
-            self._values["name"] = name
-        if notify_delay_after is not None:
-            self._values["notify_delay_after"] = notify_delay_after
-        if role is not None:
-            self._values["role"] = role
-        if security_configuration is not None:
-            self._values["security_configuration"] = security_configuration
-        if timeout is not None:
-            self._values["timeout"] = timeout
-        if worker_count is not None:
-            self._values["worker_count"] = worker_count
-        if worker_type is not None:
-            self._values["worker_type"] = worker_type
+        if match is not None:
+            self._values["match"] = match
+        if add_prefix is not None:
+            self._values["add_prefix"] = add_prefix
+        if remove_prefix is not None:
+            self._values["remove_prefix"] = remove_prefix
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
 
-        :default: - the resource is in the same account as the stack it belongs to
-        '''
-        result = self._values.get("account")
+    @builtins.property
+    def operation(self) -> "NestFilterOperation":
+        '''The operation the filter will perform.'''
+        result = self._values.get("operation")
+        assert result is not None, "Required property 'operation' is missing"
+        return typing.cast("NestFilterOperation", result)
+
+    @builtins.property
+    def add_prefix(self) -> typing.Optional[builtins.str]:
+        '''Prefix affected keys with this string.'''
+        result = self._values.get("add_prefix")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    def remove_prefix(self) -> typing.Optional[builtins.str]:
+        '''Remove prefix from affected keys if it matches this string.'''
+        result = self._values.get("remove_prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+    def __repr__(self) -> str:
+        return "FluentBitNestFilterOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class FluentBitOutput(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitOutput",
+):
+    '''Common options that allow configuration of destinations where Fluent Bit should send records after processing.'''
+
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="cloudwatchLogs")
+    @builtins.classmethod
+    def cloudwatch_logs(
+        cls,
+        match: FluentBitMatch,
+        log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
+    ) -> "IFluentBitOutputPlugin":
+        '''Sends matched records to a CloudWatch Logs log group.
+
+        :param match: A pattern filtering to which records the output should be applied.
+        :param log_group: The log group where matched records should be sent.
+
+        :return:
+
+        An output filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dab26f9f432f54b43673f47359cc7da960e6d82adb6012e75be901a3f3b3ac09)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "cloudwatchLogs", [match, log_group]))
 
-    @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    @jsii.member(jsii_name="kinesis")
+    @builtins.classmethod
+    def kinesis(
+        cls,
+        match: FluentBitMatch,
+        stream: _aws_cdk_aws_kinesis_ceddda9d.IStream,
+    ) -> "IFluentBitOutputPlugin":
+        '''Sends matched records to a Kinesis data stream.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        :param match: A pattern filtering to which records the output should be applied.
+        :param stream: The Kinesis stream where matched records should be sent.
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+        :return:
+
+        An output filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__16fe7d93a8820fa1d151349582f6a63b13f332f70c5c98bb436e7cf988d6b020)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument stream", value=stream, expected_type=type_hints["stream"])
+        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "kinesis", [match, stream]))
 
-    @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="kinesisFirehose")
+    @builtins.classmethod
+    def kinesis_firehose(
+        cls,
+        match: FluentBitMatch,
+        delivery_stream: _IDeliveryStream_cf5feed7,
+    ) -> "IFluentBitOutputPlugin":
+        '''Sends matched records to a Kinesis Firehose delivery stream.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :param match: A pattern filtering to which records the output should be applied.
+        :param delivery_stream: The Firehose delivery stream where matched records should be sent.
+
+        :return:
+
+        An output filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__af6295291f38a712113e95369264580c73772913ba57790d0e3eb2c79bca9eec)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
+        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "kinesisFirehose", [match, delivery_stream]))
 
-    @builtins.property
-    def executable(self) -> JobExecutable:
-        '''Executable properties for the Job.'''
-        result = self._values.get("executable")
-        assert result is not None, "Required property 'executable' is missing"
-        return typing.cast(JobExecutable, result)
+    @jsii.member(jsii_name="opensearch")
+    @builtins.classmethod
+    def opensearch(
+        cls,
+        match: FluentBitMatch,
+        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
+    ) -> "IFluentBitOutputPlugin":
+        '''Sends matched records to an OpenSearch domain.
 
-    @builtins.property
-    def allocated_capacity(self) -> typing.Optional[jsii.Number]:
-        '''The number of capacity units that are allocated to this job.
+        :param match: A pattern filtering to which records the output should be applied.
+        :param domain: The OpenSearch domain where matched records should be sent.
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-allocatedcapacity>`_
+        :return:
+
+        An output filter object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("allocated_capacity")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4131fc278e940c264cc3a359804bb213cef52ec4dcc6bc45de6275ff5acb3536)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
+        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "opensearch", [match, domain]))
 
-    @builtins.property
-    def connections(self) -> typing.Optional[typing.List[Connection]]:
-        '''List of Connections for use with this job.
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-connections>`_
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitOutputPluginCommonOptions",
+    jsii_struct_bases=[],
+    name_mapping={"match": "match"},
+)
+class FluentBitOutputPluginCommonOptions:
+    def __init__(self, *, match: typing.Optional[FluentBitMatch] = None) -> None:
+        '''Configuration options that apply to all Fluent Bit output plugins.
+
+        :param match: The pattern to match for records that this output should apply to.
         '''
-        result = self._values.get("connections")
-        return typing.cast(typing.Optional[typing.List[Connection]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__09888332ffdc8a6865748655bd177159b31a6abfa867b1b8b5d60fdeea5c96b6)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
 
     @builtins.property
-    def continuous_logging(self) -> typing.Optional[ContinuousLoggingProps]:
-        '''Set of properties for configuration of Continuous Logging.'''
-        result = self._values.get("continuous_logging")
-        return typing.cast(typing.Optional[ContinuousLoggingProps], result)
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
 
-    @builtins.property
-    def default_arguments(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''The default arguments for this job, specified as name-value pairs.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-defaultarguments>`_
-        '''
-        result = self._values.get("default_arguments")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+    def __repr__(self) -> str:
+        return "FluentBitOutputPluginCommonOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description of the job.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
 
-    @builtins.property
-    def enable_profiling_metrics(self) -> typing.Optional[builtins.bool]:
-        '''Boolean value for whether to enable Profiling Metrics.'''
-        result = self._values.get("enable_profiling_metrics")
-        return typing.cast(typing.Optional[builtins.bool], result)
+class FluentBitParser(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitParser",
+):
+    '''Standard parse comfigurations which can be applied to Fluent Bit to allow for parsing data from incoming records.
 
-    @builtins.property
-    def max_capacity(self) -> typing.Optional[jsii.Number]:
-        '''The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs.
+    The records to which parsers are applied is controlled using the parser
+    filter.
+
+    :see: {@link FluentBitParserFilter}
+    '''
 
-        A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-        Do not set Max Capacity if using WorkerType and NumberOfWorkers.
+    @jsii.member(jsii_name="json")
+    @builtins.classmethod
+    def json(cls, name: builtins.str) -> "IFluentBitParserPlugin":
+        '''Creates a parser that processes records that are formatted in JSON.
 
-        The value that can be allocated for MaxCapacity depends on whether you are running a Python shell job or an Apache Spark ETL job::
+        :param name: The name of the parser which will be used for referencing it in other configurations.
 
-           - When you specify a Python shell job (JobCommand.Name="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU.
+        :return:
 
-           - When you specify an Apache Spark ETL job (JobCommand.Name="glueetl"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This job type cannot have a fractional DPU allocation.
+        A parser object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("max_capacity")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d2a5c948730ec0b02dbff24e612c1f1729a3fb4d2997fd98def1d1a317ab67ec)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "json", [name]))
 
-    @builtins.property
-    def max_concurrent_runs(self) -> typing.Optional[jsii.Number]:
-        '''Maximum number of concurrent executions.
+    @jsii.member(jsii_name="logfmt")
+    @builtins.classmethod
+    def logfmt(cls, name: builtins.str) -> "IFluentBitParserPlugin":
+        '''Creates a parser that processes records that are formatted using the ``logfmt`` standard.
+
+        :param name: The name of the parser which will be used for referencing it in other configurations.
 
-        :see: `AWS::Glue::Job ExecutionProperty <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-executionproperty.html>`_
+        :return:
+
+        A parser object that can be applied to the Fluent Bit
+        configuration.
+
+        :see: `Golang logfmt documentation <https://pkg.go.dev/github.com/kr/logfmt>`_
         '''
-        result = self._values.get("max_concurrent_runs")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d8419f19685306cef1bb083add90eeae71ca31d26fdf6ad0a5bef68d4d1ae022)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "logfmt", [name]))
 
-    @builtins.property
-    def max_retries(self) -> typing.Optional[jsii.Number]:
-        '''The maximum number of times to retry this job after a JobRun fails.
+    @jsii.member(jsii_name="ltsv")
+    @builtins.classmethod
+    def ltsv(cls, name: builtins.str) -> "IFluentBitParserPlugin":
+        '''Creates a parser that processes records that are formatted using the ``ltsv`` standard.
+
+        :param name: The name of the parser which will be used for referencing it in other configurations.
+
+        :return:
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-maxretries>`_
+        A parser object that can be applied to the Fluent Bit
+        configuration.
+
+        :see: `LTSV <http://ltsv.org/>`_
         '''
-        result = self._values.get("max_retries")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3d4d3c46b533404bcbeba504ee2681b222c47d467e4716d8970b404167f926e8)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "ltsv", [name]))
 
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name for the Job.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="regex")
+    @builtins.classmethod
+    def regex(cls, name: builtins.str, regex: builtins.str) -> "IFluentBitParserPlugin":
+        '''Creates a parser that uses regular expressions to parse incoming records.
 
-    @builtins.property
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+        :param name: The name of the parser which will be used for referencing it in other configurations.
+        :param regex: The regular expression to use to parse records.
 
-        :see: `AWS::Glue::Job NotificationProperty <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-job-notificationproperty.html>`_
+        :return:
+
+        A parser object that can be applied to the Fluent Bit
+        configuration.
         '''
-        result = self._values.get("notify_delay_after")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__082be9a38cb65fcbef035dc44eb355e76f5cc06d81a262cf08cf37078bc2d04c)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "regex", [name, regex]))
 
-    @builtins.property
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''The name or Amazon Resource Name (ARN) of the IAM role associated with this job.'''
-        result = self._values.get("role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitParserFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "key_name": "keyName",
+        "parsers": "parsers",
+        "preserve_key": "preserveKey",
+        "reserve_data": "reserveData",
+    },
+)
+class FluentBitParserFilterOptions(FluentBitFilterPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+        key_name: builtins.str,
+        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
+        preserve_key: typing.Optional[builtins.bool] = None,
+        reserve_data: typing.Optional[builtins.bool] = None,
+    ) -> None:
+        '''Options for configuring the Parser Fluent Bit filter plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param key_name: Specify field name in record to parse.
+        :param parsers: The parsers to use to interpret the field.
+        :param preserve_key: Keep original ``keyName`` field in the parsed result. If ``false``, the field will be removed. Default: false
+        :param reserve_data: Keep all other original fields in the parsed result. If ``false``, all other original fields will be removed. Default: false
+
+        :see: `Parser Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/parser>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b68a9a8afdab443320e980cd8ef61a4610a316eed4b87369d206262bcf945336)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
+            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
+            check_type(argname="argument preserve_key", value=preserve_key, expected_type=type_hints["preserve_key"])
+            check_type(argname="argument reserve_data", value=reserve_data, expected_type=type_hints["reserve_data"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "key_name": key_name,
+        }
+        if match is not None:
+            self._values["match"] = match
+        if parsers is not None:
+            self._values["parsers"] = parsers
+        if preserve_key is not None:
+            self._values["preserve_key"] = preserve_key
+        if reserve_data is not None:
+            self._values["reserve_data"] = reserve_data
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def key_name(self) -> builtins.str:
+        '''Specify field name in record to parse.'''
+        result = self._values.get("key_name")
+        assert result is not None, "Required property 'key_name' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def security_configuration(self) -> typing.Optional["SecurityConfiguration"]:
-        '''The Security Configuration object to be applied to the Job.'''
-        result = self._values.get("security_configuration")
-        return typing.cast(typing.Optional["SecurityConfiguration"], result)
+    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
+        '''The parsers to use to interpret the field.'''
+        result = self._values.get("parsers")
+        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
 
     @builtins.property
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The job timeout in minutes.
+    def preserve_key(self) -> typing.Optional[builtins.bool]:
+        '''Keep original ``keyName`` field in the parsed result.
 
-        This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).
+        If ``false``, the field will be removed.
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-timeout>`_
+        :default: false
         '''
-        result = self._values.get("timeout")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
-
-    @builtins.property
-    def worker_count(self) -> typing.Optional[jsii.Number]:
-        '''The number of worker available the Job.'''
-        result = self._values.get("worker_count")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        result = self._values.get("preserve_key")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def worker_type(self) -> typing.Optional["WorkerType"]:
-        '''The type of predefined worker that is allocated when a job runs.
+    def reserve_data(self) -> typing.Optional[builtins.bool]:
+        '''Keep all other original fields in the parsed result.
 
-        Accepts a value of Standard, G.1X, or G.2X.
+        If ``false``, all other original fields will be removed.
 
-        :see: `AWS::Glue::Job <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-job.html#cfn-glue-job-workertype>`_
+        :default: false
         '''
-        result = self._values.get("worker_type")
-        return typing.cast(typing.Optional["WorkerType"], result)
+        result = self._values.get("reserve_data")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "JobProps(%s)" % ", ".join(
+        return "FluentBitParserFilterOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.JobState")
-class JobState(enum.Enum):
-    '''State a Glue job must be in in order to satisfy a predicate condition to trigger a part of a workflow.'''
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitParserPluginCommonOptions",
+    jsii_struct_bases=[],
+    name_mapping={},
+)
+class FluentBitParserPluginCommonOptions:
+    def __init__(self) -> None:
+        '''Configuration options that apply to all Fluent Bit parser plugins.'''
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
 
-    FAILED = "FAILED"
-    '''A job that has finished and ended with an error.'''
-    STOPPED = "STOPPED"
-    '''A job which was stopped before completion.'''
-    SUCCEEDED = "SUCCEEDED"
-    '''A job which has finished successfully.'''
-    TIMEOUT = "TIMEOUT"
-    '''A job which timed out without completing.'''
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-class JobType(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.JobType"):
-    '''The job type.
+    def __repr__(self) -> str:
+        return "FluentBitParserPluginCommonOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    If you need to use a JobType that doesn't exist as a static member, you
-    can instantiate a ``JobType`` object, e.g: ``JobType.of('other name')``.
-    '''
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, name: builtins.str) -> "JobType":
-        '''Custom type name.
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitPluginCommonOptions",
+    jsii_struct_bases=[],
+    name_mapping={"name": "name", "plugin_type": "pluginType"},
+)
+class FluentBitPluginCommonOptions:
+    def __init__(
+        self,
+        *,
+        name: builtins.str,
+        plugin_type: "FluentBitPluginType",
+    ) -> None:
+        '''Options that are applicable to all Fluent Bit Plugins regardless of type.
 
-        :param name: type name.
+        :param name: The name of the fluent bit plugin.
+        :param plugin_type: Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2bde216e427f277dd4ae0752c5cd28002b668b82f2864e2962977e5314f9ec83)
+            type_hints = typing.get_type_hints(_typecheckingstub__d3a289167b1afa2aa5ae024881a5a0f791281e90f1ad71f4febecc1378f28d92)
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("JobType", jsii.sinvoke(cls, "of", [name]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ETL")
-    def ETL(cls) -> "JobType":
-        '''Command for running a Glue ETL job.'''
-        return typing.cast("JobType", jsii.sget(cls, "ETL"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PYTHON_SHELL")
-    def PYTHON_SHELL(cls) -> "JobType":
-        '''Command for running a Glue python shell job.'''
-        return typing.cast("JobType", jsii.sget(cls, "PYTHON_SHELL"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="STREAMING")
-    def STREAMING(cls) -> "JobType":
-        '''Command for running a Glue streaming job.'''
-        return typing.cast("JobType", jsii.sget(cls, "STREAMING"))
+            check_type(argname="argument plugin_type", value=plugin_type, expected_type=type_hints["plugin_type"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "name": name,
+            "plugin_type": plugin_type,
+        }
 
     @builtins.property
-    @jsii.member(jsii_name="name")
     def name(self) -> builtins.str:
-        '''The name of this JobType, as expected by Job resource.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
-
+        '''The name of the fluent bit plugin.'''
+        result = self._values.get("name")
+        assert result is not None, "Required property 'name' is missing"
+        return typing.cast(builtins.str, result)
 
-class OutputFormat(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.OutputFormat",
-):
-    '''Absolute class name of the Hadoop ``OutputFormat`` to use when writing table files.'''
+    @builtins.property
+    def plugin_type(self) -> "FluentBitPluginType":
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.'''
+        result = self._values.get("plugin_type")
+        assert result is not None, "Required property 'plugin_type' is missing"
+        return typing.cast("FluentBitPluginType", result)
 
-    def __init__(self, class_name: builtins.str) -> None:
-        '''
-        :param class_name: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7922f5b0f22bd94cc964cabe57f17f7d870707d5d26e8c51a8683ee4a13f69f2)
-            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
-        jsii.create(self.__class__, self, [class_name])
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="AVRO")
-    def AVRO(cls) -> InputFormat:
-        '''OutputFormat for Avro files.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/avro/AvroContainerOutputFormat.html
-        '''
-        return typing.cast(InputFormat, jsii.sget(cls, "AVRO"))
+    def __repr__(self) -> str:
+        return "FluentBitPluginCommonOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="HIVE_IGNORE_KEY_TEXT")
-    def HIVE_IGNORE_KEY_TEXT(cls) -> "OutputFormat":
-        '''Writes text data with a null key (value only).
 
-        :see: https://hive.apache.org/javadocs/r2.2.0/api/org/apache/hadoop/hive/ql/io/HiveIgnoreKeyTextOutputFormat.html
-        '''
-        return typing.cast("OutputFormat", jsii.sget(cls, "HIVE_IGNORE_KEY_TEXT"))
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.FluentBitPluginType")
+class FluentBitPluginType(enum.Enum):
+    '''The types of Fluent Bit plugins that can be configured.'''
+
+    FILTER = "FILTER"
+    '''A plugin that transforms or filters records.'''
+    OUTPUT = "OUTPUT"
+    '''A plugin that configures where output should be sent.'''
+    PARSER = "PARSER"
+    '''A plugin that read data from input objects into structured objects.'''
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ORC")
-    def ORC(cls) -> InputFormat:
-        '''OutputFormat for Orc files.
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcOutputFormat.html
-        '''
-        return typing.cast(InputFormat, jsii.sget(cls, "ORC"))
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRecordModifierFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "allow": "allow",
+        "records": "records",
+        "remove": "remove",
+    },
+)
+class FluentBitRecordModifierFilterOptions(FluentBitFilterPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+        allow: typing.Optional[typing.Sequence[builtins.str]] = None,
+        records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
+        remove: typing.Optional[typing.Sequence[builtins.str]] = None,
+    ) -> None:
+        '''Options for configuring the Record Modifier Fluent Bit filter plugin.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PARQUET")
-    def PARQUET(cls) -> "OutputFormat":
-        '''OutputFormat for Parquet files.
+        :param match: The pattern to match for records that this output should apply to.
+        :param allow: If a tag is not match, that field is removed.
+        :param records: Add fields to the output.
+        :param remove: If a tag is match, that field is removed.
 
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/MapredParquetOutputFormat.html
+        :see: `Record Modifier Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/record-modifier>`_
         '''
-        return typing.cast("OutputFormat", jsii.sget(cls, "PARQUET"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ba63858e40aa4f37f54576c8c109ce4f32cb4535c6c5d186705c639a22214428)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument allow", value=allow, expected_type=type_hints["allow"])
+            check_type(argname="argument records", value=records, expected_type=type_hints["records"])
+            check_type(argname="argument remove", value=remove, expected_type=type_hints["remove"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if allow is not None:
+            self._values["allow"] = allow
+        if records is not None:
+            self._values["records"] = records
+        if remove is not None:
+            self._values["remove"] = remove
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def allow(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''If a tag is not match, that field is removed.'''
+        result = self._values.get("allow")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="className")
-    def class_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "className"))
-
-
-@jsii.enum(jsii_type="cdk-extensions.glue.PartitionUpdateBehavior")
-class PartitionUpdateBehavior(enum.Enum):
-    INHERIT_FROM_TABLE = "INHERIT_FROM_TABLE"
+    def records(self) -> typing.Optional[typing.List[AppendedRecord]]:
+        '''Add fields to the output.'''
+        result = self._values.get("records")
+        return typing.cast(typing.Optional[typing.List[AppendedRecord]], result)
 
+    @builtins.property
+    def remove(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''If a tag is match, that field is removed.'''
+        result = self._values.get("remove")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
-@jsii.enum(jsii_type="cdk-extensions.glue.PredicateLogicalOperator")
-class PredicateLogicalOperator(enum.Enum):
-    '''Logical operator that specifies how the conditions of a predicate should be evaluated.'''
-
-    EQUALS = "EQUALS"
-    '''State equals specified value.'''
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-@jsii.enum(jsii_type="cdk-extensions.glue.PredicateOperator")
-class PredicateOperator(enum.Enum):
-    AND = "AND"
-    OR = "OR"
+    def __repr__(self) -> str:
+        return "FluentBitRecordModifierFilterOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.PythonShellExecutableProps",
-    jsii_struct_bases=[],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRegexParserOptions",
+    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
     name_mapping={
-        "glue_version": "glueVersion",
-        "python_version": "pythonVersion",
-        "script": "script",
-        "extra_files": "extraFiles",
-        "extra_python_files": "extraPythonFiles",
+        "regex": "regex",
+        "skip_empty_values": "skipEmptyValues",
+        "time_format": "timeFormat",
+        "time_key": "timeKey",
+        "types": "types",
     },
 )
-class PythonShellExecutableProps:
+class FluentBitRegexParserOptions(FluentBitParserPluginCommonOptions):
     def __init__(
         self,
         *,
-        glue_version: GlueVersion,
-        python_version: "PythonVersion",
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+        regex: builtins.str,
+        skip_empty_values: typing.Optional[builtins.bool] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]] = None,
     ) -> None:
-        '''Props for creating a Python shell job executable.
+        '''Options for configuring the Regex Fluent Bit parser plugin.
+
+        :param regex: The regular expression to use to parse the incoming records. Use regex group names to define the name of fields being captured.
+        :param skip_empty_values: If enabled, the parser ignores empty value of the record.
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
 
-        :param glue_version: Glue version.
-        :param python_version: The Python version to use.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
+        :see: `Regex Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/regular-expression>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0770316fdacec7ca35ca6177329d14996aea7b6acb0fd95618ead49ef0b5ad06)
-            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
-            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
-            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
-            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
-            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
+            type_hints = typing.get_type_hints(_typecheckingstub__62537da56305da6b0bcb7286caa362cac36f533c837efd41b4f2abc1df3bcf11)
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+            check_type(argname="argument skip_empty_values", value=skip_empty_values, expected_type=type_hints["skip_empty_values"])
+            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "glue_version": glue_version,
-            "python_version": python_version,
-            "script": script,
+            "regex": regex,
         }
-        if extra_files is not None:
-            self._values["extra_files"] = extra_files
-        if extra_python_files is not None:
-            self._values["extra_python_files"] = extra_python_files
+        if skip_empty_values is not None:
+            self._values["skip_empty_values"] = skip_empty_values
+        if time_format is not None:
+            self._values["time_format"] = time_format
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if types is not None:
+            self._values["types"] = types
 
     @builtins.property
-    def glue_version(self) -> GlueVersion:
-        '''Glue version.
+    def regex(self) -> builtins.str:
+        '''The regular expression to use to parse the incoming records.
 
-        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        Use regex group names to define the name of fields being captured.
         '''
-        result = self._values.get("glue_version")
-        assert result is not None, "Required property 'glue_version' is missing"
-        return typing.cast(GlueVersion, result)
-
-    @builtins.property
-    def python_version(self) -> "PythonVersion":
-        '''The Python version to use.'''
-        result = self._values.get("python_version")
-        assert result is not None, "Required property 'python_version' is missing"
-        return typing.cast("PythonVersion", result)
+        result = self._values.get("regex")
+        assert result is not None, "Required property 'regex' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def script(self) -> Code:
-        '''The script that executes a job.'''
-        result = self._values.get("script")
-        assert result is not None, "Required property 'script' is missing"
-        return typing.cast(Code, result)
+    def skip_empty_values(self) -> typing.Optional[builtins.bool]:
+        '''If enabled, the parser ignores empty value of the record.'''
+        result = self._values.get("skip_empty_values")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def extra_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
-
-        Only individual files are supported, directories are not supported.
-
-        :default: [] - no extra files are copied to the working directory
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
 
-        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        result = self._values.get("extra_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        result = self._values.get("time_format")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
-
-        Only individual files are supported, directories are not supported.
-
-        :default: - no extra python files and argument is not set
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
-        '''
-        result = self._values.get("extra_python_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+    @builtins.property
+    def types(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
+        result = self._values.get("types")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "PythonShellExecutableProps(%s)" % ", ".join(
+        return "FluentBitRegexParserOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.PythonSparkJobExecutableProps",
-    jsii_struct_bases=[],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRewriteTagFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
     name_mapping={
-        "glue_version": "glueVersion",
-        "python_version": "pythonVersion",
-        "script": "script",
-        "extra_files": "extraFiles",
-        "extra_jars": "extraJars",
-        "extra_jars_first": "extraJarsFirst",
-        "extra_python_files": "extraPythonFiles",
+        "match": "match",
+        "emitter_mem_buf_limit": "emitterMemBufLimit",
+        "emitter_name": "emitterName",
+        "emitter_storage_type": "emitterStorageType",
+        "rules": "rules",
     },
 )
-class PythonSparkJobExecutableProps:
+class FluentBitRewriteTagFilterOptions(FluentBitFilterPluginCommonOptions):
     def __init__(
         self,
         *,
-        glue_version: GlueVersion,
-        python_version: "PythonVersion",
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-        extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-    ) -> None:
-        '''Props for creating a Python Spark (ETL or Streaming) job executable.
-
-        :param glue_version: Glue version.
-        :param python_version: The Python version to use.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        :param extra_python_files: Additional Python files that AWS Glue adds to the Python path before executing your script. Only individual files are supported, directories are not supported. Default: - no extra python files and argument is not set
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__abf13ee589f12cebe2bcd432fdc04c1c56ddab0d41ec2223ea1e51e77d10b532)
-            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
-            check_type(argname="argument python_version", value=python_version, expected_type=type_hints["python_version"])
-            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
-            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
-            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
-            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
-            check_type(argname="argument extra_python_files", value=extra_python_files, expected_type=type_hints["extra_python_files"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "glue_version": glue_version,
-            "python_version": python_version,
-            "script": script,
-        }
-        if extra_files is not None:
-            self._values["extra_files"] = extra_files
-        if extra_jars is not None:
-            self._values["extra_jars"] = extra_jars
-        if extra_jars_first is not None:
-            self._values["extra_jars_first"] = extra_jars_first
-        if extra_python_files is not None:
-            self._values["extra_python_files"] = extra_python_files
+        match: typing.Optional[FluentBitMatch] = None,
+        emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
+        emitter_name: typing.Optional[builtins.str] = None,
+        emitter_storage_type: typing.Optional[EmitterStorageType] = None,
+        rules: typing.Optional[typing.Sequence[typing.Union["RewriteTagRule", typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Options for configuring the Parser Fluent Bit filter plugin.
 
-    @builtins.property
-    def glue_version(self) -> GlueVersion:
-        '''Glue version.
+        :param match: The pattern to match for records that this output should apply to.
+        :param emitter_mem_buf_limit: Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure. Default: 10M
+        :param emitter_name: When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job. Since this emitter expose metrics as any other component of the pipeline, you can use this property to configure an optional name for it.
+        :param emitter_storage_type: Define a buffering mechanism for the new records created. Note these records are part of the emitter plugin.
+        :param rules: Defines the matching criteria and the format of the Tag for the matching record.
 
-        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        :see: `Parser Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/parser>`_
         '''
-        result = self._values.get("glue_version")
-        assert result is not None, "Required property 'glue_version' is missing"
-        return typing.cast(GlueVersion, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__815f89c54e571d56f00edc236c155a23cfeab33faa1efebcf6c784af74f59f04)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument emitter_mem_buf_limit", value=emitter_mem_buf_limit, expected_type=type_hints["emitter_mem_buf_limit"])
+            check_type(argname="argument emitter_name", value=emitter_name, expected_type=type_hints["emitter_name"])
+            check_type(argname="argument emitter_storage_type", value=emitter_storage_type, expected_type=type_hints["emitter_storage_type"])
+            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if emitter_mem_buf_limit is not None:
+            self._values["emitter_mem_buf_limit"] = emitter_mem_buf_limit
+        if emitter_name is not None:
+            self._values["emitter_name"] = emitter_name
+        if emitter_storage_type is not None:
+            self._values["emitter_storage_type"] = emitter_storage_type
+        if rules is not None:
+            self._values["rules"] = rules
 
     @builtins.property
-    def python_version(self) -> "PythonVersion":
-        '''The Python version to use.'''
-        result = self._values.get("python_version")
-        assert result is not None, "Required property 'python_version' is missing"
-        return typing.cast("PythonVersion", result)
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
 
     @builtins.property
-    def script(self) -> Code:
-        '''The script that executes a job.'''
-        result = self._values.get("script")
-        assert result is not None, "Required property 'script' is missing"
-        return typing.cast(Code, result)
+    def emitter_mem_buf_limit(self) -> typing.Optional[_DataSize_d20aaece]:
+        '''Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure.
+
+        :default: 10M
+        '''
+        result = self._values.get("emitter_mem_buf_limit")
+        return typing.cast(typing.Optional[_DataSize_d20aaece], result)
 
     @builtins.property
-    def extra_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+    def emitter_name(self) -> typing.Optional[builtins.str]:
+        '''When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job.
 
-        Only individual files are supported, directories are not supported.
+        Since this emitter expose
+        metrics as any other component of the pipeline, you can use this
+        property to configure an optional name for it.
+        '''
+        result = self._values.get("emitter_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: [] - no extra files are copied to the working directory
+    @builtins.property
+    def emitter_storage_type(self) -> typing.Optional[EmitterStorageType]:
+        '''Define a buffering mechanism for the new records created.
 
-        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        Note these records are part of the emitter plugin.
         '''
-        result = self._values.get("extra_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        result = self._values.get("emitter_storage_type")
+        return typing.cast(typing.Optional[EmitterStorageType], result)
 
     @builtins.property
-    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported.
+    def rules(self) -> typing.Optional[typing.List["RewriteTagRule"]]:
+        '''Defines the matching criteria and the format of the Tag for the matching record.'''
+        result = self._values.get("rules")
+        return typing.cast(typing.Optional[typing.List["RewriteTagRule"]], result)
 
-        :default: [] - no extra jars are added to the classpath
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
-        '''
-        result = self._values.get("extra_jars")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
-        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+    def __repr__(self) -> str:
+        return "FluentBitRewriteTagFilterOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :default: false - priority is not given to user-provided jars
 
-        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitThrottleFilterOptions",
+    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "interval": "interval",
+        "print_status": "printStatus",
+        "rate": "rate",
+        "window": "window",
+    },
+)
+class FluentBitThrottleFilterOptions(FluentBitFilterPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        print_status: typing.Optional[builtins.bool] = None,
+        rate: typing.Optional[jsii.Number] = None,
+        window: typing.Optional[jsii.Number] = None,
+    ) -> None:
+        '''Options for configuring the Throttle Fluent Bit filter plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param interval: Time interval.
+        :param print_status: Whether to print status messages with current rate and the limits to information logs.
+        :param rate: Amount of messages for the time.
+        :param window: Amount of intervals to calculate average over. Default: 5
+
+        :see: `Throttle Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/throttle>`_
         '''
-        result = self._values.get("extra_jars_first")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a026237a3f40e00499d4fc0204f075b1145cde7bac0b7942bed2173ce310bd9a)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
+            check_type(argname="argument print_status", value=print_status, expected_type=type_hints["print_status"])
+            check_type(argname="argument rate", value=rate, expected_type=type_hints["rate"])
+            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if interval is not None:
+            self._values["interval"] = interval
+        if print_status is not None:
+            self._values["print_status"] = print_status
+        if rate is not None:
+            self._values["rate"] = rate
+        if window is not None:
+            self._values["window"] = window
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''Time interval.'''
+        result = self._values.get("interval")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
 
     @builtins.property
-    def extra_python_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Python files that AWS Glue adds to the Python path before executing your script.
+    def print_status(self) -> typing.Optional[builtins.bool]:
+        '''Whether to print status messages with current rate and the limits to information logs.'''
+        result = self._values.get("print_status")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        Only individual files are supported, directories are not supported.
+    @builtins.property
+    def rate(self) -> typing.Optional[jsii.Number]:
+        '''Amount of messages for the time.'''
+        result = self._values.get("rate")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :default: - no extra python files and argument is not set
+    @builtins.property
+    def window(self) -> typing.Optional[jsii.Number]:
+        '''Amount of intervals to calculate average over.
 
-        :see: ``--extra-py-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :default: 5
         '''
-        result = self._values.get("extra_python_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        result = self._values.get("window")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "PythonSparkJobExecutableProps(%s)" % ", ".join(
+        return "FluentBitThrottleFilterOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.PythonVersion")
-class PythonVersion(enum.Enum):
-    THREE = "THREE"
-    '''Python 3 (the exact version depends on GlueVersion and JobCommand used).'''
-    TWO = "TWO"
-    '''Python 2 (the exact version depends on GlueVersion and JobCommand used).'''
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IExternalDnsRegistry")
+class IExternalDnsRegistry(typing_extensions.Protocol):
+    @builtins.property
+    @jsii.member(jsii_name="registryType")
+    def registry_type(self) -> builtins.str:
+        ...
 
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ExternalDnsRegistryConfiguration:
+        '''
+        :param scope: -
+        '''
+        ...
 
-@jsii.enum(jsii_type="cdk-extensions.glue.RecrawlBehavior")
-class RecrawlBehavior(enum.Enum):
-    EVENT_MODE = "EVENT_MODE"
-    EVERYTHING = "EVERYTHING"
-    NEW_FOLDERS_ONLY = "NEW_FOLDERS_ONLY"
 
+class _IExternalDnsRegistryProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IExternalDnsRegistry"
 
-class S3Code(Code, metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.S3Code"):
-    '''Glue job Code from an S3 bucket.'''
+    @builtins.property
+    @jsii.member(jsii_name="registryType")
+    def registry_type(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "registryType"))
 
-    def __init__(
+    @jsii.member(jsii_name="bind")
+    def bind(
         self,
-        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
-        key: builtins.str,
-    ) -> None:
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ExternalDnsRegistryConfiguration:
         '''
-        :param bucket: -
-        :param key: -
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__de8f54c722e452ed2da0b9a8775cdf6f8a22de4bab55c4b0f779954c84a2b2e6)
-            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        jsii.create(self.__class__, self, [bucket, key])
+            type_hints = typing.get_type_hints(_typecheckingstub__16439430780263e49cc504798dfdedbab3bf51542be52890ad92373b0d4bfc91)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IExternalDnsRegistry).__jsii_proxy_class__ = lambda : _IExternalDnsRegistryProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitPlugin")
+class IFluentBitPlugin(typing_extensions.Protocol):
+    '''Represents a Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the fluent bit plugin.'''
+        ...
+
+    @builtins.property
+    @jsii.member(jsii_name="pluginType")
+    def plugin_type(self) -> builtins.str:
+        '''The type of fluent bit plugin.'''
+        ...
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
-        _scope: _constructs_77d1e7e8.Construct,
-        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
-    ) -> CodeConfig:
-        '''Called when the Job is initialized to allow this object to bind.
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedFluentBitConfiguration":
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
 
-        :param _scope: -
-        :param grantable: -
+        :param scope: -
+        '''
+        ...
+
+
+class _IFluentBitPluginProxy:
+    '''Represents a Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitPlugin"
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the fluent bit plugin.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
+
+    @builtins.property
+    @jsii.member(jsii_name="pluginType")
+    def plugin_type(self) -> builtins.str:
+        '''The type of fluent bit plugin.'''
+        return typing.cast(builtins.str, jsii.get(self, "pluginType"))
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedFluentBitConfiguration":
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__07939ad3e69a9dd6cae1fdc4f6dec96a067b631307222f1d771e21ef5b555288)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
-        return typing.cast(CodeConfig, jsii.invoke(self, "bind", [_scope, grantable]))
+            type_hints = typing.get_type_hints(_typecheckingstub__0e96056912a504aeb9a5f0a9afa10c098c92a82a5580780a4d2bf3539c8205aa)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast("ResolvedFluentBitConfiguration", jsii.invoke(self, "bind", [scope]))
 
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IFluentBitPlugin).__jsii_proxy_class__ = lambda : _IFluentBitPluginProxy
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.S3Encryption",
-    jsii_struct_bases=[],
-    name_mapping={"mode": "mode", "kms_key": "kmsKey"},
-)
-class S3Encryption:
-    def __init__(
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.INestFilterOperation")
+class INestFilterOperation(typing_extensions.Protocol):
+    '''Represents an operation with excludive options that can be performed by the Fluent Bit Nest filter plugin.'''
+
+    @builtins.property
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
+        ...
+
+    @builtins.property
+    @jsii.member(jsii_name="operation")
+    def operation(self) -> "NestFilterOperationType":
+        ...
+
+
+class _INestFilterOperationProxy:
+    '''Represents an operation with excludive options that can be performed by the Fluent Bit Nest filter plugin.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.INestFilterOperation"
+
+    @builtins.property
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
+        return typing.cast(typing.Mapping[builtins.str, typing.List[builtins.str]], jsii.get(self, "fields"))
+
+    @builtins.property
+    @jsii.member(jsii_name="operation")
+    def operation(self) -> "NestFilterOperationType":
+        return typing.cast("NestFilterOperationType", jsii.get(self, "operation"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, INestFilterOperation).__jsii_proxy_class__ = lambda : _INestFilterOperationProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretReference")
+class ISecretReference(typing_extensions.Protocol):
+    '''Represents a resource the can be synchronized into a Kubernetes secret.'''
+
+    @jsii.member(jsii_name="bind")
+    def bind(
         self,
-        *,
-        mode: "S3EncryptionMode",
-        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
-    ) -> None:
-        '''S3 encryption configuration.
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "SecretReferenceConfiguration":
+        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.
 
-        :param mode: Encryption mode.
-        :param kms_key: The KMS key to be used to encrypt the data. Default: no kms key if mode = S3_MANAGED. A key will be created if one is not provided and mode = KMS.
+        :param scope: The scope of the construct that will be configuring the synchronization configuration.
+        '''
+        ...
+
+
+class _ISecretReferenceProxy:
+    '''Represents a resource the can be synchronized into a Kubernetes secret.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretReference"
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "SecretReferenceConfiguration":
+        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.
+
+        :param scope: The scope of the construct that will be configuring the synchronization configuration.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__34af5cf7f823d326ebb18b6676a7f173278a47afe08c3b06bf179d11c994e2f8)
-            check_type(argname="argument mode", value=mode, expected_type=type_hints["mode"])
-            check_type(argname="argument kms_key", value=kms_key, expected_type=type_hints["kms_key"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "mode": mode,
-        }
-        if kms_key is not None:
-            self._values["kms_key"] = kms_key
+            type_hints = typing.get_type_hints(_typecheckingstub__acebfc903b3b22f8c30fae481f53b07f40398b43583763b7493f53134e21c720)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast("SecretReferenceConfiguration", jsii.invoke(self, "bind", [scope]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ISecretReference).__jsii_proxy_class__ = lambda : _ISecretReferenceProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretStore")
+class ISecretStore(_constructs_77d1e7e8.IDependable, typing_extensions.Protocol):
+    '''Represents a Kubernetes secret store resource.'''
 
     @builtins.property
-    def mode(self) -> "S3EncryptionMode":
-        '''Encryption mode.'''
-        result = self._values.get("mode")
-        assert result is not None, "Required property 'mode' is missing"
-        return typing.cast("S3EncryptionMode", result)
+    @jsii.member(jsii_name="secretStoreName")
+    def secret_store_name(self) -> builtins.str:
+        '''The name of the secret store as it appears in Kubernetes.'''
+        ...
+
+
+class _ISecretStoreProxy(
+    jsii.proxy_for(_constructs_77d1e7e8.IDependable), # type: ignore[misc]
+):
+    '''Represents a Kubernetes secret store resource.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretStore"
 
     @builtins.property
-    def kms_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
-        '''The KMS key to be used to encrypt the data.
+    @jsii.member(jsii_name="secretStoreName")
+    def secret_store_name(self) -> builtins.str:
+        '''The name of the secret store as it appears in Kubernetes.'''
+        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ISecretStore).__jsii_proxy_class__ = lambda : _ISecretStoreProxy
+
+
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.KinesisFirehoseCompressionFormat")
+class KinesisFirehoseCompressionFormat(enum.Enum):
+    ARROW = "ARROW"
+    '''The Apache Arrow compression format.
 
-        :default: no kms key if mode = S3_MANAGED. A key will be created if one is not provided and mode = KMS.
+    Only available if the Fluent Fit service being used to send logs to
+    Firehose had Apache Arrow enabled at compile time.
+    '''
+    GZIP = "GZIP"
+    '''Gzip compression format.'''
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.LiftOptions",
+    jsii_struct_bases=[],
+    name_mapping={"nested_under": "nestedUnder"},
+)
+class LiftOptions:
+    def __init__(self, *, nested_under: builtins.str) -> None:
         '''
-        result = self._values.get("kms_key")
-        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)
+        :param nested_under: Lift records nested under the this key.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b5737e6839ba050eaf2ff95b5004c79062ffa98eab8e21826190de020d396648)
+            check_type(argname="argument nested_under", value=nested_under, expected_type=type_hints["nested_under"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "nested_under": nested_under,
+        }
+
+    @builtins.property
+    def nested_under(self) -> builtins.str:
+        '''Lift records nested under the this key.'''
+        result = self._values.get("nested_under")
+        assert result is not None, "Required property 'nested_under' is missing"
+        return typing.cast(builtins.str, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "S3Encryption(%s)" % ", ".join(
+        return "LiftOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.S3EncryptionMode")
-class S3EncryptionMode(enum.Enum):
-    '''Encryption mode for S3.
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.MetadataPolicy")
+class MetadataPolicy(enum.Enum):
+    '''Options for fetching tags/labels from provider secrets.'''
 
-    :see: https://docs.aws.amazon.com/glue/latest/webapi/API_S3Encryption.html#Glue-Type-S3Encryption-S3EncryptionMode
-    '''
+    FETCH = "FETCH"
+    '''Fetch tags/labels from provider secrets.'''
+    NONE = "NONE"
+    '''Do not fetch tags/labels from provider secrets.'''
 
-    KMS = "KMS"
-    '''Server-side encryption (SSE) with an AWS KMS key managed by the account owner.
 
-    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
-    '''
-    S3_MANAGED = "S3_MANAGED"
-    '''Server side encryption (SSE) with an Amazon S3-managed key.
+class ModifyCondition(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ModifyCondition",
+):
+    @jsii.member(jsii_name="aKeyMatches")
+    @builtins.classmethod
+    def a_key_matches(cls, regex: builtins.str) -> "ModifyCondition":
+        '''Condition that returns true if any key matches a specified regular expression.
 
-    :see: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html
-    '''
+        :param regex: The regular expression to evaluate against field keys.
 
+        :return: A ModifyCondition object representing the condition.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a87c7279b95393fe143c70bd0eb03afa5a2eeadbb4e0652815e47bad81d78004)
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "aKeyMatches", [regex]))
 
-@jsii.implements(ICrawlerTarget)
-class S3Target(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.S3Target"):
-    def __init__(
-        self,
-        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
-        *,
-        connection: typing.Optional[Connection] = None,
-        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        key_prefix: typing.Optional[builtins.str] = None,
-        sample_size: typing.Optional[builtins.str] = None,
-    ) -> None:
+    @jsii.member(jsii_name="keyDoesNotExists")
+    @builtins.classmethod
+    def key_does_not_exists(cls, key: builtins.str) -> "ModifyCondition":
+        '''Condition that returns true if a specified key does not exist.
+
+        :param key: The key to check for existence.
+
+        :return: A ModifyCondition object representing the condition.
         '''
-        :param bucket: -
-        :param connection: A {@link aws-glue.Connection | "Connection" } object to connect to the target with.
-        :param exclusions: A list of glob patterns used to exclude from the crawl.
-        :param key_prefix: A Prefix Key for identification and organization of objects in the bucket.
-        :param sample_size: Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9c016d68c98f4a007d811c010a657245a7cb4e35e28d68271b47271fb2e7fe04)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyDoesNotExists", [key]))
+
+    @jsii.member(jsii_name="keyExists")
+    @builtins.classmethod
+    def key_exists(cls, key: builtins.str) -> "ModifyCondition":
+        '''Condition that returns true if a specified key exists.
+
+        :param key: The key to check for existence.
+
+        :return: A ModifyCondition object representing the condition.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__fcaa86377de60481d78b8e386ba15f4ae63207cee2ee1e03d6a84890c5303f9f)
-            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
-        options = S3TargetOptions(
-            connection=connection,
-            exclusions=exclusions,
-            key_prefix=key_prefix,
-            sample_size=sample_size,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__26a4516fb03cee3ff4649a09c795cfa145f69ca27b37c8efd99e5b120be43804)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyExists", [key]))
+
+    @jsii.member(jsii_name="keyValueDoesNotEqual")
+    @builtins.classmethod
+    def key_value_does_not_equal(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if a specified key exists and its value does not match the specified value.
 
-        jsii.create(self.__class__, self, [bucket, options])
+        :param key: The key to check for existence.
+        :param value: The value to check for the given key.
 
-    @jsii.member(jsii_name="addExclusion")
-    def add_exclusion(self, exclusion: builtins.str) -> None:
+        :return: A ModifyCondition object representing the condition.
         '''
-        :param exclusion: -
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fbd75e354fc9a0d46f639f296e1b4ffe3da299a7891b0381081ad9cc7bdf6631)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueDoesNotEqual", [key, value]))
+
+    @jsii.member(jsii_name="keyValueDoesNotMatch")
+    @builtins.classmethod
+    def key_value_does_not_match(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if a specified key exists and its value does not match the specified regular expression.
+
+        :param key: The key to check for existence.
+        :param value: The regular expression to check for the given key.
+
+        :return: A ModifyCondition object representing the condition.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__78064b8f21836a6ba333208adc1772c480fd7d08c026c1f0523ba1b519e1ec92)
-            check_type(argname="argument exclusion", value=exclusion, expected_type=type_hints["exclusion"])
-        return typing.cast(None, jsii.invoke(self, "addExclusion", [exclusion]))
+            type_hints = typing.get_type_hints(_typecheckingstub__3c04874c06d71c34c233c16eca0c4b65f1a6a36f0bb05dfd69dfa0da05ffbec4)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueDoesNotMatch", [key, value]))
 
-    @jsii.member(jsii_name="bind")
-    def bind(self, crawler: "Crawler") -> CrawlerTargetCollection:
+    @jsii.member(jsii_name="keyValueEquals")
+    @builtins.classmethod
+    def key_value_equals(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if a specified key exists and its value matches the specified value.
+
+        :param key: The key to check for existence.
+        :param value: The value to match for the given key.
+
+        :return: A ModifyCondition object representing the condition.
         '''
-        :param crawler: -
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ff4b63c6ad876a769c352fa5b53d1ab44a9e4a503ccd829e1029918eb28ef3bd)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueEquals", [key, value]))
+
+    @jsii.member(jsii_name="keyValueMatches")
+    @builtins.classmethod
+    def key_value_matches(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if a specified key exists and its value matches the specified regular expression.
+
+        :param key: The key to check for existence.
+        :param value: The regular expression to match for the given key.
+
+        :return: A ModifyCondition object representing the condition.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b1ac6ccbc65917f26861da97319cead930d0dbf8fcf49a83e9e71e57ccef2986)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        return typing.cast(CrawlerTargetCollection, jsii.invoke(self, "bind", [crawler]))
+            type_hints = typing.get_type_hints(_typecheckingstub__59be3f65de5a631f24700f05f7753e529ad70a4cb137fd5d62383abdd02bf10d)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueMatches", [key, value]))
 
-    @builtins.property
-    @jsii.member(jsii_name="bucket")
-    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.IBucket:
-        '''Bucket to use as the Target.'''
-        return typing.cast(_aws_cdk_aws_s3_ceddda9d.IBucket, jsii.get(self, "bucket"))
+    @jsii.member(jsii_name="matchingKeysDoNotHaveMatchingValues")
+    @builtins.classmethod
+    def matching_keys_do_not_have_matching_values(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if all keys matching a specified regular expression have values that do not match another regular expression.
 
-    @builtins.property
-    @jsii.member(jsii_name="connection")
-    def connection(self) -> typing.Optional[Connection]:
-        '''{@link S3TargetOptions.connection}.'''
-        return typing.cast(typing.Optional[Connection], jsii.get(self, "connection"))
+        :param key: The regular expression to use to filter keys.
+        :param value: The regular expression to check the value of fields.
 
-    @builtins.property
-    @jsii.member(jsii_name="exclusions")
-    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''{@link S3TargetOptions.exclusions}.'''
-        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "exclusions"))
+        :return: A ModifyCondition object representing the condition.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b9f14e749593d361f880d1301a695fbd3315adff4d215a08b2867f766b530f6f)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "matchingKeysDoNotHaveMatchingValues", [key, value]))
 
-    @builtins.property
-    @jsii.member(jsii_name="keyPrefix")
-    def key_prefix(self) -> typing.Optional[builtins.str]:
-        '''{@link S3TargetOptions.keyPrefix}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyPrefix"))
+    @jsii.member(jsii_name="matchingKeysHaveMatchingValues")
+    @builtins.classmethod
+    def matching_keys_have_matching_values(
+        cls,
+        key: builtins.str,
+        value: builtins.str,
+    ) -> "ModifyCondition":
+        '''Condition that returns true if all keys matching a specified regular expression have values that match another regular expression.
 
-    @builtins.property
-    @jsii.member(jsii_name="sampleSize")
-    def sample_size(self) -> typing.Optional[builtins.str]:
-        '''{@link S3TargetOptions.sampleSize}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sampleSize"))
+        :param key: The regular expression to use to filter keys.
+        :param value: The regular expression to check the value of fields.
 
+        :return: A ModifyCondition object representing the condition.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3644ef417d81a715203823624e932831fa6fab3e38086a6ff12bb88a577c0d05)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "matchingKeysHaveMatchingValues", [key, value]))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.S3TargetOptions",
-    jsii_struct_bases=[],
-    name_mapping={
-        "connection": "connection",
-        "exclusions": "exclusions",
-        "key_prefix": "keyPrefix",
-        "sample_size": "sampleSize",
-    },
-)
-class S3TargetOptions:
-    def __init__(
-        self,
-        *,
-        connection: typing.Optional[Connection] = None,
-        exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        key_prefix: typing.Optional[builtins.str] = None,
-        sample_size: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Configuration for Crawler S3 target.
+    @jsii.member(jsii_name="noKeyMatches")
+    @builtins.classmethod
+    def no_key_matches(cls, regex: builtins.str) -> "ModifyCondition":
+        '''Condition that returns true if no key matches a specified regular expression.
 
-        :param connection: A {@link aws-glue.Connection | "Connection" } object to connect to the target with.
-        :param exclusions: A list of glob patterns used to exclude from the crawl.
-        :param key_prefix: A Prefix Key for identification and organization of objects in the bucket.
-        :param sample_size: Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset. If not set, all the files are crawled. A valid value is an integer between 1 and 249.
+        :param regex: The regular expression to evaluate against field keys.
+
+        :return: A ModifyCondition object representing the condition.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__adead1dc5fcd2fa7014bdfa551e765a45e7e34612c1c8ffd300d3b8edefe00b4)
-            check_type(argname="argument connection", value=connection, expected_type=type_hints["connection"])
-            check_type(argname="argument exclusions", value=exclusions, expected_type=type_hints["exclusions"])
-            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
-            check_type(argname="argument sample_size", value=sample_size, expected_type=type_hints["sample_size"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if connection is not None:
-            self._values["connection"] = connection
-        if exclusions is not None:
-            self._values["exclusions"] = exclusions
-        if key_prefix is not None:
-            self._values["key_prefix"] = key_prefix
-        if sample_size is not None:
-            self._values["sample_size"] = sample_size
+            type_hints = typing.get_type_hints(_typecheckingstub__786ab8e1494a413b4e18469e55a12839dde421149e6acea64e8a335582aa46f5)
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "noKeyMatches", [regex]))
 
-    @builtins.property
-    def connection(self) -> typing.Optional[Connection]:
-        '''A {@link aws-glue.Connection | "Connection" } object to connect to the target with.'''
-        result = self._values.get("connection")
-        return typing.cast(typing.Optional[Connection], result)
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(
+        cls,
+        condition: builtins.str,
+        args: typing.Sequence[builtins.str],
+    ) -> "ModifyCondition":
+        '''An escape hatch method that allows fo defining custom conditions to be evaluated by the modify Fluent Bit filter plugin.
 
-    @builtins.property
-    def exclusions(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''A list of glob patterns used to exclude from the crawl.
+        :param condition: The name of the condition to be evaluated.
+        :param args: The arguments to the operation.
 
-        :see: `For More Information <https://docs.aws.amazon.com/glue/latest/dg/add-crawler.html>`_
+        :return: A ModifyCondition object representing the options provided.
         '''
-        result = self._values.get("exclusions")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c6cda0ccdf12bd0d94a391aeee20b8afc334828d46c7557423da8fddc68c8a5b)
+            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
+            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
+        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "of", [condition, args]))
+
+    @jsii.member(jsii_name="toString")
+    def to_string(self) -> builtins.str:
+        '''Gets a string representation of the arguments of this condition for use in a Fluent Bit plugin field.
+
+        :return: A fluent bit value string.
+        '''
+        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
 
     @builtins.property
-    def key_prefix(self) -> typing.Optional[builtins.str]:
-        '''A Prefix Key for identification and organization of objects in the bucket.'''
-        result = self._values.get("key_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="args")
+    def args(self) -> typing.List[builtins.str]:
+        '''Collection of arguments that apply to the condition.'''
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))
 
     @builtins.property
-    def sample_size(self) -> typing.Optional[builtins.str]:
-        '''Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset.
+    @jsii.member(jsii_name="condition")
+    def condition(self) -> builtins.str:
+        '''The name of the condition being evaluated.'''
+        return typing.cast(builtins.str, jsii.get(self, "condition"))
 
-        If not set, all the files are crawled. A valid value is an integer between 1 and 249.
 
-        :see: `AWS::Glue::Crawler S3Target <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-crawler-s3target.html#cfn-glue-crawler-s3target-samplesize>`_
+class ModifyOperation(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ModifyOperation",
+):
+    @jsii.member(jsii_name="add")
+    @builtins.classmethod
+    def add(cls, key: builtins.str, value: builtins.str) -> "ModifyOperation":
+        '''Sets a field in the output to a specific value.
+
+        If a field with the same name already exists it will be kept as is.
+
+        :param key: The key name of the field to set.
+        :param value: The value to set for the specified field.
+
+        :return: A ModifyOperation object representing the add operation.
         '''
-        result = self._values.get("sample_size")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__88d1f6674bbdb9c882a91bf4bd456ed2e3b77d8ede0eda0335a9711e90ef10d8)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "add", [key, value]))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="copy")
+    @builtins.classmethod
+    def copy(
+        cls,
+        original_key: builtins.str,
+        new_key: builtins.str,
+    ) -> "ModifyOperation":
+        '''Copies a field from the input to a field with a new name if the field exists and a field with the new name does not exist.
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        If a field with the new name already exists it is overwritten.
 
-    def __repr__(self) -> str:
-        return "S3TargetOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :param original_key: The key in the input to be copied.
+        :param new_key: The new name of the field to be copied to.
 
+        :return: A ModifyOperation object representing the copy operation.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__509195f56adc1008582dfdd1ced4b6aae5a09a204f9b120954616dbe9255a6a5)
+            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
+            check_type(argname="argument new_key", value=new_key, expected_type=type_hints["new_key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "copy", [original_key, new_key]))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.ScalaJobExecutableProps",
-    jsii_struct_bases=[],
-    name_mapping={
-        "class_name": "className",
-        "glue_version": "glueVersion",
-        "script": "script",
-        "extra_files": "extraFiles",
-        "extra_jars": "extraJars",
-        "extra_jars_first": "extraJarsFirst",
-    },
-)
-class ScalaJobExecutableProps:
-    def __init__(
-        self,
-        *,
-        class_name: builtins.str,
-        glue_version: GlueVersion,
-        script: Code,
-        extra_files: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-        extra_jars_first: typing.Optional[builtins.bool] = None,
-    ) -> None:
-        '''Props for creating a Scala Spark (ETL or Streaming) job executable.
-
-        :param class_name: The fully qualified Scala class name that serves as the entry point for the job.
-        :param glue_version: Glue version.
-        :param script: The script that executes a job.
-        :param extra_files: Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it. Only individual files are supported, directories are not supported. Default: [] - no extra files are copied to the working directory
-        :param extra_jars: Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported. Default: [] - no extra jars are added to the classpath
-        :param extra_jars_first: Setting this value to true prioritizes the customer's extra JAR files in the classpath. Default: false - priority is not given to user-provided jars
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5a58d9a628f0769075f9be892e1815f81d167b0a10411ee63316264981cf0120)
-            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
-            check_type(argname="argument glue_version", value=glue_version, expected_type=type_hints["glue_version"])
-            check_type(argname="argument script", value=script, expected_type=type_hints["script"])
-            check_type(argname="argument extra_files", value=extra_files, expected_type=type_hints["extra_files"])
-            check_type(argname="argument extra_jars", value=extra_jars, expected_type=type_hints["extra_jars"])
-            check_type(argname="argument extra_jars_first", value=extra_jars_first, expected_type=type_hints["extra_jars_first"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "class_name": class_name,
-            "glue_version": glue_version,
-            "script": script,
-        }
-        if extra_files is not None:
-            self._values["extra_files"] = extra_files
-        if extra_jars is not None:
-            self._values["extra_jars"] = extra_jars
-        if extra_jars_first is not None:
-            self._values["extra_jars_first"] = extra_jars_first
+    @jsii.member(jsii_name="hardCopy")
+    @builtins.classmethod
+    def hard_copy(
+        cls,
+        original_key: builtins.str,
+        new_key: builtins.str,
+    ) -> "ModifyOperation":
+        '''Copies a field from the input to a field with a new name if the field exists and a field with the new name does not exist.
 
-    @builtins.property
-    def class_name(self) -> builtins.str:
-        '''The fully qualified Scala class name that serves as the entry point for the job.
+        :param original_key: The key in the input to be copied.
+        :param new_key: The new name of the field to be copied to.
 
-        :see: ``--class`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A ModifyOperation object representing the copy operation.
         '''
-        result = self._values.get("class_name")
-        assert result is not None, "Required property 'class_name' is missing"
-        return typing.cast(builtins.str, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4252ab4af15f45596deb41aecff5cdf63193455fcfb6a11f50e531ae913ddc19)
+            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
+            check_type(argname="argument new_key", value=new_key, expected_type=type_hints["new_key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "hardCopy", [original_key, new_key]))
 
-    @builtins.property
-    def glue_version(self) -> GlueVersion:
-        '''Glue version.
+    @jsii.member(jsii_name="hardRename")
+    @builtins.classmethod
+    def hard_rename(
+        cls,
+        original_key: builtins.str,
+        renamed_key: builtins.str,
+    ) -> "ModifyOperation":
+        '''Renames a field from the input if the field exists.
+
+        If a field with the desired name already exists it is overwritten.
+
+        :param original_key: The key in the input to be renamed.
+        :param renamed_key: The new name of the key in the output.
 
-        :see: https://docs.aws.amazon.com/glue/latest/dg/release-notes.html
+        :return: A ModifyOperation object representing the rename operation.
         '''
-        result = self._values.get("glue_version")
-        assert result is not None, "Required property 'glue_version' is missing"
-        return typing.cast(GlueVersion, result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d143c72f0b1248ef3c465526d5a4bec246e11ddc44d1e7ffb9cd998bfd89a980)
+            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
+            check_type(argname="argument renamed_key", value=renamed_key, expected_type=type_hints["renamed_key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "hardRename", [original_key, renamed_key]))
 
-    @builtins.property
-    def script(self) -> Code:
-        '''The script that executes a job.'''
-        result = self._values.get("script")
-        assert result is not None, "Required property 'script' is missing"
-        return typing.cast(Code, result)
+    @jsii.member(jsii_name="moveToEnd")
+    @builtins.classmethod
+    def move_to_end(cls, key: builtins.str) -> "ModifyOperation":
+        '''Moves fiels matching the given wildcard key to the end of the message.
 
-    @builtins.property
-    def extra_files(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional files, such as configuration files that AWS Glue copies to the working directory of your script before executing it.
+        :param key: The wildcard to to match.
 
-        Only individual files are supported, directories are not supported.
+        :return: A ModifyOperation object representing the move operation.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__58f39ecf984b31b6d9c63ea24ccc57cdf4154eb2c667a5e4b98bf4f0117cbe7f)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "moveToEnd", [key]))
+
+    @jsii.member(jsii_name="moveToStart")
+    @builtins.classmethod
+    def move_to_start(cls, key: builtins.str) -> "ModifyOperation":
+        '''Moves fiels matching the given wildcard key to the start of the message.
 
-        :default: [] - no extra files are copied to the working directory
+        :param key: The wildcard to to match.
 
-        :see: ``--extra-files`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A ModifyOperation object representing the move operation.
         '''
-        result = self._values.get("extra_files")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__21dd6a80198a6efcdd40eb3aafec20cfecfde8f707999ac8ded417642e87f43f)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "moveToStart", [key]))
 
-    @builtins.property
-    def extra_jars(self) -> typing.Optional[typing.List[Code]]:
-        '''Additional Java .jar files that AWS Glue adds to the Java classpath before executing your script. Only individual files are supported, directories are not supported.
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(
+        cls,
+        operation: builtins.str,
+        args: typing.Sequence[builtins.str],
+    ) -> "ModifyOperation":
+        '''An escape hatch method that allows fo defining custom operations to be performed by the modify Fluent Bit filter plugin.
 
-        :default: [] - no extra jars are added to the classpath
+        :param operation: The name of the operation to be performed.
+        :param args: The arguments to the operation.
 
-        :see: ``--extra-jars`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A ModifyOperation object representing the options provided.
         '''
-        result = self._values.get("extra_jars")
-        return typing.cast(typing.Optional[typing.List[Code]], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2d24729666ca872450b6aefe87e852b867ecabcb6e378292249754f4c529a432)
+            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
+            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "of", [operation, args]))
 
-    @builtins.property
-    def extra_jars_first(self) -> typing.Optional[builtins.bool]:
-        '''Setting this value to true prioritizes the customer's extra JAR files in the classpath.
+    @jsii.member(jsii_name="remove")
+    @builtins.classmethod
+    def remove(cls, key: builtins.str) -> "ModifyOperation":
+        '''Removes a field in the output with a specific key.
 
-        :default: false - priority is not given to user-provided jars
+        :param key: The key name of the field to remove.
 
-        :see: ``--user-jars-first`` in https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html
+        :return: A ModifyOperation object representing the remove operation.
         '''
-        result = self._values.get("extra_jars_first")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d0548969ac288015caf3702a3018bc6e8a9967a958e5278991beb6b8382f6fc8)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "remove", [key]))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="removeRegex")
+    @builtins.classmethod
+    def remove_regex(cls, regex: builtins.str) -> "ModifyOperation":
+        '''Removes all fields in the output matching the regular expression.
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        :param regex: The regular expression specifying which fields to remove.
 
-    def __repr__(self) -> str:
-        return "ScalaJobExecutableProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :return: A ModifyOperation object representing the remove operation.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bd9fed6d2afdca2a8d61c87b02ec06a5728541f28c7352f673e92afe99a5efcd)
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "removeRegex", [regex]))
 
+    @jsii.member(jsii_name="removeWildcard")
+    @builtins.classmethod
+    def remove_wildcard(cls, key: builtins.str) -> "ModifyOperation":
+        '''Removes all fields in the output matching the wildcard key.
 
-class SecurityConfiguration(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.SecurityConfiguration",
-):
-    def __init__(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
-        *,
-        cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-        job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-        name: typing.Optional[builtins.str] = None,
-        s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
+        :param key: The wildcard expression specifying which fields to remove.
+
+        :return: A ModifyOperation object representing the remove operation.
         '''
-        :param scope: -
-        :param id: -
-        :param cloud_watch_encryption: Cloudwatch Encryption Settings.
-        :param job_bookmarks_encryption: The encryption configuration for job bookmarks.
-        :param name: Name for the Security Configuration.
-        :param s3_encryption: The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a06eaf6be7e3ecf8c20d87aa164edc3b0351d095aa8d571d241a99dfae13e153)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "removeWildcard", [key]))
+
+    @jsii.member(jsii_name="rename")
+    @builtins.classmethod
+    def rename(
+        cls,
+        original_key: builtins.str,
+        renamed_key: builtins.str,
+    ) -> "ModifyOperation":
+        '''Renames a field from the input if the field exists and a field with the new name does not exist.
+
+        :param original_key: The key in the input to be renamed.
+        :param renamed_key: The new name of the key in the output.
+
+        :return: A ModifyOperation object representing the rename operation.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8bb80a9d0f83fcd376c282d063d76d6be646365fd7ea4850397fc1cf26b72038)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = SecurityConfigurationProps(
-            cloud_watch_encryption=cloud_watch_encryption,
-            job_bookmarks_encryption=job_bookmarks_encryption,
-            name=name,
-            s3_encryption=s3_encryption,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__4fada9b7497030c549640821afc49c367a7e9f8f75e21c42fc11b152b1655772)
+            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
+            check_type(argname="argument renamed_key", value=renamed_key, expected_type=type_hints["renamed_key"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "rename", [original_key, renamed_key]))
 
-        jsii.create(self.__class__, self, [scope, id, props])
+    @jsii.member(jsii_name="set")
+    @builtins.classmethod
+    def set(cls, key: builtins.str, value: builtins.str) -> "ModifyOperation":
+        '''Sets a field in the output to a specific value.
 
-    @builtins.property
-    @jsii.member(jsii_name="key")
-    def key(self) -> _aws_cdk_aws_kms_ceddda9d.Key:
-        return typing.cast(_aws_cdk_aws_kms_ceddda9d.Key, jsii.get(self, "key"))
+        If a field with the same name already exists it will be overridden with
+        the specified value.
 
-    @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnSecurityConfiguration:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnSecurityConfiguration, jsii.get(self, "resource"))
+        :param key: The key name of the field to set.
+        :param value: The value to set for the specified field.
 
-    @builtins.property
-    @jsii.member(jsii_name="securityConfigurationName")
-    def security_configuration_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "securityConfigurationName"))
+        :return: A ModifyOperation object representing the set operation.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2a30ee29a1bf209f7c351625daebd78e2a284fc57bc3fa2bc6d0fb94a0d6032f)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "set", [key, value]))
 
-    @builtins.property
-    @jsii.member(jsii_name="cloudWatchEncryption")
-    def cloud_watch_encryption(self) -> typing.Optional[CloudWatchEncryption]:
-        '''{@link SecurityConfigurationProps.cloudWatchEncryption}.'''
-        return typing.cast(typing.Optional[CloudWatchEncryption], jsii.get(self, "cloudWatchEncryption"))
+    @jsii.member(jsii_name="toString")
+    def to_string(self) -> builtins.str:
+        '''Gets a string representation of the arguments of this operation for use in a Fluent Bit plugin field.
 
-    @builtins.property
-    @jsii.member(jsii_name="jobBookmarksEncryption")
-    def job_bookmarks_encryption(self) -> typing.Optional[JobBookmarksEncryption]:
-        '''{@link SecurityConfigurationProps.jobBookmarksEncryption}.'''
-        return typing.cast(typing.Optional[JobBookmarksEncryption], jsii.get(self, "jobBookmarksEncryption"))
+        :return: A fluent bit value string.
+        '''
+        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link SecurityConfigurationProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    @jsii.member(jsii_name="args")
+    def args(self) -> typing.List[builtins.str]:
+        '''Collection of arguments that apply to the operation.'''
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))
 
     @builtins.property
-    @jsii.member(jsii_name="s3Encryption")
-    def s3_encryption(self) -> typing.Optional[S3Encryption]:
-        '''{@link SecurityConfigurationProps.s3Encryption}.'''
-        return typing.cast(typing.Optional[S3Encryption], jsii.get(self, "s3Encryption"))
+    @jsii.member(jsii_name="operation")
+    def operation(self) -> builtins.str:
+        '''The name of the operation being performed.'''
+        return typing.cast(builtins.str, jsii.get(self, "operation"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.SecurityConfigurationProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "cloud_watch_encryption": "cloudWatchEncryption",
-        "job_bookmarks_encryption": "jobBookmarksEncryption",
-        "name": "name",
-        "s3_encryption": "s3Encryption",
-    },
+    jsii_type="cdk-extensions.k8s_aws.NamespacedExternalSecretOptions",
+    jsii_struct_bases=[ExternalSecretOptions],
+    name_mapping={"fields": "fields", "name": "name", "namespace": "namespace"},
 )
-class SecurityConfigurationProps(_aws_cdk_ceddda9d.ResourceProps):
+class NamespacedExternalSecretOptions(ExternalSecretOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-        job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
+        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
         name: typing.Optional[builtins.str] = None,
-        s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
+        namespace: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the Glue SecurityConfiguration resource.
+        '''Configuration options for adding a Kubernetes secret synced from an external provider to a specific Kubernetes namespace.
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cloud_watch_encryption: Cloudwatch Encryption Settings.
-        :param job_bookmarks_encryption: The encryption configuration for job bookmarks.
-        :param name: Name for the Security Configuration.
-        :param s3_encryption: The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
-        '''
-        if isinstance(cloud_watch_encryption, dict):
-            cloud_watch_encryption = CloudWatchEncryption(**cloud_watch_encryption)
-        if isinstance(job_bookmarks_encryption, dict):
-            job_bookmarks_encryption = JobBookmarksEncryption(**job_bookmarks_encryption)
-        if isinstance(s3_encryption, dict):
-            s3_encryption = S3Encryption(**s3_encryption)
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
+        '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d27a4bece3fbfe787de85bd302d080942572f3712552688c636b696a9d85fa70)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cloud_watch_encryption", value=cloud_watch_encryption, expected_type=type_hints["cloud_watch_encryption"])
-            check_type(argname="argument job_bookmarks_encryption", value=job_bookmarks_encryption, expected_type=type_hints["job_bookmarks_encryption"])
+            type_hints = typing.get_type_hints(_typecheckingstub__fd3dc6435c8d865e4f7520bd4058b3d18b2d20bc9036da2f79a101b7da1409ac)
+            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument s3_encryption", value=s3_encryption, expected_type=type_hints["s3_encryption"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if cloud_watch_encryption is not None:
-            self._values["cloud_watch_encryption"] = cloud_watch_encryption
-        if job_bookmarks_encryption is not None:
-            self._values["job_bookmarks_encryption"] = job_bookmarks_encryption
+        if fields is not None:
+            self._values["fields"] = fields
         if name is not None:
             self._values["name"] = name
-        if s3_encryption is not None:
-            self._values["s3_encryption"] = s3_encryption
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
+        '''A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider.
 
-        :default: - the resource is in the same account as the stack it belongs to
+        :default:
+
+        The Kubernetes secret will mirror the fields from the secret in
+        the external provider.
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("fields")
+        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
-
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
-
-        Cannot be supplied together with either ``account`` or ``region``.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :default: A name will be auto-generated.
         '''
-        result = self._values.get("environment_from_arn")
+        result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the synced secret should be created.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
-
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+        :default: 'default'
         '''
-        result = self._values.get("physical_name")
+        result = self._values.get("namespace")
         return typing.cast(typing.Optional[builtins.str], result)
 
-    @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :default: - the resource is in the same region as the stack it belongs to
-        '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    def cloud_watch_encryption(self) -> typing.Optional[CloudWatchEncryption]:
-        '''Cloudwatch Encryption Settings.
+    def __repr__(self) -> str:
+        return "NamespacedExternalSecretOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-cloudwatchencryption>`_
+
+@jsii.implements(INestFilterOperation)
+class NestFilterOperation(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.NestFilterOperation",
+):
+    '''Operations with exclusive options that can be performed by the Fluent Bit Nest filter plugin.'''
+
+    @jsii.member(jsii_name="lift")
+    @builtins.classmethod
+    def lift(cls, *, nested_under: builtins.str) -> INestFilterOperation:
         '''
-        result = self._values.get("cloud_watch_encryption")
-        return typing.cast(typing.Optional[CloudWatchEncryption], result)
+        :param nested_under: Lift records nested under the this key.
+        '''
+        options = LiftOptions(nested_under=nested_under)
 
-    @builtins.property
-    def job_bookmarks_encryption(self) -> typing.Optional[JobBookmarksEncryption]:
-        '''The encryption configuration for job bookmarks.
+        return typing.cast(INestFilterOperation, jsii.sinvoke(cls, "lift", [options]))
 
-        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-jobbookmarksencryption>`_
+    @jsii.member(jsii_name="nest")
+    @builtins.classmethod
+    def nest(
+        cls,
+        *,
+        nest_under: builtins.str,
+        wildcards: typing.Sequence[builtins.str],
+    ) -> INestFilterOperation:
+        '''
+        :param nest_under: Nest records matching ``wildcard`` under this key.
+        :param wildcards: Nest records which field matches this wildcard,.
         '''
-        result = self._values.get("job_bookmarks_encryption")
-        return typing.cast(typing.Optional[JobBookmarksEncryption], result)
+        options = NestOptions(nest_under=nest_under, wildcards=wildcards)
+
+        return typing.cast(INestFilterOperation, jsii.sinvoke(cls, "nest", [options]))
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''Name for the Security Configuration.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
+        '''The fields representing configuration options for the operation.'''
+        return typing.cast(typing.Mapping[builtins.str, typing.List[builtins.str]], jsii.get(self, "fields"))
 
     @builtins.property
-    def s3_encryption(self) -> typing.Optional[S3Encryption]:
-        '''The encyption configuration for Amazon Simple Storage Service (Amazon S3) data.
+    @jsii.member(jsii_name="operation")
+    def operation(self) -> "NestFilterOperationType":
+        '''The type of operation to be performed.'''
+        return typing.cast("NestFilterOperationType", jsii.get(self, "operation"))
+
+
+@jsii.enum(jsii_type="cdk-extensions.k8s_aws.NestFilterOperationType")
+class NestFilterOperationType(enum.Enum):
+    '''The modes that the Fluent Bit Nest filter plugin can work in.'''
 
-        :see: `AWS::Glue::SecurityConfiguration EncryptionConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-securityconfiguration-encryptionconfiguration.html#cfn-glue-securityconfiguration-encryptionconfiguration-s3encryptions>`_
+    LIFT = "LIFT"
+    '''Lift data from a nested object.'''
+    NEST = "NEST"
+    '''Nest data into a specified object.'''
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.NestOptions",
+    jsii_struct_bases=[],
+    name_mapping={"nest_under": "nestUnder", "wildcards": "wildcards"},
+)
+class NestOptions:
+    def __init__(
+        self,
+        *,
+        nest_under: builtins.str,
+        wildcards: typing.Sequence[builtins.str],
+    ) -> None:
         '''
-        result = self._values.get("s3_encryption")
-        return typing.cast(typing.Optional[S3Encryption], result)
+        :param nest_under: Nest records matching ``wildcard`` under this key.
+        :param wildcards: Nest records which field matches this wildcard,.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b5a146c9ddfcbd766c4313db4ff21f80ccb81d8144313200dfa63dd1bb1ff770)
+            check_type(argname="argument nest_under", value=nest_under, expected_type=type_hints["nest_under"])
+            check_type(argname="argument wildcards", value=wildcards, expected_type=type_hints["wildcards"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "nest_under": nest_under,
+            "wildcards": wildcards,
+        }
+
+    @builtins.property
+    def nest_under(self) -> builtins.str:
+        '''Nest records matching ``wildcard`` under this key.'''
+        result = self._values.get("nest_under")
+        assert result is not None, "Required property 'nest_under' is missing"
+        return typing.cast(builtins.str, result)
+
+    @builtins.property
+    def wildcards(self) -> typing.List[builtins.str]:
+        '''Nest records which field matches this wildcard,.'''
+        result = self._values.get("wildcards")
+        assert result is not None, "Required property 'wildcards' is missing"
+        return typing.cast(typing.List[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "SecurityConfigurationProps(%s)" % ", ".join(
+        return "NestOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class SerializationLibrary(
+@jsii.implements(IExternalDnsRegistry)
+class NoopRegistry(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.SerializationLibrary",
+    jsii_type="cdk-extensions.k8s_aws.NoopRegistry",
 ):
-    '''Serialization library to use when serializing/deserializing (SerDe) table records.
+    '''A placeholder ExternalDNS registry that says ExternalDNS should use not use a registry.
 
-    :see: https://cwiki.apache.org/confluence/display/Hive/SerDe
+    When configuring ExternalDNS without a registry, the service has no idea the
+    original creator and maintainer of DNS records. This means that there are
+    likely to be conflicts if there are multiple services that could create or
+    change DNS records in the same zone.
     '''
 
-    def __init__(self, class_name: builtins.str) -> None:
-        '''
-        :param class_name: -
+    def __init__(self) -> None:
+        '''Creates a new instance of the NoopRegistry class.'''
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ExternalDnsRegistryConfiguration:
+        '''Generates an object with all the information needed to use the registry in a given CDK scope.
+
+        :param _scope: The CDK resource that is configuring ExternalDNS.
+
+        :return:
+
+        A configuration object representing the implementation of this
+        registry.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5be42ef34b8183a16c487d39be9e50f07bb069442ea235835d889d6c915c0fd9)
-            check_type(argname="argument class_name", value=class_name, expected_type=type_hints["class_name"])
-        jsii.create(self.__class__, self, [class_name])
+            type_hints = typing.get_type_hints(_typecheckingstub__4b8fe7eff14cfd09dcf3795cb57c69d832abf797e1e50720b10706a28cf1e816)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [_scope]))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="AVRO")
-    def AVRO(cls) -> "SerializationLibrary":
+    @builtins.property
+    @jsii.member(jsii_name="registryType")
+    def registry_type(self) -> builtins.str:
+        '''The type name of ExternalDNS registry.'''
+        return typing.cast(builtins.str, jsii.get(self, "registryType"))
+
+
+class OpenSearchOutputBufferSize(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.OpenSearchOutputBufferSize",
+):
+    '''Represents the size of the OpenSeach output buffer to be used by Fluent Bit.'''
+
+    @jsii.member(jsii_name="bytes")
+    @builtins.classmethod
+    def bytes(cls, size: _DataSize_d20aaece) -> "OpenSearchOutputBufferSize":
+        '''Set the output buffer to a specified data size.
+
+        :param size: The size of the output buffer.
+
+        :return:
+
+        An output buffer size object representing the specified buffer
+        size.
         '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/avro/AvroSerDe.html
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d4d24a390d9eb03a06583cbc6d261f3d8de476409210bcdd7f51d4e1476eeaf4)
+            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
+        return typing.cast("OpenSearchOutputBufferSize", jsii.sinvoke(cls, "bytes", [size]))
+
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, value: builtins.str) -> "OpenSearchOutputBufferSize":
+        '''An escape hatch that allows an arbitrary value to be set for the OpenSearch buffer output property.
+
+        :param value: The value to use for the OpenSearch buffer output property.
+
+        :return:
+
+        A ``OpenSearchOutputBufferSize`` object representing the passed
+        value.
         '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "AVRO"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f02160f33c5993a4b0add2859c5aaed60beda3ddc55734f5fb49997c73f69b93)
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast("OpenSearchOutputBufferSize", jsii.sinvoke(cls, "of", [value]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="CLOUDTRAIL")
-    def CLOUDTRAIL(cls) -> "SerializationLibrary":
-        '''
-        :see: https://docs.aws.amazon.com/athena/latest/ug/cloudtrail.html
+    @jsii.member(jsii_name="UNLIMITED")
+    def UNLIMITED(cls) -> "OpenSearchOutputBufferSize":
+        '''Set the output buffer size to unlimited.'''
+        return typing.cast("OpenSearchOutputBufferSize", jsii.sget(cls, "UNLIMITED"))
+
+    @builtins.property
+    @jsii.member(jsii_name="value")
+    def value(self) -> builtins.str:
+        '''The value to use for the OpenSearch buffer output property.'''
+        return typing.cast(builtins.str, jsii.get(self, "value"))
+
+
+class ParserPluginDataType(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.ParserPluginDataType",
+):
+    '''Represents the various types of data that can be mapped in Fluent Bit using a parser plugin.'''
+
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "ParserPluginDataType":
+        '''An escape hatch method that allow specifying arbitrary custom data types.
+
+        :param name: The name of the data type.
+
+        :return: An object representing the data type.
         '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "CLOUDTRAIL"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7f740f5f0bbca2b649fceb0e355052b591878a5d830606365cce99d8b088caac)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("ParserPluginDataType", jsii.sinvoke(cls, "of", [name]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="GROK")
-    def GROK(cls) -> "SerializationLibrary":
-        '''
-        :see: https://docs.aws.amazon.com/athena/latest/ug/grok.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "GROK"))
+    @jsii.member(jsii_name="BOOL")
+    def BOOL(cls) -> "ParserPluginDataType":
+        '''Object that is true or false.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "BOOL"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="HIVE_JSON")
-    def HIVE_JSON(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hive/hcatalog/data/JsonSerDe.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "HIVE_JSON"))
+    @jsii.member(jsii_name="FLOAT")
+    def FLOAT(cls) -> "ParserPluginDataType":
+        '''Floating point number values.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "FLOAT"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="LAZY_SIMPLE")
-    def LAZY_SIMPLE(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "LAZY_SIMPLE"))
+    @jsii.member(jsii_name="HEX")
+    def HEX(cls) -> "ParserPluginDataType":
+        '''Hexidecimal number values.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "HEX"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="OPEN_CSV")
-    def OPEN_CSV(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/OpenCSVSerde.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "OPEN_CSV"))
+    @jsii.member(jsii_name="INTEGER")
+    def INTEGER(cls) -> "ParserPluginDataType":
+        '''While number values.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "INTEGER"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="OPENX_JSON")
-    def OPENX_JSON(cls) -> "SerializationLibrary":
-        '''
-        :see: https://github.com/rcongiu/Hive-JSON-Serde
+    @jsii.member(jsii_name="LOGFMT")
+    def LOGFMT(cls) -> "ParserPluginDataType":
+        '''Logfmt formatted data.
+
+        :see: `Golang logfmt documentation <https://pkg.go.dev/github.com/kr/logfmt>`_
         '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "OPENX_JSON"))
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "LOGFMT"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="ORC")
-    def ORC(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/orc/OrcSerde.html
+    @jsii.member(jsii_name="LTSV")
+    def LTSV(cls) -> "ParserPluginDataType":
+        '''Labeled tab-separated values.
+
+        :see: `LTSV <http://ltsv.org/>`_
         '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "ORC"))
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "LTSV"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="PARQUET")
-    def PARQUET(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/ql/io/parquet/serde/ParquetHiveSerDe.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "PARQUET"))
+    @jsii.member(jsii_name="REGEX")
+    def REGEX(cls) -> "ParserPluginDataType":
+        '''Regular expression.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "REGEX"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="REGEXP")
-    def REGEXP(cls) -> "SerializationLibrary":
-        '''
-        :see: https://hive.apache.org/javadocs/r1.2.2/api/org/apache/hadoop/hive/serde2/RegexSerDe.html
-        '''
-        return typing.cast("SerializationLibrary", jsii.sget(cls, "REGEXP"))
+    @jsii.member(jsii_name="STRING")
+    def STRING(cls) -> "ParserPluginDataType":
+        '''Text data.'''
+        return typing.cast("ParserPluginDataType", jsii.sget(cls, "STRING"))
 
     @builtins.property
-    @jsii.member(jsii_name="className")
-    def class_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "className"))
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the data type.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
 
-class StructColumn(
-    Column,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.StructColumn",
-):
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.ResolvedFluentBitConfiguration",
+    jsii_struct_bases=[],
+    name_mapping={
+        "config_file": "configFile",
+        "parsers": "parsers",
+        "permissions": "permissions",
+    },
+)
+class ResolvedFluentBitConfiguration:
     def __init__(
         self,
         *,
-        data: typing.Optional[typing.Sequence[Column]] = None,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
+        config_file: builtins.str,
+        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
+        permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
     ) -> None:
-        '''
-        :param data: 
-        :param comment: 
-        :param name: 
-        '''
-        props = StructColumnProps(data=data, comment=comment, name=name)
-
-        jsii.create(self.__class__, self, [props])
+        '''The output of a Fluent Bit configuration object for consumption be the resource configuring Fluent Bit.
 
-    @jsii.member(jsii_name="addColumn")
-    def add_column(self, column: Column) -> None:
-        '''
-        :param column: -
+        :param config_file: The configuration rended as a configuration file that can be read by the Fluent Bit service.
+        :param parsers: A list of parsers referenced by this plugin.
+        :param permissions: IAM permissions required by resources that will be using this plugin.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f6397af3f7e2865b94205ae66351b5049b1e24eddfccbee733dc294c875d1e29)
-            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
-        return typing.cast(None, jsii.invoke(self, "addColumn", [column]))
+            type_hints = typing.get_type_hints(_typecheckingstub__c82e94df4496e54b2a8815cc2ee59fcd040f76e2dcc14bb09c3f2fc10a316803)
+            check_type(argname="argument config_file", value=config_file, expected_type=type_hints["config_file"])
+            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
+            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "config_file": config_file,
+        }
+        if parsers is not None:
+            self._values["parsers"] = parsers
+        if permissions is not None:
+            self._values["permissions"] = permissions
+
+    @builtins.property
+    def config_file(self) -> builtins.str:
+        '''The configuration rended as a configuration file that can be read by the Fluent Bit service.'''
+        result = self._values.get("config_file")
+        assert result is not None, "Required property 'config_file' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    @jsii.member(jsii_name="typeString")
-    def type_string(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "typeString"))
+    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
+        '''A list of parsers referenced by this plugin.'''
+        result = self._values.get("parsers")
+        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
+
+    @builtins.property
+    def permissions(
+        self,
+    ) -> typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]]:
+        '''IAM permissions required by resources that will be using this plugin.'''
+        result = self._values.get("permissions")
+        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ResolvedFluentBitConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.StructColumnProps",
-    jsii_struct_bases=[ColumnProps],
-    name_mapping={"comment": "comment", "name": "name", "data": "data"},
+    jsii_type="cdk-extensions.k8s_aws.RewriteTagRule",
+    jsii_struct_bases=[],
+    name_mapping={"keep": "keep", "key": "key", "new_tag": "newTag", "regex": "regex"},
 )
-class StructColumnProps(ColumnProps):
+class RewriteTagRule:
     def __init__(
         self,
         *,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        data: typing.Optional[typing.Sequence[Column]] = None,
+        keep: builtins.bool,
+        key: builtins.str,
+        new_tag: builtins.str,
+        regex: builtins.str,
     ) -> None:
-        '''
-        :param comment: 
-        :param name: 
-        :param data: 
+        '''Defines the matching criteria and the format of the Tag for the rewrite tag Fluent Bit filter plugin.
+
+        :param keep: If a rule matches a rule the filter will emit a copy of the record with the new defined Tag. The property keep takes a boolean value to define if the original record with the old Tag must be preserved and continue in the pipeline or just be discarded.
+        :param key: The key represents the name of the record key that holds the value that we want to use to match our regular expression. A key name is specified and prefixed with a ``$``.
+        :param new_tag: If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record. The tag is a concatenated string that can contain any of the following characters: ``a-z,A-Z,0-9`` and ``.-,``.
+        :param regex: Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
+
+        :see: `Rules <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#rules>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__be752f0e2780faa753092d75b32484d8113fe2d5f788daa3dfd242fa215de246)
-            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if comment is not None:
-            self._values["comment"] = comment
-        if name is not None:
-            self._values["name"] = name
-        if data is not None:
-            self._values["data"] = data
+            type_hints = typing.get_type_hints(_typecheckingstub__10d3a53f3145b3b27a3099c9f07d903492e56e8258545b4251a8bc9b20c63556)
+            check_type(argname="argument keep", value=keep, expected_type=type_hints["keep"])
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument new_tag", value=new_tag, expected_type=type_hints["new_tag"])
+            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "keep": keep,
+            "key": key,
+            "new_tag": new_tag,
+            "regex": regex,
+        }
 
     @builtins.property
-    def comment(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("comment")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def keep(self) -> builtins.bool:
+        '''If a rule matches a rule the filter will emit a copy of the record with the new defined Tag.
+
+        The property keep takes a boolean value to define if the original
+        record with the old Tag must be preserved and continue in the pipeline
+        or just be discarded.
+
+        :see: `Keep <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#keep>`_
+        '''
+        result = self._values.get("keep")
+        assert result is not None, "Required property 'keep' is missing"
+        return typing.cast(builtins.bool, result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def key(self) -> builtins.str:
+        '''The key represents the name of the record key that holds the value that we want to use to match our regular expression.
+
+        A key name is specified and prefixed with a ``$``.
+
+        :see: `Key <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#key>`_
+        '''
+        result = self._values.get("key")
+        assert result is not None, "Required property 'key' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def data(self) -> typing.Optional[typing.List[Column]]:
-        result = self._values.get("data")
-        return typing.cast(typing.Optional[typing.List[Column]], result)
+    def new_tag(self) -> builtins.str:
+        '''If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record.
+
+        The tag is a concatenated string that can contain any of the following
+        characters: ``a-z,A-Z,0-9`` and ``.-,``.
+
+        :see: `New Tag <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#new-tag>`_
+        '''
+        result = self._values.get("new_tag")
+        assert result is not None, "Required property 'new_tag' is missing"
+        return typing.cast(builtins.str, result)
+
+    @builtins.property
+    def regex(self) -> builtins.str:
+        '''Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
+
+        :see: `Rubular regex tester <https://rubular.com/>`_
+        '''
+        result = self._values.get("regex")
+        assert result is not None, "Required property 'regex' is missing"
+        return typing.cast(builtins.str, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "StructColumnProps(%s)" % ", ".join(
+        return "RewriteTagRule(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class Table(
+class Route53Dns(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Table",
+    jsii_type="cdk-extensions.k8s_aws.Route53Dns",
 ):
-    '''Creates a Table resource specifying tabular data in the Glue Database.
+    '''External DNS is a Kubernetes service that make Kubernetes resources dicoverable via public DNS servers.
+
+    It retrieves a list of resources
+    (Services, Ingresses, etc.) from the Kubernetes API to determine a desired
+    list of DNS records and configures DNS providers accordingly.
+
+    The version provided here specifically targets Amazon's Route 53 service and
+    all options provded are for configuring Route 53. After being installed
+    external-dns will create and manage Route 53 DNS records automatically to
+    allow easy network access to your pods and services.
 
-    :see: `AWS::Glue::Table <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-table.html>`_
+    :see: `Kubernetes SIGs <https://github.com/kubernetes-sigs/external-dns>`_
     '''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        database: Database,
-        columns: typing.Optional[typing.Sequence[Column]] = None,
-        compressed: typing.Optional[builtins.bool] = None,
-        data_format: typing.Optional[DataFormat] = None,
-        description: typing.Optional[builtins.str] = None,
-        location: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        owner: typing.Optional[builtins.str] = None,
-        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        partition_keys: typing.Optional[typing.Sequence[Column]] = None,
-        retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        serde_name: typing.Optional[builtins.str] = None,
-        serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        stored_as_sub_directories: typing.Optional[builtins.bool] = None,
-        table_type: typing.Optional["TableType"] = None,
-        target_table: typing.Optional["Table"] = None,
-        view_expanded_text: typing.Optional[builtins.str] = None,
-        view_original_text: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
+        api_retries: typing.Optional[jsii.Number] = None,
+        batch_change_size: typing.Optional[jsii.Number] = None,
+        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+        evaluate_target_health: typing.Optional[builtins.bool] = None,
+        log_format: typing.Optional[ExternalDnsLogFormat] = None,
+        log_level: typing.Optional[ExternalDnsLogLevel] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        prefer_cname: typing.Optional[builtins.bool] = None,
+        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
+        replica_count: typing.Optional[jsii.Number] = None,
+        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+        zone_type: typing.Optional[ExternalDnsZoneType] = None,
     ) -> None:
-        '''Creates a new instance of the Table class.
+        '''Creates a new instance of the Route53Dns class.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param database: Database object to add Table to.
-        :param columns: A list of the Columns in the table.
-        :param compressed: True if the data in the table is compressed, or False if not.
-        :param data_format: DataFormat object indicating the expected input/output format.
-        :param description: A description for the Table.
-        :param location: The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
-        :param name: A name for the Table.
-        :param owner: The table owner. Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
-        :param parameters: These key-value pairs define properties associated with the table.
-        :param partition_keys: A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
-        :param retention: The retention time for this table.
-        :param serde_name: Name of the SerDe.
-        :param serde_parameters: These key-value pairs define initialization parameters for the SerDe.
-        :param storage_parameters: The user-supplied properties in key-value form.
-        :param stored_as_sub_directories: True if the table data is stored in subdirectories, or False if not.
-        :param table_type: The type of this table. AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
-        :param target_table: A TableIdentifier structure that describes a target table for resource linking.
-        :param view_expanded_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
-        :param view_original_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where external-dns should be deployed.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
+        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
+        :param domain_filter: Limits possible target zones by domain suffixes.
+        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
+        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
+        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
+        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
+        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
+        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
+        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
+        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
+        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
+        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2eec6dbec86f7128ae48e38b1289cfeaade58e92058db1f726cfe7935a152444)
+            type_hints = typing.get_type_hints(_typecheckingstub__25ed19f0f43971dfc8f3ac2b02af3d6b57e81e4bf8f903ca7a9a94030416e6df)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TableProps(
-            database=database,
-            columns=columns,
-            compressed=compressed,
-            data_format=data_format,
-            description=description,
-            location=location,
-            name=name,
-            owner=owner,
-            parameters=parameters,
-            partition_keys=partition_keys,
-            retention=retention,
-            serde_name=serde_name,
-            serde_parameters=serde_parameters,
-            storage_parameters=storage_parameters,
-            stored_as_sub_directories=stored_as_sub_directories,
-            table_type=table_type,
-            target_table=target_table,
-            view_expanded_text=view_expanded_text,
-            view_original_text=view_original_text,
+        props = Route53DnsProps(
+            cluster=cluster,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
+            api_retries=api_retries,
+            batch_change_size=batch_change_size,
+            domain_filter=domain_filter,
+            evaluate_target_health=evaluate_target_health,
+            log_format=log_format,
+            log_level=log_level,
+            namespace=namespace,
+            prefer_cname=prefer_cname,
+            record_ownership_registry=record_ownership_registry,
+            replica_count=replica_count,
+            sync_policy=sync_policy,
+            zone_tags=zone_tags,
+            zone_type=zone_type,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="addColumn")
-    def add_column(self, column: Column) -> None:
-        '''
-        :param column: -
+    @jsii.member(jsii_name="addDomainFilter")
+    def add_domain_filter(self, domain: builtins.str) -> "Route53Dns":
+        '''Adds a domain to the domain filter list.
+
+        The domain filter list acts as a whitelist for the domains/hosted zones
+        which external-dns will manage.
+
+        When domains are added to the domain filter list, external-dns will only
+        create and manage records when their domain ends in with a domain that has
+        been approved.
+
+        :param domain: The domain to be added to the whitelist.
+
+        :return:
+
+        The external-dns service object that the domain filter was added
+        for.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7e19c0d356c0722d5d2e88f68d65807d5bf7af6ed343ef572db7c40d331591b4)
-            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
-        return typing.cast(None, jsii.invoke(self, "addColumn", [column]))
+            type_hints = typing.get_type_hints(_typecheckingstub__b366d288dd32fbd3b7303ac861a4b96ff1f42c49b0c512768f7acdc1ace18cb1)
+            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
+        return typing.cast("Route53Dns", jsii.invoke(self, "addDomainFilter", [domain]))
+
+    @jsii.member(jsii_name="addZoneTag")
+    def add_zone_tag(self, *, key: builtins.str, value: builtins.str) -> "Route53Dns":
+        '''Adds a zone tag filter to the external DNS service.
 
-    @jsii.member(jsii_name="addParameter")
-    def add_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        When zone tags are provided only Routew 53 Hosted Zones that have matching
+        tags will be managed by external DNS.
+
+        :param key: The name of the tag to filter on.
+        :param value: The value of the tag to filter on.
+
+        :return: The external-dns service object that the zone tag was added for.
         '''
-        :param key: -
-        :param value: -
+        tag = ExternalDnsZoneTag(key=key, value=value)
+
+        return typing.cast("Route53Dns", jsii.invoke(self, "addZoneTag", [tag]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="CHART_NAME")
+    def CHART_NAME(cls) -> builtins.str:
+        '''The name of the external-dns Helm chart.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "CHART_NAME"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="CHART_REPOSITORY")
+    def CHART_REPOSITORY(cls) -> builtins.str:
+        '''The Helm repository providing the chart to be used for installing the external-dns service.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "CHART_REPOSITORY"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
+    def DEFAULT_NAMESPACE(cls) -> builtins.str:
+        '''The default Kubernetes namespace where external-dns will be installed if an alternative isn't given as input.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
+
+    @builtins.property
+    @jsii.member(jsii_name="chart")
+    def chart(self) -> _aws_cdk_aws_eks_ceddda9d.HelmChart:
+        '''The Helm chart that provides the installation of external-dns.
+
+        :group: Resources
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__32c8dcc447fc94c914aa9117344531cb4adafbbd95e95f5e533aa4ec40ff0b07)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addParameter", [key, value]))
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.HelmChart, jsii.get(self, "chart"))
+
+    @builtins.property
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where external-dns should be deployed.
 
-    @jsii.member(jsii_name="addPartitionKey")
-    def add_partition_key(self, column: Column) -> None:
+        :group: Inputs
         '''
-        :param column: -
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+
+    @builtins.property
+    @jsii.member(jsii_name="domainFilter")
+    def domain_filter(self) -> typing.List[builtins.str]:
+        '''The domain suffixes that control which hosted zones external-dns is allowed to make changes for.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__45a820867b3372f968d0356f688bd57f2fabd57b9a6f1d007bfef4a653dc0d7d)
-            check_type(argname="argument column", value=column, expected_type=type_hints["column"])
-        return typing.cast(None, jsii.invoke(self, "addPartitionKey", [column]))
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "domainFilter"))
+
+    @builtins.property
+    @jsii.member(jsii_name="recordOwnershipRegistry")
+    def record_ownership_registry(self) -> IExternalDnsRegistry:
+        '''Registry specifying how ExternalDNS should track record ownership.
 
-    @jsii.member(jsii_name="addSerdeParameter")
-    def add_serde_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        Without a registry to track record ownership, External has no way to know
+        which records it owns and manages and which are owned and managed by a
+        different service.
+
+        This can cause conflicts if there are multiple instances of External DNS
+        running or if there are other services managing DNS records in similar
+        zones as the different services could try to make conflicting changes due
+        to lacking a shared state.
+
+        :group: Inputs
         '''
-        :param key: -
-        :param value: -
+        return typing.cast(IExternalDnsRegistry, jsii.get(self, "recordOwnershipRegistry"))
+
+    @builtins.property
+    @jsii.member(jsii_name="region")
+    def region(self) -> builtins.str:
+        '''Override the default region external-dns uses when calling AWS API's.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f39ac55f4ec3d384f9e5cb679d42b04bee73ebfeeb4e4ef12d7f135353860879)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addSerdeParameter", [key, value]))
+        return typing.cast(builtins.str, jsii.get(self, "region"))
+
+    @builtins.property
+    @jsii.member(jsii_name="serviceAccount")
+    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
+        '''The Kubernetes service account that is linked with the IAM Role that allows external-dns to make changes on your behalf.
 
-    @jsii.member(jsii_name="addStorageParameter")
-    def add_storage_parameter(self, key: builtins.str, value: builtins.str) -> None:
+        :group: Resources
         '''
-        :param key: -
-        :param value: -
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
+
+    @builtins.property
+    @jsii.member(jsii_name="zoneTags")
+    def zone_tags(self) -> typing.List[ExternalDnsZoneTag]:
+        '''The AWS tags that control which hosted zones external-dns is allowed to make changes for.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dbe94e982d260f87bd2f2b4bdd58ff506d9e25d5fad5f73ce4d04443585752c0)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addStorageParameter", [key, value]))
+        return typing.cast(typing.List[ExternalDnsZoneTag], jsii.get(self, "zoneTags"))
 
-    @jsii.member(jsii_name="renderStorageDescriptor")
-    def _render_storage_descriptor(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_glue_ceddda9d.CfnTable.StorageDescriptorProperty]:
-        return typing.cast(typing.Optional[_aws_cdk_aws_glue_ceddda9d.CfnTable.StorageDescriptorProperty], jsii.invoke(self, "renderStorageDescriptor", []))
+    @builtins.property
+    @jsii.member(jsii_name="apiRetries")
+    def api_retries(self) -> typing.Optional[jsii.Number]:
+        '''Maximum number of retries for AWS API calls before giving up.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "apiRetries"))
 
     @builtins.property
-    @jsii.member(jsii_name="database")
-    def database(self) -> Database:
-        '''{@link TableProps.database:}.'''
-        return typing.cast(Database, jsii.get(self, "database"))
+    @jsii.member(jsii_name="batchChangeSize")
+    def batch_change_size(self) -> typing.Optional[jsii.Number]:
+        '''Set the maximum number of changes that will be applied in each batch.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchChangeSize"))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnTable:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTable, jsii.get(self, "resource"))
+    @jsii.member(jsii_name="evaluateTargetHealth")
+    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
+        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "evaluateTargetHealth"))
 
     @builtins.property
-    @jsii.member(jsii_name="tableArn")
-    def table_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "tableArn"))
+    @jsii.member(jsii_name="logFormat")
+    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
+        '''Sets the output format external dns will use when generating logs.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ExternalDnsLogFormat], jsii.get(self, "logFormat"))
 
     @builtins.property
-    @jsii.member(jsii_name="tableName")
-    def table_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "tableName"))
+    @jsii.member(jsii_name="logLevel")
+    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
+        '''Controls the verbosity of logs generated using the external-dns service.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ExternalDnsLogLevel], jsii.get(self, "logLevel"))
 
     @builtins.property
-    @jsii.member(jsii_name="compressed")
-    def compressed(self) -> typing.Optional[builtins.bool]:
-        '''{@link TableProps.compressed}.'''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "compressed"))
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the service should be deployed.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namespace"))
 
     @builtins.property
-    @jsii.member(jsii_name="dataFormat")
-    def data_format(self) -> typing.Optional[DataFormat]:
-        '''{@link TableProps.dataFormat}.'''
-        return typing.cast(typing.Optional[DataFormat], jsii.get(self, "dataFormat"))
+    @jsii.member(jsii_name="preferCname")
+    def prefer_cname(self) -> typing.Optional[builtins.bool]:
+        '''When true, alias records will be avoided and CNAME records will be used instead.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "preferCname"))
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    @jsii.member(jsii_name="replicaCount")
+    def replica_count(self) -> typing.Optional[jsii.Number]:
+        '''Desired number of ExternalDNS replicas.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "replicaCount"))
 
     @builtins.property
-    @jsii.member(jsii_name="location")
-    def location(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.location}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "location"))
+    @jsii.member(jsii_name="syncPolicy")
+    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
+        '''Controls the operations ExternalDNS will perform on the records it manages.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], jsii.get(self, "syncPolicy"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    @jsii.member(jsii_name="zoneType")
+    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
+        '''Controls the types of hosted zones external-dns will create records for.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ExternalDnsZoneType], jsii.get(self, "zoneType"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.Route53DnsOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "api_retries": "apiRetries",
+        "batch_change_size": "batchChangeSize",
+        "domain_filter": "domainFilter",
+        "evaluate_target_health": "evaluateTargetHealth",
+        "log_format": "logFormat",
+        "log_level": "logLevel",
+        "namespace": "namespace",
+        "prefer_cname": "preferCname",
+        "record_ownership_registry": "recordOwnershipRegistry",
+        "region": "region",
+        "replica_count": "replicaCount",
+        "sync_policy": "syncPolicy",
+        "zone_tags": "zoneTags",
+        "zone_type": "zoneType",
+    },
+)
+class Route53DnsOptions:
+    def __init__(
+        self,
+        *,
+        api_retries: typing.Optional[jsii.Number] = None,
+        batch_change_size: typing.Optional[jsii.Number] = None,
+        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+        evaluate_target_health: typing.Optional[builtins.bool] = None,
+        log_format: typing.Optional[ExternalDnsLogFormat] = None,
+        log_level: typing.Optional[ExternalDnsLogLevel] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        prefer_cname: typing.Optional[builtins.bool] = None,
+        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
+        region: typing.Optional[builtins.str] = None,
+        replica_count: typing.Optional[jsii.Number] = None,
+        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+        zone_type: typing.Optional[ExternalDnsZoneType] = None,
+    ) -> None:
+        '''Optional configuration for the Route53Dns resource.
+
+        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
+        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
+        :param domain_filter: Limits possible target zones by domain suffixes.
+        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
+        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
+        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
+        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
+        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
+        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
+        :param region: Override the default region external-dns uses when calling AWS API's.
+        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
+        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
+        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
+        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__66071158131361758043670975aa8966426ce28d558d5a62b92defe0a754f8cb)
+            check_type(argname="argument api_retries", value=api_retries, expected_type=type_hints["api_retries"])
+            check_type(argname="argument batch_change_size", value=batch_change_size, expected_type=type_hints["batch_change_size"])
+            check_type(argname="argument domain_filter", value=domain_filter, expected_type=type_hints["domain_filter"])
+            check_type(argname="argument evaluate_target_health", value=evaluate_target_health, expected_type=type_hints["evaluate_target_health"])
+            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
+            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument prefer_cname", value=prefer_cname, expected_type=type_hints["prefer_cname"])
+            check_type(argname="argument record_ownership_registry", value=record_ownership_registry, expected_type=type_hints["record_ownership_registry"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument replica_count", value=replica_count, expected_type=type_hints["replica_count"])
+            check_type(argname="argument sync_policy", value=sync_policy, expected_type=type_hints["sync_policy"])
+            check_type(argname="argument zone_tags", value=zone_tags, expected_type=type_hints["zone_tags"])
+            check_type(argname="argument zone_type", value=zone_type, expected_type=type_hints["zone_type"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if api_retries is not None:
+            self._values["api_retries"] = api_retries
+        if batch_change_size is not None:
+            self._values["batch_change_size"] = batch_change_size
+        if domain_filter is not None:
+            self._values["domain_filter"] = domain_filter
+        if evaluate_target_health is not None:
+            self._values["evaluate_target_health"] = evaluate_target_health
+        if log_format is not None:
+            self._values["log_format"] = log_format
+        if log_level is not None:
+            self._values["log_level"] = log_level
+        if namespace is not None:
+            self._values["namespace"] = namespace
+        if prefer_cname is not None:
+            self._values["prefer_cname"] = prefer_cname
+        if record_ownership_registry is not None:
+            self._values["record_ownership_registry"] = record_ownership_registry
+        if region is not None:
+            self._values["region"] = region
+        if replica_count is not None:
+            self._values["replica_count"] = replica_count
+        if sync_policy is not None:
+            self._values["sync_policy"] = sync_policy
+        if zone_tags is not None:
+            self._values["zone_tags"] = zone_tags
+        if zone_type is not None:
+            self._values["zone_type"] = zone_type
 
     @builtins.property
-    @jsii.member(jsii_name="owner")
-    def owner(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.owner}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "owner"))
+    def api_retries(self) -> typing.Optional[jsii.Number]:
+        '''Maximum number of retries for AWS API calls before giving up.
+
+        :default: 3
+        '''
+        result = self._values.get("api_retries")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="retention")
-    def retention(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''{@link TableProps.retention}.'''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "retention"))
+    def batch_change_size(self) -> typing.Optional[jsii.Number]:
+        '''Set the maximum number of changes that will be applied in each batch.
+
+        :default: 1000
+        '''
+        result = self._values.get("batch_change_size")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="serdeName")
-    def serde_name(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.serdeName}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serdeName"))
+    def domain_filter(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''Limits possible target zones by domain suffixes.'''
+        result = self._values.get("domain_filter")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    @jsii.member(jsii_name="storedAsSubDirectories")
-    def stored_as_sub_directories(self) -> typing.Optional[builtins.bool]:
-        '''{@link TableProps.storedAsSubDirectories}.'''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "storedAsSubDirectories"))
+    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
+        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.'''
+        result = self._values.get("evaluate_target_health")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="tableType")
-    def table_type(self) -> typing.Optional["TableType"]:
-        '''{@link TableProps.tableType}.'''
-        return typing.cast(typing.Optional["TableType"], jsii.get(self, "tableType"))
+    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
+        '''Sets the output format external dns will use when generating logs.
+
+        :default: {@link ExternalDnsLogLevel.JSON}
+        '''
+        result = self._values.get("log_format")
+        return typing.cast(typing.Optional[ExternalDnsLogFormat], result)
 
     @builtins.property
-    @jsii.member(jsii_name="targetTable")
-    def target_table(self) -> typing.Optional["Table"]:
-        '''{@link TableProps.targetTable}.'''
-        return typing.cast(typing.Optional["Table"], jsii.get(self, "targetTable"))
+    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
+        '''Controls the verbosity of logs generated using the external-dns service.
+
+        :default: {@link ExternalDnsLogLevel.INFO}
+        '''
+        result = self._values.get("log_level")
+        return typing.cast(typing.Optional[ExternalDnsLogLevel], result)
 
     @builtins.property
-    @jsii.member(jsii_name="viewExpandedText")
-    def view_expanded_text(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.viewExpandedText}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "viewExpandedText"))
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the service should be deployed.
+
+        :default: 'kube-system'
+        '''
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def prefer_cname(self) -> typing.Optional[builtins.bool]:
+        '''When true, alias records will be avoided and CNAME records will be used instead.
+
+        :default: false
+        '''
+        result = self._values.get("prefer_cname")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def record_ownership_registry(self) -> typing.Optional[IExternalDnsRegistry]:
+        '''Registry specifying how ExternalDNS should track record ownership.
+
+        Without a registry to track record ownership, External has no way to know
+        which records it owns and manages and which are owned and managed by a
+        different service.
+
+        This can cause conflicts if there are multiple instances of External DNS
+        running or if there are other services managing DNS records in similar
+        zones as the different services could try to make conflicting changes due
+        to lacking a shared state.
+
+        :default: A TXT registry configured with defaults.
+        '''
+        result = self._values.get("record_ownership_registry")
+        return typing.cast(typing.Optional[IExternalDnsRegistry], result)
+
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''Override the default region external-dns uses when calling AWS API's.'''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="viewOriginalText")
-    def view_original_text(self) -> typing.Optional[builtins.str]:
-        '''{@link TableProps.viewOriginalText}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "viewOriginalText"))
+    def replica_count(self) -> typing.Optional[jsii.Number]:
+        '''Desired number of ExternalDNS replicas.
 
+        :default: 1
+        '''
+        result = self._values.get("replica_count")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
+        '''Controls the operations ExternalDNS will perform on the records it manages.
 
-@jsii.enum(jsii_type="cdk-extensions.glue.TableGroupingPolicy")
-class TableGroupingPolicy(enum.Enum):
-    COMBINE_COMPATIBLE_SCHEMAS = "COMBINE_COMPATIBLE_SCHEMAS"
+        :default: {@link ExternalDnsSyncPolicy.SYNC}
+        '''
+        result = self._values.get("sync_policy")
+        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], result)
+
+    @builtins.property
+    def zone_tags(self) -> typing.Optional[typing.List[ExternalDnsZoneTag]]:
+        '''A set of tags that can be used to restrict which hosted zones external DNS will make changes to.'''
+        result = self._values.get("zone_tags")
+        return typing.cast(typing.Optional[typing.List[ExternalDnsZoneTag]], result)
+
+    @builtins.property
+    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
+        '''Controls the types of hosted zones external-dns will create records for.
+
+        :default: ExternalDnsZoneType.ALL
+        '''
+        result = self._values.get("zone_type")
+        return typing.cast(typing.Optional[ExternalDnsZoneType], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "Route53DnsOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.TableProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.k8s_aws.Route53DnsProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, Route53DnsOptions],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "database": "database",
-        "columns": "columns",
-        "compressed": "compressed",
-        "data_format": "dataFormat",
-        "description": "description",
-        "location": "location",
-        "name": "name",
-        "owner": "owner",
-        "parameters": "parameters",
-        "partition_keys": "partitionKeys",
-        "retention": "retention",
-        "serde_name": "serdeName",
-        "serde_parameters": "serdeParameters",
-        "storage_parameters": "storageParameters",
-        "stored_as_sub_directories": "storedAsSubDirectories",
-        "table_type": "tableType",
-        "target_table": "targetTable",
-        "view_expanded_text": "viewExpandedText",
-        "view_original_text": "viewOriginalText",
+        "api_retries": "apiRetries",
+        "batch_change_size": "batchChangeSize",
+        "domain_filter": "domainFilter",
+        "evaluate_target_health": "evaluateTargetHealth",
+        "log_format": "logFormat",
+        "log_level": "logLevel",
+        "namespace": "namespace",
+        "prefer_cname": "preferCname",
+        "record_ownership_registry": "recordOwnershipRegistry",
+        "replica_count": "replicaCount",
+        "sync_policy": "syncPolicy",
+        "zone_tags": "zoneTags",
+        "zone_type": "zoneType",
+        "cluster": "cluster",
     },
 )
-class TableProps(_aws_cdk_ceddda9d.ResourceProps):
+class Route53DnsProps(_aws_cdk_ceddda9d.ResourceProps, Route53DnsOptions):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        database: Database,
-        columns: typing.Optional[typing.Sequence[Column]] = None,
-        compressed: typing.Optional[builtins.bool] = None,
-        data_format: typing.Optional[DataFormat] = None,
-        description: typing.Optional[builtins.str] = None,
-        location: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        owner: typing.Optional[builtins.str] = None,
-        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        partition_keys: typing.Optional[typing.Sequence[Column]] = None,
-        retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        serde_name: typing.Optional[builtins.str] = None,
-        serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        stored_as_sub_directories: typing.Optional[builtins.bool] = None,
-        table_type: typing.Optional["TableType"] = None,
-        target_table: typing.Optional[Table] = None,
-        view_expanded_text: typing.Optional[builtins.str] = None,
-        view_original_text: typing.Optional[builtins.str] = None,
+        api_retries: typing.Optional[jsii.Number] = None,
+        batch_change_size: typing.Optional[jsii.Number] = None,
+        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+        evaluate_target_health: typing.Optional[builtins.bool] = None,
+        log_format: typing.Optional[ExternalDnsLogFormat] = None,
+        log_level: typing.Optional[ExternalDnsLogLevel] = None,
+        namespace: typing.Optional[builtins.str] = None,
+        prefer_cname: typing.Optional[builtins.bool] = None,
+        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
+        replica_count: typing.Optional[jsii.Number] = None,
+        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+        zone_type: typing.Optional[ExternalDnsZoneType] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
     ) -> None:
-        '''Configuration for Table.
+        '''Full configuration for the Route53Dns resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param database: Database object to add Table to.
-        :param columns: A list of the Columns in the table.
-        :param compressed: True if the data in the table is compressed, or False if not.
-        :param data_format: DataFormat object indicating the expected input/output format.
-        :param description: A description for the Table.
-        :param location: The physical location of the table. By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
-        :param name: A name for the Table.
-        :param owner: The table owner. Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
-        :param parameters: These key-value pairs define properties associated with the table.
-        :param partition_keys: A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.
-        :param retention: The retention time for this table.
-        :param serde_name: Name of the SerDe.
-        :param serde_parameters: These key-value pairs define initialization parameters for the SerDe.
-        :param storage_parameters: The user-supplied properties in key-value form.
-        :param stored_as_sub_directories: True if the table data is stored in subdirectories, or False if not.
-        :param table_type: The type of this table. AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
-        :param target_table: A TableIdentifier structure that describes a target table for resource linking.
-        :param view_expanded_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
-        :param view_original_text: Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
+        :param region: Override the default region external-dns uses when calling AWS API's.
+        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
+        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
+        :param domain_filter: Limits possible target zones by domain suffixes.
+        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
+        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
+        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
+        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
+        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
+        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
+        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
+        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
+        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
+        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
+        :param cluster: The EKS cluster where external-dns should be deployed.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c47a2c9840f823b7524821e05bdf6ea2222940a7cf7b637b2dae2f91266503ee)
+            type_hints = typing.get_type_hints(_typecheckingstub__599f1713ffc48e89808216535a31c01bf2871a0c4778c26680cb34a48861c9ff)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
-            check_type(argname="argument columns", value=columns, expected_type=type_hints["columns"])
-            check_type(argname="argument compressed", value=compressed, expected_type=type_hints["compressed"])
-            check_type(argname="argument data_format", value=data_format, expected_type=type_hints["data_format"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument owner", value=owner, expected_type=type_hints["owner"])
-            check_type(argname="argument parameters", value=parameters, expected_type=type_hints["parameters"])
-            check_type(argname="argument partition_keys", value=partition_keys, expected_type=type_hints["partition_keys"])
-            check_type(argname="argument retention", value=retention, expected_type=type_hints["retention"])
-            check_type(argname="argument serde_name", value=serde_name, expected_type=type_hints["serde_name"])
-            check_type(argname="argument serde_parameters", value=serde_parameters, expected_type=type_hints["serde_parameters"])
-            check_type(argname="argument storage_parameters", value=storage_parameters, expected_type=type_hints["storage_parameters"])
-            check_type(argname="argument stored_as_sub_directories", value=stored_as_sub_directories, expected_type=type_hints["stored_as_sub_directories"])
-            check_type(argname="argument table_type", value=table_type, expected_type=type_hints["table_type"])
-            check_type(argname="argument target_table", value=target_table, expected_type=type_hints["target_table"])
-            check_type(argname="argument view_expanded_text", value=view_expanded_text, expected_type=type_hints["view_expanded_text"])
-            check_type(argname="argument view_original_text", value=view_original_text, expected_type=type_hints["view_original_text"])
+            check_type(argname="argument api_retries", value=api_retries, expected_type=type_hints["api_retries"])
+            check_type(argname="argument batch_change_size", value=batch_change_size, expected_type=type_hints["batch_change_size"])
+            check_type(argname="argument domain_filter", value=domain_filter, expected_type=type_hints["domain_filter"])
+            check_type(argname="argument evaluate_target_health", value=evaluate_target_health, expected_type=type_hints["evaluate_target_health"])
+            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
+            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument prefer_cname", value=prefer_cname, expected_type=type_hints["prefer_cname"])
+            check_type(argname="argument record_ownership_registry", value=record_ownership_registry, expected_type=type_hints["record_ownership_registry"])
+            check_type(argname="argument replica_count", value=replica_count, expected_type=type_hints["replica_count"])
+            check_type(argname="argument sync_policy", value=sync_policy, expected_type=type_hints["sync_policy"])
+            check_type(argname="argument zone_tags", value=zone_tags, expected_type=type_hints["zone_tags"])
+            check_type(argname="argument zone_type", value=zone_type, expected_type=type_hints["zone_type"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "database": database,
+            "cluster": cluster,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if columns is not None:
-            self._values["columns"] = columns
-        if compressed is not None:
-            self._values["compressed"] = compressed
-        if data_format is not None:
-            self._values["data_format"] = data_format
-        if description is not None:
-            self._values["description"] = description
-        if location is not None:
-            self._values["location"] = location
-        if name is not None:
-            self._values["name"] = name
-        if owner is not None:
-            self._values["owner"] = owner
-        if parameters is not None:
-            self._values["parameters"] = parameters
-        if partition_keys is not None:
-            self._values["partition_keys"] = partition_keys
-        if retention is not None:
-            self._values["retention"] = retention
-        if serde_name is not None:
-            self._values["serde_name"] = serde_name
-        if serde_parameters is not None:
-            self._values["serde_parameters"] = serde_parameters
-        if storage_parameters is not None:
-            self._values["storage_parameters"] = storage_parameters
-        if stored_as_sub_directories is not None:
-            self._values["stored_as_sub_directories"] = stored_as_sub_directories
-        if table_type is not None:
-            self._values["table_type"] = table_type
-        if target_table is not None:
-            self._values["target_table"] = target_table
-        if view_expanded_text is not None:
-            self._values["view_expanded_text"] = view_expanded_text
-        if view_original_text is not None:
-            self._values["view_original_text"] = view_original_text
+        if api_retries is not None:
+            self._values["api_retries"] = api_retries
+        if batch_change_size is not None:
+            self._values["batch_change_size"] = batch_change_size
+        if domain_filter is not None:
+            self._values["domain_filter"] = domain_filter
+        if evaluate_target_health is not None:
+            self._values["evaluate_target_health"] = evaluate_target_health
+        if log_format is not None:
+            self._values["log_format"] = log_format
+        if log_level is not None:
+            self._values["log_level"] = log_level
+        if namespace is not None:
+            self._values["namespace"] = namespace
+        if prefer_cname is not None:
+            self._values["prefer_cname"] = prefer_cname
+        if record_ownership_registry is not None:
+            self._values["record_ownership_registry"] = record_ownership_registry
+        if replica_count is not None:
+            self._values["replica_count"] = replica_count
+        if sync_policy is not None:
+            self._values["sync_policy"] = sync_policy
+        if zone_tags is not None:
+            self._values["zone_tags"] = zone_tags
+        if zone_type is not None:
+            self._values["zone_type"] = zone_type
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -5578,547 +6779,453 @@
         :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
         result = self._values.get("physical_name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
     def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
-
-        :default: - the resource is in the same region as the stack it belongs to
-        '''
+        '''Override the default region external-dns uses when calling AWS API's.'''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def database(self) -> Database:
-        '''Database object to add Table to.'''
-        result = self._values.get("database")
-        assert result is not None, "Required property 'database' is missing"
-        return typing.cast(Database, result)
+    def api_retries(self) -> typing.Optional[jsii.Number]:
+        '''Maximum number of retries for AWS API calls before giving up.
 
-    @builtins.property
-    def columns(self) -> typing.Optional[typing.List[Column]]:
-        '''A list of the Columns in the table.
-
-        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-columns>`_
+        :default: 3
         '''
-        result = self._values.get("columns")
-        return typing.cast(typing.Optional[typing.List[Column]], result)
+        result = self._values.get("api_retries")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def compressed(self) -> typing.Optional[builtins.bool]:
-        '''True if the data in the table is compressed, or False if not.
+    def batch_change_size(self) -> typing.Optional[jsii.Number]:
+        '''Set the maximum number of changes that will be applied in each batch.
 
-        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-compressed>`_
+        :default: 1000
         '''
-        result = self._values.get("compressed")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("batch_change_size")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def data_format(self) -> typing.Optional[DataFormat]:
-        '''DataFormat object indicating the expected input/output format.'''
-        result = self._values.get("data_format")
-        return typing.cast(typing.Optional[DataFormat], result)
+    def domain_filter(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''Limits possible target zones by domain suffixes.'''
+        result = self._values.get("domain_filter")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description for the Table.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
+        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.'''
+        result = self._values.get("evaluate_target_health")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def location(self) -> typing.Optional[builtins.str]:
-        '''The physical location of the table.
-
-        By default, this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.
+    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
+        '''Sets the output format external dns will use when generating logs.
 
-        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-location>`_
+        :default: {@link ExternalDnsLogLevel.JSON}
         '''
-        result = self._values.get("location")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("log_format")
+        return typing.cast(typing.Optional[ExternalDnsLogFormat], result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name for the Table.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
+        '''Controls the verbosity of logs generated using the external-dns service.
 
-    @builtins.property
-    def owner(self) -> typing.Optional[builtins.str]:
-        '''The table owner.
+        :default: {@link ExternalDnsLogLevel.INFO}
+        '''
+        result = self._values.get("log_level")
+        return typing.cast(typing.Optional[ExternalDnsLogLevel], result)
 
-        Included for Apache Hive compatibility. Not used in the normal course of AWS Glue operations.
+    @builtins.property
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the service should be deployed.
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-owner>`_
+        :default: 'kube-system'
         '''
-        result = self._values.get("owner")
+        result = self._values.get("namespace")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def parameters(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''These key-value pairs define properties associated with the table.
+    def prefer_cname(self) -> typing.Optional[builtins.bool]:
+        '''When true, alias records will be avoided and CNAME records will be used instead.
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-parameters>`_
+        :default: false
         '''
-        result = self._values.get("parameters")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+        result = self._values.get("prefer_cname")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def partition_keys(self) -> typing.Optional[typing.List[Column]]:
-        '''A list of columns by which the table is partitioned.
+    def record_ownership_registry(self) -> typing.Optional[IExternalDnsRegistry]:
+        '''Registry specifying how ExternalDNS should track record ownership.
 
-        Only primitive types are supported as partition keys.
+        Without a registry to track record ownership, External has no way to know
+        which records it owns and manages and which are owned and managed by a
+        different service.
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-parameterskeys>`_
-        '''
-        result = self._values.get("partition_keys")
-        return typing.cast(typing.Optional[typing.List[Column]], result)
-
-    @builtins.property
-    def retention(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The retention time for this table.
+        This can cause conflicts if there are multiple instances of External DNS
+        running or if there are other services managing DNS records in similar
+        zones as the different services could try to make conflicting changes due
+        to lacking a shared state.
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-retention>`_
+        :default: A TXT registry configured with defaults.
         '''
-        result = self._values.get("retention")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("record_ownership_registry")
+        return typing.cast(typing.Optional[IExternalDnsRegistry], result)
 
     @builtins.property
-    def serde_name(self) -> typing.Optional[builtins.str]:
-        '''Name of the SerDe.
+    def replica_count(self) -> typing.Optional[jsii.Number]:
+        '''Desired number of ExternalDNS replicas.
 
-        :see: `AWS::Glue::Table SerdeInfo <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-serdeinfo.html#cfn-glue-table-serdeinfo-name>`_
+        :default: 1
         '''
-        result = self._values.get("serde_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("replica_count")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def serde_parameters(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''These key-value pairs define initialization parameters for the SerDe.
+    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
+        '''Controls the operations ExternalDNS will perform on the records it manages.
 
-        :see: `AWS::Glue::Table SerdeInfo <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-serdeinfo.html#cfn-glue-table-serdeinfo-parameters>`_
+        :default: {@link ExternalDnsSyncPolicy.SYNC}
         '''
-        result = self._values.get("serde_parameters")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+        result = self._values.get("sync_policy")
+        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], result)
 
     @builtins.property
-    def storage_parameters(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''The user-supplied properties in key-value form.
-
-        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-parameters>`_
-        '''
-        result = self._values.get("storage_parameters")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+    def zone_tags(self) -> typing.Optional[typing.List[ExternalDnsZoneTag]]:
+        '''A set of tags that can be used to restrict which hosted zones external DNS will make changes to.'''
+        result = self._values.get("zone_tags")
+        return typing.cast(typing.Optional[typing.List[ExternalDnsZoneTag]], result)
 
     @builtins.property
-    def stored_as_sub_directories(self) -> typing.Optional[builtins.bool]:
-        '''True if the table data is stored in subdirectories, or False if not.
+    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
+        '''Controls the types of hosted zones external-dns will create records for.
 
-        :see: `AWS::Glue::Table StorageDescriptor <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-storagedescriptor.html#cfn-glue-table-storagedescriptor-storedassubdirectories>`_
+        :default: ExternalDnsZoneType.ALL
         '''
-        result = self._values.get("stored_as_sub_directories")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("zone_type")
+        return typing.cast(typing.Optional[ExternalDnsZoneType], result)
 
     @builtins.property
-    def table_type(self) -> typing.Optional["TableType"]:
-        '''The type of this table.
-
-        AWS Glue will create tables with the EXTERNAL_TABLE type. Other services, such as Athena, may create tables with additional table types.
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where external-dns should be deployed.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-tabletype>`_
-        '''
-        result = self._values.get("table_type")
-        return typing.cast(typing.Optional["TableType"], result)
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    def target_table(self) -> typing.Optional[Table]:
-        '''A TableIdentifier structure that describes a target table for resource linking.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-targettable>`_
-        '''
-        result = self._values.get("target_table")
-        return typing.cast(typing.Optional[Table], result)
+    def __repr__(self) -> str:
+        return "Route53DnsProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    def view_expanded_text(self) -> typing.Optional[builtins.str]:
-        '''Included for Apache Hive compatibility.
 
-        Not used in the normal course of AWS Glue operations.
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.SecretFieldReference",
+    jsii_struct_bases=[],
+    name_mapping={
+        "kubernetes_key": "kubernetesKey",
+        "metadata_policy": "metadataPolicy",
+        "remote_key": "remoteKey",
+    },
+)
+class SecretFieldReference:
+    def __init__(
+        self,
+        *,
+        kubernetes_key: builtins.str,
+        metadata_policy: typing.Optional[MetadataPolicy] = None,
+        remote_key: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for how to synchronize a specific field in a secret being imported.
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-viewexpandedtext>`_
+        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
+        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
+        :param remote_key: The JSON key for the field in the secret being imported.
         '''
-        result = self._values.get("view_expanded_text")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__85958058f60b5349b6efc3cb16e252dae2854865cf49f70b0877c64d7c4bf0dd)
+            check_type(argname="argument kubernetes_key", value=kubernetes_key, expected_type=type_hints["kubernetes_key"])
+            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
+            check_type(argname="argument remote_key", value=remote_key, expected_type=type_hints["remote_key"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "kubernetes_key": kubernetes_key,
+        }
+        if metadata_policy is not None:
+            self._values["metadata_policy"] = metadata_policy
+        if remote_key is not None:
+            self._values["remote_key"] = remote_key
 
     @builtins.property
-    def view_original_text(self) -> typing.Optional[builtins.str]:
-        '''Included for Apache Hive compatibility.
+    def kubernetes_key(self) -> builtins.str:
+        '''The name of the data key to be used for the field in the imported Kubernetes secret.'''
+        result = self._values.get("kubernetes_key")
+        assert result is not None, "Required property 'kubernetes_key' is missing"
+        return typing.cast(builtins.str, result)
 
-        Not used in the normal course of AWS Glue operations. If the table is a VIRTUAL_VIEW, certain Athena configuration encoded in base64.
+    @builtins.property
+    def metadata_policy(self) -> typing.Optional[MetadataPolicy]:
+        '''Policy for fetching tags/labels from provider secrets.'''
+        result = self._values.get("metadata_policy")
+        return typing.cast(typing.Optional[MetadataPolicy], result)
 
-        :see: `AWS::Glue::Table TableInput <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-table-tableinput.html#cfn-glue-table-tableinput-vieworiginaltext>`_
-        '''
-        result = self._values.get("view_original_text")
+    @builtins.property
+    def remote_key(self) -> typing.Optional[builtins.str]:
+        '''The JSON key for the field in the secret being imported.'''
+        result = self._values.get("remote_key")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TableProps(%s)" % ", ".join(
+        return "SecretFieldReference(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.glue.TableType")
-class TableType(enum.Enum):
-    EXTERNAL_TABLE = "EXTERNAL_TABLE"
-    VIRTUAL_VIEW = "VIRTUAL_VIEW"
-
-
-@jsii.enum(jsii_type="cdk-extensions.glue.TableUpdateBehavior")
-class TableUpdateBehavior(enum.Enum):
-    MERGE_NEW_COLUMNS = "MERGE_NEW_COLUMNS"
-
-
-@jsii.implements(ITrigger)
-class Trigger(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Trigger",
-):
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.SecretReferenceConfiguration",
+    jsii_struct_bases=[],
+    name_mapping={"remote_ref": "remoteRef", "fields": "fields"},
+)
+class SecretReferenceConfiguration:
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        type: "TriggerType",
-        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-        description: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-        predicate_operator: typing.Optional[PredicateOperator] = None,
-        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        start_on_creation: typing.Optional[builtins.bool] = None,
-        workflow: typing.Optional["Workflow"] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        remote_ref: builtins.str,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
     ) -> None:
-        '''Creates a new instance of the Trigger class.
+        '''Configuration detailing how secrets are to be synchronized.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param type: The type of trigger that this is.
-        :param actions: A list of actions initiated by this trigger.
-        :param description: A description for the trigger.
-        :param name: A name for the trigger.
-        :param predicate_conditions: A list of the conditions that determine when the trigger will fire.
-        :param predicate_operator: Operator for chaining predicate conditions if multiple are given.
-        :param schedule: A cron expression used to specify the schedule.
-        :param start_on_creation: Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
-        :param workflow: The name of the workflow associated with the trigger.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param remote_ref: The ID of the secret to be imported from the provider.
+        :param fields: A mapping of fields and per field options to use when synchronizing a secret from a provider.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9a79049a428bd5941424b4e094c84a859a725f32c171d87ac2126a1685ef641f)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = TriggerProps(
-            type=type,
-            actions=actions,
-            description=description,
-            name=name,
-            predicate_conditions=predicate_conditions,
-            predicate_operator=predicate_operator,
-            schedule=schedule,
-            start_on_creation=start_on_creation,
-            workflow=workflow,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        jsii.create(self.__class__, self, [scope, id, props])
-
-    @jsii.member(jsii_name="fromTriggerArn")
-    @builtins.classmethod
-    def from_trigger_arn(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        trigger_arn: builtins.str,
-    ) -> ITrigger:
-        '''Imports an existing trigger using its Amazon Resource Name (ARN).
+            type_hints = typing.get_type_hints(_typecheckingstub__4dc26d0199f1602801b856583653a8b0d62418efb64456ef381f7d916080559e)
+            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
+            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "remote_ref": remote_ref,
+        }
+        if fields is not None:
+            self._values["fields"] = fields
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param trigger_arn: The ARN of the trigger to import.
+    @builtins.property
+    def remote_ref(self) -> builtins.str:
+        '''The ID of the secret to be imported from the provider.'''
+        result = self._values.get("remote_ref")
+        assert result is not None, "Required property 'remote_ref' is missing"
+        return typing.cast(builtins.str, result)
 
-        :return: An object representing the trigger that was imported.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d29de485fa07fbea64e912490718223776c3ab360b719de644012a94fb6434f7)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument trigger_arn", value=trigger_arn, expected_type=type_hints["trigger_arn"])
-        return typing.cast(ITrigger, jsii.sinvoke(cls, "fromTriggerArn", [scope, id, trigger_arn]))
+    @builtins.property
+    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
+        '''A mapping of fields and per field options to use when synchronizing a secret from a provider.'''
+        result = self._values.get("fields")
+        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
 
-    @jsii.member(jsii_name="fromTriggerName")
-    @builtins.classmethod
-    def from_trigger_name(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        trigger_name: builtins.str,
-    ) -> ITrigger:
-        '''Imports an existing trigger using its name.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param trigger_name: The name of the trigger to import.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :return: An object representing the trigger that was imported.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f3434fb8f553f52f60a3e025608013104918640090d3d63398c7aa99c372b20d)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument trigger_name", value=trigger_name, expected_type=type_hints["trigger_name"])
-        return typing.cast(ITrigger, jsii.sinvoke(cls, "fromTriggerName", [scope, id, trigger_name]))
+    def __repr__(self) -> str:
+        return "SecretReferenceConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @jsii.member(jsii_name="addAction")
-    def add_action(self, action: ITriggerAction) -> "Trigger":
-        '''Registers an action with the trigger.
 
-        All actions associated with the
-        trigger are run when the conditions to trigger the trigger are met.
+@jsii.implements(ISecretReference)
+class SecretsManagerReference(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReference",
+):
+    '''Defines a reference for importing and synchronizing a Secrets Manager secret to a Kubernetes secret.'''
 
-        :param action: The action to be run by this trigger.
+    def __init__(
+        self,
+        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Creates a new instance of the SecretsManagerReference class.
 
-        :return: The trigger to which the action was added.
+        :param secret: The secret being referenced to import into Kubernetes.
+        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bc007dfc129810a05403a45fc2edb04eac2ac69328ffffbe932ae17113d5f057)
-            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
-        return typing.cast("Trigger", jsii.invoke(self, "addAction", [action]))
-
-    @jsii.member(jsii_name="addPredicate")
-    def add_predicate(self, predicate: ITriggerPredicate) -> "Trigger":
-        '''Registers a predicate with the trigger.
-
-        Triggers with predicates must meet
-        the conditions they specify in order to run.
+            type_hints = typing.get_type_hints(_typecheckingstub__c496d6306c81ceef9b7062404bcf66ea260c45a38d3b69dc2f1f0a90fd9af9d2)
+            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
+        options = SecretsManagerReferenceOptions(fields=fields)
 
-        :param predicate: The predicate to be added to the trigger.
+        jsii.create(self.__class__, self, [secret, options])
 
-        :return: The trigger to which the predicate was added.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2b67da5af6c648e853764f371b481f132349181516847a12a28a673bc51a3fe4)
-            check_type(argname="argument predicate", value=predicate, expected_type=type_hints["predicate"])
-        return typing.cast("Trigger", jsii.invoke(self, "addPredicate", [predicate]))
+    @jsii.member(jsii_name="addFieldMapping")
+    def add_field_mapping(
+        self,
+        *,
+        kubernetes_key: builtins.str,
+        metadata_policy: typing.Optional[MetadataPolicy] = None,
+        remote_key: typing.Optional[builtins.str] = None,
+    ) -> "SecretsManagerReference":
+        '''Adds a field mapping that specifies how a field from a Secrets Manager JSON secret should be mapped into the imported Kubernetes secret.
 
-    @builtins.property
-    @jsii.member(jsii_name="predicateOperator")
-    def predicate_operator(self) -> PredicateOperator:
-        '''Operator for chaining predicate conditions if multiple are given.
+        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
+        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
+        :param remote_key: The JSON key for the field in the secret being imported.
 
-        :see: `Trigger Predicate.Logical <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html#cfn-glue-trigger-predicate-logical>`_
-        :group: Inputs
+        :return: The ``SecretsManagerReference`` where the mapping was added.
         '''
-        return typing.cast(PredicateOperator, jsii.get(self, "predicateOperator"))
-
-    @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger:
-        '''The underlying Trigger CloudFormation resource.
+        field = SecretFieldReference(
+            kubernetes_key=kubernetes_key,
+            metadata_policy=metadata_policy,
+            remote_key=remote_key,
+        )
 
-        :see: `AWS::Glue::Trigger <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html>`_
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger, jsii.get(self, "resource"))
+        return typing.cast("SecretsManagerReference", jsii.invoke(self, "addFieldMapping", [field]))
 
-    @builtins.property
-    @jsii.member(jsii_name="triggerArn")
-    def trigger_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the trigger.'''
-        return typing.cast(builtins.str, jsii.get(self, "triggerArn"))
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> SecretReferenceConfiguration:
+        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.
 
-    @builtins.property
-    @jsii.member(jsii_name="triggerName")
-    def trigger_name(self) -> builtins.str:
-        '''The name of the trigger.'''
-        return typing.cast(builtins.str, jsii.get(self, "triggerName"))
+        :param _scope: The construct that will consume the generated configuration.
 
-    @builtins.property
-    @jsii.member(jsii_name="type")
-    def type(self) -> "TriggerType":
-        '''The type of trigger that this is.
+        :return:
 
-        :see: `Trigger Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-type>`_
-        :group: Inputs
+        A configuration object providing the details needed to build
+        the external secret Kubernetes resource.
         '''
-        return typing.cast("TriggerType", jsii.get(self, "type"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d70f039a06515082a5c4a0a4ba2130f884b4355bae0292328fb6429f6569cd96)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description for the trigger.
-
-        :see: `Trigger Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-description>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.List[SecretFieldReference]:
+        '''An array of field mappings which will be applied to this secret reference when mapping keys from SecretsManager JSON objects to keys in the imported secret.'''
+        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name for the trigger.
+    @jsii.member(jsii_name="secret")
+    def secret(self) -> _aws_cdk_aws_secretsmanager_ceddda9d.ISecret:
+        '''The secret being referenced to import into Kubernetes.'''
+        return typing.cast(_aws_cdk_aws_secretsmanager_ceddda9d.ISecret, jsii.get(self, "secret"))
 
-        :see: `Trigger Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-name>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
-    @builtins.property
-    @jsii.member(jsii_name="schedule")
-    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
-        '''A cron expression used to specify the schedule.
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReferenceOptions",
+    jsii_struct_bases=[],
+    name_mapping={"fields": "fields"},
+)
+class SecretsManagerReferenceOptions:
+    def __init__(
+        self,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Configuration options for referencing a Secrets Manager secret as a Kubernetes secret.
 
-        :see: `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_
-        :group: Inputs
+        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
         '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], jsii.get(self, "schedule"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__64d4869a39ffca99e3f183351ee069c38191bab52dbb76ac1d38c8a6a23da30b)
+            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if fields is not None:
+            self._values["fields"] = fields
 
     @builtins.property
-    @jsii.member(jsii_name="startOnCreation")
-    def start_on_creation(self) -> typing.Optional[builtins.bool]:
-        '''Set to true to start SCHEDULED and CONDITIONAL triggers when created.
-
-        True
-        is not supported for ON_DEMAND triggers.
+    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
+        '''Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.'''
+        result = self._values.get("fields")
+        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
 
-        :see: `Trigger StartOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-startoncreation>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "startOnCreation"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="workflow")
-    def workflow(self) -> typing.Optional["Workflow"]:
-        '''The name of the workflow associated with the trigger.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :see: `Trigger WorkflowName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-workflowname>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional["Workflow"], jsii.get(self, "workflow"))
+    def __repr__(self) -> str:
+        return "SecretsManagerReferenceOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.TriggerOptions",
+    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStoreProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "type": "type",
-        "actions": "actions",
-        "description": "description",
+        "cluster": "cluster",
         "name": "name",
-        "predicate_conditions": "predicateConditions",
-        "predicate_operator": "predicateOperator",
-        "schedule": "schedule",
-        "start_on_creation": "startOnCreation",
+        "namespace": "namespace",
     },
 )
-class TriggerOptions(_aws_cdk_ceddda9d.ResourceProps):
+class SecretsManagerSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        type: "TriggerType",
-        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-        description: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
         name: typing.Optional[builtins.str] = None,
-        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-        predicate_operator: typing.Optional[PredicateOperator] = None,
-        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        start_on_creation: typing.Optional[builtins.bool] = None,
+        namespace: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''
+        '''Configuration options for adding a new secret store resource.
+
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param type: 
-        :param actions: 
-        :param description: 
-        :param name: 
-        :param predicate_conditions: 
-        :param predicate_operator: 
-        :param schedule: 
-        :param start_on_creation: 
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__01145ca757e10f8e94b4c175dd3a267a5df9030339f6e4feb49750e5ff03ac64)
+            type_hints = typing.get_type_hints(_typecheckingstub__c06248919a788c055f92881d2ef760cb61263eb20ab5280e286e3f0705f184a0)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument predicate_conditions", value=predicate_conditions, expected_type=type_hints["predicate_conditions"])
-            check_type(argname="argument predicate_operator", value=predicate_operator, expected_type=type_hints["predicate_operator"])
-            check_type(argname="argument schedule", value=schedule, expected_type=type_hints["schedule"])
-            check_type(argname="argument start_on_creation", value=start_on_creation, expected_type=type_hints["start_on_creation"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "type": type,
+            "cluster": cluster,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if actions is not None:
-            self._values["actions"] = actions
-        if description is not None:
-            self._values["description"] = description
         if name is not None:
             self._values["name"] = name
-        if predicate_conditions is not None:
-            self._values["predicate_conditions"] = predicate_conditions
-        if predicate_operator is not None:
-            self._values["predicate_operator"] = predicate_operator
-        if schedule is not None:
-            self._values["schedule"] = schedule
-        if start_on_creation is not None:
-            self._values["start_on_creation"] = start_on_creation
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -6160,161 +7267,224 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def type(self) -> "TriggerType":
-        result = self._values.get("type")
-        assert result is not None, "Required property 'type' is missing"
-        return typing.cast("TriggerType", result)
-
-    @builtins.property
-    def actions(self) -> typing.Optional[typing.List[ITriggerAction]]:
-        result = self._values.get("actions")
-        return typing.cast(typing.Optional[typing.List[ITriggerAction]], result)
-
-    @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret store should be created.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
     @builtins.property
     def name(self) -> typing.Optional[builtins.str]:
+        '''A human friendly name for the secret store.'''
         result = self._values.get("name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def predicate_conditions(self) -> typing.Optional[typing.List[ITriggerPredicate]]:
-        result = self._values.get("predicate_conditions")
-        return typing.cast(typing.Optional[typing.List[ITriggerPredicate]], result)
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the secret store should be created.'''
+        result = self._values.get("namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "SecretsManagerSecretStoreProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.implements(ISecretReference)
+class SsmParameterReference(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.SsmParameterReference",
+):
+    '''Defines a reference for importing and synchronizing an SSM parameter to a Kubernetes secret.'''
+
+    def __init__(
+        self,
+        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Creates a new instance of the SsmParameterReference class.
+
+        :param parameter: The SSM parameter being referenced to import into Kubernetes.
+        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__be97b8cc9c656627b57f3db1afef2a495b5f9ef0693be3b77dd2ab818c7a14d2)
+            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
+        options = SsmParameterReferenceOptions(fields=fields)
+
+        jsii.create(self.__class__, self, [parameter, options])
+
+    @jsii.member(jsii_name="addFieldMapping")
+    def add_field_mapping(
+        self,
+        *,
+        kubernetes_key: builtins.str,
+        metadata_policy: typing.Optional[MetadataPolicy] = None,
+        remote_key: typing.Optional[builtins.str] = None,
+    ) -> "SsmParameterReference":
+        '''Adds a field mapping that specifies how a field from an SSM JSON parameter should be mapped into the imported Kubernetes secret.
+
+        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
+        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
+        :param remote_key: The JSON key for the field in the secret being imported.
+
+        :return: The ``SsmParameterReference`` where the mapping was added.
+        '''
+        field = SecretFieldReference(
+            kubernetes_key=kubernetes_key,
+            metadata_policy=metadata_policy,
+            remote_key=remote_key,
+        )
+
+        return typing.cast("SsmParameterReference", jsii.invoke(self, "addFieldMapping", [field]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> SecretReferenceConfiguration:
+        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.
+
+        :param _scope: The construct that will consume the generated configuration.
+
+        :return:
+
+        A configuration object providing the details needed to build
+        the external secret Kubernetes resource.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7147e379832a8ca243add61c65fb60f7361f398799b43de2302e5a36758d1417)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    def predicate_operator(self) -> typing.Optional[PredicateOperator]:
-        result = self._values.get("predicate_operator")
-        return typing.cast(typing.Optional[PredicateOperator], result)
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.List[SecretFieldReference]:
+        '''An array of field mappings which will be applied to this secret reference when mapping keys from SSM parameter JSON objects to keys in the imported secret.'''
+        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))
 
     @builtins.property
-    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
-        result = self._values.get("schedule")
-        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
+    @jsii.member(jsii_name="parameter")
+    def parameter(self) -> _aws_cdk_aws_ssm_ceddda9d.IParameter:
+        '''The SSM parameter being referenced to import into Kubernetes.'''
+        return typing.cast(_aws_cdk_aws_ssm_ceddda9d.IParameter, jsii.get(self, "parameter"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.SsmParameterReferenceOptions",
+    jsii_struct_bases=[],
+    name_mapping={"fields": "fields"},
+)
+class SsmParameterReferenceOptions:
+    def __init__(
+        self,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Configuration options for referencing an SSM parameter as a Kubernetes secret.
+
+        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__85f36849fed8daf98c94ff71f819a22287651f50ad8ac9fbde185a225ecf3d48)
+            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if fields is not None:
+            self._values["fields"] = fields
 
     @builtins.property
-    def start_on_creation(self) -> typing.Optional[builtins.bool]:
-        result = self._values.get("start_on_creation")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
+        '''Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.'''
+        result = self._values.get("fields")
+        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "TriggerOptions(%s)" % ", ".join(
+        return "SsmParameterReferenceOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.TriggerProps",
+    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStoreProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "type": "type",
-        "actions": "actions",
-        "description": "description",
+        "cluster": "cluster",
         "name": "name",
-        "predicate_conditions": "predicateConditions",
-        "predicate_operator": "predicateOperator",
-        "schedule": "schedule",
-        "start_on_creation": "startOnCreation",
-        "workflow": "workflow",
+        "namespace": "namespace",
     },
 )
-class TriggerProps(_aws_cdk_ceddda9d.ResourceProps):
+class SsmParameterSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        type: "TriggerType",
-        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-        description: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
         name: typing.Optional[builtins.str] = None,
-        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-        predicate_operator: typing.Optional[PredicateOperator] = None,
-        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        start_on_creation: typing.Optional[builtins.bool] = None,
-        workflow: typing.Optional["Workflow"] = None,
+        namespace: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the GlueTrigger resource.
+        '''Configuration options for adding a new secret store resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param type: The type of trigger that this is.
-        :param actions: A list of actions initiated by this trigger.
-        :param description: A description for the trigger.
-        :param name: A name for the trigger.
-        :param predicate_conditions: A list of the conditions that determine when the trigger will fire.
-        :param predicate_operator: Operator for chaining predicate conditions if multiple are given.
-        :param schedule: A cron expression used to specify the schedule.
-        :param start_on_creation: Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for ON_DEMAND triggers.
-        :param workflow: The name of the workflow associated with the trigger.
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ad020c3099533ac828ee3b7bc94f977e7beb54ccf917b0d37f088b52a7110039)
+            type_hints = typing.get_type_hints(_typecheckingstub__34a803d3f05acbd46634594fba4d5545e3823b2171c2f1104618a9a68b51217a)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument predicate_conditions", value=predicate_conditions, expected_type=type_hints["predicate_conditions"])
-            check_type(argname="argument predicate_operator", value=predicate_operator, expected_type=type_hints["predicate_operator"])
-            check_type(argname="argument schedule", value=schedule, expected_type=type_hints["schedule"])
-            check_type(argname="argument start_on_creation", value=start_on_creation, expected_type=type_hints["start_on_creation"])
-            check_type(argname="argument workflow", value=workflow, expected_type=type_hints["workflow"])
+            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "type": type,
+            "cluster": cluster,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if actions is not None:
-            self._values["actions"] = actions
-        if description is not None:
-            self._values["description"] = description
         if name is not None:
             self._values["name"] = name
-        if predicate_conditions is not None:
-            self._values["predicate_conditions"] = predicate_conditions
-        if predicate_operator is not None:
-            self._values["predicate_operator"] = predicate_operator
-        if schedule is not None:
-            self._values["schedule"] = schedule
-        if start_on_creation is not None:
-            self._values["start_on_creation"] = start_on_creation
-        if workflow is not None:
-            self._values["workflow"] = workflow
+        if namespace is not None:
+            self._values["namespace"] = namespace
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -6356,3709 +7526,7342 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def type(self) -> "TriggerType":
-        '''The type of trigger that this is.
-
-        :see: `Trigger Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-type>`_
-        '''
-        result = self._values.get("type")
-        assert result is not None, "Required property 'type' is missing"
-        return typing.cast("TriggerType", result)
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret store should be created.'''
+        result = self._values.get("cluster")
+        assert result is not None, "Required property 'cluster' is missing"
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
 
     @builtins.property
-    def actions(self) -> typing.Optional[typing.List[ITriggerAction]]:
-        '''A list of actions initiated by this trigger.
-
-        :see: `Trigger Actions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-actions>`_
-        '''
-        result = self._values.get("actions")
-        return typing.cast(typing.Optional[typing.List[ITriggerAction]], result)
+    def name(self) -> typing.Optional[builtins.str]:
+        '''A human friendly name for the secret store.'''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description for the trigger.
-
-        :see: `Trigger Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-description>`_
-        '''
-        result = self._values.get("description")
+    def namespace(self) -> typing.Optional[builtins.str]:
+        '''The Kubernetes namespace where the secret store should be created.'''
+        result = self._values.get("namespace")
         return typing.cast(typing.Optional[builtins.str], result)
 
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name for the trigger.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :see: `Trigger Name <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-name>`_
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    def predicate_conditions(self) -> typing.Optional[typing.List[ITriggerPredicate]]:
-        '''A list of the conditions that determine when the trigger will fire.
+    def __repr__(self) -> str:
+        return "SsmParameterSecretStoreProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :see: `Trigger Predicate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html>`_
-        '''
-        result = self._values.get("predicate_conditions")
-        return typing.cast(typing.Optional[typing.List[ITriggerPredicate]], result)
 
-    @builtins.property
-    def predicate_operator(self) -> typing.Optional[PredicateOperator]:
-        '''Operator for chaining predicate conditions if multiple are given.
+@jsii.implements(IExternalDnsRegistry)
+class TxtRegistry(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.TxtRegistry",
+):
+    '''An ExternalDNS registry that tracks DNS record ownership information using DNS TXT records.
 
-        :see: `Trigger Predicate.Logical <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-predicate.html#cfn-glue-trigger-predicate-logical>`_
-        '''
-        result = self._values.get("predicate_operator")
-        return typing.cast(typing.Optional[PredicateOperator], result)
+    :see: `About TXT records <https://support.google.com/a/answer/2716800?hl=en>`_
+    '''
 
-    @builtins.property
-    def schedule(self) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
-        '''A cron expression used to specify the schedule.
+    def __init__(
+        self,
+        *,
+        owner_id: typing.Optional[builtins.str] = None,
+        prefix: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the NoopRegistry class.
 
-        :see: `Time-Based Schedules for Jobs and Crawlers <https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html>`_
+        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
+        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
         '''
-        result = self._values.get("schedule")
-        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], result)
+        options = TxtRegistryOptions(owner_id=owner_id, prefix=prefix)
 
-    @builtins.property
-    def start_on_creation(self) -> typing.Optional[builtins.bool]:
-        '''Set to true to start SCHEDULED and CONDITIONAL triggers when created.
+        jsii.create(self.__class__, self, [options])
 
-        True
-        is not supported for ON_DEMAND triggers.
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ExternalDnsRegistryConfiguration:
+        '''Generates an object with all the information needed to use the registry in a given CDK scope.
 
-        :see: `Trigger StartOnCreation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-startoncreation>`_
-        '''
-        result = self._values.get("start_on_creation")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :param scope: The CDK resource that is configuring ExternalDNS.
 
-    @builtins.property
-    def workflow(self) -> typing.Optional["Workflow"]:
-        '''The name of the workflow associated with the trigger.
+        :return:
 
-        :see: `Trigger WorkflowName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-trigger.html#cfn-glue-trigger-workflowname>`_
+        A configuration object representing the implementation of this
+        registry.
         '''
-        result = self._values.get("workflow")
-        return typing.cast(typing.Optional["Workflow"], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__105e23602b6d46260f139f3822144dac2ba3d98f3a079c87534a0c62c41eb507)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DEFAULT_PREFIX")
+    def DEFAULT_PREFIX(cls) -> builtins.str:
+        '''The default prefix to append to TXT ownership records creates for the registry.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_PREFIX"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="NO_PREFIX")
+    def NO_PREFIX(cls) -> builtins.str:
+        '''A special value that specifies ExternalDNS should not use any prefix when creating TXT ownership records.
 
-    def __repr__(self) -> str:
-        return "TriggerProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        This is not recommended as it is likely to cause issues with record
+        creation and management with some record types that do not allow other
+        records with the same name and different types to exist (CNAME's).
 
+        However, if this behavior is desired this value can be passed as the
+        prefix to override the default behavior with will set a prefix if none
+        is provided as input.
+        '''
+        return typing.cast(builtins.str, jsii.sget(cls, "NO_PREFIX"))
 
-@jsii.enum(jsii_type="cdk-extensions.glue.TriggerType")
-class TriggerType(enum.Enum):
-    CONDITIONAL = "CONDITIONAL"
-    EVENT = "EVENT"
-    ON_DEMAND = "ON_DEMAND"
-    SCHEDULED = "SCHEDULED"
+    @builtins.property
+    @jsii.member(jsii_name="registryType")
+    def registry_type(self) -> builtins.str:
+        '''The type name of ExternalDNS registry.'''
+        return typing.cast(builtins.str, jsii.get(self, "registryType"))
 
+    @builtins.property
+    @jsii.member(jsii_name="ownerId")
+    def owner_id(self) -> typing.Optional[builtins.str]:
+        '''A unique identifier that is used to establish ownership of managed DNS records.
 
-@jsii.enum(jsii_type="cdk-extensions.glue.UpdateBehavior")
-class UpdateBehavior(enum.Enum):
-    UPDATE_IN_DATABASE = "UPDATE_IN_DATABASE"
-    LOG = "LOG"
+        Prevents conflicts in the event of multiple clusters running external-dns.
 
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ownerId"))
 
-class WorkerType(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.glue.WorkerType"):
-    '''The type of predefined worker that is allocated when a job runs.
+    @builtins.property
+    @jsii.member(jsii_name="prefix")
+    def prefix(self) -> typing.Optional[builtins.str]:
+        '''A prefix to be added top TXT ownership records.
 
-    If you need to use a WorkerType that doesn't exist as a static member, you
-    can instantiate a ``WorkerType`` object, e.g: ``WorkerType.of('other type')``.
-    '''
+        By default, the ownership record is a TXT record with the same name as the
+        managed record that was created. This causes issues as some record types
+        (CNAME's) do not allow duplicate records of a different type.
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, worker_type: builtins.str) -> "WorkerType":
-        '''Custom worker type.
+        This prefix is used to prevent such name collissions while still allowing
+        DNS ownership records to be created.
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefix"))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.TxtRegistryOptions",
+    jsii_struct_bases=[],
+    name_mapping={"owner_id": "ownerId", "prefix": "prefix"},
+)
+class TxtRegistryOptions:
+    def __init__(
+        self,
+        *,
+        owner_id: typing.Optional[builtins.str] = None,
+        prefix: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration options for setting up a TXT registry for ExternalDNS.
 
-        :param worker_type: custom worker type.
+        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
+        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4a01940e29d3d0fd83d19b9c7547e8ccfdc7c8f60414ad61defd54707cde2f02)
-            check_type(argname="argument worker_type", value=worker_type, expected_type=type_hints["worker_type"])
-        return typing.cast("WorkerType", jsii.sinvoke(cls, "of", [worker_type]))
+            type_hints = typing.get_type_hints(_typecheckingstub__49d222934bd8c2c391090725600916ef04457ba131b293ef18b5254a232b8e55)
+            check_type(argname="argument owner_id", value=owner_id, expected_type=type_hints["owner_id"])
+            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if owner_id is not None:
+            self._values["owner_id"] = owner_id
+        if prefix is not None:
+            self._values["prefix"] = prefix
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="G_1X")
-    def G_1_X(cls) -> "WorkerType":
-        '''Each worker maps to 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker.
+    @builtins.property
+    def owner_id(self) -> typing.Optional[builtins.str]:
+        '''A unique identifier that is used to establish ownership of managed DNS records.
+
+        Prevents conflicts in the event of multiple clusters running external-dns.
 
-        Suitable for memory-intensive jobs.
+        :default: Unique address of the owning CDK node.
         '''
-        return typing.cast("WorkerType", jsii.sget(cls, "G_1X"))
+        result = self._values.get("owner_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="G_2X")
-    def G_2_X(cls) -> "WorkerType":
-        '''Each worker maps to 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker.
+    @builtins.property
+    def prefix(self) -> typing.Optional[builtins.str]:
+        '''A prefix to be added top TXT ownership records.
+
+        By default, the ownership record is a TXT record with the same name as the
+        managed record that was created. This causes issues as some record types
+        (CNAME's) do not allow duplicate records of a different type.
 
-        Suitable for memory-intensive jobs.
+        This prefix is used to prevent such name collissions while still allowing
+        DNS ownership records to be created.
+
+        :default: 'edns.''
         '''
-        return typing.cast("WorkerType", jsii.sget(cls, "G_2X"))
+        result = self._values.get("prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="STANDARD")
-    def STANDARD(cls) -> "WorkerType":
-        '''Each worker provides 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.'''
-        return typing.cast("WorkerType", jsii.sget(cls, "STANDARD"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of this WorkerType, as expected by Job resource.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "TxtRegistryOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class Workflow(
+@jsii.implements(ISecretStore)
+class AwsSecretStore(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Workflow",
+    jsii_type="cdk-extensions.k8s_aws.AwsSecretStore",
 ):
+    '''A generic class representing secret store that is backed by an AWS service.'''
+
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        description: typing.Optional[builtins.str] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        service: builtins.str,
         name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the Workflow class.
+        '''Creates a new instance of the AwsSecretStore class.
 
-        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param description: A description of the Workflow.
-        :param name: A name of the Workflow.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param service: The name of the service provider backing the secret store.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__30858062db0892690086e05db3017264c21574c51cfe419ae83dc373da11b661)
+            type_hints = typing.get_type_hints(_typecheckingstub__a5db7e3c7776867e619b3b5a59436e82e10ef7dd279ce473dba2df2bc999988b)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = WorkflowProps(
-            description=description,
+        props = AwsSecretStoreProps(
+            cluster=cluster,
+            service=service,
             name=name,
+            namespace=namespace,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="addTrigger")
-    def add_trigger(
-        self,
-        id: builtins.str,
-        *,
-        type: TriggerType,
-        actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-        description: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-        predicate_operator: typing.Optional[PredicateOperator] = None,
-        schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        start_on_creation: typing.Optional[builtins.bool] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> ITrigger:
-        '''
-        :param id: -
-        :param type: 
-        :param actions: 
-        :param description: 
-        :param name: 
-        :param predicate_conditions: 
-        :param predicate_operator: 
-        :param schedule: 
-        :param start_on_creation: 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="NAME_VALIDATOR_REGEX")
+    def NAME_VALIDATOR_REGEX(cls) -> builtins.str:
+        '''The regex pattern used to validate secret store names.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "NAME_VALIDATOR_REGEX"))
+
+    @builtins.property
+    @jsii.member(jsii_name="cluster")
+    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
+        '''The EKS cluster where the secret store should be created.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ce55118dcfd5ce84c7d138d41de38e7579d11282f1f109403fe376a28709ebf9)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        options = TriggerOptions(
-            type=type,
-            actions=actions,
-            description=description,
-            name=name,
-            predicate_conditions=predicate_conditions,
-            predicate_operator=predicate_operator,
-            schedule=schedule,
-            start_on_creation=start_on_creation,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
 
-        return typing.cast(ITrigger, jsii.invoke(self, "addTrigger", [id, options]))
+    @builtins.property
+    @jsii.member(jsii_name="manifest")
+    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
+        '''The Kubernetes manifest that defines the secret store.
+
+        :group: Resources
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnWorkflow:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnWorkflow, jsii.get(self, "resource"))
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''A human friendly name for the secret store.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
     @builtins.property
-    @jsii.member(jsii_name="workflowArn")
-    def workflow_arn(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "workflowArn"))
+    @jsii.member(jsii_name="namespace")
+    def namespace(self) -> builtins.str:
+        '''The Kubernetes namespace where the secret store should be created.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "namespace"))
 
     @builtins.property
-    @jsii.member(jsii_name="workflowName")
-    def workflow_name(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "workflowName"))
+    @jsii.member(jsii_name="secretStoreName")
+    def secret_store_name(self) -> builtins.str:
+        '''The name of the secret store as it appears in Kubernetes.'''
+        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link WorkflowProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    @jsii.member(jsii_name="service")
+    def service(self) -> builtins.str:
+        '''The name of the service provider backing the secret store.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "service"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link WorkflowProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    @jsii.member(jsii_name="serviceAccount")
+    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
+        '''A Kubernetes service account mapped to an IAM role that provides the necessary permissions to sychronize secrets from an AWS rpvoder.
+
+        :group: Resources
+        '''
+        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
 
 
-class WorkflowAction(
+@jsii.implements(IExternalDnsRegistry)
+class AwsServiceDiscoveryRegistry(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowAction",
+    jsii_type="cdk-extensions.k8s_aws.AwsServiceDiscoveryRegistry",
 ):
-    '''Actions to be started by a Glue workflow trigger when it is activated.'''
+    '''An ExternalDNS registry that tracks DNS record ownership information using AWS Service Discovery.
+
+    :see: `AWS Cloud Map <https://docs.aws.amazon.com/cloud-map/latest/dg/what-is-cloud-map.html>`_
+    '''
 
     def __init__(self) -> None:
+        '''Creates a new instance of the AwsServiceDiscoveryRegistry class.'''
         jsii.create(self.__class__, self, [])
 
-    @jsii.member(jsii_name="crawler")
-    @builtins.classmethod
-    def crawler(
-        cls,
-        crawler: ICrawler,
-        *,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> "WorkflowCrawlerAction":
-        '''An action that runs a crawler as part of a Glue workflow.
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ExternalDnsRegistryConfiguration:
+        '''Generates an object with all the information needed to use the registry in a given CDK scope.
 
-        :param crawler: The crawler to run as part of the workflow.
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param scope: The CDK resource that is configuring ExternalDNS.
 
-        :return: A workflow action that runs the crawler with the given options.
+        :return:
+
+        A configuration object representing the implementation of this
+        registry.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1e1780b54c3d5134781210aa5dcce6cc5585326dcffdae0be9004a975c463191)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        options = WorkflowCrawlerActionOptions(
-            arguments=arguments,
-            notify_delay_after=notify_delay_after,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__b365e8ec462c9d5a06a032056dcf37739fad6ac73b424fbd4e54e70dd68eca9d)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="registryType")
+    def registry_type(self) -> builtins.str:
+        '''The type name of ExternalDNS registry.'''
+        return typing.cast(builtins.str, jsii.get(self, "registryType"))
 
-        return typing.cast("WorkflowCrawlerAction", jsii.sinvoke(cls, "crawler", [crawler, options]))
 
-    @jsii.member(jsii_name="job")
-    @builtins.classmethod
-    def job(
-        cls,
-        job: IJob,
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitCloudWatchLogsOutputOptions",
+    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "auto_create_group": "autoCreateGroup",
+        "auto_retry_requests": "autoRetryRequests",
+        "endpoint": "endpoint",
+        "log_format": "logFormat",
+        "log_group": "logGroup",
+        "log_group_template": "logGroupTemplate",
+        "log_key": "logKey",
+        "log_retention": "logRetention",
+        "log_stream": "logStream",
+        "log_stream_template": "logStreamTemplate",
+        "metric_dimensions": "metricDimensions",
+        "metric_namespace": "metricNamespace",
+        "region": "region",
+        "role": "role",
+        "sts_endpoint": "stsEndpoint",
+    },
+)
+class FluentBitCloudWatchLogsOutputOptions(FluentBitOutputPluginCommonOptions):
+    def __init__(
+        self,
         *,
-        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+        auto_create_group: typing.Optional[builtins.bool] = None,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_format: typing.Optional[builtins.str] = None,
+        log_group: typing.Optional[FluentBitLogGroupOutput] = None,
+        log_group_template: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
+        log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
+        log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
+        log_stream_template: typing.Optional[builtins.str] = None,
+        metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        metric_namespace: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-    ) -> "WorkflowJobAction":
-        '''An action that runs a Glue job as part of a workflow.
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for configuring the CloudWatch Logs Fluent Bit output plugin.
 
-        :param job: The job to run as part of the workflow.
-        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param match: The pattern to match for records that this output should apply to.
+        :param auto_create_group: Automatically create the log group. Default: false
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param endpoint: Specify a custom endpoint for the CloudWatch Logs API.
+        :param log_format: An optional parameter that can be used to tell CloudWatch the format of the data. A value of json/emf enables CloudWatch to extract custom metrics embedded in a JSON payload.
+        :param log_group: The CloudWatch Log Group configuration for output records.
+        :param log_group_template: Template for Log Group name using Fluent Bit record_accessor syntax. This field is optional and if configured it overrides the configured Log Group. If the template translation fails, an error is logged and the provided Log Group (which is still required) is used instead.
+        :param log_key: By default, the whole log record will be sent to CloudWatch. If you specify a key name with this option, then only the value of that key will be sent to CloudWatch.
+        :param log_retention: If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
+        :param log_stream: The CloudWatch LogStream configuration for outbound records.
+        :param log_stream_template: Template for Log Stream name using Fluent Bit record accessor syntax. This field is optional and if configured it overrides the other log stream options. If the template translation fails, an error is logged and the logStream or logStreamPrefix are used instead (and thus one of those fields is still required to be configured).
+        :param metric_dimensions: A list of lists containing the dimension keys that will be applied to all metrics. The values within a dimension set MUST also be members on the root-node.
+        :param metric_namespace: An optional string representing the CloudWatch namespace for the metrics.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+
+        :see: `CloudWatch Logs Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0a6ddb803ae38cffafb281e286ceb82c9d46f01f71cc1c19883463d5671ffb62)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument auto_create_group", value=auto_create_group, expected_type=type_hints["auto_create_group"])
+            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
+            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
+            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument log_group_template", value=log_group_template, expected_type=type_hints["log_group_template"])
+            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
+            check_type(argname="argument log_retention", value=log_retention, expected_type=type_hints["log_retention"])
+            check_type(argname="argument log_stream", value=log_stream, expected_type=type_hints["log_stream"])
+            check_type(argname="argument log_stream_template", value=log_stream_template, expected_type=type_hints["log_stream_template"])
+            check_type(argname="argument metric_dimensions", value=metric_dimensions, expected_type=type_hints["metric_dimensions"])
+            check_type(argname="argument metric_namespace", value=metric_namespace, expected_type=type_hints["metric_namespace"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if auto_create_group is not None:
+            self._values["auto_create_group"] = auto_create_group
+        if auto_retry_requests is not None:
+            self._values["auto_retry_requests"] = auto_retry_requests
+        if endpoint is not None:
+            self._values["endpoint"] = endpoint
+        if log_format is not None:
+            self._values["log_format"] = log_format
+        if log_group is not None:
+            self._values["log_group"] = log_group
+        if log_group_template is not None:
+            self._values["log_group_template"] = log_group_template
+        if log_key is not None:
+            self._values["log_key"] = log_key
+        if log_retention is not None:
+            self._values["log_retention"] = log_retention
+        if log_stream is not None:
+            self._values["log_stream"] = log_stream
+        if log_stream_template is not None:
+            self._values["log_stream_template"] = log_stream_template
+        if metric_dimensions is not None:
+            self._values["metric_dimensions"] = metric_dimensions
+        if metric_namespace is not None:
+            self._values["metric_namespace"] = metric_namespace
+        if region is not None:
+            self._values["region"] = region
+        if role is not None:
+            self._values["role"] = role
+        if sts_endpoint is not None:
+            self._values["sts_endpoint"] = sts_endpoint
 
-        :return: A workflow action that runs the job with the given options.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3a94d581f860b13a89641b07de3a6dff7bb35902a5e740ce1b0305d078a71a88)
-            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
-        options = WorkflowJobActionOptions(
-            bookmark_configuration=bookmark_configuration,
-            arguments=arguments,
-            notify_delay_after=notify_delay_after,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
 
-        return typing.cast("WorkflowJobAction", jsii.sinvoke(cls, "job", [job, options]))
+    @builtins.property
+    def auto_create_group(self) -> typing.Optional[builtins.bool]:
+        '''Automatically create the log group.
 
+        :default: false
+        '''
+        result = self._values.get("auto_create_group")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-class WorkflowActionBase(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowActionBase",
-):
-    '''Base class providing common functionality for workflow trigger actions.'''
+    @builtins.property
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
 
-    def __init__(
-        self,
-        *,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the WorkflowActionBase class.
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
 
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :default: true
         '''
-        options = WorkflowActionOptions(
-            arguments=arguments,
-            notify_delay_after=notify_delay_after,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        result = self._values.get("auto_retry_requests")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        jsii.create(self.__class__, self, [options])
+    @builtins.property
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the CloudWatch Logs API.'''
+        result = self._values.get("endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.member(jsii_name="addArgument")
-    def add_argument(self, key: builtins.str, value: builtins.str) -> None:
-        '''Adds an argument that will be passed to the specified action when triggered as part of a workflow.
+    @builtins.property
+    def log_format(self) -> typing.Optional[builtins.str]:
+        '''An optional parameter that can be used to tell CloudWatch the format of the data.
 
-        :param key: The name of the argument being set.
-        :param value: The value to pass for the specified argument.
+        A value of json/emf enables CloudWatch to extract custom
+        metrics embedded in a JSON payload.
 
-        :see: `AWS Glue job parameters <https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html>`_
+        :see: `Embedded Metric Format <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__05b16d8f0e42dabc8d5b35b3da8eefd18876b6a5a59a4f740c34c94379a3a823)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast(None, jsii.invoke(self, "addArgument", [key, value]))
+        result = self._values.get("log_format")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def log_group(self) -> typing.Optional[FluentBitLogGroupOutput]:
+        '''The CloudWatch Log Group configuration for output records.'''
+        result = self._values.get("log_group")
+        return typing.cast(typing.Optional[FluentBitLogGroupOutput], result)
 
-    @jsii.member(jsii_name="bindOptions")
-    def _bind_options(self, _scope: _constructs_77d1e7e8.IConstruct) -> typing.Any:
-        '''Associates the action with a construct that is configuring a trigger for a Glue workflow.
+    @builtins.property
+    def log_group_template(self) -> typing.Optional[builtins.str]:
+        '''Template for Log Group name using Fluent Bit record_accessor syntax.
 
-        :param _scope: The construct configuring the Glue trigger.
+        This field is optional and if configured it overrides the configured Log
+        Group.
 
-        :return:
+        If the template translation fails, an error is logged and the provided
+        Log Group (which is still required) is used instead.
 
-        A configuration object that can be used to configure a triggered
-        workflow action.
+        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__99f5b49f9607b05a4e188e075be9ce415c7b6b085607cb3e0f90e94cc8453feb)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(typing.Any, jsii.invoke(self, "bindOptions", [_scope]))
+        result = self._values.get("log_group_template")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="notifyDelayAfter")
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to CloudWatch.
 
-        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
-        :group: Inputs
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to CloudWatch.
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "notifyDelayAfter"))
+        result = self._values.get("log_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="securityConfiguration")
-    def security_configuration(self) -> typing.Optional[builtins.str]:
-        '''The name of the SecurityConfiguration structure to be used with this action.
+    def log_retention(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays]:
+        '''If set to a number greater than zero, and newly create log group's retention policy is set to this many days.'''
+        result = self._values.get("log_retention")
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays], result)
 
-        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
-        :alpha: true
-        :group: Inputs
+    @builtins.property
+    def log_stream(self) -> typing.Optional[FluentBitLogStreamOutput]:
+        '''The CloudWatch LogStream configuration for outbound records.'''
+        result = self._values.get("log_stream")
+        return typing.cast(typing.Optional[FluentBitLogStreamOutput], result)
+
+    @builtins.property
+    def log_stream_template(self) -> typing.Optional[builtins.str]:
+        '''Template for Log Stream name using Fluent Bit record accessor syntax.
+
+        This field is optional and if configured it overrides the other log
+        stream options. If the template translation fails, an error is logged
+        and the logStream or logStreamPrefix are used instead (and thus one of
+        those fields is still required to be configured).
+
+        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "securityConfiguration"))
+        result = self._values.get("log_stream_template")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeout")
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The ``JobRun`` timeout in minutes.
+    def metric_dimensions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''A list of lists containing the dimension keys that will be applied to all metrics.
 
-        This is the maximum time that a job run
-        can consume resources before it is terminated and enters TIMEOUT status.
-        The default is 48 hours. This overrides the timeout value set in the
-        parent job.
+        The values within a dimension set MUST also be members on
+        the root-node.
 
-        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
-        :group: Inputs
+        :see: `Dimensions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension>`_
+        '''
+        result = self._values.get("metric_dimensions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+
+    @builtins.property
+    def metric_namespace(self) -> typing.Optional[builtins.str]:
+        '''An optional string representing the CloudWatch namespace for the metrics.
+
+        :see: `Metric Tutorial <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch#metrics-tutorial>`_
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "timeout"))
+        result = self._values.get("metric_namespace")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.'''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).'''
+        result = self._values.get("role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+
+    @builtins.property
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.'''
+        result = self._values.get("sts_endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "FluentBitCloudWatchLogsOutputOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowActionOptions",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitElasticsearchOutputOptions",
+    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
     name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "arguments": "arguments",
-        "notify_delay_after": "notifyDelayAfter",
-        "security_configuration": "securityConfiguration",
-        "timeout": "timeout",
+        "match": "match",
+        "host": "host",
+        "aws_auth": "awsAuth",
+        "aws_external_id": "awsExternalId",
+        "aws_region": "awsRegion",
+        "aws_role": "awsRole",
+        "aws_sts_endpoint": "awsStsEndpoint",
+        "buffer_size": "bufferSize",
+        "cloud_auth": "cloudAuth",
+        "cloud_id": "cloudId",
+        "compress": "compress",
+        "current_time_index": "currentTimeIndex",
+        "generate_id": "generateId",
+        "http_passwd": "httpPasswd",
+        "http_user": "httpUser",
+        "id_key": "idKey",
+        "include_tag_key": "includeTagKey",
+        "index": "index",
+        "logstash_date_format": "logstashDateFormat",
+        "logstash_format": "logstashFormat",
+        "logstash_prefix": "logstashPrefix",
+        "logstash_prefix_key": "logstashPrefixKey",
+        "path": "path",
+        "pipeline": "pipeline",
+        "port": "port",
+        "replace_dots": "replaceDots",
+        "suppress_type_name": "suppressTypeName",
+        "tag_key": "tagKey",
+        "time_key": "timeKey",
+        "time_key_format": "timeKeyFormat",
+        "time_key_nanos": "timeKeyNanos",
+        "trace_error": "traceError",
+        "trace_output": "traceOutput",
+        "type": "type",
+        "workers": "workers",
+        "write_operation": "writeOperation",
     },
 )
-class WorkflowActionOptions(_aws_cdk_ceddda9d.ResourceProps):
+class FluentBitElasticsearchOutputOptions(FluentBitOutputPluginCommonOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    ) -> None:
-        '''Configuration for the Workflow Action resource.
+        match: typing.Optional[FluentBitMatch] = None,
+        host: builtins.str,
+        aws_auth: typing.Optional[builtins.bool] = None,
+        aws_external_id: typing.Optional[builtins.str] = None,
+        aws_region: typing.Optional[builtins.str] = None,
+        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        aws_sts_endpoint: typing.Optional[builtins.str] = None,
+        buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
+        cloud_auth: typing.Optional[builtins.str] = None,
+        cloud_id: typing.Optional[builtins.str] = None,
+        compress: typing.Optional[ElasticsearchCompressionFormat] = None,
+        current_time_index: typing.Optional[builtins.bool] = None,
+        generate_id: typing.Optional[builtins.bool] = None,
+        http_passwd: typing.Optional[builtins.str] = None,
+        http_user: typing.Optional[builtins.str] = None,
+        id_key: typing.Optional[builtins.str] = None,
+        include_tag_key: typing.Optional[builtins.bool] = None,
+        index: typing.Optional[builtins.str] = None,
+        logstash_date_format: typing.Optional[builtins.str] = None,
+        logstash_format: typing.Optional[builtins.bool] = None,
+        logstash_prefix: typing.Optional[builtins.str] = None,
+        logstash_prefix_key: typing.Optional[builtins.str] = None,
+        path: typing.Optional[builtins.str] = None,
+        pipeline: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replace_dots: typing.Optional[builtins.bool] = None,
+        suppress_type_name: typing.Optional[builtins.bool] = None,
+        tag_key: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        time_key_nanos: typing.Optional[builtins.bool] = None,
+        trace_error: typing.Optional[builtins.bool] = None,
+        trace_output: typing.Optional[builtins.bool] = None,
+        type: typing.Optional[builtins.str] = None,
+        workers: typing.Optional[jsii.Number] = None,
+        write_operation: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for configuring the Elasticsearch Fluent Bit output plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param host: IP address or hostname of the target Elasticsearch instance.
+        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service. Default: false
+        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
+        :param aws_region: Specify the AWS region for Elasticsearch Service.
+        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
+        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
+        :param buffer_size: Specify the buffer size used to read the response from the Elasticsearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
+        :param cloud_auth: Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
+        :param cloud_id: If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
+        :param compress: Set payload compression mechanism.
+        :param current_time_index: Use current time for index generation instead of message record. Default: false
+        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
+        :param http_passwd: Password for user defined in ``httpUser``.
+        :param http_user: Optional username credential for access.
+        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+        :param include_tag_key: When enabled, it append the Tag name to the record.
+        :param index: Index name. Default: 'fluent-bit
+        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
+        :param logstash_format: Enable Logstash format compatibility. Default: false
+        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
+        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
+        :param path: Elasticsearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
+        :param pipeline: Elasticsearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
+        :param port: TCP port of the target Elasticsearch instance. Default: 9200
+        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
+        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
+        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
+        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
+        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
+        :param trace_error: When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only). Default: false
+        :param trace_output: When enabled print the Elasticsearch API calls to stdout (for diag only). Default: false
+        :param type: Type name. Default: '_doc'
+        :param workers: Enables dedicated thread(s) for this output. Default: 2
+        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
+
+        :see: `Opensearch Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/elasticsearch>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d15707b98b30fc02a4da2bf5ff3f6fab3135470fb1fbfa8644ad8ebe83173635)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
+            check_type(argname="argument aws_auth", value=aws_auth, expected_type=type_hints["aws_auth"])
+            check_type(argname="argument aws_external_id", value=aws_external_id, expected_type=type_hints["aws_external_id"])
+            check_type(argname="argument aws_region", value=aws_region, expected_type=type_hints["aws_region"])
+            check_type(argname="argument aws_role", value=aws_role, expected_type=type_hints["aws_role"])
+            check_type(argname="argument aws_sts_endpoint", value=aws_sts_endpoint, expected_type=type_hints["aws_sts_endpoint"])
+            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
+            check_type(argname="argument cloud_auth", value=cloud_auth, expected_type=type_hints["cloud_auth"])
+            check_type(argname="argument cloud_id", value=cloud_id, expected_type=type_hints["cloud_id"])
+            check_type(argname="argument compress", value=compress, expected_type=type_hints["compress"])
+            check_type(argname="argument current_time_index", value=current_time_index, expected_type=type_hints["current_time_index"])
+            check_type(argname="argument generate_id", value=generate_id, expected_type=type_hints["generate_id"])
+            check_type(argname="argument http_passwd", value=http_passwd, expected_type=type_hints["http_passwd"])
+            check_type(argname="argument http_user", value=http_user, expected_type=type_hints["http_user"])
+            check_type(argname="argument id_key", value=id_key, expected_type=type_hints["id_key"])
+            check_type(argname="argument include_tag_key", value=include_tag_key, expected_type=type_hints["include_tag_key"])
+            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
+            check_type(argname="argument logstash_date_format", value=logstash_date_format, expected_type=type_hints["logstash_date_format"])
+            check_type(argname="argument logstash_format", value=logstash_format, expected_type=type_hints["logstash_format"])
+            check_type(argname="argument logstash_prefix", value=logstash_prefix, expected_type=type_hints["logstash_prefix"])
+            check_type(argname="argument logstash_prefix_key", value=logstash_prefix_key, expected_type=type_hints["logstash_prefix_key"])
+            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
+            check_type(argname="argument pipeline", value=pipeline, expected_type=type_hints["pipeline"])
+            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
+            check_type(argname="argument replace_dots", value=replace_dots, expected_type=type_hints["replace_dots"])
+            check_type(argname="argument suppress_type_name", value=suppress_type_name, expected_type=type_hints["suppress_type_name"])
+            check_type(argname="argument tag_key", value=tag_key, expected_type=type_hints["tag_key"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
+            check_type(argname="argument time_key_nanos", value=time_key_nanos, expected_type=type_hints["time_key_nanos"])
+            check_type(argname="argument trace_error", value=trace_error, expected_type=type_hints["trace_error"])
+            check_type(argname="argument trace_output", value=trace_output, expected_type=type_hints["trace_output"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+            check_type(argname="argument workers", value=workers, expected_type=type_hints["workers"])
+            check_type(argname="argument write_operation", value=write_operation, expected_type=type_hints["write_operation"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "host": host,
+        }
+        if match is not None:
+            self._values["match"] = match
+        if aws_auth is not None:
+            self._values["aws_auth"] = aws_auth
+        if aws_external_id is not None:
+            self._values["aws_external_id"] = aws_external_id
+        if aws_region is not None:
+            self._values["aws_region"] = aws_region
+        if aws_role is not None:
+            self._values["aws_role"] = aws_role
+        if aws_sts_endpoint is not None:
+            self._values["aws_sts_endpoint"] = aws_sts_endpoint
+        if buffer_size is not None:
+            self._values["buffer_size"] = buffer_size
+        if cloud_auth is not None:
+            self._values["cloud_auth"] = cloud_auth
+        if cloud_id is not None:
+            self._values["cloud_id"] = cloud_id
+        if compress is not None:
+            self._values["compress"] = compress
+        if current_time_index is not None:
+            self._values["current_time_index"] = current_time_index
+        if generate_id is not None:
+            self._values["generate_id"] = generate_id
+        if http_passwd is not None:
+            self._values["http_passwd"] = http_passwd
+        if http_user is not None:
+            self._values["http_user"] = http_user
+        if id_key is not None:
+            self._values["id_key"] = id_key
+        if include_tag_key is not None:
+            self._values["include_tag_key"] = include_tag_key
+        if index is not None:
+            self._values["index"] = index
+        if logstash_date_format is not None:
+            self._values["logstash_date_format"] = logstash_date_format
+        if logstash_format is not None:
+            self._values["logstash_format"] = logstash_format
+        if logstash_prefix is not None:
+            self._values["logstash_prefix"] = logstash_prefix
+        if logstash_prefix_key is not None:
+            self._values["logstash_prefix_key"] = logstash_prefix_key
+        if path is not None:
+            self._values["path"] = path
+        if pipeline is not None:
+            self._values["pipeline"] = pipeline
+        if port is not None:
+            self._values["port"] = port
+        if replace_dots is not None:
+            self._values["replace_dots"] = replace_dots
+        if suppress_type_name is not None:
+            self._values["suppress_type_name"] = suppress_type_name
+        if tag_key is not None:
+            self._values["tag_key"] = tag_key
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if time_key_format is not None:
+            self._values["time_key_format"] = time_key_format
+        if time_key_nanos is not None:
+            self._values["time_key_nanos"] = time_key_nanos
+        if trace_error is not None:
+            self._values["trace_error"] = trace_error
+        if trace_output is not None:
+            self._values["trace_output"] = trace_output
+        if type is not None:
+            self._values["type"] = type
+        if workers is not None:
+            self._values["workers"] = workers
+        if write_operation is not None:
+            self._values["write_operation"] = write_operation
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def host(self) -> builtins.str:
+        '''IP address or hostname of the target Elasticsearch instance.'''
+        result = self._values.get("host")
+        assert result is not None, "Required property 'host' is missing"
+        return typing.cast(builtins.str, result)
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
+    @builtins.property
+    def aws_auth(self) -> typing.Optional[builtins.bool]:
+        '''Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service.
+
+        :default: false
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7005e62847fa5591337705760979f2e03a39c841c84835a874bcebaca8a59289)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
-            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
-            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
-            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if arguments is not None:
-            self._values["arguments"] = arguments
-        if notify_delay_after is not None:
-            self._values["notify_delay_after"] = notify_delay_after
-        if security_configuration is not None:
-            self._values["security_configuration"] = security_configuration
-        if timeout is not None:
-            self._values["timeout"] = timeout
+        result = self._values.get("aws_auth")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    def aws_external_id(self) -> typing.Optional[builtins.str]:
+        '''External ID for the AWS IAM Role specified with ``awsRole``.'''
+        result = self._values.get("aws_external_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: - the resource is in the same account as the stack it belongs to
+    @builtins.property
+    def aws_region(self) -> typing.Optional[builtins.str]:
+        '''Specify the AWS region for Elasticsearch Service.'''
+        result = self._values.get("aws_region")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''AWS IAM Role to assume to put records to your Amazon cluster.'''
+        result = self._values.get("aws_role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+
+    @builtins.property
+    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.'''
+        result = self._values.get("aws_sts_endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def buffer_size(self) -> typing.Optional[ElasticsearchOutputBufferSize]:
+        '''Specify the buffer size used to read the response from the Elasticsearch HTTP service.
+
+        This option is useful for debugging purposes where is
+        required to read full responses, note that response size grows depending
+        of the number of records inserted.
         '''
-        result = self._values.get("account")
+        result = self._values.get("buffer_size")
+        return typing.cast(typing.Optional[ElasticsearchOutputBufferSize], result)
+
+    @builtins.property
+    def cloud_auth(self) -> typing.Optional[builtins.str]:
+        '''Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.'''
+        result = self._values.get("cloud_auth")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    def cloud_id(self) -> typing.Optional[builtins.str]:
+        '''If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.'''
+        result = self._values.get("cloud_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+    @builtins.property
+    def compress(self) -> typing.Optional[ElasticsearchCompressionFormat]:
+        '''Set payload compression mechanism.'''
+        result = self._values.get("compress")
+        return typing.cast(typing.Optional[ElasticsearchCompressionFormat], result)
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    @builtins.property
+    def current_time_index(self) -> typing.Optional[builtins.bool]:
+        '''Use current time for index generation instead of message record.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :default: false
         '''
-        result = self._values.get("environment_from_arn")
+        result = self._values.get("current_time_index")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def generate_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, generate ``_id`` for outgoing records.
+
+        This prevents duplicate
+        records when retrying.
+        '''
+        result = self._values.get("generate_id")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def http_passwd(self) -> typing.Optional[builtins.str]:
+        '''Password for user defined in ``httpUser``.'''
+        result = self._values.get("http_passwd")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    def http_user(self) -> typing.Optional[builtins.str]:
+        '''Optional username credential for access.'''
+        result = self._values.get("http_user")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+    @builtins.property
+    def id_key(self) -> typing.Optional[builtins.str]:
+        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.'''
+        result = self._values.get("id_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+    @builtins.property
+    def include_tag_key(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it append the Tag name to the record.'''
+        result = self._values.get("include_tag_key")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def index(self) -> typing.Optional[builtins.str]:
+        '''Index name.
+
+        :default: 'fluent-bit
         '''
-        result = self._values.get("physical_name")
+        result = self._values.get("index")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def logstash_date_format(self) -> typing.Optional[builtins.str]:
+        '''Time format (based on strftime) to generate the second part of the Index name.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :default: '%Y.%m.%d'
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        result = self._values.get("region")
+        result = self._values.get("logstash_date_format")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''The arguments to use when the associated trigger fires.
+    def logstash_format(self) -> typing.Optional[builtins.bool]:
+        '''Enable Logstash format compatibility.
 
-        Jobs run via the associated trigger will have their default arguments
-        replaced with the arguments specified.
+        :default: false
+        '''
+        result = self._values.get("logstash_format")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        You can specify arguments here that your own job-execution script
-        consumes, in addition to arguments that AWS Glue itself consumes.
+    @builtins.property
+    def logstash_prefix(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+
+        The last string appended belongs to the date when the data is being
+        generated.
 
-        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
+        :default: 'logstash'
         '''
-        result = self._values.get("arguments")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+        result = self._values.get("logstash_prefix")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
+        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
 
-        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        If
+        the key/value is not found in the record then the ``logstashPrefix`` option
+        will act as a fallback.
+
+        Nested keys are not supported (if desired, you can use the nest filter
+        plugin to remove nesting)
         '''
-        result = self._values.get("notify_delay_after")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("logstash_prefix_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def security_configuration(self) -> typing.Optional[builtins.str]:
-        '''The name of the SecurityConfiguration structure to be used with this action.
+    def path(self) -> typing.Optional[builtins.str]:
+        '''Elasticsearch accepts new data on HTTP query path "/_bulk".
 
-        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
-        :alpha: true
+        But it is
+        also possible to serve Elasticsearch behind a reverse proxy on a
+        subpath. This option defines such path on the fluent-bit side. It
+        simply adds a path prefix in the indexing HTTP POST URI..
         '''
-        result = self._values.get("security_configuration")
+        result = self._values.get("path")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The ``JobRun`` timeout in minutes.
+    def pipeline(self) -> typing.Optional[builtins.str]:
+        '''Elasticsearch allows to setup filters called pipelines.
 
-        This is the maximum time that a job run
-        can consume resources before it is terminated and enters TIMEOUT status.
-        The default is 48 hours. This overrides the timeout value set in the
-        parent job.
+        This option
+        allows to define which pipeline the database should use.
+        '''
+        result = self._values.get("pipeline")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+    @builtins.property
+    def port(self) -> typing.Optional[jsii.Number]:
+        '''TCP port of the target Elasticsearch instance.
+
+        :default: 9200
         '''
-        result = self._values.get("timeout")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("port")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def replace_dots(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, replace field name dots with underscore.
+
+        :default: false
+        '''
+        result = self._values.get("replace_dots")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, mapping types is removed and ``type`` option is ignored.
+
+        :default: false
+        '''
+        result = self._values.get("suppress_type_name")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def tag_key(self) -> typing.Optional[builtins.str]:
+        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+
+        :default: '_flb-key'
+        '''
+        result = self._values.get("tag_key")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+
+        The``timeKey`` property defines the name of that field.
+
+        :default: '
+
+        :timestamp: '
+        '''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+
+        :default: '%Y-%m-%dT%H:%M:%S'
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        '''
+        result = self._values.get("time_key_format")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
+        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+
+        :default: false
+        '''
+        result = self._values.get("time_key_nanos")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def trace_error(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only).
+
+        :default: false
+        '''
+        result = self._values.get("trace_error")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def trace_output(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the Elasticsearch API calls to stdout (for diag only).
+
+        :default: false
+        '''
+        result = self._values.get("trace_output")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def type(self) -> typing.Optional[builtins.str]:
+        '''Type name.
+
+        :default: '_doc'
+        '''
+        result = self._values.get("type")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def workers(self) -> typing.Optional[jsii.Number]:
+        '''Enables dedicated thread(s) for this output.
+
+        :default: 2
+        '''
+        result = self._values.get("workers")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def write_operation(self) -> typing.Optional[builtins.str]:
+        '''Operation to use to write in bulk requests.
+
+        :default: 'create'
+        '''
+        result = self._values.get("write_operation")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "WorkflowActionOptions(%s)" % ", ".join(
+        return "FluentBitElasticsearchOutputOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(ITriggerAction)
-class WorkflowCrawlerAction(
-    WorkflowActionBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowCrawlerAction",
-):
-    '''Configuration options for the WorkflowCrawlerAction class.'''
-
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitJsonParserOptions",
+    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
+    name_mapping={"time_format": "timeFormat", "time_key": "timeKey"},
+)
+class FluentBitJsonParserOptions(FluentBitParserPluginCommonOptions):
     def __init__(
         self,
-        crawler: ICrawler,
         *,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the WorkflowCrawlerAction class.
+        '''Options for configuring the JSON Fluent Bit parser plugin.
 
-        :param crawler: The crawler that should be triggered as part of the workflow.
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+
+        :see: `JSON Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/json>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ad3c134eb8a9a38db762359e9966bbb7beb44688976d988804ba557fa266ff4b)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        options = WorkflowCrawlerActionOptions(
-            arguments=arguments,
-            notify_delay_after=notify_delay_after,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        jsii.create(self.__class__, self, [crawler, options])
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
-        '''Associates this action with a resource that is configuring a Glue trigger.
-
-        :param scope: The construct configuring the trigger that this action will be used in.
+            type_hints = typing.get_type_hints(_typecheckingstub__676b11880e42853f892c52495c93ae1bf187c9bb63de443fc1705142de091362)
+            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if time_format is not None:
+            self._values["time_format"] = time_format
+        if time_key is not None:
+            self._values["time_key"] = time_key
 
-        :return:
+    @builtins.property
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
 
-        The configuration that can be used to configure the underlying
-        trigger resource.
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9bd574ee7e851b6cdc8e7da335779c92cb91aac7d1685e0748769e6e4e944682)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
+        result = self._values.get("time_format")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="crawler")
-    def crawler(self) -> ICrawler:
-        '''The Glue crawler to be triggered as part of the workflow.
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(ICrawler, jsii.get(self, "crawler"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "FluentBitJsonParserOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowCrawlerActionOptions",
-    jsii_struct_bases=[WorkflowActionOptions],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisFirehoseOutputOptions",
+    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
     name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
+        "match": "match",
+        "auto_retry_requests": "autoRetryRequests",
+        "compression": "compression",
+        "delivery_stream": "deliveryStream",
+        "endpoint": "endpoint",
+        "log_key": "logKey",
         "region": "region",
-        "arguments": "arguments",
-        "notify_delay_after": "notifyDelayAfter",
-        "security_configuration": "securityConfiguration",
-        "timeout": "timeout",
+        "role": "role",
+        "sts_endpoint": "stsEndpoint",
+        "time_key": "timeKey",
+        "time_key_format": "timeKeyFormat",
     },
 )
-class WorkflowCrawlerActionOptions(WorkflowActionOptions):
+class FluentBitKinesisFirehoseOutputOptions(FluentBitOutputPluginCommonOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
+        delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    ) -> None:
-        '''Configuration options for the WorkflowCrawlerAction class.
-
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2234879c337e543d2848372b9e2ea82f341e9425395819d4c59814e46dfb3233)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for configuring the Kinesis Firehose Fluent Bit output plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param compression: Compression type for Firehose records. Each log record is individually compressed and sent to Firehose.
+        :param delivery_stream: The Kinesis Firehose Delivery stream that you want log records sent to.
+        :param endpoint: Specify a custom endpoint for the Firehose API.
+        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+        :param time_key: Add the timestamp to the record under this key.
+        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+
+        :see: `Kinesis Firehose Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/firehose>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__83b0e4d7b9e83a0ce016f523fc9afe715ef0070f7415a4f5d350b20f68c2e63d)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
+            check_type(argname="argument compression", value=compression, expected_type=type_hints["compression"])
+            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
+            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
+            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
-            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
-            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
-            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
+        if match is not None:
+            self._values["match"] = match
+        if auto_retry_requests is not None:
+            self._values["auto_retry_requests"] = auto_retry_requests
+        if compression is not None:
+            self._values["compression"] = compression
+        if delivery_stream is not None:
+            self._values["delivery_stream"] = delivery_stream
+        if endpoint is not None:
+            self._values["endpoint"] = endpoint
+        if log_key is not None:
+            self._values["log_key"] = log_key
         if region is not None:
             self._values["region"] = region
-        if arguments is not None:
-            self._values["arguments"] = arguments
-        if notify_delay_after is not None:
-            self._values["notify_delay_after"] = notify_delay_after
-        if security_configuration is not None:
-            self._values["security_configuration"] = security_configuration
-        if timeout is not None:
-            self._values["timeout"] = timeout
+        if role is not None:
+            self._values["role"] = role
+        if sts_endpoint is not None:
+            self._values["sts_endpoint"] = sts_endpoint
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if time_key_format is not None:
+            self._values["time_key_format"] = time_key_format
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
+
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
+
+        :default: true
+        '''
+        result = self._values.get("auto_retry_requests")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    def compression(self) -> typing.Optional[KinesisFirehoseCompressionFormat]:
+        '''Compression type for Firehose records.
 
-        :default: - the resource is in the same account as the stack it belongs to
+        Each log record is individually
+        compressed and sent to Firehose.
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("compression")
+        return typing.cast(typing.Optional[KinesisFirehoseCompressionFormat], result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    def delivery_stream(self) -> typing.Optional[_IDeliveryStream_cf5feed7]:
+        '''The Kinesis Firehose Delivery stream that you want log records sent to.'''
+        result = self._values.get("delivery_stream")
+        return typing.cast(typing.Optional[_IDeliveryStream_cf5feed7], result)
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+    @builtins.property
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the Firehose API.'''
+        result = self._values.get("endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    @builtins.property
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to Firehose.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to Firehose.
         '''
-        result = self._values.get("environment_from_arn")
+        result = self._values.get("log_key")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.'''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+    @builtins.property
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).'''
+        result = self._values.get("role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
-        '''
-        result = self._values.get("physical_name")
+    @builtins.property
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.'''
+        result = self._values.get("sts_endpoint")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''Add the timestamp to the record under this key.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: - the resource is in the same region as the stack it belongs to
+    @builtins.property
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''A strftime compliant format string for the timestamp.
+
+        :default: '%Y-%m-%dT%H:%M:%S'
         '''
-        result = self._values.get("region")
+        result = self._values.get("time_key_format")
         return typing.cast(typing.Optional[builtins.str], result)
 
-    @builtins.property
-    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''The arguments to use when the associated trigger fires.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        Jobs run via the associated trigger will have their default arguments
-        replaced with the arguments specified.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        You can specify arguments here that your own job-execution script
-        consumes, in addition to arguments that AWS Glue itself consumes.
+    def __repr__(self) -> str:
+        return "FluentBitKinesisFirehoseOutputOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisOutputOptions",
+    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    name_mapping={
+        "match": "match",
+        "auto_retry_requests": "autoRetryRequests",
+        "endpoint": "endpoint",
+        "log_key": "logKey",
+        "region": "region",
+        "role": "role",
+        "stream": "stream",
+        "sts_endpoint": "stsEndpoint",
+        "time_key": "timeKey",
+        "time_key_format": "timeKeyFormat",
+    },
+)
+class FluentBitKinesisOutputOptions(FluentBitOutputPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for configuring the Kinesis Data Streams Fluent Bit output plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param endpoint: Specify a custom endpoint for the Firehose API.
+        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param stream: The name of the Kinesis Streams Delivery stream that you want log records sent to.
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+        :param time_key: Add the timestamp to the record under this key.
+        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+
+        :see: `Kinesis Streams Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/kinesis>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b3351322b2cfd158f546c053b64876ee28f0c4c8db9d39839fa35435992b5a02)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
+            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
+            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+            check_type(argname="argument stream", value=stream, expected_type=type_hints["stream"])
+            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if match is not None:
+            self._values["match"] = match
+        if auto_retry_requests is not None:
+            self._values["auto_retry_requests"] = auto_retry_requests
+        if endpoint is not None:
+            self._values["endpoint"] = endpoint
+        if log_key is not None:
+            self._values["log_key"] = log_key
+        if region is not None:
+            self._values["region"] = region
+        if role is not None:
+            self._values["role"] = role
+        if stream is not None:
+            self._values["stream"] = stream
+        if sts_endpoint is not None:
+            self._values["sts_endpoint"] = sts_endpoint
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if time_key_format is not None:
+            self._values["time_key_format"] = time_key_format
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
+
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
 
-        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
+        :default: true
         '''
-        result = self._values.get("arguments")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+        result = self._values.get("auto_retry_requests")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the Firehose API.'''
+        result = self._values.get("endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to Firehose.
 
-        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to Firehose.
         '''
-        result = self._values.get("notify_delay_after")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("log_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def security_configuration(self) -> typing.Optional[builtins.str]:
-        '''The name of the SecurityConfiguration structure to be used with this action.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.'''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
-        :alpha: true
-        '''
-        result = self._values.get("security_configuration")
+    @builtins.property
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).'''
+        result = self._values.get("role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+
+    @builtins.property
+    def stream(self) -> typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream]:
+        '''The name of the Kinesis Streams Delivery stream that you want log records sent to.'''
+        result = self._values.get("stream")
+        return typing.cast(typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream], result)
+
+    @builtins.property
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.'''
+        result = self._values.get("sts_endpoint")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The ``JobRun`` timeout in minutes.
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''Add the timestamp to the record under this key.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        This is the maximum time that a job run
-        can consume resources before it is terminated and enters TIMEOUT status.
-        The default is 48 hours. This overrides the timeout value set in the
-        parent job.
+    @builtins.property
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''A strftime compliant format string for the timestamp.
 
-        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+        :default: '%Y-%m-%dT%H:%M:%S'
         '''
-        result = self._values.get("timeout")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("time_key_format")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "WorkflowCrawlerActionOptions(%s)" % ", ".join(
+        return "FluentBitKinesisOutputOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(ITriggerAction)
-class WorkflowJobAction(
-    WorkflowActionBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowJobAction",
-):
-    '''Represents the configuration for a job that will be triggered as part of a workflow.'''
-
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLogfmtParserOptions",
+    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
+    name_mapping={
+        "time_format": "timeFormat",
+        "time_key": "timeKey",
+        "types": "types",
+    },
+)
+class FluentBitLogfmtParserOptions(FluentBitParserPluginCommonOptions):
     def __init__(
         self,
-        job: IJob,
         *,
-        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
     ) -> None:
-        '''Creates a new instance of the WorkflowJobAction class.
+        '''Options for configuring the logfmt Fluent Bit parser plugin.
 
-        :param job: The job that should be triggered as part of the workflow.
-        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+
+        :see: `Logfmt Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/logfmt>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4b35e7b4cd1b6215af9417101fd148d7cff1bdbaa7e82f113dafee00863f0e8b)
-            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
-        options = WorkflowJobActionOptions(
-            bookmark_configuration=bookmark_configuration,
-            arguments=arguments,
-            notify_delay_after=notify_delay_after,
-            security_configuration=security_configuration,
-            timeout=timeout,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__f56caf857f07fc4fcf3a9d82849abe1b6d988d15131ee141433d839c247afbab)
+            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if time_format is not None:
+            self._values["time_format"] = time_format
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if types is not None:
+            self._values["types"] = types
 
-        jsii.create(self.__class__, self, [job, options])
+    @builtins.property
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        '''
+        result = self._values.get("time_format")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def types(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty:
-        '''Associates this action with a resource that is configuring a Glue trigger.
+    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
+        result = self._values.get("types")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], result)
 
-        :param scope: The construct configuring the trigger that this action will be used in.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :return:
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        The configuration that can be used to configure the underlying
-        trigger resource.
+    def __repr__(self) -> str:
+        return "FluentBitLogfmtParserOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLtsvParserOptions",
+    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
+    name_mapping={
+        "time_format": "timeFormat",
+        "time_key": "timeKey",
+        "types": "types",
+    },
+)
+class FluentBitLtsvParserOptions(FluentBitParserPluginCommonOptions):
+    def __init__(
+        self,
+        *,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    ) -> None:
+        '''Options for configuring the LTSV Fluent Bit parser plugin.
+
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+
+        :see: `LTSV Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/ltsv>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a7515c04a94a863fad2bee1122daa43d9a40018fd2904b2aa74a621938706702)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ActionProperty, jsii.invoke(self, "bind", [scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__8359d0e12857464b85b7f043fe21b4c1b8581d20c4a022da8a6c0e79ee1c3386)
+            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if time_format is not None:
+            self._values["time_format"] = time_format
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if types is not None:
+            self._values["types"] = types
 
     @builtins.property
-    @jsii.member(jsii_name="job")
-    def job(self) -> IJob:
-        '''The Glue job to be triggered as part of the workflow.
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
 
-        :group: Inputs
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        return typing.cast(IJob, jsii.get(self, "job"))
+        result = self._values.get("time_format")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.'''
+        result = self._values.get("time_key")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def types(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
+        result = self._values.get("types")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "FluentBitLtsvParserOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowJobActionOptions",
-    jsii_struct_bases=[WorkflowActionOptions],
+    jsii_type="cdk-extensions.k8s_aws.FluentBitOpenSearchOutputOptions",
+    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
     name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "arguments": "arguments",
-        "notify_delay_after": "notifyDelayAfter",
-        "security_configuration": "securityConfiguration",
-        "timeout": "timeout",
-        "bookmark_configuration": "bookmarkConfiguration",
+        "match": "match",
+        "domain": "domain",
+        "aws_auth": "awsAuth",
+        "aws_external_id": "awsExternalId",
+        "aws_region": "awsRegion",
+        "aws_role": "awsRole",
+        "aws_sts_endpoint": "awsStsEndpoint",
+        "buffer_size": "bufferSize",
+        "current_time_index": "currentTimeIndex",
+        "generate_id": "generateId",
+        "host": "host",
+        "http_passwd": "httpPasswd",
+        "http_user": "httpUser",
+        "id_key": "idKey",
+        "include_tag_key": "includeTagKey",
+        "index": "index",
+        "logstash_date_format": "logstashDateFormat",
+        "logstash_format": "logstashFormat",
+        "logstash_prefix": "logstashPrefix",
+        "logstash_prefix_key": "logstashPrefixKey",
+        "path": "path",
+        "pipeline": "pipeline",
+        "port": "port",
+        "replace_dots": "replaceDots",
+        "suppress_type_name": "suppressTypeName",
+        "tag_key": "tagKey",
+        "time_key": "timeKey",
+        "time_key_format": "timeKeyFormat",
+        "time_key_nanos": "timeKeyNanos",
+        "trace_error": "traceError",
+        "trace_output": "traceOutput",
+        "type": "type",
+        "workers": "workers",
+        "write_operation": "writeOperation",
     },
 )
-class WorkflowJobActionOptions(WorkflowActionOptions):
+class FluentBitOpenSearchOutputOptions(FluentBitOutputPluginCommonOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-        notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        security_configuration: typing.Optional[builtins.str] = None,
-        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
-    ) -> None:
-        '''Configuration options for the WorkflowJobAction class.
+        match: typing.Optional[FluentBitMatch] = None,
+        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
+        aws_auth: typing.Optional[builtins.bool] = None,
+        aws_external_id: typing.Optional[builtins.str] = None,
+        aws_region: typing.Optional[builtins.str] = None,
+        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        aws_sts_endpoint: typing.Optional[builtins.str] = None,
+        buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
+        current_time_index: typing.Optional[builtins.bool] = None,
+        generate_id: typing.Optional[builtins.bool] = None,
+        host: typing.Optional[builtins.str] = None,
+        http_passwd: typing.Optional[builtins.str] = None,
+        http_user: typing.Optional[builtins.str] = None,
+        id_key: typing.Optional[builtins.str] = None,
+        include_tag_key: typing.Optional[builtins.bool] = None,
+        index: typing.Optional[builtins.str] = None,
+        logstash_date_format: typing.Optional[builtins.str] = None,
+        logstash_format: typing.Optional[builtins.bool] = None,
+        logstash_prefix: typing.Optional[builtins.str] = None,
+        logstash_prefix_key: typing.Optional[builtins.str] = None,
+        path: typing.Optional[builtins.str] = None,
+        pipeline: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replace_dots: typing.Optional[builtins.bool] = None,
+        suppress_type_name: typing.Optional[builtins.bool] = None,
+        tag_key: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        time_key_nanos: typing.Optional[builtins.bool] = None,
+        trace_error: typing.Optional[builtins.bool] = None,
+        trace_output: typing.Optional[builtins.bool] = None,
+        type: typing.Optional[builtins.str] = None,
+        workers: typing.Optional[jsii.Number] = None,
+        write_operation: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Options for configuring the OpenSearch Fluent Bit output plugin.
+
+        :param match: The pattern to match for records that this output should apply to.
+        :param domain: The Opensearch domain to which logs should be shipped.
+        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon OpenSearch Service. Default: false
+        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
+        :param aws_region: Specify the AWS region for Amazon OpenSearch Service.
+        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
+        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
+        :param buffer_size: Specify the buffer size used to read the response from the OpenSearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
+        :param current_time_index: Use current time for index generation instead of message record. Default: false
+        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
+        :param host: IP address or hostname of the target OpenSearch instance.
+        :param http_passwd: Password for user defined in ``httpUser``.
+        :param http_user: Optional username credential for access.
+        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+        :param include_tag_key: When enabled, it append the Tag name to the record.
+        :param index: Index name. Default: 'fluent-bit
+        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
+        :param logstash_format: Enable Logstash format compatibility. Default: false
+        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
+        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
+        :param path: OpenSearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve OpenSearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
+        :param pipeline: OpenSearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
+        :param port: TCP port of the target OpenSearch instance. Default: 9200
+        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
+        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
+        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
+        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
+        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
+        :param trace_error: When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only). Default: false
+        :param trace_output: When enabled print the OpenSearch API calls to stdout (for diag only). Default: false
+        :param type: Type name. Default: '_doc'
+        :param workers: Enables dedicated thread(s) for this output. Default: 2
+        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
+
+        :see: `OpenSearch Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/opensearch>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5d8425bcc923d11b65d58b1eaf5873e22f32f3ab919ad7e37262fc57ab0df995)
+            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
+            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
+            check_type(argname="argument aws_auth", value=aws_auth, expected_type=type_hints["aws_auth"])
+            check_type(argname="argument aws_external_id", value=aws_external_id, expected_type=type_hints["aws_external_id"])
+            check_type(argname="argument aws_region", value=aws_region, expected_type=type_hints["aws_region"])
+            check_type(argname="argument aws_role", value=aws_role, expected_type=type_hints["aws_role"])
+            check_type(argname="argument aws_sts_endpoint", value=aws_sts_endpoint, expected_type=type_hints["aws_sts_endpoint"])
+            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
+            check_type(argname="argument current_time_index", value=current_time_index, expected_type=type_hints["current_time_index"])
+            check_type(argname="argument generate_id", value=generate_id, expected_type=type_hints["generate_id"])
+            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
+            check_type(argname="argument http_passwd", value=http_passwd, expected_type=type_hints["http_passwd"])
+            check_type(argname="argument http_user", value=http_user, expected_type=type_hints["http_user"])
+            check_type(argname="argument id_key", value=id_key, expected_type=type_hints["id_key"])
+            check_type(argname="argument include_tag_key", value=include_tag_key, expected_type=type_hints["include_tag_key"])
+            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
+            check_type(argname="argument logstash_date_format", value=logstash_date_format, expected_type=type_hints["logstash_date_format"])
+            check_type(argname="argument logstash_format", value=logstash_format, expected_type=type_hints["logstash_format"])
+            check_type(argname="argument logstash_prefix", value=logstash_prefix, expected_type=type_hints["logstash_prefix"])
+            check_type(argname="argument logstash_prefix_key", value=logstash_prefix_key, expected_type=type_hints["logstash_prefix_key"])
+            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
+            check_type(argname="argument pipeline", value=pipeline, expected_type=type_hints["pipeline"])
+            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
+            check_type(argname="argument replace_dots", value=replace_dots, expected_type=type_hints["replace_dots"])
+            check_type(argname="argument suppress_type_name", value=suppress_type_name, expected_type=type_hints["suppress_type_name"])
+            check_type(argname="argument tag_key", value=tag_key, expected_type=type_hints["tag_key"])
+            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
+            check_type(argname="argument time_key_nanos", value=time_key_nanos, expected_type=type_hints["time_key_nanos"])
+            check_type(argname="argument trace_error", value=trace_error, expected_type=type_hints["trace_error"])
+            check_type(argname="argument trace_output", value=trace_output, expected_type=type_hints["trace_output"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+            check_type(argname="argument workers", value=workers, expected_type=type_hints["workers"])
+            check_type(argname="argument write_operation", value=write_operation, expected_type=type_hints["write_operation"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "domain": domain,
+        }
+        if match is not None:
+            self._values["match"] = match
+        if aws_auth is not None:
+            self._values["aws_auth"] = aws_auth
+        if aws_external_id is not None:
+            self._values["aws_external_id"] = aws_external_id
+        if aws_region is not None:
+            self._values["aws_region"] = aws_region
+        if aws_role is not None:
+            self._values["aws_role"] = aws_role
+        if aws_sts_endpoint is not None:
+            self._values["aws_sts_endpoint"] = aws_sts_endpoint
+        if buffer_size is not None:
+            self._values["buffer_size"] = buffer_size
+        if current_time_index is not None:
+            self._values["current_time_index"] = current_time_index
+        if generate_id is not None:
+            self._values["generate_id"] = generate_id
+        if host is not None:
+            self._values["host"] = host
+        if http_passwd is not None:
+            self._values["http_passwd"] = http_passwd
+        if http_user is not None:
+            self._values["http_user"] = http_user
+        if id_key is not None:
+            self._values["id_key"] = id_key
+        if include_tag_key is not None:
+            self._values["include_tag_key"] = include_tag_key
+        if index is not None:
+            self._values["index"] = index
+        if logstash_date_format is not None:
+            self._values["logstash_date_format"] = logstash_date_format
+        if logstash_format is not None:
+            self._values["logstash_format"] = logstash_format
+        if logstash_prefix is not None:
+            self._values["logstash_prefix"] = logstash_prefix
+        if logstash_prefix_key is not None:
+            self._values["logstash_prefix_key"] = logstash_prefix_key
+        if path is not None:
+            self._values["path"] = path
+        if pipeline is not None:
+            self._values["pipeline"] = pipeline
+        if port is not None:
+            self._values["port"] = port
+        if replace_dots is not None:
+            self._values["replace_dots"] = replace_dots
+        if suppress_type_name is not None:
+            self._values["suppress_type_name"] = suppress_type_name
+        if tag_key is not None:
+            self._values["tag_key"] = tag_key
+        if time_key is not None:
+            self._values["time_key"] = time_key
+        if time_key_format is not None:
+            self._values["time_key_format"] = time_key_format
+        if time_key_nanos is not None:
+            self._values["time_key_nanos"] = time_key_nanos
+        if trace_error is not None:
+            self._values["trace_error"] = trace_error
+        if trace_output is not None:
+            self._values["trace_output"] = trace_output
+        if type is not None:
+            self._values["type"] = type
+        if workers is not None:
+            self._values["workers"] = workers
+        if write_operation is not None:
+            self._values["write_operation"] = write_operation
+
+    @builtins.property
+    def match(self) -> typing.Optional[FluentBitMatch]:
+        '''The pattern to match for records that this output should apply to.'''
+        result = self._values.get("match")
+        return typing.cast(typing.Optional[FluentBitMatch], result)
+
+    @builtins.property
+    def domain(self) -> _aws_cdk_aws_opensearchservice_ceddda9d.IDomain:
+        '''The Opensearch domain to which logs should be shipped.'''
+        result = self._values.get("domain")
+        assert result is not None, "Required property 'domain' is missing"
+        return typing.cast(_aws_cdk_aws_opensearchservice_ceddda9d.IDomain, result)
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param arguments: The arguments to use when the associated trigger fires. Jobs run via the associated trigger will have their default arguments replaced with the arguments specified. You can specify arguments here that your own job-execution script consumes, in addition to arguments that AWS Glue itself consumes.
-        :param notify_delay_after: After a job run starts, the number of minutes to wait before sending a job run delay notification.
-        :param security_configuration: The name of the SecurityConfiguration structure to be used with this action.
-        :param timeout: The ``JobRun`` timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters TIMEOUT status. The default is 48 hours. This overrides the timeout value set in the parent job.
-        :param bookmark_configuration: The bookmark configuration override to use for the Glue job that is being triggered.
+    @builtins.property
+    def aws_auth(self) -> typing.Optional[builtins.bool]:
+        '''Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
+
+        :default: false
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bf2bd2d4a47064faaa01d005f9c67d6010a4760a0856334853b9d2c9c03d73b3)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument arguments", value=arguments, expected_type=type_hints["arguments"])
-            check_type(argname="argument notify_delay_after", value=notify_delay_after, expected_type=type_hints["notify_delay_after"])
-            check_type(argname="argument security_configuration", value=security_configuration, expected_type=type_hints["security_configuration"])
-            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
-            check_type(argname="argument bookmark_configuration", value=bookmark_configuration, expected_type=type_hints["bookmark_configuration"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if arguments is not None:
-            self._values["arguments"] = arguments
-        if notify_delay_after is not None:
-            self._values["notify_delay_after"] = notify_delay_after
-        if security_configuration is not None:
-            self._values["security_configuration"] = security_configuration
-        if timeout is not None:
-            self._values["timeout"] = timeout
-        if bookmark_configuration is not None:
-            self._values["bookmark_configuration"] = bookmark_configuration
+        result = self._values.get("aws_auth")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    def aws_external_id(self) -> typing.Optional[builtins.str]:
+        '''External ID for the AWS IAM Role specified with ``awsRole``.'''
+        result = self._values.get("aws_external_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: - the resource is in the same account as the stack it belongs to
+    @builtins.property
+    def aws_region(self) -> typing.Optional[builtins.str]:
+        '''Specify the AWS region for Amazon OpenSearch Service.'''
+        result = self._values.get("aws_region")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''AWS IAM Role to assume to put records to your Amazon cluster.'''
+        result = self._values.get("aws_role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+
+    @builtins.property
+    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.'''
+        result = self._values.get("aws_sts_endpoint")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def buffer_size(self) -> typing.Optional[OpenSearchOutputBufferSize]:
+        '''Specify the buffer size used to read the response from the OpenSearch HTTP service.
+
+        This option is useful for debugging purposes where is
+        required to read full responses, note that response size grows depending
+        of the number of records inserted.
         '''
-        result = self._values.get("account")
+        result = self._values.get("buffer_size")
+        return typing.cast(typing.Optional[OpenSearchOutputBufferSize], result)
+
+    @builtins.property
+    def current_time_index(self) -> typing.Optional[builtins.bool]:
+        '''Use current time for index generation instead of message record.
+
+        :default: false
+        '''
+        result = self._values.get("current_time_index")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def generate_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, generate ``_id`` for outgoing records.
+
+        This prevents duplicate
+        records when retrying.
+        '''
+        result = self._values.get("generate_id")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def host(self) -> typing.Optional[builtins.str]:
+        '''IP address or hostname of the target OpenSearch instance.'''
+        result = self._values.get("host")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    def http_passwd(self) -> typing.Optional[builtins.str]:
+        '''Password for user defined in ``httpUser``.'''
+        result = self._values.get("http_passwd")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+    @builtins.property
+    def http_user(self) -> typing.Optional[builtins.str]:
+        '''Optional username credential for access.'''
+        result = self._values.get("http_user")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    @builtins.property
+    def id_key(self) -> typing.Optional[builtins.str]:
+        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.'''
+        result = self._values.get("id_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+    @builtins.property
+    def include_tag_key(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it append the Tag name to the record.'''
+        result = self._values.get("include_tag_key")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def index(self) -> typing.Optional[builtins.str]:
+        '''Index name.
+
+        :default: 'fluent-bit
         '''
-        result = self._values.get("environment_from_arn")
+        result = self._values.get("index")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    def logstash_date_format(self) -> typing.Optional[builtins.str]:
+        '''Time format (based on strftime) to generate the second part of the Index name.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        :default: '%Y.%m.%d'
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        result = self._values.get("physical_name")
+        result = self._values.get("logstash_date_format")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def logstash_format(self) -> typing.Optional[builtins.bool]:
+        '''Enable Logstash format compatibility.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :default: false
         '''
-        result = self._values.get("region")
+        result = self._values.get("logstash_format")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def logstash_prefix(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+
+        The last string appended belongs to the date when the data is being
+        generated.
+
+        :default: 'logstash'
+        '''
+        result = self._values.get("logstash_prefix")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def arguments(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
-        '''The arguments to use when the associated trigger fires.
+    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
+        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
 
-        Jobs run via the associated trigger will have their default arguments
-        replaced with the arguments specified.
+        If
+        the key/value is not found in the record then the ``logstashPrefix`` option
+        will act as a fallback.
 
-        You can specify arguments here that your own job-execution script
-        consumes, in addition to arguments that AWS Glue itself consumes.
+        Nested keys are not supported (if desired, you can use the nest filter
+        plugin to remove nesting)
+        '''
+        result = self._values.get("logstash_prefix_key")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def path(self) -> typing.Optional[builtins.str]:
+        '''OpenSearch accepts new data on HTTP query path "/_bulk".
 
-        :see: `Trigger Actions.Arguments <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-arguments>`_
+        But it is also
+        possible to serve OpenSearch behind a reverse proxy on a subpath. This
+        option defines such path on the fluent-bit side. It simply adds a path
+        prefix in the indexing HTTP POST URI..
         '''
-        result = self._values.get("arguments")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
+        result = self._values.get("path")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def notify_delay_after(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''After a job run starts, the number of minutes to wait before sending a job run delay notification.
+    def pipeline(self) -> typing.Optional[builtins.str]:
+        '''OpenSearch allows to setup filters called pipelines.
 
-        :see: `Trigger Actions.NotificationProperty.NotifyDelayAfter <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-notificationproperty.html#cfn-glue-trigger-notificationproperty-notifydelayafter>`_
+        This option allows
+        to define which pipeline the database should use.
         '''
-        result = self._values.get("notify_delay_after")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("pipeline")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def port(self) -> typing.Optional[jsii.Number]:
+        '''TCP port of the target OpenSearch instance.
+
+        :default: 9200
+        '''
+        result = self._values.get("port")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def replace_dots(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, replace field name dots with underscore.
+
+        :default: false
+        '''
+        result = self._values.get("replace_dots")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, mapping types is removed and ``type`` option is ignored.
+
+        :default: false
+        '''
+        result = self._values.get("suppress_type_name")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def tag_key(self) -> typing.Optional[builtins.str]:
+        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+
+        :default: '_flb-key'
+        '''
+        result = self._values.get("tag_key")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def security_configuration(self) -> typing.Optional[builtins.str]:
-        '''The name of the SecurityConfiguration structure to be used with this action.
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+
+        The``timeKey`` property defines the name of that field.
+
+        :default: '
 
-        :see: `Trigger Actions.SecurityConfiguration <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-securityconfiguration>`_
-        :alpha: true
+        :timestamp: '
         '''
-        result = self._values.get("security_configuration")
+        result = self._values.get("time_key")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The ``JobRun`` timeout in minutes.
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
 
-        This is the maximum time that a job run
-        can consume resources before it is terminated and enters TIMEOUT status.
-        The default is 48 hours. This overrides the timeout value set in the
-        parent job.
+        :default: '%Y-%m-%dT%H:%M:%S'
 
-        :see: `Trigger Actions.Timeout <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-action.html#cfn-glue-trigger-action-timeout>`_
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
         '''
-        result = self._values.get("timeout")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+        result = self._values.get("time_key_format")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
+        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+
+        :default: false
+        '''
+        result = self._values.get("time_key_nanos")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def trace_error(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only).
+
+        :default: false
+        '''
+        result = self._values.get("trace_error")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def bookmark_configuration(self) -> typing.Optional[BookmarkConfiguration]:
-        '''The bookmark configuration override to use for the Glue job that is being triggered.'''
-        result = self._values.get("bookmark_configuration")
-        return typing.cast(typing.Optional[BookmarkConfiguration], result)
+    def trace_output(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the OpenSearch API calls to stdout (for diag only).
+
+        :default: false
+        '''
+        result = self._values.get("trace_output")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    @builtins.property
+    def type(self) -> typing.Optional[builtins.str]:
+        '''Type name.
+
+        :default: '_doc'
+        '''
+        result = self._values.get("type")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def workers(self) -> typing.Optional[jsii.Number]:
+        '''Enables dedicated thread(s) for this output.
+
+        :default: 2
+        '''
+        result = self._values.get("workers")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def write_operation(self) -> typing.Optional[builtins.str]:
+        '''Operation to use to write in bulk requests.
+
+        :default: 'create'
+        '''
+        result = self._values.get("write_operation")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "WorkflowJobActionOptions(%s)" % ", ".join(
+        return "FluentBitOpenSearchOutputOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class WorkflowPredicate(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowPredicate",
+@jsii.implements(IFluentBitPlugin)
+class FluentBitPlugin(
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitPlugin",
 ):
-    '''Predicate conditions for controlling trigger activation in a Glue workflow.'''
+    '''A Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+    def __init__(self, *, name: builtins.str, plugin_type: FluentBitPluginType) -> None:
+        '''Creates a new instance of the FluentBitPlugin class.
 
-    @jsii.member(jsii_name="crawler")
-    @builtins.classmethod
-    def crawler(
-        cls,
-        crawler: ICrawler,
-        *,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[CrawlerState] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> "WorkflowCrawlerPredicate":
-        '''A predicate condition dependent on the completion of a Glue crawler.
+        :param name: The name of the fluent bit plugin.
+        :param plugin_type: Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        '''
+        options = FluentBitPluginCommonOptions(name=name, plugin_type=plugin_type)
 
-        :param crawler: The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
-        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    @abc.abstractmethod
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param scope: The construct configuring logging using Fluent Bit.
 
         :return:
 
-        A workflow condition that is predicated on the completion of the
-        specified Glue crawler.
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        ...
+
+    @jsii.member(jsii_name="renderConfigFile")
+    def _render_config_file(
+        self,
+        config: typing.Mapping[builtins.str, typing.Any],
+    ) -> builtins.str:
+        '''
+        :param config: The configuration properties to render into a Fluent Bit configuration file.
+
+        :return: A fluent bit config file representation of the passed properties.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ffa264c859c1bcdd41fda254d289bc185e36ff404ad7901a6b7d63d92cddf8ee)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        options = WorkflowCrawlerPredicateOptions(
-            logical_operator=logical_operator,
-            state=state,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+            type_hints = typing.get_type_hints(_typecheckingstub__6444197d7722391a58b5da239897ee3a742da209a160dd73058c6c54dc737cf7)
+            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
+        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
 
-        return typing.cast("WorkflowCrawlerPredicate", jsii.sinvoke(cls, "crawler", [crawler, options]))
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the fluent bit plugin.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
-    @jsii.member(jsii_name="job")
-    @builtins.classmethod
-    def job(
-        cls,
-        job: IJob,
+    @builtins.property
+    @jsii.member(jsii_name="pluginType")
+    def plugin_type(self) -> builtins.str:
+        '''The type of fluent bit plugin.'''
+        return typing.cast(builtins.str, jsii.get(self, "pluginType"))
+
+
+class _FluentBitPluginProxy(FluentBitPlugin):
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__acc47748e8c44554d5768c7501d9e6c9274e616d8bb24e8c9c64ec6e7ca82c4e)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, FluentBitPlugin).__jsii_proxy_class__ = lambda : _FluentBitPluginProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitFilterPlugin")
+class IFluentBitFilterPlugin(IFluentBitPlugin, typing_extensions.Protocol):
+    '''Represents a Fluent Bit plugin that controls log filtering and metadata.'''
+
+    pass
+
+
+class _IFluentBitFilterPluginProxy(
+    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
+):
+    '''Represents a Fluent Bit plugin that controls log filtering and metadata.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitFilterPlugin"
+    pass
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IFluentBitFilterPlugin).__jsii_proxy_class__ = lambda : _IFluentBitFilterPluginProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitOutputPlugin")
+class IFluentBitOutputPlugin(IFluentBitPlugin, typing_extensions.Protocol):
+    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
+
+    pass
+
+
+class _IFluentBitOutputPluginProxy(
+    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
+):
+    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitOutputPlugin"
+    pass
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IFluentBitOutputPlugin).__jsii_proxy_class__ = lambda : _IFluentBitOutputPluginProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitParserPlugin")
+class IFluentBitParserPlugin(IFluentBitPlugin, typing_extensions.Protocol):
+    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+
+    @builtins.property
+    @jsii.member(jsii_name="format")
+    def format(self) -> builtins.str:
+        ...
+
+
+class _IFluentBitParserPluginProxy(
+    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
+):
+    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitParserPlugin"
+
+    @builtins.property
+    @jsii.member(jsii_name="format")
+    def format(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "format"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IFluentBitParserPlugin).__jsii_proxy_class__ = lambda : _IFluentBitParserPluginProxy
+
+
+class SecretsManagerSecretStore(
+    AwsSecretStore,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStore",
+):
+    '''A secret store that allows secrets from AWS Secrets Managers to be synchronized into Kubernetes as Kubernetes secrets.'''
+
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[JobState] = None,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-    ) -> "WorkflowJobPredicate":
-        '''A predicate condition dependent on the completion of a Glue job.
+    ) -> None:
+        '''Creates a new instance of the SecretsManagerSecretStore class.
 
-        :param job: The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
-        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-
-        :return:
-
-        A workflow condition that is predicated on the completion of the
-        specified Glue crawler.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ca6546c9bc55323e0c4cb2c970aba51c478d9a3067002ee323e9093850759207)
-            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
-        options = WorkflowJobPredicateOptions(
-            logical_operator=logical_operator,
-            state=state,
+            type_hints = typing.get_type_hints(_typecheckingstub__d0c3c962388492a04b5601f56b47b4dfbb0110dbd51c733afa1a9bed17ae16f9)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = SecretsManagerSecretStoreProps(
+            cluster=cluster,
+            name=name,
+            namespace=namespace,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        return typing.cast("WorkflowJobPredicate", jsii.sinvoke(cls, "job", [job, options]))
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="addSecret")
+    def add_secret(
+        self,
+        id: builtins.str,
+        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> ExternalSecret:
+        '''Registers a new Secrets Manager secret to be synchronized into Kubernetes.
+
+        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the Secrets Manager secret it synchronizes and so must be unique per secret.
+        :param secret: The Secrets Manager secret to synchronize into Kubernetes.
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
 
+        :return: The external secret configuration that was added.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6359c3f686f0688d1026d3fd4e13f56fdd12e614640211e1a20c6764506d0bde)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
+        options = ExternalSecretOptions(fields=fields, name=name)
 
-class WorkflowPredicateBase(
+        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, secret, options]))
+
+
+class SsmParameterSecretStore(
+    AwsSecretStore,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowPredicateBase",
+    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStore",
 ):
-    '''Base class providing common functionality for trigger predicate conditions.'''
+    '''A secret store that allows parameters from Systems Manager to be synchronized into Kubernetes as Kubernetes secrets.'''
 
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
+        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        name: typing.Optional[builtins.str] = None,
+        namespace: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Create a new instance of the WorkflowPredicateBase class.
+        '''Creates a new instance of the SsmParameterSecretStore class.
 
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
+        :param cluster: The EKS cluster where the secret store should be created.
+        :param name: A human friendly name for the secret store.
+        :param namespace: The Kubernetes namespace where the secret store should be created.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        _options = WorkflowPredicateOptions(
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8a0341aaa28a58b67be791194cbc62d0dc6cb7590b8b514b48b86ddc4b19c218)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = SsmParameterSecretStoreProps(
+            cluster=cluster,
+            name=name,
+            namespace=namespace,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
-        jsii.create(self.__class__, self, [_options])
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="addSecret")
+    def add_secret(
+        self,
+        id: builtins.str,
+        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
+        *,
+        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+        name: typing.Optional[builtins.str] = None,
+    ) -> ExternalSecret:
+        '''Registers a new SSSM parameter to be synchronized into Kubernetes.
+
+        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the SSM parameter it synchronizes and so must be unique per secret.
+        :param parameter: The SSM parameter to synchronize into Kubernetes.
+        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
+        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+
+        :return: The external secret configuration that was added.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e4726b5ae83a114c6d9a0343261df1f71b3fb8d8712d5e1a0e9dd6ffb85ada79)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
+        options = ExternalSecretOptions(fields=fields, name=name)
 
-    @jsii.member(jsii_name="bindOptions")
-    def _bind_options(self, _scope: _constructs_77d1e7e8.IConstruct) -> typing.Any:
-        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
+        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, parameter, options]))
+
+
+@jsii.implements(IFluentBitFilterPlugin)
+class FluentBitFilterPluginBase(
+    FluentBitPlugin,
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitFilterPluginBase",
+):
+    def __init__(
+        self,
+        name: builtins.str,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitOutputPlugin class.
+
+        :param name: The name of the output plugin to configure.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2b0341b3b1df86ed9b5aab4b4fadcc47fd710ae038076cca755f3c48acef6956)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitFilterPluginCommonOptions(match=match)
 
-        :param _scope: The construct configuring the Glue trigger.
+        jsii.create(self.__class__, self, [name, options])
+
+    @jsii.member(jsii_name="renderConfigFile")
+    def _render_config_file(
+        self,
+        config: typing.Mapping[builtins.str, typing.Any],
+    ) -> builtins.str:
+        '''Renders a Fluent Bit configuration file for the plugin.
+
+        :param config: The configuration options to render into a configuration file.
+
+        :return: A rendered plugin configuration file.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dd92e8237c9a3e0963fb6f8aa69a0ef0b1b6cb8403264e0fdd57816a24a83f04)
+            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
+        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+
+    @builtins.property
+    @jsii.member(jsii_name="match")
+    def match(self) -> FluentBitMatch:
+        '''The pattern to match for records that this output should apply to.
+
+        :group: Inputs
+        '''
+        return typing.cast(FluentBitMatch, jsii.get(self, "match"))
+
+
+class _FluentBitFilterPluginBaseProxy(
+    FluentBitFilterPluginBase,
+    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
+):
+    pass
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, FluentBitFilterPluginBase).__jsii_proxy_class__ = lambda : _FluentBitFilterPluginBaseProxy
+
+
+class FluentBitGrepFilter(
+    FluentBitFilterPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepFilter",
+):
+    '''A Fluent Bit filter that allows log records to be kept or discarded based on whether they match a given regular expression or not.'''
+
+    def __init__(
+        self,
+        *,
+        pattern: typing.Union[FluentBitGrepRegex, typing.Dict[builtins.str, typing.Any]],
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
+
+        :param pattern: The pattern to use for filtering records processed by the plugin.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitGrepFilterOptions(pattern=pattern, match=match)
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
 
         :return:
 
-        A configuration object that can be used to configure a predicate
-        condition for the Glue trigger.
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__532fa291e748d01f44fced9f7933021be1f8ac049d19d07677702e64c2e226cc)
+            type_hints = typing.get_type_hints(_typecheckingstub__5ad4b94abc52cd50668ebd6e0a941de90c4ed68a322b0c4bd1bf8f5d132edd78)
             check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(typing.Any, jsii.invoke(self, "bindOptions", [_scope]))
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
 
+    @builtins.property
+    @jsii.member(jsii_name="pattern")
+    def pattern(self) -> FluentBitGrepRegex:
+        '''The pattern to use for filtering records processed by the plugin.
+
+        :group: Inputs
+        '''
+        return typing.cast(FluentBitGrepRegex, jsii.get(self, "pattern"))
+
+
+class FluentBitKubernetesFilter(
+    FluentBitFilterPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKubernetesFilter",
+):
+    '''A Fluent Bit filter that allows log records to be annotated with Kubernetes metadata based on the containers that generated them.'''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowPredicateOptions",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-    },
-)
-class WorkflowPredicateOptions(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for a generic Glue Trigger predicate.
+        annotations: typing.Optional[builtins.bool] = None,
+        buffer_size: typing.Optional[_DataSize_d20aaece] = None,
+        cache_use_docker_id: typing.Optional[builtins.bool] = None,
+        dns_retries: typing.Optional[jsii.Number] = None,
+        dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        dummy_meta: typing.Optional[builtins.bool] = None,
+        k8s_logging_exclude: typing.Optional[builtins.bool] = None,
+        k8s_logging_parser: typing.Optional[builtins.bool] = None,
+        keep_log: typing.Optional[builtins.bool] = None,
+        kube_ca_file: typing.Optional[builtins.str] = None,
+        kube_ca_path: typing.Optional[builtins.str] = None,
+        kubelet_host: typing.Optional[builtins.str] = None,
+        kubelet_port: typing.Optional[jsii.Number] = None,
+        kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
+        kube_tag_prefix: typing.Optional[builtins.str] = None,
+        kube_token_command: typing.Optional[builtins.str] = None,
+        kube_token_file: typing.Optional[builtins.str] = None,
+        kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        kube_url: typing.Optional[builtins.str] = None,
+        labels: typing.Optional[builtins.bool] = None,
+        merge_log: typing.Optional[builtins.bool] = None,
+        merge_log_key: typing.Optional[builtins.str] = None,
+        merge_log_trim: typing.Optional[builtins.bool] = None,
+        merge_parser: typing.Optional[builtins.str] = None,
+        regex_parser: typing.Optional[builtins.str] = None,
+        tls_debug: typing.Optional[jsii.Number] = None,
+        tls_verify: typing.Optional[builtins.bool] = None,
+        use_journal: typing.Optional[builtins.bool] = None,
+        use_kubelet: typing.Optional[builtins.bool] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitKubernetesFilter class.
+
+        :param annotations: Include Kubernetes resource annotations in the extra metadata. Default: true
+        :param buffer_size: Set the buffer size for HTTP client when reading responses from Kubernetes API server. A value of 0 results in no limit, and the buffer will expand as-needed. Note that if pod specifications exceed the buffer limit, the API response will be discarded when retrieving metadata, and some kubernetes metadata will fail to be injected to the logs. Default: 32k
+        :param cache_use_docker_id: When enabled, metadata will be fetched from K8s when docker_id is changed. Default: false
+        :param dns_retries: DNS lookup retries N times until the network starts working. Default: 6
+        :param dns_wait_time: DNS lookup interval between network status checks. Default: 30 seconds
+        :param dummy_meta: If set, use dummy-meta data (for test/dev purposes). Default: false
+        :param k8s_logging_exclude: Allow Kubernetes Pods to exclude their logs from the log processor. Default: false
+        :param k8s_logging_parser: Allow Kubernetes Pods to suggest a pre-defined Parser. Default: false
+        :param keep_log: When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well). Default: true
+        :param kube_ca_file: CA certificate file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
+        :param kube_ca_path: Absolute path to scan for certificate files.
+        :param kubelet_host: Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
+        :param kubelet_port: Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled. Default: 10250
+        :param kube_meta_cache_ttl: Configurable TTL for K8s cached metadata. By default, it is set to 0 which means TTL for cache entries is disabled and cache entries are evicted at random when capacity is reached. In order to enable this option, you should set the number to a time interval. Default: 0
+        :param kube_meta_preload_cache_dir: If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
+        :param kube_tag_prefix: When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration. Default: 'kube.var.log.containers.'
+        :param kube_token_command: Command to get Kubernetes authorization token. If you want to manually choose a command to get it, you can set the command here. For example, run running the following to get the token using aws-cli:: aws-iam-authenticator -i your-cluster-name token --token-only This option is currently Linux-only.
+        :param kube_token_file: Token file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
+        :param kube_token_ttl: Configurable 'time to live' for the K8s token. After this time, the token is reloaded from ``kubeTokenFile`` or the ``kubeTokenCommand``. Default: 10 minutes
+        :param kube_url: API Server end-point. Default: 'https://kubernetes.default.svc/'
+        :param labels: Include Kubernetes resource labels in the extra metadata. Default: true
+        :param merge_log: When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure. Default: false
+        :param merge_log_key: When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map. Now if ``mergeLogKey`` is set (a string name), all the new structured fields taken from the original ``log`` content are inserted under the new key.
+        :param merge_log_trim: When Merge_Log is enabled, trim (remove possible \\n or \\r) field values. Default: true
+        :param merge_parser: Optional parser name to specify how to parse the data contained in the log key. Recommended use is for developers or testing only.
+        :param regex_parser: Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id. The parser must be registered in a parsers file.
+        :param tls_debug: Debug level between 0 (nothing) and 4 (every detail). Default: -1
+        :param tls_verify: When enabled, turns on certificate validation when connecting to the Kubernetes API server. Default: true
+        :param use_journal: When enabled, the filter reads logs coming in Journald format. Default: false
+        :param use_kubelet: This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log. Default: false
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitKubernetesFilterOptions(
+            annotations=annotations,
+            buffer_size=buffer_size,
+            cache_use_docker_id=cache_use_docker_id,
+            dns_retries=dns_retries,
+            dns_wait_time=dns_wait_time,
+            dummy_meta=dummy_meta,
+            k8s_logging_exclude=k8s_logging_exclude,
+            k8s_logging_parser=k8s_logging_parser,
+            keep_log=keep_log,
+            kube_ca_file=kube_ca_file,
+            kube_ca_path=kube_ca_path,
+            kubelet_host=kubelet_host,
+            kubelet_port=kubelet_port,
+            kube_meta_cache_ttl=kube_meta_cache_ttl,
+            kube_meta_preload_cache_dir=kube_meta_preload_cache_dir,
+            kube_tag_prefix=kube_tag_prefix,
+            kube_token_command=kube_token_command,
+            kube_token_file=kube_token_file,
+            kube_token_ttl=kube_token_ttl,
+            kube_url=kube_url,
+            labels=labels,
+            merge_log=merge_log,
+            merge_log_key=merge_log_key,
+            merge_log_trim=merge_log_trim,
+            merge_parser=merge_parser,
+            regex_parser=regex_parser,
+            tls_debug=tls_debug,
+            tls_verify=tls_verify,
+            use_journal=use_journal,
+            use_kubelet=use_kubelet,
+            match=match,
+        )
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0105e31834c9b424b25ba556e15b0668eb70bf912898e00b880d88fa39017523)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
+            type_hints = typing.get_type_hints(_typecheckingstub__5953f10fbafcde2546e1cf7a12bdade9d093857e166f6d1fb4bab50e2a66f14b)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PLUGIN_NAME")
+    def PLUGIN_NAME(cls) -> builtins.str:
+        '''The name of the plugin as it will appear in the fluent bit configuration.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "PLUGIN_NAME"))
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    @jsii.member(jsii_name="annotations")
+    def annotations(self) -> typing.Optional[builtins.bool]:
+        '''Include Kubernetes resource annotations in the extra metadata.
 
-        :default: - the resource is in the same account as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "annotations"))
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    @jsii.member(jsii_name="bufferSize")
+    def buffer_size(self) -> typing.Optional[_DataSize_d20aaece]:
+        '''Set the buffer size for HTTP client when reading responses from Kubernetes API server.
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+        A value of 0 results in no limit, and the buffer will expand as-needed.
 
-        Cannot be supplied together with either ``account`` or ``region``.
+        Note that if pod specifications exceed the buffer limit, the API
+        response will be discarded when retrieving metadata, and some kubernetes
+        metadata will fail to be injected to the logs.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :group: Inputs
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_DataSize_d20aaece], jsii.get(self, "bufferSize"))
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    @jsii.member(jsii_name="cacheUseDockerId")
+    def cache_use_docker_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, metadata will be fetched from K8s when docker_id is changed.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "cacheUseDockerId"))
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+    @builtins.property
+    @jsii.member(jsii_name="dnsRetries")
+    def dns_retries(self) -> typing.Optional[jsii.Number]:
+        '''DNS lookup retries N times until the network starts working.
+
+        :group: Inputs
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "dnsRetries"))
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="dnsWaitTime")
+    def dns_wait_time(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''DNS lookup interval between network status checks.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "dnsWaitTime"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="dummyMeta")
+    def dummy_meta(self) -> typing.Optional[builtins.bool]:
+        '''If set, use dummy-meta data (for test/dev purposes).
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "dummyMeta"))
 
-    def __repr__(self) -> str:
-        return "WorkflowPredicateOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="k8sLoggingExclude")
+    def k8s_logging_exclude(self) -> typing.Optional[builtins.bool]:
+        '''Allow Kubernetes Pods to exclude their logs from the log processor.
 
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "k8sLoggingExclude"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "description": "description",
-        "name": "name",
-    },
-)
-class WorkflowProps(_aws_cdk_ceddda9d.ResourceProps):
-    def __init__(
-        self,
-        *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        description: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Configuration for the Glue Workflow resource.
+    @builtins.property
+    @jsii.member(jsii_name="k8sLoggingParser")
+    def k8s_logging_parser(self) -> typing.Optional[builtins.bool]:
+        '''Allow Kubernetes Pods to suggest a pre-defined Parser.
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param description: A description of the Workflow.
-        :param name: A name of the Workflow.
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2ce544c2156b20e8e19b70a1531a61d42db72f6b0e812f45f7bc7bfbeead5f0b)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if description is not None:
-            self._values["description"] = description
-        if name is not None:
-            self._values["name"] = name
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "k8sLoggingParser"))
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    @jsii.member(jsii_name="keepLog")
+    def keep_log(self) -> typing.Optional[builtins.bool]:
+        '''When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well).
 
-        :default: - the resource is in the same account as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "keepLog"))
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    @jsii.member(jsii_name="kubeCaFile")
+    def kube_ca_file(self) -> typing.Optional[builtins.str]:
+        '''CA certificate file.
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeCaFile"))
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    @builtins.property
+    @jsii.member(jsii_name="kubeCaPath")
+    def kube_ca_path(self) -> typing.Optional[builtins.str]:
+        '''Absolute path to scan for certificate files.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :group: Inputs
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeCaPath"))
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    @jsii.member(jsii_name="kubeletHost")
+    def kubelet_host(self) -> typing.Optional[builtins.str]:
+        '''Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeletHost"))
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+    @builtins.property
+    @jsii.member(jsii_name="kubeletPort")
+    def kubelet_port(self) -> typing.Optional[jsii.Number]:
+        '''Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled.
+
+        :group: Inputs
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "kubeletPort"))
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="kubeMetaCacheTtl")
+    def kube_meta_cache_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''Configurable TTL for K8s cached metadata.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        By default, it is set to 0 which means TTL for cache entries is disabled
+        and cache entries are evicted at random when capacity is reached.
+
+        In order to enable this option, you should set the number to a time
+        interval.
+
+        :group: Inputs
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "kubeMetaCacheTtl"))
 
     @builtins.property
-    def description(self) -> typing.Optional[builtins.str]:
-        '''A description of the Workflow.'''
-        result = self._values.get("description")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="kubeMetaPreloadCacheDir")
+    def kube_meta_preload_cache_dir(self) -> typing.Optional[builtins.str]:
+        '''If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeMetaPreloadCacheDir"))
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A name of the Workflow.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="kubeTagPrefix")
+    def kube_tag_prefix(self) -> typing.Optional[builtins.str]:
+        '''When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration.
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTagPrefix"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="kubeTokenCommand")
+    def kube_token_command(self) -> typing.Optional[builtins.str]:
+        '''Command to get Kubernetes authorization token.
 
-    def __repr__(self) -> str:
-        return "WorkflowProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        If you want to manually choose a command to get it, you can set the
+        command here.
+
+        For example, run running the following to get the token using aws-cli::
+
+           aws-iam-authenticator -i your-cluster-name token --token-only
+
+        This option is currently Linux-only.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTokenCommand"))
+
+    @builtins.property
+    @jsii.member(jsii_name="kubeTokenFile")
+    def kube_token_file(self) -> typing.Optional[builtins.str]:
+        '''Token file.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTokenFile"))
+
+    @builtins.property
+    @jsii.member(jsii_name="kubeTokenTtl")
+    def kube_token_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
+        '''Configurable 'time to live' for the K8s token.
+
+        After this time, the token is reloaded from ``kubeTokenFile`` or the
+        ``kubeTokenCommand``.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "kubeTokenTtl"))
+
+    @builtins.property
+    @jsii.member(jsii_name="kubeUrl")
+    def kube_url(self) -> typing.Optional[builtins.str]:
+        '''API Server end-point.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeUrl"))
+
+    @builtins.property
+    @jsii.member(jsii_name="labels")
+    def labels(self) -> typing.Optional[builtins.bool]:
+        '''Include Kubernetes resource labels in the extra metadata.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "labels"))
+
+    @builtins.property
+    @jsii.member(jsii_name="mergeLog")
+    def merge_log(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "mergeLog"))
+
+    @builtins.property
+    @jsii.member(jsii_name="mergeLogKey")
+    def merge_log_key(self) -> typing.Optional[builtins.str]:
+        '''When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map.
+
+        Now if ``mergeLogKey`` is set (a string name), all the new structured
+        fields taken from the original ``log`` content are inserted under the new
+        key.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mergeLogKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="mergeLogTrim")
+    def merge_log_trim(self) -> typing.Optional[builtins.bool]:
+        '''When Merge_Log is enabled, trim (remove possible \\n or \\r) field values.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "mergeLogTrim"))
+
+    @builtins.property
+    @jsii.member(jsii_name="mergeParser")
+    def merge_parser(self) -> typing.Optional[builtins.str]:
+        '''Optional parser name to specify how to parse the data contained in the log key.
+
+        Recommended use is for developers or testing only.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mergeParser"))
+
+    @builtins.property
+    @jsii.member(jsii_name="regexParser")
+    def regex_parser(self) -> typing.Optional[builtins.str]:
+        '''Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id.
+
+        The parser must be registered in a parsers file.
+
+        :see: `Parsers File <https://github.com/fluent/fluent-bit/blob/master/conf/parsers.conf>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexParser"))
+
+    @builtins.property
+    @jsii.member(jsii_name="tlsDebug")
+    def tls_debug(self) -> typing.Optional[jsii.Number]:
+        '''Debug level between 0 (nothing) and 4 (every detail).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "tlsDebug"))
+
+    @builtins.property
+    @jsii.member(jsii_name="tlsVerify")
+    def tls_verify(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, turns on certificate validation when connecting to the Kubernetes API server.
 
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "tlsVerify"))
+
+    @builtins.property
+    @jsii.member(jsii_name="useJournal")
+    def use_journal(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, the filter reads logs coming in Journald format.
 
-class ArrayColumn(
-    Column,
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "useJournal"))
+
+    @builtins.property
+    @jsii.member(jsii_name="useKubelet")
+    def use_kubelet(self) -> typing.Optional[builtins.bool]:
+        '''This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log.
+
+        :see: `Kube API heavy traffic issue for large cluster <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes#optional-feature-using-kubelet-to-get-metadata>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "useKubelet"))
+
+
+class FluentBitModifyFilter(
+    FluentBitFilterPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.ArrayColumn",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitModifyFilter",
 ):
+    '''A Fluent Bit filter that allows changing records using rules and conditions.'''
+
     def __init__(
         self,
         *,
-        data: Column,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
+        conditions: typing.Optional[typing.Sequence[ModifyCondition]] = None,
+        operations: typing.Optional[typing.Sequence[ModifyOperation]] = None,
+        match: typing.Optional[FluentBitMatch] = None,
     ) -> None:
+        '''Creates a new instance of the FluentBitModifyFilter class.
+
+        :param conditions: 
+        :param operations: 
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitModifyFilterOptions(
+            conditions=conditions, operations=operations, match=match
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="addCondition")
+    def add_condition(self, condition: ModifyCondition) -> "FluentBitModifyFilter":
+        '''Adds a new condition to the modify filter.
+
+        All conditions must evaluate to ``true`` in order for operations are
+        performed.
+
+        If one or more conditions do not evaluate to true, no conditions are
+        performed.
+
+        :param condition: The condition to add to the filter.
+
+        :return: The modify filter to which the condition was added.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__60894bd40aca48d31e52eb990ad104ed6b9b8b2602d5bae83cb8098f2ea83f1a)
+            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
+        return typing.cast("FluentBitModifyFilter", jsii.invoke(self, "addCondition", [condition]))
+
+    @jsii.member(jsii_name="addOperation")
+    def add_operation(self, operation: ModifyOperation) -> "FluentBitModifyFilter":
+        '''Adds a new operation to the modify filter.
+
+        :param operation: The operation to add to the filter.
+
+        :return: The modify filter to which the operation was added.
         '''
-        :param data: 
-        :param comment: 
-        :param name: 
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4872512d801b614d842132e607c71d6d758968a7609d124502601dd7de57178a)
+            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
+        return typing.cast("FluentBitModifyFilter", jsii.invoke(self, "addOperation", [operation]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
-        props = ArrayColumnProps(data=data, comment=comment, name=name)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8290d1192e5d252ca7834f51af4ac7230139ac8edc7a97b45248f244d5803b08)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
 
-        jsii.create(self.__class__, self, [props])
+    @builtins.property
+    @jsii.member(jsii_name="conditions")
+    def conditions(self) -> typing.List[ModifyCondition]:
+        '''Collection of conditions to apply for the filter.'''
+        return typing.cast(typing.List[ModifyCondition], jsii.get(self, "conditions"))
 
     @builtins.property
-    @jsii.member(jsii_name="typeString")
-    def type_string(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "typeString"))
+    @jsii.member(jsii_name="operations")
+    def operations(self) -> typing.List[ModifyOperation]:
+        '''Collection of operations to apply for the filter.'''
+        return typing.cast(typing.List[ModifyOperation], jsii.get(self, "operations"))
 
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.ArrayColumnProps",
-    jsii_struct_bases=[ColumnProps],
-    name_mapping={"comment": "comment", "name": "name", "data": "data"},
-)
-class ArrayColumnProps(ColumnProps):
+class FluentBitNestFilter(
+    FluentBitFilterPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitNestFilter",
+):
+    '''A Fluent Bit filter that allows operating on or with nested data.'''
+
     def __init__(
         self,
         *,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        data: Column,
+        operation: NestFilterOperation,
+        add_prefix: typing.Optional[builtins.str] = None,
+        remove_prefix: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
     ) -> None:
+        '''Creates a new instance of the FluentBitNestFilter class.
+
+        :param operation: The operation the filter will perform.
+        :param add_prefix: Prefix affected keys with this string.
+        :param remove_prefix: Remove prefix from affected keys if it matches this string.
+        :param match: The pattern to match for records that this output should apply to.
         '''
-        :param comment: 
-        :param name: 
-        :param data: 
+        options = FluentBitNestFilterOptions(
+            operation=operation,
+            add_prefix=add_prefix,
+            remove_prefix=remove_prefix,
+            match=match,
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e98ee73549e5bf2df4bd363c5ccef46d94100d1940e7c591367826866bb56b21)
-            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "data": data,
-        }
-        if comment is not None:
-            self._values["comment"] = comment
-        if name is not None:
-            self._values["name"] = name
+            type_hints = typing.get_type_hints(_typecheckingstub__2ff2cbdcb80817e036a6954889caaeadf5950a28c75b5dba99ae8a9ac2313605)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    def comment(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("comment")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="operation")
+    def operation(self) -> NestFilterOperation:
+        '''Operation specific details for the plugin.'''
+        return typing.cast(NestFilterOperation, jsii.get(self, "operation"))
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="addPrefix")
+    def add_prefix(self) -> typing.Optional[builtins.str]:
+        '''Prefix affected keys with this string.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "addPrefix"))
 
     @builtins.property
-    def data(self) -> Column:
-        result = self._values.get("data")
-        assert result is not None, "Required property 'data' is missing"
-        return typing.cast(Column, result)
+    @jsii.member(jsii_name="removePrefix")
+    def remove_prefix(self) -> typing.Optional[builtins.str]:
+        '''Remove prefix from affected keys if it matches this string.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "removePrefix"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+@jsii.implements(IFluentBitOutputPlugin)
+class FluentBitOutputPluginBase(
+    FluentBitPlugin,
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitOutputPluginBase",
+):
+    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
 
-    def __repr__(self) -> str:
-        return "ArrayColumnProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    def __init__(
+        self,
+        name: builtins.str,
+        *,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitOutputPlugin class.
+
+        :param name: The name of the output plugin to configure.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6c582e20366c46fa5a93e6085edba3cad0c3a6114b9d179929c4a21e06afd000)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitOutputPluginCommonOptions(match=match)
+
+        jsii.create(self.__class__, self, [name, options])
+
+    @jsii.member(jsii_name="renderConfigFile")
+    def _render_config_file(
+        self,
+        config: typing.Mapping[builtins.str, typing.Any],
+    ) -> builtins.str:
+        '''Renders a Fluent Bit configuration file for the plugin.
+
+        :param config: The configuration options to render into a configuration file.
+
+        :return: A rendered plugin configuration file.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f55ec2d6a159d7531fd899f1f3bf43e62ed11244ce1b82143887e03f2226d642)
+            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
+        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+
+    @builtins.property
+    @jsii.member(jsii_name="match")
+    def match(self) -> FluentBitMatch:
+        '''The pattern to match for records that this output should apply to.
+
+        :group: Inputs
+        '''
+        return typing.cast(FluentBitMatch, jsii.get(self, "match"))
 
 
-class AssetCode(
-    Code,
+class _FluentBitOutputPluginBaseProxy(
+    FluentBitOutputPluginBase,
+    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
+):
+    pass
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, FluentBitOutputPluginBase).__jsii_proxy_class__ = lambda : _FluentBitOutputPluginBaseProxy
+
+
+class FluentBitParserFilter(
+    FluentBitFilterPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.AssetCode",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitParserFilter",
 ):
-    '''Job Code from a local file.'''
+    '''A Fluent Bit filter that allows parsing of fields in event records.'''
 
     def __init__(
         self,
-        path: builtins.str,
         *,
-        asset_hash: typing.Optional[builtins.str] = None,
-        asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
-        bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
+        key_name: builtins.str,
+        parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
+        preserve_key: typing.Optional[builtins.bool] = None,
+        reserve_data: typing.Optional[builtins.bool] = None,
+        match: typing.Optional[FluentBitMatch] = None,
     ) -> None:
+        '''Creates a new instance of the FluentBitParserFilter class.
+
+        :param key_name: Specify field name in record to parse.
+        :param parsers: The parsers to use to interpret the field.
+        :param preserve_key: Keep original ``keyName`` field in the parsed result. If ``false``, the field will be removed. Default: false
+        :param reserve_data: Keep all other original fields in the parsed result. If ``false``, all other original fields will be removed. Default: false
+        :param match: The pattern to match for records that this output should apply to.
         '''
-        :param path: The path to the Code file.
-        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
-        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
-        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
+        options = FluentBitParserFilterOptions(
+            key_name=key_name,
+            parsers=parsers,
+            preserve_key=preserve_key,
+            reserve_data=reserve_data,
+            match=match,
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="addParser")
+    def add_parser(self, parser: IFluentBitParserPlugin) -> "FluentBitParserFilter":
+        '''Adds a new parser to apply to matched log entries.
+
+        :param parser: The parser to use for matched log entries.
+
+        :return: The parser filter that the parser plugin was registered with.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7e088280d8611751a4dd67d784a7813fe0d71f491155a45dfd938dcbbf43714d)
-            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
-        options = _aws_cdk_ceddda9d.AssetOptions(
-            asset_hash=asset_hash, asset_hash_type=asset_hash_type, bundling=bundling
+            type_hints = typing.get_type_hints(_typecheckingstub__18b4223306efeb65c4b4c3faa3427b063444b0783b18132bf6e713a6fd9edbcb)
+            check_type(argname="argument parser", value=parser, expected_type=type_hints["parser"])
+        return typing.cast("FluentBitParserFilter", jsii.invoke(self, "addParser", [parser]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c79cf71df86cb41e555b053e2f91fa72cc6a21fe3a419e03d0eeb0bbc80de8f0)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="keyName")
+    def key_name(self) -> builtins.str:
+        '''Specify field name in record to parse.'''
+        return typing.cast(builtins.str, jsii.get(self, "keyName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="parsers")
+    def parsers(self) -> typing.List[IFluentBitParserPlugin]:
+        '''Collection of the parsers that should be used to evaluate the filter.'''
+        return typing.cast(typing.List[IFluentBitParserPlugin], jsii.get(self, "parsers"))
+
+    @builtins.property
+    @jsii.member(jsii_name="preserveKey")
+    def preserve_key(self) -> typing.Optional[builtins.bool]:
+        '''Keep original ``keyName`` field in the parsed result.
+
+        If ``false``, the field will be removed.
+
+        :default: false
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "preserveKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="reserveData")
+    def reserve_data(self) -> typing.Optional[builtins.bool]:
+        '''Keep all other original fields in the parsed result.
+
+        If ``false``, all other original fields will be removed.
+
+        :default: false
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "reserveData"))
+
+
+@jsii.implements(IFluentBitParserPlugin)
+class FluentBitParserPluginBase(
+    FluentBitPlugin,
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitParserPluginBase",
+):
+    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+
+    def __init__(self, name: builtins.str, format: builtins.str) -> None:
+        '''Creates a new instance of the FluentBitParserPlugin class.
+
+        :param name: The name of the output plugin to configure.
+        :param format: The data format that the parser extracts records from.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8aed0e3d729344028d0f8b2dd7852c483cccc00b07ab135d6bc3adfeeb63180a)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
+        _options = FluentBitParserPluginCommonOptions()
+
+        jsii.create(self.__class__, self, [name, format, _options])
+
+    @jsii.member(jsii_name="renderConfigFile")
+    def _render_config_file(
+        self,
+        config: typing.Mapping[builtins.str, typing.Any],
+    ) -> builtins.str:
+        '''Renders a Fluent Bit configuration file for the plugin.
+
+        :param config: The configuration options to render into a configuration file.
+
+        :return: A rendered plugin configuration file.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a9117f2b6ee6f3211f51ac4d139a07337fb77609903f1cdfc5d98cecfc42198b)
+            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
+        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+
+    @builtins.property
+    @jsii.member(jsii_name="format")
+    def format(self) -> builtins.str:
+        '''The data format that the parser extracts records from.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "format"))
+
+
+class _FluentBitParserPluginBaseProxy(
+    FluentBitParserPluginBase,
+    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
+):
+    pass
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, FluentBitParserPluginBase).__jsii_proxy_class__ = lambda : _FluentBitParserPluginBaseProxy
+
+
+class FluentBitRecordModifierFilter(
+    FluentBitFilterPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRecordModifierFilter",
+):
+    '''A Fluent Bit filter that allows appending fields or excluding specific fields.'''
+
+    def __init__(
+        self,
+        *,
+        allow: typing.Optional[typing.Sequence[builtins.str]] = None,
+        records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
+        remove: typing.Optional[typing.Sequence[builtins.str]] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitRecordModifierFilter class.
+
+        :param allow: If a tag is not match, that field is removed.
+        :param records: Add fields to the output.
+        :param remove: If a tag is match, that field is removed.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitRecordModifierFilterOptions(
+            allow=allow, records=records, remove=remove, match=match
         )
 
-        jsii.create(self.__class__, self, [path, options])
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="addAllow")
+    def add_allow(self, tag: builtins.str) -> "FluentBitRecordModifierFilter":
+        '''Adds a tag to be allowed on a matched input record.
+
+        If a tag is not matched it is removed.
+
+        :param tag: The tag to add to the allow list.
+
+        :return:
+
+        The record modifier filter that the tag plugin was registered
+        with.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__197d11f14d745ecc6b6f0e060796ec77dba5a2371d0b974c5188eba457ace3a9)
+            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
+        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addAllow", [tag]))
+
+    @jsii.member(jsii_name="addRecord")
+    def add_record(
+        self,
+        *,
+        field_name: builtins.str,
+        value: builtins.str,
+    ) -> "FluentBitRecordModifierFilter":
+        '''Add a record to be appended to matched events.
+
+        :param field_name: The name of the field to be added.
+        :param value: The value that the added field should be set to.
+
+        :return:
+
+        The record modifier filter that the tag plugin was registered
+        with.
+        '''
+        record = AppendedRecord(field_name=field_name, value=value)
+
+        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addRecord", [record]))
+
+    @jsii.member(jsii_name="addRemove")
+    def add_remove(self, tag: builtins.str) -> "FluentBitRecordModifierFilter":
+        '''Adds a tag to be removed on a matched input record.
+
+        If a tag is matched it is removed.
+
+        :param tag: The tag to add to the allow list.
+
+        :return:
+
+        The record modifier filter that the tag plugin was registered
+        with.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b1fb7025737a67bb8d4d600b93b0d5d19ecf74c9ce22d8ea64f634ad9895f200)
+            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
+        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addRemove", [tag]))
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
-    ) -> CodeConfig:
-        '''Called when the Job is initialized to allow this object to bind.
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
 
-        :param scope: -
-        :param grantable: -
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ec027c50ac516e8170beed01cb13e2ead3adfe45e782c6b378a332ada31736c0)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument grantable", value=grantable, expected_type=type_hints["grantable"])
-        return typing.cast(CodeConfig, jsii.invoke(self, "bind", [scope, grantable]))
+            type_hints = typing.get_type_hints(_typecheckingstub__5f389e835484d35e9442fddb76443dec0a2aa164eb591d2f71cb44abf7e9b8fa)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="allow")
+    def allow(self) -> typing.List[builtins.str]:
+        '''Collection of tags that are allowed on a matched input record.
+
+        If a tag is not matched it is removed.
+        '''
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "allow"))
+
+    @builtins.property
+    @jsii.member(jsii_name="records")
+    def records(self) -> typing.List[AppendedRecord]:
+        '''Collection of the records to be appending to matched input.'''
+        return typing.cast(typing.List[AppendedRecord], jsii.get(self, "records"))
+
+    @builtins.property
+    @jsii.member(jsii_name="remove")
+    def remove(self) -> typing.List[builtins.str]:
+        '''Collection of tags to exclude from a matched input record.
+
+        If a tag is matched it is removed.
+        '''
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "remove"))
 
 
-class BasicColumn(
-    Column,
+class FluentBitRegexParser(
+    FluentBitParserPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.BasicColumn",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRegexParser",
 ):
+    '''A Fluent Bit filter that parsed inbound messages using regular expressions.'''
+
     def __init__(
         self,
+        name: builtins.str,
         *,
-        type: builtins.str,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
+        regex: builtins.str,
+        skip_empty_values: typing.Optional[builtins.bool] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
     ) -> None:
+        '''Creates a new instance of the FluentBitLtsvParser class.
+
+        :param name: -
+        :param regex: The regular expression to use to parse the incoming records. Use regex group names to define the name of fields being captured.
+        :param skip_empty_values: If enabled, the parser ignores empty value of the record.
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
         '''
-        :param type: 
-        :param comment: 
-        :param name: 
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4179007c95e092b6ac83f12dd7ef24c1c718db06738628257564097d17575d37)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitRegexParserOptions(
+            regex=regex,
+            skip_empty_values=skip_empty_values,
+            time_format=time_format,
+            time_key=time_key,
+            types=types,
+        )
+
+        jsii.create(self.__class__, self, [name, options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
-        props = BasicColumnProps(type=type, comment=comment, name=name)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b3c327e2acce81be05e692cd50cc22811413200c4697881b0ba1fbe6ce2d81d2)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="regex")
+    def regex(self) -> builtins.str:
+        '''The regular expression to use to parse the incoming records.
 
-        jsii.create(self.__class__, self, [props])
+        Use regex group names to define the name of fields being captured.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "regex"))
 
     @builtins.property
-    @jsii.member(jsii_name="typeString")
-    def type_string(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "typeString"))
+    @jsii.member(jsii_name="skipEmptyValues")
+    def skip_empty_values(self) -> typing.Optional[builtins.bool]:
+        '''If enabled, the parser ignores empty value of the record.
 
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "skipEmptyValues"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeFormat")
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="types")
+    def types(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+
+
+class FluentBitRewriteTagFilter(
+    FluentBitFilterPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitRewriteTagFilter",
+):
+    '''A Fluent Bit filter that allows parsing of fields in event records.'''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.BasicColumnProps",
-    jsii_struct_bases=[ColumnProps],
-    name_mapping={"comment": "comment", "name": "name", "type": "type"},
-)
-class BasicColumnProps(ColumnProps):
     def __init__(
         self,
         *,
-        comment: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        type: builtins.str,
+        emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
+        emitter_name: typing.Optional[builtins.str] = None,
+        emitter_storage_type: typing.Optional[EmitterStorageType] = None,
+        rules: typing.Optional[typing.Sequence[typing.Union[RewriteTagRule, typing.Dict[builtins.str, typing.Any]]]] = None,
+        match: typing.Optional[FluentBitMatch] = None,
     ) -> None:
+        '''Creates a new instance of the FluentBitRewriteTagFilter class.
+
+        :param emitter_mem_buf_limit: Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure. Default: 10M
+        :param emitter_name: When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job. Since this emitter expose metrics as any other component of the pipeline, you can use this property to configure an optional name for it.
+        :param emitter_storage_type: Define a buffering mechanism for the new records created. Note these records are part of the emitter plugin.
+        :param rules: Defines the matching criteria and the format of the Tag for the matching record.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitRewriteTagFilterOptions(
+            emitter_mem_buf_limit=emitter_mem_buf_limit,
+            emitter_name=emitter_name,
+            emitter_storage_type=emitter_storage_type,
+            rules=rules,
+            match=match,
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="addRule")
+    def add_rule(
+        self,
+        *,
+        keep: builtins.bool,
+        key: builtins.str,
+        new_tag: builtins.str,
+        regex: builtins.str,
+    ) -> "FluentBitRewriteTagFilter":
+        '''Adds a new rule to apply to matched log entries.
+
+        :param keep: If a rule matches a rule the filter will emit a copy of the record with the new defined Tag. The property keep takes a boolean value to define if the original record with the old Tag must be preserved and continue in the pipeline or just be discarded.
+        :param key: The key represents the name of the record key that holds the value that we want to use to match our regular expression. A key name is specified and prefixed with a ``$``.
+        :param new_tag: If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record. The tag is a concatenated string that can contain any of the following characters: ``a-z,A-Z,0-9`` and ``.-,``.
+        :param regex: Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
+
+        :return: The parser filter that the parser plugin was registered with.
         '''
-        :param comment: 
-        :param name: 
-        :param type: 
+        rule = RewriteTagRule(keep=keep, key=key, new_tag=new_tag, regex=regex)
+
+        return typing.cast("FluentBitRewriteTagFilter", jsii.invoke(self, "addRule", [rule]))
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0ae472b6c02750d1961d7f516ba02f642a1ea26bb6902239beb46998e097aaf9)
-            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "type": type,
-        }
-        if comment is not None:
-            self._values["comment"] = comment
-        if name is not None:
-            self._values["name"] = name
+            type_hints = typing.get_type_hints(_typecheckingstub__7b876de72e29ff64e3f1942127300def8853d5a5fcc52fac6120aba70bdda279)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PLUGIN_NAME")
+    def PLUGIN_NAME(cls) -> builtins.str:
+        '''The name of the plugin as it will appear in the fluent bit configuration.'''
+        return typing.cast(builtins.str, jsii.sget(cls, "PLUGIN_NAME"))
 
     @builtins.property
-    def comment(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("comment")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="emitterName")
+    def emitter_name(self) -> builtins.str:
+        '''When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job.
+
+        Since this emitter expose
+        metrics as any other component of the pipeline, you can use this
+        property to configure an optional name for it.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "emitterName"))
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="rules")
+    def rules(self) -> typing.List[RewriteTagRule]:
+        '''Collection of rules defining matching criteria and the format of the tag for the matching record.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.List[RewriteTagRule], jsii.get(self, "rules"))
 
     @builtins.property
-    def type(self) -> builtins.str:
-        result = self._values.get("type")
-        assert result is not None, "Required property 'type' is missing"
-        return typing.cast(builtins.str, result)
+    @jsii.member(jsii_name="emitterMemBufLimit")
+    def emitter_mem_buf_limit(self) -> typing.Optional[_DataSize_d20aaece]:
+        '''Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure.
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_DataSize_d20aaece], jsii.get(self, "emitterMemBufLimit"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="emitterStorageType")
+    def emitter_storage_type(self) -> typing.Optional[EmitterStorageType]:
+        '''Define a buffering mechanism for the new records created.
 
-    def __repr__(self) -> str:
-        return "BasicColumnProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        Note these records are part of the emitter plugin.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[EmitterStorageType], jsii.get(self, "emitterStorageType"))
 
 
-@jsii.implements(ICrawler)
-class Crawler(
-    _aws_cdk_ceddda9d.Resource,
+class FluentBitThrottleFilter(
+    FluentBitFilterPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.Crawler",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitThrottleFilter",
 ):
-    '''Create a Crawler resource to pull information from the provided resource.
+    '''A Fluent Bit filter that sets the average *Rate* of messages per *Interval*, based on leaky bucket and sliding window algorithm.
 
-    :see: `AWS::Glue::Crawler <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-glue-crawler.html>`_
+    In case of overflood,
+    it will leak within certain rate.
     '''
 
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
-        configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
-        database: typing.Optional[Database] = None,
-        delete_behavior: typing.Optional[DeleteBehavior] = None,
-        description: typing.Optional[builtins.str] = None,
-        name: typing.Optional[builtins.str] = None,
-        recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
-        schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-        security_configuration: typing.Optional[SecurityConfiguration] = None,
-        table_prefix: typing.Optional[builtins.str] = None,
-        targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
-        update_behavior: typing.Optional[UpdateBehavior] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the Crawler class.
+        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        print_status: typing.Optional[builtins.bool] = None,
+        rate: typing.Optional[jsii.Number] = None,
+        window: typing.Optional[jsii.Number] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitThrottleFilter class.
+
+        :param interval: Time interval.
+        :param print_status: Whether to print status messages with current rate and the limits to information logs.
+        :param rate: Amount of messages for the time.
+        :param window: Amount of intervals to calculate average over. Default: 5
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitThrottleFilterOptions(
+            interval=interval,
+            print_status=print_status,
+            rate=rate,
+            window=window,
+            match=match,
+        )
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param classifiers: A list of UTF-8 strings that specify the names of custom classifiers that are associated with the crawler.
-        :param configuration: Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler's behavior. For more information, see Configuring a Crawler.
-        :param database: The {@link aws-glue.Database | Database } object in which the crawler's output is stored.
-        :param delete_behavior: The deletion behavior when the crawler finds a deleted object.
-        :param description: Description of the Crawler.
-        :param name: Name of the Crawler.
-        :param recrawl_behavior: When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl the entire dataset again or to crawl only folders that were added since the last crawler run.
-        :param schedule_expression: For scheduled crawlers, the schedule when the crawler runs.
-        :param security_configuration: A {@link aws-glue.SecurityConfiguration | SecurityConfiguration } object to apply to the Crawler.
-        :param table_prefix: The prefix added to the names of tables that are created.
-        :param targets: A collection of targets to crawl.
-        :param update_behavior: The update behavior when the crawler finds a changed schema.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5211274cd7116e3c396417e594ecadcc53088dd8ee26c4e810934deac308acc2)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = CrawlerProps(
-            classifiers=classifiers,
-            configuration=configuration,
-            database=database,
-            delete_behavior=delete_behavior,
-            description=description,
-            name=name,
-            recrawl_behavior=recrawl_behavior,
-            schedule_expression=schedule_expression,
-            security_configuration=security_configuration,
-            table_prefix=table_prefix,
-            targets=targets,
-            update_behavior=update_behavior,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
+            type_hints = typing.get_type_hints(_typecheckingstub__5ddeac1f10751e613cc3decd64281d60ce8da73f21dce744a8f23bdd94d419b9)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="interval")
+    def interval(self) -> _aws_cdk_ceddda9d.Duration:
+        '''Time interval.
+
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_ceddda9d.Duration, jsii.get(self, "interval"))
+
+    @builtins.property
+    @jsii.member(jsii_name="rate")
+    def rate(self) -> jsii.Number:
+        '''Amount of messages for the time.
+
+        :group: Inputs
+        '''
+        return typing.cast(jsii.Number, jsii.get(self, "rate"))
+
+    @builtins.property
+    @jsii.member(jsii_name="window")
+    def window(self) -> jsii.Number:
+        '''Amount of intervals to calculate average over.
+
+        :group: Inputs
+        '''
+        return typing.cast(jsii.Number, jsii.get(self, "window"))
+
+    @builtins.property
+    @jsii.member(jsii_name="printStatus")
+    def print_status(self) -> typing.Optional[builtins.bool]:
+        '''Whether to print status messages with current rate and the limits to information logs.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "printStatus"))
+
+
+class FluentBitCloudWatchLogsOutput(
+    FluentBitOutputPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitCloudWatchLogsOutput",
+):
+    '''Represents configuration for outputing logs from Fluent Bit to CloudWatch Logs.'''
+
+    def __init__(
+        self,
+        *,
+        auto_create_group: typing.Optional[builtins.bool] = None,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_format: typing.Optional[builtins.str] = None,
+        log_group: typing.Optional[FluentBitLogGroupOutput] = None,
+        log_group_template: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
+        log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
+        log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
+        log_stream_template: typing.Optional[builtins.str] = None,
+        metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        metric_namespace: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitCloudWatchLogsOutput class.
+
+        :param auto_create_group: Automatically create the log group. Default: false
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param endpoint: Specify a custom endpoint for the CloudWatch Logs API.
+        :param log_format: An optional parameter that can be used to tell CloudWatch the format of the data. A value of json/emf enables CloudWatch to extract custom metrics embedded in a JSON payload.
+        :param log_group: The CloudWatch Log Group configuration for output records.
+        :param log_group_template: Template for Log Group name using Fluent Bit record_accessor syntax. This field is optional and if configured it overrides the configured Log Group. If the template translation fails, an error is logged and the provided Log Group (which is still required) is used instead.
+        :param log_key: By default, the whole log record will be sent to CloudWatch. If you specify a key name with this option, then only the value of that key will be sent to CloudWatch.
+        :param log_retention: If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
+        :param log_stream: The CloudWatch LogStream configuration for outbound records.
+        :param log_stream_template: Template for Log Stream name using Fluent Bit record accessor syntax. This field is optional and if configured it overrides the other log stream options. If the template translation fails, an error is logged and the logStream or logStreamPrefix are used instead (and thus one of those fields is still required to be configured).
+        :param metric_dimensions: A list of lists containing the dimension keys that will be applied to all metrics. The values within a dimension set MUST also be members on the root-node.
+        :param metric_namespace: An optional string representing the CloudWatch namespace for the metrics.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitCloudWatchLogsOutputOptions(
+            auto_create_group=auto_create_group,
+            auto_retry_requests=auto_retry_requests,
+            endpoint=endpoint,
+            log_format=log_format,
+            log_group=log_group,
+            log_group_template=log_group_template,
+            log_key=log_key,
+            log_retention=log_retention,
+            log_stream=log_stream,
+            log_stream_template=log_stream_template,
+            metric_dimensions=metric_dimensions,
+            metric_namespace=metric_namespace,
             region=region,
+            role=role,
+            sts_endpoint=sts_endpoint,
+            match=match,
         )
 
-        jsii.create(self.__class__, self, [scope, id, props])
+        jsii.create(self.__class__, self, [options])
 
-    @jsii.member(jsii_name="fromCrawlerArn")
-    @builtins.classmethod
-    def from_crawler_arn(
-        cls,
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
         scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        crawler_arn: builtins.str,
-    ) -> ICrawler:
-        '''Imports an existing crawler using its Amazon Resource Name (ARN).
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param crawler_arn: The ARN of the crawler to import.
+        :param scope: The construct configuring logging using Fluent Bit.
 
-        :return: An object representing the crawler that was imported.
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d145d23256eb2d35c1a9bf019e04dff25bc109fef47efc90d6d6f6882fdb4815)
+            type_hints = typing.get_type_hints(_typecheckingstub__4fd91daa220023ad34765844283275eab65fafb87508ac56f1d7c81195ee443b)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument crawler_arn", value=crawler_arn, expected_type=type_hints["crawler_arn"])
-        return typing.cast(ICrawler, jsii.sinvoke(cls, "fromCrawlerArn", [scope, id, crawler_arn]))
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
 
-    @jsii.member(jsii_name="fromCrawlerName")
-    @builtins.classmethod
-    def from_crawler_name(
-        cls,
-        scope: _constructs_77d1e7e8.IConstruct,
-        id: builtins.str,
-        crawler_name: builtins.str,
-    ) -> ICrawler:
-        '''Imports an existing crawler using its name.
+    @builtins.property
+    @jsii.member(jsii_name="logGroup")
+    def log_group(self) -> FluentBitLogGroupOutput:
+        '''The CloudWatch Log Group configuration for output records.'''
+        return typing.cast(FluentBitLogGroupOutput, jsii.get(self, "logGroup"))
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
-        :param crawler_name: The name of the crawler to import.
+    @builtins.property
+    @jsii.member(jsii_name="logStream")
+    def log_stream(self) -> FluentBitLogStreamOutput:
+        '''The CloudWatch LogStream configuration for outbound records.'''
+        return typing.cast(FluentBitLogStreamOutput, jsii.get(self, "logStream"))
 
-        :return: An object representing the crawler that was imported.
+    @builtins.property
+    @jsii.member(jsii_name="autoCreateGroup")
+    def auto_create_group(self) -> typing.Optional[builtins.bool]:
+        '''Automatically create the log group.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d539939596ad8ddfe1a7db54e1c33868e19ed805abf7d2eef859c4a90be77941)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument crawler_name", value=crawler_name, expected_type=type_hints["crawler_name"])
-        return typing.cast(ICrawler, jsii.sinvoke(cls, "fromCrawlerName", [scope, id, crawler_name]))
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoCreateGroup"))
 
-    @jsii.member(jsii_name="addClassifier")
-    def add_classifier(self, classifier: builtins.str) -> None:
+    @builtins.property
+    @jsii.member(jsii_name="autoRetryRequests")
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
+
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
+
+        :group: Inputs
         '''
-        :param classifier: -
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
+
+    @builtins.property
+    @jsii.member(jsii_name="endpoint")
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the CloudWatch Logs API.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__96016694c1f44cc04af86f8b769bd0adb927352bc79ad9603516897998bec7b0)
-            check_type(argname="argument classifier", value=classifier, expected_type=type_hints["classifier"])
-        return typing.cast(None, jsii.invoke(self, "addClassifier", [classifier]))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logFormat")
+    def log_format(self) -> typing.Optional[builtins.str]:
+        '''An optional parameter that can be used to tell CloudWatch the format of the data.
+
+        A value of json/emf enables CloudWatch to extract custom
+        metrics embedded in a JSON payload.
 
-    @jsii.member(jsii_name="addTarget")
-    def add_target(self, target: ICrawlerTarget) -> None:
+        :see: `Embedded Metric Format <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html>`_
+        :group: Inputs
         '''
-        :param target: -
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logGroupTemplate")
+    def log_group_template(self) -> typing.Optional[builtins.str]:
+        '''Template for Log Group name using Fluent Bit record_accessor syntax.
+
+        This field is optional and if configured it overrides the configured Log
+        Group.
+
+        If the template translation fails, an error is logged and the provided
+        Log Group (which is still required) is used instead.
+
+        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dc8dd7ffc643cb691f77d16e095c4e42f8ad2f09ba25c30724c84c18b23eefac)
-            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
-        return typing.cast(None, jsii.invoke(self, "addTarget", [target]))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupTemplate"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawlerArn")
-    def crawler_arn(self) -> builtins.str:
-        '''The Amazon Resource Name (ARN) of the crawler.'''
-        return typing.cast(builtins.str, jsii.get(self, "crawlerArn"))
+    @jsii.member(jsii_name="logKey")
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to CloudWatch.
+
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to CloudWatch.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawlerName")
-    def crawler_name(self) -> builtins.str:
-        '''The name of the crawler.'''
-        return typing.cast(builtins.str, jsii.get(self, "crawlerName"))
+    @jsii.member(jsii_name="logRetention")
+    def log_retention(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays]:
+        '''If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays], jsii.get(self, "logRetention"))
 
     @builtins.property
-    @jsii.member(jsii_name="resource")
-    def resource(self) -> _aws_cdk_aws_glue_ceddda9d.CfnCrawler:
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnCrawler, jsii.get(self, "resource"))
+    @jsii.member(jsii_name="logStreamTemplate")
+    def log_stream_template(self) -> typing.Optional[builtins.str]:
+        '''Template for Log Stream name using Fluent Bit record accessor syntax.
+
+        This field is optional and if configured it overrides the other log
+        stream options. If the template translation fails, an error is logged
+        and the logStream or logStreamPrefix are used instead (and thus one of
+        those fields is still required to be configured).
+
+        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamTemplate"))
+
+    @builtins.property
+    @jsii.member(jsii_name="metricDimensions")
+    def metric_dimensions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''A list of lists containing the dimension keys that will be applied to all metrics.
+
+        The values within a dimension set MUST also be members on
+        the root-node.
+
+        :see: `Dimensions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "metricDimensions"))
+
+    @builtins.property
+    @jsii.member(jsii_name="metricNamespace")
+    def metric_namespace(self) -> typing.Optional[builtins.str]:
+        '''An optional string representing the CloudWatch namespace for the metrics.
+
+        :see: `Metric Tutorial <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch#metrics-tutorial>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "metricNamespace"))
+
+    @builtins.property
+    @jsii.member(jsii_name="region")
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
 
     @builtins.property
     @jsii.member(jsii_name="role")
-    def role(self) -> _aws_cdk_aws_iam_ceddda9d.Role:
-        return typing.cast(_aws_cdk_aws_iam_ceddda9d.Role, jsii.get(self, "role"))
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
 
     @builtins.property
-    @jsii.member(jsii_name="configuration")
-    def configuration(self) -> typing.Optional[CrawlerConfiguration]:
-        '''{@link CrawlerProps.configuration}.'''
-        return typing.cast(typing.Optional[CrawlerConfiguration], jsii.get(self, "configuration"))
+    @jsii.member(jsii_name="stsEndpoint")
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
+
+
+class FluentBitElasticsearchOutput(
+    FluentBitOutputPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitElasticsearchOutput",
+):
+    def __init__(
+        self,
+        *,
+        host: builtins.str,
+        aws_auth: typing.Optional[builtins.bool] = None,
+        aws_external_id: typing.Optional[builtins.str] = None,
+        aws_region: typing.Optional[builtins.str] = None,
+        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        aws_sts_endpoint: typing.Optional[builtins.str] = None,
+        buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
+        cloud_auth: typing.Optional[builtins.str] = None,
+        cloud_id: typing.Optional[builtins.str] = None,
+        compress: typing.Optional[ElasticsearchCompressionFormat] = None,
+        current_time_index: typing.Optional[builtins.bool] = None,
+        generate_id: typing.Optional[builtins.bool] = None,
+        http_passwd: typing.Optional[builtins.str] = None,
+        http_user: typing.Optional[builtins.str] = None,
+        id_key: typing.Optional[builtins.str] = None,
+        include_tag_key: typing.Optional[builtins.bool] = None,
+        index: typing.Optional[builtins.str] = None,
+        logstash_date_format: typing.Optional[builtins.str] = None,
+        logstash_format: typing.Optional[builtins.bool] = None,
+        logstash_prefix: typing.Optional[builtins.str] = None,
+        logstash_prefix_key: typing.Optional[builtins.str] = None,
+        path: typing.Optional[builtins.str] = None,
+        pipeline: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replace_dots: typing.Optional[builtins.bool] = None,
+        suppress_type_name: typing.Optional[builtins.bool] = None,
+        tag_key: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        time_key_nanos: typing.Optional[builtins.bool] = None,
+        trace_error: typing.Optional[builtins.bool] = None,
+        trace_output: typing.Optional[builtins.bool] = None,
+        type: typing.Optional[builtins.str] = None,
+        workers: typing.Optional[jsii.Number] = None,
+        write_operation: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
+
+        :param host: IP address or hostname of the target Elasticsearch instance.
+        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service. Default: false
+        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
+        :param aws_region: Specify the AWS region for Elasticsearch Service.
+        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
+        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
+        :param buffer_size: Specify the buffer size used to read the response from the Elasticsearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
+        :param cloud_auth: Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
+        :param cloud_id: If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
+        :param compress: Set payload compression mechanism.
+        :param current_time_index: Use current time for index generation instead of message record. Default: false
+        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
+        :param http_passwd: Password for user defined in ``httpUser``.
+        :param http_user: Optional username credential for access.
+        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+        :param include_tag_key: When enabled, it append the Tag name to the record.
+        :param index: Index name. Default: 'fluent-bit
+        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
+        :param logstash_format: Enable Logstash format compatibility. Default: false
+        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
+        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
+        :param path: Elasticsearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
+        :param pipeline: Elasticsearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
+        :param port: TCP port of the target Elasticsearch instance. Default: 9200
+        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
+        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
+        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
+        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
+        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
+        :param trace_error: When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only). Default: false
+        :param trace_output: When enabled print the Elasticsearch API calls to stdout (for diag only). Default: false
+        :param type: Type name. Default: '_doc'
+        :param workers: Enables dedicated thread(s) for this output. Default: 2
+        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitElasticsearchOutputOptions(
+            host=host,
+            aws_auth=aws_auth,
+            aws_external_id=aws_external_id,
+            aws_region=aws_region,
+            aws_role=aws_role,
+            aws_sts_endpoint=aws_sts_endpoint,
+            buffer_size=buffer_size,
+            cloud_auth=cloud_auth,
+            cloud_id=cloud_id,
+            compress=compress,
+            current_time_index=current_time_index,
+            generate_id=generate_id,
+            http_passwd=http_passwd,
+            http_user=http_user,
+            id_key=id_key,
+            include_tag_key=include_tag_key,
+            index=index,
+            logstash_date_format=logstash_date_format,
+            logstash_format=logstash_format,
+            logstash_prefix=logstash_prefix,
+            logstash_prefix_key=logstash_prefix_key,
+            path=path,
+            pipeline=pipeline,
+            port=port,
+            replace_dots=replace_dots,
+            suppress_type_name=suppress_type_name,
+            tag_key=tag_key,
+            time_key=time_key,
+            time_key_format=time_key_format,
+            time_key_nanos=time_key_nanos,
+            trace_error=trace_error,
+            trace_output=trace_output,
+            type=type,
+            workers=workers,
+            write_operation=write_operation,
+            match=match,
+        )
+
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__31e06075f1184a9eaf94b720a919de0afb675ade3a9e9f7e3f9e9140cf117b1f)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="database")
-    def database(self) -> typing.Optional[Database]:
-        '''{@link CrawlerProps.database}.'''
-        return typing.cast(typing.Optional[Database], jsii.get(self, "database"))
+    @jsii.member(jsii_name="host")
+    def host(self) -> builtins.str:
+        '''IP address or hostname of the target Elasticsearch instance.
+
+        :group: Inputs
+        '''
+        return typing.cast(builtins.str, jsii.get(self, "host"))
 
     @builtins.property
-    @jsii.member(jsii_name="deleteBehavior")
-    def delete_behavior(self) -> typing.Optional[DeleteBehavior]:
-        '''{@link CrawlerProps.deleteBehavior}.'''
-        return typing.cast(typing.Optional[DeleteBehavior], jsii.get(self, "deleteBehavior"))
+    @jsii.member(jsii_name="awsAuth")
+    def aws_auth(self) -> typing.Optional[builtins.bool]:
+        '''Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "awsAuth"))
 
     @builtins.property
-    @jsii.member(jsii_name="description")
-    def description(self) -> typing.Optional[builtins.str]:
-        '''{@link CrawlerProps.description}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
+    @jsii.member(jsii_name="awsExternalId")
+    def aws_external_id(self) -> typing.Optional[builtins.str]:
+        '''External ID for the AWS IAM Role specified with ``awsRole``.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsExternalId"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> typing.Optional[builtins.str]:
-        '''{@link CrawlerProps.name}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
+    @jsii.member(jsii_name="awsRegion")
+    def aws_region(self) -> typing.Optional[builtins.str]:
+        '''Specify the AWS region for Elasticsearch Service.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsRegion"))
+
+    @builtins.property
+    @jsii.member(jsii_name="awsRole")
+    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''AWS IAM Role to assume to put records to your Amazon cluster.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "awsRole"))
 
     @builtins.property
-    @jsii.member(jsii_name="recrawlBehavior")
-    def recrawl_behavior(self) -> typing.Optional[RecrawlBehavior]:
-        '''{@link CrawlerProps.recrawlBehavior}.'''
-        return typing.cast(typing.Optional[RecrawlBehavior], jsii.get(self, "recrawlBehavior"))
+    @jsii.member(jsii_name="awsStsEndpoint")
+    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsStsEndpoint"))
 
     @builtins.property
-    @jsii.member(jsii_name="scheduleExpression")
-    def schedule_expression(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule]:
-        '''{@link CrawlerProps.scheduleExpression}.'''
-        return typing.cast(typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule], jsii.get(self, "scheduleExpression"))
+    @jsii.member(jsii_name="bufferSize")
+    def buffer_size(self) -> typing.Optional[ElasticsearchOutputBufferSize]:
+        '''Specify the buffer size used to read the response from the Elasticsearch HTTP service.
+
+        This option is useful for debugging purposes where is
+        required to read full responses, note that response size grows depending
+        of the number of records inserted.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ElasticsearchOutputBufferSize], jsii.get(self, "bufferSize"))
+
+    @builtins.property
+    @jsii.member(jsii_name="cloudAuth")
+    def cloud_auth(self) -> typing.Optional[builtins.str]:
+        '''Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cloudAuth"))
+
+    @builtins.property
+    @jsii.member(jsii_name="cloudId")
+    def cloud_id(self) -> typing.Optional[builtins.str]:
+        '''If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cloudId"))
 
     @builtins.property
-    @jsii.member(jsii_name="securityConfiguration")
-    def security_configuration(self) -> typing.Optional[SecurityConfiguration]:
-        '''{@link CrawlerProps.securityConfiguration}.'''
-        return typing.cast(typing.Optional[SecurityConfiguration], jsii.get(self, "securityConfiguration"))
+    @jsii.member(jsii_name="compress")
+    def compress(self) -> typing.Optional[ElasticsearchCompressionFormat]:
+        '''Set payload compression mechanism.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[ElasticsearchCompressionFormat], jsii.get(self, "compress"))
 
     @builtins.property
-    @jsii.member(jsii_name="tablePrefix")
-    def table_prefix(self) -> typing.Optional[builtins.str]:
-        '''{@link CrawlerProps.tablePrefix}.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tablePrefix"))
+    @jsii.member(jsii_name="currentTimeIndex")
+    def current_time_index(self) -> typing.Optional[builtins.bool]:
+        '''Use current time for index generation instead of message record.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "currentTimeIndex"))
 
     @builtins.property
-    @jsii.member(jsii_name="updateBehavior")
-    def update_behavior(self) -> typing.Optional[UpdateBehavior]:
-        '''{@link CrawlerProps.updateBehavior}.'''
-        return typing.cast(typing.Optional[UpdateBehavior], jsii.get(self, "updateBehavior"))
+    @jsii.member(jsii_name="generateId")
+    def generate_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, generate ``_id`` for outgoing records.
 
+        This prevents duplicate
+        records when retrying.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "generateId"))
 
-@jsii.implements(ITriggerPredicate)
-class WorkflowCrawlerPredicate(
-    WorkflowPredicateBase,
+    @builtins.property
+    @jsii.member(jsii_name="httpPasswd")
+    def http_passwd(self) -> typing.Optional[builtins.str]:
+        '''Password for user defined in ``httpUser``.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpPasswd"))
+
+    @builtins.property
+    @jsii.member(jsii_name="httpUser")
+    def http_user(self) -> typing.Optional[builtins.str]:
+        '''Optional username credential for access.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpUser"))
+
+    @builtins.property
+    @jsii.member(jsii_name="idKey")
+    def id_key(self) -> typing.Optional[builtins.str]:
+        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="includeTagKey")
+    def include_tag_key(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it append the Tag name to the record.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="index")
+    def index(self) -> typing.Optional[builtins.str]:
+        '''Index name.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "index"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashDateFormat")
+    def logstash_date_format(self) -> typing.Optional[builtins.str]:
+        '''Time format (based on strftime) to generate the second part of the Index name.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashDateFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashFormat")
+    def logstash_format(self) -> typing.Optional[builtins.bool]:
+        '''Enable Logstash format compatibility.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "logstashFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashPrefix")
+    def logstash_prefix(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+
+        The last string appended belongs to the date when the data is being
+        generated.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefix"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashPrefixKey")
+    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
+        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
+
+        If
+        the key/value is not found in the record then the ``logstashPrefix`` option
+        will act as a fallback.
+
+        Nested keys are not supported (if desired, you can use the nest filter
+        plugin to remove nesting).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefixKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="path")
+    def path(self) -> typing.Optional[builtins.str]:
+        '''Elasticsearch accepts new data on HTTP query path "/_bulk".
+
+        But it is
+        also possible to serve Elasticsearch behind a reverse proxy on a
+        subpath. This option defines such path on the fluent-bit side. It
+        simply adds a path prefix in the indexing HTTP POST URI.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "path"))
+
+    @builtins.property
+    @jsii.member(jsii_name="pipeline")
+    def pipeline(self) -> typing.Optional[builtins.str]:
+        '''Elasticsearch allows to setup filters called pipelines.
+
+        This option
+        allows to define which pipeline the database should use.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pipeline"))
+
+    @builtins.property
+    @jsii.member(jsii_name="port")
+    def port(self) -> typing.Optional[jsii.Number]:
+        '''TCP port of the target Elasticsearch instance.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "port"))
+
+    @builtins.property
+    @jsii.member(jsii_name="replaceDots")
+    def replace_dots(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, replace field name dots with underscore.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "replaceDots"))
+
+    @builtins.property
+    @jsii.member(jsii_name="suppressTypeName")
+    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, mapping types is removed and ``type`` option is ignored.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "suppressTypeName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="tagKey")
+    def tag_key(self) -> typing.Optional[builtins.str]:
+        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+
+        The``timeKey`` property defines the name of that field.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKeyFormat")
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKeyNanos")
+    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
+        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "timeKeyNanos"))
+
+    @builtins.property
+    @jsii.member(jsii_name="traceError")
+    def trace_error(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceError"))
+
+    @builtins.property
+    @jsii.member(jsii_name="traceOutput")
+    def trace_output(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the Elasticsearch API calls to stdout (for diag only).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceOutput"))
+
+    @builtins.property
+    @jsii.member(jsii_name="type")
+    def type(self) -> typing.Optional[builtins.str]:
+        '''Type name.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "type"))
+
+    @builtins.property
+    @jsii.member(jsii_name="workers")
+    def workers(self) -> typing.Optional[jsii.Number]:
+        '''Enables dedicated thread(s) for this output.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workers"))
+
+    @builtins.property
+    @jsii.member(jsii_name="writeOperation")
+    def write_operation(self) -> typing.Optional[builtins.str]:
+        '''Operation to use to write in bulk requests.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "writeOperation"))
+
+
+class FluentBitJsonParser(
+    FluentBitParserPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowCrawlerPredicate",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitJsonParser",
 ):
-    '''Represents a condition that is predicated on a Glue crawler completion.
-
-    The condition can be used to create a trigger that controls the execution of
-    downstream tasks in a workflow.
-    '''
+    '''A Fluent Bit filter that parsed inbound messages in JSON format.'''
 
     def __init__(
         self,
-        crawler: ICrawler,
+        name: builtins.str,
         *,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[CrawlerState] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the WorkflowCrawlerPredicate class.
+        '''Creates a new instance of the FluentBitJsonParser class.
 
-        :param crawler: The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
-        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param name: -
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a18ab964f00a29725095bfb40c5b43949ff4de4430650c9d95b535e4941cfc7a)
-            check_type(argname="argument crawler", value=crawler, expected_type=type_hints["crawler"])
-        options = WorkflowCrawlerPredicateOptions(
-            logical_operator=logical_operator,
-            state=state,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
+            type_hints = typing.get_type_hints(_typecheckingstub__9667bfd8f45c5a175656e36d9ad7b4db85b5e7feb83c1e2fc34acbbea82478a0)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitJsonParserOptions(
+            time_format=time_format, time_key=time_key
+        )
+
+        jsii.create(self.__class__, self, [name, options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1256282bf7828450eaecad96fbe7ce7a18dbb436f8a9946b3251e80084c75330)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeFormat")
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+
+class FluentBitKinesisFirehoseOutput(
+    FluentBitOutputPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisFirehoseOutput",
+):
+    '''Represents configuration for outputing logs from Fluent Bit to Kinesis Firehose.'''
+
+    def __init__(
+        self,
+        *,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
+        delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
+
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param compression: Compression type for Firehose records. Each log record is individually compressed and sent to Firehose.
+        :param delivery_stream: The Kinesis Firehose Delivery stream that you want log records sent to.
+        :param endpoint: Specify a custom endpoint for the Firehose API.
+        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+        :param time_key: Add the timestamp to the record under this key.
+        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitKinesisFirehoseOutputOptions(
+            auto_retry_requests=auto_retry_requests,
+            compression=compression,
+            delivery_stream=delivery_stream,
+            endpoint=endpoint,
+            log_key=log_key,
             region=region,
+            role=role,
+            sts_endpoint=sts_endpoint,
+            time_key=time_key,
+            time_key_format=time_key_format,
+            match=match,
         )
 
-        jsii.create(self.__class__, self, [crawler, options])
+        jsii.create(self.__class__, self, [options])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
-        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
 
-        :param scope: The construct configuring the Glue trigger.
+        :param scope: The construct configuring logging using Fluent Bit.
 
         :return:
 
-        A configuration object that can be used to configure a predicate
-        condition for the Glue trigger.
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ab6c6045286c50786550fc825f10c79429ddaf99441ba9be931f3575ea02ea64)
+            type_hints = typing.get_type_hints(_typecheckingstub__dcda296c8eede11fa4ddcc3c2feb2e785012111fa86135f95b451f948f97bd08)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="autoRetryRequests")
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
+
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
 
     @builtins.property
-    @jsii.member(jsii_name="crawler")
-    def crawler(self) -> ICrawler:
-        '''The crawler which must complete in order to meet the requirements to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="compression")
+    def compression(self) -> typing.Optional[KinesisFirehoseCompressionFormat]:
+        '''Compression type for Firehose records.
+
+        Each log record is individually
+        compressed and sent to Firehose.
 
-        :see: `Trigger Predicate.Conditions.CrawlerName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlername>`_
         :group: Inputs
         '''
-        return typing.cast(ICrawler, jsii.get(self, "crawler"))
+        return typing.cast(typing.Optional[KinesisFirehoseCompressionFormat], jsii.get(self, "compression"))
 
     @builtins.property
-    @jsii.member(jsii_name="logicalOperator")
-    def logical_operator(self) -> PredicateLogicalOperator:
-        '''The logical operator which should be applied in determining whether a crawler meets the requested conditions.
+    @jsii.member(jsii_name="deliveryStream")
+    def delivery_stream(self) -> typing.Optional[_IDeliveryStream_cf5feed7]:
+        '''The Kinesis Firehose Delivery stream that you want log records sent to.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_IDeliveryStream_cf5feed7], jsii.get(self, "deliveryStream"))
 
-        At the moment, the only supported operator is ``EQUALS``.
+    @builtins.property
+    @jsii.member(jsii_name="endpoint")
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the Firehose API.
 
-        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
+        :group: Inputs
         '''
-        return typing.cast(PredicateLogicalOperator, jsii.get(self, "logicalOperator"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
 
     @builtins.property
-    @jsii.member(jsii_name="state")
-    def state(self) -> CrawlerState:
-        '''The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="logKey")
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to Firehose.
+
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to Firehose.
 
-        :see: `Trigger Predicate.Conditions.CrawlState <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlstate>`_
+        :group: Inputs
         '''
-        return typing.cast(CrawlerState, jsii.get(self, "state"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
 
+    @builtins.property
+    @jsii.member(jsii_name="region")
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
+
+    @builtins.property
+    @jsii.member(jsii_name="role")
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
+
+    @builtins.property
+    @jsii.member(jsii_name="stsEndpoint")
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''Add the timestamp to the record under this key.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKeyFormat")
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''A strftime compliant format string for the timestamp.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+
+
+class FluentBitKinesisOutput(
+    FluentBitOutputPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisOutput",
+):
+    '''Represents configuration for outputing logs from Fluent Bit to Kinesis Data Streams.'''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowCrawlerPredicateOptions",
-    jsii_struct_bases=[WorkflowPredicateOptions],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "logical_operator": "logicalOperator",
-        "state": "state",
-    },
-)
-class WorkflowCrawlerPredicateOptions(WorkflowPredicateOptions):
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
+        auto_retry_requests: typing.Optional[builtins.bool] = None,
+        endpoint: typing.Optional[builtins.str] = None,
+        log_key: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[CrawlerState] = None,
-    ) -> None:
-        '''Configuration options that specify the state a crawler must meet in order to satisfy the conditions of the predicate.
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
+        sts_endpoint: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitKinesisOutput class.
+
+        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
+        :param endpoint: Specify a custom endpoint for the Firehose API.
+        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
+        :param region: The AWS region.
+        :param role: ARN of an IAM role to assume (for cross account access).
+        :param stream: The name of the Kinesis Streams Delivery stream that you want log records sent to.
+        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
+        :param time_key: Add the timestamp to the record under this key.
+        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitKinesisOutputOptions(
+            auto_retry_requests=auto_retry_requests,
+            endpoint=endpoint,
+            log_key=log_key,
+            region=region,
+            role=role,
+            stream=stream,
+            sts_endpoint=sts_endpoint,
+            time_key=time_key,
+            time_key_format=time_key_format,
+            match=match,
+        )
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param logical_operator: The logical operator which should be applied in determining whether a crawler meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
+        jsii.create(self.__class__, self, [options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b34c0d221b3673906a9840fa8262a73d533de41c6c0f80b688d92ba11c4e20a1)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument logical_operator", value=logical_operator, expected_type=type_hints["logical_operator"])
-            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if logical_operator is not None:
-            self._values["logical_operator"] = logical_operator
-        if state is not None:
-            self._values["state"] = state
+            type_hints = typing.get_type_hints(_typecheckingstub__4bf7e0507e4e17249fa3d68d625e57e70517c7cc3ef3896715e32aac5c34c20a)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    @jsii.member(jsii_name="autoRetryRequests")
+    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
+        '''Immediately retry failed requests to AWS services once.
+
+        This option does
+        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
+        it enables an immediate retry with no delay for networking errors, which
+        may help improve throughput when there are transient/random networking
+        issues.
 
-        :default: - the resource is in the same account as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    @jsii.member(jsii_name="endpoint")
+    def endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom endpoint for the Firehose API.
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    @builtins.property
+    @jsii.member(jsii_name="logKey")
+    def log_key(self) -> typing.Optional[builtins.str]:
+        '''By default, the whole log record will be sent to Firehose.
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        If you
+        specify a key name with this option, then only the value of that key
+        will be sent to Firehose.
+
+        :group: Inputs
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    @jsii.member(jsii_name="region")
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+    @builtins.property
+    @jsii.member(jsii_name="role")
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''ARN of an IAM role to assume (for cross account access).
+
+        :group: Inputs
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="stream")
+    def stream(self) -> typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream]:
+        '''The name of the Kinesis Streams Delivery stream that you want log records sent to.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream], jsii.get(self, "stream"))
 
     @builtins.property
-    def logical_operator(self) -> typing.Optional[PredicateLogicalOperator]:
-        '''The logical operator which should be applied in determining whether a crawler meets the requested conditions.
+    @jsii.member(jsii_name="stsEndpoint")
+    def sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify a custom STS endpoint for the AWS STS API.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
 
-        At the moment, the only supported operator is ``EQUALS``.
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''Add the timestamp to the record under this key.
 
-        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
+        :group: Inputs
         '''
-        result = self._values.get("logical_operator")
-        return typing.cast(typing.Optional[PredicateLogicalOperator], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
 
     @builtins.property
-    def state(self) -> typing.Optional[CrawlerState]:
-        '''The state that the crawler must be in in order to meet the criteria to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="timeKeyFormat")
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''A strftime compliant format string for the timestamp.
 
-        :see: `Trigger Predicate.Conditions.CrawlState <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-crawlstate>`_
+        :group: Inputs
         '''
-        result = self._values.get("state")
-        return typing.cast(typing.Optional[CrawlerState], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+class FluentBitLogfmtParser(
+    FluentBitParserPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLogfmtParser",
+):
+    '''A Fluent Bit filter that parsed inbound messages in LTSV format.'''
 
-    def __repr__(self) -> str:
-        return "WorkflowCrawlerPredicateOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
+    def __init__(
+        self,
+        name: builtins.str,
+        *,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitLogfmtParser class.
+
+        :param name: -
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8e25b48b2e66c9db37ff8e8c3719343636a0ede774d594e4e69fefd8f541afc7)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitLogfmtParserOptions(
+            time_format=time_format, time_key=time_key, types=types
         )
 
+        jsii.create(self.__class__, self, [name, options])
 
-@jsii.implements(ITriggerPredicate)
-class WorkflowJobPredicate(
-    WorkflowPredicateBase,
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0a81c3d8601df476452f69214aca18722b70cc833bc61983875ae41787e2ce75)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeFormat")
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="types")
+    def types(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+
+
+class FluentBitLtsvParser(
+    FluentBitParserPluginBase,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.glue.WorkflowJobPredicate",
+    jsii_type="cdk-extensions.k8s_aws.FluentBitLtsvParser",
 ):
-    '''Represents a condition that is predicated on a Glue job completion.
-
-    The condition can be used to create a trigger that controls the execution of
-    downstream tasks in a workflow.
-    '''
+    '''A Fluent Bit filter that parsed inbound messages in LTSV format.'''
 
     def __init__(
         self,
-        job: IJob,
+        name: builtins.str,
         *,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[JobState] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
+        time_format: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
     ) -> None:
-        '''Creates a new instance of the WorkflowJobPredicate class.
+        '''Creates a new instance of the FluentBitLtsvParser class.
 
-        :param job: The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
-        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param name: -
+        :param time_format: Defines the format of the timestamp on the inbound record.
+        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f4c02ff62824c53aba142c5763845ac4a5e58a9cb8f54ede31043c8dba475d26)
-            check_type(argname="argument job", value=job, expected_type=type_hints["job"])
-        options = WorkflowJobPredicateOptions(
-            logical_operator=logical_operator,
-            state=state,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
+            type_hints = typing.get_type_hints(_typecheckingstub__9575880f0d90bc5de7b08966955cdc0ae58d806eef8a52a89f16c51353d5f674)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        options = FluentBitLtsvParserOptions(
+            time_format=time_format, time_key=time_key, types=types
+        )
+
+        jsii.create(self.__class__, self, [name, options])
+
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+
+        :param _scope: The construct configuring logging using Fluent Bit.
+
+        :return:
+
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9cc473e237e03b0900368e7d87fdfbee36d9a7b81802d233cd2091e9fbeed709)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeFormat")
+    def time_format(self) -> typing.Optional[builtins.str]:
+        '''Defines the format of the timestamp on the inbound record.
+
+        :default: Inputs
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''The key under which timestamp information for the inbound record is given.
+
+        :default: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="types")
+    def types(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
+        '''Maps group names matched by the regex to the data types they should be interpreted as.
+
+        :default: Inputs
+        '''
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+
+
+class FluentBitOpenSearchOutput(
+    FluentBitOutputPluginBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.k8s_aws.FluentBitOpenSearchOutput",
+):
+    def __init__(
+        self,
+        *,
+        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
+        aws_auth: typing.Optional[builtins.bool] = None,
+        aws_external_id: typing.Optional[builtins.str] = None,
+        aws_region: typing.Optional[builtins.str] = None,
+        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        aws_sts_endpoint: typing.Optional[builtins.str] = None,
+        buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
+        current_time_index: typing.Optional[builtins.bool] = None,
+        generate_id: typing.Optional[builtins.bool] = None,
+        host: typing.Optional[builtins.str] = None,
+        http_passwd: typing.Optional[builtins.str] = None,
+        http_user: typing.Optional[builtins.str] = None,
+        id_key: typing.Optional[builtins.str] = None,
+        include_tag_key: typing.Optional[builtins.bool] = None,
+        index: typing.Optional[builtins.str] = None,
+        logstash_date_format: typing.Optional[builtins.str] = None,
+        logstash_format: typing.Optional[builtins.bool] = None,
+        logstash_prefix: typing.Optional[builtins.str] = None,
+        logstash_prefix_key: typing.Optional[builtins.str] = None,
+        path: typing.Optional[builtins.str] = None,
+        pipeline: typing.Optional[builtins.str] = None,
+        port: typing.Optional[jsii.Number] = None,
+        replace_dots: typing.Optional[builtins.bool] = None,
+        suppress_type_name: typing.Optional[builtins.bool] = None,
+        tag_key: typing.Optional[builtins.str] = None,
+        time_key: typing.Optional[builtins.str] = None,
+        time_key_format: typing.Optional[builtins.str] = None,
+        time_key_nanos: typing.Optional[builtins.bool] = None,
+        trace_error: typing.Optional[builtins.bool] = None,
+        trace_output: typing.Optional[builtins.bool] = None,
+        type: typing.Optional[builtins.str] = None,
+        workers: typing.Optional[jsii.Number] = None,
+        write_operation: typing.Optional[builtins.str] = None,
+        match: typing.Optional[FluentBitMatch] = None,
+    ) -> None:
+        '''Creates a new instance of the FluentBitOpenSearchOutput class.
+
+        :param domain: The Opensearch domain to which logs should be shipped.
+        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon OpenSearch Service. Default: false
+        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
+        :param aws_region: Specify the AWS region for Amazon OpenSearch Service.
+        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
+        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
+        :param buffer_size: Specify the buffer size used to read the response from the OpenSearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
+        :param current_time_index: Use current time for index generation instead of message record. Default: false
+        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
+        :param host: IP address or hostname of the target OpenSearch instance.
+        :param http_passwd: Password for user defined in ``httpUser``.
+        :param http_user: Optional username credential for access.
+        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+        :param include_tag_key: When enabled, it append the Tag name to the record.
+        :param index: Index name. Default: 'fluent-bit
+        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
+        :param logstash_format: Enable Logstash format compatibility. Default: false
+        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
+        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
+        :param path: OpenSearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve OpenSearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
+        :param pipeline: OpenSearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
+        :param port: TCP port of the target OpenSearch instance. Default: 9200
+        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
+        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
+        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
+        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
+        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
+        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
+        :param trace_error: When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only). Default: false
+        :param trace_output: When enabled print the OpenSearch API calls to stdout (for diag only). Default: false
+        :param type: Type name. Default: '_doc'
+        :param workers: Enables dedicated thread(s) for this output. Default: 2
+        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
+        :param match: The pattern to match for records that this output should apply to.
+        '''
+        options = FluentBitOpenSearchOutputOptions(
+            domain=domain,
+            aws_auth=aws_auth,
+            aws_external_id=aws_external_id,
+            aws_region=aws_region,
+            aws_role=aws_role,
+            aws_sts_endpoint=aws_sts_endpoint,
+            buffer_size=buffer_size,
+            current_time_index=current_time_index,
+            generate_id=generate_id,
+            host=host,
+            http_passwd=http_passwd,
+            http_user=http_user,
+            id_key=id_key,
+            include_tag_key=include_tag_key,
+            index=index,
+            logstash_date_format=logstash_date_format,
+            logstash_format=logstash_format,
+            logstash_prefix=logstash_prefix,
+            logstash_prefix_key=logstash_prefix_key,
+            path=path,
+            pipeline=pipeline,
+            port=port,
+            replace_dots=replace_dots,
+            suppress_type_name=suppress_type_name,
+            tag_key=tag_key,
+            time_key=time_key,
+            time_key_format=time_key_format,
+            time_key_nanos=time_key_nanos,
+            trace_error=trace_error,
+            trace_output=trace_output,
+            type=type,
+            workers=workers,
+            write_operation=write_operation,
+            match=match,
         )
 
-        jsii.create(self.__class__, self, [job, options])
+        jsii.create(self.__class__, self, [options])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> _aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty:
-        '''Associates the predicate with a construct that is configuring a trigger for a Glue workflow.
+    ) -> ResolvedFluentBitConfiguration:
+        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
 
-        :param scope: The construct configuring the Glue trigger.
+        :param scope: The construct configuring logging using Fluent Bit.
 
         :return:
 
-        A configuration object that can be used to configure a predicate
-        condition for the Glue trigger.
+        A configuration for the plugin that con be used by the resource
+        configuring logging.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__052b1ed2cea96b32b65c6bcbd0903b2b8d644c2532b12858e569decfda630d36)
+            type_hints = typing.get_type_hints(_typecheckingstub__33bba3952c545b0c433e0348981b5b24158f45f87bd95dd02431e2b4b4656a81)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(_aws_cdk_aws_glue_ceddda9d.CfnTrigger.ConditionProperty, jsii.invoke(self, "bind", [scope]))
+        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="job")
-    def job(self) -> IJob:
-        '''The job which must complete in order to meet the requirements to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="domain")
+    def domain(self) -> _aws_cdk_aws_opensearchservice_ceddda9d.IDomain:
+        '''The Opensearch domain to which logs should be shipped.
 
-        :see: `Trigger Predicate.Conditions.JobName <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-jobname>`_
         :group: Inputs
         '''
-        return typing.cast(IJob, jsii.get(self, "job"))
+        return typing.cast(_aws_cdk_aws_opensearchservice_ceddda9d.IDomain, jsii.get(self, "domain"))
 
     @builtins.property
-    @jsii.member(jsii_name="logicalOperator")
-    def logical_operator(self) -> PredicateLogicalOperator:
-        '''The logical operator which should be applied in determining whether a job meets the requested conditions.
+    @jsii.member(jsii_name="port")
+    def port(self) -> jsii.Number:
+        '''TCP port of the target OpenSearch instance.
 
-        At the moment, the only supported operator is ``EQUALS``.
+        :group: Inputs
+        '''
+        return typing.cast(jsii.Number, jsii.get(self, "port"))
+
+    @builtins.property
+    @jsii.member(jsii_name="awsAuth")
+    def aws_auth(self) -> typing.Optional[builtins.bool]:
+        '''Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
 
-        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
         :group: Inputs
         '''
-        return typing.cast(PredicateLogicalOperator, jsii.get(self, "logicalOperator"))
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "awsAuth"))
 
     @builtins.property
-    @jsii.member(jsii_name="state")
-    def state(self) -> JobState:
-        '''The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="awsExternalId")
+    def aws_external_id(self) -> typing.Optional[builtins.str]:
+        '''External ID for the AWS IAM Role specified with ``awsRole``.
 
-        :see: `Trigger Predicate.Conditions.State <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-state>`_
         :group: Inputs
         '''
-        return typing.cast(JobState, jsii.get(self, "state"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsExternalId"))
 
+    @builtins.property
+    @jsii.member(jsii_name="awsRegion")
+    def aws_region(self) -> typing.Optional[builtins.str]:
+        '''Specify the AWS region for Amazon OpenSearch Service.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.glue.WorkflowJobPredicateOptions",
-    jsii_struct_bases=[WorkflowPredicateOptions],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "logical_operator": "logicalOperator",
-        "state": "state",
-    },
-)
-class WorkflowJobPredicateOptions(WorkflowPredicateOptions):
-    def __init__(
-        self,
-        *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-        state: typing.Optional[JobState] = None,
-    ) -> None:
-        '''Configuration options that specify the state a job must meet in order to satisfy the conditions of the predicate.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsRegion"))
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param logical_operator: The logical operator which should be applied in determining whether a job meets the requested conditions. At the moment, the only supported operator is ``EQUALS``.
-        :param state: The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+    @builtins.property
+    @jsii.member(jsii_name="awsRole")
+    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''AWS IAM Role to assume to put records to your Amazon cluster.
+
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__72482740085b262df0b54ed41b3b29c654ded6f27c0575af036d20ebf4fff046)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument logical_operator", value=logical_operator, expected_type=type_hints["logical_operator"])
-            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if logical_operator is not None:
-            self._values["logical_operator"] = logical_operator
-        if state is not None:
-            self._values["state"] = state
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "awsRole"))
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+    @jsii.member(jsii_name="awsStsEndpoint")
+    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
+        '''Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
 
-        :default: - the resource is in the same account as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsStsEndpoint"))
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    @jsii.member(jsii_name="bufferSize")
+    def buffer_size(self) -> typing.Optional[OpenSearchOutputBufferSize]:
+        '''Specify the buffer size used to read the response from the OpenSearch HTTP service.
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+        This option is useful for debugging purposes where is
+        required to read full responses, note that response size grows depending
+        of the number of records inserted.
 
-        Cannot be supplied together with either ``account`` or ``region``.
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[OpenSearchOutputBufferSize], jsii.get(self, "bufferSize"))
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+    @builtins.property
+    @jsii.member(jsii_name="currentTimeIndex")
+    def current_time_index(self) -> typing.Optional[builtins.bool]:
+        '''Use current time for index generation instead of message record.
+
+        :group: Inputs
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "currentTimeIndex"))
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    @jsii.member(jsii_name="generateId")
+    def generate_id(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, generate ``_id`` for outgoing records.
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+        This prevents duplicate
+        records when retrying.
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+        :group: Inputs
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "generateId"))
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="httpPasswd")
+    def http_passwd(self) -> typing.Optional[builtins.str]:
+        '''Password for user defined in ``httpUser``.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :group: Inputs
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpPasswd"))
+
+    @builtins.property
+    @jsii.member(jsii_name="httpUser")
+    def http_user(self) -> typing.Optional[builtins.str]:
+        '''Optional username credential for access.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpUser"))
 
     @builtins.property
-    def logical_operator(self) -> typing.Optional[PredicateLogicalOperator]:
-        '''The logical operator which should be applied in determining whether a job meets the requested conditions.
+    @jsii.member(jsii_name="idKey")
+    def id_key(self) -> typing.Optional[builtins.str]:
+        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idKey"))
 
-        At the moment, the only supported operator is ``EQUALS``.
+    @builtins.property
+    @jsii.member(jsii_name="includeTagKey")
+    def include_tag_key(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, it append the Tag name to the record.
 
-        :see: `Trigger Predicate.Conditions.LogicalOperator <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-logicaloperator>`_
+        :group: Inputs
         '''
-        result = self._values.get("logical_operator")
-        return typing.cast(typing.Optional[PredicateLogicalOperator], result)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagKey"))
 
     @builtins.property
-    def state(self) -> typing.Optional[JobState]:
-        '''The state that the job must be in in order to meet the criteria to trigger the next stage of the workflow.
+    @jsii.member(jsii_name="index")
+    def index(self) -> typing.Optional[builtins.str]:
+        '''Index name.
 
-        :see: `Trigger Predicate.Conditions.State <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-glue-trigger-condition.html#cfn-glue-trigger-condition-state>`_
+        :group: Inputs
         '''
-        result = self._values.get("state")
-        return typing.cast(typing.Optional[JobState], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "index"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="logstashDateFormat")
+    def logstash_date_format(self) -> typing.Optional[builtins.str]:
+        '''Time format (based on strftime) to generate the second part of the Index name.
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashDateFormat"))
 
-    def __repr__(self) -> str:
-        return "WorkflowJobPredicateOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="logstashFormat")
+    def logstash_format(self) -> typing.Optional[builtins.bool]:
+        '''Enable Logstash format compatibility.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "logstashFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashPrefix")
+    def logstash_prefix(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+
+        The last string appended belongs to the date when the data is being
+        generated.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefix"))
+
+    @builtins.property
+    @jsii.member(jsii_name="logstashPrefixKey")
+    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
+        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
+
+        If
+        the key/value is not found in the record then the ``logstashPrefix`` option
+        will act as a fallback.
+
+        Nested keys are not supported (if desired, you can use the nest filter
+        plugin to remove nesting).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefixKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="path")
+    def path(self) -> typing.Optional[builtins.str]:
+        '''OpenSearch accepts new data on HTTP query path "/_bulk".
+
+        But it is also
+        possible to serve OpenSearch behind a reverse proxy on a subpath. This
+        option defines such path on the fluent-bit side. It simply adds a path
+        prefix in the indexing HTTP POST URI.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "path"))
+
+    @builtins.property
+    @jsii.member(jsii_name="pipeline")
+    def pipeline(self) -> typing.Optional[builtins.str]:
+        '''OpenSearch allows to setup filters called pipelines.
+
+        This option allows
+        to define which pipeline the database should use.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pipeline"))
+
+    @builtins.property
+    @jsii.member(jsii_name="replaceDots")
+    def replace_dots(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, replace field name dots with underscore.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "replaceDots"))
+
+    @builtins.property
+    @jsii.member(jsii_name="suppressTypeName")
+    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
+        '''When enabled, mapping types is removed and ``type`` option is ignored.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "suppressTypeName"))
+
+    @builtins.property
+    @jsii.member(jsii_name="tagKey")
+    def tag_key(self) -> typing.Optional[builtins.str]:
+        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKey")
+    def time_key(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+
+        The``timeKey`` property defines the name of that field.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKeyFormat")
+    def time_key_format(self) -> typing.Optional[builtins.str]:
+        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+
+        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+
+    @builtins.property
+    @jsii.member(jsii_name="timeKeyNanos")
+    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
+        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "timeKeyNanos"))
+
+    @builtins.property
+    @jsii.member(jsii_name="traceError")
+    def trace_error(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceError"))
+
+    @builtins.property
+    @jsii.member(jsii_name="traceOutput")
+    def trace_output(self) -> typing.Optional[builtins.bool]:
+        '''When enabled print the OpenSearch API calls to stdout (for diag only).
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceOutput"))
+
+    @builtins.property
+    @jsii.member(jsii_name="type")
+    def type(self) -> typing.Optional[builtins.str]:
+        '''Type name.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "type"))
+
+    @builtins.property
+    @jsii.member(jsii_name="workers")
+    def workers(self) -> typing.Optional[jsii.Number]:
+        '''Enables dedicated thread(s) for this output.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workers"))
+
+    @builtins.property
+    @jsii.member(jsii_name="writeOperation")
+    def write_operation(self) -> typing.Optional[builtins.str]:
+        '''Operation to use to write in bulk requests.
+
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "writeOperation"))
 
 
 __all__ = [
-    "ArrayColumn",
-    "ArrayColumnProps",
-    "AssetCode",
-    "BasicColumn",
-    "BasicColumnProps",
-    "BookmarkConfiguration",
-    "BookmarkRange",
-    "ClassificationString",
-    "CloudWatchEncryption",
-    "CloudWatchEncryptionMode",
-    "Code",
-    "CodeConfig",
-    "Column",
-    "ColumnProps",
-    "ConfigurationVersion",
-    "Connection",
-    "ConnectionProps",
-    "ConnectionType",
-    "ContinuousLoggingProps",
-    "Crawler",
-    "CrawlerConfiguration",
-    "CrawlerProps",
-    "CrawlerState",
-    "CrawlerTargetCollection",
-    "DataFormat",
-    "DataFormatProps",
-    "Database",
-    "DatabaseProps",
-    "DeleteBehavior",
-    "GlueVersion",
-    "ICrawler",
-    "ICrawlerTarget",
-    "IJob",
-    "ITrigger",
-    "ITriggerAction",
-    "ITriggerPredicate",
-    "InputFormat",
-    "JdbcConnection",
-    "JdbcConnectionProps",
-    "JdbcTarget",
-    "JdbcTargetOptions",
-    "Job",
-    "JobBookmarksEncryption",
-    "JobBookmarksEncryptionMode",
-    "JobExecutable",
-    "JobExecutableConfig",
-    "JobLanguage",
-    "JobProps",
-    "JobState",
-    "JobType",
-    "OutputFormat",
-    "PartitionUpdateBehavior",
-    "PredicateLogicalOperator",
-    "PredicateOperator",
-    "PythonShellExecutableProps",
-    "PythonSparkJobExecutableProps",
-    "PythonVersion",
-    "RecrawlBehavior",
-    "S3Code",
-    "S3Encryption",
-    "S3EncryptionMode",
-    "S3Target",
-    "S3TargetOptions",
-    "ScalaJobExecutableProps",
-    "SecurityConfiguration",
-    "SecurityConfigurationProps",
-    "SerializationLibrary",
-    "StructColumn",
-    "StructColumnProps",
-    "Table",
-    "TableGroupingPolicy",
-    "TableProps",
-    "TableType",
-    "TableUpdateBehavior",
-    "Trigger",
-    "TriggerOptions",
-    "TriggerProps",
-    "TriggerType",
-    "UpdateBehavior",
-    "WorkerType",
-    "Workflow",
-    "WorkflowAction",
-    "WorkflowActionBase",
-    "WorkflowActionOptions",
-    "WorkflowCrawlerAction",
-    "WorkflowCrawlerActionOptions",
-    "WorkflowCrawlerPredicate",
-    "WorkflowCrawlerPredicateOptions",
-    "WorkflowJobAction",
-    "WorkflowJobActionOptions",
-    "WorkflowJobPredicate",
-    "WorkflowJobPredicateOptions",
-    "WorkflowPredicate",
-    "WorkflowPredicateBase",
-    "WorkflowPredicateOptions",
-    "WorkflowProps",
+    "AdotCollector",
+    "AdotCollectorProps",
+    "AppendedRecord",
+    "AwsSecretStore",
+    "AwsSecretStoreProps",
+    "AwsServiceDiscoveryRegistry",
+    "Echoserver",
+    "EchoserverProps",
+    "ElasticsearchCompressionFormat",
+    "ElasticsearchOutputBufferSize",
+    "EmitterStorageType",
+    "ExternalDnsLogFormat",
+    "ExternalDnsLogLevel",
+    "ExternalDnsRegistry",
+    "ExternalDnsRegistryConfiguration",
+    "ExternalDnsSyncPolicy",
+    "ExternalDnsZoneTag",
+    "ExternalDnsZoneType",
+    "ExternalSecret",
+    "ExternalSecretOptions",
+    "ExternalSecretProps",
+    "ExternalSecretsOperator",
+    "ExternalSecretsOperatorProps",
+    "FargateLogger",
+    "FargateLoggerOptions",
+    "FargateLoggerProps",
+    "FluentBitCloudWatchLogsOutput",
+    "FluentBitCloudWatchLogsOutputOptions",
+    "FluentBitElasticsearchOutput",
+    "FluentBitElasticsearchOutputOptions",
+    "FluentBitFilter",
+    "FluentBitFilterPluginBase",
+    "FluentBitFilterPluginCommonOptions",
+    "FluentBitGrepFilter",
+    "FluentBitGrepFilterOptions",
+    "FluentBitGrepRegex",
+    "FluentBitJsonParser",
+    "FluentBitJsonParserOptions",
+    "FluentBitKinesisFirehoseOutput",
+    "FluentBitKinesisFirehoseOutputOptions",
+    "FluentBitKinesisOutput",
+    "FluentBitKinesisOutputOptions",
+    "FluentBitKubernetesFilter",
+    "FluentBitKubernetesFilterOptions",
+    "FluentBitLogGroupOutput",
+    "FluentBitLogStreamOutput",
+    "FluentBitLogfmtParser",
+    "FluentBitLogfmtParserOptions",
+    "FluentBitLtsvParser",
+    "FluentBitLtsvParserOptions",
+    "FluentBitMatch",
+    "FluentBitMatchEvaluator",
+    "FluentBitModifyFilter",
+    "FluentBitModifyFilterOptions",
+    "FluentBitNestFilter",
+    "FluentBitNestFilterOptions",
+    "FluentBitOpenSearchOutput",
+    "FluentBitOpenSearchOutputOptions",
+    "FluentBitOutput",
+    "FluentBitOutputPluginBase",
+    "FluentBitOutputPluginCommonOptions",
+    "FluentBitParser",
+    "FluentBitParserFilter",
+    "FluentBitParserFilterOptions",
+    "FluentBitParserPluginBase",
+    "FluentBitParserPluginCommonOptions",
+    "FluentBitPlugin",
+    "FluentBitPluginCommonOptions",
+    "FluentBitPluginType",
+    "FluentBitRecordModifierFilter",
+    "FluentBitRecordModifierFilterOptions",
+    "FluentBitRegexParser",
+    "FluentBitRegexParserOptions",
+    "FluentBitRewriteTagFilter",
+    "FluentBitRewriteTagFilterOptions",
+    "FluentBitThrottleFilter",
+    "FluentBitThrottleFilterOptions",
+    "IExternalDnsRegistry",
+    "IFluentBitFilterPlugin",
+    "IFluentBitOutputPlugin",
+    "IFluentBitParserPlugin",
+    "IFluentBitPlugin",
+    "INestFilterOperation",
+    "ISecretReference",
+    "ISecretStore",
+    "KinesisFirehoseCompressionFormat",
+    "LiftOptions",
+    "MetadataPolicy",
+    "ModifyCondition",
+    "ModifyOperation",
+    "NamespacedExternalSecretOptions",
+    "NestFilterOperation",
+    "NestFilterOperationType",
+    "NestOptions",
+    "NoopRegistry",
+    "OpenSearchOutputBufferSize",
+    "ParserPluginDataType",
+    "ResolvedFluentBitConfiguration",
+    "RewriteTagRule",
+    "Route53Dns",
+    "Route53DnsOptions",
+    "Route53DnsProps",
+    "SecretFieldReference",
+    "SecretReferenceConfiguration",
+    "SecretsManagerReference",
+    "SecretsManagerReferenceOptions",
+    "SecretsManagerSecretStore",
+    "SecretsManagerSecretStoreProps",
+    "SsmParameterReference",
+    "SsmParameterReferenceOptions",
+    "SsmParameterSecretStore",
+    "SsmParameterSecretStoreProps",
+    "TxtRegistry",
+    "TxtRegistryOptions",
 ]
 
 publication.publish()
 
-def _typecheckingstub__b04343485dce8549add35ec976d45544630deb5d79090df76b4018e3f8074592(
-    value: builtins.str,
+def _typecheckingstub__f74f3540f9b92e5b04d00972307fd2234b5b3488c35a04325788dc39ab7af1c1(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
-    from_: builtins.str,
-    to: builtins.str,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    create_namespace: typing.Optional[builtins.bool] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2301b86dad3c792d837e86052ee0890dc5b59ce6914adc7fa3fd599e7ab75ccd(
+def _typecheckingstub__83410ce825ec752c0effc192594680947acd69763ae265765f04ad25b86fed2c(
     *,
-    from_: builtins.str,
-    to: builtins.str,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    create_namespace: typing.Optional[builtins.bool] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0751f5d6215bb74e22139fe2149a7f9ee7de61eb00daa8638767d444fd2006ff(
+def _typecheckingstub__136b7ffe7a51d2c8e1beb7845cc437b6f9c909db4c6852bf9306bb992440df64(
+    *,
+    field_name: builtins.str,
     value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__057163656b87fc4eb457b7ce6af51ebca528e50d7d1d66f6c8cb0392e039ac1a(
+def _typecheckingstub__47bd0514e52ab251753fed926ac3aec8ea7a2344e24eb13a2eeacbcf646482c3(
     *,
-    mode: CloudWatchEncryptionMode,
-    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    service: builtins.str,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__fe5f72a2d529dee4e5a4fd60ab73c3651fdb154cc1ac378fcf8a4c6cc14f7f47(
-    path: builtins.str,
+def _typecheckingstub__60e02c2df9c0996603c08992bffb8b230ed1d150d3db1a8f557f6056710b9fda(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
-    asset_hash: typing.Optional[builtins.str] = None,
-    asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
-    bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__0ae28ae94ca6a7f468c50a4d7ca53e509947843d875b01df05b54a3d3035fe76(
-    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
-    key: builtins.str,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
+    load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    port: typing.Optional[jsii.Number] = None,
+    replicas: typing.Optional[jsii.Number] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+    subdomain: typing.Optional[builtins.str] = None,
+    tag: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__29827b2153002e81b9ff9677022a59a77e67b7c0083100827663e2e422bda0db(
-    scope: _constructs_77d1e7e8.Construct,
-    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+def _typecheckingstub__03259ca27e67ce6d4b989554c5fe17209a196689cf650ff94b81215ab7406124(
+    domain: _Domain_165656f2,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f929a25191cf84849ac8dc0774c3d7cb58e7913b1ffa7fc2fbca5cb55667291c(
+def _typecheckingstub__cabc692f43b347b0dcc6dbe743c4a7fac3e1c95cc035ff3ff3ef2509fdef86f5(
     *,
-    s3_location: typing.Union[_aws_cdk_aws_s3_ceddda9d.Location, typing.Dict[builtins.str, typing.Any]],
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
+    load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    port: typing.Optional[jsii.Number] = None,
+    replicas: typing.Optional[jsii.Number] = None,
+    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
+    subdomain: typing.Optional[builtins.str] = None,
+    tag: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__444e4405d6fa32714b3fa80c1a990dc679108d516ba2f551601636ba37108c5e(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__91e43731ac6990c08b0792ace3a0c1b48a1f889b6e8d07aca71215174e81ac73(
+    size: _DataSize_d20aaece,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2acc8cf451159a8d67a7210893d3fff8ebd56626ab3a55b71a5a7d60b58fa6f2(
-    *,
-    comment: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
+def _typecheckingstub__9124585821a9391bca778d97002afbc3198cbd561399fa87a8e71b45d6ce6eb5(
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__023b7dc3d20f72ca57c6c81f464fce932d96d952762ad3a3710109c3be2e676c(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
-    *,
-    connection_type: ConnectionType,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__30778af9523211391b3ca0fed378de136c18bf69752f8852717af5a49e4655da(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a45f2c7f57ece25b2ed1a81fd7f6d3d5c0fe1afcbef8310db8d03a698c138480(
-    value: builtins.str,
+def _typecheckingstub__5f7c8fd432fc4f5005a0f643a18e84adbdbe3cd99f8b0197a9c3b88356ab4c36(
+    *,
+    registry_type: builtins.str,
+    permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
+    properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1eee3a4bfe7ee7514d7510a9f817a30f05617f0049f9d10ada9cc135e1b8ab26(
+def _typecheckingstub__575b91a9d80cdb1a92d59c32aa69e6b72bae0ee5d1b726d04016341d1d05ce2b(
+    *,
     key: builtins.str,
     value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0af32a3c84c0678710e524ede720205f2f84097eea14da00eb58b5d5f043557b(
+def _typecheckingstub__49513e201186ba37d9ef6756fce415cce3648eed2fa385f3e5f55eb6a5fa9de3(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    secret_store: ISecretStore,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    secrets: typing.Optional[typing.Sequence[ISecretReference]] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    connection_type: ConnectionType,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    properties: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c8560efd79afaf7b7778442a94c024de5f4c8f79564e4c191018f7871c34b5e6(
-    *,
-    enabled: builtins.bool,
-    conversion_pattern: typing.Optional[builtins.str] = None,
-    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    log_stream_prefix: typing.Optional[builtins.str] = None,
-    quiet: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__19eb3b7d91a4e74eaaed7fe7ee26f9301db18656d2c4d7d673df35310e1e67f9(
+    secret: ISecretReference,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__51a7512576b1965463466002ce33610505de95eb6d8629c5243e563c30f4f20f(
+def _typecheckingstub__9c48bcfa2d2f0d5e393569b187f9c8953494e5941b2210c23840aa29af16ef83(
     *,
-    partition_update_behavior: typing.Optional[PartitionUpdateBehavior] = None,
-    table_grouping_policy: typing.Optional[TableGroupingPolicy] = None,
-    table_level: typing.Optional[jsii.Number] = None,
-    table_update_behavior: typing.Optional[TableUpdateBehavior] = None,
-    version: typing.Optional[ConfigurationVersion] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2280b17fb14a2d4a9a875511f4dcee118bd04236b81ae5e543e8502074f74f5c(
+def _typecheckingstub__d11fa008f8a05b0740f0561849e56b56d7a687389f3927a388801e0c2089baa9(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
-    configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
-    database: typing.Optional[Database] = None,
-    delete_behavior: typing.Optional[DeleteBehavior] = None,
-    description: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    secret_store: ISecretStore,
     name: typing.Optional[builtins.str] = None,
-    recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
-    schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    security_configuration: typing.Optional[SecurityConfiguration] = None,
-    table_prefix: typing.Optional[builtins.str] = None,
-    targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
-    update_behavior: typing.Optional[UpdateBehavior] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    secrets: typing.Optional[typing.Sequence[ISecretReference]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a8896893a8fc4935daa0226b1e3669e65b536c6438cba018169f71f1a6aed7e3(
+def _typecheckingstub__92e0a4c21b4ba5a2e251aa667f38097598f22ba362cbd427dd404bbdc22ab5f6(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
-    catalog_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.CatalogTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-    dynamo_db_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.DynamoDBTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-    jdbc_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.JdbcTargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
-    s3_targets: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_glue_ceddda9d.CfnCrawler.S3TargetProperty, typing.Dict[builtins.str, typing.Any]]]] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
+    create_namespace: typing.Optional[builtins.bool] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dbf6d8049cc8299102bda3d0f4fcaafe4f62969715f5334320a23b3330bfc2e5(
+def _typecheckingstub__90685b99b2a2f337bfa2d47df40412c9b581b614b6fbaa7d3c94b067a6d562f9(
+    id: builtins.str,
+    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
     *,
-    input_format: InputFormat,
-    output_format: OutputFormat,
-    serialization_library: SerializationLibrary,
-    classification_string: typing.Optional[ClassificationString] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__45c3b158089c46e13d9c49f0ca36070229ef0a94859ba845783419cef5407fba(
-    scope: _constructs_77d1e7e8.Construct,
+def _typecheckingstub__bb968a0fa40a926483b03cb5417298b5375e8cd4b95be82c6d873ca8dc69a994(
     id: builtins.str,
+    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
     *,
-    description: typing.Optional[builtins.str] = None,
-    location_uri: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
     name: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a77b0078ad516d66ca8ca0d633ac0257b13a89e52152799cdfab2d5f1bd3e906(
+    *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
+    create_namespace: typing.Optional[builtins.bool] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0d611ab4143e7ce164987eed2bc3acb7d2232995b6cb14a3be53384f6c67d983(
+def _typecheckingstub__76dae8c2dfe10754d7c019d5c1c2151516afb99c60c1df33bb81b24d3b938dd3(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
+    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
+    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    description: typing.Optional[builtins.str] = None,
-    location_uri: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__afef4db7c413ec6c4abe2a7c38e51c3df056fd2eba5fcd9b37a75a1490334595(
-    version: builtins.str,
+def _typecheckingstub__b703c0764bfdf16eb126c71eab2089fc0d5d0baedeb889a2ab4b2d0a6b49f59d(
+    profile: _aws_cdk_aws_eks_ceddda9d.FargateProfile,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dd0bd4dee65916002df8546350cf43116d55f03d0052a252943557ca270bb18b(
-    crawler: Crawler,
+def _typecheckingstub__441c970215922062a245380ac8d1e04123624212c517def39ade49d9091b4c23(
+    filter: IFluentBitFilterPlugin,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ee93cfcd69490826c39480651b7eb34877d0667604b0e14daf995218173ee126(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__a329165d7991851e4ec8fd63a4b82083aef71de6826a3ef2e264518b24051f2b(
+    output: IFluentBitOutputPlugin,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2c73437c9e4d3b35bea065e54ce75f4a15077ddc17412786ea8a173cc1fadd1c(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__f61de38bcda89dc454156432b185bbdfe377f7811aa2270afad6e3f3d5d7e4fe(
+    parser: IFluentBitParserPlugin,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f47e29abee492d68598cef1aaeaafad27d809225eb3fede0aba56962510025d0(
-    class_name: builtins.str,
+def _typecheckingstub__5d9fa1ba40c2be86a241bebc6f8b6cc03215924d98659a18e99df90fd7eef185(
+    *,
+    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
+    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
+    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ea4b4cdb8cc43abef69d5aa672a86888b62abf53d134ac73a8ae113ee5f35600(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__331f0ef39a4852c171fb3378d45e752361c5aa7515c6965a4852b6f54a58f900(
     *,
-    password: _aws_cdk_ceddda9d.SecretValue,
-    url: builtins.str,
-    username: builtins.str,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    description: typing.Optional[builtins.str] = None,
-    enforce_ssl: typing.Optional[builtins.bool] = None,
-    name: typing.Optional[builtins.str] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
+    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
+    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
+    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__63235443ef95630aeef4ec6db0d062a07b1671eb3853e7158c18ed47070ed58a(
-    *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    password: _aws_cdk_ceddda9d.SecretValue,
-    url: builtins.str,
-    username: builtins.str,
-    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
-    description: typing.Optional[builtins.str] = None,
-    enforce_ssl: typing.Optional[builtins.bool] = None,
-    name: typing.Optional[builtins.str] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+def _typecheckingstub__004c6d6190020d8cdc3eea6ba900d6bb6b67d1b06e5b2c7a8650568795e29ce3(
+    match: FluentBitMatch,
+    *records: AppendedRecord,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__1e4fc805a8f96657a4f0acdced48b0a0ff8f731cc5e58787975d1636d9bea432(
+    match: FluentBitMatch,
+    *fields: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a5d7f10fe829e301eed5ff500477960d3c29565777d9d18780f32c7d84b383d7(
-    connection: Connection,
+def _typecheckingstub__ca125ae790631ee65913aa6e968ed7113cdb3174739710fcb3e049ee05e1225b(
+    match: FluentBitMatch,
     *,
-    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-    paths: typing.Optional[typing.Sequence[builtins.str]] = None,
+    key: builtins.str,
+    regex: builtins.str,
+    exclude: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__da7fc3d4ccd69b3e6ec79ea8dc2f9c31784d1adaa1616006b1c552d243329288(
-    exclusion: builtins.str,
+def _typecheckingstub__e62ff1da65acb39396b806ce64d2c933f7f3b043f0f4ab5b9bcfde68b282300e(
+    match: FluentBitMatch,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__92e89a811419b69c0f51822e3f45ff0bdd0ce6940b3afb1a59f04b14e85deab7(
-    path: builtins.str,
+def _typecheckingstub__b7921055d17cd6ec5863079beb06bda4bbc0aba18764be3ca76b587d53f6a90c(
+    match: FluentBitMatch,
+    nested_under: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__519dc5422365574c38b31da5db0adb61aaeabbe542682317cab78a331d1d6b96(
-    _crawler: Crawler,
+def _typecheckingstub__70f785929f2989cc94f847423b39a2b6cda43109191a9c78fc4a821025615e83(
+    match: FluentBitMatch,
+    *operations: ModifyOperation,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b92268978767ce15062df3f1f0b702e354d0abf8d764ee0dbedb1952ccd5b8f7(
-    *,
-    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-    paths: typing.Optional[typing.Sequence[builtins.str]] = None,
+def _typecheckingstub__0c44cc88268e3e2218cb706dfe1efc0b47f7a1d76b49addf6866c4a59ff82f54(
+    match: FluentBitMatch,
+    nest_under: builtins.str,
+    *fields: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dfd3e838082701af10fa1c63f23e3acc6bf12935d1a61850f26bc4a6088bfcd6(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
-    *,
-    executable: JobExecutable,
-    allocated_capacity: typing.Optional[jsii.Number] = None,
-    connections: typing.Optional[typing.Sequence[Connection]] = None,
-    continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
-    default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    description: typing.Optional[builtins.str] = None,
-    enable_profiling_metrics: typing.Optional[builtins.bool] = None,
-    max_capacity: typing.Optional[jsii.Number] = None,
-    max_concurrent_runs: typing.Optional[jsii.Number] = None,
-    max_retries: typing.Optional[jsii.Number] = None,
-    name: typing.Optional[builtins.str] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    security_configuration: typing.Optional[SecurityConfiguration] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    worker_count: typing.Optional[jsii.Number] = None,
-    worker_type: typing.Optional[WorkerType] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__10af575b9dbec2cd8ea9604aee8e29ee517e60f747a39b4910b6f4da1f217b83(
+    match: FluentBitMatch,
+    key: builtins.str,
+    *parsers: IFluentBitParserPlugin,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__6ad00a49f903b8ff296c1040af14b52c5c710377bccb726a03b7db29113abd37(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    job_arn: builtins.str,
+def _typecheckingstub__7771595b84c711392921d6ddf6f6d52281f9711dd09522a93a530883167a8e3c(
+    match: FluentBitMatch,
+    *rules: RewriteTagRule,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4b9945957a7dfb3942132fbf1eea0248c28d8f65d0f02d1af6fdcecafa689b66(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    job_name: builtins.str,
+def _typecheckingstub__c398af7ef351b52ad40eb09a1a0fcc6ae44187a82c5709af8cc8ea2d361cb61e(
+    match: FluentBitMatch,
+    interval: _aws_cdk_ceddda9d.Duration,
+    rate: jsii.Number,
+    window: jsii.Number,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__35613a54fa94475a1d6f92b6c0df6312b31ea05071004c65f6f6d6c38b3540b2(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__4a171efbee53101c625ce2956a002515e474ab45a4b74604ffee5889c1053dd3(
+    match: FluentBitMatch,
+    *fields: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9d6f7c32eed0df35efff9f38d209a916c1ac797af98a30c7d4b12c9945e72399(
-    connection: Connection,
+def _typecheckingstub__0a232fab3d929b1e9cdb75a64a4f3eec377e0983c1b4e4ffd68fc95cf216ee9d(
+    *,
+    match: typing.Optional[FluentBitMatch] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__de865e59b5a9d704335fa3900bcc2d054fc4bd594443f79fb978f7aecce4d7a2(
+def _typecheckingstub__0367bee62bb2658dda6a19b32e999c85a7a98303ad453009919555866534b235(
     *,
-    mode: JobBookmarksEncryptionMode,
-    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    pattern: typing.Union[FluentBitGrepRegex, typing.Dict[builtins.str, typing.Any]],
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__af760e5b293fa34ac6b256f1e0f627632acc4c0dd5000a33d11b6c7858e250ec(
+def _typecheckingstub__7d5213db46ae4f43816c9caa03cf901d34224d6f6abfb3d42513921dd5cdbb98(
     *,
-    glue_version: GlueVersion,
-    language: JobLanguage,
-    script: Code,
-    type: JobType,
-    class_name: typing.Optional[builtins.str] = None,
-    extra_files: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars_first: typing.Optional[builtins.bool] = None,
-    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
-    python_version: typing.Optional[PythonVersion] = None,
+    key: builtins.str,
+    regex: builtins.str,
+    exclude: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1a4f1e1b4bab338b9f8725cb2a2bdc60103a0fa9e50e731a94e0a34914c85e6e(
+def _typecheckingstub__491341e10d39ab453cf8cb9ce79aa79883683ad1bef71b12d50956da0005ed71(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    executable: JobExecutable,
-    allocated_capacity: typing.Optional[jsii.Number] = None,
-    connections: typing.Optional[typing.Sequence[Connection]] = None,
-    continuous_logging: typing.Optional[typing.Union[ContinuousLoggingProps, typing.Dict[builtins.str, typing.Any]]] = None,
-    default_arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    description: typing.Optional[builtins.str] = None,
-    enable_profiling_metrics: typing.Optional[builtins.bool] = None,
-    max_capacity: typing.Optional[jsii.Number] = None,
-    max_concurrent_runs: typing.Optional[jsii.Number] = None,
-    max_retries: typing.Optional[jsii.Number] = None,
-    name: typing.Optional[builtins.str] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    security_configuration: typing.Optional[SecurityConfiguration] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    worker_count: typing.Optional[jsii.Number] = None,
-    worker_type: typing.Optional[WorkerType] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    annotations: typing.Optional[builtins.bool] = None,
+    buffer_size: typing.Optional[_DataSize_d20aaece] = None,
+    cache_use_docker_id: typing.Optional[builtins.bool] = None,
+    dns_retries: typing.Optional[jsii.Number] = None,
+    dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    dummy_meta: typing.Optional[builtins.bool] = None,
+    k8s_logging_exclude: typing.Optional[builtins.bool] = None,
+    k8s_logging_parser: typing.Optional[builtins.bool] = None,
+    keep_log: typing.Optional[builtins.bool] = None,
+    kube_ca_file: typing.Optional[builtins.str] = None,
+    kube_ca_path: typing.Optional[builtins.str] = None,
+    kubelet_host: typing.Optional[builtins.str] = None,
+    kubelet_port: typing.Optional[jsii.Number] = None,
+    kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
+    kube_tag_prefix: typing.Optional[builtins.str] = None,
+    kube_token_command: typing.Optional[builtins.str] = None,
+    kube_token_file: typing.Optional[builtins.str] = None,
+    kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    kube_url: typing.Optional[builtins.str] = None,
+    labels: typing.Optional[builtins.bool] = None,
+    merge_log: typing.Optional[builtins.bool] = None,
+    merge_log_key: typing.Optional[builtins.str] = None,
+    merge_log_trim: typing.Optional[builtins.bool] = None,
+    merge_parser: typing.Optional[builtins.str] = None,
+    regex_parser: typing.Optional[builtins.str] = None,
+    tls_debug: typing.Optional[jsii.Number] = None,
+    tls_verify: typing.Optional[builtins.bool] = None,
+    use_journal: typing.Optional[builtins.bool] = None,
+    use_kubelet: typing.Optional[builtins.bool] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9e5f787f6c53b83309ad3224ae7cbd397dc281f463e865210fadeede93199ea7(
+    log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2bde216e427f277dd4ae0752c5cd28002b668b82f2864e2962977e5314f9ec83(
+def _typecheckingstub__67456e5d91f4ffd1bec1ee1e4391d0f4f5ae2b0b2d8f9151cd8a758ce8565c1d(
     name: builtins.str,
+    create: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7922f5b0f22bd94cc964cabe57f17f7d870707d5d26e8c51a8683ee4a13f69f2(
-    class_name: builtins.str,
+def _typecheckingstub__bf36bc82a5087381a1e00eedb991062da3fb86e1b1b2dc82f40a25d98c830a03(
+    log_stream: _aws_cdk_aws_logs_ceddda9d.ILogStream,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0770316fdacec7ca35ca6177329d14996aea7b6acb0fd95618ead49ef0b5ad06(
-    *,
-    glue_version: GlueVersion,
-    python_version: PythonVersion,
-    script: Code,
-    extra_files: typing.Optional[typing.Sequence[Code]] = None,
-    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+def _typecheckingstub__d2d24583ddfcc8876ab533165130d5b3607247d011b36995e13163c253b6e718(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__abf13ee589f12cebe2bcd432fdc04c1c56ddab0d41ec2223ea1e51e77d10b532(
-    *,
-    glue_version: GlueVersion,
-    python_version: PythonVersion,
-    script: Code,
-    extra_files: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars_first: typing.Optional[builtins.bool] = None,
-    extra_python_files: typing.Optional[typing.Sequence[Code]] = None,
+def _typecheckingstub__f2176a9e11225cfa29051ee0166fd6151266cf8a3753905e128f0cb83df80178(
+    prefix: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__de8f54c722e452ed2da0b9a8775cdf6f8a22de4bab55c4b0f779954c84a2b2e6(
-    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
-    key: builtins.str,
+def _typecheckingstub__42632d6e6d5ce15103cf294740e757e5f3a4db926970743e6ab114f398dea1d3(
+    pattern: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__07939ad3e69a9dd6cae1fdc4f6dec96a067b631307222f1d771e21ef5b555288(
-    _scope: _constructs_77d1e7e8.Construct,
-    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+def _typecheckingstub__03245bf7bb94a21d38ca01a84e1768b7dae976c76ea7c6d0c9ea4c23cb4b5063(
+    pattern: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__34af5cf7f823d326ebb18b6676a7f173278a47afe08c3b06bf179d11c994e2f8(
+def _typecheckingstub__477fb867f089070fa5d35c4c569a7ef1cc68825359200bc94957a309491b389b(
     *,
-    mode: S3EncryptionMode,
-    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    conditions: typing.Optional[typing.Sequence[ModifyCondition]] = None,
+    operations: typing.Optional[typing.Sequence[ModifyOperation]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__fcaa86377de60481d78b8e386ba15f4ae63207cee2ee1e03d6a84890c5303f9f(
-    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
+def _typecheckingstub__6baa844d691b01fb5358a6c2b04f16a51e81d297fb8c56fa7ba4e803056db09a(
     *,
-    connection: typing.Optional[Connection] = None,
-    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-    key_prefix: typing.Optional[builtins.str] = None,
-    sample_size: typing.Optional[builtins.str] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    operation: NestFilterOperation,
+    add_prefix: typing.Optional[builtins.str] = None,
+    remove_prefix: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dab26f9f432f54b43673f47359cc7da960e6d82adb6012e75be901a3f3b3ac09(
+    match: FluentBitMatch,
+    log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__16fe7d93a8820fa1d151349582f6a63b13f332f70c5c98bb436e7cf988d6b020(
+    match: FluentBitMatch,
+    stream: _aws_cdk_aws_kinesis_ceddda9d.IStream,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__78064b8f21836a6ba333208adc1772c480fd7d08c026c1f0523ba1b519e1ec92(
-    exclusion: builtins.str,
+def _typecheckingstub__af6295291f38a712113e95369264580c73772913ba57790d0e3eb2c79bca9eec(
+    match: FluentBitMatch,
+    delivery_stream: _IDeliveryStream_cf5feed7,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b1ac6ccbc65917f26861da97319cead930d0dbf8fcf49a83e9e71e57ccef2986(
-    crawler: Crawler,
+def _typecheckingstub__4131fc278e940c264cc3a359804bb213cef52ec4dcc6bc45de6275ff5acb3536(
+    match: FluentBitMatch,
+    domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__adead1dc5fcd2fa7014bdfa551e765a45e7e34612c1c8ffd300d3b8edefe00b4(
+def _typecheckingstub__09888332ffdc8a6865748655bd177159b31a6abfa867b1b8b5d60fdeea5c96b6(
     *,
-    connection: typing.Optional[Connection] = None,
-    exclusions: typing.Optional[typing.Sequence[builtins.str]] = None,
-    key_prefix: typing.Optional[builtins.str] = None,
-    sample_size: typing.Optional[builtins.str] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d2a5c948730ec0b02dbff24e612c1f1729a3fb4d2997fd98def1d1a317ab67ec(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d8419f19685306cef1bb083add90eeae71ca31d26fdf6ad0a5bef68d4d1ae022(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__3d4d3c46b533404bcbeba504ee2681b222c47d467e4716d8970b404167f926e8(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__082be9a38cb65fcbef035dc44eb355e76f5cc06d81a262cf08cf37078bc2d04c(
+    name: builtins.str,
+    regex: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5a58d9a628f0769075f9be892e1815f81d167b0a10411ee63316264981cf0120(
+def _typecheckingstub__b68a9a8afdab443320e980cd8ef61a4610a316eed4b87369d206262bcf945336(
     *,
-    class_name: builtins.str,
-    glue_version: GlueVersion,
-    script: Code,
-    extra_files: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars: typing.Optional[typing.Sequence[Code]] = None,
-    extra_jars_first: typing.Optional[builtins.bool] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    key_name: builtins.str,
+    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
+    preserve_key: typing.Optional[builtins.bool] = None,
+    reserve_data: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8bb80a9d0f83fcd376c282d063d76d6be646365fd7ea4850397fc1cf26b72038(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__d3a289167b1afa2aa5ae024881a5a0f791281e90f1ad71f4febecc1378f28d92(
     *,
-    cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-    job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-    name: typing.Optional[builtins.str] = None,
-    s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    name: builtins.str,
+    plugin_type: FluentBitPluginType,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d27a4bece3fbfe787de85bd302d080942572f3712552688c636b696a9d85fa70(
+def _typecheckingstub__ba63858e40aa4f37f54576c8c109ce4f32cb4535c6c5d186705c639a22214428(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    cloud_watch_encryption: typing.Optional[typing.Union[CloudWatchEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-    job_bookmarks_encryption: typing.Optional[typing.Union[JobBookmarksEncryption, typing.Dict[builtins.str, typing.Any]]] = None,
-    name: typing.Optional[builtins.str] = None,
-    s3_encryption: typing.Optional[typing.Union[S3Encryption, typing.Dict[builtins.str, typing.Any]]] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    allow: typing.Optional[typing.Sequence[builtins.str]] = None,
+    records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
+    remove: typing.Optional[typing.Sequence[builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5be42ef34b8183a16c487d39be9e50f07bb069442ea235835d889d6c915c0fd9(
-    class_name: builtins.str,
+def _typecheckingstub__62537da56305da6b0bcb7286caa362cac36f533c837efd41b4f2abc1df3bcf11(
+    *,
+    regex: builtins.str,
+    skip_empty_values: typing.Optional[builtins.bool] = None,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f6397af3f7e2865b94205ae66351b5049b1e24eddfccbee733dc294c875d1e29(
-    column: Column,
+def _typecheckingstub__815f89c54e571d56f00edc236c155a23cfeab33faa1efebcf6c784af74f59f04(
+    *,
+    match: typing.Optional[FluentBitMatch] = None,
+    emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
+    emitter_name: typing.Optional[builtins.str] = None,
+    emitter_storage_type: typing.Optional[EmitterStorageType] = None,
+    rules: typing.Optional[typing.Sequence[typing.Union[RewriteTagRule, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__be752f0e2780faa753092d75b32484d8113fe2d5f788daa3dfd242fa215de246(
+def _typecheckingstub__a026237a3f40e00499d4fc0204f075b1145cde7bac0b7942bed2173ce310bd9a(
     *,
-    comment: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    data: typing.Optional[typing.Sequence[Column]] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    print_status: typing.Optional[builtins.bool] = None,
+    rate: typing.Optional[jsii.Number] = None,
+    window: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2eec6dbec86f7128ae48e38b1289cfeaade58e92058db1f726cfe7935a152444(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__16439430780263e49cc504798dfdedbab3bf51542be52890ad92373b0d4bfc91(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0e96056912a504aeb9a5f0a9afa10c098c92a82a5580780a4d2bf3539c8205aa(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__acebfc903b3b22f8c30fae481f53b07f40398b43583763b7493f53134e21c720(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b5737e6839ba050eaf2ff95b5004c79062ffa98eab8e21826190de020d396648(
     *,
-    database: Database,
-    columns: typing.Optional[typing.Sequence[Column]] = None,
-    compressed: typing.Optional[builtins.bool] = None,
-    data_format: typing.Optional[DataFormat] = None,
-    description: typing.Optional[builtins.str] = None,
-    location: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    owner: typing.Optional[builtins.str] = None,
-    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    partition_keys: typing.Optional[typing.Sequence[Column]] = None,
-    retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    serde_name: typing.Optional[builtins.str] = None,
-    serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    stored_as_sub_directories: typing.Optional[builtins.bool] = None,
-    table_type: typing.Optional[TableType] = None,
-    target_table: typing.Optional[Table] = None,
-    view_expanded_text: typing.Optional[builtins.str] = None,
-    view_original_text: typing.Optional[builtins.str] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    nested_under: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7e19c0d356c0722d5d2e88f68d65807d5bf7af6ed343ef572db7c40d331591b4(
-    column: Column,
+def _typecheckingstub__a87c7279b95393fe143c70bd0eb03afa5a2eeadbb4e0652815e47bad81d78004(
+    regex: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__32c8dcc447fc94c914aa9117344531cb4adafbbd95e95f5e533aa4ec40ff0b07(
+def _typecheckingstub__9c016d68c98f4a007d811c010a657245a7cb4e35e28d68271b47271fb2e7fe04(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__26a4516fb03cee3ff4649a09c795cfa145f69ca27b37c8efd99e5b120be43804(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__fbd75e354fc9a0d46f639f296e1b4ffe3da299a7891b0381081ad9cc7bdf6631(
     key: builtins.str,
     value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__45a820867b3372f968d0356f688bd57f2fabd57b9a6f1d007bfef4a653dc0d7d(
-    column: Column,
+def _typecheckingstub__3c04874c06d71c34c233c16eca0c4b65f1a6a36f0bb05dfd69dfa0da05ffbec4(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f39ac55f4ec3d384f9e5cb679d42b04bee73ebfeeb4e4ef12d7f135353860879(
+def _typecheckingstub__ff4b63c6ad876a769c352fa5b53d1ab44a9e4a503ccd829e1029918eb28ef3bd(
     key: builtins.str,
     value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dbe94e982d260f87bd2f2b4bdd58ff506d9e25d5fad5f73ce4d04443585752c0(
+def _typecheckingstub__59be3f65de5a631f24700f05f7753e529ad70a4cb137fd5d62383abdd02bf10d(
     key: builtins.str,
     value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c47a2c9840f823b7524821e05bdf6ea2222940a7cf7b637b2dae2f91266503ee(
-    *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    database: Database,
-    columns: typing.Optional[typing.Sequence[Column]] = None,
-    compressed: typing.Optional[builtins.bool] = None,
-    data_format: typing.Optional[DataFormat] = None,
-    description: typing.Optional[builtins.str] = None,
-    location: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    owner: typing.Optional[builtins.str] = None,
-    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    partition_keys: typing.Optional[typing.Sequence[Column]] = None,
-    retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    serde_name: typing.Optional[builtins.str] = None,
-    serde_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    storage_parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    stored_as_sub_directories: typing.Optional[builtins.bool] = None,
-    table_type: typing.Optional[TableType] = None,
-    target_table: typing.Optional[Table] = None,
-    view_expanded_text: typing.Optional[builtins.str] = None,
-    view_original_text: typing.Optional[builtins.str] = None,
+def _typecheckingstub__b9f14e749593d361f880d1301a695fbd3315adff4d215a08b2867f766b530f6f(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9a79049a428bd5941424b4e094c84a859a725f32c171d87ac2126a1685ef641f(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
-    *,
-    type: TriggerType,
-    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-    predicate_operator: typing.Optional[PredicateOperator] = None,
-    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    start_on_creation: typing.Optional[builtins.bool] = None,
-    workflow: typing.Optional[Workflow] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__3644ef417d81a715203823624e932831fa6fab3e38086a6ff12bb88a577c0d05(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d29de485fa07fbea64e912490718223776c3ab360b719de644012a94fb6434f7(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    trigger_arn: builtins.str,
+def _typecheckingstub__786ab8e1494a413b4e18469e55a12839dde421149e6acea64e8a335582aa46f5(
+    regex: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f3434fb8f553f52f60a3e025608013104918640090d3d63398c7aa99c372b20d(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    trigger_name: builtins.str,
+def _typecheckingstub__c6cda0ccdf12bd0d94a391aeee20b8afc334828d46c7557423da8fddc68c8a5b(
+    condition: builtins.str,
+    args: typing.Sequence[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__88d1f6674bbdb9c882a91bf4bd456ed2e3b77d8ede0eda0335a9711e90ef10d8(
+    key: builtins.str,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__509195f56adc1008582dfdd1ced4b6aae5a09a204f9b120954616dbe9255a6a5(
+    original_key: builtins.str,
+    new_key: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bc007dfc129810a05403a45fc2edb04eac2ac69328ffffbe932ae17113d5f057(
-    action: ITriggerAction,
+def _typecheckingstub__4252ab4af15f45596deb41aecff5cdf63193455fcfb6a11f50e531ae913ddc19(
+    original_key: builtins.str,
+    new_key: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2b67da5af6c648e853764f371b481f132349181516847a12a28a673bc51a3fe4(
-    predicate: ITriggerPredicate,
+def _typecheckingstub__d143c72f0b1248ef3c465526d5a4bec246e11ddc44d1e7ffb9cd998bfd89a980(
+    original_key: builtins.str,
+    renamed_key: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__01145ca757e10f8e94b4c175dd3a267a5df9030339f6e4feb49750e5ff03ac64(
+def _typecheckingstub__58f39ecf984b31b6d9c63ea24ccc57cdf4154eb2c667a5e4b98bf4f0117cbe7f(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__21dd6a80198a6efcdd40eb3aafec20cfecfde8f707999ac8ded417642e87f43f(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2d24729666ca872450b6aefe87e852b867ecabcb6e378292249754f4c529a432(
+    operation: builtins.str,
+    args: typing.Sequence[builtins.str],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d0548969ac288015caf3702a3018bc6e8a9967a958e5278991beb6b8382f6fc8(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__bd9fed6d2afdca2a8d61c87b02ec06a5728541f28c7352f673e92afe99a5efcd(
+    regex: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a06eaf6be7e3ecf8c20d87aa164edc3b0351d095aa8d571d241a99dfae13e153(
+    key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4fada9b7497030c549640821afc49c367a7e9f8f75e21c42fc11b152b1655772(
+    original_key: builtins.str,
+    renamed_key: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2a30ee29a1bf209f7c351625daebd78e2a284fc57bc3fa2bc6d0fb94a0d6032f(
+    key: builtins.str,
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__fd3dc6435c8d865e4f7520bd4058b3d18b2d20bc9036da2f79a101b7da1409ac(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    type: TriggerType,
-    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-    description: typing.Optional[builtins.str] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
     name: typing.Optional[builtins.str] = None,
-    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-    predicate_operator: typing.Optional[PredicateOperator] = None,
-    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    start_on_creation: typing.Optional[builtins.bool] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ad020c3099533ac828ee3b7bc94f977e7beb54ccf917b0d37f088b52a7110039(
+def _typecheckingstub__b5a146c9ddfcbd766c4313db4ff21f80ccb81d8144313200dfa63dd1bb1ff770(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    type: TriggerType,
-    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-    predicate_operator: typing.Optional[PredicateOperator] = None,
-    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    start_on_creation: typing.Optional[builtins.bool] = None,
-    workflow: typing.Optional[Workflow] = None,
+    nest_under: builtins.str,
+    wildcards: typing.Sequence[builtins.str],
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4a01940e29d3d0fd83d19b9c7547e8ccfdc7c8f60414ad61defd54707cde2f02(
-    worker_type: builtins.str,
+def _typecheckingstub__4b8fe7eff14cfd09dcf3795cb57c69d832abf797e1e50720b10706a28cf1e816(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d4d24a390d9eb03a06583cbc6d261f3d8de476409210bcdd7f51d4e1476eeaf4(
+    size: _DataSize_d20aaece,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__f02160f33c5993a4b0add2859c5aaed60beda3ddc55734f5fb49997c73f69b93(
+    value: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7f740f5f0bbca2b649fceb0e355052b591878a5d830606365cce99d8b088caac(
+    name: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c82e94df4496e54b2a8815cc2ee59fcd040f76e2dcc14bb09c3f2fc10a316803(
+    *,
+    config_file: builtins.str,
+    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
+    permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__10d3a53f3145b3b27a3099c9f07d903492e56e8258545b4251a8bc9b20c63556(
+    *,
+    keep: builtins.bool,
+    key: builtins.str,
+    new_tag: builtins.str,
+    regex: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__30858062db0892690086e05db3017264c21574c51cfe419ae83dc373da11b661(
+def _typecheckingstub__25ed19f0f43971dfc8f3ac2b02af3d6b57e81e4bf8f903ca7a9a94030416e6df(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    api_retries: typing.Optional[jsii.Number] = None,
+    batch_change_size: typing.Optional[jsii.Number] = None,
+    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+    evaluate_target_health: typing.Optional[builtins.bool] = None,
+    log_format: typing.Optional[ExternalDnsLogFormat] = None,
+    log_level: typing.Optional[ExternalDnsLogLevel] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    prefer_cname: typing.Optional[builtins.bool] = None,
+    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
+    replica_count: typing.Optional[jsii.Number] = None,
+    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+    zone_type: typing.Optional[ExternalDnsZoneType] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ce55118dcfd5ce84c7d138d41de38e7579d11282f1f109403fe376a28709ebf9(
-    id: builtins.str,
+def _typecheckingstub__b366d288dd32fbd3b7303ac861a4b96ff1f42c49b0c512768f7acdc1ace18cb1(
+    domain: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__66071158131361758043670975aa8966426ce28d558d5a62b92defe0a754f8cb(
     *,
-    type: TriggerType,
-    actions: typing.Optional[typing.Sequence[ITriggerAction]] = None,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    predicate_conditions: typing.Optional[typing.Sequence[ITriggerPredicate]] = None,
-    predicate_operator: typing.Optional[PredicateOperator] = None,
-    schedule: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    start_on_creation: typing.Optional[builtins.bool] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
+    api_retries: typing.Optional[jsii.Number] = None,
+    batch_change_size: typing.Optional[jsii.Number] = None,
+    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+    evaluate_target_health: typing.Optional[builtins.bool] = None,
+    log_format: typing.Optional[ExternalDnsLogFormat] = None,
+    log_level: typing.Optional[ExternalDnsLogLevel] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    prefer_cname: typing.Optional[builtins.bool] = None,
+    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
     region: typing.Optional[builtins.str] = None,
+    replica_count: typing.Optional[jsii.Number] = None,
+    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+    zone_type: typing.Optional[ExternalDnsZoneType] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1e1780b54c3d5134781210aa5dcce6cc5585326dcffdae0be9004a975c463191(
-    crawler: ICrawler,
+def _typecheckingstub__599f1713ffc48e89808216535a31c01bf2871a0c4778c26680cb34a48861c9ff(
     *,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    api_retries: typing.Optional[jsii.Number] = None,
+    batch_change_size: typing.Optional[jsii.Number] = None,
+    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
+    evaluate_target_health: typing.Optional[builtins.bool] = None,
+    log_format: typing.Optional[ExternalDnsLogFormat] = None,
+    log_level: typing.Optional[ExternalDnsLogLevel] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    prefer_cname: typing.Optional[builtins.bool] = None,
+    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
+    replica_count: typing.Optional[jsii.Number] = None,
+    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
+    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
+    zone_type: typing.Optional[ExternalDnsZoneType] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3a94d581f860b13a89641b07de3a6dff7bb35902a5e740ce1b0305d078a71a88(
-    job: IJob,
+def _typecheckingstub__85958058f60b5349b6efc3cb16e252dae2854865cf49f70b0877c64d7c4bf0dd(
     *,
-    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    kubernetes_key: builtins.str,
+    metadata_policy: typing.Optional[MetadataPolicy] = None,
+    remote_key: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__05b16d8f0e42dabc8d5b35b3da8eefd18876b6a5a59a4f740c34c94379a3a823(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__4dc26d0199f1602801b856583653a8b0d62418efb64456ef381f7d916080559e(
+    *,
+    remote_ref: builtins.str,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__99f5b49f9607b05a4e188e075be9ce415c7b6b085607cb3e0f90e94cc8453feb(
+def _typecheckingstub__c496d6306c81ceef9b7062404bcf66ea260c45a38d3b69dc2f1f0a90fd9af9d2(
+    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
+    *,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d70f039a06515082a5c4a0a4ba2130f884b4355bae0292328fb6429f6569cd96(
     _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7005e62847fa5591337705760979f2e03a39c841c84835a874bcebaca8a59289(
+def _typecheckingstub__64d4869a39ffca99e3f183351ee069c38191bab52dbb76ac1d38c8a6a23da30b(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ad3c134eb8a9a38db762359e9966bbb7beb44688976d988804ba557fa266ff4b(
-    crawler: ICrawler,
+def _typecheckingstub__c06248919a788c055f92881d2ef760cb61263eb20ab5280e286e3f0705f184a0(
     *,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9bd574ee7e851b6cdc8e7da335779c92cb91aac7d1685e0748769e6e4e944682(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__be97b8cc9c656627b57f3db1afef2a495b5f9ef0693be3b77dd2ab818c7a14d2(
+    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
+    *,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2234879c337e543d2848372b9e2ea82f341e9425395819d4c59814e46dfb3233(
+def _typecheckingstub__7147e379832a8ca243add61c65fb60f7361f398799b43de2302e5a36758d1417(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__85f36849fed8daf98c94ff71f819a22287651f50ad8ac9fbde185a225ecf3d48(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4b35e7b4cd1b6215af9417101fd148d7cff1bdbaa7e82f113dafee00863f0e8b(
-    job: IJob,
+def _typecheckingstub__34a803d3f05acbd46634594fba4d5545e3823b2171c2f1104618a9a68b51217a(
     *,
-    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a7515c04a94a863fad2bee1122daa43d9a40018fd2904b2aa74a621938706702(
+def _typecheckingstub__105e23602b6d46260f139f3822144dac2ba3d98f3a079c87534a0c62c41eb507(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bf2bd2d4a47064faaa01d005f9c67d6010a4760a0856334853b9d2c9c03d73b3(
+def _typecheckingstub__49d222934bd8c2c391090725600916ef04457ba131b293ef18b5254a232b8e55(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    arguments: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
-    notify_delay_after: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    security_configuration: typing.Optional[builtins.str] = None,
-    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    bookmark_configuration: typing.Optional[BookmarkConfiguration] = None,
+    owner_id: typing.Optional[builtins.str] = None,
+    prefix: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ffa264c859c1bcdd41fda254d289bc185e36ff404ad7901a6b7d63d92cddf8ee(
-    crawler: ICrawler,
+def _typecheckingstub__a5db7e3c7776867e619b3b5a59436e82e10ef7dd279ce473dba2df2bc999988b(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[CrawlerState] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    service: builtins.str,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ca6546c9bc55323e0c4cb2c970aba51c478d9a3067002ee323e9093850759207(
-    job: IJob,
+def _typecheckingstub__b365e8ec462c9d5a06a032056dcf37739fad6ac73b424fbd4e54e70dd68eca9d(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0a6ddb803ae38cffafb281e286ceb82c9d46f01f71cc1c19883463d5671ffb62(
     *,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[JobState] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    auto_create_group: typing.Optional[builtins.bool] = None,
+    auto_retry_requests: typing.Optional[builtins.bool] = None,
+    endpoint: typing.Optional[builtins.str] = None,
+    log_format: typing.Optional[builtins.str] = None,
+    log_group: typing.Optional[FluentBitLogGroupOutput] = None,
+    log_group_template: typing.Optional[builtins.str] = None,
+    log_key: typing.Optional[builtins.str] = None,
+    log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
+    log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
+    log_stream_template: typing.Optional[builtins.str] = None,
+    metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    metric_namespace: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    sts_endpoint: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__532fa291e748d01f44fced9f7933021be1f8ac049d19d07677702e64c2e226cc(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__d15707b98b30fc02a4da2bf5ff3f6fab3135470fb1fbfa8644ad8ebe83173635(
+    *,
+    match: typing.Optional[FluentBitMatch] = None,
+    host: builtins.str,
+    aws_auth: typing.Optional[builtins.bool] = None,
+    aws_external_id: typing.Optional[builtins.str] = None,
+    aws_region: typing.Optional[builtins.str] = None,
+    aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    aws_sts_endpoint: typing.Optional[builtins.str] = None,
+    buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
+    cloud_auth: typing.Optional[builtins.str] = None,
+    cloud_id: typing.Optional[builtins.str] = None,
+    compress: typing.Optional[ElasticsearchCompressionFormat] = None,
+    current_time_index: typing.Optional[builtins.bool] = None,
+    generate_id: typing.Optional[builtins.bool] = None,
+    http_passwd: typing.Optional[builtins.str] = None,
+    http_user: typing.Optional[builtins.str] = None,
+    id_key: typing.Optional[builtins.str] = None,
+    include_tag_key: typing.Optional[builtins.bool] = None,
+    index: typing.Optional[builtins.str] = None,
+    logstash_date_format: typing.Optional[builtins.str] = None,
+    logstash_format: typing.Optional[builtins.bool] = None,
+    logstash_prefix: typing.Optional[builtins.str] = None,
+    logstash_prefix_key: typing.Optional[builtins.str] = None,
+    path: typing.Optional[builtins.str] = None,
+    pipeline: typing.Optional[builtins.str] = None,
+    port: typing.Optional[jsii.Number] = None,
+    replace_dots: typing.Optional[builtins.bool] = None,
+    suppress_type_name: typing.Optional[builtins.bool] = None,
+    tag_key: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    time_key_format: typing.Optional[builtins.str] = None,
+    time_key_nanos: typing.Optional[builtins.bool] = None,
+    trace_error: typing.Optional[builtins.bool] = None,
+    trace_output: typing.Optional[builtins.bool] = None,
+    type: typing.Optional[builtins.str] = None,
+    workers: typing.Optional[jsii.Number] = None,
+    write_operation: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0105e31834c9b424b25ba556e15b0668eb70bf912898e00b880d88fa39017523(
-    *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
+def _typecheckingstub__676b11880e42853f892c52495c93ae1bf187c9bb63de443fc1705142de091362(
+    *,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__83b0e4d7b9e83a0ce016f523fc9afe715ef0070f7415a4f5d350b20f68c2e63d(
+    *,
+    match: typing.Optional[FluentBitMatch] = None,
+    auto_retry_requests: typing.Optional[builtins.bool] = None,
+    compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
+    delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
+    endpoint: typing.Optional[builtins.str] = None,
+    log_key: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    sts_endpoint: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    time_key_format: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2ce544c2156b20e8e19b70a1531a61d42db72f6b0e812f45f7bc7bfbeead5f0b(
+def _typecheckingstub__b3351322b2cfd158f546c053b64876ee28f0c4c8db9d39839fa35435992b5a02(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    auto_retry_requests: typing.Optional[builtins.bool] = None,
+    endpoint: typing.Optional[builtins.str] = None,
+    log_key: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    description: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
+    sts_endpoint: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    time_key_format: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e98ee73549e5bf2df4bd363c5ccef46d94100d1940e7c591367826866bb56b21(
+def _typecheckingstub__f56caf857f07fc4fcf3a9d82849abe1b6d988d15131ee141433d839c247afbab(
     *,
-    comment: typing.Optional[builtins.str] = None,
-    name: typing.Optional[builtins.str] = None,
-    data: Column,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8359d0e12857464b85b7f043fe21b4c1b8581d20c4a022da8a6c0e79ee1c3386(
+    *,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7e088280d8611751a4dd67d784a7813fe0d71f491155a45dfd938dcbbf43714d(
-    path: builtins.str,
+def _typecheckingstub__5d8425bcc923d11b65d58b1eaf5873e22f32f3ab919ad7e37262fc57ab0df995(
     *,
-    asset_hash: typing.Optional[builtins.str] = None,
-    asset_hash_type: typing.Optional[_aws_cdk_ceddda9d.AssetHashType] = None,
-    bundling: typing.Optional[typing.Union[_aws_cdk_ceddda9d.BundlingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
+    match: typing.Optional[FluentBitMatch] = None,
+    domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
+    aws_auth: typing.Optional[builtins.bool] = None,
+    aws_external_id: typing.Optional[builtins.str] = None,
+    aws_region: typing.Optional[builtins.str] = None,
+    aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    aws_sts_endpoint: typing.Optional[builtins.str] = None,
+    buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
+    current_time_index: typing.Optional[builtins.bool] = None,
+    generate_id: typing.Optional[builtins.bool] = None,
+    host: typing.Optional[builtins.str] = None,
+    http_passwd: typing.Optional[builtins.str] = None,
+    http_user: typing.Optional[builtins.str] = None,
+    id_key: typing.Optional[builtins.str] = None,
+    include_tag_key: typing.Optional[builtins.bool] = None,
+    index: typing.Optional[builtins.str] = None,
+    logstash_date_format: typing.Optional[builtins.str] = None,
+    logstash_format: typing.Optional[builtins.bool] = None,
+    logstash_prefix: typing.Optional[builtins.str] = None,
+    logstash_prefix_key: typing.Optional[builtins.str] = None,
+    path: typing.Optional[builtins.str] = None,
+    pipeline: typing.Optional[builtins.str] = None,
+    port: typing.Optional[jsii.Number] = None,
+    replace_dots: typing.Optional[builtins.bool] = None,
+    suppress_type_name: typing.Optional[builtins.bool] = None,
+    tag_key: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    time_key_format: typing.Optional[builtins.str] = None,
+    time_key_nanos: typing.Optional[builtins.bool] = None,
+    trace_error: typing.Optional[builtins.bool] = None,
+    trace_output: typing.Optional[builtins.bool] = None,
+    type: typing.Optional[builtins.str] = None,
+    workers: typing.Optional[jsii.Number] = None,
+    write_operation: typing.Optional[builtins.str] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6444197d7722391a58b5da239897ee3a742da209a160dd73058c6c54dc737cf7(
+    config: typing.Mapping[builtins.str, typing.Any],
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ec027c50ac516e8170beed01cb13e2ead3adfe45e782c6b378a332ada31736c0(
+def _typecheckingstub__acc47748e8c44554d5768c7501d9e6c9274e616d8bb24e8c9c64ec6e7ca82c4e(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__d0c3c962388492a04b5601f56b47b4dfbb0110dbd51c733afa1a9bed17ae16f9(
     scope: _constructs_77d1e7e8.Construct,
-    grantable: _aws_cdk_aws_iam_ceddda9d.IGrantable,
+    id: builtins.str,
+    *,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    name: typing.Optional[builtins.str] = None,
+    namespace: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0ae472b6c02750d1961d7f516ba02f642a1ea26bb6902239beb46998e097aaf9(
+def _typecheckingstub__6359c3f686f0688d1026d3fd4e13f56fdd12e614640211e1a20c6764506d0bde(
+    id: builtins.str,
+    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
     *,
-    comment: typing.Optional[builtins.str] = None,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
     name: typing.Optional[builtins.str] = None,
-    type: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5211274cd7116e3c396417e594ecadcc53088dd8ee26c4e810934deac308acc2(
+def _typecheckingstub__8a0341aaa28a58b67be791194cbc62d0dc6cb7590b8b514b48b86ddc4b19c218(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    classifiers: typing.Optional[typing.Sequence[builtins.str]] = None,
-    configuration: typing.Optional[typing.Union[CrawlerConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
-    database: typing.Optional[Database] = None,
-    delete_behavior: typing.Optional[DeleteBehavior] = None,
-    description: typing.Optional[builtins.str] = None,
+    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
     name: typing.Optional[builtins.str] = None,
-    recrawl_behavior: typing.Optional[RecrawlBehavior] = None,
-    schedule_expression: typing.Optional[_aws_cdk_aws_events_ceddda9d.Schedule] = None,
-    security_configuration: typing.Optional[SecurityConfiguration] = None,
-    table_prefix: typing.Optional[builtins.str] = None,
-    targets: typing.Optional[typing.Sequence[ICrawlerTarget]] = None,
-    update_behavior: typing.Optional[UpdateBehavior] = None,
+    namespace: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d145d23256eb2d35c1a9bf019e04dff25bc109fef47efc90d6d6f6882fdb4815(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__e4726b5ae83a114c6d9a0343261df1f71b3fb8d8712d5e1a0e9dd6ffb85ada79(
     id: builtins.str,
-    crawler_arn: builtins.str,
+    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
+    *,
+    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d539939596ad8ddfe1a7db54e1c33868e19ed805abf7d2eef859c4a90be77941(
-    scope: _constructs_77d1e7e8.IConstruct,
-    id: builtins.str,
-    crawler_name: builtins.str,
+def _typecheckingstub__2b0341b3b1df86ed9b5aab4b4fadcc47fd710ae038076cca755f3c48acef6956(
+    name: builtins.str,
+    *,
+    match: typing.Optional[FluentBitMatch] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dd92e8237c9a3e0963fb6f8aa69a0ef0b1b6cb8403264e0fdd57816a24a83f04(
+    config: typing.Mapping[builtins.str, typing.Any],
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__96016694c1f44cc04af86f8b769bd0adb927352bc79ad9603516897998bec7b0(
-    classifier: builtins.str,
+def _typecheckingstub__5ad4b94abc52cd50668ebd6e0a941de90c4ed68a322b0c4bd1bf8f5d132edd78(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5953f10fbafcde2546e1cf7a12bdade9d093857e166f6d1fb4bab50e2a66f14b(
+    _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dc8dd7ffc643cb691f77d16e095c4e42f8ad2f09ba25c30724c84c18b23eefac(
-    target: ICrawlerTarget,
+def _typecheckingstub__60894bd40aca48d31e52eb990ad104ed6b9b8b2602d5bae83cb8098f2ea83f1a(
+    condition: ModifyCondition,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a18ab964f00a29725095bfb40c5b43949ff4de4430650c9d95b535e4941cfc7a(
-    crawler: ICrawler,
+def _typecheckingstub__4872512d801b614d842132e607c71d6d758968a7609d124502601dd7de57178a(
+    operation: ModifyOperation,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8290d1192e5d252ca7834f51af4ac7230139ac8edc7a97b45248f244d5803b08(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__2ff2cbdcb80817e036a6954889caaeadf5950a28c75b5dba99ae8a9ac2313605(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__6c582e20366c46fa5a93e6085edba3cad0c3a6114b9d179929c4a21e06afd000(
+    name: builtins.str,
     *,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[CrawlerState] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    match: typing.Optional[FluentBitMatch] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ab6c6045286c50786550fc825f10c79429ddaf99441ba9be931f3575ea02ea64(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__f55ec2d6a159d7531fd899f1f3bf43e62ed11244ce1b82143887e03f2226d642(
+    config: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__18b4223306efeb65c4b4c3faa3427b063444b0783b18132bf6e713a6fd9edbcb(
+    parser: IFluentBitParserPlugin,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__c79cf71df86cb41e555b053e2f91fa72cc6a21fe3a419e03d0eeb0bbc80de8f0(
+    _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b34c0d221b3673906a9840fa8262a73d533de41c6c0f80b688d92ba11c4e20a1(
+def _typecheckingstub__8aed0e3d729344028d0f8b2dd7852c483cccc00b07ab135d6bc3adfeeb63180a(
+    name: builtins.str,
+    format: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__a9117f2b6ee6f3211f51ac4d139a07337fb77609903f1cdfc5d98cecfc42198b(
+    config: typing.Mapping[builtins.str, typing.Any],
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__197d11f14d745ecc6b6f0e060796ec77dba5a2371d0b974c5188eba457ace3a9(
+    tag: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b1fb7025737a67bb8d4d600b93b0d5d19ecf74c9ce22d8ea64f634ad9895f200(
+    tag: builtins.str,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5f389e835484d35e9442fddb76443dec0a2aa164eb591d2f71cb44abf7e9b8fa(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4179007c95e092b6ac83f12dd7ef24c1c718db06738628257564097d17575d37(
+    name: builtins.str,
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[CrawlerState] = None,
+    regex: builtins.str,
+    skip_empty_values: typing.Optional[builtins.bool] = None,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__b3c327e2acce81be05e692cd50cc22811413200c4697881b0ba1fbe6ce2d81d2(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__7b876de72e29ff64e3f1942127300def8853d5a5fcc52fac6120aba70bdda279(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__5ddeac1f10751e613cc3decd64281d60ce8da73f21dce744a8f23bdd94d419b9(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__4fd91daa220023ad34765844283275eab65fafb87508ac56f1d7c81195ee443b(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f4c02ff62824c53aba142c5763845ac4a5e58a9cb8f54ede31043c8dba475d26(
-    job: IJob,
+def _typecheckingstub__31e06075f1184a9eaf94b720a919de0afb675ade3a9e9f7e3f9e9140cf117b1f(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9667bfd8f45c5a175656e36d9ad7b4db85b5e7feb83c1e2fc34acbbea82478a0(
+    name: builtins.str,
     *,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[JobState] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__052b1ed2cea96b32b65c6bcbd0903b2b8d644c2532b12858e569decfda630d36(
+def _typecheckingstub__1256282bf7828450eaecad96fbe7ce7a18dbb436f8a9946b3251e80084c75330(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__dcda296c8eede11fa4ddcc3c2feb2e785012111fa86135f95b451f948f97bd08(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__72482740085b262df0b54ed41b3b29c654ded6f27c0575af036d20ebf4fff046(
+def _typecheckingstub__4bf7e0507e4e17249fa3d68d625e57e70517c7cc3ef3896715e32aac5c34c20a(
+    scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__8e25b48b2e66c9db37ff8e8c3719343636a0ede774d594e4e69fefd8f541afc7(
+    name: builtins.str,
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    logical_operator: typing.Optional[PredicateLogicalOperator] = None,
-    state: typing.Optional[JobState] = None,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__0a81c3d8601df476452f69214aca18722b70cc833bc61983875ae41787e2ce75(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9575880f0d90bc5de7b08966955cdc0ae58d806eef8a52a89f16c51353d5f674(
+    name: builtins.str,
+    *,
+    time_format: typing.Optional[builtins.str] = None,
+    time_key: typing.Optional[builtins.str] = None,
+    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__9cc473e237e03b0900368e7d87fdfbee36d9a7b81802d233cd2091e9fbeed709(
+    _scope: _constructs_77d1e7e8.IConstruct,
+) -> None:
+    """Type checking stubs"""
+    pass
+
+def _typecheckingstub__33bba3952c545b0c433e0348981b5b24158f45f87bd95dd02431e2b4b4656a81(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/glue_tables/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/glue_tables/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/k8s_aws/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/ec2/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,244 +1,106 @@
 '''
-# K8S AWS Construct Library
+# Vibe-io CDK-Extensions EC2 Construct Library
 
-Provides Kubernetes resources for integrating with AWS services.
+The @cdk-extensions/ec2 package contains advanced constructs and patterns for
+setting up networking and instances. The constructs presented here are intended
+to be replacements for equivalent AWS constructs in the CDK EC2 module, but with
+additional features included.
 
-## Fargate Logging
+[AWS CDK EC2 API Reference](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_ec2-readme.html)
 
-Fargate logging causes the output of pods running on EKS Farget to be sent to a logging service for storage and review.
+To import and use this module within your CDK project:
 
-By default, logs are written to CloudWatch Logs.
-
-Enable Fargate logging on an EKS cluster:
-
-```
-declare const cluster: eks.FargateCluster;
-
-const logger = new k8s_aws.FargateLogger(this, 'logger', {
-    cluster: cluster,
-    fargateProfiles: [
-        cluster.defaultProfile
-    ]
-});
-```
-
-Permissions for sending logs to their configured destination are added to the Fargate profiles associated with the logger.
-
-When adding new Fargate Profiles be sure to associate them with the logger to ensure they have sufficient permissions to write logs.
-
-```
-declare const profile: eks.FargateProfile;
-declare const logger: k8s_aws.FargateLogger;
-
-logger.addFargateProfile(profile);
-```
-
-Configure logging to write to a Kinesis Firehose delivery stream:
-
-```
-declare const cluster: eks.FargateCluster;
-declare const deliveryStream: kinesis_hirehose.DeliveryStream;
-
-const logger = new k8s_aws.FargateLogger(this, 'logger', {
-    cluster: cluster,
-    fargateProfiles: [
-        cluster.defaultProfile
-    ],
-    outputs: [
-        k8s_aws.FluentBitOutput.kinesisFirehose(k8s_aws.FluentBitMatch.ALL, deliveryStream);
-    ]
-});
-```
-
-Configure logging to write to a Kinesis data stream:
-
-```
-declare const cluster: eks.FargateCluster;
-declare const stream: kinesis.Stream;
-
-const logger = new k8s_aws.FargateLogger(this, 'logger', {
-    cluster: cluster,
-    fargateProfiles: [
-        cluster.defaultProfile
-    ],
-    outputs: [
-        k8s_aws.FluentBitOutput.kinesis(k8s_aws.FluentBitMatch.ALL, stream);
-    ]
-});
-```
-
-Configure logging to write to an OpenSearch domain:
-
-```
-declare const cluster: eks.FargateCluster;
-declare const domain: opensearch.Domain;
-
-const logger = new k8s_aws.FargateLogger(this, 'logger', {
-    cluster: cluster,
-    fargateProfiles: [
-        cluster.defaultProfile
-    ],
-    outputs: [
-        k8s_aws.FluentBitOutput.opensearch(k8s_aws.FluentBitMatch.ALL, domain);
-    ]
-});
-```
-
-Filter out log messages matching the AWS load balancer health check user agent:
-
-```
-declare const logger: k8s_aws.FargateLogger;
-
-logger.addFilter(k8s_aws.FluentBitFilter.grep(k8s_aws.FluentBitMatch.ALL, {
-    exclude: true,
-    key: 'log',
-    regex: 'ELB-HealthChecker'
-}));
-```
-
-## Container Insights
-
-[AWS Container Insights](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html) provides advanced diagnostic and performance metrics for your containerized applications running on AWS. For EKS cluster, Container Insights is provided by using [AWS Distro for OpenTelemetry](https://aws.amazon.com/blogs/containers/introducing-amazon-cloudwatch-container-insights-for-amazon-eks-fargate-using-aws-distro-for-opentelemetry/).
-
-To enable Container Insights for pods running on your EKS cluster:
-
-```
-declare const cluster: eks.Cluster;
-
-const collector = new k8s_aws.AdotCollector(this, 'adot-collector', {
-    cluster: cluster
-});
-```
-
-## Route 53
-
-Enable management of Route 53 hosted zones for ingress and service hosts:
-
-```
-declare const cluster: eks.Cluster;
-
-const manager = new k8s_aws.Route53Dns(this, 'route53-dns', {
-    cluster: cluster
-});
+```python
+import * as ec2 from 'cdk-extensions/ec2';
 ```
 
-Only enable managment of Route 53 DNS to only records that end with `example.com`:
-
-```
-declare const manager: k8s_aws.Route53Dns;
+## VPC Flow Logs
 
-manager.addDomainFilter('example.com');
+VPC Flow Logs is a feature that enables you to capture information about the IP
+traffic going to and from network interfaces in your VPC. Flow log data can be
+published to Amazon CloudWatch Logs and Amazon S3. After you've created a flow
+log, you can retrieve and view its data in the chosen destination.
+[AWS VPC Flow Logs User Guide](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)
+[AWS VPC Flow Logs CFN Documentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html)
+
+For this construct, by default a S3 bucket will be created as the Flow Logs
+destination. It will also include a Glue table with the same schema as the
+configured FlowLogFormat, as well as prepared Athena queries.
+
+### Usage
+
+You can create a flow log like this:
+
+```python
+new ec2.FlowLog(this, 'FlowLog', {
+  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc)
+})
 ```
 
-Only allow management for hosted zones that are tagged with `managed-dns=enabled`:
+You can also add multiple flow logs with different destinations.
 
-```
-declare const manager: k8s_aws.Route53Dns;
+```python
+const bucket = new s3.Bucket(this, 'MyCustomBucket');
 
-manager.addZoneTag({
-    key: 'managed-dns',
-    value: 'enabled'
+new ec2.FlowLog(this, 'FlowLog', {
+  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
+  destination: ec2.FlowLogDestination.toS3(bucket)
 });
-```
-
-Only allow creates and updates of DNS records and not deletes:
-
-```
-declare const cluster: eks.Cluster;
-
-const manager = new k8s_aws.Route53Dns(this, 'route53-dns', {
-    cluster: cluster,
-    syncPolicy: ExternalDnsSyncPolicy.UPSERT_ONLY
-});
-```
-
-## Secrets Manager
-
-Enable synchronization of specific secret between Secrets Manager and Kubernetes:
 
-```
-declare const cluster: eks.Cluster;
-
-const operator = new k8s_aws.ExternalSecretsOperator(this, 'external-secrets', {
-    cluster: cluster
+new ec2.FlowLog(this, 'FlowLogCloudWatch', {
+  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
+  trafficType: ec2.FlowLogTrafficType.REJECT,
+  maxAggregationInterval: FlowLogMaxAggregationInterval.ONE_MINUTE,
 });
 ```
 
-To tell the external secrets operator to synchronise a secret:
+### Additional Features
 
-```
-declase const operator: k8s_aws.ExternalSecretsOperator;
-declare const secret: secretsmanager.Secret;
+The main advantage that this module has over the official AWS CDK module is that
+you can specific the log format at the time of FlowLog creation like this:
 
-operator.registerSecretsManagerSecret('sychronized-secret', secret);
+```python
+new ec2.FlowLog(this, 'FlowLog', {
+  resourceType: ec2.FlowLogResourceType.fromVpc(myVpc),
+  format: ec2.FlowLogFormat.V3,
+})
 ```
 
-Give the secret a human friendly name in Kubernetes:
+There are several formats that are included as part of the module, and each one
+will define the fields included in the flow log records. Each one acts similarly
+to a log level (Info, Debug, etc), with each level providing increasingly more
+detail in the logs (like region or AZ details, or AWS service details).
+
+The formats and descriptions are as follows:
+
+* ec2.FlowLogFormat.V2: The default format if none is specified. Includes common
+  basic details like log status, account ID, source and
+  destination.
+* ec2.FlowLogFormat.V3: Includes all fields from V2, as well as information on
+  the specific AWS resources associated with the traffic
+  like Vpc, subnet and instance IDs.
+* ec2.FlowLogFormat.V4: Includes all fields from V3, as well as information about
+  the region and AZ associated with the traffic.
+* ec2.FlowLogFormat.V5: Includes all fields from V4, as well as information that
+  provides visibility on packet routing.
+
+### Caveats
 
-```
-declase const operator: k8s_aws.ExternalSecretsOperator;
-declare const secret: secretsmanager.Secret;
-
-operator.registerSecretsManagerSecret('sychronized-secret', secret, {
-    name: 'database-secret'
-});
-```
-
-Only import specific JSON keys from a secret:
-
-```
-declase const operator: k8s_aws.ExternalSecretsOperator;
-declare const secret: secretsmanager.Secret;
-
-operator.registerSecretsManagerSecret('sychronized-secret', secret, {
-    fields: [
-        { kubernetesKey: 'username' },
-        { kubernetesKey: 'password' },
-    ]
-});
-```
+With the offical AWS CDK VPC construct, you can normally add a Flow Log to a VPC
+by using the addFlowLog() method like this:
 
-Map secret fields that need to be different between Secrets Manager and Kubernetes.
+```python
+const vpc = new ec2.Vpc(this, 'Vpc');
 
+vpc.addFlowLog('FlowLog');
 ```
-declase const operator: k8s_aws.ExternalSecretsOperator;
-declare const secret: secretsmanager.Secret;
 
-operator.registerSecretsManagerSecret('sychronized-secret', secret, {
-    fields: [
-        {
-            kubernetesKey: 'user',
-            remoteKey: 'username',
-        },
-        {
-            kubernetesKey: 'pass',
-            remoteKey: 'password'
-        },
-    ]
-});
-```
-
-## Echoserver
-
-A basic Kubernetes test service that can be used for testing Kubernetes cluster integrations.
-
-This is a simple HTTP service that listens for incoming requests and echo details of requests back to the user.
-
-Log messages are produced for each request and provide a convenient way to test logging filter and output configurations.
-
-To create an echoserver service:
-
-```
-declare const cluster: eks.Cluster;
-
-const echoserver = new k8s_aws.Echoserver(this, 'echoserver', {
-    cluster: cluster
-});
-```
+However, this will not include the additional FlowLogFormat functionality
+provided by the FlowLog construct in this module.
 '''
 import abc
 import builtins
 import datetime
 import enum
 import typing
 
@@ -247,385 +109,520 @@
 import typing_extensions
 
 from typeguard import check_type
 
 from .._jsii import *
 
 import aws_cdk as _aws_cdk_ceddda9d
+import aws_cdk.aws_cloudwatch as _aws_cdk_aws_cloudwatch_ceddda9d
 import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
-import aws_cdk.aws_eks as _aws_cdk_aws_eks_ceddda9d
 import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
-import aws_cdk.aws_kinesis as _aws_cdk_aws_kinesis_ceddda9d
 import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
-import aws_cdk.aws_opensearchservice as _aws_cdk_aws_opensearchservice_ceddda9d
-import aws_cdk.aws_secretsmanager as _aws_cdk_aws_secretsmanager_ceddda9d
-import aws_cdk.aws_ssm as _aws_cdk_aws_ssm_ceddda9d
+import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
 import constructs as _constructs_77d1e7e8
-from ..core import DataSize as _DataSize_d20aaece
-from ..kinesis_firehose import IDeliveryStream as _IDeliveryStream_cf5feed7
-from ..route53 import (
-    Domain as _Domain_165656f2,
-    DomainDiscovery as _DomainDiscovery_440eb9b9,
-    IDnsResolvable as _IDnsResolvable_adf49001,
+from ..ram import (
+    ISharedPrincipal as _ISharedPrincipal_9cde791b,
+    ResourceShare as _ResourceShare_f0180713,
 )
 
 
-class AdotCollector(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.AdotCollector",
-):
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.AddChildPoolOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "address_configuration": "addressConfiguration",
+        "auto_import": "autoImport",
+        "consumer": "consumer",
+        "description": "description",
+        "locale": "locale",
+        "name": "name",
+        "provisioned_cidrs": "provisionedCidrs",
+        "public_ip_source": "publicIpSource",
+        "tag_restrictions": "tagRestrictions",
+    },
+)
+class AddChildPoolOptions:
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        create_namespace: typing.Optional[builtins.bool] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the AdotCollector class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the ADOT Collector will be deployed.
-        :param create_namespace: Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to. Default: true
-        :param namespace: The Kubernetes namespace where resources related to the ADOT collector will be created. Default: {@link AdotCollector.DEFAULT_NAMESPACE}
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f74f3540f9b92e5b04d00972307fd2234b5b3488c35a04325788dc39ab7af1c1)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = AdotCollectorProps(
-            cluster=cluster,
-            create_namespace=create_namespace,
-            namespace=namespace,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        address_configuration: typing.Optional["AddressConfiguration"] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional["IpamConsumer"] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> None:
+        '''
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cd5beb9fcc270b7b94143a1da76f2e055d3a985146435bc15a04bde77d16af22)
+            check_type(argname="argument address_configuration", value=address_configuration, expected_type=type_hints["address_configuration"])
+            check_type(argname="argument auto_import", value=auto_import, expected_type=type_hints["auto_import"])
+            check_type(argname="argument consumer", value=consumer, expected_type=type_hints["consumer"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument locale", value=locale, expected_type=type_hints["locale"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument provisioned_cidrs", value=provisioned_cidrs, expected_type=type_hints["provisioned_cidrs"])
+            check_type(argname="argument public_ip_source", value=public_ip_source, expected_type=type_hints["public_ip_source"])
+            check_type(argname="argument tag_restrictions", value=tag_restrictions, expected_type=type_hints["tag_restrictions"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if address_configuration is not None:
+            self._values["address_configuration"] = address_configuration
+        if auto_import is not None:
+            self._values["auto_import"] = auto_import
+        if consumer is not None:
+            self._values["consumer"] = consumer
+        if description is not None:
+            self._values["description"] = description
+        if locale is not None:
+            self._values["locale"] = locale
+        if name is not None:
+            self._values["name"] = name
+        if provisioned_cidrs is not None:
+            self._values["provisioned_cidrs"] = provisioned_cidrs
+        if public_ip_source is not None:
+            self._values["public_ip_source"] = public_ip_source
+        if tag_restrictions is not None:
+            self._values["tag_restrictions"] = tag_restrictions
 
-        jsii.create(self.__class__, self, [scope, id, props])
+    @builtins.property
+    def address_configuration(self) -> typing.Optional["AddressConfiguration"]:
+        result = self._values.get("address_configuration")
+        return typing.cast(typing.Optional["AddressConfiguration"], result)
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
-    def DEFAULT_NAMESPACE(cls) -> builtins.str:
-        '''The default Kubernetes namespace where resources related to the ADOT collector will be created if no overriding input is provided.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
+    @builtins.property
+    def auto_import(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("auto_import")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the ADOT Collector will be deployed.
+    def consumer(self) -> typing.Optional["IpamConsumer"]:
+        result = self._values.get("consumer")
+        return typing.cast(typing.Optional["IpamConsumer"], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="createNamespace")
-    def create_namespace(self) -> builtins.bool:
-        '''Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to.
+    def locale(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("locale")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(builtins.bool, jsii.get(self, "createNamespace"))
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="manifest")
-    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
-        '''The Kubernetes manifest used to deploy the ADOT Collector.
+    def provisioned_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("provisioned_cidrs")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+    @builtins.property
+    def public_ip_source(self) -> typing.Optional["PublicIpSource"]:
+        result = self._values.get("public_ip_source")
+        return typing.cast(typing.Optional["PublicIpSource"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> builtins.str:
-        '''The Kubernetes namespace where resources related to the ADOT collector will be created.
+    def tag_restrictions(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        result = self._values.get("tag_restrictions")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "namespace"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="serviceAccount")
-    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
-        '''The Kubernetes service account that allows the ADOT collector to gather metric information and publish it to CloudWatch.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
+    def __repr__(self) -> str:
+        return "AddChildPoolOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.AdotCollectorProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "cluster": "cluster",
-        "create_namespace": "createNamespace",
-        "namespace": "namespace",
-    },
+    jsii_type="cdk-extensions.ec2.AddCidrToPoolOptions",
+    jsii_struct_bases=[],
+    name_mapping={"configuration": "configuration", "allow_inline": "allowInline"},
 )
-class AdotCollectorProps(_aws_cdk_ceddda9d.ResourceProps):
+class AddCidrToPoolOptions:
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        create_namespace: typing.Optional[builtins.bool] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        configuration: "IIpamPoolCidrConfiguration",
+        allow_inline: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Condifuration for the AdorCollector resource.
-
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the ADOT Collector will be deployed.
-        :param create_namespace: Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to. Default: true
-        :param namespace: The Kubernetes namespace where resources related to the ADOT collector will be created. Default: {@link AdotCollector.DEFAULT_NAMESPACE}
+        '''
+        :param configuration: 
+        :param allow_inline: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__83410ce825ec752c0effc192594680947acd69763ae265765f04ad25b86fed2c)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument create_namespace", value=create_namespace, expected_type=type_hints["create_namespace"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            type_hints = typing.get_type_hints(_typecheckingstub__8b557d5630889b3b826710341420be9ea32da521b6a064c2251649dc037dc337)
+            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
+            check_type(argname="argument allow_inline", value=allow_inline, expected_type=type_hints["allow_inline"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
+            "configuration": configuration,
         }
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if create_namespace is not None:
-            self._values["create_namespace"] = create_namespace
-        if namespace is not None:
-            self._values["namespace"] = namespace
+        if allow_inline is not None:
+            self._values["allow_inline"] = allow_inline
 
     @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
-
-        :default: - the resource is in the same account as the stack it belongs to
-        '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def configuration(self) -> "IIpamPoolCidrConfiguration":
+        result = self._values.get("configuration")
+        assert result is not None, "Required property 'configuration' is missing"
+        return typing.cast("IIpamPoolCidrConfiguration", result)
 
     @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
+    def allow_inline(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("allow_inline")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        Cannot be supplied together with either ``account`` or ``region``.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+    def __repr__(self) -> str:
+        return "AddCidrToPoolOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.AddCidrToPoolResult",
+    jsii_struct_bases=[],
+    name_mapping={"inline": "inline", "cidr": "cidr"},
+)
+class AddCidrToPoolResult:
+    def __init__(
+        self,
+        *,
+        inline: builtins.bool,
+        cidr: typing.Optional["IIpamPoolCidr"] = None,
+    ) -> None:
         '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param inline: 
+        :param cidr: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f02f76e73f9cee1844c78b045ee1860b4da77cb2b3ea7f9d760139719e314877)
+            check_type(argname="argument inline", value=inline, expected_type=type_hints["inline"])
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "inline": inline,
+        }
+        if cidr is not None:
+            self._values["cidr"] = cidr
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
+    def inline(self) -> builtins.bool:
+        result = self._values.get("inline")
+        assert result is not None, "Required property 'inline' is missing"
+        return typing.cast(builtins.bool, result)
 
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+    @builtins.property
+    def cidr(self) -> typing.Optional["IIpamPoolCidr"]:
+        result = self._values.get("cidr")
+        return typing.cast(typing.Optional["IIpamPoolCidr"], result)
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "AddCidrToPoolResult(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class AddressConfiguration(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.AddressConfiguration",
+):
+    @jsii.member(jsii_name="ipv4")
+    @builtins.classmethod
+    def ipv4(
+        cls,
+        *,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> "AddressConfiguration":
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        '''
+        options = Ipv4ConfigurationOptions(
+            default_netmask_length=default_netmask_length,
+            max_netmask_length=max_netmask_length,
+            min_netmask_length=min_netmask_length,
+        )
 
-    @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+        return typing.cast("AddressConfiguration", jsii.sinvoke(cls, "ipv4", [options]))
 
-        :default: - the resource is in the same region as the stack it belongs to
+    @jsii.member(jsii_name="ipv6")
+    @builtins.classmethod
+    def ipv6(
+        cls,
+        *,
+        publicly_advertisable: typing.Optional[builtins.bool] = None,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> "AddressConfiguration":
+        '''
+        :param publicly_advertisable: 
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        '''
+        options = Ipv6ConfigurationOptions(
+            publicly_advertisable=publicly_advertisable,
+            default_netmask_length=default_netmask_length,
+            max_netmask_length=max_netmask_length,
+            min_netmask_length=min_netmask_length,
+        )
+
+        return typing.cast("AddressConfiguration", jsii.sinvoke(cls, "ipv6", [options]))
+
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(
+        cls,
+        *,
+        family: builtins.str,
+        publicly_advertisable: typing.Optional[builtins.bool] = None,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> "AddressConfiguration":
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param family: 
+        :param publicly_advertisable: 
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        '''
+        props = AddressConfigurationProps(
+            family=family,
+            publicly_advertisable=publicly_advertisable,
+            default_netmask_length=default_netmask_length,
+            max_netmask_length=max_netmask_length,
+            min_netmask_length=min_netmask_length,
+        )
+
+        return typing.cast("AddressConfiguration", jsii.sinvoke(cls, "of", [props]))
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the ADOT Collector will be deployed.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+    @jsii.member(jsii_name="family")
+    def family(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "family"))
 
     @builtins.property
-    def create_namespace(self) -> typing.Optional[builtins.bool]:
-        '''Flag wich sets whether the deploy of the ADOT collector should include creating the Kubernetes namespace the service will be deployed to.
+    @jsii.member(jsii_name="defaultNetmaskLength")
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "defaultNetmaskLength"))
 
-        :default: true
-        '''
-        result = self._values.get("create_namespace")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @builtins.property
+    @jsii.member(jsii_name="maxNetmaskLength")
+    def max_netmask_length(self) -> typing.Optional[jsii.Number]:
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxNetmaskLength"))
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where resources related to the ADOT collector will be created.
+    @jsii.member(jsii_name="minNetmaskLength")
+    def min_netmask_length(self) -> typing.Optional[jsii.Number]:
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "minNetmaskLength"))
 
-        :default: {@link AdotCollector.DEFAULT_NAMESPACE}
-        '''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @builtins.property
+    @jsii.member(jsii_name="publiclyAdvertisable")
+    def publicly_advertisable(self) -> typing.Optional[builtins.bool]:
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "publiclyAdvertisable"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+class CidrProvider(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.CidrProvider",
+):
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-    def __repr__(self) -> str:
-        return "AdotCollectorProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @jsii.member(jsii_name="cidr")
+    @builtins.classmethod
+    def cidr(cls, cidr: builtins.str) -> "ICidrProvider":
+        '''
+        :param cidr: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cd7caef254218d4ebf34f9b11023b49732aa598163f909134c5a7bb044eb20cd)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+        return typing.cast("ICidrProvider", jsii.sinvoke(cls, "cidr", [cidr]))
+
+    @jsii.member(jsii_name="ipamPool")
+    @builtins.classmethod
+    def ipam_pool(cls, pool: "IIpamPool", netmask: jsii.Number) -> "ICidrProvider":
+        '''
+        :param pool: -
+        :param netmask: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__12b210002dd74d3c4489f392f3891aa197db959127d48cfc0ab81774265531fb)
+            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
+            check_type(argname="argument netmask", value=netmask, expected_type=type_hints["netmask"])
+        return typing.cast("ICidrProvider", jsii.sinvoke(cls, "ipamPool", [pool, netmask]))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.AppendedRecord",
+    jsii_type="cdk-extensions.ec2.CustomerGatewayAttributes",
     jsii_struct_bases=[],
-    name_mapping={"field_name": "fieldName", "value": "value"},
+    name_mapping={
+        "customer_gateway_id": "customerGatewayId",
+        "bgp_asn": "bgpAsn",
+        "ip_address": "ipAddress",
+    },
 )
-class AppendedRecord:
-    def __init__(self, *, field_name: builtins.str, value: builtins.str) -> None:
-        '''Represents a record field to be added by the record modifier Fluent Bit filter plugin.
+class CustomerGatewayAttributes:
+    def __init__(
+        self,
+        *,
+        customer_gateway_id: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        ip_address: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Attributes used to import an existing customer gateway.
 
-        :param field_name: The name of the field to be added.
-        :param value: The value that the added field should be set to.
+        :param customer_gateway_id: The ID of the existing customer gateway being imported.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__136b7ffe7a51d2c8e1beb7845cc437b6f9c909db4c6852bf9306bb992440df64)
-            check_type(argname="argument field_name", value=field_name, expected_type=type_hints["field_name"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+            type_hints = typing.get_type_hints(_typecheckingstub__35eab003d889c662b910b407f8e02c5f1e0c594802680266f3389251bf5ac9d3)
+            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
+            check_type(argname="argument bgp_asn", value=bgp_asn, expected_type=type_hints["bgp_asn"])
+            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "field_name": field_name,
-            "value": value,
+            "customer_gateway_id": customer_gateway_id,
         }
+        if bgp_asn is not None:
+            self._values["bgp_asn"] = bgp_asn
+        if ip_address is not None:
+            self._values["ip_address"] = ip_address
 
     @builtins.property
-    def field_name(self) -> builtins.str:
-        '''The name of the field to be added.'''
-        result = self._values.get("field_name")
-        assert result is not None, "Required property 'field_name' is missing"
+    def customer_gateway_id(self) -> builtins.str:
+        '''The ID of the existing customer gateway being imported.'''
+        result = self._values.get("customer_gateway_id")
+        assert result is not None, "Required property 'customer_gateway_id' is missing"
         return typing.cast(builtins.str, result)
 
     @builtins.property
-    def value(self) -> builtins.str:
-        '''The value that the added field should be set to.'''
-        result = self._values.get("value")
-        assert result is not None, "Required property 'value' is missing"
-        return typing.cast(builtins.str, result)
+    def bgp_asn(self) -> typing.Optional[jsii.Number]:
+        '''For devices that support BGP, the customer gateway's BGP ASN.'''
+        result = self._values.get("bgp_asn")
+        return typing.cast(typing.Optional[jsii.Number], result)
+
+    @builtins.property
+    def ip_address(self) -> typing.Optional[builtins.str]:
+        '''The Internet-routable IP address for the customer gateway's outside interface.
+
+        The address must be static.
+        '''
+        result = self._values.get("ip_address")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "AppendedRecord(%s)" % ", ".join(
+        return "CustomerGatewayAttributes(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.AwsSecretStoreProps",
+    jsii_type="cdk-extensions.ec2.CustomerGatewayProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cluster": "cluster",
-        "service": "service",
-        "name": "name",
-        "namespace": "namespace",
+        "ip_address": "ipAddress",
+        "bgp_asn": "bgpAsn",
+        "connection_type": "connectionType",
     },
 )
-class AwsSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
+class CustomerGatewayProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        service: builtins.str,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        ip_address: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
     ) -> None:
-        '''Configuration options for adding a new secret store resource.
+        '''Configuration for the CustomerGateway resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param service: The name of the service provider backing the secret store.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param connection_type: The type of VPN connection that this customer gateway supports.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__47bd0514e52ab251753fed926ac3aec8ea7a2344e24eb13a2eeacbcf646482c3)
+            type_hints = typing.get_type_hints(_typecheckingstub__e250ab0ff20773956eb3b2131200a7ee56b455ba85d22729b69f588d369a8193)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument ip_address", value=ip_address, expected_type=type_hints["ip_address"])
+            check_type(argname="argument bgp_asn", value=bgp_asn, expected_type=type_hints["bgp_asn"])
+            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
-            "service": service,
+            "ip_address": ip_address,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if name is not None:
-            self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
+        if bgp_asn is not None:
+            self._values["bgp_asn"] = bgp_asn
+        if connection_type is not None:
+            self._values["connection_type"] = connection_type
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -667,1493 +664,902 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret store should be created.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+    def ip_address(self) -> builtins.str:
+        '''The Internet-routable IP address for the customer gateway's outside interface.
 
-    @builtins.property
-    def service(self) -> builtins.str:
-        '''The name of the service provider backing the secret store.'''
-        result = self._values.get("service")
-        assert result is not None, "Required property 'service' is missing"
+        The address must be static.
+
+        :see: `CustomerGateway IpAddress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress>`_
+        '''
+        result = self._values.get("ip_address")
+        assert result is not None, "Required property 'ip_address' is missing"
         return typing.cast(builtins.str, result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A human friendly name for the secret store.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def bgp_asn(self) -> typing.Optional[jsii.Number]:
+        '''For devices that support BGP, the customer gateway's BGP ASN.
+
+        :see: `CustomerGateway BgpAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn>`_
+        '''
+        result = self._values.get("bgp_asn")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the secret store should be created.'''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
+        '''The type of VPN connection that this customer gateway supports.
+
+        :see: `CustomerGateway Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type>`_
+        '''
+        result = self._values.get("connection_type")
+        return typing.cast(typing.Optional["VpnConnectionType"], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "AwsSecretStoreProps(%s)" % ", ".join(
+        return "CustomerGatewayProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IConnectable, _IDnsResolvable_adf49001)
-class Echoserver(
-    _aws_cdk_ceddda9d.Resource,
+class FlowLog(
+    _aws_cdk_aws_ec2_ceddda9d.FlowLog,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.Echoserver",
+    jsii_type="cdk-extensions.ec2.FlowLog",
 ):
-    '''Creates a simple Kubernetes test service using the Google echoserver test image.
-
-    The server listens for incoming web requests and echos the details of the
-    request back to the user. Each request results in output being written to
-    the Docker log providing a convenient way to test logging setup.
-
-    :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
-    '''
-
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
+        scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
-        load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replicas: typing.Optional[jsii.Number] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subdomain: typing.Optional[builtins.str] = None,
-        tag: typing.Optional[builtins.str] = None,
+        resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
+        destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
+        flow_log_name: typing.Optional[builtins.str] = None,
+        log_format: typing.Optional["FlowLogFormat"] = None,
+        max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
+        traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the Echoserver class.
+        '''Creates a new instance of the FlowLog class.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS Cluster where the service should be deployed.
-        :param domain_discovery: Determines the behavior of automatic DNS discovery and configuration. Default: DomainDiscovery.PUBLIC
-        :param load_balancer_subnets: The subnets where the load balancer should be created.
-        :param name: The name of the Kubernetes service to be created. Default: 'echoserver'
-        :param namespace: The Kubernetes namespace where the service should be created. Default: 'default'
-        :param port: The port which netcat should listen on. Default: 80
-        :param replicas: The number of replicas that should exist. Default: 1
-        :param security_groups: The Security groups which should be applied to the service.
-        :param subdomain: A subdomain that should be prefixed to the beginning of all registered domains.
-        :param tag: The Docker tag specifying the version of echoserver to use.
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param resource_type: Details for the resource from which flow logs will be captured.
+        :param destination: The location where flow logs should be delivered.
+        :param flow_log_name: The name of the FlowLog.
+        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see {@link FlowLogField}.
+        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
+        :param traffic_type: The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__60e02c2df9c0996603c08992bffb8b230ed1d150d3db1a8f557f6056710b9fda)
+            type_hints = typing.get_type_hints(_typecheckingstub__685f60b23d7e8e561b55bc9dca121799b9d63919b8e78b372a1fa549c234455e)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = EchoserverProps(
-            cluster=cluster,
-            domain_discovery=domain_discovery,
-            load_balancer_subnets=load_balancer_subnets,
-            name=name,
-            namespace=namespace,
-            port=port,
-            replicas=replicas,
-            security_groups=security_groups,
-            subdomain=subdomain,
-            tag=tag,
+        props = FlowLogProps(
+            resource_type=resource_type,
+            destination=destination,
+            flow_log_name=flow_log_name,
+            log_format=log_format,
+            max_aggregation_interval=max_aggregation_interval,
+            traffic_type=traffic_type,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="registerDomain")
-    def register_domain(self, domain: _Domain_165656f2) -> None:
-        '''
-        :param domain: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__03259ca27e67ce6d4b989554c5fe17209a196689cf650ff94b81215ab7406124)
-            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
-        return typing.cast(None, jsii.invoke(self, "registerDomain", [domain]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_DOMAIN_DISCOVERY")
-    def DEFAULT_DOMAIN_DISCOVERY(cls) -> _DomainDiscovery_440eb9b9:
-        '''The default setting controlling how automatic DNS configuration should behave if none is provided as input.'''
-        return typing.cast(_DomainDiscovery_440eb9b9, jsii.sget(cls, "DEFAULT_DOMAIN_DISCOVERY"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_LOAD_BALANCER_SUBNETS")
-    def DEFAULT_LOAD_BALANCER_SUBNETS(cls) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
-        '''Default subnet selection that will be used if none is provided as input.'''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.sget(cls, "DEFAULT_LOAD_BALANCER_SUBNETS"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_NAME")
-    def DEFAULT_NAME(cls) -> builtins.str:
-        '''Default name of the Kubernetes service that will be created if none is provided as input.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAME"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
-    def DEFAULT_NAMESPACE(cls) -> builtins.str:
-        '''Default Kubernetes namespace where the service will be created if none is provided as input.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_PORT")
-    def DEFAULT_PORT(cls) -> jsii.Number:
-        '''Default port where the service will be accessible if none is provided as input.'''
-        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_PORT"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_REPLICAS")
-    def DEFAULT_REPLICAS(cls) -> jsii.Number:
-        '''Default number of replicas that should be running is none is provided as input.'''
-        return typing.cast(jsii.Number, jsii.sget(cls, "DEFAULT_REPLICAS"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_REPOSITORY")
-    def DEFAULT_REPOSITORY(cls) -> builtins.str:
-        '''The Docker repository where the echoserver image will be pulled from.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_REPOSITORY"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_TAG")
-    def DEFAULT_TAG(cls) -> builtins.str:
-        '''The default Docker tag of the image to use if none is provided as input.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_TAG"))
-
     @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS Cluster where the service should be deployed.
+    @jsii.member(jsii_name="destination")
+    def destination(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogDestination:
+        '''The location where flow logs should be delivered.
 
+        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
         :group: Inputs
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination, jsii.get(self, "destination"))
 
     @builtins.property
-    @jsii.member(jsii_name="connections")
-    def connections(self) -> _aws_cdk_aws_ec2_ceddda9d.Connections:
-        '''Access for network connections.
-
-        :group: IConnectable
-        '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Connections, jsii.get(self, "connections"))
-
-    @builtins.property
-    @jsii.member(jsii_name="domainDiscovery")
-    def domain_discovery(self) -> _DomainDiscovery_440eb9b9:
-        '''Determines the behavior of automatic DNS discovery and configuration.
-
-        :group: IDnsResolvable
-        '''
-        return typing.cast(_DomainDiscovery_440eb9b9, jsii.get(self, "domainDiscovery"))
+    @jsii.member(jsii_name="logFormat")
+    def log_format(self) -> "FlowLogFormat":
+        '''The fields to include in the flow log record, in the order in which they should appear.
 
-    @builtins.property
-    @jsii.member(jsii_name="loadBalancerSubnets")
-    def load_balancer_subnets(self) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
-        '''The subnets where the load balancer should be created..
+        For a list of available fields, see {@link FlowLogField}.
 
+        :see: `FlowLog LogFormat <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat>`_
         :group: Inputs
         '''
-        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.get(self, "loadBalancerSubnets"))
+        return typing.cast("FlowLogFormat", jsii.get(self, "logFormat"))
 
     @builtins.property
-    @jsii.member(jsii_name="manifest")
-    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
-        '''The Kubernetes manifest that creates the ConfigMap that Fargate uses to configure logging.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnFlowLog:
+        '''The underlying FlowLog CloudFormation resource.
 
+        :see: `AWS::EC2::FlowLog <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html>`_
         :group: Resources
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnFlowLog, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the Kubernetes service to be created.
+    @jsii.member(jsii_name="resourceType")
+    def resource_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType:
+        '''Details for the resource from which flow logs will be captured.
 
+        :see: `FlowLog ResourceType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype>`_
         :group: Inputs
         '''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType, jsii.get(self, "resourceType"))
 
     @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> builtins.str:
-        '''The Kubernetes namespace where the service should be created.
+    @jsii.member(jsii_name="trafficType")
+    def traffic_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType:
+        '''The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
 
+        :see: `FlowLog TrafficType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype>`_
         :group: Inputs
         '''
-        return typing.cast(builtins.str, jsii.get(self, "namespace"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType, jsii.get(self, "trafficType"))
 
     @builtins.property
-    @jsii.member(jsii_name="port")
-    def port(self) -> jsii.Number:
-        '''The port which netcat should listen on.
+    @jsii.member(jsii_name="flowLogName")
+    def flow_log_name(self) -> typing.Optional[builtins.str]:
+        '''The name of the FlowLog.
 
         :group: Inputs
         '''
-        return typing.cast(jsii.Number, jsii.get(self, "port"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "flowLogName"))
 
     @builtins.property
-    @jsii.member(jsii_name="replicas")
-    def replicas(self) -> jsii.Number:
-        '''The number of replicas that should exist.
+    @jsii.member(jsii_name="maxAggregationInterval")
+    def max_aggregation_interval(
+        self,
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval]:
+        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
 
+        :see: `FlowLog MaxAggregationInterval <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval>`_
         :group: Inputs
         '''
-        return typing.cast(jsii.Number, jsii.get(self, "replicas"))
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval], jsii.get(self, "maxAggregationInterval"))
 
-    @builtins.property
-    @jsii.member(jsii_name="tag")
-    def tag(self) -> builtins.str:
-        '''The Docker tag specifying the version of echoserver to use.
-
-        :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "tag"))
 
-    @builtins.property
-    @jsii.member(jsii_name="subdomain")
-    def subdomain(self) -> typing.Optional[builtins.str]:
-        '''A subdomain that should be prefixed to the beginning of all registered domains.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subdomain"))
+@jsii.enum(jsii_type="cdk-extensions.ec2.FlowLogDataType")
+class FlowLogDataType(enum.Enum):
+    INT_32 = "INT_32"
+    '''32 bit signed int.'''
+    INT_64 = "INT_64"
+    '''64 bit signed int.'''
+    STRING = "STRING"
+    '''UTF-8 encoded character string.'''
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.EchoserverProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.ec2.FlowLogDestinationConfig",
+    jsii_struct_bases=[],
     name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "cluster": "cluster",
-        "domain_discovery": "domainDiscovery",
-        "load_balancer_subnets": "loadBalancerSubnets",
-        "name": "name",
-        "namespace": "namespace",
-        "port": "port",
-        "replicas": "replicas",
-        "security_groups": "securityGroups",
-        "subdomain": "subdomain",
-        "tag": "tag",
+        "destination_type": "destinationType",
+        "bucket": "bucket",
+        "destination_options": "destinationOptions",
+        "log_group": "logGroup",
+        "role": "role",
+        "s3_path": "s3Path",
     },
 )
-class EchoserverProps(_aws_cdk_ceddda9d.ResourceProps):
+class FlowLogDestinationConfig:
     def __init__(
         self,
         *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
-        load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replicas: typing.Optional[jsii.Number] = None,
-        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-        subdomain: typing.Optional[builtins.str] = None,
-        tag: typing.Optional[builtins.str] = None,
+        destination_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType,
+        bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
+        destination_options: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+        s3_path: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration for the Echoserver resource.
+        '''A configuration object providing the details necessary to set up log delivery to a given destination.
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS Cluster where the service should be deployed.
-        :param domain_discovery: Determines the behavior of automatic DNS discovery and configuration. Default: DomainDiscovery.PUBLIC
-        :param load_balancer_subnets: The subnets where the load balancer should be created.
-        :param name: The name of the Kubernetes service to be created. Default: 'echoserver'
-        :param namespace: The Kubernetes namespace where the service should be created. Default: 'default'
-        :param port: The port which netcat should listen on. Default: 80
-        :param replicas: The number of replicas that should exist. Default: 1
-        :param security_groups: The Security groups which should be applied to the service.
-        :param subdomain: A subdomain that should be prefixed to the beginning of all registered domains.
-        :param tag: The Docker tag specifying the version of echoserver to use.
-        '''
-        if isinstance(load_balancer_subnets, dict):
-            load_balancer_subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**load_balancer_subnets)
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__cabc692f43b347b0dcc6dbe743c4a7fac3e1c95cc035ff3ff3ef2509fdef86f5)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument domain_discovery", value=domain_discovery, expected_type=type_hints["domain_discovery"])
-            check_type(argname="argument load_balancer_subnets", value=load_balancer_subnets, expected_type=type_hints["load_balancer_subnets"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
-            check_type(argname="argument replicas", value=replicas, expected_type=type_hints["replicas"])
-            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
-            check_type(argname="argument subdomain", value=subdomain, expected_type=type_hints["subdomain"])
-            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
+        :param destination_type: The type of destination for the flow log data.
+        :param bucket: An S3 bucket where logs should be delivered.
+        :param destination_options: Additional options that control the format and behavior of logs delivered to the destination.
+        :param log_group: A CloudWatch LogGroup where logs should be delivered.
+        :param role: The ARN of the IAM role that allows Amazon EC2 to publish flow logs in your account.
+        :param s3_path: An Amazon Resource Name (ARN) for the S3 destination where log files are to be delivered. If a custom prefix is being added the ARN should reflect that prefix.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__11b243acaaaa5840cda314f12b7b4d009805f9002ef9847296dedc4c734cfaa8)
+            check_type(argname="argument destination_type", value=destination_type, expected_type=type_hints["destination_type"])
+            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
+            check_type(argname="argument destination_options", value=destination_options, expected_type=type_hints["destination_options"])
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+            check_type(argname="argument s3_path", value=s3_path, expected_type=type_hints["s3_path"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
+            "destination_type": destination_type,
         }
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if domain_discovery is not None:
-            self._values["domain_discovery"] = domain_discovery
-        if load_balancer_subnets is not None:
-            self._values["load_balancer_subnets"] = load_balancer_subnets
-        if name is not None:
-            self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
-        if port is not None:
-            self._values["port"] = port
-        if replicas is not None:
-            self._values["replicas"] = replicas
-        if security_groups is not None:
-            self._values["security_groups"] = security_groups
-        if subdomain is not None:
-            self._values["subdomain"] = subdomain
-        if tag is not None:
-            self._values["tag"] = tag
-
-    @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
-
-        :default: - the resource is in the same account as the stack it belongs to
-        '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
-
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
-
-        Cannot be supplied together with either ``account`` or ``region``.
-
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
-
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
-
-        :default: - The physical name will be allocated by CloudFormation at deployment time
-        '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if bucket is not None:
+            self._values["bucket"] = bucket
+        if destination_options is not None:
+            self._values["destination_options"] = destination_options
+        if log_group is not None:
+            self._values["log_group"] = log_group
+        if role is not None:
+            self._values["role"] = role
+        if s3_path is not None:
+            self._values["s3_path"] = s3_path
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def destination_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType:
+        '''The type of destination for the flow log data.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS Cluster where the service should be deployed.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+        result = self._values.get("destination_type")
+        assert result is not None, "Required property 'destination_type' is missing"
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType, result)
 
     @builtins.property
-    def domain_discovery(self) -> typing.Optional[_DomainDiscovery_440eb9b9]:
-        '''Determines the behavior of automatic DNS discovery and configuration.
+    def bucket(self) -> typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket]:
+        '''An S3 bucket where logs should be delivered.
 
-        :default: DomainDiscovery.PUBLIC
+        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
         '''
-        result = self._values.get("domain_discovery")
-        return typing.cast(typing.Optional[_DomainDiscovery_440eb9b9], result)
+        result = self._values.get("bucket")
+        return typing.cast(typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket], result)
 
     @builtins.property
-    def load_balancer_subnets(
+    def destination_options(
         self,
-    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
-        '''The subnets where the load balancer should be created.'''
-        result = self._values.get("load_balancer_subnets")
-        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Kubernetes service to be created.
-
-        :default: 'echoserver'
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the service should be created.
-
-        :default: 'default'
-        '''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
+        '''Additional options that control the format and behavior of logs delivered to the destination.'''
+        result = self._values.get("destination_options")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)
 
     @builtins.property
-    def port(self) -> typing.Optional[jsii.Number]:
-        '''The port which netcat should listen on.
+    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
+        '''A CloudWatch LogGroup where logs should be delivered.
 
-        :default: 80
+        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
         '''
-        result = self._values.get("port")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        result = self._values.get("log_group")
+        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
 
     @builtins.property
-    def replicas(self) -> typing.Optional[jsii.Number]:
-        '''The number of replicas that should exist.
+    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
+        '''The ARN of the IAM role that allows Amazon EC2 to publish flow logs in your account.
 
-        :default: 1
+        :see: `FlowLog DeliverLogsPermissionArn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn>`_
         '''
-        result = self._values.get("replicas")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def security_groups(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
-        '''The Security groups which should be applied to the service.'''
-        result = self._values.get("security_groups")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)
+        result = self._values.get("role")
+        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
 
     @builtins.property
-    def subdomain(self) -> typing.Optional[builtins.str]:
-        '''A subdomain that should be prefixed to the beginning of all registered domains.'''
-        result = self._values.get("subdomain")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def s3_path(self) -> typing.Optional[builtins.str]:
+        '''An Amazon Resource Name (ARN) for the S3 destination where log files are to be delivered.
 
-    @builtins.property
-    def tag(self) -> typing.Optional[builtins.str]:
-        '''The Docker tag specifying the version of echoserver to use.
+        If a custom prefix is being added the ARN should reflect that prefix.
 
-        :see: `Google echoserver image repository <https://console.cloud.google.com/gcr/images/google-containers/GLOBAL/echoserver>`_
+        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
         '''
-        result = self._values.get("tag")
+        result = self._values.get("s3_path")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "EchoserverProps(%s)" % ", ".join(
+        return "FlowLogDestinationConfig(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ElasticsearchCompressionFormat")
-class ElasticsearchCompressionFormat(enum.Enum):
-    GZIP = "GZIP"
-    '''Gzip compression format.'''
-
-
-class ElasticsearchOutputBufferSize(
+class FlowLogField(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ElasticsearchOutputBufferSize",
+    jsii_type="cdk-extensions.ec2.FlowLogField",
 ):
-    '''Represents the size of the Elasticsearch output buffer to be used by Fluent Bit.'''
-
-    @jsii.member(jsii_name="bytes")
-    @builtins.classmethod
-    def bytes(cls, size: _DataSize_d20aaece) -> "ElasticsearchOutputBufferSize":
-        '''Set the output buffer to a specified data size.
-
-        :param size: The size of the output buffer.
-
-        :return:
+    def __init__(self, name: builtins.str, type: FlowLogDataType) -> None:
+        '''Creates a new instance of the FlowLogField class.
 
-        An output buffer size object representing the specified buffer
-        size.
+        :param name: The name of the Flow Log field, as it should be used when building a format string.
+        :param type: The data type of the field as it would appear in Parquet. For information on the type for various files, see documentation on the `available fields <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-logs-fields>`_.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__91e43731ac6990c08b0792ace3a0c1b48a1f889b6e8d07aca71215174e81ac73)
-            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
-        return typing.cast("ElasticsearchOutputBufferSize", jsii.sinvoke(cls, "bytes", [size]))
+            type_hints = typing.get_type_hints(_typecheckingstub__52a7eb2a067a774b7223df31becb41f1517c9aa30eb3b326b26ad7504939a991)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
+        jsii.create(self.__class__, self, [name, type])
 
-    @jsii.member(jsii_name="of")
+    @jsii.member(jsii_name="lookupField")
     @builtins.classmethod
-    def of(cls, value: builtins.str) -> "ElasticsearchOutputBufferSize":
-        '''An escape hatch that allows an arbitrary value to be set for the Elasticsearch buffer output property.
+    def lookup_field(cls, name: builtins.str) -> typing.Optional["FlowLogField"]:
+        '''Tries to retieve full flow log field data for a log field based on name.
+
+        Returns undefined if the field name is not recognized.
 
-        :param value: The value to use for the Elasticsearch buffer output property.
+        :param name: The name of the FlowLogField to look up.
 
         :return:
 
-        A ``ElasticsearchOutputBufferSize`` object representing the
-        passed value.
+        The FlowLogField data for a field with the given name if one is
+        found.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9124585821a9391bca778d97002afbc3198cbd561399fa87a8e71b45d6ce6eb5)
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ElasticsearchOutputBufferSize", jsii.sinvoke(cls, "of", [value]))
+            type_hints = typing.get_type_hints(_typecheckingstub__186041c191f59ab5a16d388d89fb358a9ce5c7c993bd90eb9e6479e368341acd)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast(typing.Optional["FlowLogField"], jsii.sinvoke(cls, "lookupField", [name]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="UNLIMITED")
-    def UNLIMITED(cls) -> "ElasticsearchOutputBufferSize":
-        '''Set the output buffer size to unlimited.'''
-        return typing.cast("ElasticsearchOutputBufferSize", jsii.sget(cls, "UNLIMITED"))
-
-    @builtins.property
-    @jsii.member(jsii_name="value")
-    def value(self) -> builtins.str:
-        '''The value to use for the Elasticsearch buffer output property.'''
-        return typing.cast(builtins.str, jsii.get(self, "value"))
-
-
-class EmitterStorageType(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.EmitterStorageType",
-):
-    '''Define a buffering mechanism for the new records created by the rewrite tag Fluent Bit filter plugin.'''
-
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, name: builtins.str) -> "EmitterStorageType":
-        '''An escape hatch that allows for specifying a custom value for the rewrite tag plugin's ``Emitter_Storage.type`` field.
-
-        :param name: The name of the buffering type to use.
+    @jsii.member(jsii_name="ACCOUNT_ID")
+    def ACCOUNT_ID(cls) -> "FlowLogField":
+        '''The AWS account ID of the owner of the source network interface for which traffic is recorded.
+
+        If the network interface is created by an
+        AWS service, for example when creating a VPC endpoint or Network Load
+        Balancer, the record might display unknown for this field.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__30778af9523211391b3ca0fed378de136c18bf69752f8852717af5a49e4655da)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("EmitterStorageType", jsii.sinvoke(cls, "of", [name]))
+        return typing.cast("FlowLogField", jsii.sget(cls, "ACCOUNT_ID"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="FILESYSTEM")
-    def FILESYSTEM(cls) -> "EmitterStorageType":
-        '''Buffer records on the filesystem.
-
-        This is recommended if the destination for new records generated might
-        face backpressure due to latency or slow network speeds.
+    @jsii.member(jsii_name="ACTION")
+    def ACTION(cls) -> "FlowLogField":
+        '''The action that is associated with the traffic:.
+
+        ACCEPT: The recorded traffic was permitted by the security groups and
+        network ACLs.
+        REJECT: The recorded traffic was not permitted by the security groups
+        or network ACLs.
         '''
-        return typing.cast("EmitterStorageType", jsii.sget(cls, "FILESYSTEM"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "ACTION"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="MEMORY")
-    def MEMORY(cls) -> "EmitterStorageType":
-        '''Buffer records in memory.
+    @jsii.member(jsii_name="AZ_ID")
+    def AZ_ID(cls) -> "FlowLogField":
+        '''The ID of the Availability Zone that contains the network interface for which traffic is recorded.
 
-        This is the default behavior.
+        If the traffic is from a sublocation, the
+        record displays a '-' symbol for this field.
         '''
-        return typing.cast("EmitterStorageType", jsii.sget(cls, "MEMORY"))
-
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the emitter storage type as it should appear in the plugin configuration file.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
-
+        return typing.cast("FlowLogField", jsii.sget(cls, "AZ_ID"))
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsLogFormat")
-class ExternalDnsLogFormat(enum.Enum):
-    '''The format external dns should use to output logs.'''
-
-    JSON = "JSON"
-    '''Output logs will be written as JSON objects.'''
-    TEXT = "TEXT"
-    '''Output logs will be written in plain text.'''
-
-
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsLogLevel")
-class ExternalDnsLogLevel(enum.Enum):
-    '''Verbosity of the logs generated by the external-dns service.'''
-
-    PANIC = "PANIC"
-    '''Set log level to 'panic'.'''
-    DEBUG = "DEBUG"
-    '''Set log level to 'debug'.'''
-    INFO = "INFO"
-    '''Set log level to 'info'.'''
-    WARNING = "WARNING"
-    '''Set log level to 'warning'.'''
-    ERROR = "ERROR"
-    '''Set log level to 'error'.'''
-    FATAL = "FATAL"
-    '''Set log level to 'fatal'.'''
-    TRACE = "TRACE"
-    '''Set log level to 'trace'.'''
-
-
-class ExternalDnsRegistry(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ExternalDnsRegistry",
-):
-    '''Helper class that provides access to the available ExternalDns registry options.'''
-
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
-
-    @jsii.member(jsii_name="awsServiceDiscovery")
-    @builtins.classmethod
-    def aws_service_discovery(cls) -> "AwsServiceDiscoveryRegistry":
-        '''An ExternalDNS registry that tracks DNS record ownership information using AWS Service Discovery.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="BYTES")
+    def BYTES(cls) -> "FlowLogField":
+        '''The number of bytes transferred during the flow.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "BYTES"))
 
-        :return:
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DSTADDR")
+    def DSTADDR(cls) -> "FlowLogField":
+        '''The destination address for outgoing traffic, or the IPv4 or IPv6 address of the network interface for incoming traffic on the network interface.
 
-        A ExternalDNS registry object configured to use AWS Cloud Map
-        for ownership information.
+        The IPv4 address of the network interface is always its
+        private IPv4 address.
 
-        :see: `AWS Cloud Map <https://docs.aws.amazon.com/cloud-map/latest/dg/what-is-cloud-map.html>`_
+        See also:
+        {@link FlowLogField.PKT_DSTADDR | PKT_DSTADDR}
         '''
-        return typing.cast("AwsServiceDiscoveryRegistry", jsii.sinvoke(cls, "awsServiceDiscovery", []))
+        return typing.cast("FlowLogField", jsii.sget(cls, "DSTADDR"))
 
-    @jsii.member(jsii_name="noop")
-    @builtins.classmethod
-    def noop(cls) -> "NoopRegistry":
-        '''A placeholder ExternalDNS registry that says ExternalDNS should use not use a registry.
-
-        When configuring ExternalDNS without a registry, the service has no idea
-        the original creator and maintainer of DNS records. This means that
-        there are likely to be conflicts if there are multiple services that
-        could create or change DNS records in the same zone.
-
-        :return:
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="DSTPORT")
+    def DSTPORT(cls) -> "FlowLogField":
+        '''The destination port of the traffic.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "DSTPORT"))
 
-        An object that instructs ExternalDNS to not store record
-        ownership information and will perform record updates without
-        validation.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="END")
+    def END(cls) -> "FlowLogField":
+        '''The time, in Unix seconds, when the last packet of the flow was received within the aggregation interval.
+
+        This might be up to 60
+        seconds after the packet was transmitted or received on the network
+        interface.
         '''
-        return typing.cast("NoopRegistry", jsii.sinvoke(cls, "noop", []))
+        return typing.cast("FlowLogField", jsii.sget(cls, "END"))
 
-    @jsii.member(jsii_name="txt")
-    @builtins.classmethod
-    def txt(
-        cls,
-        *,
-        owner_id: typing.Optional[builtins.str] = None,
-        prefix: typing.Optional[builtins.str] = None,
-    ) -> "TxtRegistry":
-        '''An ExternalDNS registry that tracks DNS record ownership information using DNS TXT records.
-
-        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
-        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
-
-        :return:
-
-        A ExternalDNS registry object configured to use DNS TXT records
-        for ownership information.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="FLOW_DIRECTION")
+    def FLOW_DIRECTION(cls) -> "FlowLogField":
+        '''The direction of the flow with respect to the interface where traffic is captured.
 
-        :see: `About TXT records <https://support.google.com/a/answer/2716800?hl=en>`_
+        The possible values are: ingress | egress.
         '''
-        options = TxtRegistryOptions(owner_id=owner_id, prefix=prefix)
-
-        return typing.cast("TxtRegistry", jsii.sinvoke(cls, "txt", [options]))
+        return typing.cast("FlowLogField", jsii.sget(cls, "FLOW_DIRECTION"))
 
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="INSTANCE_ID")
+    def INSTANCE_ID(cls) -> "FlowLogField":
+        '''The ID of the instance that's associated with network interface for which the traffic is recorded, if the instance is owned by you.
+
+        Returns
+        a '-' symbol for a requester-managed network interface; for example,
+        the network interface for a NAT gateway.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ExternalDnsRegistryConfiguration",
-    jsii_struct_bases=[],
-    name_mapping={
-        "registry_type": "registryType",
-        "permissions": "permissions",
-        "properties": "properties",
-    },
-)
-class ExternalDnsRegistryConfiguration:
-    def __init__(
-        self,
-        *,
-        registry_type: builtins.str,
-        permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
-        properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
-    ) -> None:
+        See also:
+        `Request-managed ENI <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/requester-managed-eni.html>`_
         '''
-        :param registry_type: 
-        :param permissions: 
-        :param properties: 
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5f7c8fd432fc4f5005a0f643a18e84adbdbe3cd99f8b0197a9c3b88356ab4c36)
-            check_type(argname="argument registry_type", value=registry_type, expected_type=type_hints["registry_type"])
-            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
-            check_type(argname="argument properties", value=properties, expected_type=type_hints["properties"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "registry_type": registry_type,
-        }
-        if permissions is not None:
-            self._values["permissions"] = permissions
-        if properties is not None:
-            self._values["properties"] = properties
-
-    @builtins.property
-    def registry_type(self) -> builtins.str:
-        result = self._values.get("registry_type")
-        assert result is not None, "Required property 'registry_type' is missing"
-        return typing.cast(builtins.str, result)
-
-    @builtins.property
-    def permissions(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]]:
-        result = self._values.get("permissions")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]], result)
-
-    @builtins.property
-    def properties(self) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
-        result = self._values.get("properties")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "ExternalDnsRegistryConfiguration(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsSyncPolicy")
-class ExternalDnsSyncPolicy(enum.Enum):
-    '''Controls the operations ExternalDNS will perform on the records it manages.'''
-
-    SYNC = "SYNC"
-    '''Full sync mode.
-
-    Records will be created, updated, and deleted based on the
-    statis of their backing resources on the Kubernetes cluster.
-    '''
-    UPSERT_ONLY = "UPSERT_ONLY"
-    '''Only allow create and update operations.
-
-    Records will have their values
-    set based on the status of their backing Kubernetes resources, however if
-    those resources are removed the DNS records will be retained, set to their
-    last configured value.
-    '''
-
+        return typing.cast("FlowLogField", jsii.sget(cls, "INSTANCE_ID"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ExternalDnsZoneTag",
-    jsii_struct_bases=[],
-    name_mapping={"key": "key", "value": "value"},
-)
-class ExternalDnsZoneTag:
-    def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
-        '''Specifies a tag that can be used to restrict which Hosted Zone external-dns will have access to.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="INTERFACE_ID")
+    def INTERFACE_ID(cls) -> "FlowLogField":
+        '''The ID of the network interface for which the traffic is recorded.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "INTERFACE_ID"))
 
-        :param key: The name of the tag to filter on.
-        :param value: The value of the tag to filter on.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="LOG_STATUS")
+    def LOG_STATUS(cls) -> "FlowLogField":
+        '''The logging status of the flow log:.
+
+        OK: Data is logging normally to the chosen destinations.
+        NODATA: There was no network traffic to or from the network interface
+        during the aggregation interval.
+        SKIPDATA — Some flow log records were skipped during the aggregation
+        interval. This might be because of an internal capacity constraint, or
+        an internal error.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__575b91a9d80cdb1a92d59c32aa69e6b72bae0ee5d1b726d04016341d1d05ce2b)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "key": key,
-            "value": value,
-        }
-
-    @builtins.property
-    def key(self) -> builtins.str:
-        '''The name of the tag to filter on.'''
-        result = self._values.get("key")
-        assert result is not None, "Required property 'key' is missing"
-        return typing.cast(builtins.str, result)
-
-    @builtins.property
-    def value(self) -> builtins.str:
-        '''The value of the tag to filter on.'''
-        result = self._values.get("value")
-        assert result is not None, "Required property 'value' is missing"
-        return typing.cast(builtins.str, result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "ExternalDnsZoneTag(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.ExternalDnsZoneType")
-class ExternalDnsZoneType(enum.Enum):
-    '''Controls the types of Hosted Zones external DNS will create records for.'''
-
-    ALL = "ALL"
-    '''Create DNS records for both public and private hosted zones.'''
-    PRIVATE = "PRIVATE"
-    '''Only create DNS records for private hosted zones.'''
-    PUBLIC = "PUBLIC"
-    '''Only create DNS records for public hosted zones.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "LOG_STATUS"))
 
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PACKETS")
+    def PACKETS(cls) -> "FlowLogField":
+        '''The number of packets transferred during the flow.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "PACKETS"))
 
-class ExternalSecret(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ExternalSecret",
-):
-    '''Represents a Kubernetes secret that is being synchronized from an external provider.
-
-    On a technical level, provides the configuration for how the external
-    secrets operator service should manage the synchronization of the Kubernetes
-    secret.
-    '''
-
-    def __init__(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
-        *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        secret_store: "ISecretStore",
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the ExternalSecret class.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PKT_DST_AWS_SERVICE")
+    def PKT_DST_AWS_SERVICE(cls) -> "FlowLogField":
+        '''The name of the subset of IP address ranges for the pkt-dstaddr field, if the destination IP address is for an AWS service.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the secret should be created.
-        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
-        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
-        :param namespace: The name where the synchronized secret should be created.
-        :param refresh_interval: The frequency at which synchronization should occur.
-        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        For a list of
+        possible values, see the {@link FlowLogField.PKT_SRC_AWS_SERVICE | PKT_SRC_AWS_SERVICE} field.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__49513e201186ba37d9ef6756fce415cce3648eed2fa385f3e5f55eb6a5fa9de3)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = ExternalSecretProps(
-            cluster=cluster,
-            secret_store=secret_store,
-            name=name,
-            namespace=namespace,
-            refresh_interval=refresh_interval,
-            secrets=secrets,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
+        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_DST_AWS_SERVICE"))
 
-        jsii.create(self.__class__, self, [scope, id, props])
-
-    @jsii.member(jsii_name="addSecret")
-    def add_secret(self, secret: "ISecretReference") -> "ExternalSecret":
-        '''Adds a provider secret reference to the synchronized Kubernetes secret.
-
-        For external secrets that reference multiple provider secrets the keys of
-        all provider secrets will be merged into the single Kubernetes secret.
-
-        :param secret: The provider secret to reference.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PKT_DSTADDR")
+    def PKT_DSTADDR(cls) -> "FlowLogField":
+        '''The packet-level (original) destination IP address for the traffic.
+
+        Use
+        this field with the dstaddr field to distinguish between the IP address
+        of an intermediate layer through which traffic flows, and the final
+        destination IP address of the traffic. For example, when traffic flows
+        through a network interface for a NAT gateway, or where the IP address
+        of a pod in Amazon EKS is different from the IP address of the network
+        interface of the instance node on which the pod is running (for
+        communication within a VPC).
 
-        :return: The external secret resoiurce where the reference was added.
+        See also:
+        `Flow Log Example NAT <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-nat>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__19eb3b7d91a4e74eaaed7fe7ee26f9301db18656d2c4d7d673df35310e1e67f9)
-            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
-        return typing.cast("ExternalSecret", jsii.invoke(self, "addSecret", [secret]))
-
-    @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret should be created.
+        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_DSTADDR"))
 
-        :group: Inputs
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PKT_SRC_AWS_SERVICE")
+    def PKT_SRC_AWS_SERVICE(cls) -> "FlowLogField":
+        '''The name of the subset of IP address ranges for the pkt-srcaddr field, if the source IP address is for an AWS service.
+
+        The possible values
+        are: AMAZON | AMAZON_APPFLOW | AMAZON_CONNECT | API_GATEWAY |
+        CHIME_MEETINGS | CHIME_VOICECONNECTOR | CLOUD9 | CLOUDFRONT |
+        CODEBUILD | DYNAMODB | EBS | EC2 | EC2_INSTANCE_CONNECT |
+        GLOBALACCELERATOR | KINESIS_VIDEO_STREAMS | ROUTE53 |
+        ROUTE53_HEALTHCHECKS | ROUTE53_HEALTHCHECKS_PUBLISHING |
+        ROUTE53_RESOLVER | S3 | WORKSPACES_GATEWAYS.
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_SRC_AWS_SERVICE"))
 
-    @builtins.property
-    @jsii.member(jsii_name="manifest")
-    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
-        '''The Kubernetes manifest defining the configuration of how to synchronize the Kubernetes secret from the provider secrets.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PKT_SRCADDR")
+    def PKT_SRCADDR(cls) -> "FlowLogField":
+        '''The packet-level (original) source IP address of the traffic.
+
+        Use this
+        field with the srcaddr field to distinguish between the IP address of
+        an intermediate layer through which traffic flows, and the original
+        source IP address of the traffic. For example, when traffic flows
+        through a network interface for a NAT gateway, or where the IP address
+        of a pod in Amazon EKS is different from the IP address of the network
+        interface of the instance node on which the pod is running (for
+        communication within a VPC).
 
-        :group: Resources
+        See also:
+        `Flow Log Example NAT <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-nat>`_
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "PKT_SRCADDR"))
 
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="PROTOCOL")
+    def PROTOCOL(cls) -> "FlowLogField":
+        '''The IANA protocol number of the traffic.
 
-        :group: Inputs
+        See also:
+        `Assigned Internet Protocol Numbers <http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_.
         '''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
-
-    @builtins.property
-    @jsii.member(jsii_name="secretName")
-    def secret_name(self) -> builtins.str:
-        '''The name of the Kubernetes secret.'''
-        return typing.cast(builtins.str, jsii.get(self, "secretName"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "PROTOCOL"))
 
-    @builtins.property
-    @jsii.member(jsii_name="secrets")
-    def secrets(self) -> typing.List["ISecretReference"]:
-        '''The collection of referenced provider secrets that are referenced in the Kubernetes secret.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="REGION")
+    def REGION(cls) -> "FlowLogField":
+        '''The Region that contains the network interface for which traffic is recorded.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "REGION"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.List["ISecretReference"], jsii.get(self, "secrets"))
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="SRCADDR")
+    def SRCADDR(cls) -> "FlowLogField":
+        '''The source address for incoming traffic, or the IPv4 or IPv6 address of the network interface for outgoing traffic on the network interface.
 
-    @builtins.property
-    @jsii.member(jsii_name="secretStore")
-    def secret_store(self) -> "ISecretStore":
-        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
+        The IPv4 address of the network interface is always its private IPv4
+        address.
 
-        :group: Inputs
+        See also:
+        {@link FlowLogField.PKT_SRCADDR | PKT_SRCADDR}
         '''
-        return typing.cast("ISecretStore", jsii.get(self, "secretStore"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "SRCADDR"))
 
-    @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The name where the synchronized secret should be created.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="SRCPORT")
+    def SRCPORT(cls) -> "FlowLogField":
+        '''The source port of the traffic.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "SRCPORT"))
 
-        :group: Inputs
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="START")
+    def START(cls) -> "FlowLogField":
+        '''The time, in Unix seconds, when the first packet of the flow was received within the aggregation interval.
+
+        This might be up to 60
+        seconds after the packet was transmitted or received on the network
+        interface.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namespace"))
+        return typing.cast("FlowLogField", jsii.sget(cls, "START"))
 
-    @builtins.property
-    @jsii.member(jsii_name="refreshInterval")
-    def refresh_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The frequency at which synchronization should occur.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="SUBLOCATION_ID")
+    def SUBLOCATION_ID(cls) -> "FlowLogField":
+        '''The ID of the sublocation that contains the network interface for which traffic is recorded.
 
-        :group: Inputs
+        If the traffic is not from a sublocation, the
+        record displays a '-' symbol for this field.
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "refreshInterval"))
-
+        return typing.cast("FlowLogField", jsii.sget(cls, "SUBLOCATION_ID"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ExternalSecretOptions",
-    jsii_struct_bases=[],
-    name_mapping={"fields": "fields", "name": "name"},
-)
-class ExternalSecretOptions:
-    def __init__(
-        self,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Configuration options for adding a Kubernetes secret synced from an external provider to Kubernetes.
-
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="SUBLOCATION_TYPE")
+    def SUBLOCATION_TYPE(cls) -> "FlowLogField":
+        '''The type of sublocation that's returned in the sublocation-id field.
+
+        The possible values are: wavelength | outpost | localzone. If the
+        traffic is not from a sublocation, the record displays a '-' symbol
+        for this field.
+
+        See also:
+        `Wavelength <https://aws.amazon.com/wavelength/>`_
+        `Outposts <https://docs.aws.amazon.com/outposts/latest/userguide/>`_
+        `Local Zones <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-local-zones>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9c48bcfa2d2f0d5e393569b187f9c8953494e5941b2210c23840aa29af16ef83)
-            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if fields is not None:
-            self._values["fields"] = fields
-        if name is not None:
-            self._values["name"] = name
+        return typing.cast("FlowLogField", jsii.sget(cls, "SUBLOCATION_TYPE"))
 
-    @builtins.property
-    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
-        '''A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider.
-
-        :default:
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="SUBNET_ID")
+    def SUBNET_ID(cls) -> "FlowLogField":
+        '''The ID of the subnet that contains the network interface for which the traffic is recorded.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "SUBNET_ID"))
 
-        The Kubernetes secret will mirror the fields from the secret in
-        the external provider.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="TCP_FLAGS")
+    def TCP_FLAGS(cls) -> "FlowLogField":
+        '''The bitmask value for the following TCP flags:.
+
+        FIN: 1
+        SYN: 2
+        RST: 4
+        PSH: 8
+        ACK: 16
+        SYN-ACK: 18
+        URG: 32
+
+        When a flow log entry consists of only ACK packets, the flag value is
+        0, not 16.
+
+        TCP flags can be OR-ed during the aggregation interval. For short
+        connections, the flags might be set on the same line in the flow log
+        record, for example, 19 for SYN-ACK and FIN, and 3 for SYN and FIN.
+
+        See also:
+        `TCP Segment Structure <https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure>`_
+        `TCP Flag Sequence <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-records-examples.html#flow-log-example-tcp-flag>`_
         '''
-        result = self._values.get("fields")
-        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster.
+        return typing.cast("FlowLogField", jsii.sget(cls, "TCP_FLAGS"))
 
-        :default: A name will be auto-generated.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="TRAFFIC_PATH")
+    def TRAFFIC_PATH(cls) -> "FlowLogField":
+        '''The path that egress traffic takes to the destination.
+
+        To determine
+        whether the traffic is egress traffic, check the flow-direction field.
+        The possible values are as follows. If none of the values apply, the
+        field is set to -.
+
+        1: Through another resource in the same VPC
+        2: Through an internet gateway or a gateway VPC endpoint
+        3: Through a virtual private gateway
+        4: Through an intra-region VPC peering connection
+        5: Through an inter-region VPC peering connection
+        6: Through a local gateway
+        7: Through a gateway VPC endpoint (Nitro-based instances only)
+        8: Through an internet gateway (Nitro-based instances only)
         '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+        return typing.cast("FlowLogField", jsii.sget(cls, "TRAFFIC_PATH"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "ExternalSecretOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ExternalSecretProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
-    name_mapping={
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "cluster": "cluster",
-        "secret_store": "secretStore",
-        "name": "name",
-        "namespace": "namespace",
-        "refresh_interval": "refreshInterval",
-        "secrets": "secrets",
-    },
-)
-class ExternalSecretProps(_aws_cdk_ceddda9d.ResourceProps):
-    def __init__(
-        self,
-        *,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        secret_store: "ISecretStore",
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        secrets: typing.Optional[typing.Sequence["ISecretReference"]] = None,
-    ) -> None:
-        '''Configuration for the ExternalSecret resource.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="TYPE")
+    def TYPE(cls) -> "FlowLogField":
+        '''The type of traffic. The possible values are: IPv4 | IPv6 | EFA.
 
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the secret should be created.
-        :param secret_store: The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.
-        :param name: The name to use for the Kubernetes secret resource when it is synchronized into the cluster.
-        :param namespace: The name where the synchronized secret should be created.
-        :param refresh_interval: The frequency at which synchronization should occur.
-        :param secrets: The secrets to synchronize into this Kubernetes secret. If multiple secrets are provided their fields will be merged.
+        See also:
+        `Elastic Fabric Adapter <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d11fa008f8a05b0740f0561849e56b56d7a687389f3927a388801e0c2089baa9)
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument secret_store", value=secret_store, expected_type=type_hints["secret_store"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
-            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
-            "secret_store": secret_store,
-        }
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
-        if name is not None:
-            self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
-        if refresh_interval is not None:
-            self._values["refresh_interval"] = refresh_interval
-        if secrets is not None:
-            self._values["secrets"] = secrets
+        return typing.cast("FlowLogField", jsii.sget(cls, "TYPE"))
 
-    @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
-
-        :default: - the resource is in the same account as the stack it belongs to
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="VERSION")
+    def VERSION(cls) -> "FlowLogField":
+        '''The VPC Flow Logs version.
+
+        If you use the default format, the version
+        is 2. If you use a custom format, the version is the highest version
+        among the specified fields. For example, if you specify only fields
+        from version 2, the version is 2. If you specify a mixture of fields
+        from versions 2, 3, and 4, the version is 4.
         '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
-
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
-
-        Cannot be supplied together with either ``account`` or ``region``.
+        return typing.cast("FlowLogField", jsii.sget(cls, "VERSION"))
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="VPC_ID")
+    def VPC_ID(cls) -> "FlowLogField":
+        '''The ID of the VPC that contains the network interface for which the traffic is recorded.'''
+        return typing.cast("FlowLogField", jsii.sget(cls, "VPC_ID"))
 
     @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
-
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
-
-        :default: - The physical name will be allocated by CloudFormation at deployment time
-        '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the Flow Log field, as it should be used when building a format string.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    @jsii.member(jsii_name="type")
+    def type(self) -> FlowLogDataType:
+        '''The data type of the field as it would appear in Parquet.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        For
+        information on the type for various files, see documentation on the
+        `available fields <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-logs-fields>`_.
         '''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret should be created.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
-
-    @builtins.property
-    def secret_store(self) -> "ISecretStore":
-        '''The Kubernetes secret store resource that provides details and permissions to use for importing secrets from the provider.'''
-        result = self._values.get("secret_store")
-        assert result is not None, "Required property 'secret_store' is missing"
-        return typing.cast("ISecretStore", result)
-
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name to use for the Kubernetes secret resource when it is synchronized into the cluster.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(FlowLogDataType, jsii.get(self, "type"))
 
-    @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The name where the synchronized secret should be created.'''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
 
-    @builtins.property
-    def refresh_interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''The frequency at which synchronization should occur.'''
-        result = self._values.get("refresh_interval")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
-
-    @builtins.property
-    def secrets(self) -> typing.Optional[typing.List["ISecretReference"]]:
-        '''The secrets to synchronize into this Kubernetes secret.
+@jsii.enum(jsii_type="cdk-extensions.ec2.FlowLogFileFormat")
+class FlowLogFileFormat(enum.Enum):
+    '''The file format options for flow log files delivered to S3.
 
-        If multiple secrets are provided their fields will be merged.
-        '''
-        result = self._values.get("secrets")
-        return typing.cast(typing.Optional[typing.List["ISecretReference"]], result)
+    :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
+    '''
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    PARQUET = "PARQUET"
+    '''Apache Parquet is a columnar data format.
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    Queries on data in Parquet
+    format are 10 to 100 times faster compared to queries on data in plain
+    text. Data in Parquet format with Gzip compression takes 20 percent less
+    storage space than plain text with Gzip compression.
+    '''
+    PLAIN_TEXT = "PLAIN_TEXT"
+    '''Plain text.
 
-    def __repr__(self) -> str:
-        return "ExternalSecretProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    This is the default format.
+    '''
 
 
-class ExternalSecretsOperator(
-    _aws_cdk_ceddda9d.Resource,
+class FlowLogFormat(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperator",
+    jsii_type="cdk-extensions.ec2.FlowLogFormat",
 ):
-    '''External Secrets Operator is a Kubernetes operator that integrates external secret management systems like AWS Secrets Manager, HashiCorp Vault, Google Secrets Manager, Azure Key Vault and many more.
-
-    The operator reads
-    information from external APIs and automatically injects the values into a
-    Kubernetes Secret.
+    def __init__(self, *fields: FlowLogField) -> None:
+        '''Creates a new instance of the FlowLogFormat class.
 
-    :see: `External Secrets Website <https://external-secrets.io/>`_
-    '''
-
-    def __init__(
-        self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
-        *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
-        create_namespace: typing.Optional[builtins.bool] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the ExternalSecretsOperator class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the external secrets operator should be installed.
-        :param create_namespace: Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster. When this flag is ``true`` and the namespace doesn't exist, the namespace will be created automatically. When this flag is ``false`` and the namespace doesn't exist, an error will occur and resource creation will fail. Default: true
-        :param namespace: The Kubernetes namespace where the external secrets operator service should be installed and configured. Default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param fields: The fields that should be included in the flow log output.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__92e0a4c21b4ba5a2e251aa667f38097598f22ba362cbd427dd404bbdc22ab5f6)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = ExternalSecretsOperatorProps(
-            cluster=cluster,
-            create_namespace=create_namespace,
-            namespace=namespace,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        jsii.create(self.__class__, self, [scope, id, props])
+            type_hints = typing.get_type_hints(_typecheckingstub__011095d32393e36e81237f11a84f5543e965a7ff361a20975a530a17197f4a8e)
+            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
+        jsii.create(self.__class__, self, [*fields])
 
-    @jsii.member(jsii_name="registerSecretsManagerSecret")
-    def register_secrets_manager_secret(
-        self,
-        id: builtins.str,
-        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
-        *,
-        namespace: typing.Optional[builtins.str] = None,
-        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> ExternalSecret:
-        '''Registers a Secrets Manager secret with the external secrets operator, enabling syncing from the Secrets Manager secret into Kubernetes.
+    @jsii.member(jsii_name="fromTemplate")
+    @builtins.classmethod
+    def from_template(cls, template: builtins.str) -> "FlowLogFormat":
+        '''Parses a flow log format template string to create a new FlowLogFormat object.
 
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within for each secrets manager secret within a Kubernetes namespace.
-        :param secret: The Secrets Manager secret to enable syncing for.
-        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+        :param template: A flow log template string to parse.
 
-        :return: The external secret object that was created.
+        :return: A FlowLogFormat object representing the passed template.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__90685b99b2a2f337bfa2d47df40412c9b581b614b6fbaa7d3c94b067a6d562f9)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
-        options = NamespacedExternalSecretOptions(
-            namespace=namespace, fields=fields, name=name
-        )
-
-        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSecretsManagerSecret", [id, secret, options]))
+            type_hints = typing.get_type_hints(_typecheckingstub__5cb1f7019aee739ea8276bab9a93a7e6f40b4ebf40d15497239b2c6b1676033e)
+            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
+        return typing.cast("FlowLogFormat", jsii.sinvoke(cls, "fromTemplate", [template]))
 
-    @jsii.member(jsii_name="registerSsmParameterSecret")
-    def register_ssm_parameter_secret(
-        self,
-        id: builtins.str,
-        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-        *,
-        namespace: typing.Optional[builtins.str] = None,
-        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> ExternalSecret:
-        '''Registers a Systems Manager parameter with the external secrets operator, enabling syncing from the Systems Manager parameter into Kubernetes.
+    @jsii.member(jsii_name="addField")
+    def add_field(self, field: FlowLogField) -> None:
+        '''Adds a new field to the flow log output.
 
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within for each Systems Manager parameter within a Kubernetes namespace.
-        :param parameter: The Systems Manager parameter to enable syncing for.
-        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+        New fields are added at the
+        end of a log entry after all the other fields that came before it.
 
-        :return: The external secret object that was created.
+        :param field: The field to add to the FlowLogFormat.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bb968a0fa40a926483b03cb5417298b5375e8cd4b95be82c6d873ca8dc69a994)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
-        options = NamespacedExternalSecretOptions(
-            namespace=namespace, fields=fields, name=name
-        )
-
-        return typing.cast(ExternalSecret, jsii.invoke(self, "registerSsmParameterSecret", [id, parameter, options]))
+            type_hints = typing.get_type_hints(_typecheckingstub__79cf487bf8fa03e8840d7c2097f578bf3849b50872d93bdad4cc33d93380f5cd)
+            check_type(argname="argument field", value=field, expected_type=type_hints["field"])
+        return typing.cast(None, jsii.invoke(self, "addField", [field]))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="CHART_NAME")
-    def CHART_NAME(cls) -> builtins.str:
-        '''The name of the Helm chart to install from the Helm repository.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "CHART_NAME"))
+    @jsii.member(jsii_name="V2")
+    def V2(cls) -> "FlowLogFormat":
+        '''The basic set of fields included in most flow logs.
+
+        This is the default
+        format that is used when new flow logs are created without specifying a
+        custom format.
+        '''
+        return typing.cast("FlowLogFormat", jsii.sget(cls, "V2"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="CHART_REPOSITORY")
-    def CHART_REPOSITORY(cls) -> builtins.str:
-        '''The URL of the Helm repository that hostys the Helm charts used to install the externalk secrets operator service.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "CHART_REPOSITORY"))
+    @jsii.member(jsii_name="V3")
+    def V3(cls) -> "FlowLogFormat":
+        '''Includes all the fields available in V2.
+
+        Adds fields to help identify
+        AWS resources associated with traffic as well as fields that give
+        greater visibility into protocol specific details.
+        '''
+        return typing.cast("FlowLogFormat", jsii.sget(cls, "V3"))
 
     @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
-    def DEFAULT_NAMESPACE(cls) -> builtins.str:
-        '''The default Kubernetes namespace where the external secrets operator service should be installed and configured if no overriding input is provided.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
-
-    @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
-        '''The EKS cluster where the external secrets operator service should be installed and configured.
-
-        :group: Inputs
+    @jsii.member(jsii_name="V4")
+    def V4(cls) -> "FlowLogFormat":
+        '''Includes all the fields available in V3.
+
+        Adds fields for identifying
+        the region and availabilty zone associated with flows, as well as
+        details related to extended zones such as Wavelength, Outputs, and
+        Local Zones.
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, jsii.get(self, "cluster"))
+        return typing.cast("FlowLogFormat", jsii.sget(cls, "V4"))
 
-    @builtins.property
-    @jsii.member(jsii_name="helmChart")
-    def helm_chart(self) -> _aws_cdk_aws_eks_ceddda9d.HelmChart:
-        '''The Helm chart the manages the installation and configuration of the external secrets operator service.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="V5")
+    def V5(cls) -> "FlowLogFormat":
+        '''Includes all the fields available in V4.
 
-        :group: Resources
+        Adds fields to help identify
+        related AWS services and improve visibility into packet routing.
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.HelmChart, jsii.get(self, "helmChart"))
+        return typing.cast("FlowLogFormat", jsii.sget(cls, "V5"))
 
     @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> builtins.str:
-        '''The Kubernetes namespace where the external secrets operator service should be installed and configured.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "namespace"))
+    @jsii.member(jsii_name="fields")
+    def fields(self) -> typing.List[FlowLogField]:
+        '''The fields that make up the flow log format, in the order that they should appear in the log entries.'''
+        return typing.cast(typing.List[FlowLogField], jsii.get(self, "fields"))
 
     @builtins.property
-    @jsii.member(jsii_name="createNamespace")
-    def create_namespace(self) -> typing.Optional[builtins.bool]:
-        '''Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster.
-
-        When this flag is ``true`` and the namespace doesn't exist, the namespace
-        will be created automatically.
-
-        When this flag is ``false`` and the namespace doesn't exist, an error will
-        occur and resource creation will fail.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "createNamespace"))
+    @jsii.member(jsii_name="template")
+    def template(self) -> builtins.str:
+        '''The rendered format string in the format expected by AWS when creating a new Flow Log.'''
+        return typing.cast(builtins.str, jsii.get(self, "template"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ExternalSecretsOperatorProps",
+    jsii_type="cdk-extensions.ec2.FlowLogProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cluster": "cluster",
-        "create_namespace": "createNamespace",
-        "namespace": "namespace",
+        "resource_type": "resourceType",
+        "destination": "destination",
+        "flow_log_name": "flowLogName",
+        "log_format": "logFormat",
+        "max_aggregation_interval": "maxAggregationInterval",
+        "traffic_type": "trafficType",
     },
 )
-class ExternalSecretsOperatorProps(_aws_cdk_ceddda9d.ResourceProps):
+class FlowLogProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
-        create_namespace: typing.Optional[builtins.bool] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
+        destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
+        flow_log_name: typing.Optional[builtins.str] = None,
+        log_format: typing.Optional[FlowLogFormat] = None,
+        max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
+        traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
     ) -> None:
-        '''Configuration for the ExternalSecretsOperator resource.
+        '''Configuration for the FlowLog class.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the external secrets operator should be installed.
-        :param create_namespace: Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster. When this flag is ``true`` and the namespace doesn't exist, the namespace will be created automatically. When this flag is ``false`` and the namespace doesn't exist, an error will occur and resource creation will fail. Default: true
-        :param namespace: The Kubernetes namespace where the external secrets operator service should be installed and configured. Default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
+        :param resource_type: Details for the resource from which flow logs will be captured.
+        :param destination: The location where flow logs should be delivered.
+        :param flow_log_name: The name of the FlowLog.
+        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see {@link FlowLogField}.
+        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
+        :param traffic_type: The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a77b0078ad516d66ca8ca0d633ac0257b13a89e52152799cdfab2d5f1bd3e906)
+            type_hints = typing.get_type_hints(_typecheckingstub__ab60db00df2ad42cfdeb4bac9052956c6ceecbdc94e94e83e7a5b1a8d4db724f)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument create_namespace", value=create_namespace, expected_type=type_hints["create_namespace"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument resource_type", value=resource_type, expected_type=type_hints["resource_type"])
+            check_type(argname="argument destination", value=destination, expected_type=type_hints["destination"])
+            check_type(argname="argument flow_log_name", value=flow_log_name, expected_type=type_hints["flow_log_name"])
+            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
+            check_type(argname="argument max_aggregation_interval", value=max_aggregation_interval, expected_type=type_hints["max_aggregation_interval"])
+            check_type(argname="argument traffic_type", value=traffic_type, expected_type=type_hints["traffic_type"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
+            "resource_type": resource_type,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if create_namespace is not None:
-            self._values["create_namespace"] = create_namespace
-        if namespace is not None:
-            self._values["namespace"] = namespace
+        if destination is not None:
+            self._values["destination"] = destination
+        if flow_log_name is not None:
+            self._values["flow_log_name"] = flow_log_name
+        if log_format is not None:
+            self._values["log_format"] = log_format
+        if max_aggregation_interval is not None:
+            self._values["max_aggregation_interval"] = max_aggregation_interval
+        if traffic_type is not None:
+            self._values["traffic_type"] = traffic_type
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -2195,4557 +1601,3000 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.Cluster:
-        '''The EKS cluster where the external secrets operator should be installed.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.Cluster, result)
-
-    @builtins.property
-    def create_namespace(self) -> typing.Optional[builtins.bool]:
-        '''Determines the behavior when the service is deployed to a namespace that doesn't already exist on the EKS cluster.
-
-        When this flag is ``true`` and the namespace doesn't exist, the namespace
-        will be created automatically.
+    def resource_type(self) -> _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType:
+        '''Details for the resource from which flow logs will be captured.
 
-        When this flag is ``false`` and the namespace doesn't exist, an error will
-        occur and resource creation will fail.
-
-        :default: true
+        :see: `FlowLog ResourceType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype>`_
+        :group: Inputs
         '''
-        result = self._values.get("create_namespace")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("resource_type")
+        assert result is not None, "Required property 'resource_type' is missing"
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType, result)
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the external secrets operator service should be installed and configured.
-
-        :default: {@link ExternalSecretsOperator.DEFAULT_NAMESPACE}
-        '''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "ExternalSecretsOperatorProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-class FargateLogger(
-    _aws_cdk_ceddda9d.Resource,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FargateLogger",
-):
-    '''Creates a ConfigMap that configures logging for containers running in EKS on Fargate.'''
-
-    def __init__(
+    def destination(
         self,
-        scope: _constructs_77d1e7e8.Construct,
-        id: builtins.str,
-        *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
-        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the FargateLogger class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS Cluster to configure Fargate logging for.
-        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
-        :param filters: The filters that should be applied to logs being processed.
-        :param log_group: The CloudWatch log group where Farget container logs will be sent.
-        :param outputs: The output destinations where logs should be written.
-        :param parsers: The parsers to be used when reading log files.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__76dae8c2dfe10754d7c019d5c1c2151516afb99c60c1df33bb81b24d3b938dd3)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = FargateLoggerProps(
-            cluster=cluster,
-            fargate_profiles=fargate_profiles,
-            filters=filters,
-            log_group=log_group,
-            outputs=outputs,
-            parsers=parsers,
-            account=account,
-            environment_from_arn=environment_from_arn,
-            physical_name=physical_name,
-            region=region,
-        )
-
-        jsii.create(self.__class__, self, [scope, id, props])
-
-    @jsii.member(jsii_name="addFargateProfile")
-    def add_fargate_profile(
-        self,
-        profile: _aws_cdk_aws_eks_ceddda9d.FargateProfile,
-    ) -> "FargateLogger":
-        '''
-        :param profile: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b703c0764bfdf16eb126c71eab2089fc0d5d0baedeb889a2ab4b2d0a6b49f59d)
-            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
-        return typing.cast("FargateLogger", jsii.invoke(self, "addFargateProfile", [profile]))
-
-    @jsii.member(jsii_name="addFilter")
-    def add_filter(self, filter: "IFluentBitFilterPlugin") -> "FargateLogger":
-        '''
-        :param filter: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__441c970215922062a245380ac8d1e04123624212c517def39ade49d9091b4c23)
-            check_type(argname="argument filter", value=filter, expected_type=type_hints["filter"])
-        return typing.cast("FargateLogger", jsii.invoke(self, "addFilter", [filter]))
-
-    @jsii.member(jsii_name="addOutput")
-    def add_output(self, output: "IFluentBitOutputPlugin") -> "FargateLogger":
-        '''
-        :param output: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a329165d7991851e4ec8fd63a4b82083aef71de6826a3ef2e264518b24051f2b)
-            check_type(argname="argument output", value=output, expected_type=type_hints["output"])
-        return typing.cast("FargateLogger", jsii.invoke(self, "addOutput", [output]))
-
-    @jsii.member(jsii_name="addParser")
-    def add_parser(self, parser: "IFluentBitParserPlugin") -> "FargateLogger":
-        '''
-        :param parser: -
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f61de38bcda89dc454156432b185bbdfe377f7811aa2270afad6e3f3d5d7e4fe)
-            check_type(argname="argument parser", value=parser, expected_type=type_hints["parser"])
-        return typing.cast("FargateLogger", jsii.invoke(self, "addParser", [parser]))
-
-    @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where Fargate logging is being configured.
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination]:
+        '''The location where flow logs should be delivered.
 
+        :see: `FlowLog LogDestinationType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype>`_
         :group: Inputs
         '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+        result = self._values.get("destination")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination], result)
 
     @builtins.property
-    @jsii.member(jsii_name="filters")
-    def filters(self) -> typing.List["IFluentBitFilterPlugin"]:
-        '''Collection of Fluent Bit filter plugins being configured for logging.
+    def flow_log_name(self) -> typing.Optional[builtins.str]:
+        '''The name of the FlowLog.
 
         :group: Inputs
         '''
-        return typing.cast(typing.List["IFluentBitFilterPlugin"], jsii.get(self, "filters"))
+        result = self._values.get("flow_log_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="manifest")
-    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
-        '''The Kubernetes manifest that creates the ConfigMap that Fargate uses to configure logging.
-
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+    def log_format(self) -> typing.Optional[FlowLogFormat]:
+        '''The fields to include in the flow log record, in the order in which they should appear.
 
-    @builtins.property
-    @jsii.member(jsii_name="outputs")
-    def outputs(self) -> typing.List["IFluentBitOutputPlugin"]:
-        '''Collection of Fluent Bit output plugins being configured for logging.
+        For a list of available fields, see {@link FlowLogField}.
 
+        :see: `FlowLog LogFormat <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat>`_
         :group: Inputs
         '''
-        return typing.cast(typing.List["IFluentBitOutputPlugin"], jsii.get(self, "outputs"))
+        result = self._values.get("log_format")
+        return typing.cast(typing.Optional[FlowLogFormat], result)
 
     @builtins.property
-    @jsii.member(jsii_name="parsers")
-    def parsers(self) -> typing.List["IFluentBitParserPlugin"]:
-        '''Collection of Fluent Bit parser plugins being configured for logging.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.List["IFluentBitParserPlugin"], jsii.get(self, "parsers"))
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FargateLoggerOptions",
-    jsii_struct_bases=[],
-    name_mapping={
-        "fargate_profiles": "fargateProfiles",
-        "filters": "filters",
-        "log_group": "logGroup",
-        "outputs": "outputs",
-        "parsers": "parsers",
-    },
-)
-class FargateLoggerOptions:
-    def __init__(
+    def max_aggregation_interval(
         self,
-        *,
-        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
-        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
-    ) -> None:
-        '''Optional configuration for the FargateLogger resource.
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval]:
+        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.
 
-        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
-        :param filters: The filters that should be applied to logs being processed.
-        :param log_group: The CloudWatch log group where Farget container logs will be sent.
-        :param outputs: The output destinations where logs should be written.
-        :param parsers: The parsers to be used when reading log files.
+        :see: `FlowLog MaxAggregationInterval <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5d9fa1ba40c2be86a241bebc6f8b6cc03215924d98659a18e99df90fd7eef185)
-            check_type(argname="argument fargate_profiles", value=fargate_profiles, expected_type=type_hints["fargate_profiles"])
-            check_type(argname="argument filters", value=filters, expected_type=type_hints["filters"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
-            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if fargate_profiles is not None:
-            self._values["fargate_profiles"] = fargate_profiles
-        if filters is not None:
-            self._values["filters"] = filters
-        if log_group is not None:
-            self._values["log_group"] = log_group
-        if outputs is not None:
-            self._values["outputs"] = outputs
-        if parsers is not None:
-            self._values["parsers"] = parsers
+        result = self._values.get("max_aggregation_interval")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval], result)
 
     @builtins.property
-    def fargate_profiles(
+    def traffic_type(
         self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]]:
-        '''A default list of Fargate profiles that should have permissions configured.
+    ) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType]:
+        '''The type of traffic to monitor (accepted traffic, rejected traffic, or all traffic).
 
-        Alternatively profiles can be added at any time by calling
-        ``addProfile``.
+        :see: `FlowLog TrafficType <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype>`_
+        :group: Inputs
         '''
-        result = self._values.get("fargate_profiles")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]], result)
-
-    @builtins.property
-    def filters(self) -> typing.Optional[typing.List["IFluentBitFilterPlugin"]]:
-        '''The filters that should be applied to logs being processed.'''
-        result = self._values.get("filters")
-        return typing.cast(typing.Optional[typing.List["IFluentBitFilterPlugin"]], result)
-
-    @builtins.property
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        '''The CloudWatch log group where Farget container logs will be sent.'''
-        result = self._values.get("log_group")
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
-
-    @builtins.property
-    def outputs(self) -> typing.Optional[typing.List["IFluentBitOutputPlugin"]]:
-        '''The output destinations where logs should be written.'''
-        result = self._values.get("outputs")
-        return typing.cast(typing.Optional[typing.List["IFluentBitOutputPlugin"]], result)
-
-    @builtins.property
-    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
-        '''The parsers to be used when reading log files.'''
-        result = self._values.get("parsers")
-        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
+        result = self._values.get("traffic_type")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FargateLoggerOptions(%s)" % ", ".join(
+        return "FlowLogProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FargateLoggerProps",
-    jsii_struct_bases=[FargateLoggerOptions, _aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.ec2.FlowLogS3Options",
+    jsii_struct_bases=[],
     name_mapping={
-        "fargate_profiles": "fargateProfiles",
-        "filters": "filters",
-        "log_group": "logGroup",
-        "outputs": "outputs",
-        "parsers": "parsers",
-        "account": "account",
-        "environment_from_arn": "environmentFromArn",
-        "physical_name": "physicalName",
-        "region": "region",
-        "cluster": "cluster",
+        "file_format": "fileFormat",
+        "hive_compatible_partitions": "hiveCompatiblePartitions",
+        "key_prefix": "keyPrefix",
+        "per_hour_partition": "perHourPartition",
     },
 )
-class FargateLoggerProps(FargateLoggerOptions, _aws_cdk_ceddda9d.ResourceProps):
+class FlowLogS3Options:
     def __init__(
         self,
         *,
-        fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-        filters: typing.Optional[typing.Sequence["IFluentBitFilterPlugin"]] = None,
-        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-        outputs: typing.Optional[typing.Sequence["IFluentBitOutputPlugin"]] = None,
-        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
-        account: typing.Optional[builtins.str] = None,
-        environment_from_arn: typing.Optional[builtins.str] = None,
-        physical_name: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        file_format: typing.Optional[FlowLogFileFormat] = None,
+        hive_compatible_partitions: typing.Optional[builtins.bool] = None,
+        key_prefix: typing.Optional[builtins.str] = None,
+        per_hour_partition: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Required configuration for the Fargate logger resource.
-
-        :param fargate_profiles: A default list of Fargate profiles that should have permissions configured. Alternatively profiles can be added at any time by calling ``addProfile``.
-        :param filters: The filters that should be applied to logs being processed.
-        :param log_group: The CloudWatch log group where Farget container logs will be sent.
-        :param outputs: The output destinations where logs should be written.
-        :param parsers: The parsers to be used when reading log files.
-        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
-        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS Cluster to configure Fargate logging for.
+        '''
+        :param file_format: The file format in which flow logs should be delivered to S3.
+        :param hive_compatible_partitions: Controls the format of partitions ("folders") when the flow logs are delivered to S3. By default, flow logs are delivered partitioned such that each part of the S3 path represents a values pertaining to details of the log. When hive compatible partitions are enabled, partitions will be structured such that keys declaring the partition name are added at each level. An example of standard partitioning:: /us-east-1/2020/03/08/log.tar.gz An example with Hive compatible partitions:: /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
+        :param key_prefix: An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
+        :param per_hour_partition: Indicates whether to partition the flow log per hour. By default, flow logs are partitioned (organized into S3 "folders") by day. Setting this to true will add an extra layer of directories splitting flow log files by the hour in which they were delivered.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__331f0ef39a4852c171fb3378d45e752361c5aa7515c6965a4852b6f54a58f900)
-            check_type(argname="argument fargate_profiles", value=fargate_profiles, expected_type=type_hints["fargate_profiles"])
-            check_type(argname="argument filters", value=filters, expected_type=type_hints["filters"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument outputs", value=outputs, expected_type=type_hints["outputs"])
-            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
-            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
-            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
-            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
-        }
-        if fargate_profiles is not None:
-            self._values["fargate_profiles"] = fargate_profiles
-        if filters is not None:
-            self._values["filters"] = filters
-        if log_group is not None:
-            self._values["log_group"] = log_group
-        if outputs is not None:
-            self._values["outputs"] = outputs
-        if parsers is not None:
-            self._values["parsers"] = parsers
-        if account is not None:
-            self._values["account"] = account
-        if environment_from_arn is not None:
-            self._values["environment_from_arn"] = environment_from_arn
-        if physical_name is not None:
-            self._values["physical_name"] = physical_name
-        if region is not None:
-            self._values["region"] = region
+            type_hints = typing.get_type_hints(_typecheckingstub__7e005d34fc5ab0b60e83479b723ba4e2e86a135e05fd16b18daaac30743245ed)
+            check_type(argname="argument file_format", value=file_format, expected_type=type_hints["file_format"])
+            check_type(argname="argument hive_compatible_partitions", value=hive_compatible_partitions, expected_type=type_hints["hive_compatible_partitions"])
+            check_type(argname="argument key_prefix", value=key_prefix, expected_type=type_hints["key_prefix"])
+            check_type(argname="argument per_hour_partition", value=per_hour_partition, expected_type=type_hints["per_hour_partition"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if file_format is not None:
+            self._values["file_format"] = file_format
+        if hive_compatible_partitions is not None:
+            self._values["hive_compatible_partitions"] = hive_compatible_partitions
+        if key_prefix is not None:
+            self._values["key_prefix"] = key_prefix
+        if per_hour_partition is not None:
+            self._values["per_hour_partition"] = per_hour_partition
 
     @builtins.property
-    def fargate_profiles(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]]:
-        '''A default list of Fargate profiles that should have permissions configured.
+    def file_format(self) -> typing.Optional[FlowLogFileFormat]:
+        '''The file format in which flow logs should be delivered to S3.
 
-        Alternatively profiles can be added at any time by calling
-        ``addProfile``.
+        :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
         '''
-        result = self._values.get("fargate_profiles")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_eks_ceddda9d.FargateProfile]], result)
+        result = self._values.get("file_format")
+        return typing.cast(typing.Optional[FlowLogFileFormat], result)
 
     @builtins.property
-    def filters(self) -> typing.Optional[typing.List["IFluentBitFilterPlugin"]]:
-        '''The filters that should be applied to logs being processed.'''
-        result = self._values.get("filters")
-        return typing.cast(typing.Optional[typing.List["IFluentBitFilterPlugin"]], result)
+    def hive_compatible_partitions(self) -> typing.Optional[builtins.bool]:
+        '''Controls the format of partitions ("folders") when the flow logs are delivered to S3.
 
-    @builtins.property
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        '''The CloudWatch log group where Farget container logs will be sent.'''
-        result = self._values.get("log_group")
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], result)
+        By default, flow logs are delivered partitioned such that each part of
+        the S3 path represents a values pertaining to details of the log.
 
-    @builtins.property
-    def outputs(self) -> typing.Optional[typing.List["IFluentBitOutputPlugin"]]:
-        '''The output destinations where logs should be written.'''
-        result = self._values.get("outputs")
-        return typing.cast(typing.Optional[typing.List["IFluentBitOutputPlugin"]], result)
+        When hive compatible partitions are enabled, partitions will be
+        structured such that keys declaring the partition name are added at
+        each level.
 
-    @builtins.property
-    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
-        '''The parsers to be used when reading log files.'''
-        result = self._values.get("parsers")
-        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
+        An example of standard partitioning::
 
-    @builtins.property
-    def account(self) -> typing.Optional[builtins.str]:
-        '''The AWS account ID this resource belongs to.
+           /us-east-1/2020/03/08/log.tar.gz
 
-        :default: - the resource is in the same account as the stack it belongs to
-        '''
-        result = self._values.get("account")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def environment_from_arn(self) -> typing.Optional[builtins.str]:
-        '''ARN to deduce region and account from.
-
-        The ARN is parsed and the account and region are taken from the ARN.
-        This should be used for imported resources.
-
-        Cannot be supplied together with either ``account`` or ``region``.
+        An example with Hive compatible partitions::
 
-        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
-        '''
-        result = self._values.get("environment_from_arn")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def physical_name(self) -> typing.Optional[builtins.str]:
-        '''The value passed in by users to the physical name prop of the resource.
-
-        - ``undefined`` implies that a physical name will be allocated by
-          CloudFormation during deployment.
-        - a concrete value implies a specific physical name
-        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
-          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+           /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
 
-        :default: - The physical name will be allocated by CloudFormation at deployment time
+        :see: `AWS Big Data Blog <https://aws.amazon.com/blogs/big-data/optimize-performance-and-reduce-costs-for-network-analytics-with-vpc-flow-logs-in-apache-parquet-format/>`_
         '''
-        result = self._values.get("physical_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("hive_compatible_partitions")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region this resource belongs to.
+    def key_prefix(self) -> typing.Optional[builtins.str]:
+        '''An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
 
-        :default: - the resource is in the same region as the stack it belongs to
+        :see: `FlowLog LogDestination <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination>`_
         '''
-        result = self._values.get("region")
+        result = self._values.get("key_prefix")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS Cluster to configure Fargate logging for.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "FargateLoggerProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-class FluentBitFilter(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitFilter",
-):
-    '''Standard filter options which can be applied to Fluent Bit to control the output and formatting of logs.
-
-    Filters change the structure of log records by doing things like adding
-    metadata to a record, restructuring a record, or adding and removing fields.
-    '''
-
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
-
-    @jsii.member(jsii_name="appendFields")
-    @builtins.classmethod
-    def append_fields(
-        cls,
-        match: "FluentBitMatch",
-        *records: AppendedRecord,
-    ) -> "IFluentBitFilterPlugin":
-        '''Creates a filter that adds fields to a record that matches the given pattern.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param records: The fields to be added to matched records.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__004c6d6190020d8cdc3eea6ba900d6bb6b67d1b06e5b2c7a8650568795e29ce3)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument records", value=records, expected_type=typing.Tuple[type_hints["records"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "appendFields", [match, *records]))
-
-    @jsii.member(jsii_name="blacklistFields")
-    @builtins.classmethod
-    def blacklist_fields(
-        cls,
-        match: "FluentBitMatch",
-        *fields: builtins.str,
-    ) -> "IFluentBitFilterPlugin":
-        '''Creates a filter that removes a set of fields from any records that match a given pattern.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param fields: The fields which should be removed from the record if they are present.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1e4fc805a8f96657a4f0acdced48b0a0ff8f731cc5e58787975d1636d9bea432)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "blacklistFields", [match, *fields]))
-
-    @jsii.member(jsii_name="grep")
-    @builtins.classmethod
-    def grep(
-        cls,
-        match: "FluentBitMatch",
-        *,
-        key: builtins.str,
-        regex: builtins.str,
-        exclude: typing.Optional[builtins.bool] = None,
-    ) -> "IFluentBitFilterPlugin":
-        '''Filters log entries based on a pattern.
-
-        Log entries can be removed and
-        not forwarded based on whether they match or do not match the given
-        pattern.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param key: The key of the fields which you want to filter using the regex.
-        :param regex: The regular expression to apply to the specified field.
-        :param exclude: Whether the matched expression should exclude or include records from being output. When this is true, only records that match the given expression will be output. When this is false, only records that do not match the given expression will be output. Default: false
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ca125ae790631ee65913aa6e968ed7113cdb3174739710fcb3e049ee05e1225b)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-        pattern = FluentBitGrepRegex(key=key, regex=regex, exclude=exclude)
-
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "grep", [match, pattern]))
-
-    @jsii.member(jsii_name="kubernetes")
-    @builtins.classmethod
-    def kubernetes(cls, match: "FluentBitMatch") -> "IFluentBitFilterPlugin":
-        '''Adds Kubernetes metadata to output records including pod information, labels, etc..
-
-        :param match: A pattern filtering to which records the filter should be applied.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e62ff1da65acb39396b806ce64d2c933f7f3b043f0f4ab5b9bcfde68b282300e)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "kubernetes", [match]))
-
-    @jsii.member(jsii_name="lift")
-    @builtins.classmethod
-    def lift(
-        cls,
-        match: "FluentBitMatch",
-        nested_under: builtins.str,
-    ) -> "IFluentBitFilterPlugin":
-        '''Lifts nested fields in a record up to their parent object.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param nested_under: The record object under which you want to lift fields.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b7921055d17cd6ec5863079beb06bda4bbc0aba18764be3ca76b587d53f6a90c)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument nested_under", value=nested_under, expected_type=type_hints["nested_under"])
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "lift", [match, nested_under]))
-
-    @jsii.member(jsii_name="modify")
-    @builtins.classmethod
-    def modify(
-        cls,
-        match: "FluentBitMatch",
-        *operations: "ModifyOperation",
-    ) -> "IFluentBitFilterPlugin":
-        '''Applies various transformations to matched records including adding, removing, copying, and renaming fields.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param operations: The operations to apply to the matched records.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__70f785929f2989cc94f847423b39a2b6cda43109191a9c78fc4a821025615e83)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument operations", value=operations, expected_type=typing.Tuple[type_hints["operations"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "modify", [match, *operations]))
-
-    @jsii.member(jsii_name="nest")
-    @builtins.classmethod
-    def nest(
-        cls,
-        match: "FluentBitMatch",
-        nest_under: builtins.str,
-        *fields: builtins.str,
-    ) -> "IFluentBitFilterPlugin":
-        '''Nests a set of fields in a record under into a specified object.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param nest_under: The record object under which you want to nest matched fields.
-        :param fields: The fields to nest under the specified object.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0c44cc88268e3e2218cb706dfe1efc0b47f7a1d76b49addf6866c4a59ff82f54)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument nest_under", value=nest_under, expected_type=type_hints["nest_under"])
-            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "nest", [match, nest_under, *fields]))
-
-    @jsii.member(jsii_name="parser")
-    @builtins.classmethod
-    def parser(
-        cls,
-        match: "FluentBitMatch",
-        key: builtins.str,
-        *parsers: "IFluentBitParserPlugin",
-    ) -> "IFluentBitFilterPlugin":
-        '''Applies a set of parsers to matched records.
-
-        The parser is used to read the input record and set structured fields in
-        the output.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param key: The key of the field to be parsed.
-        :param parsers: The parser plugins to use to read matched records.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__10af575b9dbec2cd8ea9604aee8e29ee517e60f747a39b4910b6f4da1f217b83)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument parsers", value=parsers, expected_type=typing.Tuple[type_hints["parsers"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "parser", [match, key, *parsers]))
-
-    @jsii.member(jsii_name="rewriteTag")
-    @builtins.classmethod
-    def rewrite_tag(
-        cls,
-        match: "FluentBitMatch",
-        *rules: "RewriteTagRule",
-    ) -> "IFluentBitFilterPlugin":
-        '''Allows modification of tags set by the input configuration to affect the routing of when records are output.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param rules: The rules that define the matching criteria of format of the tag for the matching record.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7771595b84c711392921d6ddf6f6d52281f9711dd09522a93a530883167a8e3c)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument rules", value=rules, expected_type=typing.Tuple[type_hints["rules"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "rewriteTag", [match, *rules]))
-
-    @jsii.member(jsii_name="throttle")
-    @builtins.classmethod
-    def throttle(
-        cls,
-        match: "FluentBitMatch",
-        interval: _aws_cdk_ceddda9d.Duration,
-        rate: jsii.Number,
-        window: jsii.Number,
-    ) -> "IFluentBitFilterPlugin":
-        '''Sets an average rate of messages that are allowed to be output over a configured period of time.
-
-        When the rate of messages surpasses the configured limits messages will
-        be dropped.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param interval: The interval of time over rate should be sampled to calculate an average.
-        :param rate: The average amount of messages over a given period.
-        :param window: Amount of intervals to calculate average over.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c398af7ef351b52ad40eb09a1a0fcc6ae44187a82c5709af8cc8ea2d361cb61e)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
-            check_type(argname="argument rate", value=rate, expected_type=type_hints["rate"])
-            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "throttle", [match, interval, rate, window]))
-
-    @jsii.member(jsii_name="whitelistFields")
-    @builtins.classmethod
-    def whitelist_fields(
-        cls,
-        match: "FluentBitMatch",
-        *fields: builtins.str,
-    ) -> "IFluentBitFilterPlugin":
-        '''Creates a filter that removes all fields in a record that are not approved.
-
-        :param match: A pattern filtering to which records the filter should be applied.
-        :param fields: The fields which are allowed to appear in the output record.
-
-        :return:
-
-        A filter object that can be applied to the Fluent Bit
-        configuration.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4a171efbee53101c625ce2956a002515e474ab45a4b74604ffee5889c1053dd3)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument fields", value=fields, expected_type=typing.Tuple[type_hints["fields"], ...]) # pyright: ignore [reportGeneralTypeIssues]
-        return typing.cast("IFluentBitFilterPlugin", jsii.sinvoke(cls, "whitelistFields", [match, *fields]))
+    def per_hour_partition(self) -> typing.Optional[builtins.bool]:
+        '''Indicates whether to partition the flow log per hour.
 
+        By default, flow logs are partitioned (organized into S3 "folders") by
+        day.
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitFilterPluginCommonOptions",
-    jsii_struct_bases=[],
-    name_mapping={"match": "match"},
-)
-class FluentBitFilterPluginCommonOptions:
-    def __init__(self, *, match: typing.Optional["FluentBitMatch"] = None) -> None:
-        '''Configuration options that apply to all Fluent Bit output plugins.
+        Setting this to true will add an extra layer of directories splitting
+        flow log files by the hour in which they were delivered.
 
-        :param match: The pattern to match for records that this output should apply to.
+        :see: `Flow log files <https://docs.aws.amazon.com/vpc/latest/tgw/flow-logs-s3.html#flow-logs-s3-path>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0a232fab3d929b1e9cdb75a64a4f3eec377e0983c1b4e4ffd68fc95cf216ee9d)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-
-    @builtins.property
-    def match(self) -> typing.Optional["FluentBitMatch"]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional["FluentBitMatch"], result)
+        result = self._values.get("per_hour_partition")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitFilterPluginCommonOptions(%s)" % ", ".join(
+        return "FlowLogS3Options(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={"match": "match", "pattern": "pattern"},
-)
-class FluentBitGrepFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
-        self,
-        *,
-        match: typing.Optional["FluentBitMatch"] = None,
-        pattern: typing.Union["FluentBitGrepRegex", typing.Dict[builtins.str, typing.Any]],
-    ) -> None:
-        '''Options for configuring the Grep Fluent Bit filter plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param pattern: The pattern to use for filtering records processed by the plugin.
-
-        :see: `Grep Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/grep>`_
-        '''
-        if isinstance(pattern, dict):
-            pattern = FluentBitGrepRegex(**pattern)
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0367bee62bb2658dda6a19b32e999c85a7a98303ad453009919555866534b235)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "pattern": pattern,
-        }
-        if match is not None:
-            self._values["match"] = match
-
+@jsii.interface(jsii_type="cdk-extensions.ec2.IAddressConfiguration")
+class IAddressConfiguration(typing_extensions.Protocol):
     @builtins.property
-    def match(self) -> typing.Optional["FluentBitMatch"]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional["FluentBitMatch"], result)
+    @jsii.member(jsii_name="family")
+    def family(self) -> builtins.str:
+        ...
 
     @builtins.property
-    def pattern(self) -> "FluentBitGrepRegex":
-        '''The pattern to use for filtering records processed by the plugin.'''
-        result = self._values.get("pattern")
-        assert result is not None, "Required property 'pattern' is missing"
-        return typing.cast("FluentBitGrepRegex", result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="publiclyAdvertisable")
+    def publicly_advertisable(self) -> typing.Optional[builtins.bool]:
+        ...
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "FluentBitGrepFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
 
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepRegex",
-    jsii_struct_bases=[],
-    name_mapping={"key": "key", "regex": "regex", "exclude": "exclude"},
-)
-class FluentBitGrepRegex:
-    def __init__(
-        self,
-        *,
-        key: builtins.str,
-        regex: builtins.str,
-        exclude: typing.Optional[builtins.bool] = None,
-    ) -> None:
-        '''Configures a pattern to match against a Fluent Bit record.
-
-        :param key: The key of the fields which you want to filter using the regex.
-        :param regex: The regular expression to apply to the specified field.
-        :param exclude: Whether the matched expression should exclude or include records from being output. When this is true, only records that match the given expression will be output. When this is false, only records that do not match the given expression will be output. Default: false
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7d5213db46ae4f43816c9caa03cf901d34224d6f6abfb3d42513921dd5cdbb98)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-            check_type(argname="argument exclude", value=exclude, expected_type=type_hints["exclude"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "key": key,
-            "regex": regex,
-        }
-        if exclude is not None:
-            self._values["exclude"] = exclude
+class _IAddressConfigurationProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IAddressConfiguration"
 
     @builtins.property
-    def key(self) -> builtins.str:
-        '''The key of the fields which you want to filter using the regex.'''
-        result = self._values.get("key")
-        assert result is not None, "Required property 'key' is missing"
-        return typing.cast(builtins.str, result)
+    @jsii.member(jsii_name="family")
+    def family(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "family"))
 
     @builtins.property
-    def regex(self) -> builtins.str:
-        '''The regular expression to apply to the specified field.'''
-        result = self._values.get("regex")
-        assert result is not None, "Required property 'regex' is missing"
-        return typing.cast(builtins.str, result)
-
-    @builtins.property
-    def exclude(self) -> typing.Optional[builtins.bool]:
-        '''Whether the matched expression should exclude or include records from being output.
-
-        When this is true, only records that match the given expression will be
-        output.
-
-        When this is false, only records that do not match the given expression
-        will be output.
-
-        :default: false
-        '''
-        result = self._values.get("exclude")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "FluentBitGrepRegex(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @jsii.member(jsii_name="publiclyAdvertisable")
+    def publicly_advertisable(self) -> typing.Optional[builtins.bool]:
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "publiclyAdvertisable"))
 
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IAddressConfiguration).__jsii_proxy_class__ = lambda : _IAddressConfigurationProxy
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKubernetesFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "annotations": "annotations",
-        "buffer_size": "bufferSize",
-        "cache_use_docker_id": "cacheUseDockerId",
-        "dns_retries": "dnsRetries",
-        "dns_wait_time": "dnsWaitTime",
-        "dummy_meta": "dummyMeta",
-        "k8s_logging_exclude": "k8sLoggingExclude",
-        "k8s_logging_parser": "k8sLoggingParser",
-        "keep_log": "keepLog",
-        "kube_ca_file": "kubeCaFile",
-        "kube_ca_path": "kubeCaPath",
-        "kubelet_host": "kubeletHost",
-        "kubelet_port": "kubeletPort",
-        "kube_meta_cache_ttl": "kubeMetaCacheTtl",
-        "kube_meta_preload_cache_dir": "kubeMetaPreloadCacheDir",
-        "kube_tag_prefix": "kubeTagPrefix",
-        "kube_token_command": "kubeTokenCommand",
-        "kube_token_file": "kubeTokenFile",
-        "kube_token_ttl": "kubeTokenTtl",
-        "kube_url": "kubeUrl",
-        "labels": "labels",
-        "merge_log": "mergeLog",
-        "merge_log_key": "mergeLogKey",
-        "merge_log_trim": "mergeLogTrim",
-        "merge_parser": "mergeParser",
-        "regex_parser": "regexParser",
-        "tls_debug": "tlsDebug",
-        "tls_verify": "tlsVerify",
-        "use_journal": "useJournal",
-        "use_kubelet": "useKubelet",
-    },
-)
-class FluentBitKubernetesFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
-        self,
-        *,
-        match: typing.Optional["FluentBitMatch"] = None,
-        annotations: typing.Optional[builtins.bool] = None,
-        buffer_size: typing.Optional[_DataSize_d20aaece] = None,
-        cache_use_docker_id: typing.Optional[builtins.bool] = None,
-        dns_retries: typing.Optional[jsii.Number] = None,
-        dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        dummy_meta: typing.Optional[builtins.bool] = None,
-        k8s_logging_exclude: typing.Optional[builtins.bool] = None,
-        k8s_logging_parser: typing.Optional[builtins.bool] = None,
-        keep_log: typing.Optional[builtins.bool] = None,
-        kube_ca_file: typing.Optional[builtins.str] = None,
-        kube_ca_path: typing.Optional[builtins.str] = None,
-        kubelet_host: typing.Optional[builtins.str] = None,
-        kubelet_port: typing.Optional[jsii.Number] = None,
-        kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
-        kube_tag_prefix: typing.Optional[builtins.str] = None,
-        kube_token_command: typing.Optional[builtins.str] = None,
-        kube_token_file: typing.Optional[builtins.str] = None,
-        kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        kube_url: typing.Optional[builtins.str] = None,
-        labels: typing.Optional[builtins.bool] = None,
-        merge_log: typing.Optional[builtins.bool] = None,
-        merge_log_key: typing.Optional[builtins.str] = None,
-        merge_log_trim: typing.Optional[builtins.bool] = None,
-        merge_parser: typing.Optional[builtins.str] = None,
-        regex_parser: typing.Optional[builtins.str] = None,
-        tls_debug: typing.Optional[jsii.Number] = None,
-        tls_verify: typing.Optional[builtins.bool] = None,
-        use_journal: typing.Optional[builtins.bool] = None,
-        use_kubelet: typing.Optional[builtins.bool] = None,
-    ) -> None:
-        '''Options for configuring the Kubernetes Fluent Bit filter plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param annotations: Include Kubernetes resource annotations in the extra metadata. Default: true
-        :param buffer_size: Set the buffer size for HTTP client when reading responses from Kubernetes API server. A value of 0 results in no limit, and the buffer will expand as-needed. Note that if pod specifications exceed the buffer limit, the API response will be discarded when retrieving metadata, and some kubernetes metadata will fail to be injected to the logs. Default: 32k
-        :param cache_use_docker_id: When enabled, metadata will be fetched from K8s when docker_id is changed. Default: false
-        :param dns_retries: DNS lookup retries N times until the network starts working. Default: 6
-        :param dns_wait_time: DNS lookup interval between network status checks. Default: 30 seconds
-        :param dummy_meta: If set, use dummy-meta data (for test/dev purposes). Default: false
-        :param k8s_logging_exclude: Allow Kubernetes Pods to exclude their logs from the log processor. Default: false
-        :param k8s_logging_parser: Allow Kubernetes Pods to suggest a pre-defined Parser. Default: false
-        :param keep_log: When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well). Default: true
-        :param kube_ca_file: CA certificate file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
-        :param kube_ca_path: Absolute path to scan for certificate files.
-        :param kubelet_host: Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
-        :param kubelet_port: Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled. Default: 10250
-        :param kube_meta_cache_ttl: Configurable TTL for K8s cached metadata. By default, it is set to 0 which means TTL for cache entries is disabled and cache entries are evicted at random when capacity is reached. In order to enable this option, you should set the number to a time interval. Default: 0
-        :param kube_meta_preload_cache_dir: If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
-        :param kube_tag_prefix: When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration. Default: 'kube.var.log.containers.'
-        :param kube_token_command: Command to get Kubernetes authorization token. If you want to manually choose a command to get it, you can set the command here. For example, run running the following to get the token using aws-cli:: aws-iam-authenticator -i your-cluster-name token --token-only This option is currently Linux-only.
-        :param kube_token_file: Token file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
-        :param kube_token_ttl: Configurable 'time to live' for the K8s token. After this time, the token is reloaded from ``kubeTokenFile`` or the ``kubeTokenCommand``. Default: 10 minutes
-        :param kube_url: API Server end-point. Default: 'https://kubernetes.default.svc/'
-        :param labels: Include Kubernetes resource labels in the extra metadata. Default: true
-        :param merge_log: When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure. Default: false
-        :param merge_log_key: When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map. Now if ``mergeLogKey`` is set (a string name), all the new structured fields taken from the original ``log`` content are inserted under the new key.
-        :param merge_log_trim: When Merge_Log is enabled, trim (remove possible \\n or \\r) field values. Default: true
-        :param merge_parser: Optional parser name to specify how to parse the data contained in the log key. Recommended use is for developers or testing only.
-        :param regex_parser: Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id. The parser must be registered in a parsers file.
-        :param tls_debug: Debug level between 0 (nothing) and 4 (every detail). Default: -1
-        :param tls_verify: When enabled, turns on certificate validation when connecting to the Kubernetes API server. Default: true
-        :param use_journal: When enabled, the filter reads logs coming in Journald format. Default: false
-        :param use_kubelet: This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log. Default: false
-
-        :see: `Kubernetes Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__491341e10d39ab453cf8cb9ce79aa79883683ad1bef71b12d50956da0005ed71)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
-            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
-            check_type(argname="argument cache_use_docker_id", value=cache_use_docker_id, expected_type=type_hints["cache_use_docker_id"])
-            check_type(argname="argument dns_retries", value=dns_retries, expected_type=type_hints["dns_retries"])
-            check_type(argname="argument dns_wait_time", value=dns_wait_time, expected_type=type_hints["dns_wait_time"])
-            check_type(argname="argument dummy_meta", value=dummy_meta, expected_type=type_hints["dummy_meta"])
-            check_type(argname="argument k8s_logging_exclude", value=k8s_logging_exclude, expected_type=type_hints["k8s_logging_exclude"])
-            check_type(argname="argument k8s_logging_parser", value=k8s_logging_parser, expected_type=type_hints["k8s_logging_parser"])
-            check_type(argname="argument keep_log", value=keep_log, expected_type=type_hints["keep_log"])
-            check_type(argname="argument kube_ca_file", value=kube_ca_file, expected_type=type_hints["kube_ca_file"])
-            check_type(argname="argument kube_ca_path", value=kube_ca_path, expected_type=type_hints["kube_ca_path"])
-            check_type(argname="argument kubelet_host", value=kubelet_host, expected_type=type_hints["kubelet_host"])
-            check_type(argname="argument kubelet_port", value=kubelet_port, expected_type=type_hints["kubelet_port"])
-            check_type(argname="argument kube_meta_cache_ttl", value=kube_meta_cache_ttl, expected_type=type_hints["kube_meta_cache_ttl"])
-            check_type(argname="argument kube_meta_preload_cache_dir", value=kube_meta_preload_cache_dir, expected_type=type_hints["kube_meta_preload_cache_dir"])
-            check_type(argname="argument kube_tag_prefix", value=kube_tag_prefix, expected_type=type_hints["kube_tag_prefix"])
-            check_type(argname="argument kube_token_command", value=kube_token_command, expected_type=type_hints["kube_token_command"])
-            check_type(argname="argument kube_token_file", value=kube_token_file, expected_type=type_hints["kube_token_file"])
-            check_type(argname="argument kube_token_ttl", value=kube_token_ttl, expected_type=type_hints["kube_token_ttl"])
-            check_type(argname="argument kube_url", value=kube_url, expected_type=type_hints["kube_url"])
-            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
-            check_type(argname="argument merge_log", value=merge_log, expected_type=type_hints["merge_log"])
-            check_type(argname="argument merge_log_key", value=merge_log_key, expected_type=type_hints["merge_log_key"])
-            check_type(argname="argument merge_log_trim", value=merge_log_trim, expected_type=type_hints["merge_log_trim"])
-            check_type(argname="argument merge_parser", value=merge_parser, expected_type=type_hints["merge_parser"])
-            check_type(argname="argument regex_parser", value=regex_parser, expected_type=type_hints["regex_parser"])
-            check_type(argname="argument tls_debug", value=tls_debug, expected_type=type_hints["tls_debug"])
-            check_type(argname="argument tls_verify", value=tls_verify, expected_type=type_hints["tls_verify"])
-            check_type(argname="argument use_journal", value=use_journal, expected_type=type_hints["use_journal"])
-            check_type(argname="argument use_kubelet", value=use_kubelet, expected_type=type_hints["use_kubelet"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if annotations is not None:
-            self._values["annotations"] = annotations
-        if buffer_size is not None:
-            self._values["buffer_size"] = buffer_size
-        if cache_use_docker_id is not None:
-            self._values["cache_use_docker_id"] = cache_use_docker_id
-        if dns_retries is not None:
-            self._values["dns_retries"] = dns_retries
-        if dns_wait_time is not None:
-            self._values["dns_wait_time"] = dns_wait_time
-        if dummy_meta is not None:
-            self._values["dummy_meta"] = dummy_meta
-        if k8s_logging_exclude is not None:
-            self._values["k8s_logging_exclude"] = k8s_logging_exclude
-        if k8s_logging_parser is not None:
-            self._values["k8s_logging_parser"] = k8s_logging_parser
-        if keep_log is not None:
-            self._values["keep_log"] = keep_log
-        if kube_ca_file is not None:
-            self._values["kube_ca_file"] = kube_ca_file
-        if kube_ca_path is not None:
-            self._values["kube_ca_path"] = kube_ca_path
-        if kubelet_host is not None:
-            self._values["kubelet_host"] = kubelet_host
-        if kubelet_port is not None:
-            self._values["kubelet_port"] = kubelet_port
-        if kube_meta_cache_ttl is not None:
-            self._values["kube_meta_cache_ttl"] = kube_meta_cache_ttl
-        if kube_meta_preload_cache_dir is not None:
-            self._values["kube_meta_preload_cache_dir"] = kube_meta_preload_cache_dir
-        if kube_tag_prefix is not None:
-            self._values["kube_tag_prefix"] = kube_tag_prefix
-        if kube_token_command is not None:
-            self._values["kube_token_command"] = kube_token_command
-        if kube_token_file is not None:
-            self._values["kube_token_file"] = kube_token_file
-        if kube_token_ttl is not None:
-            self._values["kube_token_ttl"] = kube_token_ttl
-        if kube_url is not None:
-            self._values["kube_url"] = kube_url
-        if labels is not None:
-            self._values["labels"] = labels
-        if merge_log is not None:
-            self._values["merge_log"] = merge_log
-        if merge_log_key is not None:
-            self._values["merge_log_key"] = merge_log_key
-        if merge_log_trim is not None:
-            self._values["merge_log_trim"] = merge_log_trim
-        if merge_parser is not None:
-            self._values["merge_parser"] = merge_parser
-        if regex_parser is not None:
-            self._values["regex_parser"] = regex_parser
-        if tls_debug is not None:
-            self._values["tls_debug"] = tls_debug
-        if tls_verify is not None:
-            self._values["tls_verify"] = tls_verify
-        if use_journal is not None:
-            self._values["use_journal"] = use_journal
-        if use_kubelet is not None:
-            self._values["use_kubelet"] = use_kubelet
-
-    @builtins.property
-    def match(self) -> typing.Optional["FluentBitMatch"]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional["FluentBitMatch"], result)
 
+@jsii.interface(jsii_type="cdk-extensions.ec2.ICidrProvider")
+class ICidrProvider(typing_extensions.Protocol):
     @builtins.property
-    def annotations(self) -> typing.Optional[builtins.bool]:
-        '''Include Kubernetes resource annotations in the extra metadata.
-
-        :default: true
-        '''
-        result = self._values.get("annotations")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="ipamOptions")
+    def ipam_options(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions:
+        ...
 
     @builtins.property
-    def buffer_size(self) -> typing.Optional[_DataSize_d20aaece]:
-        '''Set the buffer size for HTTP client when reading responses from Kubernetes API server.
+    @jsii.member(jsii_name="netmask")
+    def netmask(self) -> jsii.Number:
+        ...
 
-        A value of 0 results in no limit, and the buffer will expand as-needed.
+    @builtins.property
+    @jsii.member(jsii_name="ipamPool")
+    def ipam_pool(self) -> typing.Optional["IIpamPool"]:
+        ...
 
-        Note that if pod specifications exceed the buffer limit, the API
-        response will be discarded when retrieving metadata, and some kubernetes
-        metadata will fail to be injected to the logs.
 
-        :default: 32k
-        '''
-        result = self._values.get("buffer_size")
-        return typing.cast(typing.Optional[_DataSize_d20aaece], result)
+class _ICidrProviderProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ICidrProvider"
 
     @builtins.property
-    def cache_use_docker_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, metadata will be fetched from K8s when docker_id is changed.
-
-        :default: false
-        '''
-        result = self._values.get("cache_use_docker_id")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="ipamOptions")
+    def ipam_options(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions, jsii.get(self, "ipamOptions"))
 
     @builtins.property
-    def dns_retries(self) -> typing.Optional[jsii.Number]:
-        '''DNS lookup retries N times until the network starts working.
-
-        :default: 6
-        '''
-        result = self._values.get("dns_retries")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    @jsii.member(jsii_name="netmask")
+    def netmask(self) -> jsii.Number:
+        return typing.cast(jsii.Number, jsii.get(self, "netmask"))
 
     @builtins.property
-    def dns_wait_time(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''DNS lookup interval between network status checks.
+    @jsii.member(jsii_name="ipamPool")
+    def ipam_pool(self) -> typing.Optional["IIpamPool"]:
+        return typing.cast(typing.Optional["IIpamPool"], jsii.get(self, "ipamPool"))
 
-        :default: 30 seconds
-        '''
-        result = self._values.get("dns_wait_time")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ICidrProvider).__jsii_proxy_class__ = lambda : _ICidrProviderProxy
 
-    @builtins.property
-    def dummy_meta(self) -> typing.Optional[builtins.bool]:
-        '''If set, use dummy-meta data (for test/dev purposes).
 
-        :default: false
-        '''
-        result = self._values.get("dummy_meta")
-        return typing.cast(typing.Optional[builtins.bool], result)
+@jsii.interface(jsii_type="cdk-extensions.ec2.ICustomerGateway")
+class ICustomerGateway(typing_extensions.Protocol):
+    '''Represents a customer gateway in AWS.'''
 
     @builtins.property
-    def k8s_logging_exclude(self) -> typing.Optional[builtins.bool]:
-        '''Allow Kubernetes Pods to exclude their logs from the log processor.
-
-        :default: false
-        '''
-        result = self._values.get("k8s_logging_exclude")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="customerGatewayAsn")
+    def customer_gateway_asn(self) -> jsii.Number:
+        '''The BGP ASN of the customer gateway.'''
+        ...
 
     @builtins.property
-    def k8s_logging_parser(self) -> typing.Optional[builtins.bool]:
-        '''Allow Kubernetes Pods to suggest a pre-defined Parser.
-
-        :default: false
-        '''
-        result = self._values.get("k8s_logging_parser")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="customerGatewayId")
+    def customer_gateway_id(self) -> builtins.str:
+        '''The ID of the customer gateway.'''
+        ...
 
     @builtins.property
-    def keep_log(self) -> typing.Optional[builtins.bool]:
-        '''When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well).
+    @jsii.member(jsii_name="customerGatewayIp")
+    def customer_gateway_ip(self) -> builtins.str:
+        '''The IP address of the customer gateway.'''
+        ...
 
-        :default: true
-        '''
-        result = self._values.get("keep_log")
-        return typing.cast(typing.Optional[builtins.bool], result)
 
-    @builtins.property
-    def kube_ca_file(self) -> typing.Optional[builtins.str]:
-        '''CA certificate file.
+class _ICustomerGatewayProxy:
+    '''Represents a customer gateway in AWS.'''
 
-        :default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
-        '''
-        result = self._values.get("kube_ca_file")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def kube_ca_path(self) -> typing.Optional[builtins.str]:
-        '''Absolute path to scan for certificate files.'''
-        result = self._values.get("kube_ca_path")
-        return typing.cast(typing.Optional[builtins.str], result)
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ICustomerGateway"
 
     @builtins.property
-    def kubelet_host(self) -> typing.Optional[builtins.str]:
-        '''Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.'''
-        result = self._values.get("kubelet_host")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="customerGatewayAsn")
+    def customer_gateway_asn(self) -> jsii.Number:
+        '''The BGP ASN of the customer gateway.'''
+        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
 
     @builtins.property
-    def kubelet_port(self) -> typing.Optional[jsii.Number]:
-        '''Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled.
-
-        :default: 10250
-        '''
-        result = self._values.get("kubelet_port")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    @jsii.member(jsii_name="customerGatewayId")
+    def customer_gateway_id(self) -> builtins.str:
+        '''The ID of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
 
     @builtins.property
-    def kube_meta_cache_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''Configurable TTL for K8s cached metadata.
+    @jsii.member(jsii_name="customerGatewayIp")
+    def customer_gateway_ip(self) -> builtins.str:
+        '''The IP address of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
 
-        By default, it is set to 0 which means TTL for cache entries is disabled
-        and cache entries are evicted at random when capacity is reached.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ICustomerGateway).__jsii_proxy_class__ = lambda : _ICustomerGatewayProxy
 
-        In order to enable this option, you should set the number to a time
-        interval.
 
-        :default: 0
-        '''
-        result = self._values.get("kube_meta_cache_ttl")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpam")
+class IIpam(typing_extensions.Protocol):
+    '''Represents an IPAM in AWS.'''
 
     @builtins.property
-    def kube_meta_preload_cache_dir(self) -> typing.Optional[builtins.str]:
-        '''If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.'''
-        result = self._values.get("kube_meta_preload_cache_dir")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamArn")
+    def ipam_arn(self) -> builtins.str:
+        '''The ARN of the IPAM.'''
+        ...
 
     @builtins.property
-    def kube_tag_prefix(self) -> typing.Optional[builtins.str]:
-        '''When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration.
-
-        :default: 'kube.var.log.containers.'
-        '''
-        result = self._values.get("kube_tag_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamId")
+    def ipam_id(self) -> builtins.str:
+        '''The ID of the IPAM.'''
+        ...
 
     @builtins.property
-    def kube_token_command(self) -> typing.Optional[builtins.str]:
-        '''Command to get Kubernetes authorization token.
-
-        If you want to manually choose a command to get it, you can set the
-        command here.
-
-        For example, run running the following to get the token using aws-cli::
-
-           aws-iam-authenticator -i your-cluster-name token --token-only
-
-        This option is currently Linux-only.
-        '''
-        result = self._values.get("kube_token_command")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamPrivateDefaultScopeId")
+    def ipam_private_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default private scope.'''
+        ...
 
     @builtins.property
-    def kube_token_file(self) -> typing.Optional[builtins.str]:
-        '''Token file.
-
-        :default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
-        '''
-        result = self._values.get("kube_token_file")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamPublicDefaultScopeId")
+    def ipam_public_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default public scope.'''
+        ...
 
     @builtins.property
-    def kube_token_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''Configurable 'time to live' for the K8s token.
-
-        After this time, the token is reloaded from ``kubeTokenFile`` or the
-        ``kubeTokenCommand``.
+    @jsii.member(jsii_name="ipamScopeCount")
+    def ipam_scope_count(self) -> jsii.Number:
+        '''The number of scopes in the IPAM.
 
-        :default: 10 minutes
+        The scope quota is 5.
         '''
-        result = self._values.get("kube_token_ttl")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
-
-    @builtins.property
-    def kube_url(self) -> typing.Optional[builtins.str]:
-        '''API Server end-point.
+        ...
 
-        :default: 'https://kubernetes.default.svc/'
-        '''
-        result = self._values.get("kube_url")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="addScope")
+    def add_scope(
+        self,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+    ) -> "IIpamScope":
+        '''Adds an IPAM scope to the IPAM.
 
-    @builtins.property
-    def labels(self) -> typing.Optional[builtins.bool]:
-        '''Include Kubernetes resource labels in the extra metadata.
+        In IPAM, a scope is the highest-level container within IPAM. Scopes enable
+        you to reuse IP addresses across multiple unconnected networks without
+        causing IP address overlap or conflict.
 
-        :default: true
-        '''
-        result = self._values.get("labels")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :param id: A name to be associated to the scope being added. A unique id must be used each time this method is invoked.
+        :param description: The description of the scope.
 
-    @builtins.property
-    def merge_log(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure.
+        :return: The scope that was added to the IPAM.
 
-        :default: false
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
         '''
-        result = self._values.get("merge_log")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def merge_log_key(self) -> typing.Optional[builtins.str]:
-        '''When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map.
+        ...
 
-        Now if ``mergeLogKey`` is set (a string name), all the new structured
-        fields taken from the original ``log`` content are inserted under the new
-        key.
-        '''
-        result = self._values.get("merge_log_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="associateResourceDiscovery")
+    def associate_resource_discovery(
+        self,
+        resource_discovery: "IIpamResourceDiscovery",
+    ) -> "IIpamResourceDiscoveryAssociation":
+        '''Associates an existing IPAM resource discovery with the IPAM.
 
-    @builtins.property
-    def merge_log_trim(self) -> typing.Optional[builtins.bool]:
-        '''When Merge_Log is enabled, trim (remove possible \\n or \\r) field values.
+        IPAM aggregates the resource CIDRs discovered by the associated resource
+        discovery.
 
-        :default: true
-        '''
-        result = self._values.get("merge_log_trim")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :param resource_discovery: The IPAM resource discovery to associate with the IPAM.
 
-    @builtins.property
-    def merge_parser(self) -> typing.Optional[builtins.str]:
-        '''Optional parser name to specify how to parse the data contained in the log key.
+        :return:
 
-        Recommended use is for developers or testing only.
+        The association resource that handles the association between the
+        IPAM and the resource discovery.
         '''
-        result = self._values.get("merge_parser")
-        return typing.cast(typing.Optional[builtins.str], result)
+        ...
 
-    @builtins.property
-    def regex_parser(self) -> typing.Optional[builtins.str]:
-        '''Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id.
 
-        The parser must be registered in a parsers file.
+class _IIpamProxy:
+    '''Represents an IPAM in AWS.'''
 
-        :see: `Parsers File <https://github.com/fluent/fluent-bit/blob/master/conf/parsers.conf>`_
-        '''
-        result = self._values.get("regex_parser")
-        return typing.cast(typing.Optional[builtins.str], result)
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpam"
 
     @builtins.property
-    def tls_debug(self) -> typing.Optional[jsii.Number]:
-        '''Debug level between 0 (nothing) and 4 (every detail).
-
-        :default: -1
-        '''
-        result = self._values.get("tls_debug")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    @jsii.member(jsii_name="ipamArn")
+    def ipam_arn(self) -> builtins.str:
+        '''The ARN of the IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamArn"))
 
     @builtins.property
-    def tls_verify(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, turns on certificate validation when connecting to the Kubernetes API server.
-
-        :default: true
-        '''
-        result = self._values.get("tls_verify")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="ipamId")
+    def ipam_id(self) -> builtins.str:
+        '''The ID of the IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamId"))
 
     @builtins.property
-    def use_journal(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, the filter reads logs coming in Journald format.
-
-        :default: false
-        '''
-        result = self._values.get("use_journal")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="ipamPrivateDefaultScopeId")
+    def ipam_private_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default private scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamPrivateDefaultScopeId"))
 
     @builtins.property
-    def use_kubelet(self) -> typing.Optional[builtins.bool]:
-        '''This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log.
+    @jsii.member(jsii_name="ipamPublicDefaultScopeId")
+    def ipam_public_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default public scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamPublicDefaultScopeId"))
 
-        :default: false
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeCount")
+    def ipam_scope_count(self) -> jsii.Number:
+        '''The number of scopes in the IPAM.
 
-        :see: `Kube API heavy traffic issue for large cluster <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes#optional-feature-using-kubelet-to-get-metadata>`_
+        The scope quota is 5.
         '''
-        result = self._values.get("use_kubelet")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast(jsii.Number, jsii.get(self, "ipamScopeCount"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @jsii.member(jsii_name="addScope")
+    def add_scope(
+        self,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+    ) -> "IIpamScope":
+        '''Adds an IPAM scope to the IPAM.
 
-    def __repr__(self) -> str:
-        return "FluentBitKubernetesFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        In IPAM, a scope is the highest-level container within IPAM. Scopes enable
+        you to reuse IP addresses across multiple unconnected networks without
+        causing IP address overlap or conflict.
 
+        :param id: A name to be associated to the scope being added. A unique id must be used each time this method is invoked.
+        :param description: The description of the scope.
 
-class FluentBitLogGroupOutput(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLogGroupOutput",
-):
-    '''Represents valid log group output configuration options to be used by Fluent Bit when writing to CloudWatch Logs.'''
+        :return: The scope that was added to the IPAM.
 
-    @jsii.member(jsii_name="create")
-    @builtins.classmethod
-    def create(cls) -> "FluentBitLogGroupOutput":
-        '''Sets a flag saying that a log group should be created automatically.
-
-        Depending on the configuration of the plugin, this flag will either cause
-        permissions to be granted for Fluent Bit to create the log group itself or
-        the plugin CDK resource will create a Log Group and use that as the
-        destination.
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a1b636be2a744fe98f3e277a800df843bb1e2f86672d166ac7ef45b182fad912)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamScopeOptions(description=description)
 
-        :return:
+        return typing.cast("IIpamScope", jsii.invoke(self, "addScope", [id, options]))
 
-        A FluentBitLogGroupOutput object representing the configured log
-        group destination.
-        '''
-        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "create", []))
+    @jsii.member(jsii_name="associateResourceDiscovery")
+    def associate_resource_discovery(
+        self,
+        resource_discovery: "IIpamResourceDiscovery",
+    ) -> "IIpamResourceDiscoveryAssociation":
+        '''Associates an existing IPAM resource discovery with the IPAM.
 
-    @jsii.member(jsii_name="fromLogGroup")
-    @builtins.classmethod
-    def from_log_group(
-        cls,
-        log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
-    ) -> "FluentBitLogGroupOutput":
-        '''Sets the destination log group to a LogGroup CDK resource.
+        IPAM aggregates the resource CIDRs discovered by the associated resource
+        discovery.
 
-        :param log_group: The log group where output records should be written.
+        :param resource_discovery: The IPAM resource discovery to associate with the IPAM.
 
         :return:
 
-        A FluentBitLogGroupOutput object representing the configured log
-        group destination.
+        The association resource that handles the association between the
+        IPAM and the resource discovery.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9e5f787f6c53b83309ad3224ae7cbd397dc281f463e865210fadeede93199ea7)
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "fromLogGroup", [log_group]))
-
-    @jsii.member(jsii_name="fromName")
-    @builtins.classmethod
-    def from_name(
-        cls,
-        name: builtins.str,
-        create: typing.Optional[builtins.bool] = None,
-    ) -> "FluentBitLogGroupOutput":
-        '''Sets the destination for logs to the named log group.
+            type_hints = typing.get_type_hints(_typecheckingstub__1038342f468b756d95a5fa72e9acf7a439b03b68ab6d8fa6f1f066a4d21949f8)
+            check_type(argname="argument resource_discovery", value=resource_discovery, expected_type=type_hints["resource_discovery"])
+        return typing.cast("IIpamResourceDiscoveryAssociation", jsii.invoke(self, "associateResourceDiscovery", [resource_discovery]))
 
-        :param name: The name of the log group where output records should be written.
-        :param create: -
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpam).__jsii_proxy_class__ = lambda : _IIpamProxy
 
-        :return:
-
-        A FluentBitLogGroupOutput object representing the configured log
-        group destination.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__67456e5d91f4ffd1bec1ee1e4391d0f4f5ae2b0b2d8f9151cd8a758ce8565c1d)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument create", value=create, expected_type=type_hints["create"])
-        return typing.cast("FluentBitLogGroupOutput", jsii.sinvoke(cls, "fromName", [name, create]))
 
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamAllocation")
+class IIpamAllocation(typing_extensions.Protocol):
     @builtins.property
-    @jsii.member(jsii_name="autoCreate")
-    def auto_create(self) -> typing.Optional[builtins.bool]:
-        '''Flag that determines whether or not a log group should be automatically created.'''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoCreate"))
+    @jsii.member(jsii_name="ipamAllocationCidr")
+    def ipam_allocation_cidr(self) -> builtins.str:
+        ...
 
     @builtins.property
-    @jsii.member(jsii_name="logGroup")
-    def log_group(self) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup]:
-        '''A log group resource object to use as the destination.'''
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup], jsii.get(self, "logGroup"))
+    @jsii.member(jsii_name="ipamAllocationId")
+    def ipam_allocation_id(self) -> builtins.str:
+        ...
 
-    @builtins.property
-    @jsii.member(jsii_name="logGroupName")
-    def log_group_name(self) -> typing.Optional[builtins.str]:
-        '''The name for the log group that should be used for output records.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupName"))
 
+class _IIpamAllocationProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamAllocation"
 
-class FluentBitLogStreamOutput(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLogStreamOutput",
-):
-    '''Represents valid log stream output configuration options to be used by Fluent Bit when writing to CloudWatch Logs.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamAllocationCidr")
+    def ipam_allocation_cidr(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamAllocationCidr"))
 
-    @jsii.member(jsii_name="fromLogStream")
-    @builtins.classmethod
-    def from_log_stream(
-        cls,
-        log_stream: _aws_cdk_aws_logs_ceddda9d.ILogStream,
-    ) -> "FluentBitLogStreamOutput":
-        '''Sets output to be a log stream resource object.
+    @builtins.property
+    @jsii.member(jsii_name="ipamAllocationId")
+    def ipam_allocation_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamAllocationId"))
 
-        :param log_stream: The log stream where records should be written.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamAllocation).__jsii_proxy_class__ = lambda : _IIpamAllocationProxy
 
-        :return:
 
-        A FluentBitLogStreamOutput object representing the configured
-        log stream destination.
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamAllocationConfiguration")
+class IIpamAllocationConfiguration(typing_extensions.Protocol):
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedIpamAllocationConfiguration":
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bf36bc82a5087381a1e00eedb991062da3fb86e1b1b2dc82f40a25d98c830a03)
-            check_type(argname="argument log_stream", value=log_stream, expected_type=type_hints["log_stream"])
-        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromLogStream", [log_stream]))
-
-    @jsii.member(jsii_name="fromName")
-    @builtins.classmethod
-    def from_name(cls, name: builtins.str) -> "FluentBitLogStreamOutput":
-        '''Sets output to a named log stream.
-
-        If a log stream with the given name doesn't exist in the configured log
-        group a log stream with the given name will be created.
+        :param scope: -
+        '''
+        ...
 
-        :param name: The name of the log stream where records should be written.
 
-        :return:
+class _IIpamAllocationConfigurationProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamAllocationConfiguration"
 
-        A FluentBitLogStreamOutput object representing the configured
-        log stream destination.
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedIpamAllocationConfiguration":
+        '''
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d2d24583ddfcc8876ab533165130d5b3607247d011b36995e13163c253b6e718)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromName", [name]))
-
-    @jsii.member(jsii_name="fromPrefix")
-    @builtins.classmethod
-    def from_prefix(cls, prefix: builtins.str) -> "FluentBitLogStreamOutput":
-        '''Sets output to a prefixed log stream.
+            type_hints = typing.get_type_hints(_typecheckingstub__dece55321285f291ec77410a702ac3c08fbcf7db95c03c5bf9bedf2291da114f)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast("ResolvedIpamAllocationConfiguration", jsii.invoke(self, "bind", [scope]))
 
-        Log streams will be created on a per-pod basis with the name oof the log
-        streams starting with the provided prefix.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamAllocationConfiguration).__jsii_proxy_class__ = lambda : _IIpamAllocationConfigurationProxy
 
-        :param prefix: The prefix for log streams which will be created.
 
-        :return:
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamPool")
+class IIpamPool(_aws_cdk_ceddda9d.IResource, typing_extensions.Protocol):
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolArn")
+    def ipam_pool_arn(self) -> builtins.str:
+        ...
 
-        A FluentBitLogStreamOutput object representing the configured
-        log stream destination.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f2176a9e11225cfa29051ee0166fd6151266cf8a3753905e128f0cb83df80178)
-            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
-        return typing.cast("FluentBitLogStreamOutput", jsii.sinvoke(cls, "fromPrefix", [prefix]))
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolDepth")
+    def ipam_pool_depth(self) -> jsii.Number:
+        ...
 
     @builtins.property
-    @jsii.member(jsii_name="logStreamName")
-    def log_stream_name(self) -> typing.Optional[builtins.str]:
-        '''The name of the log stream where records should be created.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamName"))
+    @jsii.member(jsii_name="ipamPoolId")
+    def ipam_pool_id(self) -> builtins.str:
+        ...
 
     @builtins.property
-    @jsii.member(jsii_name="logStreamPrefix")
-    def log_stream_prefix(self) -> typing.Optional[builtins.str]:
-        '''The prefix for log streams that will be created on a per-pod basis.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamPrefix"))
+    @jsii.member(jsii_name="ipamPoolIpamArn")
+    def ipam_pool_ipam_arn(self) -> builtins.str:
+        ...
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolScopeArn")
+    def ipam_pool_scope_arn(self) -> builtins.str:
+        ...
 
-class FluentBitMatch(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitMatch",
-):
-    '''Represents a filter that can be applied to Filter and Output plugins that scopes down what records the given filter should apply to.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolScopeType")
+    def ipam_pool_scope_type(self) -> builtins.str:
+        ...
 
-    @jsii.member(jsii_name="glob")
-    @builtins.classmethod
-    def glob(cls, pattern: builtins.str) -> "FluentBitMatch":
-        '''Creates a match pattern that supports basic wildcard matching using the star character (``*``).
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolState")
+    def ipam_pool_state(self) -> builtins.str:
+        ...
 
-        :param pattern: The pattern to use to match against the tags of an incoming record. It's case sensitive and support the star (``*``) character as a wildcard.
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolStateMessage")
+    def ipam_pool_state_message(self) -> builtins.str:
+        ...
 
-        :return: A match object representing the given pattern.
+    @jsii.member(jsii_name="addChildPool")
+    def add_child_pool(
+        self,
+        id: builtins.str,
+        *,
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional["IpamConsumer"] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> "IIpamPool":
+        '''
+        :param id: -
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__42632d6e6d5ce15103cf294740e757e5f3a4db926970743e6ab114f398dea1d3)
-            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
-        return typing.cast("FluentBitMatch", jsii.sinvoke(cls, "glob", [pattern]))
-
-    @jsii.member(jsii_name="regex")
-    @builtins.classmethod
-    def regex(cls, pattern: builtins.str) -> "FluentBitMatch":
-        '''Creates a match pattern that supports full regex matching.
-
-        :param pattern: A regular expression to match against the tags of incoming records.
+        ...
 
-        :return: A match object representing the given pattern.
+    @jsii.member(jsii_name="addCidrToPool")
+    def add_cidr_to_pool(
+        self,
+        id: builtins.str,
+        *,
+        configuration: "IIpamPoolCidrConfiguration",
+        allow_inline: typing.Optional[builtins.bool] = None,
+    ) -> AddCidrToPoolResult:
+        '''
+        :param id: -
+        :param configuration: 
+        :param allow_inline: 
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__03245bf7bb94a21d38ca01a84e1768b7dae976c76ea7c6d0c9ea4c23cb4b5063)
-            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
-        return typing.cast("FluentBitMatch", jsii.sinvoke(cls, "regex", [pattern]))
-
-    @jsii.member(jsii_name="toObject")
-    def to_object(self) -> typing.Mapping[builtins.str, builtins.str]:
-        '''Creates a record object that can be used to represent the match in Fluent Bit configuration files.
+        ...
 
-        :return: The object that can be used to represent this match object.
+    @jsii.member(jsii_name="allocateCidrFromPool")
+    def allocate_cidr_from_pool(
+        self,
+        id: builtins.str,
+        *,
+        scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
+    ) -> IIpamAllocation:
+        '''
+        :param id: -
+        :param scope: 
+        :param allocation: 
+        :param description: 
         '''
-        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.invoke(self, "toObject", []))
+        ...
 
-    @jsii.member(jsii_name="toString")
-    def to_string(self) -> builtins.str:
-        '''Creates a string representation of this match object that reflects how it will appear in a Fluent Bit configuration file.
 
-        :return: A string representation of this match.
-        '''
-        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="ALL")
-    def ALL(cls) -> "FluentBitMatch":
-        '''Represents a pattern that will match all log entries.'''
-        return typing.cast("FluentBitMatch", jsii.sget(cls, "ALL"))
+class _IIpamPoolProxy(
+    jsii.proxy_for(_aws_cdk_ceddda9d.IResource), # type: ignore[misc]
+):
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamPool"
 
     @builtins.property
-    @jsii.member(jsii_name="evaluator")
-    def evaluator(self) -> "FluentBitMatchEvaluator":
-        '''The pattern matching syntax to use when evaluating incoming tags.
+    @jsii.member(jsii_name="ipamPoolArn")
+    def ipam_pool_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolArn"))
 
-        :group: Inputs
-        '''
-        return typing.cast("FluentBitMatchEvaluator", jsii.get(self, "evaluator"))
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolDepth")
+    def ipam_pool_depth(self) -> jsii.Number:
+        return typing.cast(jsii.Number, jsii.get(self, "ipamPoolDepth"))
 
     @builtins.property
-    @jsii.member(jsii_name="pattern")
-    def pattern(self) -> builtins.str:
-        '''The pattern to compare against the tags of incoming records.
+    @jsii.member(jsii_name="ipamPoolId")
+    def ipam_pool_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolId"))
 
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "pattern"))
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolIpamArn")
+    def ipam_pool_ipam_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolIpamArn"))
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolScopeArn")
+    def ipam_pool_scope_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolScopeArn"))
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.FluentBitMatchEvaluator")
-class FluentBitMatchEvaluator(enum.Enum):
-    '''Matching patterns supported by Fluent Bit plugins for scoping down incoming records.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolScopeType")
+    def ipam_pool_scope_type(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolScopeType"))
 
-    GLOB = "GLOB"
-    '''A basic pattern match supporting the star (``*``) character as a wildcard.'''
-    REGEX = "REGEX"
-    '''Full pattern matching using regular expressions.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolState")
+    def ipam_pool_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolState"))
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolStateMessage")
+    def ipam_pool_state_message(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolStateMessage"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitModifyFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "conditions": "conditions",
-        "operations": "operations",
-    },
-)
-class FluentBitModifyFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @jsii.member(jsii_name="addChildPool")
+    def add_child_pool(
         self,
+        id: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        conditions: typing.Optional[typing.Sequence["ModifyCondition"]] = None,
-        operations: typing.Optional[typing.Sequence["ModifyOperation"]] = None,
-    ) -> None:
-        '''Options for configuring the Modify Fluent Bit filter plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param conditions: 
-        :param operations: 
-
-        :see: `Modify Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/modify>`_
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional["IpamConsumer"] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> IIpamPool:
+        '''
+        :param id: -
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__477fb867f089070fa5d35c4c569a7ef1cc68825359200bc94957a309491b389b)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
-            check_type(argname="argument operations", value=operations, expected_type=type_hints["operations"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if conditions is not None:
-            self._values["conditions"] = conditions
-        if operations is not None:
-            self._values["operations"] = operations
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def conditions(self) -> typing.Optional[typing.List["ModifyCondition"]]:
-        result = self._values.get("conditions")
-        return typing.cast(typing.Optional[typing.List["ModifyCondition"]], result)
-
-    @builtins.property
-    def operations(self) -> typing.Optional[typing.List["ModifyOperation"]]:
-        result = self._values.get("operations")
-        return typing.cast(typing.Optional[typing.List["ModifyOperation"]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "FluentBitModifyFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
+            type_hints = typing.get_type_hints(_typecheckingstub__c7b9943cf34c897a8e2e801a7d2568d247995e02adfa9ebe1c8e9b9ff66f4b83)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AddChildPoolOptions(
+            address_configuration=address_configuration,
+            auto_import=auto_import,
+            consumer=consumer,
+            description=description,
+            locale=locale,
+            name=name,
+            provisioned_cidrs=provisioned_cidrs,
+            public_ip_source=public_ip_source,
+            tag_restrictions=tag_restrictions,
         )
 
+        return typing.cast(IIpamPool, jsii.invoke(self, "addChildPool", [id, options]))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitNestFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "operation": "operation",
-        "add_prefix": "addPrefix",
-        "remove_prefix": "removePrefix",
-    },
-)
-class FluentBitNestFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @jsii.member(jsii_name="addCidrToPool")
+    def add_cidr_to_pool(
         self,
+        id: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        operation: "NestFilterOperation",
-        add_prefix: typing.Optional[builtins.str] = None,
-        remove_prefix: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the Nest Fluent Bit filter plugin.
+        configuration: "IIpamPoolCidrConfiguration",
+        allow_inline: typing.Optional[builtins.bool] = None,
+    ) -> AddCidrToPoolResult:
+        '''
+        :param id: -
+        :param configuration: 
+        :param allow_inline: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0a3cfc72aca71117a43f300844c4498cc57a52c74a03750c5d05c818a74afac5)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AddCidrToPoolOptions(
+            configuration=configuration, allow_inline=allow_inline
+        )
 
-        :param match: The pattern to match for records that this output should apply to.
-        :param operation: The operation the filter will perform.
-        :param add_prefix: Prefix affected keys with this string.
-        :param remove_prefix: Remove prefix from affected keys if it matches this string.
+        return typing.cast(AddCidrToPoolResult, jsii.invoke(self, "addCidrToPool", [id, options]))
 
-        :see: `Nest Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/nest>`_
+    @jsii.member(jsii_name="allocateCidrFromPool")
+    def allocate_cidr_from_pool(
+        self,
+        id: builtins.str,
+        *,
+        scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
+    ) -> IIpamAllocation:
+        '''
+        :param id: -
+        :param scope: 
+        :param allocation: 
+        :param description: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__6baa844d691b01fb5358a6c2b04f16a51e81d297fb8c56fa7ba4e803056db09a)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
-            check_type(argname="argument add_prefix", value=add_prefix, expected_type=type_hints["add_prefix"])
-            check_type(argname="argument remove_prefix", value=remove_prefix, expected_type=type_hints["remove_prefix"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "operation": operation,
-        }
-        if match is not None:
-            self._values["match"] = match
-        if add_prefix is not None:
-            self._values["add_prefix"] = add_prefix
-        if remove_prefix is not None:
-            self._values["remove_prefix"] = remove_prefix
+            type_hints = typing.get_type_hints(_typecheckingstub__bc151299648c50c942a10f8ea00d0fc83b8c79aff1210095bcbe955062e51fd8)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AllocateCidrFromPoolOptions(
+            scope=scope, allocation=allocation, description=description
+        )
 
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
+        return typing.cast(IIpamAllocation, jsii.invoke(self, "allocateCidrFromPool", [id, options]))
 
-    @builtins.property
-    def operation(self) -> "NestFilterOperation":
-        '''The operation the filter will perform.'''
-        result = self._values.get("operation")
-        assert result is not None, "Required property 'operation' is missing"
-        return typing.cast("NestFilterOperation", result)
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamPool).__jsii_proxy_class__ = lambda : _IIpamPoolProxy
 
-    @builtins.property
-    def add_prefix(self) -> typing.Optional[builtins.str]:
-        '''Prefix affected keys with this string.'''
-        result = self._values.get("add_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
 
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamPoolCidr")
+class IIpamPoolCidr(typing_extensions.Protocol):
     @builtins.property
-    def remove_prefix(self) -> typing.Optional[builtins.str]:
-        '''Remove prefix from affected keys if it matches this string.'''
-        result = self._values.get("remove_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="ipamPoolCidrId")
+    def ipam_pool_cidr_id(self) -> builtins.str:
+        ...
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolCidrState")
+    def ipam_pool_cidr_state(self) -> builtins.str:
+        ...
 
-    def __repr__(self) -> str:
-        return "FluentBitNestFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
 
+class _IIpamPoolCidrProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamPoolCidr"
 
-class FluentBitOutput(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitOutput",
-):
-    '''Common options that allow configuration of destinations where Fluent Bit should send records after processing.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolCidrId")
+    def ipam_pool_cidr_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolCidrId"))
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+    @builtins.property
+    @jsii.member(jsii_name="ipamPoolCidrState")
+    def ipam_pool_cidr_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolCidrState"))
 
-    @jsii.member(jsii_name="cloudwatchLogs")
-    @builtins.classmethod
-    def cloudwatch_logs(
-        cls,
-        match: FluentBitMatch,
-        log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
-    ) -> "IFluentBitOutputPlugin":
-        '''Sends matched records to a CloudWatch Logs log group.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamPoolCidr).__jsii_proxy_class__ = lambda : _IIpamPoolCidrProxy
 
-        :param match: A pattern filtering to which records the output should be applied.
-        :param log_group: The log group where matched records should be sent.
 
-        :return:
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamPoolCidrConfiguration")
+class IIpamPoolCidrConfiguration(typing_extensions.Protocol):
+    @builtins.property
+    @jsii.member(jsii_name="inline")
+    def inline(self) -> builtins.bool:
+        ...
 
-        An output filter object that can be applied to the Fluent Bit
-        configuration.
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedIpamPoolCidrConfiguration":
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dab26f9f432f54b43673f47359cc7da960e6d82adb6012e75be901a3f3b3ac09)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "cloudwatchLogs", [match, log_group]))
-
-    @jsii.member(jsii_name="kinesis")
-    @builtins.classmethod
-    def kinesis(
-        cls,
-        match: FluentBitMatch,
-        stream: _aws_cdk_aws_kinesis_ceddda9d.IStream,
-    ) -> "IFluentBitOutputPlugin":
-        '''Sends matched records to a Kinesis data stream.
-
-        :param match: A pattern filtering to which records the output should be applied.
-        :param stream: The Kinesis stream where matched records should be sent.
-
-        :return:
-
-        An output filter object that can be applied to the Fluent Bit
-        configuration.
+        :param scope: -
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__16fe7d93a8820fa1d151349582f6a63b13f332f70c5c98bb436e7cf988d6b020)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument stream", value=stream, expected_type=type_hints["stream"])
-        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "kinesis", [match, stream]))
+        ...
 
-    @jsii.member(jsii_name="kinesisFirehose")
-    @builtins.classmethod
-    def kinesis_firehose(
-        cls,
-        match: FluentBitMatch,
-        delivery_stream: _IDeliveryStream_cf5feed7,
-    ) -> "IFluentBitOutputPlugin":
-        '''Sends matched records to a Kinesis Firehose delivery stream.
 
-        :param match: A pattern filtering to which records the output should be applied.
-        :param delivery_stream: The Firehose delivery stream where matched records should be sent.
+class _IIpamPoolCidrConfigurationProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamPoolCidrConfiguration"
 
-        :return:
+    @builtins.property
+    @jsii.member(jsii_name="inline")
+    def inline(self) -> builtins.bool:
+        return typing.cast(builtins.bool, jsii.get(self, "inline"))
 
-        An output filter object that can be applied to the Fluent Bit
-        configuration.
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "ResolvedIpamPoolCidrConfiguration":
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__af6295291f38a712113e95369264580c73772913ba57790d0e3eb2c79bca9eec)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
-        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "kinesisFirehose", [match, delivery_stream]))
-
-    @jsii.member(jsii_name="opensearch")
-    @builtins.classmethod
-    def opensearch(
-        cls,
-        match: FluentBitMatch,
-        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
-    ) -> "IFluentBitOutputPlugin":
-        '''Sends matched records to an OpenSearch domain.
-
-        :param match: A pattern filtering to which records the output should be applied.
-        :param domain: The OpenSearch domain where matched records should be sent.
-
-        :return:
-
-        An output filter object that can be applied to the Fluent Bit
-        configuration.
+        :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4131fc278e940c264cc3a359804bb213cef52ec4dcc6bc45de6275ff5acb3536)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
-        return typing.cast("IFluentBitOutputPlugin", jsii.sinvoke(cls, "opensearch", [match, domain]))
+            type_hints = typing.get_type_hints(_typecheckingstub__bfbb670dc272cc6a46a2eb1688ca556b350e710de16c3d30873f13a34d57b284)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast("ResolvedIpamPoolCidrConfiguration", jsii.invoke(self, "bind", [scope]))
 
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamPoolCidrConfiguration).__jsii_proxy_class__ = lambda : _IIpamPoolCidrConfigurationProxy
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitOutputPluginCommonOptions",
-    jsii_struct_bases=[],
-    name_mapping={"match": "match"},
-)
-class FluentBitOutputPluginCommonOptions:
-    def __init__(self, *, match: typing.Optional[FluentBitMatch] = None) -> None:
-        '''Configuration options that apply to all Fluent Bit output plugins.
 
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__09888332ffdc8a6865748655bd177159b31a6abfa867b1b8b5d60fdeea5c96b6)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamResourceDiscovery")
+class IIpamResourceDiscovery(_aws_cdk_ceddda9d.IResource, typing_extensions.Protocol):
+    '''Represents an IPAM resource discovery in AWS.'''
 
     @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "FluentBitOutputPluginCommonOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-class FluentBitParser(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitParser",
-):
-    '''Standard parse comfigurations which can be applied to Fluent Bit to allow for parsing data from incoming records.
-
-    The records to which parsers are applied is controlled using the parser
-    filter.
-
-    :see: {@link FluentBitParserFilter}
-    '''
+    @jsii.member(jsii_name="ipamResourceDiscoveryArn")
+    def ipam_resource_discovery_arn(self) -> builtins.str:
+        '''The resource discovery ARN.'''
+        ...
 
-    def __init__(self) -> None:
-        jsii.create(self.__class__, self, [])
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryId")
+    def ipam_resource_discovery_id(self) -> builtins.str:
+        '''The resource discovery ID.'''
+        ...
 
-    @jsii.member(jsii_name="json")
-    @builtins.classmethod
-    def json(cls, name: builtins.str) -> "IFluentBitParserPlugin":
-        '''Creates a parser that processes records that are formatted in JSON.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryIsDefault")
+    def ipam_resource_discovery_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the resource discovery is the default.
+
+        The default resource
+        discovery is the resource discovery automatically created when you create
+        an IPAM.
+        '''
+        ...
 
-        :param name: The name of the parser which will be used for referencing it in other configurations.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryOwnerId")
+    def ipam_resource_discovery_owner_id(self) -> builtins.str:
+        '''The owner ID.'''
+        ...
 
-        :return:
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryRegion")
+    def ipam_resource_discovery_region(self) -> builtins.str:
+        '''The resource discovery Region.'''
+        ...
 
-        A parser object that can be applied to the Fluent Bit
-        configuration.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryState")
+    def ipam_resource_discovery_state(self) -> builtins.str:
+        '''The resource discovery's state.
+
+        - create-in-progress - Resource discovery is being created.
+        - create-complete - Resource discovery creation is complete.
+        - create-failed - Resource discovery creation has failed.
+        - modify-in-progress - Resource discovery is being modified.
+        - modify-complete - Resource discovery modification is complete.
+        - modify-failed - Resource discovery modification has failed.
+        - delete-in-progress - Resource discovery is being deleted.
+        - delete-complete - Resource discovery deletion is complete.
+        - delete-failed - Resource discovery deletion has failed.
+        - isolate-in-progress - AWS account that created the resource discovery
+          has been removed and the resource discovery is being isolated.
+        - isolate-complete - Resource discovery isolation is complete.
+        - restore-in-progress - AWS account that created the resource discovery
+          and was isolated has been restored.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d2a5c948730ec0b02dbff24e612c1f1729a3fb4d2997fd98def1d1a317ab67ec)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "json", [name]))
-
-    @jsii.member(jsii_name="logfmt")
-    @builtins.classmethod
-    def logfmt(cls, name: builtins.str) -> "IFluentBitParserPlugin":
-        '''Creates a parser that processes records that are formatted using the ``logfmt`` standard.
+        ...
 
-        :param name: The name of the parser which will be used for referencing it in other configurations.
+    @jsii.member(jsii_name="addIpam")
+    def add_ipam(
+        self,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> IIpam:
+        '''
+        :param id: -
+        :param description: The description for the IPAM.
+        :param regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        ...
 
-        :return:
+    @jsii.member(jsii_name="associateIpam")
+    def associate_ipam(self, ipam: IIpam) -> "IIpamResourceDiscoveryAssociation":
+        '''
+        :param ipam: -
+        '''
+        ...
 
-        A parser object that can be applied to the Fluent Bit
-        configuration.
 
-        :see: `Golang logfmt documentation <https://pkg.go.dev/github.com/kr/logfmt>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d8419f19685306cef1bb083add90eeae71ca31d26fdf6ad0a5bef68d4d1ae022)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "logfmt", [name]))
+class _IIpamResourceDiscoveryProxy(
+    jsii.proxy_for(_aws_cdk_ceddda9d.IResource), # type: ignore[misc]
+):
+    '''Represents an IPAM resource discovery in AWS.'''
 
-    @jsii.member(jsii_name="ltsv")
-    @builtins.classmethod
-    def ltsv(cls, name: builtins.str) -> "IFluentBitParserPlugin":
-        '''Creates a parser that processes records that are formatted using the ``ltsv`` standard.
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamResourceDiscovery"
 
-        :param name: The name of the parser which will be used for referencing it in other configurations.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryArn")
+    def ipam_resource_discovery_arn(self) -> builtins.str:
+        '''The resource discovery ARN.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryArn"))
 
-        :return:
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryId")
+    def ipam_resource_discovery_id(self) -> builtins.str:
+        '''The resource discovery ID.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryId"))
 
-        A parser object that can be applied to the Fluent Bit
-        configuration.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryIsDefault")
+    def ipam_resource_discovery_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the resource discovery is the default.
 
-        :see: `LTSV <http://ltsv.org/>`_
+        The default resource
+        discovery is the resource discovery automatically created when you create
+        an IPAM.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3d4d3c46b533404bcbeba504ee2681b222c47d467e4716d8970b404167f926e8)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "ltsv", [name]))
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamResourceDiscoveryIsDefault"))
 
-    @jsii.member(jsii_name="regex")
-    @builtins.classmethod
-    def regex(cls, name: builtins.str, regex: builtins.str) -> "IFluentBitParserPlugin":
-        '''Creates a parser that uses regular expressions to parse incoming records.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryOwnerId")
+    def ipam_resource_discovery_owner_id(self) -> builtins.str:
+        '''The owner ID.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryOwnerId"))
 
-        :param name: The name of the parser which will be used for referencing it in other configurations.
-        :param regex: The regular expression to use to parse records.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryRegion")
+    def ipam_resource_discovery_region(self) -> builtins.str:
+        '''The resource discovery Region.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryRegion"))
 
-        :return:
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryState")
+    def ipam_resource_discovery_state(self) -> builtins.str:
+        '''The resource discovery's state.
 
-        A parser object that can be applied to the Fluent Bit
-        configuration.
+        - create-in-progress - Resource discovery is being created.
+        - create-complete - Resource discovery creation is complete.
+        - create-failed - Resource discovery creation has failed.
+        - modify-in-progress - Resource discovery is being modified.
+        - modify-complete - Resource discovery modification is complete.
+        - modify-failed - Resource discovery modification has failed.
+        - delete-in-progress - Resource discovery is being deleted.
+        - delete-complete - Resource discovery deletion is complete.
+        - delete-failed - Resource discovery deletion has failed.
+        - isolate-in-progress - AWS account that created the resource discovery
+          has been removed and the resource discovery is being isolated.
+        - isolate-complete - Resource discovery isolation is complete.
+        - restore-in-progress - AWS account that created the resource discovery
+          and was isolated has been restored.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__082be9a38cb65fcbef035dc44eb355e76f5cc06d81a262cf08cf37078bc2d04c)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-        return typing.cast("IFluentBitParserPlugin", jsii.sinvoke(cls, "regex", [name, regex]))
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryState"))
 
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitParserFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "key_name": "keyName",
-        "parsers": "parsers",
-        "preserve_key": "preserveKey",
-        "reserve_data": "reserveData",
-    },
-)
-class FluentBitParserFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @jsii.member(jsii_name="addIpam")
+    def add_ipam(
         self,
+        id: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        key_name: builtins.str,
-        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
-        preserve_key: typing.Optional[builtins.bool] = None,
-        reserve_data: typing.Optional[builtins.bool] = None,
-    ) -> None:
-        '''Options for configuring the Parser Fluent Bit filter plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param key_name: Specify field name in record to parse.
-        :param parsers: The parsers to use to interpret the field.
-        :param preserve_key: Keep original ``keyName`` field in the parsed result. If ``false``, the field will be removed. Default: false
-        :param reserve_data: Keep all other original fields in the parsed result. If ``false``, all other original fields will be removed. Default: false
-
-        :see: `Parser Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/parser>`_
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> IIpam:
+        '''
+        :param id: -
+        :param description: The description for the IPAM.
+        :param regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b68a9a8afdab443320e980cd8ef61a4610a316eed4b87369d206262bcf945336)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument key_name", value=key_name, expected_type=type_hints["key_name"])
-            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
-            check_type(argname="argument preserve_key", value=preserve_key, expected_type=type_hints["preserve_key"])
-            check_type(argname="argument reserve_data", value=reserve_data, expected_type=type_hints["reserve_data"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "key_name": key_name,
-        }
-        if match is not None:
-            self._values["match"] = match
-        if parsers is not None:
-            self._values["parsers"] = parsers
-        if preserve_key is not None:
-            self._values["preserve_key"] = preserve_key
-        if reserve_data is not None:
-            self._values["reserve_data"] = reserve_data
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def key_name(self) -> builtins.str:
-        '''Specify field name in record to parse.'''
-        result = self._values.get("key_name")
-        assert result is not None, "Required property 'key_name' is missing"
-        return typing.cast(builtins.str, result)
-
-    @builtins.property
-    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
-        '''The parsers to use to interpret the field.'''
-        result = self._values.get("parsers")
-        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
-
-    @builtins.property
-    def preserve_key(self) -> typing.Optional[builtins.bool]:
-        '''Keep original ``keyName`` field in the parsed result.
+            type_hints = typing.get_type_hints(_typecheckingstub__ce91fde6b672209b03c5936977bcee9bb0b1a59cde007a9e22596692c19cec8c)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamProps(
+            description=description,
+            regions=regions,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-        If ``false``, the field will be removed.
+        return typing.cast(IIpam, jsii.invoke(self, "addIpam", [id, options]))
 
-        :default: false
+    @jsii.member(jsii_name="associateIpam")
+    def associate_ipam(self, ipam: IIpam) -> "IIpamResourceDiscoveryAssociation":
         '''
-        result = self._values.get("preserve_key")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def reserve_data(self) -> typing.Optional[builtins.bool]:
-        '''Keep all other original fields in the parsed result.
-
-        If ``false``, all other original fields will be removed.
-
-        :default: false
+        :param ipam: -
         '''
-        result = self._values.get("reserve_data")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3afa737c1c12929060efb451b5661894860392d2a80d30e86753ead777130750)
+            check_type(argname="argument ipam", value=ipam, expected_type=type_hints["ipam"])
+        return typing.cast("IIpamResourceDiscoveryAssociation", jsii.invoke(self, "associateIpam", [ipam]))
 
-    def __repr__(self) -> str:
-        return "FluentBitParserFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamResourceDiscovery).__jsii_proxy_class__ = lambda : _IIpamResourceDiscoveryProxy
 
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitParserPluginCommonOptions",
-    jsii_struct_bases=[],
-    name_mapping={},
-)
-class FluentBitParserPluginCommonOptions:
-    def __init__(self) -> None:
-        '''Configuration options that apply to all Fluent Bit parser plugins.'''
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamResourceDiscoveryAssociation")
+class IIpamResourceDiscoveryAssociation(typing_extensions.Protocol):
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationArn")
+    def ipam_resource_discovery_association_arn(self) -> builtins.str:
+        ...
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationId")
+    def ipam_resource_discovery_association_id(self) -> builtins.str:
+        ...
 
-    def __repr__(self) -> str:
-        return "FluentBitParserPluginCommonOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamArn")
+    def ipam_resource_discovery_association_ipam_arn(self) -> builtins.str:
+        ...
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamRegion")
+    def ipam_resource_discovery_association_ipam_region(self) -> builtins.str:
+        ...
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitPluginCommonOptions",
-    jsii_struct_bases=[],
-    name_mapping={"name": "name", "plugin_type": "pluginType"},
-)
-class FluentBitPluginCommonOptions:
-    def __init__(
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIsDefault")
+    def ipam_resource_discovery_association_is_default(
         self,
-        *,
-        name: builtins.str,
-        plugin_type: "FluentBitPluginType",
-    ) -> None:
-        '''Options that are applicable to all Fluent Bit Plugins regardless of type.
+    ) -> _aws_cdk_ceddda9d.IResolvable:
+        ...
 
-        :param name: The name of the fluent bit plugin.
-        :param plugin_type: Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d3a289167b1afa2aa5ae024881a5a0f791281e90f1ad71f4febecc1378f28d92)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument plugin_type", value=plugin_type, expected_type=type_hints["plugin_type"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "name": name,
-            "plugin_type": plugin_type,
-        }
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationOwnerId")
+    def ipam_resource_discovery_association_owner_id(self) -> builtins.str:
+        ...
 
     @builtins.property
-    def name(self) -> builtins.str:
-        '''The name of the fluent bit plugin.'''
-        result = self._values.get("name")
-        assert result is not None, "Required property 'name' is missing"
-        return typing.cast(builtins.str, result)
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryId")
+    def ipam_resource_discovery_association_resource_discovery_id(self) -> builtins.str:
+        ...
 
     @builtins.property
-    def plugin_type(self) -> "FluentBitPluginType":
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.'''
-        result = self._values.get("plugin_type")
-        assert result is not None, "Required property 'plugin_type' is missing"
-        return typing.cast("FluentBitPluginType", result)
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryStatus")
+    def ipam_resource_discovery_association_resource_discovery_status(
+        self,
+    ) -> builtins.str:
+        ...
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationState")
+    def ipam_resource_discovery_association_state(self) -> builtins.str:
+        ...
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
 
-    def __repr__(self) -> str:
-        return "FluentBitPluginCommonOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+class _IIpamResourceDiscoveryAssociationProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamResourceDiscoveryAssociation"
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationArn")
+    def ipam_resource_discovery_association_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationArn"))
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.FluentBitPluginType")
-class FluentBitPluginType(enum.Enum):
-    '''The types of Fluent Bit plugins that can be configured.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationId")
+    def ipam_resource_discovery_association_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationId"))
 
-    FILTER = "FILTER"
-    '''A plugin that transforms or filters records.'''
-    OUTPUT = "OUTPUT"
-    '''A plugin that configures where output should be sent.'''
-    PARSER = "PARSER"
-    '''A plugin that read data from input objects into structured objects.'''
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamArn")
+    def ipam_resource_discovery_association_ipam_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationIpamArn"))
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamRegion")
+    def ipam_resource_discovery_association_ipam_region(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationIpamRegion"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRecordModifierFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "allow": "allow",
-        "records": "records",
-        "remove": "remove",
-    },
-)
-class FluentBitRecordModifierFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIsDefault")
+    def ipam_resource_discovery_association_is_default(
         self,
-        *,
-        match: typing.Optional[FluentBitMatch] = None,
-        allow: typing.Optional[typing.Sequence[builtins.str]] = None,
-        records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
-        remove: typing.Optional[typing.Sequence[builtins.str]] = None,
-    ) -> None:
-        '''Options for configuring the Record Modifier Fluent Bit filter plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param allow: If a tag is not match, that field is removed.
-        :param records: Add fields to the output.
-        :param remove: If a tag is match, that field is removed.
-
-        :see: `Record Modifier Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/record-modifier>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ba63858e40aa4f37f54576c8c109ce4f32cb4535c6c5d186705c639a22214428)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument allow", value=allow, expected_type=type_hints["allow"])
-            check_type(argname="argument records", value=records, expected_type=type_hints["records"])
-            check_type(argname="argument remove", value=remove, expected_type=type_hints["remove"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if allow is not None:
-            self._values["allow"] = allow
-        if records is not None:
-            self._values["records"] = records
-        if remove is not None:
-            self._values["remove"] = remove
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def allow(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''If a tag is not match, that field is removed.'''
-        result = self._values.get("allow")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+    ) -> _aws_cdk_ceddda9d.IResolvable:
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamResourceDiscoveryAssociationIsDefault"))
 
     @builtins.property
-    def records(self) -> typing.Optional[typing.List[AppendedRecord]]:
-        '''Add fields to the output.'''
-        result = self._values.get("records")
-        return typing.cast(typing.Optional[typing.List[AppendedRecord]], result)
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationOwnerId")
+    def ipam_resource_discovery_association_owner_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationOwnerId"))
 
     @builtins.property
-    def remove(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''If a tag is match, that field is removed.'''
-        result = self._values.get("remove")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryId")
+    def ipam_resource_discovery_association_resource_discovery_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationResourceDiscoveryId"))
 
-    def __repr__(self) -> str:
-        return "FluentBitRecordModifierFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRegexParserOptions",
-    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
-    name_mapping={
-        "regex": "regex",
-        "skip_empty_values": "skipEmptyValues",
-        "time_format": "timeFormat",
-        "time_key": "timeKey",
-        "types": "types",
-    },
-)
-class FluentBitRegexParserOptions(FluentBitParserPluginCommonOptions):
-    def __init__(
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryStatus")
+    def ipam_resource_discovery_association_resource_discovery_status(
         self,
-        *,
-        regex: builtins.str,
-        skip_empty_values: typing.Optional[builtins.bool] = None,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]] = None,
-    ) -> None:
-        '''Options for configuring the Regex Fluent Bit parser plugin.
+    ) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationResourceDiscoveryStatus"))
 
-        :param regex: The regular expression to use to parse the incoming records. Use regex group names to define the name of fields being captured.
-        :param skip_empty_values: If enabled, the parser ignores empty value of the record.
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationState")
+    def ipam_resource_discovery_association_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationState"))
 
-        :see: `Regex Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/regular-expression>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__62537da56305da6b0bcb7286caa362cac36f533c837efd41b4f2abc1df3bcf11)
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-            check_type(argname="argument skip_empty_values", value=skip_empty_values, expected_type=type_hints["skip_empty_values"])
-            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "regex": regex,
-        }
-        if skip_empty_values is not None:
-            self._values["skip_empty_values"] = skip_empty_values
-        if time_format is not None:
-            self._values["time_format"] = time_format
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if types is not None:
-            self._values["types"] = types
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamResourceDiscoveryAssociation).__jsii_proxy_class__ = lambda : _IIpamResourceDiscoveryAssociationProxy
 
-    @builtins.property
-    def regex(self) -> builtins.str:
-        '''The regular expression to use to parse the incoming records.
 
-        Use regex group names to define the name of fields being captured.
-        '''
-        result = self._values.get("regex")
-        assert result is not None, "Required property 'regex' is missing"
-        return typing.cast(builtins.str, result)
+@jsii.interface(jsii_type="cdk-extensions.ec2.IIpamScope")
+class IIpamScope(typing_extensions.Protocol):
+    '''Represents an IPAM scope in AWS.'''
 
     @builtins.property
-    def skip_empty_values(self) -> typing.Optional[builtins.bool]:
-        '''If enabled, the parser ignores empty value of the record.'''
-        result = self._values.get("skip_empty_values")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="ipamScopeArn")
+    def ipam_scope_arn(self) -> builtins.str:
+        '''The ARN of the scope.'''
+        ...
 
     @builtins.property
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
-
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        '''
-        result = self._values.get("time_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamScopeId")
+    def ipam_scope_id(self) -> builtins.str:
+        '''The ID of an IPAM scope.'''
+        ...
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.'''
-        result = self._values.get("time_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamScopeIpamArn")
+    def ipam_scope_ipam_arn(self) -> builtins.str:
+        '''The ARN of an IPAM.'''
+        ...
 
     @builtins.property
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
-        result = self._values.get("types")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "ParserPluginDataType"]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @jsii.member(jsii_name="ipamScopeIsDefault")
+    def ipam_scope_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the scope is the default scope or not.'''
+        ...
 
-    def __repr__(self) -> str:
-        return "FluentBitRegexParserOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopePoolCount")
+    def ipam_scope_pool_count(self) -> jsii.Number:
+        '''The number of pools in a scope.'''
+        ...
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeType")
+    def ipam_scope_type(self) -> builtins.str:
+        '''The type of the scope.'''
+        ...
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRewriteTagFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "emitter_mem_buf_limit": "emitterMemBufLimit",
-        "emitter_name": "emitterName",
-        "emitter_storage_type": "emitterStorageType",
-        "rules": "rules",
-    },
-)
-class FluentBitRewriteTagFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @jsii.member(jsii_name="addPool")
+    def add_pool(
         self,
+        id: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
-        emitter_name: typing.Optional[builtins.str] = None,
-        emitter_storage_type: typing.Optional[EmitterStorageType] = None,
-        rules: typing.Optional[typing.Sequence[typing.Union["RewriteTagRule", typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Options for configuring the Parser Fluent Bit filter plugin.
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional["IpamConsumer"] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> IIpamPool:
+        '''Adds an IPAM pool to the IPAM scope.
+
+        A pool is a collection of contiguous IP address ranges (or CIDRs). IPAM
+        pools enable you to organize your IP addresses according to your routing
+        and security needs.
+
+        :param id: A name to be associated with the pool bing added. A unique id must be used each time the method is invoked.
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
 
-        :param match: The pattern to match for records that this output should apply to.
-        :param emitter_mem_buf_limit: Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure. Default: 10M
-        :param emitter_name: When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job. Since this emitter expose metrics as any other component of the pipeline, you can use this property to configure an optional name for it.
-        :param emitter_storage_type: Define a buffering mechanism for the new records created. Note these records are part of the emitter plugin.
-        :param rules: Defines the matching criteria and the format of the Tag for the matching record.
+        :return: The pool that was added to the scope.
 
-        :see: `Parser Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/parser>`_
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__815f89c54e571d56f00edc236c155a23cfeab33faa1efebcf6c784af74f59f04)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument emitter_mem_buf_limit", value=emitter_mem_buf_limit, expected_type=type_hints["emitter_mem_buf_limit"])
-            check_type(argname="argument emitter_name", value=emitter_name, expected_type=type_hints["emitter_name"])
-            check_type(argname="argument emitter_storage_type", value=emitter_storage_type, expected_type=type_hints["emitter_storage_type"])
-            check_type(argname="argument rules", value=rules, expected_type=type_hints["rules"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if emitter_mem_buf_limit is not None:
-            self._values["emitter_mem_buf_limit"] = emitter_mem_buf_limit
-        if emitter_name is not None:
-            self._values["emitter_name"] = emitter_name
-        if emitter_storage_type is not None:
-            self._values["emitter_storage_type"] = emitter_storage_type
-        if rules is not None:
-            self._values["rules"] = rules
+        ...
 
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
 
-    @builtins.property
-    def emitter_mem_buf_limit(self) -> typing.Optional[_DataSize_d20aaece]:
-        '''Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure.
+class _IIpamScopeProxy:
+    '''Represents an IPAM scope in AWS.'''
 
-        :default: 10M
-        '''
-        result = self._values.get("emitter_mem_buf_limit")
-        return typing.cast(typing.Optional[_DataSize_d20aaece], result)
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IIpamScope"
 
     @builtins.property
-    def emitter_name(self) -> typing.Optional[builtins.str]:
-        '''When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job.
-
-        Since this emitter expose
-        metrics as any other component of the pipeline, you can use this
-        property to configure an optional name for it.
-        '''
-        result = self._values.get("emitter_name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamScopeArn")
+    def ipam_scope_arn(self) -> builtins.str:
+        '''The ARN of the scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeArn"))
 
     @builtins.property
-    def emitter_storage_type(self) -> typing.Optional[EmitterStorageType]:
-        '''Define a buffering mechanism for the new records created.
-
-        Note these records are part of the emitter plugin.
-        '''
-        result = self._values.get("emitter_storage_type")
-        return typing.cast(typing.Optional[EmitterStorageType], result)
+    @jsii.member(jsii_name="ipamScopeId")
+    def ipam_scope_id(self) -> builtins.str:
+        '''The ID of an IPAM scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeId"))
 
     @builtins.property
-    def rules(self) -> typing.Optional[typing.List["RewriteTagRule"]]:
-        '''Defines the matching criteria and the format of the Tag for the matching record.'''
-        result = self._values.get("rules")
-        return typing.cast(typing.Optional[typing.List["RewriteTagRule"]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @jsii.member(jsii_name="ipamScopeIpamArn")
+    def ipam_scope_ipam_arn(self) -> builtins.str:
+        '''The ARN of an IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeIpamArn"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeIsDefault")
+    def ipam_scope_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the scope is the default scope or not.'''
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamScopeIsDefault"))
 
-    def __repr__(self) -> str:
-        return "FluentBitRewriteTagFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopePoolCount")
+    def ipam_scope_pool_count(self) -> jsii.Number:
+        '''The number of pools in a scope.'''
+        return typing.cast(jsii.Number, jsii.get(self, "ipamScopePoolCount"))
 
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeType")
+    def ipam_scope_type(self) -> builtins.str:
+        '''The type of the scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeType"))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitThrottleFilterOptions",
-    jsii_struct_bases=[FluentBitFilterPluginCommonOptions],
-    name_mapping={
-        "match": "match",
-        "interval": "interval",
-        "print_status": "printStatus",
-        "rate": "rate",
-        "window": "window",
-    },
-)
-class FluentBitThrottleFilterOptions(FluentBitFilterPluginCommonOptions):
-    def __init__(
+    @jsii.member(jsii_name="addPool")
+    def add_pool(
         self,
+        id: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        print_status: typing.Optional[builtins.bool] = None,
-        rate: typing.Optional[jsii.Number] = None,
-        window: typing.Optional[jsii.Number] = None,
-    ) -> None:
-        '''Options for configuring the Throttle Fluent Bit filter plugin.
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional["IpamConsumer"] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> IIpamPool:
+        '''Adds an IPAM pool to the IPAM scope.
+
+        A pool is a collection of contiguous IP address ranges (or CIDRs). IPAM
+        pools enable you to organize your IP addresses according to your routing
+        and security needs.
+
+        :param id: A name to be associated with the pool bing added. A unique id must be used each time the method is invoked.
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
 
-        :param match: The pattern to match for records that this output should apply to.
-        :param interval: Time interval.
-        :param print_status: Whether to print status messages with current rate and the limits to information logs.
-        :param rate: Amount of messages for the time.
-        :param window: Amount of intervals to calculate average over. Default: 5
+        :return: The pool that was added to the scope.
 
-        :see: `Throttle Plugin Documention <https://docs.fluentbit.io/manual/pipeline/filters/throttle>`_
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a026237a3f40e00499d4fc0204f075b1145cde7bac0b7942bed2173ce310bd9a)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument interval", value=interval, expected_type=type_hints["interval"])
-            check_type(argname="argument print_status", value=print_status, expected_type=type_hints["print_status"])
-            check_type(argname="argument rate", value=rate, expected_type=type_hints["rate"])
-            check_type(argname="argument window", value=window, expected_type=type_hints["window"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if interval is not None:
-            self._values["interval"] = interval
-        if print_status is not None:
-            self._values["print_status"] = print_status
-        if rate is not None:
-            self._values["rate"] = rate
-        if window is not None:
-            self._values["window"] = window
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def interval(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''Time interval.'''
-        result = self._values.get("interval")
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)
-
-    @builtins.property
-    def print_status(self) -> typing.Optional[builtins.bool]:
-        '''Whether to print status messages with current rate and the limits to information logs.'''
-        result = self._values.get("print_status")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def rate(self) -> typing.Optional[jsii.Number]:
-        '''Amount of messages for the time.'''
-        result = self._values.get("rate")
-        return typing.cast(typing.Optional[jsii.Number], result)
+            type_hints = typing.get_type_hints(_typecheckingstub__3a86136ad382579c871429e414991bd17165494c17b0539dc436d1f271594b37)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamPoolOptions(
+            address_configuration=address_configuration,
+            auto_import=auto_import,
+            consumer=consumer,
+            description=description,
+            locale=locale,
+            name=name,
+            parent_pool=parent_pool,
+            provisioned_cidrs=provisioned_cidrs,
+            public_ip_source=public_ip_source,
+            tag_restrictions=tag_restrictions,
+        )
 
-    @builtins.property
-    def window(self) -> typing.Optional[jsii.Number]:
-        '''Amount of intervals to calculate average over.
+        return typing.cast(IIpamPool, jsii.invoke(self, "addPool", [id, options]))
 
-        :default: 5
-        '''
-        result = self._values.get("window")
-        return typing.cast(typing.Optional[jsii.Number], result)
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, IIpamScope).__jsii_proxy_class__ = lambda : _IIpamScopeProxy
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+@jsii.interface(jsii_type="cdk-extensions.ec2.ILocalVpnEndpoint")
+class ILocalVpnEndpoint(typing_extensions.Protocol):
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> "LocalVpnEndpointConfiguration":
+        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
 
-    def __repr__(self) -> str:
-        return "FluentBitThrottleFilterOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        :param scope: The construct configuring the VPN connection that will be referencing the local endpoint.
+        '''
+        ...
 
 
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IExternalDnsRegistry")
-class IExternalDnsRegistry(typing_extensions.Protocol):
-    @builtins.property
-    @jsii.member(jsii_name="registryType")
-    def registry_type(self) -> builtins.str:
-        ...
+class _ILocalVpnEndpointProxy:
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ILocalVpnEndpoint"
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ExternalDnsRegistryConfiguration:
+    ) -> "LocalVpnEndpointConfiguration":
+        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+
+        :param scope: The construct configuring the VPN connection that will be referencing the local endpoint.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5f7fbf7fd0e305a60cc72790e4c2e467542eeb749b6ca114948036c7e283f4e3)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast("LocalVpnEndpointConfiguration", jsii.invoke(self, "bind", [scope]))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ILocalVpnEndpoint).__jsii_proxy_class__ = lambda : _ILocalVpnEndpointProxy
+
+
+@jsii.interface(jsii_type="cdk-extensions.ec2.ILogDestination")
+class ILogDestination(typing_extensions.Protocol):
+    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
+
+    @jsii.member(jsii_name="bind")
+    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
         '''
         :param scope: -
         '''
         ...
 
 
-class _IExternalDnsRegistryProxy:
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IExternalDnsRegistry"
+class _ILogDestinationProxy:
+    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="registryType")
-    def registry_type(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "registryType"))
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ILogDestination"
 
     @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ExternalDnsRegistryConfiguration:
+    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
         '''
         :param scope: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__16439430780263e49cc504798dfdedbab3bf51542be52890ad92373b0d4bfc91)
+            type_hints = typing.get_type_hints(_typecheckingstub__31e7dac1ec2cefa56a83155a4b3ff82206bfe5b1607d5af572c5d16cf98aba7a)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
+        return typing.cast(FlowLogDestinationConfig, jsii.invoke(self, "bind", [scope]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IExternalDnsRegistry).__jsii_proxy_class__ = lambda : _IExternalDnsRegistryProxy
-
+typing.cast(typing.Any, ILogDestination).__jsii_proxy_class__ = lambda : _ILogDestinationProxy
 
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitPlugin")
-class IFluentBitPlugin(typing_extensions.Protocol):
-    '''Represents a Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the fluent bit plugin.'''
-        ...
-
-    @builtins.property
-    @jsii.member(jsii_name="pluginType")
-    def plugin_type(self) -> builtins.str:
-        '''The type of fluent bit plugin.'''
-        ...
+@jsii.interface(jsii_type="cdk-extensions.ec2.IRemoteVpnEndpoint")
+class IRemoteVpnEndpoint(typing_extensions.Protocol):
+    '''An object that can be used to retrieve the details for the remote end of a VPN connection.'''
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "ResolvedFluentBitConfiguration":
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    ) -> "RemoteVpnEndpointConfiguration":
+        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
 
-        :param scope: -
+        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
         '''
         ...
 
 
-class _IFluentBitPluginProxy:
-    '''Represents a Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitPlugin"
-
-    @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the fluent bit plugin.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+class _IRemoteVpnEndpointProxy:
+    '''An object that can be used to retrieve the details for the remote end of a VPN connection.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="pluginType")
-    def plugin_type(self) -> builtins.str:
-        '''The type of fluent bit plugin.'''
-        return typing.cast(builtins.str, jsii.get(self, "pluginType"))
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.IRemoteVpnEndpoint"
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "ResolvedFluentBitConfiguration":
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    ) -> "RemoteVpnEndpointConfiguration":
+        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
 
-        :param scope: -
+        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0e96056912a504aeb9a5f0a9afa10c098c92a82a5580780a4d2bf3539c8205aa)
+            type_hints = typing.get_type_hints(_typecheckingstub__f1c8cc16017de426ad6eb532d21e5db4c058f7a279485763c47026f54ff6b02a)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast("ResolvedFluentBitConfiguration", jsii.invoke(self, "bind", [scope]))
+        return typing.cast("RemoteVpnEndpointConfiguration", jsii.invoke(self, "bind", [scope]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IFluentBitPlugin).__jsii_proxy_class__ = lambda : _IFluentBitPluginProxy
+typing.cast(typing.Any, IRemoteVpnEndpoint).__jsii_proxy_class__ = lambda : _IRemoteVpnEndpointProxy
 
 
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.INestFilterOperation")
-class INestFilterOperation(typing_extensions.Protocol):
-    '''Represents an operation with excludive options that can be performed by the Fluent Bit Nest filter plugin.'''
+@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGateway")
+class ITransitGateway(_constructs_77d1e7e8.IConstruct, typing_extensions.Protocol):
+    '''Represents a transit gateway in AWS.'''
 
     @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
+    @jsii.member(jsii_name="transitGatewayArn")
+    def transit_gateway_arn(self) -> builtins.str:
         ...
 
     @builtins.property
-    @jsii.member(jsii_name="operation")
-    def operation(self) -> "NestFilterOperationType":
+    @jsii.member(jsii_name="transitGatewayId")
+    def transit_gateway_id(self) -> builtins.str:
         ...
 
+    @jsii.member(jsii_name="addRouteTable")
+    def add_route_table(
+        self,
+        *,
+        name: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayRouteTable":
+        '''
+        :param name: 
+        '''
+        ...
 
-class _INestFilterOperationProxy:
-    '''Represents an operation with excludive options that can be performed by the Fluent Bit Nest filter plugin.'''
+    @jsii.member(jsii_name="addVpn")
+    def add_vpn(
+        self,
+        id: builtins.str,
+        *,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> "VpnConnection":
+        '''
+        :param id: -
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
+        '''
+        ...
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.INestFilterOperation"
+    @jsii.member(jsii_name="attachVpc")
+    def attach_vpc(
+        self,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        *,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> "TransitGatewayAttachment":
+        '''
+        :param vpc: -
+        :param name: 
+        :param subnets: 
+        '''
+        ...
 
-    @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
-        return typing.cast(typing.Mapping[builtins.str, typing.List[builtins.str]], jsii.get(self, "fields"))
 
-    @builtins.property
-    @jsii.member(jsii_name="operation")
-    def operation(self) -> "NestFilterOperationType":
-        return typing.cast("NestFilterOperationType", jsii.get(self, "operation"))
+class _ITransitGatewayProxy(
+    jsii.proxy_for(_constructs_77d1e7e8.IConstruct), # type: ignore[misc]
+):
+    '''Represents a transit gateway in AWS.'''
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, INestFilterOperation).__jsii_proxy_class__ = lambda : _INestFilterOperationProxy
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGateway"
 
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayArn")
+    def transit_gateway_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayArn"))
 
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretReference")
-class ISecretReference(typing_extensions.Protocol):
-    '''Represents a resource the can be synchronized into a Kubernetes secret.'''
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayId")
+    def transit_gateway_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+    @jsii.member(jsii_name="addRouteTable")
+    def add_route_table(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "SecretReferenceConfiguration":
-        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.
-
-        :param scope: The scope of the construct that will be configuring the synchronization configuration.
+        *,
+        name: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayRouteTable":
         '''
-        ...
+        :param name: 
+        '''
+        options = TransitGatewayRouteTableOptions(name=name)
 
+        return typing.cast("TransitGatewayRouteTable", jsii.invoke(self, "addRouteTable", [options]))
 
-class _ISecretReferenceProxy:
-    '''Represents a resource the can be synchronized into a Kubernetes secret.'''
+    @jsii.member(jsii_name="addVpn")
+    def add_vpn(
+        self,
+        id: builtins.str,
+        *,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> "VpnConnection":
+        '''
+        :param id: -
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3c530d4e033cb58d409cbdec91a29a99e796c6b5949a8fe0b776e9a57ebda677)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = VpnAttachmentOptions(
+            remote_endpoint=remote_endpoint,
+            connection_type=connection_type,
+            static_routes_only=static_routes_only,
+            tunnel_configurations=tunnel_configurations,
+        )
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretReference"
+        return typing.cast("VpnConnection", jsii.invoke(self, "addVpn", [id, options]))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+    @jsii.member(jsii_name="attachVpc")
+    def attach_vpc(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> "SecretReferenceConfiguration":
-        '''Gets the configuration details for the resource being sychronized in a form that can be universally used to create the synchronization configuration.
-
-        :param scope: The scope of the construct that will be configuring the synchronization configuration.
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        *,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> "TransitGatewayAttachment":
+        '''
+        :param vpc: -
+        :param name: 
+        :param subnets: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__acebfc903b3b22f8c30fae481f53b07f40398b43583763b7493f53134e21c720)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast("SecretReferenceConfiguration", jsii.invoke(self, "bind", [scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__7e51602274287d74df7ba0b1c9462a003ef4081742f553f9fccc7d78f9e0f591)
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+        options = VpcAttachmentOptions(name=name, subnets=subnets)
+
+        return typing.cast("TransitGatewayAttachment", jsii.invoke(self, "attachVpc", [vpc, options]))
 
 # Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ISecretReference).__jsii_proxy_class__ = lambda : _ISecretReferenceProxy
+typing.cast(typing.Any, ITransitGateway).__jsii_proxy_class__ = lambda : _ITransitGatewayProxy
 
 
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.ISecretStore")
-class ISecretStore(_constructs_77d1e7e8.IDependable, typing_extensions.Protocol):
-    '''Represents a Kubernetes secret store resource.'''
+@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayAttachment")
+class ITransitGatewayAttachment(typing_extensions.Protocol):
+    '''Represents a Transit Gateway Attachment in AWS.'''
 
     @builtins.property
-    @jsii.member(jsii_name="secretStoreName")
-    def secret_store_name(self) -> builtins.str:
-        '''The name of the secret store as it appears in Kubernetes.'''
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of the transit gateway attachment.'''
         ...
 
-
-class _ISecretStoreProxy(
-    jsii.proxy_for(_constructs_77d1e7e8.IDependable), # type: ignore[misc]
-):
-    '''Represents a Kubernetes secret store resource.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.ISecretStore"
-
     @builtins.property
-    @jsii.member(jsii_name="secretStoreName")
-    def secret_store_name(self) -> builtins.str:
-        '''The name of the secret store as it appears in Kubernetes.'''
-        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of the transit gateway attachment.'''
+        ...
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, ISecretStore).__jsii_proxy_class__ = lambda : _ISecretStoreProxy
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
+        self,
+        cidr: builtins.str,
+        route_table: "ITransitGatewayRouteTable",
+    ) -> "ITransitGatewayRoute":
+        '''Adds a route that directs traffic to this transit gateway attachment.
 
+        :param cidr: CIDR range that should be routed to this attachment.
+        :param route_table: The transit gateway route table where the route should be added.
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.KinesisFirehoseCompressionFormat")
-class KinesisFirehoseCompressionFormat(enum.Enum):
-    ARROW = "ARROW"
-    '''The Apache Arrow compression format.
+        :return: The TransitGatewayRoute that was added.
+        '''
+        ...
 
-    Only available if the Fluent Fit service being used to send logs to
-    Firehose had Apache Arrow enabled at compile time.
-    '''
-    GZIP = "GZIP"
-    '''Gzip compression format.'''
 
+class _ITransitGatewayAttachmentProxy:
+    '''Represents a Transit Gateway Attachment in AWS.'''
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.LiftOptions",
-    jsii_struct_bases=[],
-    name_mapping={"nested_under": "nestedUnder"},
-)
-class LiftOptions:
-    def __init__(self, *, nested_under: builtins.str) -> None:
-        '''
-        :param nested_under: Lift records nested under the this key.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b5737e6839ba050eaf2ff95b5004c79062ffa98eab8e21826190de020d396648)
-            check_type(argname="argument nested_under", value=nested_under, expected_type=type_hints["nested_under"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "nested_under": nested_under,
-        }
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayAttachment"
 
     @builtins.property
-    def nested_under(self) -> builtins.str:
-        '''Lift records nested under the this key.'''
-        result = self._values.get("nested_under")
-        assert result is not None, "Required property 'nested_under' is missing"
-        return typing.cast(builtins.str, result)
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of the transit gateway attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of the transit gateway attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
 
-    def __repr__(self) -> str:
-        return "LiftOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
+        self,
+        cidr: builtins.str,
+        route_table: "ITransitGatewayRouteTable",
+    ) -> "ITransitGatewayRoute":
+        '''Adds a route that directs traffic to this transit gateway attachment.
 
+        :param cidr: CIDR range that should be routed to this attachment.
+        :param route_table: The transit gateway route table where the route should be added.
 
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.MetadataPolicy")
-class MetadataPolicy(enum.Enum):
-    '''Options for fetching tags/labels from provider secrets.'''
+        :return: The TransitGatewayRoute that was added.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7b44f941842017d2d4c6c21860f08701108fc8a70636475b6b9ab6eb37332692)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
+        return typing.cast("ITransitGatewayRoute", jsii.invoke(self, "addRoute", [cidr, route_table]))
 
-    FETCH = "FETCH"
-    '''Fetch tags/labels from provider secrets.'''
-    NONE = "NONE"
-    '''Do not fetch tags/labels from provider secrets.'''
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITransitGatewayAttachment).__jsii_proxy_class__ = lambda : _ITransitGatewayAttachmentProxy
 
 
-class ModifyCondition(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ModifyCondition",
+@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayPeeringAttachment")
+class ITransitGatewayPeeringAttachment(
+    ITransitGatewayAttachment,
+    typing_extensions.Protocol,
 ):
-    @jsii.member(jsii_name="aKeyMatches")
-    @builtins.classmethod
-    def a_key_matches(cls, regex: builtins.str) -> "ModifyCondition":
-        '''Condition that returns true if any key matches a specified regular expression.
+    '''Represents a transit gateway route table in AWS.'''
 
-        :param regex: The regular expression to evaluate against field keys.
-
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a87c7279b95393fe143c70bd0eb03afa5a2eeadbb4e0652815e47bad81d78004)
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "aKeyMatches", [regex]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
+    def transit_gateway_attachment_creation_time(self) -> builtins.str:
+        '''The time the transit gateway peering attachment was created.'''
+        ...
 
-    @jsii.member(jsii_name="keyDoesNotExists")
-    @builtins.classmethod
-    def key_does_not_exists(cls, key: builtins.str) -> "ModifyCondition":
-        '''Condition that returns true if a specified key does not exist.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentState")
+    def transit_gateway_attachment_state(self) -> builtins.str:
+        '''The state of the transit gateway peering attachment.'''
+        ...
 
-        :param key: The key to check for existence.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
+    def transit_gateway_attachment_status(self) -> builtins.str:
+        '''The status of the transit gateway peering attachment.'''
+        ...
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9c016d68c98f4a007d811c010a657245a7cb4e35e28d68271b47271fb2e7fe04)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyDoesNotExists", [key]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
+    def transit_gateway_attachment_status_code(self) -> builtins.str:
+        '''The status code for the current status of the attachment.'''
+        ...
 
-    @jsii.member(jsii_name="keyExists")
-    @builtins.classmethod
-    def key_exists(cls, key: builtins.str) -> "ModifyCondition":
-        '''Condition that returns true if a specified key exists.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
+    def transit_gateway_attachment_status_message(self) -> builtins.str:
+        '''The status message for the current status of the attachment.'''
+        ...
 
-        :param key: The key to check for existence.
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__26a4516fb03cee3ff4649a09c795cfa145f69ca27b37c8efd99e5b120be43804)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyExists", [key]))
+class _ITransitGatewayPeeringAttachmentProxy(
+    jsii.proxy_for(ITransitGatewayAttachment), # type: ignore[misc]
+):
+    '''Represents a transit gateway route table in AWS.'''
 
-    @jsii.member(jsii_name="keyValueDoesNotEqual")
-    @builtins.classmethod
-    def key_value_does_not_equal(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if a specified key exists and its value does not match the specified value.
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayPeeringAttachment"
 
-        :param key: The key to check for existence.
-        :param value: The value to check for the given key.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
+    def transit_gateway_attachment_creation_time(self) -> builtins.str:
+        '''The time the transit gateway peering attachment was created.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentCreationTime"))
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__fbd75e354fc9a0d46f639f296e1b4ffe3da299a7891b0381081ad9cc7bdf6631)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueDoesNotEqual", [key, value]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentState")
+    def transit_gateway_attachment_state(self) -> builtins.str:
+        '''The state of the transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentState"))
 
-    @jsii.member(jsii_name="keyValueDoesNotMatch")
-    @builtins.classmethod
-    def key_value_does_not_match(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if a specified key exists and its value does not match the specified regular expression.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
+    def transit_gateway_attachment_status(self) -> builtins.str:
+        '''The status of the transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatus"))
 
-        :param key: The key to check for existence.
-        :param value: The regular expression to check for the given key.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
+    def transit_gateway_attachment_status_code(self) -> builtins.str:
+        '''The status code for the current status of the attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusCode"))
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3c04874c06d71c34c233c16eca0c4b65f1a6a36f0bb05dfd69dfa0da05ffbec4)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueDoesNotMatch", [key, value]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
+    def transit_gateway_attachment_status_message(self) -> builtins.str:
+        '''The status message for the current status of the attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusMessage"))
 
-    @jsii.member(jsii_name="keyValueEquals")
-    @builtins.classmethod
-    def key_value_equals(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if a specified key exists and its value matches the specified value.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITransitGatewayPeeringAttachment).__jsii_proxy_class__ = lambda : _ITransitGatewayPeeringAttachmentProxy
 
-        :param key: The key to check for existence.
-        :param value: The value to match for the given key.
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__ff4b63c6ad876a769c352fa5b53d1ab44a9e4a503ccd829e1029918eb28ef3bd)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueEquals", [key, value]))
+@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayRoute")
+class ITransitGatewayRoute(typing_extensions.Protocol):
+    '''Represents a Transit Gateway Route in AWS.'''
 
-    @jsii.member(jsii_name="keyValueMatches")
-    @builtins.classmethod
-    def key_value_matches(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if a specified key exists and its value matches the specified regular expression.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteId")
+    def transit_gateway_route_id(self) -> builtins.str:
+        '''The ID of the Transit Gateway Route.'''
+        ...
 
-        :param key: The key to check for existence.
-        :param value: The regular expression to match for the given key.
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__59be3f65de5a631f24700f05f7753e529ad70a4cb137fd5d62383abdd02bf10d)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "keyValueMatches", [key, value]))
+class _ITransitGatewayRouteProxy:
+    '''Represents a Transit Gateway Route in AWS.'''
 
-    @jsii.member(jsii_name="matchingKeysDoNotHaveMatchingValues")
-    @builtins.classmethod
-    def matching_keys_do_not_have_matching_values(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if all keys matching a specified regular expression have values that do not match another regular expression.
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayRoute"
 
-        :param key: The regular expression to use to filter keys.
-        :param value: The regular expression to check the value of fields.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteId")
+    def transit_gateway_route_id(self) -> builtins.str:
+        '''The ID of the Transit Gateway Route.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteId"))
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b9f14e749593d361f880d1301a695fbd3315adff4d215a08b2867f766b530f6f)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "matchingKeysDoNotHaveMatchingValues", [key, value]))
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITransitGatewayRoute).__jsii_proxy_class__ = lambda : _ITransitGatewayRouteProxy
 
-    @jsii.member(jsii_name="matchingKeysHaveMatchingValues")
-    @builtins.classmethod
-    def matching_keys_have_matching_values(
-        cls,
-        key: builtins.str,
-        value: builtins.str,
-    ) -> "ModifyCondition":
-        '''Condition that returns true if all keys matching a specified regular expression have values that match another regular expression.
 
-        :param key: The regular expression to use to filter keys.
-        :param value: The regular expression to check the value of fields.
+@jsii.interface(jsii_type="cdk-extensions.ec2.ITransitGatewayRouteTable")
+class ITransitGatewayRouteTable(typing_extensions.Protocol):
+    '''Represents a transit gateway route table in AWS.'''
 
-        :return: A ModifyCondition object representing the condition.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__3644ef417d81a715203823624e932831fa6fab3e38086a6ff12bb88a577c0d05)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "matchingKeysHaveMatchingValues", [key, value]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteTableArn")
+    def transit_gateway_route_table_arn(self) -> builtins.str:
+        '''The ARN of the transit gateway route table.'''
+        ...
 
-    @jsii.member(jsii_name="noKeyMatches")
-    @builtins.classmethod
-    def no_key_matches(cls, regex: builtins.str) -> "ModifyCondition":
-        '''Condition that returns true if no key matches a specified regular expression.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteTableId")
+    def transit_gateway_route_table_id(self) -> builtins.str:
+        '''The ID of the transit gateway route table.'''
+        ...
 
-        :param regex: The regular expression to evaluate against field keys.
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
+        self,
+        *,
+        cidr: builtins.str,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayRoute":
+        '''Adds a route to this transit gateway route table.
 
-        :return: A ModifyCondition object representing the condition.
+        :param cidr: The CIDR range to match for the route.
+        :param attachment: The transit gateway attachment where matched traffic should be routed.
+        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__786ab8e1494a413b4e18469e55a12839dde421149e6acea64e8a335582aa46f5)
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "noKeyMatches", [regex]))
+        ...
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(
-        cls,
-        condition: builtins.str,
-        args: typing.Sequence[builtins.str],
-    ) -> "ModifyCondition":
-        '''An escape hatch method that allows fo defining custom conditions to be evaluated by the modify Fluent Bit filter plugin.
 
-        :param condition: The name of the condition to be evaluated.
-        :param args: The arguments to the operation.
+class _ITransitGatewayRouteTableProxy:
+    '''Represents a transit gateway route table in AWS.'''
 
-        :return: A ModifyCondition object representing the options provided.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c6cda0ccdf12bd0d94a391aeee20b8afc334828d46c7557423da8fddc68c8a5b)
-            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
-            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
-        return typing.cast("ModifyCondition", jsii.sinvoke(cls, "of", [condition, args]))
+    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.ec2.ITransitGatewayRouteTable"
 
-    @jsii.member(jsii_name="toString")
-    def to_string(self) -> builtins.str:
-        '''Gets a string representation of the arguments of this condition for use in a Fluent Bit plugin field.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteTableArn")
+    def transit_gateway_route_table_arn(self) -> builtins.str:
+        '''The ARN of the transit gateway route table.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteTableId")
+    def transit_gateway_route_table_id(self) -> builtins.str:
+        '''The ID of the transit gateway route table.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))
 
-        :return: A fluent bit value string.
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
+        self,
+        *,
+        cidr: builtins.str,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayRoute":
+        '''Adds a route to this transit gateway route table.
+
+        :param cidr: The CIDR range to match for the route.
+        :param attachment: The transit gateway attachment where matched traffic should be routed.
+        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
+        options = TransitGatewayRouteOptions(
+            cidr=cidr,
+            attachment=attachment,
+            blackhole=blackhole,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="args")
-    def args(self) -> typing.List[builtins.str]:
-        '''Collection of arguments that apply to the condition.'''
-        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))
+        return typing.cast("TransitGatewayRoute", jsii.invoke(self, "addRoute", [options]))
 
-    @builtins.property
-    @jsii.member(jsii_name="condition")
-    def condition(self) -> builtins.str:
-        '''The name of the condition being evaluated.'''
-        return typing.cast(builtins.str, jsii.get(self, "condition"))
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
+typing.cast(typing.Any, ITransitGatewayRouteTable).__jsii_proxy_class__ = lambda : _ITransitGatewayRouteTableProxy
 
 
-class ModifyOperation(
+@jsii.implements(IIpam)
+class Ipam(
+    _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ModifyOperation",
+    jsii_type="cdk-extensions.ec2.Ipam",
 ):
-    @jsii.member(jsii_name="add")
-    @builtins.classmethod
-    def add(cls, key: builtins.str, value: builtins.str) -> "ModifyOperation":
-        '''Sets a field in the output to a specific value.
+    '''Represents an AWS IP Address Manager.
 
-        If a field with the same name already exists it will be kept as is.
+    IPAM is a VPC feature that you can use to automate your IP address
+    management workflows including assigning, tracking, troubleshooting, and
+    auditing IP addresses across AWS Regions and accounts throughout your AWS
+    Organization.
 
-        :param key: The key name of the field to set.
-        :param value: The value to set for the specified field.
+    :see: `AWS::EC2::IPAM <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html>`_
+    '''
 
-        :return: A ModifyOperation object representing the add operation.
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the Ipam class.
+
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param description: The description for the IPAM.
+        :param regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__88d1f6674bbdb9c882a91bf4bd456ed2e3b77d8ede0eda0335a9711e90ef10d8)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "add", [key, value]))
+            type_hints = typing.get_type_hints(_typecheckingstub__6bcaae469a83ecd464cf6ee2fdec64932121a1d626847b4286e9b571c2738345)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpamProps(
+            description=description,
+            regions=regions,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @jsii.member(jsii_name="copy")
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="fromIpamArn")
     @builtins.classmethod
-    def copy(
+    def from_ipam_arn(
         cls,
-        original_key: builtins.str,
-        new_key: builtins.str,
-    ) -> "ModifyOperation":
-        '''Copies a field from the input to a field with a new name if the field exists and a field with the new name does not exist.
-
-        If a field with the new name already exists it is overwritten.
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        ipam_arn: builtins.str,
+    ) -> IIpam:
+        '''Imports an existing IPAM by specifying its Amazon Resource Name (ARN).
 
-        :param original_key: The key in the input to be copied.
-        :param new_key: The new name of the field to be copied to.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_arn: The ARN of the existing IPAM to be imported.
 
-        :return: A ModifyOperation object representing the copy operation.
+        :return: An object representing the imported IPAM.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__509195f56adc1008582dfdd1ced4b6aae5a09a204f9b120954616dbe9255a6a5)
-            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
-            check_type(argname="argument new_key", value=new_key, expected_type=type_hints["new_key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "copy", [original_key, new_key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__f22237c1da869dfd24c6b3bd9591ee8f4bb8b24ac263036e6bad87d6f59f290f)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_arn", value=ipam_arn, expected_type=type_hints["ipam_arn"])
+        return typing.cast(IIpam, jsii.sinvoke(cls, "fromIpamArn", [scope, id, ipam_arn]))
 
-    @jsii.member(jsii_name="hardCopy")
+    @jsii.member(jsii_name="fromIpamAttributes")
     @builtins.classmethod
-    def hard_copy(
+    def from_ipam_attributes(
         cls,
-        original_key: builtins.str,
-        new_key: builtins.str,
-    ) -> "ModifyOperation":
-        '''Copies a field from the input to a field with a new name if the field exists and a field with the new name does not exist.
-
-        :param original_key: The key in the input to be copied.
-        :param new_key: The new name of the field to be copied to.
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        ipam_arn: typing.Optional[builtins.str] = None,
+        ipam_id: typing.Optional[builtins.str] = None,
+        private_default_scope: typing.Optional[IIpamScope] = None,
+        public_default_scope: typing.Optional[IIpamScope] = None,
+        scope_count: typing.Optional[jsii.Number] = None,
+    ) -> IIpam:
+        '''Imports an existing IAPM by explicitly specifying its attributes.
+
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_arn: The Amazon Resource Name (ARN) of the IPAM.
+        :param ipam_id: The ID generated by AWS for the IPAM.
+        :param private_default_scope: The IPAM's default private scope.
+        :param public_default_scope: The IPAM's default public scope.
+        :param scope_count: The number of scopes in the IPAM.
 
-        :return: A ModifyOperation object representing the copy operation.
+        :return: An object representing the imported IPAM.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4252ab4af15f45596deb41aecff5cdf63193455fcfb6a11f50e531ae913ddc19)
-            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
-            check_type(argname="argument new_key", value=new_key, expected_type=type_hints["new_key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "hardCopy", [original_key, new_key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__eb571f1f21cbfaf021fd1248ccdd35a0949e39d2400dcec2e3fe7eaac35304d4)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        attrs = IpamAttributes(
+            ipam_arn=ipam_arn,
+            ipam_id=ipam_id,
+            private_default_scope=private_default_scope,
+            public_default_scope=public_default_scope,
+            scope_count=scope_count,
+        )
+
+        return typing.cast(IIpam, jsii.sinvoke(cls, "fromIpamAttributes", [scope, id, attrs]))
 
-    @jsii.member(jsii_name="hardRename")
+    @jsii.member(jsii_name="fromIpamId")
     @builtins.classmethod
-    def hard_rename(
+    def from_ipam_id(
         cls,
-        original_key: builtins.str,
-        renamed_key: builtins.str,
-    ) -> "ModifyOperation":
-        '''Renames a field from the input if the field exists.
-
-        If a field with the desired name already exists it is overwritten.
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        ipam_id: builtins.str,
+    ) -> IIpam:
+        '''Imports an existing IPAM by explicitly specifying its AWS generated ID.
 
-        :param original_key: The key in the input to be renamed.
-        :param renamed_key: The new name of the key in the output.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_id: The AWS generated ID of the existing IPAM to be imported.
 
-        :return: A ModifyOperation object representing the rename operation.
+        :return: An object representing the imported IPAM.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d143c72f0b1248ef3c465526d5a4bec246e11ddc44d1e7ffb9cd998bfd89a980)
-            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
-            check_type(argname="argument renamed_key", value=renamed_key, expected_type=type_hints["renamed_key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "hardRename", [original_key, renamed_key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__5f7d3d1a0e00906b5868c50d6ef8fecef67fbe25667614fcde04f846719061e3)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_id", value=ipam_id, expected_type=type_hints["ipam_id"])
+        return typing.cast(IIpam, jsii.sinvoke(cls, "fromIpamId", [scope, id, ipam_id]))
 
-    @jsii.member(jsii_name="moveToEnd")
-    @builtins.classmethod
-    def move_to_end(cls, key: builtins.str) -> "ModifyOperation":
-        '''Moves fiels matching the given wildcard key to the end of the message.
+    @jsii.member(jsii_name="addRegion")
+    def add_region(self, region: builtins.str) -> None:
+        '''Adds an operating region to the IPAM.
 
-        :param key: The wildcard to to match.
+        The operating Regions for an IPAM. Operating Regions are AWS Regions where
+        the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and
+        monitors resources in the AWS Regions you select as operating Regions.
 
-        :return: A ModifyOperation object representing the move operation.
+        :param region: The region to add to the IPAM.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__58f39ecf984b31b6d9c63ea24ccc57cdf4154eb2c667a5e4b98bf4f0117cbe7f)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "moveToEnd", [key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__b41f4e5b2750bf68e1fe11144249a54f1b8abc0145d51b5c5a5e6306100fb06e)
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+        return typing.cast(None, jsii.invoke(self, "addRegion", [region]))
 
-    @jsii.member(jsii_name="moveToStart")
-    @builtins.classmethod
-    def move_to_start(cls, key: builtins.str) -> "ModifyOperation":
-        '''Moves fiels matching the given wildcard key to the start of the message.
+    @jsii.member(jsii_name="addScope")
+    def add_scope(
+        self,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+    ) -> IIpamScope:
+        '''Adds an IPAM scope to the IPAM.
+
+        In IPAM, a scope is the highest-level container within IPAM. Scopes enable
+        you to reuse IP addresses across multiple unconnected networks without
+        causing IP address overlap or conflict.
 
-        :param key: The wildcard to to match.
+        :param id: A name to be associated to the scope being added. A unique id must be used each time this method is invoked.
+        :param description: The description of the scope.
 
-        :return: A ModifyOperation object representing the move operation.
+        :return: The scope that was added to the IPAM.
+
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__21dd6a80198a6efcdd40eb3aafec20cfecfde8f707999ac8ded417642e87f43f)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "moveToStart", [key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__102b40df4c003fe21fa6f5c3eccca856cd54d3476ddd3fef7d50ecdb6f08218e)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamScopeOptions(description=description)
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(
-        cls,
-        operation: builtins.str,
-        args: typing.Sequence[builtins.str],
-    ) -> "ModifyOperation":
-        '''An escape hatch method that allows fo defining custom operations to be performed by the modify Fluent Bit filter plugin.
+        return typing.cast(IIpamScope, jsii.invoke(self, "addScope", [id, options]))
 
-        :param operation: The name of the operation to be performed.
-        :param args: The arguments to the operation.
+    @jsii.member(jsii_name="associateResourceDiscovery")
+    def associate_resource_discovery(
+        self,
+        resource_discovery: IIpamResourceDiscovery,
+    ) -> IIpamResourceDiscoveryAssociation:
+        '''Associates an existing IPAM resource discovery with the IPAM.
 
-        :return: A ModifyOperation object representing the options provided.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2d24729666ca872450b6aefe87e852b867ecabcb6e378292249754f4c529a432)
-            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
-            check_type(argname="argument args", value=args, expected_type=type_hints["args"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "of", [operation, args]))
+        IPAM aggregates the resource CIDRs discovered by the associated resource
+        discovery.
 
-    @jsii.member(jsii_name="remove")
-    @builtins.classmethod
-    def remove(cls, key: builtins.str) -> "ModifyOperation":
-        '''Removes a field in the output with a specific key.
+        :param resource_discovery: The IPAM resource discovery to associate with the IPAM.
 
-        :param key: The key name of the field to remove.
+        :return:
 
-        :return: A ModifyOperation object representing the remove operation.
+        The association resource that handles the association between the
+        IPAM and the resource discovery.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d0548969ac288015caf3702a3018bc6e8a9967a958e5278991beb6b8382f6fc8)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "remove", [key]))
+            type_hints = typing.get_type_hints(_typecheckingstub__072bf43c0c6efdfd93d9c5feb21872c2bf837b58a9ff45374b138a5823245daf)
+            check_type(argname="argument resource_discovery", value=resource_discovery, expected_type=type_hints["resource_discovery"])
+        return typing.cast(IIpamResourceDiscoveryAssociation, jsii.invoke(self, "associateResourceDiscovery", [resource_discovery]))
 
-    @jsii.member(jsii_name="removeRegex")
-    @builtins.classmethod
-    def remove_regex(cls, regex: builtins.str) -> "ModifyOperation":
-        '''Removes all fields in the output matching the regular expression.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ARN_FORMAT")
+    def ARN_FORMAT(cls) -> _aws_cdk_ceddda9d.ArnFormat:
+        '''The format for Amazon Resource Names (ARN's) for IPAM resources.'''
+        return typing.cast(_aws_cdk_ceddda9d.ArnFormat, jsii.sget(cls, "ARN_FORMAT"))
 
-        :param regex: The regular expression specifying which fields to remove.
+    @builtins.property
+    @jsii.member(jsii_name="defaultPrivateScope")
+    def default_private_scope(self) -> IIpamScope:
+        '''The IPAM's default private scope.'''
+        return typing.cast(IIpamScope, jsii.get(self, "defaultPrivateScope"))
 
-        :return: A ModifyOperation object representing the remove operation.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__bd9fed6d2afdca2a8d61c87b02ec06a5728541f28c7352f673e92afe99a5efcd)
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "removeRegex", [regex]))
+    @builtins.property
+    @jsii.member(jsii_name="defaultPublicScope")
+    def default_public_scope(self) -> IIpamScope:
+        '''The IPAM's default public scope.'''
+        return typing.cast(IIpamScope, jsii.get(self, "defaultPublicScope"))
 
-    @jsii.member(jsii_name="removeWildcard")
-    @builtins.classmethod
-    def remove_wildcard(cls, key: builtins.str) -> "ModifyOperation":
-        '''Removes all fields in the output matching the wildcard key.
+    @builtins.property
+    @jsii.member(jsii_name="ipamArn")
+    def ipam_arn(self) -> builtins.str:
+        '''The ARN of the IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamArn"))
 
-        :param key: The wildcard expression specifying which fields to remove.
+    @builtins.property
+    @jsii.member(jsii_name="ipamId")
+    def ipam_id(self) -> builtins.str:
+        '''The ID of the IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamId"))
 
-        :return: A ModifyOperation object representing the remove operation.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a06eaf6be7e3ecf8c20d87aa164edc3b0351d095aa8d571d241a99dfae13e153)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "removeWildcard", [key]))
+    @builtins.property
+    @jsii.member(jsii_name="ipamPrivateDefaultScopeId")
+    def ipam_private_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default private scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamPrivateDefaultScopeId"))
 
-    @jsii.member(jsii_name="rename")
-    @builtins.classmethod
-    def rename(
-        cls,
-        original_key: builtins.str,
-        renamed_key: builtins.str,
-    ) -> "ModifyOperation":
-        '''Renames a field from the input if the field exists and a field with the new name does not exist.
+    @builtins.property
+    @jsii.member(jsii_name="ipamPublicDefaultScopeId")
+    def ipam_public_default_scope_id(self) -> builtins.str:
+        '''The ID of the IPAM's default public scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamPublicDefaultScopeId"))
 
-        :param original_key: The key in the input to be renamed.
-        :param renamed_key: The new name of the key in the output.
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeCount")
+    def ipam_scope_count(self) -> jsii.Number:
+        '''The number of scopes in the IPAM.
 
-        :return: A ModifyOperation object representing the rename operation.
+        The scope quota is 5.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4fada9b7497030c549640821afc49c367a7e9f8f75e21c42fc11b152b1655772)
-            check_type(argname="argument original_key", value=original_key, expected_type=type_hints["original_key"])
-            check_type(argname="argument renamed_key", value=renamed_key, expected_type=type_hints["renamed_key"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "rename", [original_key, renamed_key]))
-
-    @jsii.member(jsii_name="set")
-    @builtins.classmethod
-    def set(cls, key: builtins.str, value: builtins.str) -> "ModifyOperation":
-        '''Sets a field in the output to a specific value.
+        return typing.cast(jsii.Number, jsii.get(self, "ipamScopeCount"))
 
-        If a field with the same name already exists it will be overridden with
-        the specified value.
+    @builtins.property
+    @jsii.member(jsii_name="regions")
+    def regions(self) -> typing.List[builtins.str]:
+        '''An immutable collection of operating Regions for an IPAM.
 
-        :param key: The key name of the field to set.
-        :param value: The value to set for the specified field.
+        Operating Regions are AWS Regions where the IPAM is allowed to manage IP
+        address CIDRs. IPAM only discovers and monitors resources in the AWS
+        Regions you select as operating Regions.
 
-        :return: A ModifyOperation object representing the set operation.
+        :see: `Create an IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/create-ipam.html>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2a30ee29a1bf209f7c351625daebd78e2a284fc57bc3fa2bc6d0fb94a0d6032f)
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("ModifyOperation", jsii.sinvoke(cls, "set", [key, value]))
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "regions"))
 
-    @jsii.member(jsii_name="toString")
-    def to_string(self) -> builtins.str:
-        '''Gets a string representation of the arguments of this operation for use in a Fluent Bit plugin field.
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAM:
+        '''The underlying IPAM CloudFormation resource.
 
-        :return: A fluent bit value string.
+        :see: `AWS::EC2::IPAM <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html>`_
+        :group: Resources
         '''
-        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAM, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="args")
-    def args(self) -> typing.List[builtins.str]:
-        '''Collection of arguments that apply to the operation.'''
-        return typing.cast(typing.List[builtins.str], jsii.get(self, "args"))
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description for the IPAM.
 
-    @builtins.property
-    @jsii.member(jsii_name="operation")
-    def operation(self) -> builtins.str:
-        '''The name of the operation being performed.'''
-        return typing.cast(builtins.str, jsii.get(self, "operation"))
+        :see: `IPAM Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.NamespacedExternalSecretOptions",
-    jsii_struct_bases=[ExternalSecretOptions],
-    name_mapping={"fields": "fields", "name": "name", "namespace": "namespace"},
-)
-class NamespacedExternalSecretOptions(ExternalSecretOptions):
+@jsii.implements(IIpamAllocation)
+class IpamAllocation(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.IpamAllocation",
+):
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
         *,
-        fields: typing.Optional[typing.Sequence[typing.Union["SecretFieldReference", typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        ipam_pool: IIpamPool,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Configuration options for adding a Kubernetes secret synced from an external provider to a specific Kubernetes namespace.
-
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
-        :param namespace: The Kubernetes namespace where the synced secret should be created. Default: 'default'
+        '''
+        :param scope: -
+        :param id: -
+        :param ipam_pool: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param allocation: 
+        :param description: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__fd3dc6435c8d865e4f7520bd4058b3d18b2d20bc9036da2f79a101b7da1409ac)
-            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if fields is not None:
-            self._values["fields"] = fields
-        if name is not None:
-            self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
-
-    @builtins.property
-    def fields(self) -> typing.Optional[typing.List["SecretFieldReference"]]:
-        '''A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider.
-
-        :default:
+            type_hints = typing.get_type_hints(_typecheckingstub__62b34aa15d811a8c1c7a6291d668364a570669c52080fee054ac7fca374fc959)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpamAllocationProps(
+            ipam_pool=ipam_pool,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+            allocation=allocation,
+            description=description,
+        )
 
-        The Kubernetes secret will mirror the fields from the secret in
-        the external provider.
-        '''
-        result = self._values.get("fields")
-        return typing.cast(typing.Optional[typing.List["SecretFieldReference"]], result)
+        jsii.create(self.__class__, self, [scope, id, props])
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster.
-
-        :default: A name will be auto-generated.
-        '''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="allocation")
+    def allocation(self) -> IIpamAllocationConfiguration:
+        return typing.cast(IIpamAllocationConfiguration, jsii.get(self, "allocation"))
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the synced secret should be created.
+    @jsii.member(jsii_name="ipamAllocationCidr")
+    def ipam_allocation_cidr(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamAllocationCidr"))
 
-        :default: 'default'
-        '''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @builtins.property
+    @jsii.member(jsii_name="ipamAllocationId")
+    def ipam_allocation_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamAllocationId"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="ipamPool")
+    def ipam_pool(self) -> IIpamPool:
+        return typing.cast(IIpamPool, jsii.get(self, "ipamPool"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMAllocation:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMAllocation, jsii.get(self, "resource"))
 
-    def __repr__(self) -> str:
-        return "NamespacedExternalSecretOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
 
-@jsii.implements(INestFilterOperation)
-class NestFilterOperation(
+class IpamAllocationConfiguration(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.NestFilterOperation",
+    jsii_type="cdk-extensions.ec2.IpamAllocationConfiguration",
 ):
-    '''Operations with exclusive options that can be performed by the Fluent Bit Nest filter plugin.'''
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-    @jsii.member(jsii_name="lift")
+    @jsii.member(jsii_name="auto")
     @builtins.classmethod
-    def lift(cls, *, nested_under: builtins.str) -> INestFilterOperation:
+    def auto(cls) -> IIpamAllocationConfiguration:
+        return typing.cast(IIpamAllocationConfiguration, jsii.sinvoke(cls, "auto", []))
+
+    @jsii.member(jsii_name="cidr")
+    @builtins.classmethod
+    def cidr(cls, cidr: builtins.str) -> IIpamAllocationConfiguration:
         '''
-        :param nested_under: Lift records nested under the this key.
+        :param cidr: -
         '''
-        options = LiftOptions(nested_under=nested_under)
-
-        return typing.cast(INestFilterOperation, jsii.sinvoke(cls, "lift", [options]))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__90a5f1bf2b9d90ffe699d47216484dc1d6dc0c36521c06f33dd356324546157d)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+        return typing.cast(IIpamAllocationConfiguration, jsii.sinvoke(cls, "cidr", [cidr]))
 
-    @jsii.member(jsii_name="nest")
+    @jsii.member(jsii_name="netmask")
     @builtins.classmethod
-    def nest(
-        cls,
-        *,
-        nest_under: builtins.str,
-        wildcards: typing.Sequence[builtins.str],
-    ) -> INestFilterOperation:
+    def netmask(cls, length: jsii.Number) -> IIpamAllocationConfiguration:
         '''
-        :param nest_under: Nest records matching ``wildcard`` under this key.
-        :param wildcards: Nest records which field matches this wildcard,.
+        :param length: -
         '''
-        options = NestOptions(nest_under=nest_under, wildcards=wildcards)
-
-        return typing.cast(INestFilterOperation, jsii.sinvoke(cls, "nest", [options]))
-
-    @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
-        '''The fields representing configuration options for the operation.'''
-        return typing.cast(typing.Mapping[builtins.str, typing.List[builtins.str]], jsii.get(self, "fields"))
-
-    @builtins.property
-    @jsii.member(jsii_name="operation")
-    def operation(self) -> "NestFilterOperationType":
-        '''The type of operation to be performed.'''
-        return typing.cast("NestFilterOperationType", jsii.get(self, "operation"))
-
-
-@jsii.enum(jsii_type="cdk-extensions.k8s_aws.NestFilterOperationType")
-class NestFilterOperationType(enum.Enum):
-    '''The modes that the Fluent Bit Nest filter plugin can work in.'''
-
-    LIFT = "LIFT"
-    '''Lift data from a nested object.'''
-    NEST = "NEST"
-    '''Nest data into a specified object.'''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7f5ea0eb8eb95fb7b3817d0fd0189eb58694dac360bce4da34bba03e52edebe7)
+            check_type(argname="argument length", value=length, expected_type=type_hints["length"])
+        return typing.cast(IIpamAllocationConfiguration, jsii.sinvoke(cls, "netmask", [length]))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.NestOptions",
+    jsii_type="cdk-extensions.ec2.IpamAllocationOptions",
     jsii_struct_bases=[],
-    name_mapping={"nest_under": "nestUnder", "wildcards": "wildcards"},
+    name_mapping={"allocation": "allocation", "description": "description"},
 )
-class NestOptions:
+class IpamAllocationOptions:
     def __init__(
         self,
         *,
-        nest_under: builtins.str,
-        wildcards: typing.Sequence[builtins.str],
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
     ) -> None:
         '''
-        :param nest_under: Nest records matching ``wildcard`` under this key.
-        :param wildcards: Nest records which field matches this wildcard,.
+        :param allocation: 
+        :param description: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b5a146c9ddfcbd766c4313db4ff21f80ccb81d8144313200dfa63dd1bb1ff770)
-            check_type(argname="argument nest_under", value=nest_under, expected_type=type_hints["nest_under"])
-            check_type(argname="argument wildcards", value=wildcards, expected_type=type_hints["wildcards"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "nest_under": nest_under,
-            "wildcards": wildcards,
-        }
+            type_hints = typing.get_type_hints(_typecheckingstub__4d460bd7922658dcf43edece504384376cb5f442b4bff65f958ac6c2836ac293)
+            check_type(argname="argument allocation", value=allocation, expected_type=type_hints["allocation"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if allocation is not None:
+            self._values["allocation"] = allocation
+        if description is not None:
+            self._values["description"] = description
 
     @builtins.property
-    def nest_under(self) -> builtins.str:
-        '''Nest records matching ``wildcard`` under this key.'''
-        result = self._values.get("nest_under")
-        assert result is not None, "Required property 'nest_under' is missing"
-        return typing.cast(builtins.str, result)
+    def allocation(self) -> typing.Optional[IIpamAllocationConfiguration]:
+        result = self._values.get("allocation")
+        return typing.cast(typing.Optional[IIpamAllocationConfiguration], result)
 
     @builtins.property
-    def wildcards(self) -> typing.List[builtins.str]:
-        '''Nest records which field matches this wildcard,.'''
-        result = self._values.get("wildcards")
-        assert result is not None, "Required property 'wildcards' is missing"
-        return typing.cast(typing.List[builtins.str], result)
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "NestOptions(%s)" % ", ".join(
+        return "IpamAllocationOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(IExternalDnsRegistry)
-class NoopRegistry(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.NoopRegistry",
-):
-    '''A placeholder ExternalDNS registry that says ExternalDNS should use not use a registry.
-
-    When configuring ExternalDNS without a registry, the service has no idea the
-    original creator and maintainer of DNS records. This means that there are
-    likely to be conflicts if there are multiple services that could create or
-    change DNS records in the same zone.
-    '''
-
-    def __init__(self) -> None:
-        '''Creates a new instance of the NoopRegistry class.'''
-        jsii.create(self.__class__, self, [])
-
-    @jsii.member(jsii_name="bind")
-    def bind(
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.IpamAllocationProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, IpamAllocationOptions],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "allocation": "allocation",
+        "description": "description",
+        "ipam_pool": "ipamPool",
+    },
+)
+class IpamAllocationProps(_aws_cdk_ceddda9d.ResourceProps, IpamAllocationOptions):
+    def __init__(
         self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ExternalDnsRegistryConfiguration:
-        '''Generates an object with all the information needed to use the registry in a given CDK scope.
-
-        :param _scope: The CDK resource that is configuring ExternalDNS.
-
-        :return:
-
-        A configuration object representing the implementation of this
-        registry.
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
+        ipam_pool: IIpamPool,
+    ) -> None:
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4b8fe7eff14cfd09dcf3795cb57c69d832abf797e1e50720b10706a28cf1e816)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [_scope]))
-
-    @builtins.property
-    @jsii.member(jsii_name="registryType")
-    def registry_type(self) -> builtins.str:
-        '''The type name of ExternalDNS registry.'''
-        return typing.cast(builtins.str, jsii.get(self, "registryType"))
-
-
-class OpenSearchOutputBufferSize(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.OpenSearchOutputBufferSize",
-):
-    '''Represents the size of the OpenSeach output buffer to be used by Fluent Bit.'''
-
-    @jsii.member(jsii_name="bytes")
-    @builtins.classmethod
-    def bytes(cls, size: _DataSize_d20aaece) -> "OpenSearchOutputBufferSize":
-        '''Set the output buffer to a specified data size.
-
-        :param size: The size of the output buffer.
-
-        :return:
-
-        An output buffer size object representing the specified buffer
-        size.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param allocation: 
+        :param description: 
+        :param ipam_pool: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d4d24a390d9eb03a06583cbc6d261f3d8de476409210bcdd7f51d4e1476eeaf4)
-            check_type(argname="argument size", value=size, expected_type=type_hints["size"])
-        return typing.cast("OpenSearchOutputBufferSize", jsii.sinvoke(cls, "bytes", [size]))
-
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, value: builtins.str) -> "OpenSearchOutputBufferSize":
-        '''An escape hatch that allows an arbitrary value to be set for the OpenSearch buffer output property.
-
-        :param value: The value to use for the OpenSearch buffer output property.
+            type_hints = typing.get_type_hints(_typecheckingstub__a07b8bbd3bc9b799c207889e9985ac227583d9101f33f1dcb0b174d27c62a6b7)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument allocation", value=allocation, expected_type=type_hints["allocation"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument ipam_pool", value=ipam_pool, expected_type=type_hints["ipam_pool"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "ipam_pool": ipam_pool,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if allocation is not None:
+            self._values["allocation"] = allocation
+        if description is not None:
+            self._values["description"] = description
 
-        :return:
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        A ``OpenSearchOutputBufferSize`` object representing the passed
-        value.
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f02160f33c5993a4b0add2859c5aaed60beda3ddc55734f5fb49997c73f69b93)
-            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
-        return typing.cast("OpenSearchOutputBufferSize", jsii.sinvoke(cls, "of", [value]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="UNLIMITED")
-    def UNLIMITED(cls) -> "OpenSearchOutputBufferSize":
-        '''Set the output buffer size to unlimited.'''
-        return typing.cast("OpenSearchOutputBufferSize", jsii.sget(cls, "UNLIMITED"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="value")
-    def value(self) -> builtins.str:
-        '''The value to use for the OpenSearch buffer output property.'''
-        return typing.cast(builtins.str, jsii.get(self, "value"))
-
-
-class ParserPluginDataType(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.ParserPluginDataType",
-):
-    '''Represents the various types of data that can be mapped in Fluent Bit using a parser plugin.'''
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-    @jsii.member(jsii_name="of")
-    @builtins.classmethod
-    def of(cls, name: builtins.str) -> "ParserPluginDataType":
-        '''An escape hatch method that allow specifying arbitrary custom data types.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        :param name: The name of the data type.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :return: An object representing the data type.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7f740f5f0bbca2b649fceb0e355052b591878a5d830606365cce99d8b088caac)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        return typing.cast("ParserPluginDataType", jsii.sinvoke(cls, "of", [name]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="BOOL")
-    def BOOL(cls) -> "ParserPluginDataType":
-        '''Object that is true or false.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "BOOL"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="FLOAT")
-    def FLOAT(cls) -> "ParserPluginDataType":
-        '''Floating point number values.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "FLOAT"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="HEX")
-    def HEX(cls) -> "ParserPluginDataType":
-        '''Hexidecimal number values.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "HEX"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="INTEGER")
-    def INTEGER(cls) -> "ParserPluginDataType":
-        '''While number values.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "INTEGER"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="LOGFMT")
-    def LOGFMT(cls) -> "ParserPluginDataType":
-        '''Logfmt formatted data.
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :see: `Golang logfmt documentation <https://pkg.go.dev/github.com/kr/logfmt>`_
-        '''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "LOGFMT"))
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="LTSV")
-    def LTSV(cls) -> "ParserPluginDataType":
-        '''Labeled tab-separated values.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :see: `LTSV <http://ltsv.org/>`_
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "LTSV"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="REGEX")
-    def REGEX(cls) -> "ParserPluginDataType":
-        '''Regular expression.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "REGEX"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="STRING")
-    def STRING(cls) -> "ParserPluginDataType":
-        '''Text data.'''
-        return typing.cast("ParserPluginDataType", jsii.sget(cls, "STRING"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the data type.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.ResolvedFluentBitConfiguration",
-    jsii_struct_bases=[],
-    name_mapping={
-        "config_file": "configFile",
-        "parsers": "parsers",
-        "permissions": "permissions",
-    },
-)
-class ResolvedFluentBitConfiguration:
-    def __init__(
-        self,
-        *,
-        config_file: builtins.str,
-        parsers: typing.Optional[typing.Sequence["IFluentBitParserPlugin"]] = None,
-        permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
-    ) -> None:
-        '''The output of a Fluent Bit configuration object for consumption be the resource configuring Fluent Bit.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :param config_file: The configuration rended as a configuration file that can be read by the Fluent Bit service.
-        :param parsers: A list of parsers referenced by this plugin.
-        :param permissions: IAM permissions required by resources that will be using this plugin.
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c82e94df4496e54b2a8815cc2ee59fcd040f76e2dcc14bb09c3f2fc10a316803)
-            check_type(argname="argument config_file", value=config_file, expected_type=type_hints["config_file"])
-            check_type(argname="argument parsers", value=parsers, expected_type=type_hints["parsers"])
-            check_type(argname="argument permissions", value=permissions, expected_type=type_hints["permissions"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "config_file": config_file,
-        }
-        if parsers is not None:
-            self._values["parsers"] = parsers
-        if permissions is not None:
-            self._values["permissions"] = permissions
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def config_file(self) -> builtins.str:
-        '''The configuration rended as a configuration file that can be read by the Fluent Bit service.'''
-        result = self._values.get("config_file")
-        assert result is not None, "Required property 'config_file' is missing"
-        return typing.cast(builtins.str, result)
+    def allocation(self) -> typing.Optional[IIpamAllocationConfiguration]:
+        result = self._values.get("allocation")
+        return typing.cast(typing.Optional[IIpamAllocationConfiguration], result)
 
     @builtins.property
-    def parsers(self) -> typing.Optional[typing.List["IFluentBitParserPlugin"]]:
-        '''A list of parsers referenced by this plugin.'''
-        result = self._values.get("parsers")
-        return typing.cast(typing.Optional[typing.List["IFluentBitParserPlugin"]], result)
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def permissions(
-        self,
-    ) -> typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]]:
-        '''IAM permissions required by resources that will be using this plugin.'''
-        result = self._values.get("permissions")
-        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]], result)
+    def ipam_pool(self) -> IIpamPool:
+        result = self._values.get("ipam_pool")
+        assert result is not None, "Required property 'ipam_pool' is missing"
+        return typing.cast(IIpamPool, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "ResolvedFluentBitConfiguration(%s)" % ", ".join(
+        return "IpamAllocationProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.RewriteTagRule",
+    jsii_type="cdk-extensions.ec2.IpamAttributes",
     jsii_struct_bases=[],
-    name_mapping={"keep": "keep", "key": "key", "new_tag": "newTag", "regex": "regex"},
+    name_mapping={
+        "ipam_arn": "ipamArn",
+        "ipam_id": "ipamId",
+        "private_default_scope": "privateDefaultScope",
+        "public_default_scope": "publicDefaultScope",
+        "scope_count": "scopeCount",
+    },
 )
-class RewriteTagRule:
+class IpamAttributes:
     def __init__(
         self,
         *,
-        keep: builtins.bool,
-        key: builtins.str,
-        new_tag: builtins.str,
-        regex: builtins.str,
+        ipam_arn: typing.Optional[builtins.str] = None,
+        ipam_id: typing.Optional[builtins.str] = None,
+        private_default_scope: typing.Optional[IIpamScope] = None,
+        public_default_scope: typing.Optional[IIpamScope] = None,
+        scope_count: typing.Optional[jsii.Number] = None,
     ) -> None:
-        '''Defines the matching criteria and the format of the Tag for the rewrite tag Fluent Bit filter plugin.
+        '''Configuration for importing an existing IPAM.
 
-        :param keep: If a rule matches a rule the filter will emit a copy of the record with the new defined Tag. The property keep takes a boolean value to define if the original record with the old Tag must be preserved and continue in the pipeline or just be discarded.
-        :param key: The key represents the name of the record key that holds the value that we want to use to match our regular expression. A key name is specified and prefixed with a ``$``.
-        :param new_tag: If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record. The tag is a concatenated string that can contain any of the following characters: ``a-z,A-Z,0-9`` and ``.-,``.
-        :param regex: Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
-
-        :see: `Rules <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#rules>`_
+        :param ipam_arn: The Amazon Resource Name (ARN) of the IPAM.
+        :param ipam_id: The ID generated by AWS for the IPAM.
+        :param private_default_scope: The IPAM's default private scope.
+        :param public_default_scope: The IPAM's default public scope.
+        :param scope_count: The number of scopes in the IPAM.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__10d3a53f3145b3b27a3099c9f07d903492e56e8258545b4251a8bc9b20c63556)
-            check_type(argname="argument keep", value=keep, expected_type=type_hints["keep"])
-            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
-            check_type(argname="argument new_tag", value=new_tag, expected_type=type_hints["new_tag"])
-            check_type(argname="argument regex", value=regex, expected_type=type_hints["regex"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "keep": keep,
-            "key": key,
-            "new_tag": new_tag,
-            "regex": regex,
-        }
+            type_hints = typing.get_type_hints(_typecheckingstub__4511450bed75a1ae15c3778c31cc7035b506e40a7c9cf91f81050dd2fc0ac150)
+            check_type(argname="argument ipam_arn", value=ipam_arn, expected_type=type_hints["ipam_arn"])
+            check_type(argname="argument ipam_id", value=ipam_id, expected_type=type_hints["ipam_id"])
+            check_type(argname="argument private_default_scope", value=private_default_scope, expected_type=type_hints["private_default_scope"])
+            check_type(argname="argument public_default_scope", value=public_default_scope, expected_type=type_hints["public_default_scope"])
+            check_type(argname="argument scope_count", value=scope_count, expected_type=type_hints["scope_count"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if ipam_arn is not None:
+            self._values["ipam_arn"] = ipam_arn
+        if ipam_id is not None:
+            self._values["ipam_id"] = ipam_id
+        if private_default_scope is not None:
+            self._values["private_default_scope"] = private_default_scope
+        if public_default_scope is not None:
+            self._values["public_default_scope"] = public_default_scope
+        if scope_count is not None:
+            self._values["scope_count"] = scope_count
 
     @builtins.property
-    def keep(self) -> builtins.bool:
-        '''If a rule matches a rule the filter will emit a copy of the record with the new defined Tag.
-
-        The property keep takes a boolean value to define if the original
-        record with the old Tag must be preserved and continue in the pipeline
-        or just be discarded.
-
-        :see: `Keep <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#keep>`_
-        '''
-        result = self._values.get("keep")
-        assert result is not None, "Required property 'keep' is missing"
-        return typing.cast(builtins.bool, result)
+    def ipam_arn(self) -> typing.Optional[builtins.str]:
+        '''The Amazon Resource Name (ARN) of the IPAM.'''
+        result = self._values.get("ipam_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def key(self) -> builtins.str:
-        '''The key represents the name of the record key that holds the value that we want to use to match our regular expression.
-
-        A key name is specified and prefixed with a ``$``.
-
-        :see: `Key <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#key>`_
-        '''
-        result = self._values.get("key")
-        assert result is not None, "Required property 'key' is missing"
-        return typing.cast(builtins.str, result)
+    def ipam_id(self) -> typing.Optional[builtins.str]:
+        '''The ID generated by AWS for the IPAM.'''
+        result = self._values.get("ipam_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def new_tag(self) -> builtins.str:
-        '''If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record.
-
-        The tag is a concatenated string that can contain any of the following
-        characters: ``a-z,A-Z,0-9`` and ``.-,``.
-
-        :see: `New Tag <https://docs.fluentbit.io/manual/pipeline/filters/rewrite-tag#new-tag>`_
-        '''
-        result = self._values.get("new_tag")
-        assert result is not None, "Required property 'new_tag' is missing"
-        return typing.cast(builtins.str, result)
+    def private_default_scope(self) -> typing.Optional[IIpamScope]:
+        '''The IPAM's default private scope.'''
+        result = self._values.get("private_default_scope")
+        return typing.cast(typing.Optional[IIpamScope], result)
 
     @builtins.property
-    def regex(self) -> builtins.str:
-        '''Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
+    def public_default_scope(self) -> typing.Optional[IIpamScope]:
+        '''The IPAM's default public scope.'''
+        result = self._values.get("public_default_scope")
+        return typing.cast(typing.Optional[IIpamScope], result)
 
-        :see: `Rubular regex tester <https://rubular.com/>`_
-        '''
-        result = self._values.get("regex")
-        assert result is not None, "Required property 'regex' is missing"
-        return typing.cast(builtins.str, result)
+    @builtins.property
+    def scope_count(self) -> typing.Optional[jsii.Number]:
+        '''The number of scopes in the IPAM.'''
+        result = self._values.get("scope_count")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "RewriteTagRule(%s)" % ", ".join(
+        return "IpamAttributes(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-class Route53Dns(
-    _aws_cdk_ceddda9d.Resource,
+class IpamConsumer(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.Route53Dns",
+    jsii_type="cdk-extensions.ec2.IpamConsumer",
 ):
-    '''External DNS is a Kubernetes service that make Kubernetes resources dicoverable via public DNS servers.
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "IpamConsumer":
+        '''
+        :param name: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__286c12a5ef14167a5ceeb4a61b036f35ae0e15cf700b54c3e1867aded79c8910)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("IpamConsumer", jsii.sinvoke(cls, "of", [name]))
 
-    It retrieves a list of resources
-    (Services, Ingresses, etc.) from the Kubernetes API to determine a desired
-    list of DNS records and configures DNS providers accordingly.
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="EC2")
+    def EC2(cls) -> "IpamConsumer":
+        return typing.cast("IpamConsumer", jsii.sget(cls, "EC2"))
 
-    The version provided here specifically targets Amazon's Route 53 service and
-    all options provded are for configuring Route 53. After being installed
-    external-dns will create and manage Route 53 DNS records automatically to
-    allow easy network access to your pods and services.
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
-    :see: `Kubernetes SIGs <https://github.com/kubernetes-sigs/external-dns>`_
-    '''
 
+@jsii.implements(IIpamPool)
+class IpamPool(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.IpamPool",
+):
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
+        scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        ipam_scope: IIpamScope,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        api_retries: typing.Optional[jsii.Number] = None,
-        batch_change_size: typing.Optional[jsii.Number] = None,
-        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-        evaluate_target_health: typing.Optional[builtins.bool] = None,
-        log_format: typing.Optional[ExternalDnsLogFormat] = None,
-        log_level: typing.Optional[ExternalDnsLogLevel] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        prefer_cname: typing.Optional[builtins.bool] = None,
-        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-        replica_count: typing.Optional[jsii.Number] = None,
-        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-        zone_type: typing.Optional[ExternalDnsZoneType] = None,
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional[IpamConsumer] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
     ) -> None:
-        '''Creates a new instance of the Route53Dns class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where external-dns should be deployed.
+        '''
+        :param scope: -
+        :param id: -
+        :param ipam_scope: 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
-        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
-        :param domain_filter: Limits possible target zones by domain suffixes.
-        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
-        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
-        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
-        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
-        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
-        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
-        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
-        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
-        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
-        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__25ed19f0f43971dfc8f3ac2b02af3d6b57e81e4bf8f903ca7a9a94030416e6df)
+            type_hints = typing.get_type_hints(_typecheckingstub__9c1663d7016f62377ea107cf058e68f823c75f65351209f4f0aba2cdeee51aee)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = Route53DnsProps(
-            cluster=cluster,
+        props = IpamPoolProps(
+            ipam_scope=ipam_scope,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
-            api_retries=api_retries,
-            batch_change_size=batch_change_size,
-            domain_filter=domain_filter,
-            evaluate_target_health=evaluate_target_health,
-            log_format=log_format,
-            log_level=log_level,
-            namespace=namespace,
-            prefer_cname=prefer_cname,
-            record_ownership_registry=record_ownership_registry,
-            replica_count=replica_count,
-            sync_policy=sync_policy,
-            zone_tags=zone_tags,
-            zone_type=zone_type,
+            address_configuration=address_configuration,
+            auto_import=auto_import,
+            consumer=consumer,
+            description=description,
+            locale=locale,
+            name=name,
+            parent_pool=parent_pool,
+            provisioned_cidrs=provisioned_cidrs,
+            public_ip_source=public_ip_source,
+            tag_restrictions=tag_restrictions,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="addDomainFilter")
-    def add_domain_filter(self, domain: builtins.str) -> "Route53Dns":
-        '''Adds a domain to the domain filter list.
-
-        The domain filter list acts as a whitelist for the domains/hosted zones
-        which external-dns will manage.
-
-        When domains are added to the domain filter list, external-dns will only
-        create and manage records when their domain ends in with a domain that has
-        been approved.
-
-        :param domain: The domain to be added to the whitelist.
-
-        :return:
-
-        The external-dns service object that the domain filter was added
-        for.
+    @jsii.member(jsii_name="addChildPool")
+    def add_child_pool(
+        self,
+        id: builtins.str,
+        *,
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional[IpamConsumer] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> IIpamPool:
+        '''
+        :param id: -
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b366d288dd32fbd3b7303ac861a4b96ff1f42c49b0c512768f7acdc1ace18cb1)
-            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
-        return typing.cast("Route53Dns", jsii.invoke(self, "addDomainFilter", [domain]))
-
-    @jsii.member(jsii_name="addZoneTag")
-    def add_zone_tag(self, *, key: builtins.str, value: builtins.str) -> "Route53Dns":
-        '''Adds a zone tag filter to the external DNS service.
-
-        When zone tags are provided only Routew 53 Hosted Zones that have matching
-        tags will be managed by external DNS.
+            type_hints = typing.get_type_hints(_typecheckingstub__a7567b7c123b03ca4fe677156bcf8da88b7b533dddd10988046466f920ffea74)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AddChildPoolOptions(
+            address_configuration=address_configuration,
+            auto_import=auto_import,
+            consumer=consumer,
+            description=description,
+            locale=locale,
+            name=name,
+            provisioned_cidrs=provisioned_cidrs,
+            public_ip_source=public_ip_source,
+            tag_restrictions=tag_restrictions,
+        )
 
-        :param key: The name of the tag to filter on.
-        :param value: The value of the tag to filter on.
+        return typing.cast(IIpamPool, jsii.invoke(self, "addChildPool", [id, options]))
 
-        :return: The external-dns service object that the zone tag was added for.
+    @jsii.member(jsii_name="addCidrToPool")
+    def add_cidr_to_pool(
+        self,
+        id: builtins.str,
+        *,
+        configuration: IIpamPoolCidrConfiguration,
+        allow_inline: typing.Optional[builtins.bool] = None,
+    ) -> AddCidrToPoolResult:
+        '''
+        :param id: -
+        :param configuration: 
+        :param allow_inline: 
         '''
-        tag = ExternalDnsZoneTag(key=key, value=value)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4075a35e6e1610736b7c269bed0b1519cb48461c587fa68f672112aa62765952)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AddCidrToPoolOptions(
+            configuration=configuration, allow_inline=allow_inline
+        )
 
-        return typing.cast("Route53Dns", jsii.invoke(self, "addZoneTag", [tag]))
+        return typing.cast(AddCidrToPoolResult, jsii.invoke(self, "addCidrToPool", [id, options]))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CHART_NAME")
-    def CHART_NAME(cls) -> builtins.str:
-        '''The name of the external-dns Helm chart.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "CHART_NAME"))
+    @jsii.member(jsii_name="addTagRestriction")
+    def add_tag_restriction(self, key: builtins.str, value: builtins.str) -> IIpamPool:
+        '''
+        :param key: -
+        :param value: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7c9706b72709e9a6ba823b8fe9a6152930be0d3c32bba2b5f7fe73f06ffa76fc)
+            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
+            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
+        return typing.cast(IIpamPool, jsii.invoke(self, "addTagRestriction", [key, value]))
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="CHART_REPOSITORY")
-    def CHART_REPOSITORY(cls) -> builtins.str:
-        '''The Helm repository providing the chart to be used for installing the external-dns service.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "CHART_REPOSITORY"))
+    @jsii.member(jsii_name="allocateCidrFromPool")
+    def allocate_cidr_from_pool(
+        self,
+        id: builtins.str,
+        *,
+        scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
+    ) -> IIpamAllocation:
+        '''
+        :param id: -
+        :param scope: 
+        :param allocation: 
+        :param description: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cd97e16b1589e82ca19d21ff1c68bd2cfba34b2982db96fd23e8b70025d0cd21)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = AllocateCidrFromPoolOptions(
+            scope=scope, allocation=allocation, description=description
+        )
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_NAMESPACE")
-    def DEFAULT_NAMESPACE(cls) -> builtins.str:
-        '''The default Kubernetes namespace where external-dns will be installed if an alternative isn't given as input.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_NAMESPACE"))
+        return typing.cast(IIpamAllocation, jsii.invoke(self, "allocateCidrFromPool", [id, options]))
 
     @builtins.property
-    @jsii.member(jsii_name="chart")
-    def chart(self) -> _aws_cdk_aws_eks_ceddda9d.HelmChart:
-        '''The Helm chart that provides the installation of external-dns.
-
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.HelmChart, jsii.get(self, "chart"))
+    @jsii.member(jsii_name="ipamPoolArn")
+    def ipam_pool_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where external-dns should be deployed.
-
-        :group: Inputs
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+    @jsii.member(jsii_name="ipamPoolDepth")
+    def ipam_pool_depth(self) -> jsii.Number:
+        return typing.cast(jsii.Number, jsii.get(self, "ipamPoolDepth"))
 
     @builtins.property
-    @jsii.member(jsii_name="domainFilter")
-    def domain_filter(self) -> typing.List[builtins.str]:
-        '''The domain suffixes that control which hosted zones external-dns is allowed to make changes for.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.List[builtins.str], jsii.get(self, "domainFilter"))
+    @jsii.member(jsii_name="ipamPoolId")
+    def ipam_pool_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolId"))
 
     @builtins.property
-    @jsii.member(jsii_name="recordOwnershipRegistry")
-    def record_ownership_registry(self) -> IExternalDnsRegistry:
-        '''Registry specifying how ExternalDNS should track record ownership.
-
-        Without a registry to track record ownership, External has no way to know
-        which records it owns and manages and which are owned and managed by a
-        different service.
-
-        This can cause conflicts if there are multiple instances of External DNS
-        running or if there are other services managing DNS records in similar
-        zones as the different services could try to make conflicting changes due
-        to lacking a shared state.
-
-        :group: Inputs
-        '''
-        return typing.cast(IExternalDnsRegistry, jsii.get(self, "recordOwnershipRegistry"))
+    @jsii.member(jsii_name="ipamPoolIpamArn")
+    def ipam_pool_ipam_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolIpamArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="region")
-    def region(self) -> builtins.str:
-        '''Override the default region external-dns uses when calling AWS API's.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "region"))
+    @jsii.member(jsii_name="ipamPoolScopeArn")
+    def ipam_pool_scope_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolScopeArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="serviceAccount")
-    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
-        '''The Kubernetes service account that is linked with the IAM Role that allows external-dns to make changes on your behalf.
-
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
+    @jsii.member(jsii_name="ipamPoolScopeType")
+    def ipam_pool_scope_type(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolScopeType"))
 
     @builtins.property
-    @jsii.member(jsii_name="zoneTags")
-    def zone_tags(self) -> typing.List[ExternalDnsZoneTag]:
-        '''The AWS tags that control which hosted zones external-dns is allowed to make changes for.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.List[ExternalDnsZoneTag], jsii.get(self, "zoneTags"))
+    @jsii.member(jsii_name="ipamPoolState")
+    def ipam_pool_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolState"))
 
     @builtins.property
-    @jsii.member(jsii_name="apiRetries")
-    def api_retries(self) -> typing.Optional[jsii.Number]:
-        '''Maximum number of retries for AWS API calls before giving up.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "apiRetries"))
+    @jsii.member(jsii_name="ipamPoolStateMessage")
+    def ipam_pool_state_message(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolStateMessage"))
 
     @builtins.property
-    @jsii.member(jsii_name="batchChangeSize")
-    def batch_change_size(self) -> typing.Optional[jsii.Number]:
-        '''Set the maximum number of changes that will be applied in each batch.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "batchChangeSize"))
+    @jsii.member(jsii_name="ipamScope")
+    def ipam_scope(self) -> IIpamScope:
+        return typing.cast(IIpamScope, jsii.get(self, "ipamScope"))
 
     @builtins.property
-    @jsii.member(jsii_name="evaluateTargetHealth")
-    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
-        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "evaluateTargetHealth"))
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMPool:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMPool, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="logFormat")
-    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
-        '''Sets the output format external dns will use when generating logs.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ExternalDnsLogFormat], jsii.get(self, "logFormat"))
+    @jsii.member(jsii_name="addressConfiguration")
+    def address_configuration(self) -> typing.Optional[AddressConfiguration]:
+        return typing.cast(typing.Optional[AddressConfiguration], jsii.get(self, "addressConfiguration"))
 
     @builtins.property
-    @jsii.member(jsii_name="logLevel")
-    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
-        '''Controls the verbosity of logs generated using the external-dns service.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ExternalDnsLogLevel], jsii.get(self, "logLevel"))
+    @jsii.member(jsii_name="autoImport")
+    def auto_import(self) -> typing.Optional[builtins.bool]:
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoImport"))
 
     @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the service should be deployed.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "namespace"))
+    @jsii.member(jsii_name="consumer")
+    def consumer(self) -> typing.Optional[IpamConsumer]:
+        return typing.cast(typing.Optional[IpamConsumer], jsii.get(self, "consumer"))
 
     @builtins.property
-    @jsii.member(jsii_name="preferCname")
-    def prefer_cname(self) -> typing.Optional[builtins.bool]:
-        '''When true, alias records will be avoided and CNAME records will be used instead.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "preferCname"))
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
     @builtins.property
-    @jsii.member(jsii_name="replicaCount")
-    def replica_count(self) -> typing.Optional[jsii.Number]:
-        '''Desired number of ExternalDNS replicas.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "replicaCount"))
+    @jsii.member(jsii_name="locale")
+    def locale(self) -> typing.Optional[builtins.str]:
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locale"))
 
     @builtins.property
-    @jsii.member(jsii_name="syncPolicy")
-    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
-        '''Controls the operations ExternalDNS will perform on the records it manages.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], jsii.get(self, "syncPolicy"))
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
     @builtins.property
-    @jsii.member(jsii_name="zoneType")
-    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
-        '''Controls the types of hosted zones external-dns will create records for.
+    @jsii.member(jsii_name="parentPool")
+    def parent_pool(self) -> typing.Optional[IIpamPool]:
+        return typing.cast(typing.Optional[IIpamPool], jsii.get(self, "parentPool"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ExternalDnsZoneType], jsii.get(self, "zoneType"))
+    @builtins.property
+    @jsii.member(jsii_name="publicIpSource")
+    def public_ip_source(self) -> typing.Optional["PublicIpSource"]:
+        return typing.cast(typing.Optional["PublicIpSource"], jsii.get(self, "publicIpSource"))
 
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.Route53DnsOptions",
-    jsii_struct_bases=[],
-    name_mapping={
-        "api_retries": "apiRetries",
-        "batch_change_size": "batchChangeSize",
-        "domain_filter": "domainFilter",
-        "evaluate_target_health": "evaluateTargetHealth",
-        "log_format": "logFormat",
-        "log_level": "logLevel",
-        "namespace": "namespace",
-        "prefer_cname": "preferCname",
-        "record_ownership_registry": "recordOwnershipRegistry",
-        "region": "region",
-        "replica_count": "replicaCount",
-        "sync_policy": "syncPolicy",
-        "zone_tags": "zoneTags",
-        "zone_type": "zoneType",
-    },
-)
-class Route53DnsOptions:
+@jsii.implements(IIpamPoolCidr)
+class IpamPoolCidr(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.IpamPoolCidr",
+):
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
         *,
-        api_retries: typing.Optional[jsii.Number] = None,
-        batch_change_size: typing.Optional[jsii.Number] = None,
-        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-        evaluate_target_health: typing.Optional[builtins.bool] = None,
-        log_format: typing.Optional[ExternalDnsLogFormat] = None,
-        log_level: typing.Optional[ExternalDnsLogLevel] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        prefer_cname: typing.Optional[builtins.bool] = None,
-        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-        region: typing.Optional[builtins.str] = None,
-        replica_count: typing.Optional[jsii.Number] = None,
-        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-        zone_type: typing.Optional[ExternalDnsZoneType] = None,
-    ) -> None:
-        '''Optional configuration for the Route53Dns resource.
-
-        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
-        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
-        :param domain_filter: Limits possible target zones by domain suffixes.
-        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
-        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
-        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
-        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
-        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
-        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
-        :param region: Override the default region external-dns uses when calling AWS API's.
-        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
-        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
-        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
-        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__66071158131361758043670975aa8966426ce28d558d5a62b92defe0a754f8cb)
-            check_type(argname="argument api_retries", value=api_retries, expected_type=type_hints["api_retries"])
-            check_type(argname="argument batch_change_size", value=batch_change_size, expected_type=type_hints["batch_change_size"])
-            check_type(argname="argument domain_filter", value=domain_filter, expected_type=type_hints["domain_filter"])
-            check_type(argname="argument evaluate_target_health", value=evaluate_target_health, expected_type=type_hints["evaluate_target_health"])
-            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
-            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-            check_type(argname="argument prefer_cname", value=prefer_cname, expected_type=type_hints["prefer_cname"])
-            check_type(argname="argument record_ownership_registry", value=record_ownership_registry, expected_type=type_hints["record_ownership_registry"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument replica_count", value=replica_count, expected_type=type_hints["replica_count"])
-            check_type(argname="argument sync_policy", value=sync_policy, expected_type=type_hints["sync_policy"])
-            check_type(argname="argument zone_tags", value=zone_tags, expected_type=type_hints["zone_tags"])
-            check_type(argname="argument zone_type", value=zone_type, expected_type=type_hints["zone_type"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if api_retries is not None:
-            self._values["api_retries"] = api_retries
-        if batch_change_size is not None:
-            self._values["batch_change_size"] = batch_change_size
-        if domain_filter is not None:
-            self._values["domain_filter"] = domain_filter
-        if evaluate_target_health is not None:
-            self._values["evaluate_target_health"] = evaluate_target_health
-        if log_format is not None:
-            self._values["log_format"] = log_format
-        if log_level is not None:
-            self._values["log_level"] = log_level
-        if namespace is not None:
-            self._values["namespace"] = namespace
-        if prefer_cname is not None:
-            self._values["prefer_cname"] = prefer_cname
-        if record_ownership_registry is not None:
-            self._values["record_ownership_registry"] = record_ownership_registry
-        if region is not None:
-            self._values["region"] = region
-        if replica_count is not None:
-            self._values["replica_count"] = replica_count
-        if sync_policy is not None:
-            self._values["sync_policy"] = sync_policy
-        if zone_tags is not None:
-            self._values["zone_tags"] = zone_tags
-        if zone_type is not None:
-            self._values["zone_type"] = zone_type
-
-    @builtins.property
-    def api_retries(self) -> typing.Optional[jsii.Number]:
-        '''Maximum number of retries for AWS API calls before giving up.
-
-        :default: 3
+        configuration: IIpamPoolCidrConfiguration,
+        ipam_pool: IIpamPool,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
         '''
-        result = self._values.get("api_retries")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def batch_change_size(self) -> typing.Optional[jsii.Number]:
-        '''Set the maximum number of changes that will be applied in each batch.
-
-        :default: 1000
+        :param scope: -
+        :param id: -
+        :param configuration: 
+        :param ipam_pool: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("batch_change_size")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__74b6a3269ad2cfdb786d1a0a8ba349a2556f673ced579f7dd6edc5d90e2338ae)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpamPoolCidrProps(
+            configuration=configuration,
+            ipam_pool=ipam_pool,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    def domain_filter(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''Limits possible target zones by domain suffixes.'''
-        result = self._values.get("domain_filter")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+        jsii.create(self.__class__, self, [scope, id, props])
 
     @builtins.property
-    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
-        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.'''
-        result = self._values.get("evaluate_target_health")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="configuration")
+    def configuration(self) -> IIpamPoolCidrConfiguration:
+        return typing.cast(IIpamPoolCidrConfiguration, jsii.get(self, "configuration"))
 
     @builtins.property
-    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
-        '''Sets the output format external dns will use when generating logs.
-
-        :default: {@link ExternalDnsLogLevel.JSON}
-        '''
-        result = self._values.get("log_format")
-        return typing.cast(typing.Optional[ExternalDnsLogFormat], result)
+    @jsii.member(jsii_name="ipamPool")
+    def ipam_pool(self) -> IIpamPool:
+        return typing.cast(IIpamPool, jsii.get(self, "ipamPool"))
 
     @builtins.property
-    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
-        '''Controls the verbosity of logs generated using the external-dns service.
-
-        :default: {@link ExternalDnsLogLevel.INFO}
-        '''
-        result = self._values.get("log_level")
-        return typing.cast(typing.Optional[ExternalDnsLogLevel], result)
+    @jsii.member(jsii_name="ipamPoolCidrId")
+    def ipam_pool_cidr_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolCidrId"))
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the service should be deployed.
-
-        :default: 'kube-system'
-        '''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamPoolCidrState")
+    def ipam_pool_cidr_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamPoolCidrState"))
 
     @builtins.property
-    def prefer_cname(self) -> typing.Optional[builtins.bool]:
-        '''When true, alias records will be avoided and CNAME records will be used instead.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMPoolCidr:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMPoolCidr, jsii.get(self, "resource"))
 
-        :default: false
-        '''
-        result = self._values.get("prefer_cname")
-        return typing.cast(typing.Optional[builtins.bool], result)
 
-    @builtins.property
-    def record_ownership_registry(self) -> typing.Optional[IExternalDnsRegistry]:
-        '''Registry specifying how ExternalDNS should track record ownership.
-
-        Without a registry to track record ownership, External has no way to know
-        which records it owns and manages and which are owned and managed by a
-        different service.
-
-        This can cause conflicts if there are multiple instances of External DNS
-        running or if there are other services managing DNS records in similar
-        zones as the different services could try to make conflicting changes due
-        to lacking a shared state.
+class IpamPoolCidrConfiguration(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.IpamPoolCidrConfiguration",
+):
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-        :default: A TXT registry configured with defaults.
+    @jsii.member(jsii_name="cidr")
+    @builtins.classmethod
+    def cidr(cls, cidr: builtins.str) -> IIpamPoolCidrConfiguration:
         '''
-        result = self._values.get("record_ownership_registry")
-        return typing.cast(typing.Optional[IExternalDnsRegistry], result)
-
-    @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''Override the default region external-dns uses when calling AWS API's.'''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def replica_count(self) -> typing.Optional[jsii.Number]:
-        '''Desired number of ExternalDNS replicas.
-
-        :default: 1
+        :param cidr: -
         '''
-        result = self._values.get("replica_count")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
-        '''Controls the operations ExternalDNS will perform on the records it manages.
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__dc961c0fc15b09f22e1e3c627d658e6e36ab62bae6dc22cc4e0499a1937fd464)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+        return typing.cast(IIpamPoolCidrConfiguration, jsii.sinvoke(cls, "cidr", [cidr]))
 
-        :default: {@link ExternalDnsSyncPolicy.SYNC}
+    @jsii.member(jsii_name="netmask")
+    @builtins.classmethod
+    def netmask(cls, length: jsii.Number) -> IIpamPoolCidrConfiguration:
         '''
-        result = self._values.get("sync_policy")
-        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], result)
-
-    @builtins.property
-    def zone_tags(self) -> typing.Optional[typing.List[ExternalDnsZoneTag]]:
-        '''A set of tags that can be used to restrict which hosted zones external DNS will make changes to.'''
-        result = self._values.get("zone_tags")
-        return typing.cast(typing.Optional[typing.List[ExternalDnsZoneTag]], result)
-
-    @builtins.property
-    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
-        '''Controls the types of hosted zones external-dns will create records for.
-
-        :default: ExternalDnsZoneType.ALL
+        :param length: -
         '''
-        result = self._values.get("zone_type")
-        return typing.cast(typing.Optional[ExternalDnsZoneType], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "Route53DnsOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fbb2dcf98ee84cc749c81f534e8dd19ef41782955e44c73207733837516df3f6)
+            check_type(argname="argument length", value=length, expected_type=type_hints["length"])
+        return typing.cast(IIpamPoolCidrConfiguration, jsii.sinvoke(cls, "netmask", [length]))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.Route53DnsProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, Route53DnsOptions],
+    jsii_type="cdk-extensions.ec2.IpamPoolCidrProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "api_retries": "apiRetries",
-        "batch_change_size": "batchChangeSize",
-        "domain_filter": "domainFilter",
-        "evaluate_target_health": "evaluateTargetHealth",
-        "log_format": "logFormat",
-        "log_level": "logLevel",
-        "namespace": "namespace",
-        "prefer_cname": "preferCname",
-        "record_ownership_registry": "recordOwnershipRegistry",
-        "replica_count": "replicaCount",
-        "sync_policy": "syncPolicy",
-        "zone_tags": "zoneTags",
-        "zone_type": "zoneType",
-        "cluster": "cluster",
+        "configuration": "configuration",
+        "ipam_pool": "ipamPool",
     },
 )
-class Route53DnsProps(_aws_cdk_ceddda9d.ResourceProps, Route53DnsOptions):
+class IpamPoolCidrProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        api_retries: typing.Optional[jsii.Number] = None,
-        batch_change_size: typing.Optional[jsii.Number] = None,
-        domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-        evaluate_target_health: typing.Optional[builtins.bool] = None,
-        log_format: typing.Optional[ExternalDnsLogFormat] = None,
-        log_level: typing.Optional[ExternalDnsLogLevel] = None,
-        namespace: typing.Optional[builtins.str] = None,
-        prefer_cname: typing.Optional[builtins.bool] = None,
-        record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-        replica_count: typing.Optional[jsii.Number] = None,
-        sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-        zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-        zone_type: typing.Optional[ExternalDnsZoneType] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        configuration: IIpamPoolCidrConfiguration,
+        ipam_pool: IIpamPool,
     ) -> None:
-        '''Full configuration for the Route53Dns resource.
-
+        '''
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
-        :param region: Override the default region external-dns uses when calling AWS API's.
-        :param api_retries: Maximum number of retries for AWS API calls before giving up. Default: 3
-        :param batch_change_size: Set the maximum number of changes that will be applied in each batch. Default: 1000
-        :param domain_filter: Limits possible target zones by domain suffixes.
-        :param evaluate_target_health: Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.
-        :param log_format: Sets the output format external dns will use when generating logs. Default: {@link ExternalDnsLogLevel.JSON}
-        :param log_level: Controls the verbosity of logs generated using the external-dns service. Default: {@link ExternalDnsLogLevel.INFO}
-        :param namespace: The Kubernetes namespace where the service should be deployed. Default: 'kube-system'
-        :param prefer_cname: When true, alias records will be avoided and CNAME records will be used instead. Default: false
-        :param record_ownership_registry: Registry specifying how ExternalDNS should track record ownership. Without a registry to track record ownership, External has no way to know which records it owns and manages and which are owned and managed by a different service. This can cause conflicts if there are multiple instances of External DNS running or if there are other services managing DNS records in similar zones as the different services could try to make conflicting changes due to lacking a shared state. Default: A TXT registry configured with defaults.
-        :param replica_count: Desired number of ExternalDNS replicas. Default: 1
-        :param sync_policy: Controls the operations ExternalDNS will perform on the records it manages. Default: {@link ExternalDnsSyncPolicy.SYNC}
-        :param zone_tags: A set of tags that can be used to restrict which hosted zones external DNS will make changes to.
-        :param zone_type: Controls the types of hosted zones external-dns will create records for. Default: ExternalDnsZoneType.ALL
-        :param cluster: The EKS cluster where external-dns should be deployed.
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param configuration: 
+        :param ipam_pool: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__599f1713ffc48e89808216535a31c01bf2871a0c4778c26680cb34a48861c9ff)
+            type_hints = typing.get_type_hints(_typecheckingstub__664dfe67992b369ef692d99523e907081aeb4ace3eff5712a089f8c1084f86a1)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument api_retries", value=api_retries, expected_type=type_hints["api_retries"])
-            check_type(argname="argument batch_change_size", value=batch_change_size, expected_type=type_hints["batch_change_size"])
-            check_type(argname="argument domain_filter", value=domain_filter, expected_type=type_hints["domain_filter"])
-            check_type(argname="argument evaluate_target_health", value=evaluate_target_health, expected_type=type_hints["evaluate_target_health"])
-            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
-            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-            check_type(argname="argument prefer_cname", value=prefer_cname, expected_type=type_hints["prefer_cname"])
-            check_type(argname="argument record_ownership_registry", value=record_ownership_registry, expected_type=type_hints["record_ownership_registry"])
-            check_type(argname="argument replica_count", value=replica_count, expected_type=type_hints["replica_count"])
-            check_type(argname="argument sync_policy", value=sync_policy, expected_type=type_hints["sync_policy"])
-            check_type(argname="argument zone_tags", value=zone_tags, expected_type=type_hints["zone_tags"])
-            check_type(argname="argument zone_type", value=zone_type, expected_type=type_hints["zone_type"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument configuration", value=configuration, expected_type=type_hints["configuration"])
+            check_type(argname="argument ipam_pool", value=ipam_pool, expected_type=type_hints["ipam_pool"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
+            "configuration": configuration,
+            "ipam_pool": ipam_pool,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if api_retries is not None:
-            self._values["api_retries"] = api_retries
-        if batch_change_size is not None:
-            self._values["batch_change_size"] = batch_change_size
-        if domain_filter is not None:
-            self._values["domain_filter"] = domain_filter
-        if evaluate_target_health is not None:
-            self._values["evaluate_target_health"] = evaluate_target_health
-        if log_format is not None:
-            self._values["log_format"] = log_format
-        if log_level is not None:
-            self._values["log_level"] = log_level
-        if namespace is not None:
-            self._values["namespace"] = namespace
-        if prefer_cname is not None:
-            self._values["prefer_cname"] = prefer_cname
-        if record_ownership_registry is not None:
-            self._values["record_ownership_registry"] = record_ownership_registry
-        if replica_count is not None:
-            self._values["replica_count"] = replica_count
-        if sync_policy is not None:
-            self._values["sync_policy"] = sync_policy
-        if zone_tags is not None:
-            self._values["zone_tags"] = zone_tags
-        if zone_type is not None:
-            self._values["zone_type"] = zone_type
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -6779,453 +4628,292 @@
         :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
         result = self._values.get("physical_name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
     def region(self) -> typing.Optional[builtins.str]:
-        '''Override the default region external-dns uses when calling AWS API's.'''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def api_retries(self) -> typing.Optional[jsii.Number]:
-        '''Maximum number of retries for AWS API calls before giving up.
-
-        :default: 3
-        '''
-        result = self._values.get("api_retries")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def batch_change_size(self) -> typing.Optional[jsii.Number]:
-        '''Set the maximum number of changes that will be applied in each batch.
-
-        :default: 1000
-        '''
-        result = self._values.get("batch_change_size")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def domain_filter(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''Limits possible target zones by domain suffixes.'''
-        result = self._values.get("domain_filter")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
-
-    @builtins.property
-    def evaluate_target_health(self) -> typing.Optional[builtins.bool]:
-        '''Sets a flag determining whether the health of the backend service should be evaluated when determining DNS routing.'''
-        result = self._values.get("evaluate_target_health")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def log_format(self) -> typing.Optional[ExternalDnsLogFormat]:
-        '''Sets the output format external dns will use when generating logs.
-
-        :default: {@link ExternalDnsLogLevel.JSON}
-        '''
-        result = self._values.get("log_format")
-        return typing.cast(typing.Optional[ExternalDnsLogFormat], result)
-
-    @builtins.property
-    def log_level(self) -> typing.Optional[ExternalDnsLogLevel]:
-        '''Controls the verbosity of logs generated using the external-dns service.
-
-        :default: {@link ExternalDnsLogLevel.INFO}
-        '''
-        result = self._values.get("log_level")
-        return typing.cast(typing.Optional[ExternalDnsLogLevel], result)
-
-    @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the service should be deployed.
+        '''The AWS region this resource belongs to.
 
-        :default: 'kube-system'
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("namespace")
+        result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def prefer_cname(self) -> typing.Optional[builtins.bool]:
-        '''When true, alias records will be avoided and CNAME records will be used instead.
-
-        :default: false
-        '''
-        result = self._values.get("prefer_cname")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def record_ownership_registry(self) -> typing.Optional[IExternalDnsRegistry]:
-        '''Registry specifying how ExternalDNS should track record ownership.
-
-        Without a registry to track record ownership, External has no way to know
-        which records it owns and manages and which are owned and managed by a
-        different service.
-
-        This can cause conflicts if there are multiple instances of External DNS
-        running or if there are other services managing DNS records in similar
-        zones as the different services could try to make conflicting changes due
-        to lacking a shared state.
-
-        :default: A TXT registry configured with defaults.
-        '''
-        result = self._values.get("record_ownership_registry")
-        return typing.cast(typing.Optional[IExternalDnsRegistry], result)
-
-    @builtins.property
-    def replica_count(self) -> typing.Optional[jsii.Number]:
-        '''Desired number of ExternalDNS replicas.
-
-        :default: 1
-        '''
-        result = self._values.get("replica_count")
-        return typing.cast(typing.Optional[jsii.Number], result)
-
-    @builtins.property
-    def sync_policy(self) -> typing.Optional[ExternalDnsSyncPolicy]:
-        '''Controls the operations ExternalDNS will perform on the records it manages.
-
-        :default: {@link ExternalDnsSyncPolicy.SYNC}
-        '''
-        result = self._values.get("sync_policy")
-        return typing.cast(typing.Optional[ExternalDnsSyncPolicy], result)
+    def configuration(self) -> IIpamPoolCidrConfiguration:
+        result = self._values.get("configuration")
+        assert result is not None, "Required property 'configuration' is missing"
+        return typing.cast(IIpamPoolCidrConfiguration, result)
 
     @builtins.property
-    def zone_tags(self) -> typing.Optional[typing.List[ExternalDnsZoneTag]]:
-        '''A set of tags that can be used to restrict which hosted zones external DNS will make changes to.'''
-        result = self._values.get("zone_tags")
-        return typing.cast(typing.Optional[typing.List[ExternalDnsZoneTag]], result)
-
-    @builtins.property
-    def zone_type(self) -> typing.Optional[ExternalDnsZoneType]:
-        '''Controls the types of hosted zones external-dns will create records for.
-
-        :default: ExternalDnsZoneType.ALL
-        '''
-        result = self._values.get("zone_type")
-        return typing.cast(typing.Optional[ExternalDnsZoneType], result)
-
-    @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where external-dns should be deployed.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+    def ipam_pool(self) -> IIpamPool:
+        result = self._values.get("ipam_pool")
+        assert result is not None, "Required property 'ipam_pool' is missing"
+        return typing.cast(IIpamPool, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "Route53DnsProps(%s)" % ", ".join(
+        return "IpamPoolCidrProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SecretFieldReference",
+    jsii_type="cdk-extensions.ec2.IpamPoolOptions",
     jsii_struct_bases=[],
     name_mapping={
-        "kubernetes_key": "kubernetesKey",
-        "metadata_policy": "metadataPolicy",
-        "remote_key": "remoteKey",
+        "address_configuration": "addressConfiguration",
+        "auto_import": "autoImport",
+        "consumer": "consumer",
+        "description": "description",
+        "locale": "locale",
+        "name": "name",
+        "parent_pool": "parentPool",
+        "provisioned_cidrs": "provisionedCidrs",
+        "public_ip_source": "publicIpSource",
+        "tag_restrictions": "tagRestrictions",
     },
 )
-class SecretFieldReference:
+class IpamPoolOptions:
     def __init__(
         self,
         *,
-        kubernetes_key: builtins.str,
-        metadata_policy: typing.Optional[MetadataPolicy] = None,
-        remote_key: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for how to synchronize a specific field in a secret being imported.
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional[IpamConsumer] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> None:
+        '''
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__061f4cc380e680b0f6b91b8e790f5e28364348b69f9e14707149af8856a32fb7)
+            check_type(argname="argument address_configuration", value=address_configuration, expected_type=type_hints["address_configuration"])
+            check_type(argname="argument auto_import", value=auto_import, expected_type=type_hints["auto_import"])
+            check_type(argname="argument consumer", value=consumer, expected_type=type_hints["consumer"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument locale", value=locale, expected_type=type_hints["locale"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument parent_pool", value=parent_pool, expected_type=type_hints["parent_pool"])
+            check_type(argname="argument provisioned_cidrs", value=provisioned_cidrs, expected_type=type_hints["provisioned_cidrs"])
+            check_type(argname="argument public_ip_source", value=public_ip_source, expected_type=type_hints["public_ip_source"])
+            check_type(argname="argument tag_restrictions", value=tag_restrictions, expected_type=type_hints["tag_restrictions"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if address_configuration is not None:
+            self._values["address_configuration"] = address_configuration
+        if auto_import is not None:
+            self._values["auto_import"] = auto_import
+        if consumer is not None:
+            self._values["consumer"] = consumer
+        if description is not None:
+            self._values["description"] = description
+        if locale is not None:
+            self._values["locale"] = locale
+        if name is not None:
+            self._values["name"] = name
+        if parent_pool is not None:
+            self._values["parent_pool"] = parent_pool
+        if provisioned_cidrs is not None:
+            self._values["provisioned_cidrs"] = provisioned_cidrs
+        if public_ip_source is not None:
+            self._values["public_ip_source"] = public_ip_source
+        if tag_restrictions is not None:
+            self._values["tag_restrictions"] = tag_restrictions
 
-        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
-        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
-        :param remote_key: The JSON key for the field in the secret being imported.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__85958058f60b5349b6efc3cb16e252dae2854865cf49f70b0877c64d7c4bf0dd)
-            check_type(argname="argument kubernetes_key", value=kubernetes_key, expected_type=type_hints["kubernetes_key"])
-            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
-            check_type(argname="argument remote_key", value=remote_key, expected_type=type_hints["remote_key"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "kubernetes_key": kubernetes_key,
-        }
-        if metadata_policy is not None:
-            self._values["metadata_policy"] = metadata_policy
-        if remote_key is not None:
-            self._values["remote_key"] = remote_key
+    @builtins.property
+    def address_configuration(self) -> typing.Optional[AddressConfiguration]:
+        result = self._values.get("address_configuration")
+        return typing.cast(typing.Optional[AddressConfiguration], result)
 
     @builtins.property
-    def kubernetes_key(self) -> builtins.str:
-        '''The name of the data key to be used for the field in the imported Kubernetes secret.'''
-        result = self._values.get("kubernetes_key")
-        assert result is not None, "Required property 'kubernetes_key' is missing"
-        return typing.cast(builtins.str, result)
+    def auto_import(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("auto_import")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def metadata_policy(self) -> typing.Optional[MetadataPolicy]:
-        '''Policy for fetching tags/labels from provider secrets.'''
-        result = self._values.get("metadata_policy")
-        return typing.cast(typing.Optional[MetadataPolicy], result)
+    def consumer(self) -> typing.Optional[IpamConsumer]:
+        result = self._values.get("consumer")
+        return typing.cast(typing.Optional[IpamConsumer], result)
 
     @builtins.property
-    def remote_key(self) -> typing.Optional[builtins.str]:
-        '''The JSON key for the field in the secret being imported.'''
-        result = self._values.get("remote_key")
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "SecretFieldReference(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SecretReferenceConfiguration",
-    jsii_struct_bases=[],
-    name_mapping={"remote_ref": "remoteRef", "fields": "fields"},
-)
-class SecretReferenceConfiguration:
-    def __init__(
-        self,
-        *,
-        remote_ref: builtins.str,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Configuration detailing how secrets are to be synchronized.
-
-        :param remote_ref: The ID of the secret to be imported from the provider.
-        :param fields: A mapping of fields and per field options to use when synchronizing a secret from a provider.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4dc26d0199f1602801b856583653a8b0d62418efb64456ef381f7d916080559e)
-            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
-            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "remote_ref": remote_ref,
-        }
-        if fields is not None:
-            self._values["fields"] = fields
-
     @builtins.property
-    def remote_ref(self) -> builtins.str:
-        '''The ID of the secret to be imported from the provider.'''
-        result = self._values.get("remote_ref")
-        assert result is not None, "Required property 'remote_ref' is missing"
-        return typing.cast(builtins.str, result)
+    def locale(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("locale")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
-        '''A mapping of fields and per field options to use when synchronizing a secret from a provider.'''
-        result = self._values.get("fields")
-        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "SecretReferenceConfiguration(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.implements(ISecretReference)
-class SecretsManagerReference(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReference",
-):
-    '''Defines a reference for importing and synchronizing a Secrets Manager secret to a Kubernetes secret.'''
-
-    def __init__(
-        self,
-        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Creates a new instance of the SecretsManagerReference class.
-
-        :param secret: The secret being referenced to import into Kubernetes.
-        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c496d6306c81ceef9b7062404bcf66ea260c45a38d3b69dc2f1f0a90fd9af9d2)
-            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
-        options = SecretsManagerReferenceOptions(fields=fields)
-
-        jsii.create(self.__class__, self, [secret, options])
-
-    @jsii.member(jsii_name="addFieldMapping")
-    def add_field_mapping(
-        self,
-        *,
-        kubernetes_key: builtins.str,
-        metadata_policy: typing.Optional[MetadataPolicy] = None,
-        remote_key: typing.Optional[builtins.str] = None,
-    ) -> "SecretsManagerReference":
-        '''Adds a field mapping that specifies how a field from a Secrets Manager JSON secret should be mapped into the imported Kubernetes secret.
-
-        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
-        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
-        :param remote_key: The JSON key for the field in the secret being imported.
-
-        :return: The ``SecretsManagerReference`` where the mapping was added.
-        '''
-        field = SecretFieldReference(
-            kubernetes_key=kubernetes_key,
-            metadata_policy=metadata_policy,
-            remote_key=remote_key,
-        )
-
-        return typing.cast("SecretsManagerReference", jsii.invoke(self, "addFieldMapping", [field]))
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> SecretReferenceConfiguration:
-        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.
-
-        :param _scope: The construct that will consume the generated configuration.
-
-        :return:
-
-        A configuration object providing the details needed to build
-        the external secret Kubernetes resource.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d70f039a06515082a5c4a0a4ba2130f884b4355bae0292328fb6429f6569cd96)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.List[SecretFieldReference]:
-        '''An array of field mappings which will be applied to this secret reference when mapping keys from SecretsManager JSON objects to keys in the imported secret.'''
-        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))
+    def parent_pool(self) -> typing.Optional[IIpamPool]:
+        result = self._values.get("parent_pool")
+        return typing.cast(typing.Optional[IIpamPool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="secret")
-    def secret(self) -> _aws_cdk_aws_secretsmanager_ceddda9d.ISecret:
-        '''The secret being referenced to import into Kubernetes.'''
-        return typing.cast(_aws_cdk_aws_secretsmanager_ceddda9d.ISecret, jsii.get(self, "secret"))
-
-
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SecretsManagerReferenceOptions",
-    jsii_struct_bases=[],
-    name_mapping={"fields": "fields"},
-)
-class SecretsManagerReferenceOptions:
-    def __init__(
-        self,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Configuration options for referencing a Secrets Manager secret as a Kubernetes secret.
+    def provisioned_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("provisioned_cidrs")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
-        :param fields: Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__64d4869a39ffca99e3f183351ee069c38191bab52dbb76ac1d38c8a6a23da30b)
-            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if fields is not None:
-            self._values["fields"] = fields
+    @builtins.property
+    def public_ip_source(self) -> typing.Optional["PublicIpSource"]:
+        result = self._values.get("public_ip_source")
+        return typing.cast(typing.Optional["PublicIpSource"], result)
 
     @builtins.property
-    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
-        '''Defines a mapping of how JSON keys in the Secrets Manager secret should appear in the imported Kubernetes secret.'''
-        result = self._values.get("fields")
-        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
+    def tag_restrictions(
+        self,
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        result = self._values.get("tag_restrictions")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "SecretsManagerReferenceOptions(%s)" % ", ".join(
+        return "IpamPoolOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStoreProps",
-    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    jsii_type="cdk-extensions.ec2.IpamPoolProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, IpamPoolOptions],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cluster": "cluster",
+        "address_configuration": "addressConfiguration",
+        "auto_import": "autoImport",
+        "consumer": "consumer",
+        "description": "description",
+        "locale": "locale",
         "name": "name",
-        "namespace": "namespace",
+        "parent_pool": "parentPool",
+        "provisioned_cidrs": "provisionedCidrs",
+        "public_ip_source": "publicIpSource",
+        "tag_restrictions": "tagRestrictions",
+        "ipam_scope": "ipamScope",
     },
 )
-class SecretsManagerSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
+class IpamPoolProps(_aws_cdk_ceddda9d.ResourceProps, IpamPoolOptions):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional[IpamConsumer] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
         name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        ipam_scope: IIpamScope,
     ) -> None:
-        '''Configuration options for adding a new secret store resource.
-
+        '''
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
+        :param ipam_scope: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c06248919a788c055f92881d2ef760cb61263eb20ab5280e286e3f0705f184a0)
+            type_hints = typing.get_type_hints(_typecheckingstub__ea5a2693388a6b25adff4e7abd9638424194ce86e7dfcc7a2334fde02f2e69d2)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
+            check_type(argname="argument address_configuration", value=address_configuration, expected_type=type_hints["address_configuration"])
+            check_type(argname="argument auto_import", value=auto_import, expected_type=type_hints["auto_import"])
+            check_type(argname="argument consumer", value=consumer, expected_type=type_hints["consumer"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument locale", value=locale, expected_type=type_hints["locale"])
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
+            check_type(argname="argument parent_pool", value=parent_pool, expected_type=type_hints["parent_pool"])
+            check_type(argname="argument provisioned_cidrs", value=provisioned_cidrs, expected_type=type_hints["provisioned_cidrs"])
+            check_type(argname="argument public_ip_source", value=public_ip_source, expected_type=type_hints["public_ip_source"])
+            check_type(argname="argument tag_restrictions", value=tag_restrictions, expected_type=type_hints["tag_restrictions"])
+            check_type(argname="argument ipam_scope", value=ipam_scope, expected_type=type_hints["ipam_scope"])
         self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
+            "ipam_scope": ipam_scope,
         }
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
+        if address_configuration is not None:
+            self._values["address_configuration"] = address_configuration
+        if auto_import is not None:
+            self._values["auto_import"] = auto_import
+        if consumer is not None:
+            self._values["consumer"] = consumer
+        if description is not None:
+            self._values["description"] = description
+        if locale is not None:
+            self._values["locale"] = locale
         if name is not None:
             self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
+        if parent_pool is not None:
+            self._values["parent_pool"] = parent_pool
+        if provisioned_cidrs is not None:
+            self._values["provisioned_cidrs"] = provisioned_cidrs
+        if public_ip_source is not None:
+            self._values["public_ip_source"] = public_ip_source
+        if tag_restrictions is not None:
+            self._values["tag_restrictions"] = tag_restrictions
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -7267,224 +4955,136 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret store should be created.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+    def address_configuration(self) -> typing.Optional[AddressConfiguration]:
+        result = self._values.get("address_configuration")
+        return typing.cast(typing.Optional[AddressConfiguration], result)
 
     @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A human friendly name for the secret store.'''
-        result = self._values.get("name")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def auto_import(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("auto_import")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the secret store should be created.'''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
-
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
-
-    def __repr__(self) -> str:
-        return "SecretsManagerSecretStoreProps(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
-
-
-@jsii.implements(ISecretReference)
-class SsmParameterReference(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.SsmParameterReference",
-):
-    '''Defines a reference for importing and synchronizing an SSM parameter to a Kubernetes secret.'''
-
-    def __init__(
-        self,
-        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Creates a new instance of the SsmParameterReference class.
-
-        :param parameter: The SSM parameter being referenced to import into Kubernetes.
-        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__be97b8cc9c656627b57f3db1afef2a495b5f9ef0693be3b77dd2ab818c7a14d2)
-            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
-        options = SsmParameterReferenceOptions(fields=fields)
-
-        jsii.create(self.__class__, self, [parameter, options])
-
-    @jsii.member(jsii_name="addFieldMapping")
-    def add_field_mapping(
-        self,
-        *,
-        kubernetes_key: builtins.str,
-        metadata_policy: typing.Optional[MetadataPolicy] = None,
-        remote_key: typing.Optional[builtins.str] = None,
-    ) -> "SsmParameterReference":
-        '''Adds a field mapping that specifies how a field from an SSM JSON parameter should be mapped into the imported Kubernetes secret.
-
-        :param kubernetes_key: The name of the data key to be used for the field in the imported Kubernetes secret.
-        :param metadata_policy: Policy for fetching tags/labels from provider secrets.
-        :param remote_key: The JSON key for the field in the secret being imported.
-
-        :return: The ``SsmParameterReference`` where the mapping was added.
-        '''
-        field = SecretFieldReference(
-            kubernetes_key=kubernetes_key,
-            metadata_policy=metadata_policy,
-            remote_key=remote_key,
-        )
-
-        return typing.cast("SsmParameterReference", jsii.invoke(self, "addFieldMapping", [field]))
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> SecretReferenceConfiguration:
-        '''Binds the reference to an object that is in charge of generating the manifest for the external secret.
+    def consumer(self) -> typing.Optional[IpamConsumer]:
+        result = self._values.get("consumer")
+        return typing.cast(typing.Optional[IpamConsumer], result)
 
-        :param _scope: The construct that will consume the generated configuration.
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def locale(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("locale")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        A configuration object providing the details needed to build
-        the external secret Kubernetes resource.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7147e379832a8ca243add61c65fb60f7361f398799b43de2302e5a36758d1417)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(SecretReferenceConfiguration, jsii.invoke(self, "bind", [_scope]))
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="fields")
-    def fields(self) -> typing.List[SecretFieldReference]:
-        '''An array of field mappings which will be applied to this secret reference when mapping keys from SSM parameter JSON objects to keys in the imported secret.'''
-        return typing.cast(typing.List[SecretFieldReference], jsii.get(self, "fields"))
+    def parent_pool(self) -> typing.Optional[IIpamPool]:
+        result = self._values.get("parent_pool")
+        return typing.cast(typing.Optional[IIpamPool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="parameter")
-    def parameter(self) -> _aws_cdk_aws_ssm_ceddda9d.IParameter:
-        '''The SSM parameter being referenced to import into Kubernetes.'''
-        return typing.cast(_aws_cdk_aws_ssm_ceddda9d.IParameter, jsii.get(self, "parameter"))
+    def provisioned_cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("provisioned_cidrs")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
+    @builtins.property
+    def public_ip_source(self) -> typing.Optional["PublicIpSource"]:
+        result = self._values.get("public_ip_source")
+        return typing.cast(typing.Optional["PublicIpSource"], result)
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SsmParameterReferenceOptions",
-    jsii_struct_bases=[],
-    name_mapping={"fields": "fields"},
-)
-class SsmParameterReferenceOptions:
-    def __init__(
+    @builtins.property
+    def tag_restrictions(
         self,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    ) -> None:
-        '''Configuration options for referencing an SSM parameter as a Kubernetes secret.
-
-        :param fields: Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__85f36849fed8daf98c94ff71f819a22287651f50ad8ac9fbde185a225ecf3d48)
-            check_type(argname="argument fields", value=fields, expected_type=type_hints["fields"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if fields is not None:
-            self._values["fields"] = fields
+    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
+        result = self._values.get("tag_restrictions")
+        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)
 
     @builtins.property
-    def fields(self) -> typing.Optional[typing.List[SecretFieldReference]]:
-        '''Defines a mapping of how JSON keys in the SSM parameter should appear in the imported Kubernetes secret.'''
-        result = self._values.get("fields")
-        return typing.cast(typing.Optional[typing.List[SecretFieldReference]], result)
+    def ipam_scope(self) -> IIpamScope:
+        result = self._values.get("ipam_scope")
+        assert result is not None, "Required property 'ipam_scope' is missing"
+        return typing.cast(IIpamScope, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "SsmParameterReferenceOptions(%s)" % ", ".join(
+        return "IpamPoolProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStoreProps",
+    jsii_type="cdk-extensions.ec2.IpamProps",
     jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
         "account": "account",
         "environment_from_arn": "environmentFromArn",
         "physical_name": "physicalName",
         "region": "region",
-        "cluster": "cluster",
-        "name": "name",
-        "namespace": "namespace",
+        "description": "description",
+        "regions": "regions",
     },
 )
-class SsmParameterSecretStoreProps(_aws_cdk_ceddda9d.ResourceProps):
+class IpamProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
     ) -> None:
-        '''Configuration options for adding a new secret store resource.
+        '''Configuration for the IPAM resource.
 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        :param description: The description for the IPAM.
+        :param regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__34a803d3f05acbd46634594fba4d5545e3823b2171c2f1104618a9a68b51217a)
+            type_hints = typing.get_type_hints(_typecheckingstub__10b81e5f1145574ea39d7eb21e272f73536f77bb1c6c467b098554d1a8d77cb6)
             check_type(argname="argument account", value=account, expected_type=type_hints["account"])
             check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
             check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "cluster": cluster,
-        }
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument regions", value=regions, expected_type=type_hints["regions"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
         if account is not None:
             self._values["account"] = account
         if environment_from_arn is not None:
             self._values["environment_from_arn"] = environment_from_arn
         if physical_name is not None:
             self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if name is not None:
-            self._values["name"] = name
-        if namespace is not None:
-            self._values["namespace"] = namespace
+        if description is not None:
+            self._values["description"] = description
+        if regions is not None:
+            self._values["regions"] = regions
 
     @builtins.property
     def account(self) -> typing.Optional[builtins.str]:
         '''The AWS account ID this resource belongs to.
 
         :default: - the resource is in the same account as the stack it belongs to
         '''
@@ -7526,7342 +5126,7848 @@
 
         :default: - the resource is in the same region as the stack it belongs to
         '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret store should be created.'''
-        result = self._values.get("cluster")
-        assert result is not None, "Required property 'cluster' is missing"
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, result)
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description for the IPAM.
 
-    @builtins.property
-    def name(self) -> typing.Optional[builtins.str]:
-        '''A human friendly name for the secret store.'''
-        result = self._values.get("name")
+        :see: `IPAM Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description>`_
+        '''
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def namespace(self) -> typing.Optional[builtins.str]:
-        '''The Kubernetes namespace where the secret store should be created.'''
-        result = self._values.get("namespace")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def regions(self) -> typing.Optional[typing.List[builtins.str]]:
+        '''The operating Regions for an IPAM.
+
+        Operating Regions are AWS Regions where
+        the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and
+        monitors resources in the AWS Regions you select as operating Regions.
+
+        :see: `Create an IPAM <https://docs.aws.amazon.com/vpc/latest/ipam/create-ipam.html>`_
+        '''
+        result = self._values.get("regions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "SsmParameterSecretStoreProps(%s)" % ", ".join(
+        return "IpamProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
-@jsii.implements(IExternalDnsRegistry)
-class TxtRegistry(
+@jsii.implements(IIpamResourceDiscovery)
+class IpamResourceDiscovery(
+    _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.TxtRegistry",
+    jsii_type="cdk-extensions.ec2.IpamResourceDiscovery",
 ):
-    '''An ExternalDNS registry that tracks DNS record ownership information using DNS TXT records.
-
-    :see: `About TXT records <https://support.google.com/a/answer/2716800?hl=en>`_
-    '''
-
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
         *,
-        owner_id: typing.Optional[builtins.str] = None,
-        prefix: typing.Optional[builtins.str] = None,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the NoopRegistry class.
-
-        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
-        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
         '''
-        options = TxtRegistryOptions(owner_id=owner_id, prefix=prefix)
+        :param scope: -
+        :param id: -
+        :param description: 
+        :param regions: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__71027560fa4c32a65f8c9a42c4e88c7d1f32a1b5fa58598aad99b6b612744f41)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpamResourceDiscoveryProps(
+            description=description,
+            regions=regions,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-        jsii.create(self.__class__, self, [options])
+        jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
+    @jsii.member(jsii_name="fromIpamResourceDiscoveryArn")
+    @builtins.classmethod
+    def from_ipam_resource_discovery_arn(
+        cls,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ExternalDnsRegistryConfiguration:
-        '''Generates an object with all the information needed to use the registry in a given CDK scope.
-
-        :param scope: The CDK resource that is configuring ExternalDNS.
+        id: builtins.str,
+        ipam_resource_discovery_arn: builtins.str,
+    ) -> IIpamResourceDiscovery:
+        '''Imports an existing IPAM resource discovery by specifying its Amazon Resource Name (ARN).
 
-        :return:
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_resource_discovery_arn: The ARN of the existing IPAM resource discovery to be imported.
 
-        A configuration object representing the implementation of this
-        registry.
+        :return: An object representing the imported IPAM resource discovery.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__105e23602b6d46260f139f3822144dac2ba3d98f3a079c87534a0c62c41eb507)
+            type_hints = typing.get_type_hints(_typecheckingstub__ea8e2af6623ebfc6fede9041108985a0e1f4bc7a068690c15426bd2051ff73d9)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="DEFAULT_PREFIX")
-    def DEFAULT_PREFIX(cls) -> builtins.str:
-        '''The default prefix to append to TXT ownership records creates for the registry.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_PREFIX"))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="NO_PREFIX")
-    def NO_PREFIX(cls) -> builtins.str:
-        '''A special value that specifies ExternalDNS should not use any prefix when creating TXT ownership records.
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_resource_discovery_arn", value=ipam_resource_discovery_arn, expected_type=type_hints["ipam_resource_discovery_arn"])
+        return typing.cast(IIpamResourceDiscovery, jsii.sinvoke(cls, "fromIpamResourceDiscoveryArn", [scope, id, ipam_resource_discovery_arn]))
 
-        This is not recommended as it is likely to cause issues with record
-        creation and management with some record types that do not allow other
-        records with the same name and different types to exist (CNAME's).
+    @jsii.member(jsii_name="fromIpamResourceDiscoveryAttributes")
+    @builtins.classmethod
+    def from_ipam_resource_discovery_attributes(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        is_default: typing.Optional[builtins.bool] = None,
+        owner_id: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        resource_discovery_arn: typing.Optional[builtins.str] = None,
+        resource_discovery_id: typing.Optional[builtins.str] = None,
+        state: typing.Optional[builtins.str] = None,
+    ) -> IIpamResourceDiscovery:
+        '''Imports an existing IPAM resource discovery by explicitly specifying its attributes.
+
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param is_default: 
+        :param owner_id: 
+        :param region: 
+        :param resource_discovery_arn: 
+        :param resource_discovery_id: 
+        :param state: 
 
-        However, if this behavior is desired this value can be passed as the
-        prefix to override the default behavior with will set a prefix if none
-        is provided as input.
+        :return: An object representing the imported IPAM resource discovery.
         '''
-        return typing.cast(builtins.str, jsii.sget(cls, "NO_PREFIX"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__57b4066a1554d13ec3de7912e54640267313c350bae201bd366576707917edbc)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        attrs = IpamResourceDiscoveryAttributes(
+            is_default=is_default,
+            owner_id=owner_id,
+            region=region,
+            resource_discovery_arn=resource_discovery_arn,
+            resource_discovery_id=resource_discovery_id,
+            state=state,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="registryType")
-    def registry_type(self) -> builtins.str:
-        '''The type name of ExternalDNS registry.'''
-        return typing.cast(builtins.str, jsii.get(self, "registryType"))
+        return typing.cast(IIpamResourceDiscovery, jsii.sinvoke(cls, "fromIpamResourceDiscoveryAttributes", [scope, id, attrs]))
 
-    @builtins.property
-    @jsii.member(jsii_name="ownerId")
-    def owner_id(self) -> typing.Optional[builtins.str]:
-        '''A unique identifier that is used to establish ownership of managed DNS records.
+    @jsii.member(jsii_name="fromIpamResourceDiscoveryId")
+    @builtins.classmethod
+    def from_ipam_resource_discovery_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        ipam_resource_discovery_id: builtins.str,
+    ) -> IIpamResourceDiscovery:
+        '''Imports an existing IPAM resource discovery by explicitly specifying its AWS generated ID.
 
-        Prevents conflicts in the event of multiple clusters running external-dns.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_resource_discovery_id: The AWS generated ID of the existing IPAM resource discovery to be imported.
 
-        :group: Inputs
+        :return: An object representing the imported IPAM resource discovery.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ownerId"))
-
-    @builtins.property
-    @jsii.member(jsii_name="prefix")
-    def prefix(self) -> typing.Optional[builtins.str]:
-        '''A prefix to be added top TXT ownership records.
-
-        By default, the ownership record is a TXT record with the same name as the
-        managed record that was created. This causes issues as some record types
-        (CNAME's) do not allow duplicate records of a different type.
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__6e99343677a106a86300ba3a771df4a8f868464d143c4fb1acd63f95313e2276)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_resource_discovery_id", value=ipam_resource_discovery_id, expected_type=type_hints["ipam_resource_discovery_id"])
+        return typing.cast(IIpamResourceDiscovery, jsii.sinvoke(cls, "fromIpamResourceDiscoveryId", [scope, id, ipam_resource_discovery_id]))
 
-        This prefix is used to prevent such name collissions while still allowing
-        DNS ownership records to be created.
+    @jsii.member(jsii_name="addIpam")
+    def add_ipam(
+        self,
+        id: builtins.str,
+        *,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> IIpam:
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "prefix"))
+        :param id: -
+        :param description: The description for the IPAM.
+        :param regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e687a9c82d39b4816bcb8181beeb34fa78ade11ccb9883598d96a6fabe978893)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamProps(
+            description=description,
+            regions=regions,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
+        return typing.cast(IIpam, jsii.invoke(self, "addIpam", [id, options]))
 
-@jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.TxtRegistryOptions",
-    jsii_struct_bases=[],
-    name_mapping={"owner_id": "ownerId", "prefix": "prefix"},
-)
-class TxtRegistryOptions:
-    def __init__(
-        self,
-        *,
-        owner_id: typing.Optional[builtins.str] = None,
-        prefix: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Configuration options for setting up a TXT registry for ExternalDNS.
+    @jsii.member(jsii_name="addRegion")
+    def add_region(self, region: builtins.str) -> None:
+        '''
+        :param region: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7899a22c8f823f15fea279d534d9b1124d0e6dc669ea76eca0f521dfe2fd0e98)
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+        return typing.cast(None, jsii.invoke(self, "addRegion", [region]))
 
-        :param owner_id: A unique identifier that is used to establish ownership of managed DNS records. Prevents conflicts in the event of multiple clusters running external-dns. Default: Unique address of the owning CDK node.
-        :param prefix: A prefix to be added top TXT ownership records. By default, the ownership record is a TXT record with the same name as the managed record that was created. This causes issues as some record types (CNAME's) do not allow duplicate records of a different type. This prefix is used to prevent such name collissions while still allowing DNS ownership records to be created. Default: 'edns.''
+    @jsii.member(jsii_name="associateIpam")
+    def associate_ipam(self, ipam: IIpam) -> IIpamResourceDiscoveryAssociation:
+        '''
+        :param ipam: -
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__49d222934bd8c2c391090725600916ef04457ba131b293ef18b5254a232b8e55)
-            check_type(argname="argument owner_id", value=owner_id, expected_type=type_hints["owner_id"])
-            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if owner_id is not None:
-            self._values["owner_id"] = owner_id
-        if prefix is not None:
-            self._values["prefix"] = prefix
+            type_hints = typing.get_type_hints(_typecheckingstub__711ba854c1e0329bf19749b97e1ccf49b8cf344550e5bf80368d997cad106847)
+            check_type(argname="argument ipam", value=ipam, expected_type=type_hints["ipam"])
+        return typing.cast(IIpamResourceDiscoveryAssociation, jsii.invoke(self, "associateIpam", [ipam]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ARN_FORMAT")
+    def ARN_FORMAT(cls) -> _aws_cdk_ceddda9d.ArnFormat:
+        '''The format for Amazon Resource Names (ARN's) for IPAM resource discovery resources.'''
+        return typing.cast(_aws_cdk_ceddda9d.ArnFormat, jsii.sget(cls, "ARN_FORMAT"))
 
     @builtins.property
-    def owner_id(self) -> typing.Optional[builtins.str]:
-        '''A unique identifier that is used to establish ownership of managed DNS records.
+    @jsii.member(jsii_name="ipamResourceDiscoveryArn")
+    def ipam_resource_discovery_arn(self) -> builtins.str:
+        '''The resource discovery ARN.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryArn"))
 
-        Prevents conflicts in the event of multiple clusters running external-dns.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryId")
+    def ipam_resource_discovery_id(self) -> builtins.str:
+        '''The resource discovery ID.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryId"))
 
-        :default: Unique address of the owning CDK node.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryIsDefault")
+    def ipam_resource_discovery_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the resource discovery is the default.
+
+        The default resource
+        discovery is the resource discovery automatically created when you create
+        an IPAM.
         '''
-        result = self._values.get("owner_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamResourceDiscoveryIsDefault"))
 
     @builtins.property
-    def prefix(self) -> typing.Optional[builtins.str]:
-        '''A prefix to be added top TXT ownership records.
+    @jsii.member(jsii_name="ipamResourceDiscoveryOwnerId")
+    def ipam_resource_discovery_owner_id(self) -> builtins.str:
+        '''The owner ID.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryOwnerId"))
 
-        By default, the ownership record is a TXT record with the same name as the
-        managed record that was created. This causes issues as some record types
-        (CNAME's) do not allow duplicate records of a different type.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryRegion")
+    def ipam_resource_discovery_region(self) -> builtins.str:
+        '''The resource discovery Region.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryRegion"))
 
-        This prefix is used to prevent such name collissions while still allowing
-        DNS ownership records to be created.
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryState")
+    def ipam_resource_discovery_state(self) -> builtins.str:
+        '''The resource discovery's state.
 
-        :default: 'edns.''
+        - create-in-progress - Resource discovery is being created.
+        - create-complete - Resource discovery creation is complete.
+        - create-failed - Resource discovery creation has failed.
+        - modify-in-progress - Resource discovery is being modified.
+        - modify-complete - Resource discovery modification is complete.
+        - modify-failed - Resource discovery modification has failed.
+        - delete-in-progress - Resource discovery is being deleted.
+        - delete-complete - Resource discovery deletion is complete.
+        - delete-failed - Resource discovery deletion has failed.
+        - isolate-in-progress - AWS account that created the resource discovery
+          has been removed and the resource discovery is being isolated.
+        - isolate-complete - Resource discovery isolation is complete.
+        - restore-in-progress - AWS account that created the resource discovery
+          and was isolated has been restored.
         '''
-        result = self._values.get("prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryState"))
 
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="regions")
+    def regions(self) -> typing.List[builtins.str]:
+        return typing.cast(typing.List[builtins.str], jsii.get(self, "regions"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMResourceDiscovery:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMResourceDiscovery, jsii.get(self, "resource"))
 
-    def __repr__(self) -> str:
-        return "TxtRegistryOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
 
-@jsii.implements(ISecretStore)
-class AwsSecretStore(
+@jsii.implements(IIpamResourceDiscoveryAssociation)
+class IpamResourceDiscoveryAssociation(
     _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.AwsSecretStore",
+    jsii_type="cdk-extensions.ec2.IpamResourceDiscoveryAssociation",
 ):
-    '''A generic class representing secret store that is backed by an AWS service.'''
-
     def __init__(
         self,
-        scope: _constructs_77d1e7e8.Construct,
+        scope: _constructs_77d1e7e8.IConstruct,
         id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        service: builtins.str,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        ipam: IIpam,
+        ipam_resource_discovery: IIpamResourceDiscovery,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the AwsSecretStore class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param service: The name of the service provider backing the secret store.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        '''
+        :param scope: -
+        :param id: -
+        :param ipam: 
+        :param ipam_resource_discovery: 
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a5db7e3c7776867e619b3b5a59436e82e10ef7dd279ce473dba2df2bc999988b)
+            type_hints = typing.get_type_hints(_typecheckingstub__501f8b5a36c021031daa8db977a3a96bb8f5e6f6f3800fd94f093a381bcf80ca)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = AwsSecretStoreProps(
-            cluster=cluster,
-            service=service,
-            name=name,
-            namespace=namespace,
+        props = IpamResourceDiscoveryAssociationProps(
+            ipam=ipam,
+            ipam_resource_discovery=ipam_resource_discovery,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="NAME_VALIDATOR_REGEX")
-    def NAME_VALIDATOR_REGEX(cls) -> builtins.str:
-        '''The regex pattern used to validate secret store names.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "NAME_VALIDATOR_REGEX"))
-
     @builtins.property
-    @jsii.member(jsii_name="cluster")
-    def cluster(self) -> _aws_cdk_aws_eks_ceddda9d.ICluster:
-        '''The EKS cluster where the secret store should be created.
-
-        :group: Inputs
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ICluster, jsii.get(self, "cluster"))
+    @jsii.member(jsii_name="ipam")
+    def ipam(self) -> IIpam:
+        return typing.cast(IIpam, jsii.get(self, "ipam"))
 
     @builtins.property
-    @jsii.member(jsii_name="manifest")
-    def manifest(self) -> _aws_cdk_aws_eks_ceddda9d.KubernetesManifest:
-        '''The Kubernetes manifest that defines the secret store.
-
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.KubernetesManifest, jsii.get(self, "manifest"))
+    @jsii.member(jsii_name="ipamResourceDiscovery")
+    def ipam_resource_discovery(self) -> IIpamResourceDiscovery:
+        return typing.cast(IIpamResourceDiscovery, jsii.get(self, "ipamResourceDiscovery"))
 
     @builtins.property
-    @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''A human friendly name for the secret store.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationArn")
+    def ipam_resource_discovery_association_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="namespace")
-    def namespace(self) -> builtins.str:
-        '''The Kubernetes namespace where the secret store should be created.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "namespace"))
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationId")
+    def ipam_resource_discovery_association_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationId"))
 
     @builtins.property
-    @jsii.member(jsii_name="secretStoreName")
-    def secret_store_name(self) -> builtins.str:
-        '''The name of the secret store as it appears in Kubernetes.'''
-        return typing.cast(builtins.str, jsii.get(self, "secretStoreName"))
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamArn")
+    def ipam_resource_discovery_association_ipam_arn(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationIpamArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="service")
-    def service(self) -> builtins.str:
-        '''The name of the service provider backing the secret store.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "service"))
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIpamRegion")
+    def ipam_resource_discovery_association_ipam_region(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationIpamRegion"))
 
     @builtins.property
-    @jsii.member(jsii_name="serviceAccount")
-    def service_account(self) -> _aws_cdk_aws_eks_ceddda9d.ServiceAccount:
-        '''A Kubernetes service account mapped to an IAM role that provides the necessary permissions to sychronize secrets from an AWS rpvoder.
-
-        :group: Resources
-        '''
-        return typing.cast(_aws_cdk_aws_eks_ceddda9d.ServiceAccount, jsii.get(self, "serviceAccount"))
-
-
-@jsii.implements(IExternalDnsRegistry)
-class AwsServiceDiscoveryRegistry(
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.AwsServiceDiscoveryRegistry",
-):
-    '''An ExternalDNS registry that tracks DNS record ownership information using AWS Service Discovery.
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationIsDefault")
+    def ipam_resource_discovery_association_is_default(
+        self,
+    ) -> _aws_cdk_ceddda9d.IResolvable:
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamResourceDiscoveryAssociationIsDefault"))
 
-    :see: `AWS Cloud Map <https://docs.aws.amazon.com/cloud-map/latest/dg/what-is-cloud-map.html>`_
-    '''
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationOwnerId")
+    def ipam_resource_discovery_association_owner_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationOwnerId"))
 
-    def __init__(self) -> None:
-        '''Creates a new instance of the AwsServiceDiscoveryRegistry class.'''
-        jsii.create(self.__class__, self, [])
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryId")
+    def ipam_resource_discovery_association_resource_discovery_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationResourceDiscoveryId"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationResourceDiscoveryStatus")
+    def ipam_resource_discovery_association_resource_discovery_status(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ExternalDnsRegistryConfiguration:
-        '''Generates an object with all the information needed to use the registry in a given CDK scope.
-
-        :param scope: The CDK resource that is configuring ExternalDNS.
-
-        :return:
+    ) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationResourceDiscoveryStatus"))
 
-        A configuration object representing the implementation of this
-        registry.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b365e8ec462c9d5a06a032056dcf37739fad6ac73b424fbd4e54e70dd68eca9d)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ExternalDnsRegistryConfiguration, jsii.invoke(self, "bind", [scope]))
+    @builtins.property
+    @jsii.member(jsii_name="ipamResourceDiscoveryAssociationState")
+    def ipam_resource_discovery_association_state(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "ipamResourceDiscoveryAssociationState"))
 
     @builtins.property
-    @jsii.member(jsii_name="registryType")
-    def registry_type(self) -> builtins.str:
-        '''The type name of ExternalDNS registry.'''
-        return typing.cast(builtins.str, jsii.get(self, "registryType"))
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMResourceDiscoveryAssociation:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMResourceDiscoveryAssociation, jsii.get(self, "resource"))
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitCloudWatchLogsOutputOptions",
-    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.IpamResourceDiscoveryAssociationProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
-        "match": "match",
-        "auto_create_group": "autoCreateGroup",
-        "auto_retry_requests": "autoRetryRequests",
-        "endpoint": "endpoint",
-        "log_format": "logFormat",
-        "log_group": "logGroup",
-        "log_group_template": "logGroupTemplate",
-        "log_key": "logKey",
-        "log_retention": "logRetention",
-        "log_stream": "logStream",
-        "log_stream_template": "logStreamTemplate",
-        "metric_dimensions": "metricDimensions",
-        "metric_namespace": "metricNamespace",
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
         "region": "region",
-        "role": "role",
-        "sts_endpoint": "stsEndpoint",
+        "ipam": "ipam",
+        "ipam_resource_discovery": "ipamResourceDiscovery",
     },
 )
-class FluentBitCloudWatchLogsOutputOptions(FluentBitOutputPluginCommonOptions):
+class IpamResourceDiscoveryAssociationProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        auto_create_group: typing.Optional[builtins.bool] = None,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_format: typing.Optional[builtins.str] = None,
-        log_group: typing.Optional[FluentBitLogGroupOutput] = None,
-        log_group_template: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
-        log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
-        log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
-        log_stream_template: typing.Optional[builtins.str] = None,
-        metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        metric_namespace: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
+        ipam: IIpam,
+        ipam_resource_discovery: IIpamResourceDiscovery,
     ) -> None:
-        '''Options for configuring the CloudWatch Logs Fluent Bit output plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param auto_create_group: Automatically create the log group. Default: false
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param endpoint: Specify a custom endpoint for the CloudWatch Logs API.
-        :param log_format: An optional parameter that can be used to tell CloudWatch the format of the data. A value of json/emf enables CloudWatch to extract custom metrics embedded in a JSON payload.
-        :param log_group: The CloudWatch Log Group configuration for output records.
-        :param log_group_template: Template for Log Group name using Fluent Bit record_accessor syntax. This field is optional and if configured it overrides the configured Log Group. If the template translation fails, an error is logged and the provided Log Group (which is still required) is used instead.
-        :param log_key: By default, the whole log record will be sent to CloudWatch. If you specify a key name with this option, then only the value of that key will be sent to CloudWatch.
-        :param log_retention: If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
-        :param log_stream: The CloudWatch LogStream configuration for outbound records.
-        :param log_stream_template: Template for Log Stream name using Fluent Bit record accessor syntax. This field is optional and if configured it overrides the other log stream options. If the template translation fails, an error is logged and the logStream or logStreamPrefix are used instead (and thus one of those fields is still required to be configured).
-        :param metric_dimensions: A list of lists containing the dimension keys that will be applied to all metrics. The values within a dimension set MUST also be members on the root-node.
-        :param metric_namespace: An optional string representing the CloudWatch namespace for the metrics.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-
-        :see: `CloudWatch Logs Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0a6ddb803ae38cffafb281e286ceb82c9d46f01f71cc1c19883463d5671ffb62)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument auto_create_group", value=auto_create_group, expected_type=type_hints["auto_create_group"])
-            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
-            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
-            check_type(argname="argument log_format", value=log_format, expected_type=type_hints["log_format"])
-            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
-            check_type(argname="argument log_group_template", value=log_group_template, expected_type=type_hints["log_group_template"])
-            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
-            check_type(argname="argument log_retention", value=log_retention, expected_type=type_hints["log_retention"])
-            check_type(argname="argument log_stream", value=log_stream, expected_type=type_hints["log_stream"])
-            check_type(argname="argument log_stream_template", value=log_stream_template, expected_type=type_hints["log_stream_template"])
-            check_type(argname="argument metric_dimensions", value=metric_dimensions, expected_type=type_hints["metric_dimensions"])
-            check_type(argname="argument metric_namespace", value=metric_namespace, expected_type=type_hints["metric_namespace"])
+        '''
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param ipam: 
+        :param ipam_resource_discovery: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__cdc08bda216ca133f887348a17c9ffedb62d0f71c106e0553aefe0df4a1f924d)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if auto_create_group is not None:
-            self._values["auto_create_group"] = auto_create_group
-        if auto_retry_requests is not None:
-            self._values["auto_retry_requests"] = auto_retry_requests
-        if endpoint is not None:
-            self._values["endpoint"] = endpoint
-        if log_format is not None:
-            self._values["log_format"] = log_format
-        if log_group is not None:
-            self._values["log_group"] = log_group
-        if log_group_template is not None:
-            self._values["log_group_template"] = log_group_template
-        if log_key is not None:
-            self._values["log_key"] = log_key
-        if log_retention is not None:
-            self._values["log_retention"] = log_retention
-        if log_stream is not None:
-            self._values["log_stream"] = log_stream
-        if log_stream_template is not None:
-            self._values["log_stream_template"] = log_stream_template
-        if metric_dimensions is not None:
-            self._values["metric_dimensions"] = metric_dimensions
-        if metric_namespace is not None:
-            self._values["metric_namespace"] = metric_namespace
+            check_type(argname="argument ipam", value=ipam, expected_type=type_hints["ipam"])
+            check_type(argname="argument ipam_resource_discovery", value=ipam_resource_discovery, expected_type=type_hints["ipam_resource_discovery"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "ipam": ipam,
+            "ipam_resource_discovery": ipam_resource_discovery,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if role is not None:
-            self._values["role"] = role
-        if sts_endpoint is not None:
-            self._values["sts_endpoint"] = sts_endpoint
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
 
     @builtins.property
-    def auto_create_group(self) -> typing.Optional[builtins.bool]:
-        '''Automatically create the log group.
-
-        :default: false
-        '''
-        result = self._values.get("auto_create_group")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
-
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :default: true
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        result = self._values.get("auto_retry_requests")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the CloudWatch Logs API.'''
-        result = self._values.get("endpoint")
+        result = self._values.get("account")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_format(self) -> typing.Optional[builtins.str]:
-        '''An optional parameter that can be used to tell CloudWatch the format of the data.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        A value of json/emf enables CloudWatch to extract custom
-        metrics embedded in a JSON payload.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        :see: `Embedded Metric Format <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html>`_
+        Cannot be supplied together with either ``account`` or ``region``.
+
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        result = self._values.get("log_format")
+        result = self._values.get("environment_from_arn")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_group(self) -> typing.Optional[FluentBitLogGroupOutput]:
-        '''The CloudWatch Log Group configuration for output records.'''
-        result = self._values.get("log_group")
-        return typing.cast(typing.Optional[FluentBitLogGroupOutput], result)
-
-    @builtins.property
-    def log_group_template(self) -> typing.Optional[builtins.str]:
-        '''Template for Log Group name using Fluent Bit record_accessor syntax.
-
-        This field is optional and if configured it overrides the configured Log
-        Group.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        If the template translation fails, an error is logged and the provided
-        Log Group (which is still required) is used instead.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        result = self._values.get("log_group_template")
+        result = self._values.get("physical_name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to CloudWatch.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to CloudWatch.
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("log_key")
+        result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_retention(
-        self,
-    ) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays]:
-        '''If set to a number greater than zero, and newly create log group's retention policy is set to this many days.'''
-        result = self._values.get("log_retention")
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays], result)
-
-    @builtins.property
-    def log_stream(self) -> typing.Optional[FluentBitLogStreamOutput]:
-        '''The CloudWatch LogStream configuration for outbound records.'''
-        result = self._values.get("log_stream")
-        return typing.cast(typing.Optional[FluentBitLogStreamOutput], result)
+    def ipam(self) -> IIpam:
+        result = self._values.get("ipam")
+        assert result is not None, "Required property 'ipam' is missing"
+        return typing.cast(IIpam, result)
 
     @builtins.property
-    def log_stream_template(self) -> typing.Optional[builtins.str]:
-        '''Template for Log Stream name using Fluent Bit record accessor syntax.
+    def ipam_resource_discovery(self) -> IIpamResourceDiscovery:
+        result = self._values.get("ipam_resource_discovery")
+        assert result is not None, "Required property 'ipam_resource_discovery' is missing"
+        return typing.cast(IIpamResourceDiscovery, result)
 
-        This field is optional and if configured it overrides the other log
-        stream options. If the template translation fails, an error is logged
-        and the logStream or logStreamPrefix are used instead (and thus one of
-        those fields is still required to be configured).
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
-        '''
-        result = self._values.get("log_stream_template")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    def metric_dimensions(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''A list of lists containing the dimension keys that will be applied to all metrics.
+    def __repr__(self) -> str:
+        return "IpamResourceDiscoveryAssociationProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        The values within a dimension set MUST also be members on
-        the root-node.
 
-        :see: `Dimensions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension>`_
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.IpamResourceDiscoveryAttributes",
+    jsii_struct_bases=[],
+    name_mapping={
+        "is_default": "isDefault",
+        "owner_id": "ownerId",
+        "region": "region",
+        "resource_discovery_arn": "resourceDiscoveryArn",
+        "resource_discovery_id": "resourceDiscoveryId",
+        "state": "state",
+    },
+)
+class IpamResourceDiscoveryAttributes:
+    def __init__(
+        self,
+        *,
+        is_default: typing.Optional[builtins.bool] = None,
+        owner_id: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        resource_discovery_arn: typing.Optional[builtins.str] = None,
+        resource_discovery_id: typing.Optional[builtins.str] = None,
+        state: typing.Optional[builtins.str] = None,
+    ) -> None:
         '''
-        result = self._values.get("metric_dimensions")
-        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
+        :param is_default: 
+        :param owner_id: 
+        :param region: 
+        :param resource_discovery_arn: 
+        :param resource_discovery_id: 
+        :param state: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bfe8ddca2aa37f07665bc994257efce3c571bea8f2042fba22c0e32f876e6be4)
+            check_type(argname="argument is_default", value=is_default, expected_type=type_hints["is_default"])
+            check_type(argname="argument owner_id", value=owner_id, expected_type=type_hints["owner_id"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument resource_discovery_arn", value=resource_discovery_arn, expected_type=type_hints["resource_discovery_arn"])
+            check_type(argname="argument resource_discovery_id", value=resource_discovery_id, expected_type=type_hints["resource_discovery_id"])
+            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if is_default is not None:
+            self._values["is_default"] = is_default
+        if owner_id is not None:
+            self._values["owner_id"] = owner_id
+        if region is not None:
+            self._values["region"] = region
+        if resource_discovery_arn is not None:
+            self._values["resource_discovery_arn"] = resource_discovery_arn
+        if resource_discovery_id is not None:
+            self._values["resource_discovery_id"] = resource_discovery_id
+        if state is not None:
+            self._values["state"] = state
 
     @builtins.property
-    def metric_namespace(self) -> typing.Optional[builtins.str]:
-        '''An optional string representing the CloudWatch namespace for the metrics.
+    def is_default(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("is_default")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        :see: `Metric Tutorial <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch#metrics-tutorial>`_
-        '''
-        result = self._values.get("metric_namespace")
+    @builtins.property
+    def owner_id(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("owner_id")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
     def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.'''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).'''
-        result = self._values.get("role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+    def resource_discovery_arn(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("resource_discovery_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def resource_discovery_id(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("resource_discovery_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.'''
-        result = self._values.get("sts_endpoint")
+    def state(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("state")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitCloudWatchLogsOutputOptions(%s)" % ", ".join(
+        return "IpamResourceDiscoveryAttributes(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitElasticsearchOutputOptions",
-    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.IpamResourceDiscoveryProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
     name_mapping={
-        "match": "match",
-        "host": "host",
-        "aws_auth": "awsAuth",
-        "aws_external_id": "awsExternalId",
-        "aws_region": "awsRegion",
-        "aws_role": "awsRole",
-        "aws_sts_endpoint": "awsStsEndpoint",
-        "buffer_size": "bufferSize",
-        "cloud_auth": "cloudAuth",
-        "cloud_id": "cloudId",
-        "compress": "compress",
-        "current_time_index": "currentTimeIndex",
-        "generate_id": "generateId",
-        "http_passwd": "httpPasswd",
-        "http_user": "httpUser",
-        "id_key": "idKey",
-        "include_tag_key": "includeTagKey",
-        "index": "index",
-        "logstash_date_format": "logstashDateFormat",
-        "logstash_format": "logstashFormat",
-        "logstash_prefix": "logstashPrefix",
-        "logstash_prefix_key": "logstashPrefixKey",
-        "path": "path",
-        "pipeline": "pipeline",
-        "port": "port",
-        "replace_dots": "replaceDots",
-        "suppress_type_name": "suppressTypeName",
-        "tag_key": "tagKey",
-        "time_key": "timeKey",
-        "time_key_format": "timeKeyFormat",
-        "time_key_nanos": "timeKeyNanos",
-        "trace_error": "traceError",
-        "trace_output": "traceOutput",
-        "type": "type",
-        "workers": "workers",
-        "write_operation": "writeOperation",
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "description": "description",
+        "regions": "regions",
     },
 )
-class FluentBitElasticsearchOutputOptions(FluentBitOutputPluginCommonOptions):
+class IpamResourceDiscoveryProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        host: builtins.str,
-        aws_auth: typing.Optional[builtins.bool] = None,
-        aws_external_id: typing.Optional[builtins.str] = None,
-        aws_region: typing.Optional[builtins.str] = None,
-        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        aws_sts_endpoint: typing.Optional[builtins.str] = None,
-        buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
-        cloud_auth: typing.Optional[builtins.str] = None,
-        cloud_id: typing.Optional[builtins.str] = None,
-        compress: typing.Optional[ElasticsearchCompressionFormat] = None,
-        current_time_index: typing.Optional[builtins.bool] = None,
-        generate_id: typing.Optional[builtins.bool] = None,
-        http_passwd: typing.Optional[builtins.str] = None,
-        http_user: typing.Optional[builtins.str] = None,
-        id_key: typing.Optional[builtins.str] = None,
-        include_tag_key: typing.Optional[builtins.bool] = None,
-        index: typing.Optional[builtins.str] = None,
-        logstash_date_format: typing.Optional[builtins.str] = None,
-        logstash_format: typing.Optional[builtins.bool] = None,
-        logstash_prefix: typing.Optional[builtins.str] = None,
-        logstash_prefix_key: typing.Optional[builtins.str] = None,
-        path: typing.Optional[builtins.str] = None,
-        pipeline: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replace_dots: typing.Optional[builtins.bool] = None,
-        suppress_type_name: typing.Optional[builtins.bool] = None,
-        tag_key: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        time_key_nanos: typing.Optional[builtins.bool] = None,
-        trace_error: typing.Optional[builtins.bool] = None,
-        trace_output: typing.Optional[builtins.bool] = None,
-        type: typing.Optional[builtins.str] = None,
-        workers: typing.Optional[jsii.Number] = None,
-        write_operation: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the Elasticsearch Fluent Bit output plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param host: IP address or hostname of the target Elasticsearch instance.
-        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service. Default: false
-        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
-        :param aws_region: Specify the AWS region for Elasticsearch Service.
-        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
-        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
-        :param buffer_size: Specify the buffer size used to read the response from the Elasticsearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
-        :param cloud_auth: Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
-        :param cloud_id: If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
-        :param compress: Set payload compression mechanism.
-        :param current_time_index: Use current time for index generation instead of message record. Default: false
-        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
-        :param http_passwd: Password for user defined in ``httpUser``.
-        :param http_user: Optional username credential for access.
-        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
-        :param include_tag_key: When enabled, it append the Tag name to the record.
-        :param index: Index name. Default: 'fluent-bit
-        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
-        :param logstash_format: Enable Logstash format compatibility. Default: false
-        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
-        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
-        :param path: Elasticsearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
-        :param pipeline: Elasticsearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
-        :param port: TCP port of the target Elasticsearch instance. Default: 9200
-        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
-        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
-        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
-        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
-        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
-        :param trace_error: When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only). Default: false
-        :param trace_output: When enabled print the Elasticsearch API calls to stdout (for diag only). Default: false
-        :param type: Type name. Default: '_doc'
-        :param workers: Enables dedicated thread(s) for this output. Default: 2
-        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
-
-        :see: `Opensearch Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/elasticsearch>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d15707b98b30fc02a4da2bf5ff3f6fab3135470fb1fbfa8644ad8ebe83173635)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
-            check_type(argname="argument aws_auth", value=aws_auth, expected_type=type_hints["aws_auth"])
-            check_type(argname="argument aws_external_id", value=aws_external_id, expected_type=type_hints["aws_external_id"])
-            check_type(argname="argument aws_region", value=aws_region, expected_type=type_hints["aws_region"])
-            check_type(argname="argument aws_role", value=aws_role, expected_type=type_hints["aws_role"])
-            check_type(argname="argument aws_sts_endpoint", value=aws_sts_endpoint, expected_type=type_hints["aws_sts_endpoint"])
-            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
-            check_type(argname="argument cloud_auth", value=cloud_auth, expected_type=type_hints["cloud_auth"])
-            check_type(argname="argument cloud_id", value=cloud_id, expected_type=type_hints["cloud_id"])
-            check_type(argname="argument compress", value=compress, expected_type=type_hints["compress"])
-            check_type(argname="argument current_time_index", value=current_time_index, expected_type=type_hints["current_time_index"])
-            check_type(argname="argument generate_id", value=generate_id, expected_type=type_hints["generate_id"])
-            check_type(argname="argument http_passwd", value=http_passwd, expected_type=type_hints["http_passwd"])
-            check_type(argname="argument http_user", value=http_user, expected_type=type_hints["http_user"])
-            check_type(argname="argument id_key", value=id_key, expected_type=type_hints["id_key"])
-            check_type(argname="argument include_tag_key", value=include_tag_key, expected_type=type_hints["include_tag_key"])
-            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
-            check_type(argname="argument logstash_date_format", value=logstash_date_format, expected_type=type_hints["logstash_date_format"])
-            check_type(argname="argument logstash_format", value=logstash_format, expected_type=type_hints["logstash_format"])
-            check_type(argname="argument logstash_prefix", value=logstash_prefix, expected_type=type_hints["logstash_prefix"])
-            check_type(argname="argument logstash_prefix_key", value=logstash_prefix_key, expected_type=type_hints["logstash_prefix_key"])
-            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
-            check_type(argname="argument pipeline", value=pipeline, expected_type=type_hints["pipeline"])
-            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
-            check_type(argname="argument replace_dots", value=replace_dots, expected_type=type_hints["replace_dots"])
-            check_type(argname="argument suppress_type_name", value=suppress_type_name, expected_type=type_hints["suppress_type_name"])
-            check_type(argname="argument tag_key", value=tag_key, expected_type=type_hints["tag_key"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
-            check_type(argname="argument time_key_nanos", value=time_key_nanos, expected_type=type_hints["time_key_nanos"])
-            check_type(argname="argument trace_error", value=trace_error, expected_type=type_hints["trace_error"])
-            check_type(argname="argument trace_output", value=trace_output, expected_type=type_hints["trace_output"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-            check_type(argname="argument workers", value=workers, expected_type=type_hints["workers"])
-            check_type(argname="argument write_operation", value=write_operation, expected_type=type_hints["write_operation"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "host": host,
-        }
-        if match is not None:
-            self._values["match"] = match
-        if aws_auth is not None:
-            self._values["aws_auth"] = aws_auth
-        if aws_external_id is not None:
-            self._values["aws_external_id"] = aws_external_id
-        if aws_region is not None:
-            self._values["aws_region"] = aws_region
-        if aws_role is not None:
-            self._values["aws_role"] = aws_role
-        if aws_sts_endpoint is not None:
-            self._values["aws_sts_endpoint"] = aws_sts_endpoint
-        if buffer_size is not None:
-            self._values["buffer_size"] = buffer_size
-        if cloud_auth is not None:
-            self._values["cloud_auth"] = cloud_auth
-        if cloud_id is not None:
-            self._values["cloud_id"] = cloud_id
-        if compress is not None:
-            self._values["compress"] = compress
-        if current_time_index is not None:
-            self._values["current_time_index"] = current_time_index
-        if generate_id is not None:
-            self._values["generate_id"] = generate_id
-        if http_passwd is not None:
-            self._values["http_passwd"] = http_passwd
-        if http_user is not None:
-            self._values["http_user"] = http_user
-        if id_key is not None:
-            self._values["id_key"] = id_key
-        if include_tag_key is not None:
-            self._values["include_tag_key"] = include_tag_key
-        if index is not None:
-            self._values["index"] = index
-        if logstash_date_format is not None:
-            self._values["logstash_date_format"] = logstash_date_format
-        if logstash_format is not None:
-            self._values["logstash_format"] = logstash_format
-        if logstash_prefix is not None:
-            self._values["logstash_prefix"] = logstash_prefix
-        if logstash_prefix_key is not None:
-            self._values["logstash_prefix_key"] = logstash_prefix_key
-        if path is not None:
-            self._values["path"] = path
-        if pipeline is not None:
-            self._values["pipeline"] = pipeline
-        if port is not None:
-            self._values["port"] = port
-        if replace_dots is not None:
-            self._values["replace_dots"] = replace_dots
-        if suppress_type_name is not None:
-            self._values["suppress_type_name"] = suppress_type_name
-        if tag_key is not None:
-            self._values["tag_key"] = tag_key
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if time_key_format is not None:
-            self._values["time_key_format"] = time_key_format
-        if time_key_nanos is not None:
-            self._values["time_key_nanos"] = time_key_nanos
-        if trace_error is not None:
-            self._values["trace_error"] = trace_error
-        if trace_output is not None:
-            self._values["trace_output"] = trace_output
-        if type is not None:
-            self._values["type"] = type
-        if workers is not None:
-            self._values["workers"] = workers
-        if write_operation is not None:
-            self._values["write_operation"] = write_operation
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def host(self) -> builtins.str:
-        '''IP address or hostname of the target Elasticsearch instance.'''
-        result = self._values.get("host")
-        assert result is not None, "Required property 'host' is missing"
-        return typing.cast(builtins.str, result)
-
-    @builtins.property
-    def aws_auth(self) -> typing.Optional[builtins.bool]:
-        '''Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service.
-
-        :default: false
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        description: typing.Optional[builtins.str] = None,
+        regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    ) -> None:
         '''
-        result = self._values.get("aws_auth")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param description: 
+        :param regions: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__51b5341103db45e2ba709accab3d05ff60b89051d4b3ce8eca228f2b3e64ebd0)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument regions", value=regions, expected_type=type_hints["regions"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if description is not None:
+            self._values["description"] = description
+        if regions is not None:
+            self._values["regions"] = regions
 
     @builtins.property
-    def aws_external_id(self) -> typing.Optional[builtins.str]:
-        '''External ID for the AWS IAM Role specified with ``awsRole``.'''
-        result = self._values.get("aws_external_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-    @builtins.property
-    def aws_region(self) -> typing.Optional[builtins.str]:
-        '''Specify the AWS region for Elasticsearch Service.'''
-        result = self._values.get("aws_region")
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''AWS IAM Role to assume to put records to your Amazon cluster.'''
-        result = self._values.get("aws_role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-    @builtins.property
-    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.'''
-        result = self._values.get("aws_sts_endpoint")
-        return typing.cast(typing.Optional[builtins.str], result)
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @builtins.property
-    def buffer_size(self) -> typing.Optional[ElasticsearchOutputBufferSize]:
-        '''Specify the buffer size used to read the response from the Elasticsearch HTTP service.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        This option is useful for debugging purposes where is
-        required to read full responses, note that response size grows depending
-        of the number of records inserted.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        result = self._values.get("buffer_size")
-        return typing.cast(typing.Optional[ElasticsearchOutputBufferSize], result)
-
-    @builtins.property
-    def cloud_auth(self) -> typing.Optional[builtins.str]:
-        '''Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.'''
-        result = self._values.get("cloud_auth")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def cloud_id(self) -> typing.Optional[builtins.str]:
-        '''If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.'''
-        result = self._values.get("cloud_id")
+        result = self._values.get("environment_from_arn")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def compress(self) -> typing.Optional[ElasticsearchCompressionFormat]:
-        '''Set payload compression mechanism.'''
-        result = self._values.get("compress")
-        return typing.cast(typing.Optional[ElasticsearchCompressionFormat], result)
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    @builtins.property
-    def current_time_index(self) -> typing.Optional[builtins.bool]:
-        '''Use current time for index generation instead of message record.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :default: false
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        result = self._values.get("current_time_index")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def generate_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, generate ``_id`` for outgoing records.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        This prevents duplicate
-        records when retrying.
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("generate_id")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def http_passwd(self) -> typing.Optional[builtins.str]:
-        '''Password for user defined in ``httpUser``.'''
-        result = self._values.get("http_passwd")
+        result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def http_user(self) -> typing.Optional[builtins.str]:
-        '''Optional username credential for access.'''
-        result = self._values.get("http_user")
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def id_key(self) -> typing.Optional[builtins.str]:
-        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.'''
-        result = self._values.get("id_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def regions(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("regions")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
-    @builtins.property
-    def include_tag_key(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it append the Tag name to the record.'''
-        result = self._values.get("include_tag_key")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    def index(self) -> typing.Optional[builtins.str]:
-        '''Index name.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :default: 'fluent-bit
-        '''
-        result = self._values.get("index")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __repr__(self) -> str:
+        return "IpamResourceDiscoveryProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    def logstash_date_format(self) -> typing.Optional[builtins.str]:
-        '''Time format (based on strftime) to generate the second part of the Index name.
 
-        :default: '%Y.%m.%d'
+@jsii.implements(IIpamScope)
+class IpamScope(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.IpamScope",
+):
+    '''Represents an IPAM scope.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        '''
-        result = self._values.get("logstash_date_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+    In IPAM, a scope is the highest-level container within IPAM. An IPAM
+    contains two default scopes. Each scope represents the IP space for a single
+    network. The private scope is intended for all private IP address space. The
+    public scope is intended for all public IP address space. Scopes enable you
+    to reuse IP addresses across multiple unconnected networks without causing
+    IP address overlap or conflict.
 
-    @builtins.property
-    def logstash_format(self) -> typing.Optional[builtins.bool]:
-        '''Enable Logstash format compatibility.
+    :see: `AWS::EC2::IPAMScope <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html>`_
+    '''
 
-        :default: false
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        ipam: IIpam,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        description: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the IpamScope class.
+
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam: The IPAM for which you're creating this scope.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param description: The description of the scope.
         '''
-        result = self._values.get("logstash_format")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9a546cb546e1edf13cb28bf17b9775fc767dbfdc928eef8397187ce0b17dfc5b)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = IpamScopeProps(
+            ipam=ipam,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+            description=description,
+        )
 
-    @builtins.property
-    def logstash_prefix(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+        jsii.create(self.__class__, self, [scope, id, props])
+
+    @jsii.member(jsii_name="fromIpamScopeArn")
+    @builtins.classmethod
+    def from_ipam_scope_arn(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        ipam_scope_arn: builtins.str,
+    ) -> IIpamScope:
+        '''Imports an existing IPAM scope by specifying its Amazon Resource Name (ARN).
 
-        The last string appended belongs to the date when the data is being
-        generated.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_scope_arn: The ARN of the existing IPAM scope to be imported.
 
-        :default: 'logstash'
+        :return: An object representing the imported IPAM scope.
         '''
-        result = self._values.get("logstash_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
-        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7f98969dee71b840db4c335d87294497a204a67e6e48b2dbbb159311385c076a)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_scope_arn", value=ipam_scope_arn, expected_type=type_hints["ipam_scope_arn"])
+        return typing.cast(IIpamScope, jsii.sinvoke(cls, "fromIpamScopeArn", [scope, id, ipam_scope_arn]))
 
-        If
-        the key/value is not found in the record then the ``logstashPrefix`` option
-        will act as a fallback.
+    @jsii.member(jsii_name="fromIpamScopeAttributes")
+    @builtins.classmethod
+    def from_ipam_scope_attributes(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        ipam: typing.Optional[IIpam] = None,
+        ipam_scope_arn: typing.Optional[builtins.str] = None,
+        ipam_scope_id: typing.Optional[builtins.str] = None,
+        is_default: typing.Optional[builtins.bool] = None,
+        pool_count: typing.Optional[jsii.Number] = None,
+        scope_type: typing.Optional[builtins.str] = None,
+    ) -> IIpamScope:
+        '''Imports an existing IAPM scope by explicitly specifying its attributes.
+
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam: The IPAM to which the scope belongs.
+        :param ipam_scope_arn: The Amazon Resource Name (ARN) of the IPAM scope.
+        :param ipam_scope_id: The ID generated by AWS for the IPAM scope.
+        :param is_default: Defines if the scope is the default scope or not.
+        :param pool_count: The number of pools in a scope.
+        :param scope_type: The type of the scope.
 
-        Nested keys are not supported (if desired, you can use the nest filter
-        plugin to remove nesting)
+        :return: An object representing the imported IPAM scope.
         '''
-        result = self._values.get("logstash_prefix_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__eb421be29901d65e6749e6323366a4f5af5dfcc7d300913711cc9ee381276a94)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        attrs = IpamScopeAttributes(
+            ipam=ipam,
+            ipam_scope_arn=ipam_scope_arn,
+            ipam_scope_id=ipam_scope_id,
+            is_default=is_default,
+            pool_count=pool_count,
+            scope_type=scope_type,
+        )
 
-    @builtins.property
-    def path(self) -> typing.Optional[builtins.str]:
-        '''Elasticsearch accepts new data on HTTP query path "/_bulk".
+        return typing.cast(IIpamScope, jsii.sinvoke(cls, "fromIpamScopeAttributes", [scope, id, attrs]))
 
-        But it is
-        also possible to serve Elasticsearch behind a reverse proxy on a
-        subpath. This option defines such path on the fluent-bit side. It
-        simply adds a path prefix in the indexing HTTP POST URI..
-        '''
-        result = self._values.get("path")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="fromIpamScopeId")
+    @builtins.classmethod
+    def from_ipam_scope_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        ipam_scope_id: builtins.str,
+    ) -> IIpamScope:
+        '''Imports an existing IPAM scope by explicitly specifying its AWS generated ID.
 
-    @builtins.property
-    def pipeline(self) -> typing.Optional[builtins.str]:
-        '''Elasticsearch allows to setup filters called pipelines.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ipam_scope_id: The AWS generated ID of the existing IPAM scope to be imported.
 
-        This option
-        allows to define which pipeline the database should use.
+        :return: An object representing the imported IPAM scope.
         '''
-        result = self._values.get("pipeline")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2dbab482810f62dc9995dde4f7df63db48fea271cb75c5366412a8b2520369b5)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument ipam_scope_id", value=ipam_scope_id, expected_type=type_hints["ipam_scope_id"])
+        return typing.cast(IIpamScope, jsii.sinvoke(cls, "fromIpamScopeId", [scope, id, ipam_scope_id]))
 
-    @builtins.property
-    def port(self) -> typing.Optional[jsii.Number]:
-        '''TCP port of the target Elasticsearch instance.
+    @jsii.member(jsii_name="addPool")
+    def add_pool(
+        self,
+        id: builtins.str,
+        *,
+        address_configuration: typing.Optional[AddressConfiguration] = None,
+        auto_import: typing.Optional[builtins.bool] = None,
+        consumer: typing.Optional[IpamConsumer] = None,
+        description: typing.Optional[builtins.str] = None,
+        locale: typing.Optional[builtins.str] = None,
+        name: typing.Optional[builtins.str] = None,
+        parent_pool: typing.Optional[IIpamPool] = None,
+        provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+        public_ip_source: typing.Optional["PublicIpSource"] = None,
+        tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ) -> IIpamPool:
+        '''Adds an IPAM pool to the IPAM scope.
+
+        A pool is a collection of contiguous IP address ranges (or CIDRs). IPAM
+        pools enable you to organize your IP addresses according to your routing
+        and security needs.
+
+        :param id: A name to be associated with the pool bing added. A unique id must be used each time the method is invoked.
+        :param address_configuration: 
+        :param auto_import: 
+        :param consumer: 
+        :param description: 
+        :param locale: 
+        :param name: 
+        :param parent_pool: 
+        :param provisioned_cidrs: 
+        :param public_ip_source: 
+        :param tag_restrictions: 
 
-        :default: 9200
+        :return: The pool that was added to the scope.
+
+        :see: `How IPAM works <https://docs.aws.amazon.com/vpc/latest/ipam/how-it-works-ipam.html>`_
         '''
-        result = self._values.get("port")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d12727c7e1919d4e36b715bbc9350697e6c18a46226953e5ecc1e34d98e666b6)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = IpamPoolOptions(
+            address_configuration=address_configuration,
+            auto_import=auto_import,
+            consumer=consumer,
+            description=description,
+            locale=locale,
+            name=name,
+            parent_pool=parent_pool,
+            provisioned_cidrs=provisioned_cidrs,
+            public_ip_source=public_ip_source,
+            tag_restrictions=tag_restrictions,
+        )
 
-    @builtins.property
-    def replace_dots(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, replace field name dots with underscore.
+        return typing.cast(IIpamPool, jsii.invoke(self, "addPool", [id, options]))
 
-        :default: false
-        '''
-        result = self._values.get("replace_dots")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="ARN_FORMAT")
+    def ARN_FORMAT(cls) -> _aws_cdk_ceddda9d.ArnFormat:
+        '''The format for Amazon Resource Names (ARN's) for IPAM scope resources.'''
+        return typing.cast(_aws_cdk_ceddda9d.ArnFormat, jsii.sget(cls, "ARN_FORMAT"))
 
     @builtins.property
-    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, mapping types is removed and ``type`` option is ignored.
+    @jsii.member(jsii_name="ipam")
+    def ipam(self) -> IIpam:
+        '''The IPAM for which you're creating this scope.
 
-        :default: false
+        :see: `IPAMScope IpamId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid>`_
+        :group: Inputs
         '''
-        result = self._values.get("suppress_type_name")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast(IIpam, jsii.get(self, "ipam"))
 
     @builtins.property
-    def tag_key(self) -> typing.Optional[builtins.str]:
-        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
-
-        :default: '_flb-key'
-        '''
-        result = self._values.get("tag_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="ipamScopeArn")
+    def ipam_scope_arn(self) -> builtins.str:
+        '''The ARN of the scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeArn"))
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+    @jsii.member(jsii_name="ipamScopeId")
+    def ipam_scope_id(self) -> builtins.str:
+        '''The ID of an IPAM scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeId"))
 
-        The``timeKey`` property defines the name of that field.
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeIpamArn")
+    def ipam_scope_ipam_arn(self) -> builtins.str:
+        '''The ARN of an IPAM.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeIpamArn"))
 
-        :default: '
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopeIsDefault")
+    def ipam_scope_is_default(self) -> _aws_cdk_ceddda9d.IResolvable:
+        '''Defines if the scope is the default scope or not.'''
+        return typing.cast(_aws_cdk_ceddda9d.IResolvable, jsii.get(self, "ipamScopeIsDefault"))
 
-        :timestamp: '
-        '''
-        result = self._values.get("time_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @builtins.property
+    @jsii.member(jsii_name="ipamScopePoolCount")
+    def ipam_scope_pool_count(self) -> jsii.Number:
+        '''The number of pools in a scope.'''
+        return typing.cast(jsii.Number, jsii.get(self, "ipamScopePoolCount"))
 
     @builtins.property
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+    @jsii.member(jsii_name="ipamScopeType")
+    def ipam_scope_type(self) -> builtins.str:
+        '''The type of the scope.'''
+        return typing.cast(builtins.str, jsii.get(self, "ipamScopeType"))
 
-        :default: '%Y-%m-%dT%H:%M:%S'
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnIPAMScope:
+        '''The underlying IPAM scope CloudFormation resource.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :see: `AWS::EC2::IPAMScope <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html>`_
+        :group: Resources
         '''
-        result = self._values.get("time_key_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnIPAMScope, jsii.get(self, "resource"))
 
     @builtins.property
-    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
-        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description of the scope.
 
-        :default: false
+        :see: `IPAMScope Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description>`_
+        :group: Inputs
         '''
-        result = self._values.get("time_key_nanos")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
-    @builtins.property
-    def trace_error(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only).
 
-        :default: false
-        '''
-        result = self._values.get("trace_error")
-        return typing.cast(typing.Optional[builtins.bool], result)
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.IpamScopeAttributes",
+    jsii_struct_bases=[],
+    name_mapping={
+        "ipam": "ipam",
+        "ipam_scope_arn": "ipamScopeArn",
+        "ipam_scope_id": "ipamScopeId",
+        "is_default": "isDefault",
+        "pool_count": "poolCount",
+        "scope_type": "scopeType",
+    },
+)
+class IpamScopeAttributes:
+    def __init__(
+        self,
+        *,
+        ipam: typing.Optional[IIpam] = None,
+        ipam_scope_arn: typing.Optional[builtins.str] = None,
+        ipam_scope_id: typing.Optional[builtins.str] = None,
+        is_default: typing.Optional[builtins.bool] = None,
+        pool_count: typing.Optional[jsii.Number] = None,
+        scope_type: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration for importing an existing IPAM scope.
+
+        :param ipam: The IPAM to which the scope belongs.
+        :param ipam_scope_arn: The Amazon Resource Name (ARN) of the IPAM scope.
+        :param ipam_scope_id: The ID generated by AWS for the IPAM scope.
+        :param is_default: Defines if the scope is the default scope or not.
+        :param pool_count: The number of pools in a scope.
+        :param scope_type: The type of the scope.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fa734344faca5c5ba3d617d94e6e6edb0a25134e0ec500d1a0f1583821b486ea)
+            check_type(argname="argument ipam", value=ipam, expected_type=type_hints["ipam"])
+            check_type(argname="argument ipam_scope_arn", value=ipam_scope_arn, expected_type=type_hints["ipam_scope_arn"])
+            check_type(argname="argument ipam_scope_id", value=ipam_scope_id, expected_type=type_hints["ipam_scope_id"])
+            check_type(argname="argument is_default", value=is_default, expected_type=type_hints["is_default"])
+            check_type(argname="argument pool_count", value=pool_count, expected_type=type_hints["pool_count"])
+            check_type(argname="argument scope_type", value=scope_type, expected_type=type_hints["scope_type"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if ipam is not None:
+            self._values["ipam"] = ipam
+        if ipam_scope_arn is not None:
+            self._values["ipam_scope_arn"] = ipam_scope_arn
+        if ipam_scope_id is not None:
+            self._values["ipam_scope_id"] = ipam_scope_id
+        if is_default is not None:
+            self._values["is_default"] = is_default
+        if pool_count is not None:
+            self._values["pool_count"] = pool_count
+        if scope_type is not None:
+            self._values["scope_type"] = scope_type
 
     @builtins.property
-    def trace_output(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the Elasticsearch API calls to stdout (for diag only).
-
-        :default: false
-        '''
-        result = self._values.get("trace_output")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def ipam(self) -> typing.Optional[IIpam]:
+        '''The IPAM to which the scope belongs.'''
+        result = self._values.get("ipam")
+        return typing.cast(typing.Optional[IIpam], result)
 
     @builtins.property
-    def type(self) -> typing.Optional[builtins.str]:
-        '''Type name.
+    def ipam_scope_arn(self) -> typing.Optional[builtins.str]:
+        '''The Amazon Resource Name (ARN) of the IPAM scope.'''
+        result = self._values.get("ipam_scope_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :default: '_doc'
-        '''
-        result = self._values.get("type")
+    @builtins.property
+    def ipam_scope_id(self) -> typing.Optional[builtins.str]:
+        '''The ID generated by AWS for the IPAM scope.'''
+        result = self._values.get("ipam_scope_id")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def workers(self) -> typing.Optional[jsii.Number]:
-        '''Enables dedicated thread(s) for this output.
+    def is_default(self) -> typing.Optional[builtins.bool]:
+        '''Defines if the scope is the default scope or not.'''
+        result = self._values.get("is_default")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        :default: 2
-        '''
-        result = self._values.get("workers")
+    @builtins.property
+    def pool_count(self) -> typing.Optional[jsii.Number]:
+        '''The number of pools in a scope.'''
+        result = self._values.get("pool_count")
         return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def write_operation(self) -> typing.Optional[builtins.str]:
-        '''Operation to use to write in bulk requests.
-
-        :default: 'create'
-        '''
-        result = self._values.get("write_operation")
+    def scope_type(self) -> typing.Optional[builtins.str]:
+        '''The type of the scope.'''
+        result = self._values.get("scope_type")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitElasticsearchOutputOptions(%s)" % ", ".join(
+        return "IpamScopeAttributes(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitJsonParserOptions",
-    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
-    name_mapping={"time_format": "timeFormat", "time_key": "timeKey"},
+    jsii_type="cdk-extensions.ec2.IpamScopeOptions",
+    jsii_struct_bases=[],
+    name_mapping={"description": "description"},
 )
-class FluentBitJsonParserOptions(FluentBitParserPluginCommonOptions):
-    def __init__(
-        self,
-        *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the JSON Fluent Bit parser plugin.
-
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
+class IpamScopeOptions:
+    def __init__(self, *, description: typing.Optional[builtins.str] = None) -> None:
+        '''Optional configuration for the IPAM scope resource.
 
-        :see: `JSON Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/json>`_
+        :param description: The description of the scope.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__676b11880e42853f892c52495c93ae1bf187c9bb63de443fc1705142de091362)
-            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
+            type_hints = typing.get_type_hints(_typecheckingstub__bd70c16717441fc94ebfa82eec86afb658add62cd41adff91da0ff31fde6f35a)
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if time_format is not None:
-            self._values["time_format"] = time_format
-        if time_key is not None:
-            self._values["time_key"] = time_key
+        if description is not None:
+            self._values["description"] = description
 
     @builtins.property
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description of the scope.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :see: `IPAMScope Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description>`_
         '''
-        result = self._values.get("time_format")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.'''
-        result = self._values.get("time_key")
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitJsonParserOptions(%s)" % ", ".join(
+        return "IpamScopeOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisFirehoseOutputOptions",
-    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.IpamScopeProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps, IpamScopeOptions],
     name_mapping={
-        "match": "match",
-        "auto_retry_requests": "autoRetryRequests",
-        "compression": "compression",
-        "delivery_stream": "deliveryStream",
-        "endpoint": "endpoint",
-        "log_key": "logKey",
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
         "region": "region",
-        "role": "role",
-        "sts_endpoint": "stsEndpoint",
-        "time_key": "timeKey",
-        "time_key_format": "timeKeyFormat",
+        "description": "description",
+        "ipam": "ipam",
     },
 )
-class FluentBitKinesisFirehoseOutputOptions(FluentBitOutputPluginCommonOptions):
+class IpamScopeProps(_aws_cdk_ceddda9d.ResourceProps, IpamScopeOptions):
     def __init__(
         self,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
-        delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the Kinesis Firehose Fluent Bit output plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param compression: Compression type for Firehose records. Each log record is individually compressed and sent to Firehose.
-        :param delivery_stream: The Kinesis Firehose Delivery stream that you want log records sent to.
-        :param endpoint: Specify a custom endpoint for the Firehose API.
-        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-        :param time_key: Add the timestamp to the record under this key.
-        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-
-        :see: `Kinesis Firehose Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/firehose>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__83b0e4d7b9e83a0ce016f523fc9afe715ef0070f7415a4f5d350b20f68c2e63d)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
-            check_type(argname="argument compression", value=compression, expected_type=type_hints["compression"])
-            check_type(argname="argument delivery_stream", value=delivery_stream, expected_type=type_hints["delivery_stream"])
-            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
-            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
+        description: typing.Optional[builtins.str] = None,
+        ipam: IIpam,
+    ) -> None:
+        '''Configuration for the IPAM scope resource.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param description: The description of the scope.
+        :param ipam: The IPAM for which you're creating this scope.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2e5cd89563bee24b90643dbcc9bc44c2859951f5fe446c27b0edaed36160fa0b)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
             check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if auto_retry_requests is not None:
-            self._values["auto_retry_requests"] = auto_retry_requests
-        if compression is not None:
-            self._values["compression"] = compression
-        if delivery_stream is not None:
-            self._values["delivery_stream"] = delivery_stream
-        if endpoint is not None:
-            self._values["endpoint"] = endpoint
-        if log_key is not None:
-            self._values["log_key"] = log_key
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument ipam", value=ipam, expected_type=type_hints["ipam"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "ipam": ipam,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
         if region is not None:
             self._values["region"] = region
-        if role is not None:
-            self._values["role"] = role
-        if sts_endpoint is not None:
-            self._values["sts_endpoint"] = sts_endpoint
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if time_key_format is not None:
-            self._values["time_key_format"] = time_key_format
+        if description is not None:
+            self._values["description"] = description
 
     @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
-
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :default: true
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        result = self._values.get("auto_retry_requests")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def compression(self) -> typing.Optional[KinesisFirehoseCompressionFormat]:
-        '''Compression type for Firehose records.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        Each log record is individually
-        compressed and sent to Firehose.
-        '''
-        result = self._values.get("compression")
-        return typing.cast(typing.Optional[KinesisFirehoseCompressionFormat], result)
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @builtins.property
-    def delivery_stream(self) -> typing.Optional[_IDeliveryStream_cf5feed7]:
-        '''The Kinesis Firehose Delivery stream that you want log records sent to.'''
-        result = self._values.get("delivery_stream")
-        return typing.cast(typing.Optional[_IDeliveryStream_cf5feed7], result)
+        Cannot be supplied together with either ``account`` or ``region``.
 
-    @builtins.property
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the Firehose API.'''
-        result = self._values.get("endpoint")
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        '''
+        result = self._values.get("environment_from_arn")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to Firehose.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to Firehose.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        result = self._values.get("log_key")
+        result = self._values.get("physical_name")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
     def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.'''
+        '''The AWS region this resource belongs to.
+
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
         result = self._values.get("region")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).'''
-        result = self._values.get("role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
-
-    @builtins.property
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.'''
-        result = self._values.get("sts_endpoint")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description of the scope.
 
-    @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''Add the timestamp to the record under this key.'''
-        result = self._values.get("time_key")
+        :see: `IPAMScope Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description>`_
+        '''
+        result = self._values.get("description")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''A strftime compliant format string for the timestamp.
+    def ipam(self) -> IIpam:
+        '''The IPAM for which you're creating this scope.
 
-        :default: '%Y-%m-%dT%H:%M:%S'
+        :see: `IPAMScope IpamId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid>`_
         '''
-        result = self._values.get("time_key_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+        result = self._values.get("ipam")
+        assert result is not None, "Required property 'ipam' is missing"
+        return typing.cast(IIpam, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitKinesisFirehoseOutputOptions(%s)" % ", ".join(
+        return "IpamScopeProps(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisOutputOptions",
-    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.LocalVpnEndpointConfiguration",
+    jsii_struct_bases=[],
     name_mapping={
-        "match": "match",
-        "auto_retry_requests": "autoRetryRequests",
-        "endpoint": "endpoint",
-        "log_key": "logKey",
-        "region": "region",
-        "role": "role",
-        "stream": "stream",
-        "sts_endpoint": "stsEndpoint",
-        "time_key": "timeKey",
-        "time_key_format": "timeKeyFormat",
+        "transit_gateway_id": "transitGatewayId",
+        "vpn_gateway_id": "vpnGatewayId",
     },
 )
-class FluentBitKinesisOutputOptions(FluentBitOutputPluginCommonOptions):
+class LocalVpnEndpointConfiguration:
     def __init__(
         self,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the Kinesis Data Streams Fluent Bit output plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param endpoint: Specify a custom endpoint for the Firehose API.
-        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param stream: The name of the Kinesis Streams Delivery stream that you want log records sent to.
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-        :param time_key: Add the timestamp to the record under this key.
-        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-
-        :see: `Kinesis Streams Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/kinesis>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b3351322b2cfd158f546c053b64876ee28f0c4c8db9d39839fa35435992b5a02)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument auto_retry_requests", value=auto_retry_requests, expected_type=type_hints["auto_retry_requests"])
-            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
-            check_type(argname="argument log_key", value=log_key, expected_type=type_hints["log_key"])
-            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
-            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
-            check_type(argname="argument stream", value=stream, expected_type=type_hints["stream"])
-            check_type(argname="argument sts_endpoint", value=sts_endpoint, expected_type=type_hints["sts_endpoint"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if match is not None:
-            self._values["match"] = match
-        if auto_retry_requests is not None:
-            self._values["auto_retry_requests"] = auto_retry_requests
-        if endpoint is not None:
-            self._values["endpoint"] = endpoint
-        if log_key is not None:
-            self._values["log_key"] = log_key
-        if region is not None:
-            self._values["region"] = region
-        if role is not None:
-            self._values["role"] = role
-        if stream is not None:
-            self._values["stream"] = stream
-        if sts_endpoint is not None:
-            self._values["sts_endpoint"] = sts_endpoint
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if time_key_format is not None:
-            self._values["time_key_format"] = time_key_format
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
-
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+        transit_gateway_id: typing.Optional[builtins.str] = None,
+        vpn_gateway_id: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration object containing the vlues needed to configure the local end of a VPN connection.
 
-        :default: true
+        :param transit_gateway_id: The ID of the transit gateway that serves as the local end of the VPN connection.
+        :param vpn_gateway_id: The ID of the VPN gateway that serves as the local end of the VPN connection.
         '''
-        result = self._values.get("auto_retry_requests")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c283c95ccb48c40fb03d7fffd4f63ce7927ef657d47052d65ed9aa32cbd6609a)
+            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
+            check_type(argname="argument vpn_gateway_id", value=vpn_gateway_id, expected_type=type_hints["vpn_gateway_id"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if transit_gateway_id is not None:
+            self._values["transit_gateway_id"] = transit_gateway_id
+        if vpn_gateway_id is not None:
+            self._values["vpn_gateway_id"] = vpn_gateway_id
 
     @builtins.property
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the Firehose API.'''
-        result = self._values.get("endpoint")
+    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
+        '''The ID of the transit gateway that serves as the local end of the VPN connection.'''
+        result = self._values.get("transit_gateway_id")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to Firehose.
+    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
+        '''The ID of the VPN gateway that serves as the local end of the VPN connection.'''
+        result = self._values.get("vpn_gateway_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to Firehose.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "LocalVpnEndpointConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class NatProvider(metaclass=jsii.JSIIMeta, jsii_type="cdk-extensions.ec2.NatProvider"):
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="gateway")
+    @builtins.classmethod
+    def gateway(
+        cls,
+        *,
+        eip_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
+    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
         '''
-        result = self._values.get("log_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param eip_allocation_ids: EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways
+        '''
+        props = _aws_cdk_aws_ec2_ceddda9d.NatGatewayProps(
+            eip_allocation_ids=eip_allocation_ids
+        )
 
-    @builtins.property
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.'''
-        result = self._values.get("region")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "gateway", [props]))
 
-    @builtins.property
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).'''
-        result = self._values.get("role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+    @jsii.member(jsii_name="instance")
+    @builtins.classmethod
+    def instance(
+        cls,
+        *,
+        instance_type: _aws_cdk_aws_ec2_ceddda9d.InstanceType,
+        default_allowed_traffic: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.NatTrafficDirection] = None,
+        key_name: typing.Optional[builtins.str] = None,
+        machine_image: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IMachineImage] = None,
+        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
+    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
+        '''
+        :param instance_type: Instance type of the NAT instance.
+        :param default_allowed_traffic: Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND
+        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
+        :param machine_image: The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image
+        :param security_group: Security Group for NAT instances. Default: - A new security group will be created
+        '''
+        props = _aws_cdk_aws_ec2_ceddda9d.NatInstanceProps(
+            instance_type=instance_type,
+            default_allowed_traffic=default_allowed_traffic,
+            key_name=key_name,
+            machine_image=machine_image,
+            security_group=security_group,
+        )
 
-    @builtins.property
-    def stream(self) -> typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream]:
-        '''The name of the Kinesis Streams Delivery stream that you want log records sent to.'''
-        result = self._values.get("stream")
-        return typing.cast(typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "instance", [props]))
 
-    @builtins.property
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.'''
-        result = self._values.get("sts_endpoint")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="transitGateway")
+    @builtins.classmethod
+    def transit_gateway(
+        cls,
+        *,
+        transit_gateway: ITransitGateway,
+    ) -> _aws_cdk_aws_ec2_ceddda9d.NatProvider:
+        '''
+        :param transit_gateway: 
+        '''
+        props = TransitGatewayNatProviderOptions(transit_gateway=transit_gateway)
+
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.NatProvider, jsii.sinvoke(cls, "transitGateway", [props]))
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.NetmaskLengthOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "default_netmask_length": "defaultNetmaskLength",
+        "max_netmask_length": "maxNetmaskLength",
+        "min_netmask_length": "minNetmaskLength",
+    },
+)
+class NetmaskLengthOptions:
+    def __init__(
+        self,
+        *,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> None:
+        '''
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5c24e074cb6c4710f3d276f35c8e07673e45a6607185bf49bf9fa23b44a6edbd)
+            check_type(argname="argument default_netmask_length", value=default_netmask_length, expected_type=type_hints["default_netmask_length"])
+            check_type(argname="argument max_netmask_length", value=max_netmask_length, expected_type=type_hints["max_netmask_length"])
+            check_type(argname="argument min_netmask_length", value=min_netmask_length, expected_type=type_hints["min_netmask_length"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if default_netmask_length is not None:
+            self._values["default_netmask_length"] = default_netmask_length
+        if max_netmask_length is not None:
+            self._values["max_netmask_length"] = max_netmask_length
+        if min_netmask_length is not None:
+            self._values["min_netmask_length"] = min_netmask_length
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''Add the timestamp to the record under this key.'''
-        result = self._values.get("time_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''A strftime compliant format string for the timestamp.
+    def max_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("max_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :default: '%Y-%m-%dT%H:%M:%S'
-        '''
-        result = self._values.get("time_key_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @builtins.property
+    def min_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("min_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitKinesisOutputOptions(%s)" % ", ".join(
+        return "NetmaskLengthOptions(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
+class PublicIpSource(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.PublicIpSource",
+):
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "PublicIpSource":
+        '''
+        :param name: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fb48b402397208864dcc706e2324e2d924048520c76c7003a49c6ef760e2d942)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("PublicIpSource", jsii.sinvoke(cls, "of", [name]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="AMAZON")
+    def AMAZON(cls) -> "PublicIpSource":
+        return typing.cast("PublicIpSource", jsii.sget(cls, "AMAZON"))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="BYOIP")
+    def BYOIP(cls) -> "PublicIpSource":
+        return typing.cast("PublicIpSource", jsii.sget(cls, "BYOIP"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "name"))
+
+
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLogfmtParserOptions",
-    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.RemoteVpnEndpointConfiguration",
+    jsii_struct_bases=[],
     name_mapping={
-        "time_format": "timeFormat",
-        "time_key": "timeKey",
-        "types": "types",
+        "customer_gateway_asn": "customerGatewayAsn",
+        "customer_gateway_id": "customerGatewayId",
+        "customer_gateway_ip": "customerGatewayIp",
     },
 )
-class FluentBitLogfmtParserOptions(FluentBitParserPluginCommonOptions):
+class RemoteVpnEndpointConfiguration:
     def __init__(
         self,
         *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+        customer_gateway_asn: jsii.Number,
+        customer_gateway_id: builtins.str,
+        customer_gateway_ip: builtins.str,
     ) -> None:
-        '''Options for configuring the logfmt Fluent Bit parser plugin.
-
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+        '''Configuration object containing the vlues needed to configure the remote end of a VPN connection.
 
-        :see: `Logfmt Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/logfmt>`_
+        :param customer_gateway_asn: The BGP ASN of the customer gateway which is configured with the details of the remote endpoint device.
+        :param customer_gateway_id: The ID of the customer gateway which is configured with the details of the remote endpoint device.
+        :param customer_gateway_ip: The IP address of the customer gateway which is configured with the details of the remote endpoint device.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f56caf857f07fc4fcf3a9d82849abe1b6d988d15131ee141433d839c247afbab)
-            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if time_format is not None:
-            self._values["time_format"] = time_format
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if types is not None:
-            self._values["types"] = types
+            type_hints = typing.get_type_hints(_typecheckingstub__8914f39fbdc8cc3e17d3f0de803ae8f59bb0822173529944b495b0fe17106662)
+            check_type(argname="argument customer_gateway_asn", value=customer_gateway_asn, expected_type=type_hints["customer_gateway_asn"])
+            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
+            check_type(argname="argument customer_gateway_ip", value=customer_gateway_ip, expected_type=type_hints["customer_gateway_ip"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "customer_gateway_asn": customer_gateway_asn,
+            "customer_gateway_id": customer_gateway_id,
+            "customer_gateway_ip": customer_gateway_ip,
+        }
 
     @builtins.property
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
-
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        '''
-        result = self._values.get("time_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def customer_gateway_asn(self) -> jsii.Number:
+        '''The BGP ASN of the customer gateway which is configured with the details of the remote endpoint device.'''
+        result = self._values.get("customer_gateway_asn")
+        assert result is not None, "Required property 'customer_gateway_asn' is missing"
+        return typing.cast(jsii.Number, result)
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.'''
-        result = self._values.get("time_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def customer_gateway_id(self) -> builtins.str:
+        '''The ID of the customer gateway which is configured with the details of the remote endpoint device.'''
+        result = self._values.get("customer_gateway_id")
+        assert result is not None, "Required property 'customer_gateway_id' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
-        result = self._values.get("types")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], result)
+    def customer_gateway_ip(self) -> builtins.str:
+        '''The IP address of the customer gateway which is configured with the details of the remote endpoint device.'''
+        result = self._values.get("customer_gateway_ip")
+        assert result is not None, "Required property 'customer_gateway_ip' is missing"
+        return typing.cast(builtins.str, result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitLogfmtParserOptions(%s)" % ", ".join(
+        return "RemoteVpnEndpointConfiguration(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLtsvParserOptions",
-    jsii_struct_bases=[FluentBitParserPluginCommonOptions],
-    name_mapping={
-        "time_format": "timeFormat",
-        "time_key": "timeKey",
-        "types": "types",
-    },
+    jsii_type="cdk-extensions.ec2.ResolvedIpamAllocationConfiguration",
+    jsii_struct_bases=[],
+    name_mapping={"cidr": "cidr", "netmask_length": "netmaskLength"},
 )
-class FluentBitLtsvParserOptions(FluentBitParserPluginCommonOptions):
+class ResolvedIpamAllocationConfiguration:
     def __init__(
         self,
         *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+        cidr: typing.Optional[builtins.str] = None,
+        netmask_length: typing.Optional[jsii.Number] = None,
     ) -> None:
-        '''Options for configuring the LTSV Fluent Bit parser plugin.
-
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
-
-        :see: `LTSV Plugin Documention <https://docs.fluentbit.io/manual/pipeline/parsers/ltsv>`_
+        '''
+        :param cidr: 
+        :param netmask_length: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8359d0e12857464b85b7f043fe21b4c1b8581d20c4a022da8a6c0e79ee1c3386)
-            check_type(argname="argument time_format", value=time_format, expected_type=type_hints["time_format"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument types", value=types, expected_type=type_hints["types"])
+            type_hints = typing.get_type_hints(_typecheckingstub__d6a6fb9ff8ed88515dc74aa71837868e0d16d8ef2ac4a3a46e432a333f40e9d0)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument netmask_length", value=netmask_length, expected_type=type_hints["netmask_length"])
         self._values: typing.Dict[builtins.str, typing.Any] = {}
-        if time_format is not None:
-            self._values["time_format"] = time_format
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if types is not None:
-            self._values["types"] = types
+        if cidr is not None:
+            self._values["cidr"] = cidr
+        if netmask_length is not None:
+            self._values["netmask_length"] = netmask_length
 
     @builtins.property
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
+    def cidr(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("cidr")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "ResolvedIpamAllocationConfiguration(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.ResolvedIpamPoolCidrConfiguration",
+    jsii_struct_bases=[],
+    name_mapping={"cidr": "cidr", "netmask_length": "netmaskLength"},
+)
+class ResolvedIpamPoolCidrConfiguration:
+    def __init__(
+        self,
+        *,
+        cidr: typing.Optional[builtins.str] = None,
+        netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> None:
         '''
-        result = self._values.get("time_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param cidr: 
+        :param netmask_length: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__f937d2844c2174b9db397ff6d5bf4089b68ef2d9ee3c31b6fae8baf52964476b)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument netmask_length", value=netmask_length, expected_type=type_hints["netmask_length"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if cidr is not None:
+            self._values["cidr"] = cidr
+        if netmask_length is not None:
+            self._values["netmask_length"] = netmask_length
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.'''
-        result = self._values.get("time_key")
+    def cidr(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("cidr")
         return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
-        result = self._values.get("types")
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], result)
+    def netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     def __eq__(self, rhs: typing.Any) -> builtins.bool:
         return isinstance(rhs, self.__class__) and rhs._values == self._values
 
     def __ne__(self, rhs: typing.Any) -> builtins.bool:
         return not (rhs == self)
 
     def __repr__(self) -> str:
-        return "FluentBitLtsvParserOptions(%s)" % ", ".join(
+        return "ResolvedIpamPoolCidrConfiguration(%s)" % ", ".join(
             k + "=" + repr(v) for k, v in self._values.items()
         )
 
 
 @jsii.data_type(
-    jsii_type="cdk-extensions.k8s_aws.FluentBitOpenSearchOutputOptions",
-    jsii_struct_bases=[FluentBitOutputPluginCommonOptions],
+    jsii_type="cdk-extensions.ec2.SharingOptions",
+    jsii_struct_bases=[],
     name_mapping={
-        "match": "match",
-        "domain": "domain",
-        "aws_auth": "awsAuth",
-        "aws_external_id": "awsExternalId",
-        "aws_region": "awsRegion",
-        "aws_role": "awsRole",
-        "aws_sts_endpoint": "awsStsEndpoint",
-        "buffer_size": "bufferSize",
-        "current_time_index": "currentTimeIndex",
-        "generate_id": "generateId",
-        "host": "host",
-        "http_passwd": "httpPasswd",
-        "http_user": "httpUser",
-        "id_key": "idKey",
-        "include_tag_key": "includeTagKey",
-        "index": "index",
-        "logstash_date_format": "logstashDateFormat",
-        "logstash_format": "logstashFormat",
-        "logstash_prefix": "logstashPrefix",
-        "logstash_prefix_key": "logstashPrefixKey",
-        "path": "path",
-        "pipeline": "pipeline",
-        "port": "port",
-        "replace_dots": "replaceDots",
-        "suppress_type_name": "suppressTypeName",
-        "tag_key": "tagKey",
-        "time_key": "timeKey",
-        "time_key_format": "timeKeyFormat",
-        "time_key_nanos": "timeKeyNanos",
-        "trace_error": "traceError",
-        "trace_output": "traceOutput",
-        "type": "type",
-        "workers": "workers",
-        "write_operation": "writeOperation",
+        "allow_external_principals": "allowExternalPrincipals",
+        "auto_discover_accounts": "autoDiscoverAccounts",
+        "principals": "principals",
     },
 )
-class FluentBitOpenSearchOutputOptions(FluentBitOutputPluginCommonOptions):
+class SharingOptions:
     def __init__(
         self,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
-        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
-        aws_auth: typing.Optional[builtins.bool] = None,
-        aws_external_id: typing.Optional[builtins.str] = None,
-        aws_region: typing.Optional[builtins.str] = None,
-        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        aws_sts_endpoint: typing.Optional[builtins.str] = None,
-        buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
-        current_time_index: typing.Optional[builtins.bool] = None,
-        generate_id: typing.Optional[builtins.bool] = None,
-        host: typing.Optional[builtins.str] = None,
-        http_passwd: typing.Optional[builtins.str] = None,
-        http_user: typing.Optional[builtins.str] = None,
-        id_key: typing.Optional[builtins.str] = None,
-        include_tag_key: typing.Optional[builtins.bool] = None,
-        index: typing.Optional[builtins.str] = None,
-        logstash_date_format: typing.Optional[builtins.str] = None,
-        logstash_format: typing.Optional[builtins.bool] = None,
-        logstash_prefix: typing.Optional[builtins.str] = None,
-        logstash_prefix_key: typing.Optional[builtins.str] = None,
-        path: typing.Optional[builtins.str] = None,
-        pipeline: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replace_dots: typing.Optional[builtins.bool] = None,
-        suppress_type_name: typing.Optional[builtins.bool] = None,
-        tag_key: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        time_key_nanos: typing.Optional[builtins.bool] = None,
-        trace_error: typing.Optional[builtins.bool] = None,
-        trace_output: typing.Optional[builtins.bool] = None,
-        type: typing.Optional[builtins.str] = None,
-        workers: typing.Optional[jsii.Number] = None,
-        write_operation: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Options for configuring the OpenSearch Fluent Bit output plugin.
-
-        :param match: The pattern to match for records that this output should apply to.
-        :param domain: The Opensearch domain to which logs should be shipped.
-        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon OpenSearch Service. Default: false
-        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
-        :param aws_region: Specify the AWS region for Amazon OpenSearch Service.
-        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
-        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
-        :param buffer_size: Specify the buffer size used to read the response from the OpenSearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
-        :param current_time_index: Use current time for index generation instead of message record. Default: false
-        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
-        :param host: IP address or hostname of the target OpenSearch instance.
-        :param http_passwd: Password for user defined in ``httpUser``.
-        :param http_user: Optional username credential for access.
-        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
-        :param include_tag_key: When enabled, it append the Tag name to the record.
-        :param index: Index name. Default: 'fluent-bit
-        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
-        :param logstash_format: Enable Logstash format compatibility. Default: false
-        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
-        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
-        :param path: OpenSearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve OpenSearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
-        :param pipeline: OpenSearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
-        :param port: TCP port of the target OpenSearch instance. Default: 9200
-        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
-        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
-        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
-        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
-        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
-        :param trace_error: When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only). Default: false
-        :param trace_output: When enabled print the OpenSearch API calls to stdout (for diag only). Default: false
-        :param type: Type name. Default: '_doc'
-        :param workers: Enables dedicated thread(s) for this output. Default: 2
-        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
-
-        :see: `OpenSearch Plugin Documention <https://docs.fluentbit.io/manual/pipeline/outputs/opensearch>`_
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5d8425bcc923d11b65d58b1eaf5873e22f32f3ab919ad7e37262fc57ab0df995)
-            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
-            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
-            check_type(argname="argument aws_auth", value=aws_auth, expected_type=type_hints["aws_auth"])
-            check_type(argname="argument aws_external_id", value=aws_external_id, expected_type=type_hints["aws_external_id"])
-            check_type(argname="argument aws_region", value=aws_region, expected_type=type_hints["aws_region"])
-            check_type(argname="argument aws_role", value=aws_role, expected_type=type_hints["aws_role"])
-            check_type(argname="argument aws_sts_endpoint", value=aws_sts_endpoint, expected_type=type_hints["aws_sts_endpoint"])
-            check_type(argname="argument buffer_size", value=buffer_size, expected_type=type_hints["buffer_size"])
-            check_type(argname="argument current_time_index", value=current_time_index, expected_type=type_hints["current_time_index"])
-            check_type(argname="argument generate_id", value=generate_id, expected_type=type_hints["generate_id"])
-            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
-            check_type(argname="argument http_passwd", value=http_passwd, expected_type=type_hints["http_passwd"])
-            check_type(argname="argument http_user", value=http_user, expected_type=type_hints["http_user"])
-            check_type(argname="argument id_key", value=id_key, expected_type=type_hints["id_key"])
-            check_type(argname="argument include_tag_key", value=include_tag_key, expected_type=type_hints["include_tag_key"])
-            check_type(argname="argument index", value=index, expected_type=type_hints["index"])
-            check_type(argname="argument logstash_date_format", value=logstash_date_format, expected_type=type_hints["logstash_date_format"])
-            check_type(argname="argument logstash_format", value=logstash_format, expected_type=type_hints["logstash_format"])
-            check_type(argname="argument logstash_prefix", value=logstash_prefix, expected_type=type_hints["logstash_prefix"])
-            check_type(argname="argument logstash_prefix_key", value=logstash_prefix_key, expected_type=type_hints["logstash_prefix_key"])
-            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
-            check_type(argname="argument pipeline", value=pipeline, expected_type=type_hints["pipeline"])
-            check_type(argname="argument port", value=port, expected_type=type_hints["port"])
-            check_type(argname="argument replace_dots", value=replace_dots, expected_type=type_hints["replace_dots"])
-            check_type(argname="argument suppress_type_name", value=suppress_type_name, expected_type=type_hints["suppress_type_name"])
-            check_type(argname="argument tag_key", value=tag_key, expected_type=type_hints["tag_key"])
-            check_type(argname="argument time_key", value=time_key, expected_type=type_hints["time_key"])
-            check_type(argname="argument time_key_format", value=time_key_format, expected_type=type_hints["time_key_format"])
-            check_type(argname="argument time_key_nanos", value=time_key_nanos, expected_type=type_hints["time_key_nanos"])
-            check_type(argname="argument trace_error", value=trace_error, expected_type=type_hints["trace_error"])
-            check_type(argname="argument trace_output", value=trace_output, expected_type=type_hints["trace_output"])
-            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
-            check_type(argname="argument workers", value=workers, expected_type=type_hints["workers"])
-            check_type(argname="argument write_operation", value=write_operation, expected_type=type_hints["write_operation"])
-        self._values: typing.Dict[builtins.str, typing.Any] = {
-            "domain": domain,
-        }
-        if match is not None:
-            self._values["match"] = match
-        if aws_auth is not None:
-            self._values["aws_auth"] = aws_auth
-        if aws_external_id is not None:
-            self._values["aws_external_id"] = aws_external_id
-        if aws_region is not None:
-            self._values["aws_region"] = aws_region
-        if aws_role is not None:
-            self._values["aws_role"] = aws_role
-        if aws_sts_endpoint is not None:
-            self._values["aws_sts_endpoint"] = aws_sts_endpoint
-        if buffer_size is not None:
-            self._values["buffer_size"] = buffer_size
-        if current_time_index is not None:
-            self._values["current_time_index"] = current_time_index
-        if generate_id is not None:
-            self._values["generate_id"] = generate_id
-        if host is not None:
-            self._values["host"] = host
-        if http_passwd is not None:
-            self._values["http_passwd"] = http_passwd
-        if http_user is not None:
-            self._values["http_user"] = http_user
-        if id_key is not None:
-            self._values["id_key"] = id_key
-        if include_tag_key is not None:
-            self._values["include_tag_key"] = include_tag_key
-        if index is not None:
-            self._values["index"] = index
-        if logstash_date_format is not None:
-            self._values["logstash_date_format"] = logstash_date_format
-        if logstash_format is not None:
-            self._values["logstash_format"] = logstash_format
-        if logstash_prefix is not None:
-            self._values["logstash_prefix"] = logstash_prefix
-        if logstash_prefix_key is not None:
-            self._values["logstash_prefix_key"] = logstash_prefix_key
-        if path is not None:
-            self._values["path"] = path
-        if pipeline is not None:
-            self._values["pipeline"] = pipeline
-        if port is not None:
-            self._values["port"] = port
-        if replace_dots is not None:
-            self._values["replace_dots"] = replace_dots
-        if suppress_type_name is not None:
-            self._values["suppress_type_name"] = suppress_type_name
-        if tag_key is not None:
-            self._values["tag_key"] = tag_key
-        if time_key is not None:
-            self._values["time_key"] = time_key
-        if time_key_format is not None:
-            self._values["time_key_format"] = time_key_format
-        if time_key_nanos is not None:
-            self._values["time_key_nanos"] = time_key_nanos
-        if trace_error is not None:
-            self._values["trace_error"] = trace_error
-        if trace_output is not None:
-            self._values["trace_output"] = trace_output
-        if type is not None:
-            self._values["type"] = type
-        if workers is not None:
-            self._values["workers"] = workers
-        if write_operation is not None:
-            self._values["write_operation"] = write_operation
-
-    @builtins.property
-    def match(self) -> typing.Optional[FluentBitMatch]:
-        '''The pattern to match for records that this output should apply to.'''
-        result = self._values.get("match")
-        return typing.cast(typing.Optional[FluentBitMatch], result)
-
-    @builtins.property
-    def domain(self) -> _aws_cdk_aws_opensearchservice_ceddda9d.IDomain:
-        '''The Opensearch domain to which logs should be shipped.'''
-        result = self._values.get("domain")
-        assert result is not None, "Required property 'domain' is missing"
-        return typing.cast(_aws_cdk_aws_opensearchservice_ceddda9d.IDomain, result)
+        allow_external_principals: typing.Optional[builtins.bool] = None,
+        auto_discover_accounts: typing.Optional[builtins.bool] = None,
+        principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
+    ) -> None:
+        '''
+        :param allow_external_principals: 
+        :param auto_discover_accounts: 
+        :param principals: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5d7430c10280f3e429f967b91e374da316928ba959b852656888cb4465f871ab)
+            check_type(argname="argument allow_external_principals", value=allow_external_principals, expected_type=type_hints["allow_external_principals"])
+            check_type(argname="argument auto_discover_accounts", value=auto_discover_accounts, expected_type=type_hints["auto_discover_accounts"])
+            check_type(argname="argument principals", value=principals, expected_type=type_hints["principals"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if allow_external_principals is not None:
+            self._values["allow_external_principals"] = allow_external_principals
+        if auto_discover_accounts is not None:
+            self._values["auto_discover_accounts"] = auto_discover_accounts
+        if principals is not None:
+            self._values["principals"] = principals
 
     @builtins.property
-    def aws_auth(self) -> typing.Optional[builtins.bool]:
-        '''Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
-
-        :default: false
-        '''
-        result = self._values.get("aws_auth")
+    def allow_external_principals(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("allow_external_principals")
         return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def aws_external_id(self) -> typing.Optional[builtins.str]:
-        '''External ID for the AWS IAM Role specified with ``awsRole``.'''
-        result = self._values.get("aws_external_id")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def auto_discover_accounts(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("auto_discover_accounts")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    def aws_region(self) -> typing.Optional[builtins.str]:
-        '''Specify the AWS region for Amazon OpenSearch Service.'''
-        result = self._values.get("aws_region")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def principals(self) -> typing.Optional[typing.List[_ISharedPrincipal_9cde791b]]:
+        result = self._values.get("principals")
+        return typing.cast(typing.Optional[typing.List[_ISharedPrincipal_9cde791b]], result)
 
-    @builtins.property
-    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''AWS IAM Role to assume to put records to your Amazon cluster.'''
-        result = self._values.get("aws_role")
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.'''
-        result = self._values.get("aws_sts_endpoint")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "SharingOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    def buffer_size(self) -> typing.Optional[OpenSearchOutputBufferSize]:
-        '''Specify the buffer size used to read the response from the OpenSearch HTTP service.
 
-        This option is useful for debugging purposes where is
-        required to read full responses, note that response size grows depending
-        of the number of records inserted.
+@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IIpAddresses)
+class TieredSubnets(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TieredSubnets",
+):
+    def __init__(
+        self,
+        *,
+        provider: ICidrProvider,
+        tier_mask: typing.Optional[jsii.Number] = None,
+    ) -> None:
+        '''
+        :param provider: 
+        :param tier_mask: 
         '''
-        result = self._values.get("buffer_size")
-        return typing.cast(typing.Optional[OpenSearchOutputBufferSize], result)
+        options = TieredSubnetsOptions(provider=provider, tier_mask=tier_mask)
 
-    @builtins.property
-    def current_time_index(self) -> typing.Optional[builtins.bool]:
-        '''Use current time for index generation instead of message record.
+        jsii.create(self.__class__, self, [options])
 
-        :default: false
-        '''
-        result = self._values.get("current_time_index")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="allocateSubnetsCidr")
+    def allocate_subnets_cidr(
+        self,
+        *,
+        requested_subnets: typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.RequestedSubnet, typing.Dict[builtins.str, typing.Any]]],
+        vpc_cidr: builtins.str,
+    ) -> _aws_cdk_aws_ec2_ceddda9d.SubnetIpamOptions:
+        '''Called by the VPC to retrieve Subnet options from the Ipam
 
-    @builtins.property
-    def generate_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, generate ``_id`` for outgoing records.
+Don't call this directly, the VPC will call it automatically.
 
-        This prevents duplicate
-        records when retrying.
+        :param requested_subnets: The Subnets to be allocated.
+        :param vpc_cidr: The IPv4 CIDR block for this Vpc.
         '''
-        result = self._values.get("generate_id")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        input = _aws_cdk_aws_ec2_ceddda9d.AllocateCidrRequest(
+            requested_subnets=requested_subnets, vpc_cidr=vpc_cidr
+        )
 
-    @builtins.property
-    def host(self) -> typing.Optional[builtins.str]:
-        '''IP address or hostname of the target OpenSearch instance.'''
-        result = self._values.get("host")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetIpamOptions, jsii.invoke(self, "allocateSubnetsCidr", [input]))
 
-    @builtins.property
-    def http_passwd(self) -> typing.Optional[builtins.str]:
-        '''Password for user defined in ``httpUser``.'''
-        result = self._values.get("http_passwd")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="allocateVpcCidr")
+    def allocate_vpc_cidr(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions:
+        '''Called by the VPC to retrieve VPC options from the Ipam
 
-    @builtins.property
-    def http_user(self) -> typing.Optional[builtins.str]:
-        '''Optional username credential for access.'''
-        result = self._values.get("http_user")
-        return typing.cast(typing.Optional[builtins.str], result)
+Don't call this directly, the VPC will call it automatically.'''
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcIpamOptions, jsii.invoke(self, "allocateVpcCidr", []))
 
     @builtins.property
-    def id_key(self) -> typing.Optional[builtins.str]:
-        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.'''
-        result = self._values.get("id_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+    @jsii.member(jsii_name="provider")
+    def provider(self) -> ICidrProvider:
+        return typing.cast(ICidrProvider, jsii.get(self, "provider"))
 
     @builtins.property
-    def include_tag_key(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it append the Tag name to the record.'''
-        result = self._values.get("include_tag_key")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    @jsii.member(jsii_name="tierMask")
+    def tier_mask(self) -> typing.Optional[jsii.Number]:
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "tierMask"))
 
-    @builtins.property
-    def index(self) -> typing.Optional[builtins.str]:
-        '''Index name.
 
-        :default: 'fluent-bit
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TieredSubnetsOptions",
+    jsii_struct_bases=[],
+    name_mapping={"provider": "provider", "tier_mask": "tierMask"},
+)
+class TieredSubnetsOptions:
+    def __init__(
+        self,
+        *,
+        provider: ICidrProvider,
+        tier_mask: typing.Optional[jsii.Number] = None,
+    ) -> None:
         '''
-        result = self._values.get("index")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param provider: 
+        :param tier_mask: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0ebcc1ff7b7a99559a7a9d7feb7af82f8670e1cbdb892fd154081f69de879b67)
+            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
+            check_type(argname="argument tier_mask", value=tier_mask, expected_type=type_hints["tier_mask"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "provider": provider,
+        }
+        if tier_mask is not None:
+            self._values["tier_mask"] = tier_mask
 
     @builtins.property
-    def logstash_date_format(self) -> typing.Optional[builtins.str]:
-        '''Time format (based on strftime) to generate the second part of the Index name.
+    def provider(self) -> ICidrProvider:
+        result = self._values.get("provider")
+        assert result is not None, "Required property 'provider' is missing"
+        return typing.cast(ICidrProvider, result)
 
-        :default: '%Y.%m.%d'
+    @builtins.property
+    def tier_mask(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("tier_mask")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        '''
-        result = self._values.get("logstash_date_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    def logstash_format(self) -> typing.Optional[builtins.bool]:
-        '''Enable Logstash format compatibility.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :default: false
-        '''
-        result = self._values.get("logstash_format")
-        return typing.cast(typing.Optional[builtins.bool], result)
+    def __repr__(self) -> str:
+        return "TieredSubnetsOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    def logstash_prefix(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
 
-        The last string appended belongs to the date when the data is being
-        generated.
+@jsii.implements(ITransitGateway)
+class TransitGateway(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TransitGateway",
+):
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        amazon_side_asn: typing.Optional[jsii.Number] = None,
+        auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
+        cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
+        default_route_table_association: typing.Optional[builtins.bool] = None,
+        default_route_table_id: typing.Optional[builtins.str] = None,
+        default_route_table_propagation: typing.Optional[builtins.bool] = None,
+        description: typing.Optional[builtins.str] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        multicast_support: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the Database class.
 
-        :default: 'logstash'
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param amazon_side_asn: 
+        :param auto_accept_shared_attachments: 
+        :param cidr_blocks: 
+        :param default_route_table_association: 
+        :param default_route_table_id: 
+        :param default_route_table_propagation: 
+        :param description: 
+        :param dns_support: 
+        :param multicast_support: 
+        :param name: 
+        :param vpn_ecmp_support: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        result = self._values.get("logstash_prefix")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__66b0aca7557ca99e67ff904b7cb9edf704abd3cf24b45ecad18d9ccffdb7fcdc)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = TransitGatewayProps(
+            amazon_side_asn=amazon_side_asn,
+            auto_accept_shared_attachments=auto_accept_shared_attachments,
+            cidr_blocks=cidr_blocks,
+            default_route_table_association=default_route_table_association,
+            default_route_table_id=default_route_table_id,
+            default_route_table_propagation=default_route_table_propagation,
+            description=description,
+            dns_support=dns_support,
+            multicast_support=multicast_support,
+            name=name,
+            vpn_ecmp_support=vpn_ecmp_support,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
-        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
+        jsii.create(self.__class__, self, [scope, id, props])
 
-        If
-        the key/value is not found in the record then the ``logstashPrefix`` option
-        will act as a fallback.
+    @jsii.member(jsii_name="fromTransitGatewayId")
+    @builtins.classmethod
+    def from_transit_gateway_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        transit_gateway_id: builtins.str,
+    ) -> ITransitGateway:
+        '''
+        :param scope: -
+        :param id: -
+        :param transit_gateway_id: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__46c3cc263035d23bc511197c75afb01d4a672fd46f5af176fbea6a400bccd00b)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument transit_gateway_id", value=transit_gateway_id, expected_type=type_hints["transit_gateway_id"])
+        return typing.cast(ITransitGateway, jsii.sinvoke(cls, "fromTransitGatewayId", [scope, id, transit_gateway_id]))
 
-        Nested keys are not supported (if desired, you can use the nest filter
-        plugin to remove nesting)
+    @jsii.member(jsii_name="addCidrBlock")
+    def add_cidr_block(self, cidr: builtins.str) -> None:
         '''
-        result = self._values.get("logstash_prefix_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param cidr: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2efd1666acd64cb987a354787ffd07add5920ed5de7e64ad3a01aa00619b7310)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+        return typing.cast(None, jsii.invoke(self, "addCidrBlock", [cidr]))
 
-    @builtins.property
-    def path(self) -> typing.Optional[builtins.str]:
-        '''OpenSearch accepts new data on HTTP query path "/_bulk".
+    @jsii.member(jsii_name="addRouteTable")
+    def add_route_table(
+        self,
+        *,
+        name: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayRouteTable":
+        '''Creates a new Transit Gateway Route Table for this Transit Gateway.
 
-        But it is also
-        possible to serve OpenSearch behind a reverse proxy on a subpath. This
-        option defines such path on the fluent-bit side. It simply adds a path
-        prefix in the indexing HTTP POST URI..
+        :param name: 
+
+        :return: The newly created Transit Gateway Route Table.
         '''
-        result = self._values.get("path")
-        return typing.cast(typing.Optional[builtins.str], result)
+        options = TransitGatewayRouteTableOptions(name=name)
 
-    @builtins.property
-    def pipeline(self) -> typing.Optional[builtins.str]:
-        '''OpenSearch allows to setup filters called pipelines.
+        return typing.cast("TransitGatewayRouteTable", jsii.invoke(self, "addRouteTable", [options]))
 
-        This option allows
-        to define which pipeline the database should use.
+    @jsii.member(jsii_name="addVpn")
+    def add_vpn(
+        self,
+        id: builtins.str,
+        *,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union["TunnelOptions", typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> "VpnConnection":
+        '''Creates a new VPN connection that terminates on the AWS side at this Transit Gateway.
+
+        :param id: A unique identifier for this VPN connection. Must be unique within the context of scope.
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
+
+        :return: The VPN connection that was created.
         '''
-        result = self._values.get("pipeline")
-        return typing.cast(typing.Optional[builtins.str], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9989ffc3141ccddce9a6e8246aa4b31bd76f3ad0a11bbc1cbee86d607e50200d)
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        options = VpnAttachmentOptions(
+            remote_endpoint=remote_endpoint,
+            connection_type=connection_type,
+            static_routes_only=static_routes_only,
+            tunnel_configurations=tunnel_configurations,
+        )
 
-    @builtins.property
-    def port(self) -> typing.Optional[jsii.Number]:
-        '''TCP port of the target OpenSearch instance.
+        return typing.cast("VpnConnection", jsii.invoke(self, "addVpn", [id, options]))
 
-        :default: 9200
-        '''
-        result = self._values.get("port")
-        return typing.cast(typing.Optional[jsii.Number], result)
+    @jsii.member(jsii_name="attachPeer")
+    def attach_peer(
+        self,
+        peer: ITransitGateway,
+        *,
+        name: typing.Optional[builtins.str] = None,
+        peer_account_id: typing.Optional[builtins.str] = None,
+        peer_region: typing.Optional[builtins.str] = None,
+    ) -> "TransitGatewayPeeringAttachment":
+        '''Creates a new transit gateway peering attachment for this transit gateway.
 
-    @builtins.property
-    def replace_dots(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, replace field name dots with underscore.
+        :param peer: The remote transit gateway to create the peering connection with.
+        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param peer_account_id: The account that contains the transit gateway being peered with.
+        :param peer_region: The region that contains the transit gateway being peered with.
 
-        :default: false
+        :return: The newly created TransitGatewayPeeringAttachment.
         '''
-        result = self._values.get("replace_dots")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3fca635a725c4277e8db84123074663ecf20e88af86d11cb8f03c6390d8b7bc8)
+            check_type(argname="argument peer", value=peer, expected_type=type_hints["peer"])
+        options = TransitGatewayPeeringAttachmentOptions(
+            name=name, peer_account_id=peer_account_id, peer_region=peer_region
+        )
 
-    @builtins.property
-    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, mapping types is removed and ``type`` option is ignored.
+        return typing.cast("TransitGatewayPeeringAttachment", jsii.invoke(self, "attachPeer", [peer, options]))
 
-        :default: false
+    @jsii.member(jsii_name="attachVpc")
+    def attach_vpc(
+        self,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        *,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> "TransitGatewayAttachment":
+        '''Creates a new VPC transit gateway attachment for this transit gateway.
+
+        :param vpc: The VPC to connect to this Transit Gateway.
+        :param name: 
+        :param subnets: 
+
+        :return: The newly created TransitGatewayAttachment.
         '''
-        result = self._values.get("suppress_type_name")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ac3f5d6f3de4328a56c1673d48d7168afe72b9b6c52725fb46ee3d5121211524)
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+        options = VpcAttachmentOptions(name=name, subnets=subnets)
 
-    @builtins.property
-    def tag_key(self) -> typing.Optional[builtins.str]:
-        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+        return typing.cast("TransitGatewayAttachment", jsii.invoke(self, "attachVpc", [vpc, options]))
 
-        :default: '_flb-key'
+    @jsii.member(jsii_name="enableSharing")
+    def enable_sharing(
+        self,
+        *,
+        allow_external_principals: typing.Optional[builtins.bool] = None,
+        auto_discover_accounts: typing.Optional[builtins.bool] = None,
+        principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
+    ) -> _ResourceShare_f0180713:
         '''
-        result = self._values.get("tag_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+        :param allow_external_principals: 
+        :param auto_discover_accounts: 
+        :param principals: 
+        '''
+        options = SharingOptions(
+            allow_external_principals=allow_external_principals,
+            auto_discover_accounts=auto_discover_accounts,
+            principals=principals,
+        )
+
+        return typing.cast(_ResourceShare_f0180713, jsii.invoke(self, "enableSharing", [options]))
 
     @builtins.property
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+    @jsii.member(jsii_name="autoAcceptSharedAttachments")
+    def auto_accept_shared_attachments(self) -> builtins.bool:
+        '''Enable or disable automatic acceptance of attachment requests.
 
-        The``timeKey`` property defines the name of that field.
+        When enabled any new transit gateway attachments that are created in other
+        accounts via a resource share will be accepted automatically. Otherwise,
+        manual intervention will be required to approve all new attachments.
 
-        :default: '
+        This is disabled by default to maintain the highest levels of security,
+        however enabling should be strongly considered as without this full
+        automation of infrastructure will not be possible for cross account
+        setups.
 
-        :timestamp: '
+        :see: `Accept a shared attachment <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#tgw-accept-shared-attachment>`_
+        :group: Inputs
         '''
-        result = self._values.get("time_key")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(builtins.bool, jsii.get(self, "autoAcceptSharedAttachments"))
 
     @builtins.property
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+    @jsii.member(jsii_name="defaultRouteTableAssociation")
+    def default_route_table_association(self) -> builtins.bool:
+        '''Enable or disable automatic association with the default association route table.
 
-        :default: '%Y-%m-%dT%H:%M:%S'
+        When enabled, all new attachments that are accepted will be automatically
+        associated with the default association route table. By default this is
+        the route table that is created automatically when the transit gateway is
+        created.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :see: `TransitGateway.DefaultRouteTableAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation>`_
+        :group: Inputs
         '''
-        result = self._values.get("time_key_format")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(builtins.bool, jsii.get(self, "defaultRouteTableAssociation"))
 
     @builtins.property
-    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
-        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+    @jsii.member(jsii_name="defaultRouteTablePropagation")
+    def default_route_table_propagation(self) -> builtins.bool:
+        '''Enable or disable automatic propagation of routes to the default propagation route table.
 
-        :default: false
-        '''
-        result = self._values.get("time_key_nanos")
-        return typing.cast(typing.Optional[builtins.bool], result)
-
-    @builtins.property
-    def trace_error(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only).
+        When a new attachment is accepted, the routes associated with that
+        attachment will automatically be added to the default propagation route
+        table. By default this is the route table that is created automatically
+        when the transit gateway is created.
 
-        :default: false
+        :see: `Route propagation <https://docs.aws.amazon.com/vpc/latest/tgw/how-transit-gateways-work.html#tgw-route-propagation-overview>`_
+        :group: Inputs
         '''
-        result = self._values.get("trace_error")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast(builtins.bool, jsii.get(self, "defaultRouteTablePropagation"))
 
     @builtins.property
-    def trace_output(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the OpenSearch API calls to stdout (for diag only).
+    @jsii.member(jsii_name="dnsSupport")
+    def dns_support(self) -> builtins.bool:
+        '''Enable or disable DNS support.
+
+        When DNS support is enabled on a transit gateway, VPC DNS resolution in
+        attached VPC's will automatically resolve public IP addresses from other
+        VPC's to their provate IP address equivalent.
 
-        :default: false
+        :see: `Create a transit gateway <https://docs.aws.amazon.com/vpc/latest/tgw/tgw-transit-gateways.html#create-tgw>`_
+        :group: Inputs
         '''
-        result = self._values.get("trace_output")
-        return typing.cast(typing.Optional[builtins.bool], result)
+        return typing.cast(builtins.bool, jsii.get(self, "dnsSupport"))
 
     @builtins.property
-    def type(self) -> typing.Optional[builtins.str]:
-        '''Type name.
+    @jsii.member(jsii_name="multicastSupport")
+    def multicast_support(self) -> builtins.bool:
+        '''Indicates whether multicast is enabled on the transit gateway.
 
-        :default: '_doc'
+        :see: `Multicast reference architectures <https://d1.awsstatic.com/architecture-diagrams/ArchitectureDiagrams/transitgateway_multicast_ra.pdf?did=wp_card&trk=wp_card>`_
+        :group: Inputs
         '''
-        result = self._values.get("type")
-        return typing.cast(typing.Optional[builtins.str], result)
+        return typing.cast(builtins.bool, jsii.get(self, "multicastSupport"))
 
     @builtins.property
-    def workers(self) -> typing.Optional[jsii.Number]:
-        '''Enables dedicated thread(s) for this output.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGateway:
+        '''The underlying TransitGateway CloudFormation resource.
 
-        :default: 2
+        :see: `AWS::EC2::TransitGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html>`_
+        :group: Resources
         '''
-        result = self._values.get("workers")
-        return typing.cast(typing.Optional[jsii.Number], result)
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGateway, jsii.get(self, "resource"))
 
     @builtins.property
-    def write_operation(self) -> typing.Optional[builtins.str]:
-        '''Operation to use to write in bulk requests.
+    @jsii.member(jsii_name="transitGatewayArn")
+    def transit_gateway_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayArn"))
 
-        :default: 'create'
-        '''
-        result = self._values.get("write_operation")
-        return typing.cast(typing.Optional[builtins.str], result)
-
-    def __eq__(self, rhs: typing.Any) -> builtins.bool:
-        return isinstance(rhs, self.__class__) and rhs._values == self._values
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayId")
+    def transit_gateway_id(self) -> builtins.str:
+        '''The ID of this Transit Gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))
 
-    def __ne__(self, rhs: typing.Any) -> builtins.bool:
-        return not (rhs == self)
+    @builtins.property
+    @jsii.member(jsii_name="amazonSideAsn")
+    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
+        '''A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
 
-    def __repr__(self) -> str:
-        return "FluentBitOpenSearchOutputOptions(%s)" % ", ".join(
-            k + "=" + repr(v) for k, v in self._values.items()
-        )
+        The range is 64512 to 65534 for 16-bit ASNs.
 
+        :see: `TransitGateway.AmazonSideAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "amazonSideAsn"))
 
-@jsii.implements(IFluentBitPlugin)
-class FluentBitPlugin(
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitPlugin",
-):
-    '''A Fluent Bit plugin that allows for configuration of options and can be used to configure logging from containers.'''
+    @builtins.property
+    @jsii.member(jsii_name="defaultRouteTable")
+    def default_route_table(self) -> typing.Optional[ITransitGatewayRouteTable]:
+        '''The default route table that got created along with the Transit Gateway.
 
-    def __init__(self, *, name: builtins.str, plugin_type: FluentBitPluginType) -> None:
-        '''Creates a new instance of the FluentBitPlugin class.
+        This information is not exposed by CloudFormation. As such, this resource
+        will only be available if the default reoute table ID is passed in.
 
-        :param name: The name of the fluent bit plugin.
-        :param plugin_type: Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        :group: Resources
         '''
-        options = FluentBitPluginCommonOptions(name=name, plugin_type=plugin_type)
+        return typing.cast(typing.Optional[ITransitGatewayRouteTable], jsii.get(self, "defaultRouteTable"))
 
-        jsii.create(self.__class__, self, [options])
+    @builtins.property
+    @jsii.member(jsii_name="defaultRouteTableId")
+    def default_route_table_id(self) -> typing.Optional[builtins.str]:
+        '''The ID of the default route table that was created with the transit gateway.
 
-    @jsii.member(jsii_name="bind")
-    @abc.abstractmethod
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        This route table is critical to some transit gateway architectures and is
+        not exposed by CloudFormation.
 
-        :param scope: The construct configuring logging using Fluent Bit.
+        Passing in the ID of the default route table will make an object available
+        that represents it and can be used for further operations.
 
-        :return:
-
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :group: Inputs
         '''
-        ...
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultRouteTableId"))
 
-    @jsii.member(jsii_name="renderConfigFile")
-    def _render_config_file(
-        self,
-        config: typing.Mapping[builtins.str, typing.Any],
-    ) -> builtins.str:
-        '''
-        :param config: The configuration properties to render into a Fluent Bit configuration file.
+    @builtins.property
+    @jsii.member(jsii_name="description")
+    def description(self) -> typing.Optional[builtins.str]:
+        '''The description of the transit gateway.
 
-        :return: A fluent bit config file representation of the passed properties.
+        :see: `TransitGateway.Description <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__6444197d7722391a58b5da239897ee3a742da209a160dd73058c6c54dc737cf7)
-            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
-        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))
 
     @builtins.property
     @jsii.member(jsii_name="name")
-    def name(self) -> builtins.str:
-        '''The name of the fluent bit plugin.'''
-        return typing.cast(builtins.str, jsii.get(self, "name"))
-
-    @builtins.property
-    @jsii.member(jsii_name="pluginType")
-    def plugin_type(self) -> builtins.str:
-        '''The type of fluent bit plugin.'''
-        return typing.cast(builtins.str, jsii.get(self, "pluginType"))
-
-
-class _FluentBitPluginProxy(FluentBitPlugin):
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param scope: The construct configuring logging using Fluent Bit.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway.
 
-        :return:
+        Used to tag the transit gateway with a name that will be displayed in the
+        AWS VPC console.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :see: `TransitGateway.Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__acc47748e8c44554d5768c7501d9e6c9274e616d8bb24e8c9c64ec6e7ca82c4e)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, FluentBitPlugin).__jsii_proxy_class__ = lambda : _FluentBitPluginProxy
-
-
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitFilterPlugin")
-class IFluentBitFilterPlugin(IFluentBitPlugin, typing_extensions.Protocol):
-    '''Represents a Fluent Bit plugin that controls log filtering and metadata.'''
-
-    pass
-
-
-class _IFluentBitFilterPluginProxy(
-    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
-):
-    '''Represents a Fluent Bit plugin that controls log filtering and metadata.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitFilterPlugin"
-    pass
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IFluentBitFilterPlugin).__jsii_proxy_class__ = lambda : _IFluentBitFilterPluginProxy
-
-
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitOutputPlugin")
-class IFluentBitOutputPlugin(IFluentBitPlugin, typing_extensions.Protocol):
-    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
-
-    pass
-
-
-class _IFluentBitOutputPluginProxy(
-    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
-):
-    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
-
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitOutputPlugin"
-    pass
-
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IFluentBitOutputPlugin).__jsii_proxy_class__ = lambda : _IFluentBitOutputPluginProxy
-
-
-@jsii.interface(jsii_type="cdk-extensions.k8s_aws.IFluentBitParserPlugin")
-class IFluentBitParserPlugin(IFluentBitPlugin, typing_extensions.Protocol):
-    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
     @builtins.property
-    @jsii.member(jsii_name="format")
-    def format(self) -> builtins.str:
-        ...
-
-
-class _IFluentBitParserPluginProxy(
-    jsii.proxy_for(IFluentBitPlugin), # type: ignore[misc]
-):
-    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+    @jsii.member(jsii_name="resourceShare")
+    def resource_share(self) -> typing.Optional[_ResourceShare_f0180713]:
+        '''The RAM resource share that is used for sharing the transit gateway with other accounts.
 
-    __jsii_type__: typing.ClassVar[str] = "cdk-extensions.k8s_aws.IFluentBitParserPlugin"
+        :group: Resources
+        '''
+        return typing.cast(typing.Optional[_ResourceShare_f0180713], jsii.get(self, "resourceShare"))
 
     @builtins.property
-    @jsii.member(jsii_name="format")
-    def format(self) -> builtins.str:
-        return typing.cast(builtins.str, jsii.get(self, "format"))
+    @jsii.member(jsii_name="vpnEcmpSupport")
+    def vpn_ecmp_support(self) -> typing.Optional[builtins.bool]:
+        '''Enable or disable Equal Cost Multipath Protocol support.
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
-typing.cast(typing.Any, IFluentBitParserPlugin).__jsii_proxy_class__ = lambda : _IFluentBitParserPluginProxy
+        :see: `Achieve ECMP with multiple VPN tunnels <https://aws.amazon.com/premiumsupport/knowledge-center/transit-gateway-ecmp-multiple-tunnels/>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "vpnEcmpSupport"))
 
 
-class SecretsManagerSecretStore(
-    AwsSecretStore,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.SecretsManagerSecretStore",
+@jsii.implements(ITransitGatewayAttachment)
+class TransitGatewayAttachmentBase(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentBase",
 ):
-    '''A secret store that allows secrets from AWS Secrets Managers to be synchronized into Kubernetes as Kubernetes secrets.'''
+    '''A base class providing common functionality between created and imported Transit Gateway Attachments.'''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-        name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the SecretsManagerSecretStore class.
-
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        '''
+        :param scope: -
+        :param id: -
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__d0c3c962388492a04b5601f56b47b4dfbb0110dbd51c733afa1a9bed17ae16f9)
+            type_hints = typing.get_type_hints(_typecheckingstub__b49d47ed81c7ffb2a1650ef26c6a7262dbfbe5b02d6a33f4521aaba40facd96b)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = SecretsManagerSecretStoreProps(
-            cluster=cluster,
-            name=name,
-            namespace=namespace,
+        props = _aws_cdk_ceddda9d.ResourceProps(
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="addSecret")
-    def add_secret(
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
         self,
-        id: builtins.str,
-        secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> ExternalSecret:
-        '''Registers a new Secrets Manager secret to be synchronized into Kubernetes.
+        cidr: builtins.str,
+        route_table: ITransitGatewayRouteTable,
+    ) -> ITransitGatewayRoute:
+        '''Adds a route that directs traffic to this transit gateway attachment.
 
-        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the Secrets Manager secret it synchronizes and so must be unique per secret.
-        :param secret: The Secrets Manager secret to synchronize into Kubernetes.
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
+        :param cidr: CIDR range that should be routed to this attachment.
+        :param route_table: The transit gateway route table where the route should be added.
 
-        :return: The external secret configuration that was added.
+        :return: The TransitGatewayRoute that was added.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__6359c3f686f0688d1026d3fd4e13f56fdd12e614640211e1a20c6764506d0bde)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
-        options = ExternalSecretOptions(fields=fields, name=name)
+            type_hints = typing.get_type_hints(_typecheckingstub__3c4b8aae9fc7113caa263f0a78c3a90cd7457571433a27e89da36b0ae99fc4c6)
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
+        return typing.cast(ITransitGatewayRoute, jsii.invoke(self, "addRoute", [cidr, route_table]))
 
-        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, secret, options]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    @abc.abstractmethod
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway Attachment.'''
+        ...
 
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    @abc.abstractmethod
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The name of this Transit Gateway Attachment.'''
+        ...
 
-class SsmParameterSecretStore(
-    AwsSecretStore,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.SsmParameterSecretStore",
+
+class _TransitGatewayAttachmentBaseProxy(
+    TransitGatewayAttachmentBase,
+    jsii.proxy_for(_aws_cdk_ceddda9d.Resource), # type: ignore[misc]
+):
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
+
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The name of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
+
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, TransitGatewayAttachmentBase).__jsii_proxy_class__ = lambda : _TransitGatewayAttachmentBaseProxy
+
+
+class TransitGatewayAttachmentResource(
+    TransitGatewayAttachmentBase,
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentResource",
 ):
-    '''A secret store that allows parameters from Systems Manager to be synchronized into Kubernetes as Kubernetes secrets.'''
+    '''Attaches a VPC to a transit gateway.
+
+    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC
+    that is already attached, the new VPC CIDR range is not propagated to the
+    default propagation route table.
+    '''
 
     def __init__(
         self,
         scope: _constructs_77d1e7e8.Construct,
         id: builtins.str,
         *,
-        cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+        transit_gateway: ITransitGateway,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        appliance_mode_support: typing.Optional[builtins.bool] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        ipv6_support: typing.Optional[builtins.bool] = None,
         name: typing.Optional[builtins.str] = None,
-        namespace: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
         account: typing.Optional[builtins.str] = None,
         environment_from_arn: typing.Optional[builtins.str] = None,
         physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the SsmParameterSecretStore class.
+        '''Creates a new instance of the TransitGatewayAttachment class.
 
-        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
-        :param id: A name to be associated with the resource and used in resource naming. Must be unique within the context of 'scope'.
-        :param cluster: The EKS cluster where the secret store should be created.
-        :param name: A human friendly name for the secret store.
-        :param namespace: The Kubernetes namespace where the secret store should be created.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway: The transit gateway for which the attachment should be created.
+        :param vpc: The VPC where the attachment should be created.
+        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
+        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
         :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
         :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
         :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8a0341aaa28a58b67be791194cbc62d0dc6cb7590b8b514b48b86ddc4b19c218)
+            type_hints = typing.get_type_hints(_typecheckingstub__06c53aa420590eceea4fb9b075681a4977d93106ad928386f59f565ada883d5b)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
             check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-        props = SsmParameterSecretStoreProps(
-            cluster=cluster,
+        props = TransitGatewayAttachmentResourceProps(
+            transit_gateway=transit_gateway,
+            vpc=vpc,
+            appliance_mode_support=appliance_mode_support,
+            dns_support=dns_support,
+            ipv6_support=ipv6_support,
             name=name,
-            namespace=namespace,
+            subnets=subnets,
             account=account,
             environment_from_arn=environment_from_arn,
             physical_name=physical_name,
             region=region,
         )
 
         jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="addSecret")
-    def add_secret(
+    @jsii.member(jsii_name="translateBoolean")
+    def _translate_boolean(
         self,
-        id: builtins.str,
-        parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-        *,
-        fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-        name: typing.Optional[builtins.str] = None,
-    ) -> ExternalSecret:
-        '''Registers a new SSSM parameter to be synchronized into Kubernetes.
-
-        :param id: The ID of the secret import configuration in the CDK construct tree. The configuration is placed under the SSM parameter it synchronizes and so must be unique per secret.
-        :param parameter: The SSM parameter to synchronize into Kubernetes.
-        :param fields: A collection of field mappings that tells the external secrets operator the structure of the Kubernetes secret to create and which how fields in the Kubernetes secret should map to fields in the secret from the external secret provider. Default: The Kubernetes secret will mirror the fields from the secret in the external provider.
-        :param name: The name of the Kubernetes secret that will be created, as it will appear from within the Kubernetes cluster. Default: A name will be auto-generated.
-
-        :return: The external secret configuration that was added.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__e4726b5ae83a114c6d9a0343261df1f71b3fb8d8712d5e1a0e9dd6ffb85ada79)
-            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
-            check_type(argname="argument parameter", value=parameter, expected_type=type_hints["parameter"])
-        options = ExternalSecretOptions(fields=fields, name=name)
+        val: typing.Optional[builtins.bool] = None,
+    ) -> typing.Optional[builtins.str]:
+        '''Translates a boolean input into the strings used by the transit gateway attachment resource to implement boolean values.
 
-        return typing.cast(ExternalSecret, jsii.invoke(self, "addSecret", [id, parameter, options]))
+        :param val: The input value to translate.
 
+        :return:
 
-@jsii.implements(IFluentBitFilterPlugin)
-class FluentBitFilterPluginBase(
-    FluentBitPlugin,
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitFilterPluginBase",
-):
-    def __init__(
-        self,
-        name: builtins.str,
-        *,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitOutputPlugin class.
-
-        :param name: The name of the output plugin to configure.
-        :param match: The pattern to match for records that this output should apply to.
+        The string used to reprersent the input boolean or undefined if
+        the input boolean is undefined.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2b0341b3b1df86ed9b5aab4b4fadcc47fd710ae038076cca755f3c48acef6956)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitFilterPluginCommonOptions(match=match)
+            type_hints = typing.get_type_hints(_typecheckingstub__d9616ce11448deda7c7f7a6abcc3dc7343fd9d23bf7197f988d750a4ed8ab7b9)
+            check_type(argname="argument val", value=val, expected_type=type_hints["val"])
+        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "translateBoolean", [val]))
 
-        jsii.create(self.__class__, self, [name, options])
-
-    @jsii.member(jsii_name="renderConfigFile")
-    def _render_config_file(
-        self,
-        config: typing.Mapping[builtins.str, typing.Any],
-    ) -> builtins.str:
-        '''Renders a Fluent Bit configuration file for the plugin.
+    @builtins.property
+    @jsii.member(jsii_name="subnets")
+    def subnets(self) -> _aws_cdk_aws_ec2_ceddda9d.SubnetSelection:
+        '''The subnets where the attachment should be created.
 
-        :param config: The configuration options to render into a configuration file.
+        Can select up to one subnet per Availability Zone.
 
-        :return: A rendered plugin configuration file.
+        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dd92e8237c9a3e0963fb6f8aa69a0ef0b1b6cb8403264e0fdd57816a24a83f04)
-            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
-        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, jsii.get(self, "subnets"))
 
     @builtins.property
-    @jsii.member(jsii_name="match")
-    def match(self) -> FluentBitMatch:
-        '''The pattern to match for records that this output should apply to.
+    @jsii.member(jsii_name="transitGateway")
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway for which the attachment should be created.
 
         :group: Inputs
         '''
-        return typing.cast(FluentBitMatch, jsii.get(self, "match"))
+        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
 
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    @abc.abstractmethod
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway Attachment.'''
+        ...
 
-class _FluentBitFilterPluginBaseProxy(
-    FluentBitFilterPluginBase,
-    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
-):
-    pass
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    @abc.abstractmethod
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of this Transit Gateway Attachment.'''
+        ...
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, FluentBitFilterPluginBase).__jsii_proxy_class__ = lambda : _FluentBitFilterPluginBaseProxy
+    @builtins.property
+    @jsii.member(jsii_name="vpc")
+    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
+        '''The VPC where the attachment should be created.
 
+        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
+        :group: Inputs
+        '''
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, jsii.get(self, "vpc"))
 
-class FluentBitGrepFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitGrepFilter",
-):
-    '''A Fluent Bit filter that allows log records to be kept or discarded based on whether they match a given regular expression or not.'''
+    @builtins.property
+    @jsii.member(jsii_name="applianceModeSupport")
+    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables appliance mode on the attachment.
 
-    def __init__(
-        self,
-        *,
-        pattern: typing.Union[FluentBitGrepRegex, typing.Dict[builtins.str, typing.Any]],
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
+        When appliance mode is enabled, all traffic flowing between attachments is
+        forwarded to an appliance in a shared VPC to be inspected and processed.
 
-        :param pattern: The pattern to use for filtering records processed by the plugin.
-        :param match: The pattern to match for records that this output should apply to.
+        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
+        :group: Inputs
         '''
-        options = FluentBitGrepFilterOptions(pattern=pattern, match=match)
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "applianceModeSupport"))
 
-        jsii.create(self.__class__, self, [options])
+    @builtins.property
+    @jsii.member(jsii_name="dnsSupport")
+    def dns_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "dnsSupport"))
 
-        :return:
+    @builtins.property
+    @jsii.member(jsii_name="ipv6Support")
+    def ipv6_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
+
+        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5ad4b94abc52cd50668ebd6e0a941de90c4ed68a322b0c4bd1bf8f5d132edd78)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "ipv6Support"))
 
     @builtins.property
-    @jsii.member(jsii_name="pattern")
-    def pattern(self) -> FluentBitGrepRegex:
-        '''The pattern to use for filtering records processed by the plugin.
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Transit Gateway Attachment.
 
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
+
+        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
         :group: Inputs
         '''
-        return typing.cast(FluentBitGrepRegex, jsii.get(self, "pattern"))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
 
-class FluentBitKubernetesFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKubernetesFilter",
+class _TransitGatewayAttachmentResourceProxy(
+    TransitGatewayAttachmentResource,
+    jsii.proxy_for(TransitGatewayAttachmentBase), # type: ignore[misc]
 ):
-    '''A Fluent Bit filter that allows log records to be annotated with Kubernetes metadata based on the containers that generated them.'''
-
-    def __init__(
-        self,
-        *,
-        annotations: typing.Optional[builtins.bool] = None,
-        buffer_size: typing.Optional[_DataSize_d20aaece] = None,
-        cache_use_docker_id: typing.Optional[builtins.bool] = None,
-        dns_retries: typing.Optional[jsii.Number] = None,
-        dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        dummy_meta: typing.Optional[builtins.bool] = None,
-        k8s_logging_exclude: typing.Optional[builtins.bool] = None,
-        k8s_logging_parser: typing.Optional[builtins.bool] = None,
-        keep_log: typing.Optional[builtins.bool] = None,
-        kube_ca_file: typing.Optional[builtins.str] = None,
-        kube_ca_path: typing.Optional[builtins.str] = None,
-        kubelet_host: typing.Optional[builtins.str] = None,
-        kubelet_port: typing.Optional[jsii.Number] = None,
-        kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
-        kube_tag_prefix: typing.Optional[builtins.str] = None,
-        kube_token_command: typing.Optional[builtins.str] = None,
-        kube_token_file: typing.Optional[builtins.str] = None,
-        kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        kube_url: typing.Optional[builtins.str] = None,
-        labels: typing.Optional[builtins.bool] = None,
-        merge_log: typing.Optional[builtins.bool] = None,
-        merge_log_key: typing.Optional[builtins.str] = None,
-        merge_log_trim: typing.Optional[builtins.bool] = None,
-        merge_parser: typing.Optional[builtins.str] = None,
-        regex_parser: typing.Optional[builtins.str] = None,
-        tls_debug: typing.Optional[jsii.Number] = None,
-        tls_verify: typing.Optional[builtins.bool] = None,
-        use_journal: typing.Optional[builtins.bool] = None,
-        use_kubelet: typing.Optional[builtins.bool] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitKubernetesFilter class.
-
-        :param annotations: Include Kubernetes resource annotations in the extra metadata. Default: true
-        :param buffer_size: Set the buffer size for HTTP client when reading responses from Kubernetes API server. A value of 0 results in no limit, and the buffer will expand as-needed. Note that if pod specifications exceed the buffer limit, the API response will be discarded when retrieving metadata, and some kubernetes metadata will fail to be injected to the logs. Default: 32k
-        :param cache_use_docker_id: When enabled, metadata will be fetched from K8s when docker_id is changed. Default: false
-        :param dns_retries: DNS lookup retries N times until the network starts working. Default: 6
-        :param dns_wait_time: DNS lookup interval between network status checks. Default: 30 seconds
-        :param dummy_meta: If set, use dummy-meta data (for test/dev purposes). Default: false
-        :param k8s_logging_exclude: Allow Kubernetes Pods to exclude their logs from the log processor. Default: false
-        :param k8s_logging_parser: Allow Kubernetes Pods to suggest a pre-defined Parser. Default: false
-        :param keep_log: When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well). Default: true
-        :param kube_ca_file: CA certificate file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
-        :param kube_ca_path: Absolute path to scan for certificate files.
-        :param kubelet_host: Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
-        :param kubelet_port: Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled. Default: 10250
-        :param kube_meta_cache_ttl: Configurable TTL for K8s cached metadata. By default, it is set to 0 which means TTL for cache entries is disabled and cache entries are evicted at random when capacity is reached. In order to enable this option, you should set the number to a time interval. Default: 0
-        :param kube_meta_preload_cache_dir: If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
-        :param kube_tag_prefix: When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration. Default: 'kube.var.log.containers.'
-        :param kube_token_command: Command to get Kubernetes authorization token. If you want to manually choose a command to get it, you can set the command here. For example, run running the following to get the token using aws-cli:: aws-iam-authenticator -i your-cluster-name token --token-only This option is currently Linux-only.
-        :param kube_token_file: Token file. Default: '/var/run/secrets/kubernetes.io/serviceaccount/token'
-        :param kube_token_ttl: Configurable 'time to live' for the K8s token. After this time, the token is reloaded from ``kubeTokenFile`` or the ``kubeTokenCommand``. Default: 10 minutes
-        :param kube_url: API Server end-point. Default: 'https://kubernetes.default.svc/'
-        :param labels: Include Kubernetes resource labels in the extra metadata. Default: true
-        :param merge_log: When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure. Default: false
-        :param merge_log_key: When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map. Now if ``mergeLogKey`` is set (a string name), all the new structured fields taken from the original ``log`` content are inserted under the new key.
-        :param merge_log_trim: When Merge_Log is enabled, trim (remove possible \\n or \\r) field values. Default: true
-        :param merge_parser: Optional parser name to specify how to parse the data contained in the log key. Recommended use is for developers or testing only.
-        :param regex_parser: Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id. The parser must be registered in a parsers file.
-        :param tls_debug: Debug level between 0 (nothing) and 4 (every detail). Default: -1
-        :param tls_verify: When enabled, turns on certificate validation when connecting to the Kubernetes API server. Default: true
-        :param use_journal: When enabled, the filter reads logs coming in Journald format. Default: false
-        :param use_kubelet: This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log. Default: false
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitKubernetesFilterOptions(
-            annotations=annotations,
-            buffer_size=buffer_size,
-            cache_use_docker_id=cache_use_docker_id,
-            dns_retries=dns_retries,
-            dns_wait_time=dns_wait_time,
-            dummy_meta=dummy_meta,
-            k8s_logging_exclude=k8s_logging_exclude,
-            k8s_logging_parser=k8s_logging_parser,
-            keep_log=keep_log,
-            kube_ca_file=kube_ca_file,
-            kube_ca_path=kube_ca_path,
-            kubelet_host=kubelet_host,
-            kubelet_port=kubelet_port,
-            kube_meta_cache_ttl=kube_meta_cache_ttl,
-            kube_meta_preload_cache_dir=kube_meta_preload_cache_dir,
-            kube_tag_prefix=kube_tag_prefix,
-            kube_token_command=kube_token_command,
-            kube_token_file=kube_token_file,
-            kube_token_ttl=kube_token_ttl,
-            kube_url=kube_url,
-            labels=labels,
-            merge_log=merge_log,
-            merge_log_key=merge_log_key,
-            merge_log_trim=merge_log_trim,
-            merge_parser=merge_parser,
-            regex_parser=regex_parser,
-            tls_debug=tls_debug,
-            tls_verify=tls_verify,
-            use_journal=use_journal,
-            use_kubelet=use_kubelet,
-            match=match,
-        )
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
 
-        jsii.create(self.__class__, self, [options])
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, TransitGatewayAttachmentResource).__jsii_proxy_class__ = lambda : _TransitGatewayAttachmentResourceProxy
 
-        :param _scope: The construct configuring logging using Fluent Bit.
 
-        :return:
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentResourceProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "transit_gateway": "transitGateway",
+        "vpc": "vpc",
+        "appliance_mode_support": "applianceModeSupport",
+        "dns_support": "dnsSupport",
+        "ipv6_support": "ipv6Support",
+        "name": "name",
+        "subnets": "subnets",
+    },
+)
+class TransitGatewayAttachmentResourceProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        transit_gateway: ITransitGateway,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        appliance_mode_support: typing.Optional[builtins.bool] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        ipv6_support: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
+        '''Configuration for TransitGatewayAttachmentResource resource.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param transit_gateway: The transit gateway for which the attachment should be created.
+        :param vpc: The VPC where the attachment should be created.
+        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
+        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
         '''
+        if isinstance(subnets, dict):
+            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5953f10fbafcde2546e1cf7a12bdade9d093857e166f6d1fb4bab50e2a66f14b)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PLUGIN_NAME")
-    def PLUGIN_NAME(cls) -> builtins.str:
-        '''The name of the plugin as it will appear in the fluent bit configuration.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "PLUGIN_NAME"))
+            type_hints = typing.get_type_hints(_typecheckingstub__3d1c15189bbc90871ac0f1cb7928d7a06dc7a543bed65a3917a78189021d8767)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+            check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
+            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
+            check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "transit_gateway": transit_gateway,
+            "vpc": vpc,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if appliance_mode_support is not None:
+            self._values["appliance_mode_support"] = appliance_mode_support
+        if dns_support is not None:
+            self._values["dns_support"] = dns_support
+        if ipv6_support is not None:
+            self._values["ipv6_support"] = ipv6_support
+        if name is not None:
+            self._values["name"] = name
+        if subnets is not None:
+            self._values["subnets"] = subnets
 
     @builtins.property
-    @jsii.member(jsii_name="annotations")
-    def annotations(self) -> typing.Optional[builtins.bool]:
-        '''Include Kubernetes resource annotations in the extra metadata.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "annotations"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="bufferSize")
-    def buffer_size(self) -> typing.Optional[_DataSize_d20aaece]:
-        '''Set the buffer size for HTTP client when reading responses from Kubernetes API server.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        A value of 0 results in no limit, and the buffer will expand as-needed.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        Note that if pod specifications exceed the buffer limit, the API
-        response will be discarded when retrieving metadata, and some kubernetes
-        metadata will fail to be injected to the logs.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :group: Inputs
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(typing.Optional[_DataSize_d20aaece], jsii.get(self, "bufferSize"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="cacheUseDockerId")
-    def cache_use_docker_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, metadata will be fetched from K8s when docker_id is changed.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :group: Inputs
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "cacheUseDockerId"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="dnsRetries")
-    def dns_retries(self) -> typing.Optional[jsii.Number]:
-        '''DNS lookup retries N times until the network starts working.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "dnsRetries"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="dnsWaitTime")
-    def dns_wait_time(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''DNS lookup interval between network status checks.
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway for which the attachment should be created.
 
-        :group: Inputs
+        :see: `TransitGatewayVpcAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid>`_
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "dnsWaitTime"))
+        result = self._values.get("transit_gateway")
+        assert result is not None, "Required property 'transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
     @builtins.property
-    @jsii.member(jsii_name="dummyMeta")
-    def dummy_meta(self) -> typing.Optional[builtins.bool]:
-        '''If set, use dummy-meta data (for test/dev purposes).
+    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
+        '''The VPC where the attachment should be created.
 
-        :group: Inputs
+        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "dummyMeta"))
+        result = self._values.get("vpc")
+        assert result is not None, "Required property 'vpc' is missing"
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
 
     @builtins.property
-    @jsii.member(jsii_name="k8sLoggingExclude")
-    def k8s_logging_exclude(self) -> typing.Optional[builtins.bool]:
-        '''Allow Kubernetes Pods to exclude their logs from the log processor.
+    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables appliance mode on the attachment.
 
-        :group: Inputs
+        When appliance mode is enabled, all traffic flowing between attachments is
+        forwarded to an appliance in a shared VPC to be inspected and processed.
+
+        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "k8sLoggingExclude"))
+        result = self._values.get("appliance_mode_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="k8sLoggingParser")
-    def k8s_logging_parser(self) -> typing.Optional[builtins.bool]:
-        '''Allow Kubernetes Pods to suggest a pre-defined Parser.
+    def dns_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-        :group: Inputs
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
+
+        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "k8sLoggingParser"))
+        result = self._values.get("dns_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="keepLog")
-    def keep_log(self) -> typing.Optional[builtins.bool]:
-        '''When ``keepLog`` is disabled, the log field is removed from the incoming message once it has been successfully merged (``mergeLog`` must be enabled as well).
+    def ipv6_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-        :group: Inputs
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
+
+        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "keepLog"))
+        result = self._values.get("ipv6_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="kubeCaFile")
-    def kube_ca_file(self) -> typing.Optional[builtins.str]:
-        '''CA certificate file.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Transit Gateway Attachment.
 
-        :group: Inputs
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
+
+        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeCaFile"))
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="kubeCaPath")
-    def kube_ca_path(self) -> typing.Optional[builtins.str]:
-        '''Absolute path to scan for certificate files.
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''The subnets where the attachment should be created.
 
-        :group: Inputs
+        Can select up to one subnet per Availability Zone.
+
+        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeCaPath"))
+        result = self._values.get("subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
 
-    @builtins.property
-    @jsii.member(jsii_name="kubeletHost")
-    def kubelet_host(self) -> typing.Optional[builtins.str]:
-        '''Kubelet host using for HTTP request, this only works when ``useKubelet`` is enabled.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeletHost"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="kubeletPort")
-    def kubelet_port(self) -> typing.Optional[jsii.Number]:
-        '''Kubelet port using for HTTP request, this only works when ``useKubelet`` is enabled.
+    def __repr__(self) -> str:
+        return "TransitGatewayAttachmentResourceProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "kubeletPort"))
 
-    @builtins.property
-    @jsii.member(jsii_name="kubeMetaCacheTtl")
-    def kube_meta_cache_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''Configurable TTL for K8s cached metadata.
+@jsii.implements(ILocalVpnEndpoint)
+class TransitGatewayLocalVpnEndpoint(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TransitGatewayLocalVpnEndpoint",
+):
+    '''Specifies a VPN connection endpoint which routes to a transit gateway on the AWS side.'''
 
-        By default, it is set to 0 which means TTL for cache entries is disabled
-        and cache entries are evicted at random when capacity is reached.
+    def __init__(self, transit_gateway: ITransitGateway) -> None:
+        '''Creates a new instance of the TransitGatewayLocalVpnEndpoint class.
 
-        In order to enable this option, you should set the number to a time
-        interval.
+        :param transit_gateway: The transit gateway that serves as the local end of a VPN connection.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__085d2039b0a4b4caf19e1943608efeb5e97be1be7d732ad9e6c87845449f8c0e)
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+        jsii.create(self.__class__, self, [transit_gateway])
 
-        :group: Inputs
+    @jsii.member(jsii_name="bind")
+    def bind(
+        self,
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> LocalVpnEndpointConfiguration:
+        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
+
+        :param _scope: The construct configuring the VPN connection that will be referencing the local endpoint.
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "kubeMetaCacheTtl"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1649477704b8d5959bab11d00a58a0814e904ca0755f79fc92c902b7548831e8)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(LocalVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="kubeMetaPreloadCacheDir")
-    def kube_meta_preload_cache_dir(self) -> typing.Optional[builtins.str]:
-        '''If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta.
+    @jsii.member(jsii_name="transitGateway")
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway that serves as the local end of a VPN connection.
 
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeMetaPreloadCacheDir"))
+        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
 
-    @builtins.property
-    @jsii.member(jsii_name="kubeTagPrefix")
-    def kube_tag_prefix(self) -> typing.Optional[builtins.str]:
-        '''When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration.
 
-        :group: Inputs
+class TransitGatewayNatProvider(
+    _aws_cdk_aws_ec2_ceddda9d.NatProvider,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TransitGatewayNatProvider",
+):
+    def __init__(self, *, transit_gateway: ITransitGateway) -> None:
+        '''
+        :param transit_gateway: 
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTagPrefix"))
+        options = TransitGatewayNatProviderOptions(transit_gateway=transit_gateway)
 
-    @builtins.property
-    @jsii.member(jsii_name="kubeTokenCommand")
-    def kube_token_command(self) -> typing.Optional[builtins.str]:
-        '''Command to get Kubernetes authorization token.
+        jsii.create(self.__class__, self, [options])
 
-        If you want to manually choose a command to get it, you can set the
-        command here.
+    @jsii.member(jsii_name="configureNat")
+    def configure_nat(
+        self,
+        *,
+        nat_subnets: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.PublicSubnet],
+        private_subnets: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.PrivateSubnet],
+        vpc: _aws_cdk_aws_ec2_ceddda9d.Vpc,
+    ) -> None:
+        '''Called by the VPC to configure NAT
+
+Don't call this directly, the VPC will call it automatically.
 
-        For example, run running the following to get the token using aws-cli::
+        :param nat_subnets: The public subnets where the NAT providers need to be placed.
+        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
+        :param vpc: The VPC we're configuring NAT for.
+        '''
+        options = _aws_cdk_aws_ec2_ceddda9d.ConfigureNatOptions(
+            nat_subnets=nat_subnets, private_subnets=private_subnets, vpc=vpc
+        )
 
-           aws-iam-authenticator -i your-cluster-name token --token-only
+        return typing.cast(None, jsii.invoke(self, "configureNat", [options]))
 
-        This option is currently Linux-only.
+    @jsii.member(jsii_name="configureSubnet")
+    def configure_subnet(self, subnet: _aws_cdk_aws_ec2_ceddda9d.PrivateSubnet) -> None:
+        '''Configures subnet with the gateway
 
-        :group: Inputs
+Don't call this directly, the VPC will call it automatically.
+
+        :param subnet: -
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTokenCommand"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__2ce5b6c12f42e572c0fd8116f08202bd45321782d0dface0d78758e8ae4afce0)
+            check_type(argname="argument subnet", value=subnet, expected_type=type_hints["subnet"])
+        return typing.cast(None, jsii.invoke(self, "configureSubnet", [subnet]))
 
     @builtins.property
-    @jsii.member(jsii_name="kubeTokenFile")
-    def kube_token_file(self) -> typing.Optional[builtins.str]:
-        '''Token file.
+    @jsii.member(jsii_name="configuredGateways")
+    def configured_gateways(
+        self,
+    ) -> typing.List[_aws_cdk_aws_ec2_ceddda9d.GatewayConfig]:
+        '''Return list of gateways spawned by the provider.'''
+        return typing.cast(typing.List[_aws_cdk_aws_ec2_ceddda9d.GatewayConfig], jsii.get(self, "configuredGateways"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeTokenFile"))
+    @builtins.property
+    @jsii.member(jsii_name="transitGateway")
+    def transit_gateway(self) -> ITransitGateway:
+        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
 
     @builtins.property
-    @jsii.member(jsii_name="kubeTokenTtl")
-    def kube_token_ttl(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
-        '''Configurable 'time to live' for the K8s token.
+    @jsii.member(jsii_name="transitGatewayAttachment")
+    def transit_gateway_attachment(self) -> typing.Optional["TransitGatewayAttachment"]:
+        return typing.cast(typing.Optional["TransitGatewayAttachment"], jsii.get(self, "transitGatewayAttachment"))
 
-        After this time, the token is reloaded from ``kubeTokenFile`` or the
-        ``kubeTokenCommand``.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayNatProviderOptions",
+    jsii_struct_bases=[],
+    name_mapping={"transit_gateway": "transitGateway"},
+)
+class TransitGatewayNatProviderOptions:
+    def __init__(self, *, transit_gateway: ITransitGateway) -> None:
+        '''
+        :param transit_gateway: 
         '''
-        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], jsii.get(self, "kubeTokenTtl"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3d866260e3cfdb20c411a4b77ce2ef5ed9046a68ea0356988681824395af2b48)
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "transit_gateway": transit_gateway,
+        }
 
     @builtins.property
-    @jsii.member(jsii_name="kubeUrl")
-    def kube_url(self) -> typing.Optional[builtins.str]:
-        '''API Server end-point.
+    def transit_gateway(self) -> ITransitGateway:
+        result = self._values.get("transit_gateway")
+        assert result is not None, "Required property 'transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kubeUrl"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="labels")
-    def labels(self) -> typing.Optional[builtins.bool]:
-        '''Include Kubernetes resource labels in the extra metadata.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "labels"))
+    def __repr__(self) -> str:
+        return "TransitGatewayNatProviderOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="mergeLog")
-    def merge_log(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it checks if the ``log`` field content is a JSON string map, if so, it append the map fields as part of the log structure.
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "mergeLog"))
+@jsii.implements(ITransitGatewayPeeringAttachment)
+class TransitGatewayPeeringAttachment(
+    TransitGatewayAttachmentBase,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachment",
+):
+    '''Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter).
 
-    @builtins.property
-    @jsii.member(jsii_name="mergeLogKey")
-    def merge_log_key(self) -> typing.Optional[builtins.str]:
-        '''When ``mergeLog`` is enabled, the filter tries to assume the ``log`` field from the incoming message is a JSON string message and make a structured representation of it at the same level of the ``log`` field in the map.
+    The peer transit
+    gateway can be in your account or a different AWS account.
 
-        Now if ``mergeLogKey`` is set (a string name), all the new structured
-        fields taken from the original ``log`` content are inserted under the new
-        key.
+    After you create the peering attachment, the owner of the accepter transit
+    gateway must accept the attachment request.
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mergeLogKey"))
+    :see: `AWS::EC2::TransitGatewayPeeringAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html>`_
+    '''
 
-    @builtins.property
-    @jsii.member(jsii_name="mergeLogTrim")
-    def merge_log_trim(self) -> typing.Optional[builtins.bool]:
-        '''When Merge_Log is enabled, trim (remove possible \\n or \\r) field values.
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        local_transit_gateway: ITransitGateway,
+        peer_transit_gateway: ITransitGateway,
+        name: typing.Optional[builtins.str] = None,
+        peer_account_id: typing.Optional[builtins.str] = None,
+        peer_region: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the TransitGatewayPeeringAttachment class.
 
-        :group: Inputs
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param local_transit_gateway: The local side of the transit gateway peering connection.
+        :param peer_transit_gateway: The remote transit gateway being peered with.
+        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param peer_account_id: The account that contains the transit gateway being peered with.
+        :param peer_region: The region that contains the transit gateway being peered with.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "mergeLogTrim"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__094bd3c738b0a006e2a59600942e6cb57ce41b066d2acabef2f32729f9b6c14c)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = TransitGatewayPeeringAttachmentProps(
+            local_transit_gateway=local_transit_gateway,
+            peer_transit_gateway=peer_transit_gateway,
+            name=name,
+            peer_account_id=peer_account_id,
+            peer_region=peer_region,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="mergeParser")
-    def merge_parser(self) -> typing.Optional[builtins.str]:
-        '''Optional parser name to specify how to parse the data contained in the log key.
+        jsii.create(self.__class__, self, [scope, id, props])
 
-        Recommended use is for developers or testing only.
+    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentArn")
+    @builtins.classmethod
+    def from_transit_gateway_peering_attachment_arn(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        arn: builtins.str,
+    ) -> ITransitGatewayPeeringAttachment:
+        '''Imports an existing transit gateway peering attachment using its ARN.
 
-        :group: Inputs
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param arn: The Amazon Resource Name (ARN) of the resource being imported.
+
+        :return:
+
+        An object representing the imported transit gateway peering
+        attachment.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "mergeParser"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__d64bc0ce43e9c832901d2f4073f54276e12b588a41c623026825482bf1d43c63)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
+        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentArn", [scope, id, arn]))
 
-    @builtins.property
-    @jsii.member(jsii_name="regexParser")
-    def regex_parser(self) -> typing.Optional[builtins.str]:
-        '''Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id.
+    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentAttributes")
+    @builtins.classmethod
+    def from_transit_gateway_peering_attachment_attributes(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        *,
+        arn: typing.Optional[builtins.str] = None,
+        attachment_id: typing.Optional[builtins.str] = None,
+        creation_time: typing.Optional[builtins.str] = None,
+        state: typing.Optional[builtins.str] = None,
+        status: typing.Optional[builtins.str] = None,
+        status_code: typing.Optional[builtins.str] = None,
+        status_message: typing.Optional[builtins.str] = None,
+    ) -> ITransitGatewayPeeringAttachment:
+        '''Imports an existing transit gateway peering attachment by defining its components.
+
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param arn: The ARN of this Transit Gateway Attachment.
+        :param attachment_id: The ID of this Transit Gateway Attachment.
+        :param creation_time: The time the transit gateway peering attachment was created.
+        :param state: The state of the transit gateway peering attachment.
+        :param status: The status of the transit gateway peering attachment.
+        :param status_code: The status code for the current status of the attachment.
+        :param status_message: The status message for the current status of the attachment.
 
-        The parser must be registered in a parsers file.
+        :return:
 
-        :see: `Parsers File <https://github.com/fluent/fluent-bit/blob/master/conf/parsers.conf>`_
-        :group: Inputs
+        An object representing the imported transit gateway peering
+        attachment.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "regexParser"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__9b9ddfaf131e6a5091a636a0dad2dd2579ae4140b68c99fe5fee2e2506d45105)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        attrs = TransitGatewayPeeringAttachmentImportAttributes(
+            arn=arn,
+            attachment_id=attachment_id,
+            creation_time=creation_time,
+            state=state,
+            status=status,
+            status_code=status_code,
+            status_message=status_message,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="tlsDebug")
-    def tls_debug(self) -> typing.Optional[jsii.Number]:
-        '''Debug level between 0 (nothing) and 4 (every detail).
+        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentAttributes", [scope, id, attrs]))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "tlsDebug"))
+    @jsii.member(jsii_name="fromTransitGatewayPeeringAttachmentId")
+    @builtins.classmethod
+    def from_transit_gateway_peering_attachment_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        attachment_id: builtins.str,
+    ) -> ITransitGatewayPeeringAttachment:
+        '''Imports an existing transit gateway peering attachment using its attachment ID.
 
-    @builtins.property
-    @jsii.member(jsii_name="tlsVerify")
-    def tls_verify(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, turns on certificate validation when connecting to the Kubernetes API server.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param attachment_id: The ID of the resource being imported.
 
-        :group: Inputs
+        :return:
+
+        An object representing the imported transit gateway peering
+        attachment.
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "tlsVerify"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__fe35553be2f81ae71d207839c426c22b6542d57d2604a744dec33a748b8631f6)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument attachment_id", value=attachment_id, expected_type=type_hints["attachment_id"])
+        return typing.cast(ITransitGatewayPeeringAttachment, jsii.sinvoke(cls, "fromTransitGatewayPeeringAttachmentId", [scope, id, attachment_id]))
 
     @builtins.property
-    @jsii.member(jsii_name="useJournal")
-    def use_journal(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, the filter reads logs coming in Journald format.
+    @jsii.member(jsii_name="localTransitGateway")
+    def local_transit_gateway(self) -> ITransitGateway:
+        '''The local side of the transit gateway peering connection.
 
+        :see: `TransitGatewayPeeringAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "useJournal"))
+        return typing.cast(ITransitGateway, jsii.get(self, "localTransitGateway"))
 
     @builtins.property
-    @jsii.member(jsii_name="useKubelet")
-    def use_kubelet(self) -> typing.Optional[builtins.bool]:
-        '''This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log.
+    @jsii.member(jsii_name="peerTransitGateway")
+    def peer_transit_gateway(self) -> ITransitGateway:
+        '''The remote transit gateway being peered with.
 
-        :see: `Kube API heavy traffic issue for large cluster <https://docs.fluentbit.io/manual/pipeline/filters/kubernetes#optional-feature-using-kubelet-to-get-metadata>`_
+        :see: `TransitGatewayPeeringAttachment PeerTransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "useKubelet"))
-
+        return typing.cast(ITransitGateway, jsii.get(self, "peerTransitGateway"))
 
-class FluentBitModifyFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitModifyFilter",
-):
-    '''A Fluent Bit filter that allows changing records using rules and conditions.'''
-
-    def __init__(
-        self,
-        *,
-        conditions: typing.Optional[typing.Sequence[ModifyCondition]] = None,
-        operations: typing.Optional[typing.Sequence[ModifyOperation]] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitModifyFilter class.
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayPeeringAttachment:
+        '''The underlying TransitGatewayRouteTable CloudFormation resource.
 
-        :param conditions: 
-        :param operations: 
-        :param match: The pattern to match for records that this output should apply to.
+        :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
+        :group: Resources
         '''
-        options = FluentBitModifyFilterOptions(
-            conditions=conditions, operations=operations, match=match
-        )
-
-        jsii.create(self.__class__, self, [options])
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayPeeringAttachment, jsii.get(self, "resource"))
 
-    @jsii.member(jsii_name="addCondition")
-    def add_condition(self, condition: ModifyCondition) -> "FluentBitModifyFilter":
-        '''Adds a new condition to the modify filter.
-
-        All conditions must evaluate to ``true`` in order for operations are
-        performed.
-
-        If one or more conditions do not evaluate to true, no conditions are
-        performed.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
 
-        :param condition: The condition to add to the filter.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentCreationTime")
+    def transit_gateway_attachment_creation_time(self) -> builtins.str:
+        '''The time the transit gateway peering attachment was created.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentCreationTime"))
 
-        :return: The modify filter to which the condition was added.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__60894bd40aca48d31e52eb990ad104ed6b9b8b2602d5bae83cb8098f2ea83f1a)
-            check_type(argname="argument condition", value=condition, expected_type=type_hints["condition"])
-        return typing.cast("FluentBitModifyFilter", jsii.invoke(self, "addCondition", [condition]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of this transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
 
-    @jsii.member(jsii_name="addOperation")
-    def add_operation(self, operation: ModifyOperation) -> "FluentBitModifyFilter":
-        '''Adds a new operation to the modify filter.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentState")
+    def transit_gateway_attachment_state(self) -> builtins.str:
+        '''The state of the transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentState"))
 
-        :param operation: The operation to add to the filter.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatus")
+    def transit_gateway_attachment_status(self) -> builtins.str:
+        '''The status of the transit gateway peering attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatus"))
 
-        :return: The modify filter to which the operation was added.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4872512d801b614d842132e607c71d6d758968a7609d124502601dd7de57178a)
-            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
-        return typing.cast("FluentBitModifyFilter", jsii.invoke(self, "addOperation", [operation]))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusCode")
+    def transit_gateway_attachment_status_code(self) -> builtins.str:
+        '''The status code for the current status of the attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusCode"))
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayAttachmentStatusMessage")
+    def transit_gateway_attachment_status_message(self) -> builtins.str:
+        '''The status message for the current status of the attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentStatusMessage"))
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway peering attachment.
 
-        :return:
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
+        :group: Inputs
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8290d1192e5d252ca7834f51af4ac7230139ac8edc7a97b45248f244d5803b08)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
     @builtins.property
-    @jsii.member(jsii_name="conditions")
-    def conditions(self) -> typing.List[ModifyCondition]:
-        '''Collection of conditions to apply for the filter.'''
-        return typing.cast(typing.List[ModifyCondition], jsii.get(self, "conditions"))
+    @jsii.member(jsii_name="peerAccountId")
+    def peer_account_id(self) -> typing.Optional[builtins.str]:
+        '''The account that contains the transit gateway being peered with.
+
+        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerAccountId"))
 
     @builtins.property
-    @jsii.member(jsii_name="operations")
-    def operations(self) -> typing.List[ModifyOperation]:
-        '''Collection of operations to apply for the filter.'''
-        return typing.cast(typing.List[ModifyOperation], jsii.get(self, "operations"))
+    @jsii.member(jsii_name="peerRegion")
+    def peer_region(self) -> typing.Optional[builtins.str]:
+        '''The region that contains the transit gateway being peered with.
 
+        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
+        :group: Inputs
+        '''
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerRegion"))
 
-class FluentBitNestFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitNestFilter",
-):
-    '''A Fluent Bit filter that allows operating on or with nested data.'''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentImportAttributes",
+    jsii_struct_bases=[],
+    name_mapping={
+        "arn": "arn",
+        "attachment_id": "attachmentId",
+        "creation_time": "creationTime",
+        "state": "state",
+        "status": "status",
+        "status_code": "statusCode",
+        "status_message": "statusMessage",
+    },
+)
+class TransitGatewayPeeringAttachmentImportAttributes:
     def __init__(
         self,
         *,
-        operation: NestFilterOperation,
-        add_prefix: typing.Optional[builtins.str] = None,
-        remove_prefix: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitNestFilter class.
-
-        :param operation: The operation the filter will perform.
-        :param add_prefix: Prefix affected keys with this string.
-        :param remove_prefix: Remove prefix from affected keys if it matches this string.
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitNestFilterOptions(
-            operation=operation,
-            add_prefix=add_prefix,
-            remove_prefix=remove_prefix,
-            match=match,
-        )
-
-        jsii.create(self.__class__, self, [options])
+        arn: typing.Optional[builtins.str] = None,
+        attachment_id: typing.Optional[builtins.str] = None,
+        creation_time: typing.Optional[builtins.str] = None,
+        state: typing.Optional[builtins.str] = None,
+        status: typing.Optional[builtins.str] = None,
+        status_code: typing.Optional[builtins.str] = None,
+        status_message: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration options for importing a transit gateway peering attachment.
+
+        :param arn: The ARN of this Transit Gateway Attachment.
+        :param attachment_id: The ID of this Transit Gateway Attachment.
+        :param creation_time: The time the transit gateway peering attachment was created.
+        :param state: The state of the transit gateway peering attachment.
+        :param status: The status of the transit gateway peering attachment.
+        :param status_code: The status code for the current status of the attachment.
+        :param status_message: The status message for the current status of the attachment.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__17eab9c1c0483a81bcbc3cfb19dfc9cd1902962956a39306a77b2b041a6f2182)
+            check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
+            check_type(argname="argument attachment_id", value=attachment_id, expected_type=type_hints["attachment_id"])
+            check_type(argname="argument creation_time", value=creation_time, expected_type=type_hints["creation_time"])
+            check_type(argname="argument state", value=state, expected_type=type_hints["state"])
+            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
+            check_type(argname="argument status_code", value=status_code, expected_type=type_hints["status_code"])
+            check_type(argname="argument status_message", value=status_message, expected_type=type_hints["status_message"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if arn is not None:
+            self._values["arn"] = arn
+        if attachment_id is not None:
+            self._values["attachment_id"] = attachment_id
+        if creation_time is not None:
+            self._values["creation_time"] = creation_time
+        if state is not None:
+            self._values["state"] = state
+        if status is not None:
+            self._values["status"] = status
+        if status_code is not None:
+            self._values["status_code"] = status_code
+        if status_message is not None:
+            self._values["status_message"] = status_message
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    @builtins.property
+    def arn(self) -> typing.Optional[builtins.str]:
+        '''The ARN of this Transit Gateway Attachment.'''
+        result = self._values.get("arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+    @builtins.property
+    def attachment_id(self) -> typing.Optional[builtins.str]:
+        '''The ID of this Transit Gateway Attachment.'''
+        result = self._values.get("attachment_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def creation_time(self) -> typing.Optional[builtins.str]:
+        '''The time the transit gateway peering attachment was created.'''
+        result = self._values.get("creation_time")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__2ff2cbdcb80817e036a6954889caaeadf5950a28c75b5dba99ae8a9ac2313605)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+    @builtins.property
+    def state(self) -> typing.Optional[builtins.str]:
+        '''The state of the transit gateway peering attachment.'''
+        result = self._values.get("state")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="operation")
-    def operation(self) -> NestFilterOperation:
-        '''Operation specific details for the plugin.'''
-        return typing.cast(NestFilterOperation, jsii.get(self, "operation"))
+    def status(self) -> typing.Optional[builtins.str]:
+        '''The status of the transit gateway peering attachment.'''
+        result = self._values.get("status")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="addPrefix")
-    def add_prefix(self) -> typing.Optional[builtins.str]:
-        '''Prefix affected keys with this string.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "addPrefix"))
+    def status_code(self) -> typing.Optional[builtins.str]:
+        '''The status code for the current status of the attachment.'''
+        result = self._values.get("status_code")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="removePrefix")
-    def remove_prefix(self) -> typing.Optional[builtins.str]:
-        '''Remove prefix from affected keys if it matches this string.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "removePrefix"))
+    def status_message(self) -> typing.Optional[builtins.str]:
+        '''The status message for the current status of the attachment.'''
+        result = self._values.get("status_message")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "TransitGatewayPeeringAttachmentImportAttributes(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-@jsii.implements(IFluentBitOutputPlugin)
-class FluentBitOutputPluginBase(
-    FluentBitPlugin,
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitOutputPluginBase",
-):
-    '''Represents a Fluent Bit plugin that controls log output to a given destination.'''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "name": "name",
+        "peer_account_id": "peerAccountId",
+        "peer_region": "peerRegion",
+    },
+)
+class TransitGatewayPeeringAttachmentOptions:
     def __init__(
         self,
-        name: builtins.str,
         *,
-        match: typing.Optional[FluentBitMatch] = None,
+        name: typing.Optional[builtins.str] = None,
+        peer_account_id: typing.Optional[builtins.str] = None,
+        peer_region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitOutputPlugin class.
+        '''Optional configuration for TransitGatewayPeeringAttachment resource.
 
-        :param name: The name of the output plugin to configure.
-        :param match: The pattern to match for records that this output should apply to.
+        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param peer_account_id: The account that contains the transit gateway being peered with.
+        :param peer_region: The region that contains the transit gateway being peered with.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__6c582e20366c46fa5a93e6085edba3cad0c3a6114b9d179929c4a21e06afd000)
+            type_hints = typing.get_type_hints(_typecheckingstub__25aee8c8ebebcfa519a0f5706458a5669157c84f5af528e93a86402ac7c50aae)
             check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitOutputPluginCommonOptions(match=match)
+            check_type(argname="argument peer_account_id", value=peer_account_id, expected_type=type_hints["peer_account_id"])
+            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if name is not None:
+            self._values["name"] = name
+        if peer_account_id is not None:
+            self._values["peer_account_id"] = peer_account_id
+        if peer_region is not None:
+            self._values["peer_region"] = peer_region
 
-        jsii.create(self.__class__, self, [name, options])
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway peering attachment.
 
-    @jsii.member(jsii_name="renderConfigFile")
-    def _render_config_file(
-        self,
-        config: typing.Mapping[builtins.str, typing.Any],
-    ) -> builtins.str:
-        '''Renders a Fluent Bit configuration file for the plugin.
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
 
-        :param config: The configuration options to render into a configuration file.
+        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
+        '''
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
+
+    @builtins.property
+    def peer_account_id(self) -> typing.Optional[builtins.str]:
+        '''The account that contains the transit gateway being peered with.
 
-        :return: A rendered plugin configuration file.
+        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__f55ec2d6a159d7531fd899f1f3bf43e62ed11244ce1b82143887e03f2226d642)
-            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
-        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+        result = self._values.get("peer_account_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="match")
-    def match(self) -> FluentBitMatch:
-        '''The pattern to match for records that this output should apply to.
+    def peer_region(self) -> typing.Optional[builtins.str]:
+        '''The region that contains the transit gateway being peered with.
 
-        :group: Inputs
+        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
         '''
-        return typing.cast(FluentBitMatch, jsii.get(self, "match"))
+        result = self._values.get("peer_region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-class _FluentBitOutputPluginBaseProxy(
-    FluentBitOutputPluginBase,
-    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
-):
-    pass
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, FluentBitOutputPluginBase).__jsii_proxy_class__ = lambda : _FluentBitOutputPluginBaseProxy
+    def __repr__(self) -> str:
+        return "TransitGatewayPeeringAttachmentOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class FluentBitParserFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitParserFilter",
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayPeeringAttachmentProps",
+    jsii_struct_bases=[
+        TransitGatewayPeeringAttachmentOptions, _aws_cdk_ceddda9d.ResourceProps
+    ],
+    name_mapping={
+        "name": "name",
+        "peer_account_id": "peerAccountId",
+        "peer_region": "peerRegion",
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "local_transit_gateway": "localTransitGateway",
+        "peer_transit_gateway": "peerTransitGateway",
+    },
+)
+class TransitGatewayPeeringAttachmentProps(
+    TransitGatewayPeeringAttachmentOptions,
+    _aws_cdk_ceddda9d.ResourceProps,
 ):
-    '''A Fluent Bit filter that allows parsing of fields in event records.'''
-
     def __init__(
         self,
         *,
-        key_name: builtins.str,
-        parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
-        preserve_key: typing.Optional[builtins.bool] = None,
-        reserve_data: typing.Optional[builtins.bool] = None,
-        match: typing.Optional[FluentBitMatch] = None,
+        name: typing.Optional[builtins.str] = None,
+        peer_account_id: typing.Optional[builtins.str] = None,
+        peer_region: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        local_transit_gateway: ITransitGateway,
+        peer_transit_gateway: ITransitGateway,
     ) -> None:
-        '''Creates a new instance of the FluentBitParserFilter class.
+        '''Configuration for TransitGatewayPeeringAttachment resource.
 
-        :param key_name: Specify field name in record to parse.
-        :param parsers: The parsers to use to interpret the field.
-        :param preserve_key: Keep original ``keyName`` field in the parsed result. If ``false``, the field will be removed. Default: false
-        :param reserve_data: Keep all other original fields in the parsed result. If ``false``, all other original fields will be removed. Default: false
-        :param match: The pattern to match for records that this output should apply to.
+        :param name: The name of the transit gateway peering attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param peer_account_id: The account that contains the transit gateway being peered with.
+        :param peer_region: The region that contains the transit gateway being peered with.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param local_transit_gateway: The local side of the transit gateway peering connection.
+        :param peer_transit_gateway: The remote transit gateway being peered with.
         '''
-        options = FluentBitParserFilterOptions(
-            key_name=key_name,
-            parsers=parsers,
-            preserve_key=preserve_key,
-            reserve_data=reserve_data,
-            match=match,
-        )
-
-        jsii.create(self.__class__, self, [options])
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__1b477916bc8b985cd2d6731bf57489e1a7c94f20fccf7711617cdf0d1bd25beb)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument peer_account_id", value=peer_account_id, expected_type=type_hints["peer_account_id"])
+            check_type(argname="argument peer_region", value=peer_region, expected_type=type_hints["peer_region"])
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument local_transit_gateway", value=local_transit_gateway, expected_type=type_hints["local_transit_gateway"])
+            check_type(argname="argument peer_transit_gateway", value=peer_transit_gateway, expected_type=type_hints["peer_transit_gateway"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "local_transit_gateway": local_transit_gateway,
+            "peer_transit_gateway": peer_transit_gateway,
+        }
+        if name is not None:
+            self._values["name"] = name
+        if peer_account_id is not None:
+            self._values["peer_account_id"] = peer_account_id
+        if peer_region is not None:
+            self._values["peer_region"] = peer_region
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
 
-    @jsii.member(jsii_name="addParser")
-    def add_parser(self, parser: IFluentBitParserPlugin) -> "FluentBitParserFilter":
-        '''Adds a new parser to apply to matched log entries.
+    @builtins.property
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway peering attachment.
 
-        :param parser: The parser to use for matched log entries.
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
 
-        :return: The parser filter that the parser plugin was registered with.
+        :see: `TransitGatewayPeeringAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__18b4223306efeb65c4b4c3faa3427b063444b0783b18132bf6e713a6fd9edbcb)
-            check_type(argname="argument parser", value=parser, expected_type=type_hints["parser"])
-        return typing.cast("FluentBitParserFilter", jsii.invoke(self, "addParser", [parser]))
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param _scope: The construct configuring logging using Fluent Bit.
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def peer_account_id(self) -> typing.Optional[builtins.str]:
+        '''The account that contains the transit gateway being peered with.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :see: `TransitGatewayPeeringAttachment PeerAccountId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__c79cf71df86cb41e555b053e2f91fa72cc6a21fe3a419e03d0eeb0bbc80de8f0)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+        result = self._values.get("peer_account_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="keyName")
-    def key_name(self) -> builtins.str:
-        '''Specify field name in record to parse.'''
-        return typing.cast(builtins.str, jsii.get(self, "keyName"))
+    def peer_region(self) -> typing.Optional[builtins.str]:
+        '''The region that contains the transit gateway being peered with.
 
-    @builtins.property
-    @jsii.member(jsii_name="parsers")
-    def parsers(self) -> typing.List[IFluentBitParserPlugin]:
-        '''Collection of the parsers that should be used to evaluate the filter.'''
-        return typing.cast(typing.List[IFluentBitParserPlugin], jsii.get(self, "parsers"))
+        :see: `TransitGatewayPeeringAttachment PeerRegion <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion>`_
+        '''
+        result = self._values.get("peer_region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="preserveKey")
-    def preserve_key(self) -> typing.Optional[builtins.bool]:
-        '''Keep original ``keyName`` field in the parsed result.
-
-        If ``false``, the field will be removed.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :default: false
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "preserveKey"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="reserveData")
-    def reserve_data(self) -> typing.Optional[builtins.bool]:
-        '''Keep all other original fields in the parsed result.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
+
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        If ``false``, all other original fields will be removed.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :default: false
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "reserveData"))
-
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-@jsii.implements(IFluentBitParserPlugin)
-class FluentBitParserPluginBase(
-    FluentBitPlugin,
-    metaclass=jsii.JSIIAbstractClass,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitParserPluginBase",
-):
-    '''Represents a Fluent Bit plugin that parses inbound records to populate fields.'''
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-    def __init__(self, name: builtins.str, format: builtins.str) -> None:
-        '''Creates a new instance of the FluentBitParserPlugin class.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :param name: The name of the output plugin to configure.
-        :param format: The data format that the parser extracts records from.
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8aed0e3d729344028d0f8b2dd7852c483cccc00b07ab135d6bc3adfeeb63180a)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
-        _options = FluentBitParserPluginCommonOptions()
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        jsii.create(self.__class__, self, [name, format, _options])
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-    @jsii.member(jsii_name="renderConfigFile")
-    def _render_config_file(
-        self,
-        config: typing.Mapping[builtins.str, typing.Any],
-    ) -> builtins.str:
-        '''Renders a Fluent Bit configuration file for the plugin.
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :param config: The configuration options to render into a configuration file.
+    @builtins.property
+    def local_transit_gateway(self) -> ITransitGateway:
+        '''The local side of the transit gateway peering connection.
 
-        :return: A rendered plugin configuration file.
+        :see: `TransitGatewayPeeringAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid>`_
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__a9117f2b6ee6f3211f51ac4d139a07337fb77609903f1cdfc5d98cecfc42198b)
-            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
-        return typing.cast(builtins.str, jsii.invoke(self, "renderConfigFile", [config]))
+        result = self._values.get("local_transit_gateway")
+        assert result is not None, "Required property 'local_transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
     @builtins.property
-    @jsii.member(jsii_name="format")
-    def format(self) -> builtins.str:
-        '''The data format that the parser extracts records from.
+    def peer_transit_gateway(self) -> ITransitGateway:
+        '''The remote transit gateway being peered with.
 
-        :group: Inputs
+        :see: `TransitGatewayPeeringAttachment PeerTransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid>`_
         '''
-        return typing.cast(builtins.str, jsii.get(self, "format"))
-
+        result = self._values.get("peer_transit_gateway")
+        assert result is not None, "Required property 'peer_transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
-class _FluentBitParserPluginBaseProxy(
-    FluentBitParserPluginBase,
-    jsii.proxy_for(FluentBitPlugin), # type: ignore[misc]
-):
-    pass
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
-typing.cast(typing.Any, FluentBitParserPluginBase).__jsii_proxy_class__ = lambda : _FluentBitParserPluginBaseProxy
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
+    def __repr__(self) -> str:
+        return "TransitGatewayPeeringAttachmentProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-class FluentBitRecordModifierFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRecordModifierFilter",
-):
-    '''A Fluent Bit filter that allows appending fields or excluding specific fields.'''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "amazon_side_asn": "amazonSideAsn",
+        "auto_accept_shared_attachments": "autoAcceptSharedAttachments",
+        "cidr_blocks": "cidrBlocks",
+        "default_route_table_association": "defaultRouteTableAssociation",
+        "default_route_table_id": "defaultRouteTableId",
+        "default_route_table_propagation": "defaultRouteTablePropagation",
+        "description": "description",
+        "dns_support": "dnsSupport",
+        "multicast_support": "multicastSupport",
+        "name": "name",
+        "vpn_ecmp_support": "vpnEcmpSupport",
+    },
+)
+class TransitGatewayProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        allow: typing.Optional[typing.Sequence[builtins.str]] = None,
-        records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
-        remove: typing.Optional[typing.Sequence[builtins.str]] = None,
-        match: typing.Optional[FluentBitMatch] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        amazon_side_asn: typing.Optional[jsii.Number] = None,
+        auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
+        cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
+        default_route_table_association: typing.Optional[builtins.bool] = None,
+        default_route_table_id: typing.Optional[builtins.str] = None,
+        default_route_table_propagation: typing.Optional[builtins.bool] = None,
+        description: typing.Optional[builtins.str] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        multicast_support: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        vpn_ecmp_support: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitRecordModifierFilter class.
+        '''Configuration for TransitGateway resource.
 
-        :param allow: If a tag is not match, that field is removed.
-        :param records: Add fields to the output.
-        :param remove: If a tag is match, that field is removed.
-        :param match: The pattern to match for records that this output should apply to.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param amazon_side_asn: 
+        :param auto_accept_shared_attachments: 
+        :param cidr_blocks: 
+        :param default_route_table_association: 
+        :param default_route_table_id: 
+        :param default_route_table_propagation: 
+        :param description: 
+        :param dns_support: 
+        :param multicast_support: 
+        :param name: 
+        :param vpn_ecmp_support: 
         '''
-        options = FluentBitRecordModifierFilterOptions(
-            allow=allow, records=records, remove=remove, match=match
-        )
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__34be88b6da81fce37f3376e8b1fd1aff7e222c4b2fb4ab8e879c634868d58a81)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument amazon_side_asn", value=amazon_side_asn, expected_type=type_hints["amazon_side_asn"])
+            check_type(argname="argument auto_accept_shared_attachments", value=auto_accept_shared_attachments, expected_type=type_hints["auto_accept_shared_attachments"])
+            check_type(argname="argument cidr_blocks", value=cidr_blocks, expected_type=type_hints["cidr_blocks"])
+            check_type(argname="argument default_route_table_association", value=default_route_table_association, expected_type=type_hints["default_route_table_association"])
+            check_type(argname="argument default_route_table_id", value=default_route_table_id, expected_type=type_hints["default_route_table_id"])
+            check_type(argname="argument default_route_table_propagation", value=default_route_table_propagation, expected_type=type_hints["default_route_table_propagation"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
+            check_type(argname="argument multicast_support", value=multicast_support, expected_type=type_hints["multicast_support"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument vpn_ecmp_support", value=vpn_ecmp_support, expected_type=type_hints["vpn_ecmp_support"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if amazon_side_asn is not None:
+            self._values["amazon_side_asn"] = amazon_side_asn
+        if auto_accept_shared_attachments is not None:
+            self._values["auto_accept_shared_attachments"] = auto_accept_shared_attachments
+        if cidr_blocks is not None:
+            self._values["cidr_blocks"] = cidr_blocks
+        if default_route_table_association is not None:
+            self._values["default_route_table_association"] = default_route_table_association
+        if default_route_table_id is not None:
+            self._values["default_route_table_id"] = default_route_table_id
+        if default_route_table_propagation is not None:
+            self._values["default_route_table_propagation"] = default_route_table_propagation
+        if description is not None:
+            self._values["description"] = description
+        if dns_support is not None:
+            self._values["dns_support"] = dns_support
+        if multicast_support is not None:
+            self._values["multicast_support"] = multicast_support
+        if name is not None:
+            self._values["name"] = name
+        if vpn_ecmp_support is not None:
+            self._values["vpn_ecmp_support"] = vpn_ecmp_support
 
-        jsii.create(self.__class__, self, [options])
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-    @jsii.member(jsii_name="addAllow")
-    def add_allow(self, tag: builtins.str) -> "FluentBitRecordModifierFilter":
-        '''Adds a tag to be allowed on a matched input record.
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        If a tag is not matched it is removed.
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        :param tag: The tag to add to the allow list.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        :return:
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        The record modifier filter that the tag plugin was registered
-        with.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__197d11f14d745ecc6b6f0e060796ec77dba5a2371d0b974c5188eba457ace3a9)
-            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
-        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addAllow", [tag]))
-
-    @jsii.member(jsii_name="addRecord")
-    def add_record(
-        self,
-        *,
-        field_name: builtins.str,
-        value: builtins.str,
-    ) -> "FluentBitRecordModifierFilter":
-        '''Add a record to be appended to matched events.
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :param field_name: The name of the field to be added.
-        :param value: The value that the added field should be set to.
+    @builtins.property
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :return:
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        The record modifier filter that the tag plugin was registered
-        with.
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        record = AppendedRecord(field_name=field_name, value=value)
-
-        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addRecord", [record]))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.member(jsii_name="addRemove")
-    def add_remove(self, tag: builtins.str) -> "FluentBitRecordModifierFilter":
-        '''Adds a tag to be removed on a matched input record.
+    @builtins.property
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        If a tag is matched it is removed.
+        :default: - the resource is in the same region as the stack it belongs to
+        '''
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :param tag: The tag to add to the allow list.
+    @builtins.property
+    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("amazon_side_asn")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :return:
+    @builtins.property
+    def auto_accept_shared_attachments(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("auto_accept_shared_attachments")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        The record modifier filter that the tag plugin was registered
-        with.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b1fb7025737a67bb8d4d600b93b0d5d19ecf74c9ce22d8ea64f634ad9895f200)
-            check_type(argname="argument tag", value=tag, expected_type=type_hints["tag"])
-        return typing.cast("FluentBitRecordModifierFilter", jsii.invoke(self, "addRemove", [tag]))
+    @builtins.property
+    def cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
+        result = self._values.get("cidr_blocks")
+        return typing.cast(typing.Optional[typing.List[builtins.str]], result)
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    @builtins.property
+    def default_route_table_association(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("default_route_table_association")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+    @builtins.property
+    def default_route_table_id(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("default_route_table_id")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def default_route_table_propagation(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("default_route_table_propagation")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
-        '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5f389e835484d35e9442fddb76443dec0a2aa164eb591d2f71cb44abf7e9b8fa)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="allow")
-    def allow(self) -> typing.List[builtins.str]:
-        '''Collection of tags that are allowed on a matched input record.
+    def dns_support(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("dns_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        If a tag is not matched it is removed.
-        '''
-        return typing.cast(typing.List[builtins.str], jsii.get(self, "allow"))
+    @builtins.property
+    def multicast_support(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("multicast_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="records")
-    def records(self) -> typing.List[AppendedRecord]:
-        '''Collection of the records to be appending to matched input.'''
-        return typing.cast(typing.List[AppendedRecord], jsii.get(self, "records"))
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="remove")
-    def remove(self) -> typing.List[builtins.str]:
-        '''Collection of tags to exclude from a matched input record.
+    def vpn_ecmp_support(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("vpn_ecmp_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        If a tag is matched it is removed.
-        '''
-        return typing.cast(typing.List[builtins.str], jsii.get(self, "remove"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-class FluentBitRegexParser(
-    FluentBitParserPluginBase,
+    def __repr__(self) -> str:
+        return "TransitGatewayProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+class TransitGatewayRoute(
+    _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRegexParser",
+    jsii_type="cdk-extensions.ec2.TransitGatewayRoute",
 ):
-    '''A Fluent Bit filter that parsed inbound messages using regular expressions.'''
+    '''Adds a routing rule for a transit gateway route table.'''
 
     def __init__(
         self,
-        name: builtins.str,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        regex: builtins.str,
-        skip_empty_values: typing.Optional[builtins.bool] = None,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+        cidr: builtins.str,
+        route_table: ITransitGatewayRouteTable,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitLtsvParser class.
+        '''Creates a new instance of the TransitGatewayAttachment class.
 
-        :param name: -
-        :param regex: The regular expression to use to parse the incoming records. Use regex group names to define the name of fields being captured.
-        :param skip_empty_values: If enabled, the parser ignores empty value of the record.
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param cidr: 
+        :param route_table: 
+        :param attachment: 
+        :param blackhole: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4179007c95e092b6ac83f12dd7ef24c1c718db06738628257564097d17575d37)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitRegexParserOptions(
-            regex=regex,
-            skip_empty_values=skip_empty_values,
-            time_format=time_format,
-            time_key=time_key,
-            types=types,
+            type_hints = typing.get_type_hints(_typecheckingstub__472f0a715c24828891d913514782594fd48e540d0192f96901c525a6f2c9845f)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = TransitGatewayRouteProps(
+            cidr=cidr,
+            route_table=route_table,
+            attachment=attachment,
+            blackhole=blackhole,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
         )
 
-        jsii.create(self.__class__, self, [name, options])
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        jsii.create(self.__class__, self, [scope, id, props])
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+    @jsii.member(jsii_name="fromTransitGatewayRouteId")
+    @builtins.classmethod
+    def from_transit_gateway_route_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        transit_gateway_route_id: builtins.str,
+    ) -> ITransitGatewayRoute:
+        '''Imports an existing Transit Gateway Route using its route ID.
 
-        :return:
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway_route_id: The ID of the Transit Gateway route being imported.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :return: An object representing the imported Transit Gateway route.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__b3c327e2acce81be05e692cd50cc22811413200c4697881b0ba1fbe6ce2d81d2)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__e915393403cdd527b11e940ce216647c74d6e6b709f726e821e12fa1b470873d)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument transit_gateway_route_id", value=transit_gateway_route_id, expected_type=type_hints["transit_gateway_route_id"])
+        return typing.cast(ITransitGatewayRoute, jsii.sinvoke(cls, "fromTransitGatewayRouteId", [scope, id, transit_gateway_route_id]))
 
     @builtins.property
-    @jsii.member(jsii_name="regex")
-    def regex(self) -> builtins.str:
-        '''The regular expression to use to parse the incoming records.
-
-        Use regex group names to define the name of fields being captured.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "regex"))
+    @jsii.member(jsii_name="cidr")
+    def cidr(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "cidr"))
 
     @builtins.property
-    @jsii.member(jsii_name="skipEmptyValues")
-    def skip_empty_values(self) -> typing.Optional[builtins.bool]:
-        '''If enabled, the parser ignores empty value of the record.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "skipEmptyValues"))
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRoute:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRoute, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="timeFormat")
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
-
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+    @jsii.member(jsii_name="routeTable")
+    def route_table(self) -> ITransitGatewayRouteTable:
+        return typing.cast(ITransitGatewayRouteTable, jsii.get(self, "routeTable"))
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+    @jsii.member(jsii_name="transitGatewayRouteId")
+    def transit_gateway_route_id(self) -> builtins.str:
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteId"))
 
     @builtins.property
-    @jsii.member(jsii_name="types")
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+    @jsii.member(jsii_name="attachment")
+    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
+        return typing.cast(typing.Optional[ITransitGatewayAttachment], jsii.get(self, "attachment"))
 
+    @builtins.property
+    @jsii.member(jsii_name="blackhole")
+    def blackhole(self) -> typing.Optional[builtins.bool]:
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "blackhole"))
 
-class FluentBitRewriteTagFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitRewriteTagFilter",
-):
-    '''A Fluent Bit filter that allows parsing of fields in event records.'''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayRouteOptions",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "cidr": "cidr",
+        "attachment": "attachment",
+        "blackhole": "blackhole",
+    },
+)
+class TransitGatewayRouteOptions(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
-        emitter_name: typing.Optional[builtins.str] = None,
-        emitter_storage_type: typing.Optional[EmitterStorageType] = None,
-        rules: typing.Optional[typing.Sequence[typing.Union[RewriteTagRule, typing.Dict[builtins.str, typing.Any]]]] = None,
-        match: typing.Optional[FluentBitMatch] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        cidr: builtins.str,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitRewriteTagFilter class.
+        '''Options for adding a route to a transit gateway route table.
 
-        :param emitter_mem_buf_limit: Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure. Default: 10M
-        :param emitter_name: When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job. Since this emitter expose metrics as any other component of the pipeline, you can use this property to configure an optional name for it.
-        :param emitter_storage_type: Define a buffering mechanism for the new records created. Note these records are part of the emitter plugin.
-        :param rules: Defines the matching criteria and the format of the Tag for the matching record.
-        :param match: The pattern to match for records that this output should apply to.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param cidr: The CIDR range to match for the route.
+        :param attachment: The transit gateway attachment where matched traffic should be routed.
+        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
         '''
-        options = FluentBitRewriteTagFilterOptions(
-            emitter_mem_buf_limit=emitter_mem_buf_limit,
-            emitter_name=emitter_name,
-            emitter_storage_type=emitter_storage_type,
-            rules=rules,
-            match=match,
-        )
-
-        jsii.create(self.__class__, self, [options])
-
-    @jsii.member(jsii_name="addRule")
-    def add_rule(
-        self,
-        *,
-        keep: builtins.bool,
-        key: builtins.str,
-        new_tag: builtins.str,
-        regex: builtins.str,
-    ) -> "FluentBitRewriteTagFilter":
-        '''Adds a new rule to apply to matched log entries.
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__eac305487ec828686fdbbd312914a754c55ca742068c194f48ac724cf9aef071)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument attachment", value=attachment, expected_type=type_hints["attachment"])
+            check_type(argname="argument blackhole", value=blackhole, expected_type=type_hints["blackhole"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "cidr": cidr,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if attachment is not None:
+            self._values["attachment"] = attachment
+        if blackhole is not None:
+            self._values["blackhole"] = blackhole
 
-        :param keep: If a rule matches a rule the filter will emit a copy of the record with the new defined Tag. The property keep takes a boolean value to define if the original record with the old Tag must be preserved and continue in the pipeline or just be discarded.
-        :param key: The key represents the name of the record key that holds the value that we want to use to match our regular expression. A key name is specified and prefixed with a ``$``.
-        :param new_tag: If a regular expression has matched the value of the defined key in the rule, we are ready to compose a new Tag for that specific record. The tag is a concatenated string that can contain any of the following characters: ``a-z,A-Z,0-9`` and ``.-,``.
-        :param regex: Using a simple regular expression we can specify a matching pattern to use against the value of the key specified, also we can take advantage of group capturing to create custom placeholder values.
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :return: The parser filter that the parser plugin was registered with.
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        rule = RewriteTagRule(keep=keep, key=key, new_tag=new_tag, regex=regex)
-
-        return typing.cast("FluentBitRewriteTagFilter", jsii.invoke(self, "addRule", [rule]))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        :return:
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__7b876de72e29ff64e3f1942127300def8853d5a5fcc52fac6120aba70bdda279)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
-
-    @jsii.python.classproperty
-    @jsii.member(jsii_name="PLUGIN_NAME")
-    def PLUGIN_NAME(cls) -> builtins.str:
-        '''The name of the plugin as it will appear in the fluent bit configuration.'''
-        return typing.cast(builtins.str, jsii.sget(cls, "PLUGIN_NAME"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="emitterName")
-    def emitter_name(self) -> builtins.str:
-        '''When the filter emits a record under the new Tag, there is an internal emitter plugin that takes care of the job.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        Since this emitter expose
-        metrics as any other component of the pipeline, you can use this
-        property to configure an optional name for it.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :group: Inputs
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(builtins.str, jsii.get(self, "emitterName"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="rules")
-    def rules(self) -> typing.List[RewriteTagRule]:
-        '''Collection of rules defining matching criteria and the format of the tag for the matching record.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.List[RewriteTagRule], jsii.get(self, "rules"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="emitterMemBufLimit")
-    def emitter_mem_buf_limit(self) -> typing.Optional[_DataSize_d20aaece]:
-        '''Set a limit on the amount of memory the tag rewrite emitter can consume if the outputs provide backpressure.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_DataSize_d20aaece], jsii.get(self, "emitterMemBufLimit"))
+    def cidr(self) -> builtins.str:
+        '''The CIDR range to match for the route.'''
+        result = self._values.get("cidr")
+        assert result is not None, "Required property 'cidr' is missing"
+        return typing.cast(builtins.str, result)
 
     @builtins.property
-    @jsii.member(jsii_name="emitterStorageType")
-    def emitter_storage_type(self) -> typing.Optional[EmitterStorageType]:
-        '''Define a buffering mechanism for the new records created.
+    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
+        '''The transit gateway attachment where matched traffic should be routed.'''
+        result = self._values.get("attachment")
+        return typing.cast(typing.Optional[ITransitGatewayAttachment], result)
 
-        Note these records are part of the emitter plugin.
+    @builtins.property
+    def blackhole(self) -> typing.Optional[builtins.bool]:
+        '''Whether the traffic should be black holed (discarded) rather than being routed to an attachment.'''
+        result = self._values.get("blackhole")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[EmitterStorageType], jsii.get(self, "emitterStorageType"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-class FluentBitThrottleFilter(
-    FluentBitFilterPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitThrottleFilter",
-):
-    '''A Fluent Bit filter that sets the average *Rate* of messages per *Interval*, based on leaky bucket and sliding window algorithm.
+    def __repr__(self) -> str:
+        return "TransitGatewayRouteOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    In case of overflood,
-    it will leak within certain rate.
-    '''
 
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayRouteProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "cidr": "cidr",
+        "route_table": "routeTable",
+        "attachment": "attachment",
+        "blackhole": "blackhole",
+    },
+)
+class TransitGatewayRouteProps(_aws_cdk_ceddda9d.ResourceProps):
     def __init__(
         self,
         *,
-        interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-        print_status: typing.Optional[builtins.bool] = None,
-        rate: typing.Optional[jsii.Number] = None,
-        window: typing.Optional[jsii.Number] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitThrottleFilter class.
-
-        :param interval: Time interval.
-        :param print_status: Whether to print status messages with current rate and the limits to information logs.
-        :param rate: Amount of messages for the time.
-        :param window: Amount of intervals to calculate average over. Default: 5
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitThrottleFilterOptions(
-            interval=interval,
-            print_status=print_status,
-            rate=rate,
-            window=window,
-            match=match,
-        )
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        cidr: builtins.str,
+        route_table: ITransitGatewayRouteTable,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
+    ) -> None:
+        '''Configuration for TransitGatewayRoute resource.
 
-        jsii.create(self.__class__, self, [options])
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param cidr: 
+        :param route_table: 
+        :param attachment: 
+        :param blackhole: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__36f603e48c36f0aabd623aee3c75f3f94dcd322957a71fb2d3539585045d2c00)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument cidr", value=cidr, expected_type=type_hints["cidr"])
+            check_type(argname="argument route_table", value=route_table, expected_type=type_hints["route_table"])
+            check_type(argname="argument attachment", value=attachment, expected_type=type_hints["attachment"])
+            check_type(argname="argument blackhole", value=blackhole, expected_type=type_hints["blackhole"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "cidr": cidr,
+            "route_table": route_table,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if attachment is not None:
+            self._values["attachment"] = attachment
+        if blackhole is not None:
+            self._values["blackhole"] = blackhole
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+    @builtins.property
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+        :default: - the resource is in the same account as the stack it belongs to
+        '''
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        :return:
+    @builtins.property
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
+
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
+
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__5ddeac1f10751e613cc3decd64281d60ce8da73f21dce744a8f23bdd94d419b9)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="interval")
-    def interval(self) -> _aws_cdk_ceddda9d.Duration:
-        '''Time interval.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :group: Inputs
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(_aws_cdk_ceddda9d.Duration, jsii.get(self, "interval"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="rate")
-    def rate(self) -> jsii.Number:
-        '''Amount of messages for the time.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(jsii.Number, jsii.get(self, "rate"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="window")
-    def window(self) -> jsii.Number:
-        '''Amount of intervals to calculate average over.
+    def cidr(self) -> builtins.str:
+        result = self._values.get("cidr")
+        assert result is not None, "Required property 'cidr' is missing"
+        return typing.cast(builtins.str, result)
 
-        :group: Inputs
-        '''
-        return typing.cast(jsii.Number, jsii.get(self, "window"))
+    @builtins.property
+    def route_table(self) -> ITransitGatewayRouteTable:
+        result = self._values.get("route_table")
+        assert result is not None, "Required property 'route_table' is missing"
+        return typing.cast(ITransitGatewayRouteTable, result)
 
     @builtins.property
-    @jsii.member(jsii_name="printStatus")
-    def print_status(self) -> typing.Optional[builtins.bool]:
-        '''Whether to print status messages with current rate and the limits to information logs.
+    def attachment(self) -> typing.Optional[ITransitGatewayAttachment]:
+        result = self._values.get("attachment")
+        return typing.cast(typing.Optional[ITransitGatewayAttachment], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "printStatus"))
+    @builtins.property
+    def blackhole(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("blackhole")
+        return typing.cast(typing.Optional[builtins.bool], result)
+
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
+
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "TransitGatewayRouteProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class FluentBitCloudWatchLogsOutput(
-    FluentBitOutputPluginBase,
+@jsii.implements(ITransitGatewayRouteTable)
+class TransitGatewayRouteTable(
+    _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitCloudWatchLogsOutput",
+    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTable",
 ):
-    '''Represents configuration for outputing logs from Fluent Bit to CloudWatch Logs.'''
+    '''Creates a route table for traffic being processed by a transit gateway.
+
+    When traffic is routed to a transit gateway via an attachment, the route
+    table associated with that attachment is used when evaluating how the
+    inbound traffic should be routed.
+
+    :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
+    '''
 
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        auto_create_group: typing.Optional[builtins.bool] = None,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_format: typing.Optional[builtins.str] = None,
-        log_group: typing.Optional[FluentBitLogGroupOutput] = None,
-        log_group_template: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
-        log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
-        log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
-        log_stream_template: typing.Optional[builtins.str] = None,
-        metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
-        metric_namespace: typing.Optional[builtins.str] = None,
+        transit_gateway: ITransitGateway,
+        name: typing.Optional[builtins.str] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitCloudWatchLogsOutput class.
+        '''Creates a new instance of the TransitGatewayRouteTable class.
 
-        :param auto_create_group: Automatically create the log group. Default: false
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param endpoint: Specify a custom endpoint for the CloudWatch Logs API.
-        :param log_format: An optional parameter that can be used to tell CloudWatch the format of the data. A value of json/emf enables CloudWatch to extract custom metrics embedded in a JSON payload.
-        :param log_group: The CloudWatch Log Group configuration for output records.
-        :param log_group_template: Template for Log Group name using Fluent Bit record_accessor syntax. This field is optional and if configured it overrides the configured Log Group. If the template translation fails, an error is logged and the provided Log Group (which is still required) is used instead.
-        :param log_key: By default, the whole log record will be sent to CloudWatch. If you specify a key name with this option, then only the value of that key will be sent to CloudWatch.
-        :param log_retention: If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
-        :param log_stream: The CloudWatch LogStream configuration for outbound records.
-        :param log_stream_template: Template for Log Stream name using Fluent Bit record accessor syntax. This field is optional and if configured it overrides the other log stream options. If the template translation fails, an error is logged and the logStream or logStreamPrefix are used instead (and thus one of those fields is still required to be configured).
-        :param metric_dimensions: A list of lists containing the dimension keys that will be applied to all metrics. The values within a dimension set MUST also be members on the root-node.
-        :param metric_namespace: An optional string representing the CloudWatch namespace for the metrics.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitCloudWatchLogsOutputOptions(
-            auto_create_group=auto_create_group,
-            auto_retry_requests=auto_retry_requests,
-            endpoint=endpoint,
-            log_format=log_format,
-            log_group=log_group,
-            log_group_template=log_group_template,
-            log_key=log_key,
-            log_retention=log_retention,
-            log_stream=log_stream,
-            log_stream_template=log_stream_template,
-            metric_dimensions=metric_dimensions,
-            metric_namespace=metric_namespace,
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway: The transit gateway for which the route table should be created.
+        :param name: The name of the transit gateway route table. Used to tag the route table with a name that will be displayed in the AWS VPC console.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__bf9f0e3a9c51ac3498209cf81371557e5b56db1c03ff409740d882fde1cacda7)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = TransitGatewayRouteTableProps(
+            transit_gateway=transit_gateway,
+            name=name,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
             region=region,
-            role=role,
-            sts_endpoint=sts_endpoint,
-            match=match,
         )
 
-        jsii.create(self.__class__, self, [options])
+        jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
+    @jsii.member(jsii_name="fromTransitGatewayRouteTableId")
+    @builtins.classmethod
+    def from_transit_gateway_route_table_id(
+        cls,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param scope: The construct configuring logging using Fluent Bit.
+        id: builtins.str,
+        transit_gateway_route_table_id: builtins.str,
+    ) -> ITransitGatewayRouteTable:
+        '''Imports an existing transit gateway route table using its route table ID.
 
-        :return:
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway_route_table_id: The attachment ID of the transit gateway route table being imported.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :return: An object representing the imported transit gateway route table.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4fd91daa220023ad34765844283275eab65fafb87508ac56f1d7c81195ee443b)
+            type_hints = typing.get_type_hints(_typecheckingstub__7ddc972512f9b73360cad75e0fd028f815d92130c441ed49e42d40f77ebd8fff)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument transit_gateway_route_table_id", value=transit_gateway_route_table_id, expected_type=type_hints["transit_gateway_route_table_id"])
+        return typing.cast(ITransitGatewayRouteTable, jsii.sinvoke(cls, "fromTransitGatewayRouteTableId", [scope, id, transit_gateway_route_table_id]))
 
-    @builtins.property
-    @jsii.member(jsii_name="logGroup")
-    def log_group(self) -> FluentBitLogGroupOutput:
-        '''The CloudWatch Log Group configuration for output records.'''
-        return typing.cast(FluentBitLogGroupOutput, jsii.get(self, "logGroup"))
+    @jsii.member(jsii_name="addRoute")
+    def add_route(
+        self,
+        *,
+        cidr: builtins.str,
+        attachment: typing.Optional[ITransitGatewayAttachment] = None,
+        blackhole: typing.Optional[builtins.bool] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> TransitGatewayRoute:
+        '''Adds a route to this transit gateway route table.
 
-    @builtins.property
-    @jsii.member(jsii_name="logStream")
-    def log_stream(self) -> FluentBitLogStreamOutput:
-        '''The CloudWatch LogStream configuration for outbound records.'''
-        return typing.cast(FluentBitLogStreamOutput, jsii.get(self, "logStream"))
+        :param cidr: The CIDR range to match for the route.
+        :param attachment: The transit gateway attachment where matched traffic should be routed.
+        :param blackhole: Whether the traffic should be black holed (discarded) rather than being routed to an attachment.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+
+        :return: The TransitGatewayRoute that was added.
+        '''
+        options = TransitGatewayRouteOptions(
+            cidr=cidr,
+            attachment=attachment,
+            blackhole=blackhole,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
+
+        return typing.cast(TransitGatewayRoute, jsii.invoke(self, "addRoute", [options]))
 
     @builtins.property
-    @jsii.member(jsii_name="autoCreateGroup")
-    def auto_create_group(self) -> typing.Optional[builtins.bool]:
-        '''Automatically create the log group.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRouteTable:
+        '''The underlying TransitGatewayRouteTable CloudFormation resource.
 
-        :group: Inputs
+        :see: `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_
+        :group: Resources
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoCreateGroup"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayRouteTable, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="autoRetryRequests")
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
-
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+    @jsii.member(jsii_name="transitGateway")
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway for which the route table should be created.
 
+        :see: `TransitGatewayRouteTable TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
+        return typing.cast(ITransitGateway, jsii.get(self, "transitGateway"))
 
     @builtins.property
-    @jsii.member(jsii_name="endpoint")
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the CloudWatch Logs API.
+    @jsii.member(jsii_name="transitGatewayRouteTableArn")
+    def transit_gateway_route_table_arn(self) -> builtins.str:
+        '''The ARN of this transit gateway route table.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableArn"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
+    @builtins.property
+    @jsii.member(jsii_name="transitGatewayRouteTableId")
+    def transit_gateway_route_table_id(self) -> builtins.str:
+        '''The ID of this transit gateway route table.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))
 
     @builtins.property
-    @jsii.member(jsii_name="logFormat")
-    def log_format(self) -> typing.Optional[builtins.str]:
-        '''An optional parameter that can be used to tell CloudWatch the format of the data.
+    @jsii.member(jsii_name="name")
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway route table.
 
-        A value of json/emf enables CloudWatch to extract custom
-        metrics embedded in a JSON payload.
+        Used to tag the route table with a name that will be displayed in the AWS
+        EC2 console.
 
-        :see: `Embedded Metric Format <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html>`_
+        :see: `TransitGatewayRouteTable Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logFormat"))
-
-    @builtins.property
-    @jsii.member(jsii_name="logGroupTemplate")
-    def log_group_template(self) -> typing.Optional[builtins.str]:
-        '''Template for Log Group name using Fluent Bit record_accessor syntax.
-
-        This field is optional and if configured it overrides the configured Log
-        Group.
+        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "name"))
 
-        If the template translation fails, an error is logged and the provided
-        Log Group (which is still required) is used instead.
 
-        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTableOptions",
+    jsii_struct_bases=[],
+    name_mapping={"name": "name"},
+)
+class TransitGatewayRouteTableOptions:
+    def __init__(self, *, name: typing.Optional[builtins.str] = None) -> None:
+        '''
+        :param name: 
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupTemplate"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__ba42798c9102c3419b7c375a3d8ce27fef028001fb7cc17a2798c1aad61854ff)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if name is not None:
+            self._values["name"] = name
 
     @builtins.property
-    @jsii.member(jsii_name="logKey")
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to CloudWatch.
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to CloudWatch.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="logRetention")
-    def log_retention(
+    def __repr__(self) -> str:
+        return "TransitGatewayRouteTableOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
+
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayRouteTableProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "transit_gateway": "transitGateway",
+        "name": "name",
+    },
+)
+class TransitGatewayRouteTableProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
         self,
-    ) -> typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays]:
-        '''If set to a number greater than zero, and newly create log group's retention policy is set to this many days.
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        transit_gateway: ITransitGateway,
+        name: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Configuration for TransitGatewayRouteTable resource.
 
-        :group: Inputs
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param transit_gateway: The transit gateway for which the route table should be created.
+        :param name: The name of the transit gateway route table. Used to tag the route table with a name that will be displayed in the AWS VPC console.
         '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays], jsii.get(self, "logRetention"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__8ae02cfe78ce98fb4f7880816162efbcf405d70470d3f4d83605632beeb8a6f7)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "transit_gateway": transit_gateway,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if name is not None:
+            self._values["name"] = name
 
     @builtins.property
-    @jsii.member(jsii_name="logStreamTemplate")
-    def log_stream_template(self) -> typing.Optional[builtins.str]:
-        '''Template for Log Stream name using Fluent Bit record accessor syntax.
-
-        This field is optional and if configured it overrides the other log
-        stream options. If the template translation fails, an error is logged
-        and the logStream or logStreamPrefix are used instead (and thus one of
-        those fields is still required to be configured).
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :see: `Fluent Bit record accessor snytax <https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/classic-mode/record-accessor>`_
-        :group: Inputs
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logStreamTemplate"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="metricDimensions")
-    def metric_dimensions(self) -> typing.Optional[typing.List[builtins.str]]:
-        '''A list of lists containing the dimension keys that will be applied to all metrics.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        The values within a dimension set MUST also be members on
-        the root-node.
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        :see: `Dimensions <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension>`_
-        :group: Inputs
+        Cannot be supplied together with either ``account`` or ``region``.
+
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "metricDimensions"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="metricNamespace")
-    def metric_namespace(self) -> typing.Optional[builtins.str]:
-        '''An optional string representing the CloudWatch namespace for the metrics.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        :see: `Metric Tutorial <https://docs.fluentbit.io/manual/pipeline/outputs/cloudwatch#metrics-tutorial>`_
-        :group: Inputs
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
+
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "metricNamespace"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="region")
     def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.
+        '''The AWS region this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="role")
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway for which the route table should be created.
 
-        :group: Inputs
+        :see: `TransitGatewayRouteTable TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid>`_
         '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
+        result = self._values.get("transit_gateway")
+        assert result is not None, "Required property 'transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
     @builtins.property
-    @jsii.member(jsii_name="stsEndpoint")
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the transit gateway route table.
 
-        :group: Inputs
+        Used to tag the route table with a name that will be displayed in the AWS
+        VPC console.
+
+        :see: `TransitGatewayRouteTable Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-class FluentBitElasticsearchOutput(
-    FluentBitOutputPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitElasticsearchOutput",
-):
-    def __init__(
-        self,
-        *,
-        host: builtins.str,
-        aws_auth: typing.Optional[builtins.bool] = None,
-        aws_external_id: typing.Optional[builtins.str] = None,
-        aws_region: typing.Optional[builtins.str] = None,
-        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        aws_sts_endpoint: typing.Optional[builtins.str] = None,
-        buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
-        cloud_auth: typing.Optional[builtins.str] = None,
-        cloud_id: typing.Optional[builtins.str] = None,
-        compress: typing.Optional[ElasticsearchCompressionFormat] = None,
-        current_time_index: typing.Optional[builtins.bool] = None,
-        generate_id: typing.Optional[builtins.bool] = None,
-        http_passwd: typing.Optional[builtins.str] = None,
-        http_user: typing.Optional[builtins.str] = None,
-        id_key: typing.Optional[builtins.str] = None,
-        include_tag_key: typing.Optional[builtins.bool] = None,
-        index: typing.Optional[builtins.str] = None,
-        logstash_date_format: typing.Optional[builtins.str] = None,
-        logstash_format: typing.Optional[builtins.bool] = None,
-        logstash_prefix: typing.Optional[builtins.str] = None,
-        logstash_prefix_key: typing.Optional[builtins.str] = None,
-        path: typing.Optional[builtins.str] = None,
-        pipeline: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replace_dots: typing.Optional[builtins.bool] = None,
-        suppress_type_name: typing.Optional[builtins.bool] = None,
-        tag_key: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        time_key_nanos: typing.Optional[builtins.bool] = None,
-        trace_error: typing.Optional[builtins.bool] = None,
-        trace_output: typing.Optional[builtins.bool] = None,
-        type: typing.Optional[builtins.str] = None,
-        workers: typing.Optional[jsii.Number] = None,
-        write_operation: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
-
-        :param host: IP address or hostname of the target Elasticsearch instance.
-        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service. Default: false
-        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
-        :param aws_region: Specify the AWS region for Elasticsearch Service.
-        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
-        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
-        :param buffer_size: Specify the buffer size used to read the response from the Elasticsearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
-        :param cloud_auth: Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
-        :param cloud_id: If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
-        :param compress: Set payload compression mechanism.
-        :param current_time_index: Use current time for index generation instead of message record. Default: false
-        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
-        :param http_passwd: Password for user defined in ``httpUser``.
-        :param http_user: Optional username credential for access.
-        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
-        :param include_tag_key: When enabled, it append the Tag name to the record.
-        :param index: Index name. Default: 'fluent-bit
-        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
-        :param logstash_format: Enable Logstash format compatibility. Default: false
-        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
-        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
-        :param path: Elasticsearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve Elasticsearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
-        :param pipeline: Elasticsearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
-        :param port: TCP port of the target Elasticsearch instance. Default: 9200
-        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
-        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
-        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
-        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
-        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
-        :param trace_error: When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only). Default: false
-        :param trace_output: When enabled print the Elasticsearch API calls to stdout (for diag only). Default: false
-        :param type: Type name. Default: '_doc'
-        :param workers: Enables dedicated thread(s) for this output. Default: 2
-        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitElasticsearchOutputOptions(
-            host=host,
-            aws_auth=aws_auth,
-            aws_external_id=aws_external_id,
-            aws_region=aws_region,
-            aws_role=aws_role,
-            aws_sts_endpoint=aws_sts_endpoint,
-            buffer_size=buffer_size,
-            cloud_auth=cloud_auth,
-            cloud_id=cloud_id,
-            compress=compress,
-            current_time_index=current_time_index,
-            generate_id=generate_id,
-            http_passwd=http_passwd,
-            http_user=http_user,
-            id_key=id_key,
-            include_tag_key=include_tag_key,
-            index=index,
-            logstash_date_format=logstash_date_format,
-            logstash_format=logstash_format,
-            logstash_prefix=logstash_prefix,
-            logstash_prefix_key=logstash_prefix_key,
-            path=path,
-            pipeline=pipeline,
-            port=port,
-            replace_dots=replace_dots,
-            suppress_type_name=suppress_type_name,
-            tag_key=tag_key,
-            time_key=time_key,
-            time_key_format=time_key_format,
-            time_key_nanos=time_key_nanos,
-            trace_error=trace_error,
-            trace_output=trace_output,
-            type=type,
-            workers=workers,
-            write_operation=write_operation,
-            match=match,
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "TransitGatewayRouteTableProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
         )
 
-        jsii.create(self.__class__, self, [options])
 
-    @jsii.member(jsii_name="bind")
-    def bind(
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TunnelOptions",
+    jsii_struct_bases=[],
+    name_mapping={"inside_cidr": "insideCidr", "pre_shared_key": "preSharedKey"},
+)
+class TunnelOptions:
+    def __init__(
         self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param _scope: The construct configuring logging using Fluent Bit.
-
-        :return:
-
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        *,
+        inside_cidr: typing.Optional[builtins.str] = None,
+        pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
+    ) -> None:
+        '''
+        :param inside_cidr: 
+        :param pre_shared_key: 
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__31e06075f1184a9eaf94b720a919de0afb675ade3a9e9f7e3f9e9140cf117b1f)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__4312d41d9a05862a91818a278fa16d6a73ff75dcd46ad08d731c98c54086e195)
+            check_type(argname="argument inside_cidr", value=inside_cidr, expected_type=type_hints["inside_cidr"])
+            check_type(argname="argument pre_shared_key", value=pre_shared_key, expected_type=type_hints["pre_shared_key"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if inside_cidr is not None:
+            self._values["inside_cidr"] = inside_cidr
+        if pre_shared_key is not None:
+            self._values["pre_shared_key"] = pre_shared_key
 
     @builtins.property
-    @jsii.member(jsii_name="host")
-    def host(self) -> builtins.str:
-        '''IP address or hostname of the target Elasticsearch instance.
-
-        :group: Inputs
-        '''
-        return typing.cast(builtins.str, jsii.get(self, "host"))
+    def inside_cidr(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("inside_cidr")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="awsAuth")
-    def aws_auth(self) -> typing.Optional[builtins.bool]:
-        '''Enable AWS Sigv4 Authentication for Amazon Elasticsearch Service.
+    def pre_shared_key(self) -> typing.Optional[_aws_cdk_ceddda9d.SecretValue]:
+        result = self._values.get("pre_shared_key")
+        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.SecretValue], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "awsAuth"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="awsExternalId")
-    def aws_external_id(self) -> typing.Optional[builtins.str]:
-        '''External ID for the AWS IAM Role specified with ``awsRole``.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsExternalId"))
+    def __repr__(self) -> str:
+        return "TunnelOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="awsRegion")
-    def aws_region(self) -> typing.Optional[builtins.str]:
-        '''Specify the AWS region for Elasticsearch Service.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.VpcAttachmentOptions",
+    jsii_struct_bases=[],
+    name_mapping={"name": "name", "subnets": "subnets"},
+)
+class VpcAttachmentOptions:
+    def __init__(
+        self,
+        *,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsRegion"))
-
-    @builtins.property
-    @jsii.member(jsii_name="awsRole")
-    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''AWS IAM Role to assume to put records to your Amazon cluster.
-
-        :group: Inputs
+        :param name: 
+        :param subnets: 
         '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "awsRole"))
+        if isinstance(subnets, dict):
+            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3dff1261f60aa49a2037d280e97af162d26181faeabf698640e4139891619042)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if name is not None:
+            self._values["name"] = name
+        if subnets is not None:
+            self._values["subnets"] = subnets
 
     @builtins.property
-    @jsii.member(jsii_name="awsStsEndpoint")
-    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify the custom sts endpoint to be used with STS API for Amazon Elasticsearch Service.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsStsEndpoint"))
+    def name(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="bufferSize")
-    def buffer_size(self) -> typing.Optional[ElasticsearchOutputBufferSize]:
-        '''Specify the buffer size used to read the response from the Elasticsearch HTTP service.
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        result = self._values.get("subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
 
-        This option is useful for debugging purposes where is
-        required to read full responses, note that response size grows depending
-        of the number of records inserted.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ElasticsearchOutputBufferSize], jsii.get(self, "bufferSize"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="cloudAuth")
-    def cloud_auth(self) -> typing.Optional[builtins.str]:
-        '''Specify the credentials to use to connect to Elastic's Elasticsearch Service running on Elastic Cloud.
+    def __repr__(self) -> str:
+        return "VpcAttachmentOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :group: Inputs
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.VpnAttachmentOptions",
+    jsii_struct_bases=[],
+    name_mapping={
+        "remote_endpoint": "remoteEndpoint",
+        "connection_type": "connectionType",
+        "static_routes_only": "staticRoutesOnly",
+        "tunnel_configurations": "tunnelConfigurations",
+    },
+)
+class VpnAttachmentOptions:
+    def __init__(
+        self,
+        *,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cloudAuth"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__c68fcd54ad9cdc22e3838841971cc60da339a1c6b65f45abf9839c71f80a1ad8)
+            check_type(argname="argument remote_endpoint", value=remote_endpoint, expected_type=type_hints["remote_endpoint"])
+            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
+            check_type(argname="argument static_routes_only", value=static_routes_only, expected_type=type_hints["static_routes_only"])
+            check_type(argname="argument tunnel_configurations", value=tunnel_configurations, expected_type=type_hints["tunnel_configurations"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "remote_endpoint": remote_endpoint,
+        }
+        if connection_type is not None:
+            self._values["connection_type"] = connection_type
+        if static_routes_only is not None:
+            self._values["static_routes_only"] = static_routes_only
+        if tunnel_configurations is not None:
+            self._values["tunnel_configurations"] = tunnel_configurations
 
     @builtins.property
-    @jsii.member(jsii_name="cloudId")
-    def cloud_id(self) -> typing.Optional[builtins.str]:
-        '''If you are using Elastic's Elasticsearch Service you can specify the cloud_id of the cluster running.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cloudId"))
+    def remote_endpoint(self) -> IRemoteVpnEndpoint:
+        result = self._values.get("remote_endpoint")
+        assert result is not None, "Required property 'remote_endpoint' is missing"
+        return typing.cast(IRemoteVpnEndpoint, result)
 
     @builtins.property
-    @jsii.member(jsii_name="compress")
-    def compress(self) -> typing.Optional[ElasticsearchCompressionFormat]:
-        '''Set payload compression mechanism.
+    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
+        result = self._values.get("connection_type")
+        return typing.cast(typing.Optional["VpnConnectionType"], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[ElasticsearchCompressionFormat], jsii.get(self, "compress"))
+    @builtins.property
+    def static_routes_only(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("static_routes_only")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="currentTimeIndex")
-    def current_time_index(self) -> typing.Optional[builtins.bool]:
-        '''Use current time for index generation instead of message record.
+    def tunnel_configurations(self) -> typing.Optional[typing.List[TunnelOptions]]:
+        result = self._values.get("tunnel_configurations")
+        return typing.cast(typing.Optional[typing.List[TunnelOptions]], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "currentTimeIndex"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="generateId")
-    def generate_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, generate ``_id`` for outgoing records.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        This prevents duplicate
-        records when retrying.
+    def __repr__(self) -> str:
+        return "VpnAttachmentOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "generateId"))
 
-    @builtins.property
-    @jsii.member(jsii_name="httpPasswd")
-    def http_passwd(self) -> typing.Optional[builtins.str]:
-        '''Password for user defined in ``httpUser``.
+@jsii.implements(_aws_cdk_aws_ec2_ceddda9d.IVpnConnection)
+class VpnConnection(
+    _aws_cdk_ceddda9d.Resource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.VpnConnection",
+):
+    '''Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.'''
 
-        :group: Inputs
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        local_endpoint: ILocalVpnEndpoint,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the TransitGatewayAttachment class.
+
+        :param scope: A CDK Construct that will serve as this stack's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param local_endpoint: 
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpPasswd"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__db1711f2c24c8b7a52cb1e23aa7c00f2ee31a53d068176d8b694ba413b49c85e)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = VpnConnectionProps(
+            local_endpoint=local_endpoint,
+            remote_endpoint=remote_endpoint,
+            connection_type=connection_type,
+            static_routes_only=static_routes_only,
+            tunnel_configurations=tunnel_configurations,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="httpUser")
-    def http_user(self) -> typing.Optional[builtins.str]:
-        '''Optional username credential for access.
+        jsii.create(self.__class__, self, [scope, id, props])
 
-        :group: Inputs
+    @jsii.member(jsii_name="addTunnelConfiguration")
+    def add_tunnel_configuration(
+        self,
+        *,
+        inside_cidr: typing.Optional[builtins.str] = None,
+        pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
+    ) -> None:
+        '''
+        :param inside_cidr: 
+        :param pre_shared_key: 
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpUser"))
+        options = TunnelOptions(inside_cidr=inside_cidr, pre_shared_key=pre_shared_key)
 
-    @builtins.property
-    @jsii.member(jsii_name="idKey")
-    def id_key(self) -> typing.Optional[builtins.str]:
-        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+        return typing.cast(None, jsii.invoke(self, "addTunnelConfiguration", [options]))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idKey"))
+    @jsii.member(jsii_name="metric")
+    def metric(
+        self,
+        metric_name: builtins.str,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        color: typing.Optional[builtins.str] = None,
+        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        label: typing.Optional[builtins.str] = None,
+        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        region: typing.Optional[builtins.str] = None,
+        statistic: typing.Optional[builtins.str] = None,
+        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
+    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
+        '''Return the given named metric for this VPNConnection.
+
+        :param metric_name: -
+        :param account: Account which this metric comes from. Default: - Deployment account.
+        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
+        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
+        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
+        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
+        :param region: Region which this metric comes from. Default: - Deployment region.
+        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
+        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__3b1943d41246b0671229072a9d9650d8d0f9f66aaf7b458b59f96ab84ad35da3)
+            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
+        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+            account=account,
+            color=color,
+            dimensions_map=dimensions_map,
+            label=label,
+            period=period,
+            region=region,
+            statistic=statistic,
+            unit=unit,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="includeTagKey")
-    def include_tag_key(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it append the Tag name to the record.
+        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metric", [metric_name, props]))
 
-        :group: Inputs
+    @jsii.member(jsii_name="metricTunnelDataIn")
+    def metric_tunnel_data_in(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        color: typing.Optional[builtins.str] = None,
+        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        label: typing.Optional[builtins.str] = None,
+        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        region: typing.Optional[builtins.str] = None,
+        statistic: typing.Optional[builtins.str] = None,
+        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
+    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
+        '''The bytes received through the VPN tunnel.
+
+        Sum over 5 minutes
+
+        :param account: Account which this metric comes from. Default: - Deployment account.
+        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
+        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
+        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
+        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
+        :param region: Region which this metric comes from. Default: - Deployment region.
+        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
+        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagKey"))
+        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+            account=account,
+            color=color,
+            dimensions_map=dimensions_map,
+            label=label,
+            period=period,
+            region=region,
+            statistic=statistic,
+            unit=unit,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="index")
-    def index(self) -> typing.Optional[builtins.str]:
-        '''Index name.
+        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelDataIn", [props]))
 
-        :group: Inputs
+    @jsii.member(jsii_name="metricTunnelDataOut")
+    def metric_tunnel_data_out(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        color: typing.Optional[builtins.str] = None,
+        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        label: typing.Optional[builtins.str] = None,
+        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        region: typing.Optional[builtins.str] = None,
+        statistic: typing.Optional[builtins.str] = None,
+        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
+    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
+        '''The bytes sent through the VPN tunnel.
+
+        Sum over 5 minutes
+
+        :param account: Account which this metric comes from. Default: - Deployment account.
+        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
+        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
+        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
+        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
+        :param region: Region which this metric comes from. Default: - Deployment region.
+        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
+        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "index"))
+        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+            account=account,
+            color=color,
+            dimensions_map=dimensions_map,
+            label=label,
+            period=period,
+            region=region,
+            statistic=statistic,
+            unit=unit,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="logstashDateFormat")
-    def logstash_date_format(self) -> typing.Optional[builtins.str]:
-        '''Time format (based on strftime) to generate the second part of the Index name.
+        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelDataOut", [props]))
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
+    @jsii.member(jsii_name="metricTunnelState")
+    def metric_tunnel_state(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        color: typing.Optional[builtins.str] = None,
+        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+        label: typing.Optional[builtins.str] = None,
+        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+        region: typing.Optional[builtins.str] = None,
+        statistic: typing.Optional[builtins.str] = None,
+        unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
+    ) -> _aws_cdk_aws_cloudwatch_ceddda9d.Metric:
+        '''The state of the tunnel.
+
+        0 indicates DOWN and 1 indicates UP.
+
+        Average over 5 minutes
+
+        :param account: Account which this metric comes from. Default: - Deployment account.
+        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
+        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
+        :param label: Label for this metric when added to a Graph in a Dashboard. You can use `dynamic labels <https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html>`_ to show summary information about the entire displayed time series in the legend. For example, if you use:: [max: ${MAX}] MyMetric As the metric label, the maximum value in the visible range will be shown next to the time series name in the graph's legend. Default: - No label
+        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
+        :param region: Region which this metric comes from. Default: - Deployment region.
+        :param statistic: What function to use for aggregating. Use the ``aws_cloudwatch.Stats`` helper class to construct valid input strings. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" - "tmNN.NN" | "tm(NN.NN%:NN.NN%)" - "iqm" - "wmNN.NN" | "wm(NN.NN%:NN.NN%)" - "tcNN.NN" | "tc(NN.NN%:NN.NN%)" - "tsNN.NN" | "ts(NN.NN%:NN.NN%)" Default: Average
+        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashDateFormat"))
+        props = _aws_cdk_aws_cloudwatch_ceddda9d.MetricOptions(
+            account=account,
+            color=color,
+            dimensions_map=dimensions_map,
+            label=label,
+            period=period,
+            region=region,
+            statistic=statistic,
+            unit=unit,
+        )
+
+        return typing.cast(_aws_cdk_aws_cloudwatch_ceddda9d.Metric, jsii.invoke(self, "metricTunnelState", [props]))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashFormat")
-    def logstash_format(self) -> typing.Optional[builtins.bool]:
-        '''Enable Logstash format compatibility.
+    @jsii.member(jsii_name="connectionType")
+    def connection_type(self) -> "VpnConnectionType":
+        return typing.cast("VpnConnectionType", jsii.get(self, "connectionType"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "logstashFormat"))
+    @builtins.property
+    @jsii.member(jsii_name="customerGatewayAsn")
+    def customer_gateway_asn(self) -> jsii.Number:
+        '''The ASN of the customer gateway.'''
+        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashPrefix")
-    def logstash_prefix(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+    @jsii.member(jsii_name="customerGatewayId")
+    def customer_gateway_id(self) -> builtins.str:
+        '''The id of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
 
-        The last string appended belongs to the date when the data is being
-        generated.
+    @builtins.property
+    @jsii.member(jsii_name="customerGatewayIp")
+    def customer_gateway_ip(self) -> builtins.str:
+        '''The ip address of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefix"))
+    @builtins.property
+    @jsii.member(jsii_name="localEndpoint")
+    def local_endpoint(self) -> ILocalVpnEndpoint:
+        return typing.cast(ILocalVpnEndpoint, jsii.get(self, "localEndpoint"))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashPrefixKey")
-    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
-        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
+    @jsii.member(jsii_name="remoteEndpoint")
+    def remote_endpoint(self) -> IRemoteVpnEndpoint:
+        return typing.cast(IRemoteVpnEndpoint, jsii.get(self, "remoteEndpoint"))
 
-        If
-        the key/value is not found in the record then the ``logstashPrefix`` option
-        will act as a fallback.
+    @builtins.property
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection:
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection, jsii.get(self, "resource"))
 
-        Nested keys are not supported (if desired, you can use the nest filter
-        plugin to remove nesting).
+    @builtins.property
+    @jsii.member(jsii_name="tunnelConfigurations")
+    def tunnel_configurations(self) -> typing.List[TunnelOptions]:
+        return typing.cast(typing.List[TunnelOptions], jsii.get(self, "tunnelConfigurations"))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefixKey"))
+    @builtins.property
+    @jsii.member(jsii_name="vpnId")
+    def vpn_id(self) -> builtins.str:
+        '''The id of the VPN connection.'''
+        return typing.cast(builtins.str, jsii.get(self, "vpnId"))
 
     @builtins.property
-    @jsii.member(jsii_name="path")
-    def path(self) -> typing.Optional[builtins.str]:
-        '''Elasticsearch accepts new data on HTTP query path "/_bulk".
+    @jsii.member(jsii_name="staticRoutesOnly")
+    def static_routes_only(self) -> typing.Optional[builtins.bool]:
+        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "staticRoutesOnly"))
 
-        But it is
-        also possible to serve Elasticsearch behind a reverse proxy on a
-        subpath. This option defines such path on the fluent-bit side. It
-        simply adds a path prefix in the indexing HTTP POST URI.
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "path"))
+class VpnConnectionLocalEndpoint(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.VpnConnectionLocalEndpoint",
+):
+    '''Provides options for specifying the local side of a VPN connection.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="pipeline")
-    def pipeline(self) -> typing.Optional[builtins.str]:
-        '''Elasticsearch allows to setup filters called pipelines.
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-        This option
-        allows to define which pipeline the database should use.
+    @jsii.member(jsii_name="fromTransitGateway")
+    @builtins.classmethod
+    def from_transit_gateway(
+        cls,
+        transit_gateway: ITransitGateway,
+    ) -> TransitGatewayLocalVpnEndpoint:
+        '''
+        :param transit_gateway: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__b7ddda611ef5d00d1dbfb980664aaf365a9109585805083204f9dd201f73b937)
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+        return typing.cast(TransitGatewayLocalVpnEndpoint, jsii.sinvoke(cls, "fromTransitGateway", [transit_gateway]))
 
-        :group: Inputs
+    @jsii.member(jsii_name="fromVpnGateway")
+    @builtins.classmethod
+    def from_vpn_gateway(
+        cls,
+        vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
+    ) -> "VpnGatewayLocalVpnEndpoint":
+        '''
+        :param vpn_gateway: -
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pipeline"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__255c4f2f88d39694addb3404e05f43b66d5900dda0a83d02497e7579af1e9f87)
+            check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
+        return typing.cast("VpnGatewayLocalVpnEndpoint", jsii.sinvoke(cls, "fromVpnGateway", [vpn_gateway]))
 
-    @builtins.property
-    @jsii.member(jsii_name="port")
-    def port(self) -> typing.Optional[jsii.Number]:
-        '''TCP port of the target Elasticsearch instance.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.VpnConnectionProps",
+    jsii_struct_bases=[_aws_cdk_ceddda9d.ResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "local_endpoint": "localEndpoint",
+        "remote_endpoint": "remoteEndpoint",
+        "connection_type": "connectionType",
+        "static_routes_only": "staticRoutesOnly",
+        "tunnel_configurations": "tunnelConfigurations",
+    },
+)
+class VpnConnectionProps(_aws_cdk_ceddda9d.ResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        local_endpoint: ILocalVpnEndpoint,
+        remote_endpoint: IRemoteVpnEndpoint,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        static_routes_only: typing.Optional[builtins.bool] = None,
+        tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    ) -> None:
+        '''Configuration for the VpnConnection resource.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param local_endpoint: 
+        :param remote_endpoint: 
+        :param connection_type: 
+        :param static_routes_only: 
+        :param tunnel_configurations: 
         '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "port"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e9f1ecffd701acc1acc5674e16c0bca0e65f2e2327e74bfb0fe4021722919ad1)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument local_endpoint", value=local_endpoint, expected_type=type_hints["local_endpoint"])
+            check_type(argname="argument remote_endpoint", value=remote_endpoint, expected_type=type_hints["remote_endpoint"])
+            check_type(argname="argument connection_type", value=connection_type, expected_type=type_hints["connection_type"])
+            check_type(argname="argument static_routes_only", value=static_routes_only, expected_type=type_hints["static_routes_only"])
+            check_type(argname="argument tunnel_configurations", value=tunnel_configurations, expected_type=type_hints["tunnel_configurations"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "local_endpoint": local_endpoint,
+            "remote_endpoint": remote_endpoint,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if connection_type is not None:
+            self._values["connection_type"] = connection_type
+        if static_routes_only is not None:
+            self._values["static_routes_only"] = static_routes_only
+        if tunnel_configurations is not None:
+            self._values["tunnel_configurations"] = tunnel_configurations
 
     @builtins.property
-    @jsii.member(jsii_name="replaceDots")
-    def replace_dots(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, replace field name dots with underscore.
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "replaceDots"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="suppressTypeName")
-    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, mapping types is removed and ``type`` option is ignored.
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "suppressTypeName"))
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-    @builtins.property
-    @jsii.member(jsii_name="tagKey")
-    def tag_key(self) -> typing.Optional[builtins.str]:
-        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :group: Inputs
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagKey"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        The``timeKey`` property defines the name of that field.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :group: Inputs
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKeyFormat")
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKeyNanos")
-    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
-        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "timeKeyNanos"))
+    def local_endpoint(self) -> ILocalVpnEndpoint:
+        result = self._values.get("local_endpoint")
+        assert result is not None, "Required property 'local_endpoint' is missing"
+        return typing.cast(ILocalVpnEndpoint, result)
 
     @builtins.property
-    @jsii.member(jsii_name="traceError")
-    def trace_error(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the Elasticsearch API calls to stdout when Elasticsearch returns an error (for diag only).
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceError"))
+    def remote_endpoint(self) -> IRemoteVpnEndpoint:
+        result = self._values.get("remote_endpoint")
+        assert result is not None, "Required property 'remote_endpoint' is missing"
+        return typing.cast(IRemoteVpnEndpoint, result)
 
     @builtins.property
-    @jsii.member(jsii_name="traceOutput")
-    def trace_output(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the Elasticsearch API calls to stdout (for diag only).
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceOutput"))
+    def connection_type(self) -> typing.Optional["VpnConnectionType"]:
+        result = self._values.get("connection_type")
+        return typing.cast(typing.Optional["VpnConnectionType"], result)
 
     @builtins.property
-    @jsii.member(jsii_name="type")
-    def type(self) -> typing.Optional[builtins.str]:
-        '''Type name.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "type"))
+    def static_routes_only(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("static_routes_only")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="workers")
-    def workers(self) -> typing.Optional[jsii.Number]:
-        '''Enables dedicated thread(s) for this output.
+    def tunnel_configurations(self) -> typing.Optional[typing.List[TunnelOptions]]:
+        result = self._values.get("tunnel_configurations")
+        return typing.cast(typing.Optional[typing.List[TunnelOptions]], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workers"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="writeOperation")
-    def write_operation(self) -> typing.Optional[builtins.str]:
-        '''Operation to use to write in bulk requests.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "writeOperation"))
+    def __repr__(self) -> str:
+        return "VpnConnectionProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class FluentBitJsonParser(
-    FluentBitParserPluginBase,
+class VpnConnectionRemoteEndpoint(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitJsonParser",
+    jsii_type="cdk-extensions.ec2.VpnConnectionRemoteEndpoint",
 ):
-    '''A Fluent Bit filter that parsed inbound messages in JSON format.'''
+    '''Provides options for specifying the remote side of a VPN connection.'''
 
-    def __init__(
-        self,
-        name: builtins.str,
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
+
+    @jsii.member(jsii_name="fromConfiguration")
+    @builtins.classmethod
+    def from_configuration(
+        cls,
         *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitJsonParser class.
+        ip_address: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        connection_type: typing.Optional["VpnConnectionType"] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> "CustomerGatewayConfigurationRemoteVpnEndpoint":
+        '''Creates a remote connection using the configuration details provided.
 
-        :param name: -
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+
+        :return: A configuration object representing a remote VPN destination.
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9667bfd8f45c5a175656e36d9ad7b4db85b5e7feb83c1e2fc34acbbea82478a0)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitJsonParserOptions(
-            time_format=time_format, time_key=time_key
+        configuration = CustomerGatewayProps(
+            ip_address=ip_address,
+            bgp_asn=bgp_asn,
+            connection_type=connection_type,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
         )
 
-        jsii.create(self.__class__, self, [name, options])
-
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        return typing.cast("CustomerGatewayConfigurationRemoteVpnEndpoint", jsii.sinvoke(cls, "fromConfiguration", [configuration]))
 
-        :param _scope: The construct configuring logging using Fluent Bit.
+    @jsii.member(jsii_name="fromCustomerGateway")
+    @builtins.classmethod
+    def from_customer_gateway(
+        cls,
+        customer_gateway: ICustomerGateway,
+    ) -> "CustomerGatewayRemoteVpnEndpoint":
+        '''Creates a remote connection using a customer gateway.
 
-        :return:
+        :param customer_gateway: The customer gateway that is configured for the remote endpoint device.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :return: A configuration object representing a remote VPN destination.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__1256282bf7828450eaecad96fbe7ce7a18dbb436f8a9946b3251e80084c75330)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__0ec3ce1dacbcb72f74a7ad181d5838d1e71517bb5fc661cee673e3d13cf35dbe)
+            check_type(argname="argument customer_gateway", value=customer_gateway, expected_type=type_hints["customer_gateway"])
+        return typing.cast("CustomerGatewayRemoteVpnEndpoint", jsii.sinvoke(cls, "fromCustomerGateway", [customer_gateway]))
 
-    @builtins.property
-    @jsii.member(jsii_name="timeFormat")
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+class VpnConnectionType(
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.VpnConnectionType",
+):
+    '''Represents a VPN protocol that can be used to establish a connection.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.
+    @jsii.member(jsii_name="of")
+    @builtins.classmethod
+    def of(cls, name: builtins.str) -> "VpnConnectionType":
+        '''An escape hatch method that allows defining custom VPN protocols.
 
-        :group: Inputs
+        :param name: The name of the VPN protocol.
+
+        :return: A VpnConnectionType object representing the specified protocol.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__19c531bfa20e4b82501cd1840a34d989b2593246657ad35703dfdd6156ae409b)
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+        return typing.cast("VpnConnectionType", jsii.sinvoke(cls, "of", [name]))
+
+    @jsii.python.classproperty
+    @jsii.member(jsii_name="IPSEC_1")
+    def IPSEC_1(cls) -> "VpnConnectionType":
+        '''The ipsec.1 VPN protocol.'''
+        return typing.cast("VpnConnectionType", jsii.sget(cls, "IPSEC_1"))
+
+    @builtins.property
+    @jsii.member(jsii_name="name")
+    def name(self) -> builtins.str:
+        '''The name of the VPN protocol.'''
+        return typing.cast(builtins.str, jsii.get(self, "name"))
 
 
-class FluentBitKinesisFirehoseOutput(
-    FluentBitOutputPluginBase,
+@jsii.implements(ILocalVpnEndpoint)
+class VpnGatewayLocalVpnEndpoint(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisFirehoseOutput",
+    jsii_type="cdk-extensions.ec2.VpnGatewayLocalVpnEndpoint",
 ):
-    '''Represents configuration for outputing logs from Fluent Bit to Kinesis Firehose.'''
+    '''Specifies a VPN connection endpoint which routes to a VPN gateway on the AWS side.'''
 
-    def __init__(
-        self,
-        *,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
-        delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
-        region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitKinesisFirehoseOutput class.
-
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param compression: Compression type for Firehose records. Each log record is individually compressed and sent to Firehose.
-        :param delivery_stream: The Kinesis Firehose Delivery stream that you want log records sent to.
-        :param endpoint: Specify a custom endpoint for the Firehose API.
-        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-        :param time_key: Add the timestamp to the record under this key.
-        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitKinesisFirehoseOutputOptions(
-            auto_retry_requests=auto_retry_requests,
-            compression=compression,
-            delivery_stream=delivery_stream,
-            endpoint=endpoint,
-            log_key=log_key,
-            region=region,
-            role=role,
-            sts_endpoint=sts_endpoint,
-            time_key=time_key,
-            time_key_format=time_key_format,
-            match=match,
-        )
+    def __init__(self, vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway) -> None:
+        '''Creates a new instance of the VpnGatewayLocalVpnEndpoint class.
 
-        jsii.create(self.__class__, self, [options])
+        :param vpn_gateway: The VPN gateway that serves as the local end of a VPN connection.
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__a4c9d0488d52533eda0e8e013c7c8dc98375bf35fbfb4d0119edfc6dafc3add2)
+            check_type(argname="argument vpn_gateway", value=vpn_gateway, expected_type=type_hints["vpn_gateway"])
+        jsii.create(self.__class__, self, [vpn_gateway])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param scope: The construct configuring logging using Fluent Bit.
-
-        :return:
+        _scope: _constructs_77d1e7e8.IConstruct,
+    ) -> LocalVpnEndpointConfiguration:
+        '''Produces a configuration that can be used when configuring the local end of a VPN connection.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :param _scope: The construct configuring the VPN connection that will be referencing the local endpoint.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__dcda296c8eede11fa4ddcc3c2feb2e785012111fa86135f95b451f948f97bd08)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__b034f4493a7f4e0ef9f3e966d78f68321b168b61b98dda5c4dace5477a2b5d5e)
+            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
+        return typing.cast(LocalVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="autoRetryRequests")
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
-
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+    @jsii.member(jsii_name="vpnGateway")
+    def vpn_gateway(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpnGateway:
+        '''The VPN gateway that serves as the local end of a VPN connection.
 
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
-
-    @builtins.property
-    @jsii.member(jsii_name="compression")
-    def compression(self) -> typing.Optional[KinesisFirehoseCompressionFormat]:
-        '''Compression type for Firehose records.
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpnGateway, jsii.get(self, "vpnGateway"))
 
-        Each log record is individually
-        compressed and sent to Firehose.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.AddressConfigurationProps",
+    jsii_struct_bases=[NetmaskLengthOptions],
+    name_mapping={
+        "default_netmask_length": "defaultNetmaskLength",
+        "max_netmask_length": "maxNetmaskLength",
+        "min_netmask_length": "minNetmaskLength",
+        "family": "family",
+        "publicly_advertisable": "publiclyAdvertisable",
+    },
+)
+class AddressConfigurationProps(NetmaskLengthOptions):
+    def __init__(
+        self,
+        *,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+        family: builtins.str,
+        publicly_advertisable: typing.Optional[builtins.bool] = None,
+    ) -> None:
         '''
-        return typing.cast(typing.Optional[KinesisFirehoseCompressionFormat], jsii.get(self, "compression"))
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        :param family: 
+        :param publicly_advertisable: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__70829756f6d4615ae6fcf33ab20a8d6ad7c5e9441db840b515597cfad99ddef1)
+            check_type(argname="argument default_netmask_length", value=default_netmask_length, expected_type=type_hints["default_netmask_length"])
+            check_type(argname="argument max_netmask_length", value=max_netmask_length, expected_type=type_hints["max_netmask_length"])
+            check_type(argname="argument min_netmask_length", value=min_netmask_length, expected_type=type_hints["min_netmask_length"])
+            check_type(argname="argument family", value=family, expected_type=type_hints["family"])
+            check_type(argname="argument publicly_advertisable", value=publicly_advertisable, expected_type=type_hints["publicly_advertisable"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "family": family,
+        }
+        if default_netmask_length is not None:
+            self._values["default_netmask_length"] = default_netmask_length
+        if max_netmask_length is not None:
+            self._values["max_netmask_length"] = max_netmask_length
+        if min_netmask_length is not None:
+            self._values["min_netmask_length"] = min_netmask_length
+        if publicly_advertisable is not None:
+            self._values["publicly_advertisable"] = publicly_advertisable
 
     @builtins.property
-    @jsii.member(jsii_name="deliveryStream")
-    def delivery_stream(self) -> typing.Optional[_IDeliveryStream_cf5feed7]:
-        '''The Kinesis Firehose Delivery stream that you want log records sent to.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_IDeliveryStream_cf5feed7], jsii.get(self, "deliveryStream"))
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="endpoint")
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the Firehose API.
+    def max_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("max_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
+    @builtins.property
+    def min_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("min_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="logKey")
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to Firehose.
+    def family(self) -> builtins.str:
+        result = self._values.get("family")
+        assert result is not None, "Required property 'family' is missing"
+        return typing.cast(builtins.str, result)
 
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to Firehose.
+    @builtins.property
+    def publicly_advertisable(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("publicly_advertisable")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="region")
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
+    def __repr__(self) -> str:
+        return "AddressConfigurationProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="role")
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.AllocateCidrFromPoolOptions",
+    jsii_struct_bases=[IpamAllocationOptions],
+    name_mapping={
+        "allocation": "allocation",
+        "description": "description",
+        "scope": "scope",
+    },
+)
+class AllocateCidrFromPoolOptions(IpamAllocationOptions):
+    def __init__(
+        self,
+        *,
+        allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+        description: typing.Optional[builtins.str] = None,
+        scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+    ) -> None:
         '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
+        :param allocation: 
+        :param description: 
+        :param scope: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__55ce524183de9e545e778862db7286b6b76ac2dfa4cff44105d75e9625dec995)
+            check_type(argname="argument allocation", value=allocation, expected_type=type_hints["allocation"])
+            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if allocation is not None:
+            self._values["allocation"] = allocation
+        if description is not None:
+            self._values["description"] = description
+        if scope is not None:
+            self._values["scope"] = scope
 
     @builtins.property
-    @jsii.member(jsii_name="stsEndpoint")
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.
+    def allocation(self) -> typing.Optional[IIpamAllocationConfiguration]:
+        result = self._values.get("allocation")
+        return typing.cast(typing.Optional[IIpamAllocationConfiguration], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
+    @builtins.property
+    def description(self) -> typing.Optional[builtins.str]:
+        result = self._values.get("description")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''Add the timestamp to the record under this key.
+    def scope(self) -> typing.Optional[_constructs_77d1e7e8.IConstruct]:
+        result = self._values.get("scope")
+        return typing.cast(typing.Optional[_constructs_77d1e7e8.IConstruct], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="timeKeyFormat")
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''A strftime compliant format string for the timestamp.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+    def __repr__(self) -> str:
+        return "AllocateCidrFromPoolOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
-class FluentBitKinesisOutput(
-    FluentBitOutputPluginBase,
+@jsii.implements(ICustomerGateway)
+class CustomerGateway(
+    _aws_cdk_ceddda9d.Resource,
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitKinesisOutput",
+    jsii_type="cdk-extensions.ec2.CustomerGateway",
 ):
-    '''Represents configuration for outputing logs from Fluent Bit to Kinesis Data Streams.'''
+    '''Specifies thje details of a remote endpoint that can serve as an endpoint for connections to AWS.'''
 
     def __init__(
         self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
         *,
-        auto_retry_requests: typing.Optional[builtins.bool] = None,
-        endpoint: typing.Optional[builtins.str] = None,
-        log_key: typing.Optional[builtins.str] = None,
+        ip_address: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        connection_type: typing.Optional[VpnConnectionType] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
         region: typing.Optional[builtins.str] = None,
-        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
-        sts_endpoint: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitKinesisOutput class.
-
-        :param auto_retry_requests: Immediately retry failed requests to AWS services once. This option does not affect the normal Fluent Bit retry mechanism with backoff. Instead, it enables an immediate retry with no delay for networking errors, which may help improve throughput when there are transient/random networking issues. Default: true
-        :param endpoint: Specify a custom endpoint for the Firehose API.
-        :param log_key: By default, the whole log record will be sent to Firehose. If you specify a key name with this option, then only the value of that key will be sent to Firehose.
-        :param region: The AWS region.
-        :param role: ARN of an IAM role to assume (for cross account access).
-        :param stream: The name of the Kinesis Streams Delivery stream that you want log records sent to.
-        :param sts_endpoint: Specify a custom STS endpoint for the AWS STS API.
-        :param time_key: Add the timestamp to the record under this key.
-        :param time_key_format: A strftime compliant format string for the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitKinesisOutputOptions(
-            auto_retry_requests=auto_retry_requests,
-            endpoint=endpoint,
-            log_key=log_key,
+    ) -> None:
+        '''Creates a new instance of the CustomerGateway class.
+
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__7814523b269d29ae5e2e42aa21c1f81bdc5a471fe5e300b0768c03a21b6a6f91)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = CustomerGatewayProps(
+            ip_address=ip_address,
+            bgp_asn=bgp_asn,
+            connection_type=connection_type,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
             region=region,
-            role=role,
-            stream=stream,
-            sts_endpoint=sts_endpoint,
-            time_key=time_key,
-            time_key_format=time_key_format,
-            match=match,
         )
 
-        jsii.create(self.__class__, self, [options])
+        jsii.create(self.__class__, self, [scope, id, props])
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
+    @jsii.member(jsii_name="fromCustomerGatewayAttributes")
+    @builtins.classmethod
+    def from_customer_gateway_attributes(
+        cls,
         scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param scope: The construct configuring logging using Fluent Bit.
+        id: builtins.str,
+        *,
+        customer_gateway_id: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        ip_address: typing.Optional[builtins.str] = None,
+    ) -> ICustomerGateway:
+        '''Imports an existing custom gateway by specifying its details.
 
-        :return:
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param customer_gateway_id: The ID of the existing customer gateway being imported.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :return: An object representing the imported customer gateway.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__4bf7e0507e4e17249fa3d68d625e57e70517c7cc3ef3896715e32aac5c34c20a)
+            type_hints = typing.get_type_hints(_typecheckingstub__9cee3aaa3f8d41d377b44df84c1bd31404fc3c74c1f3d4d50f41733f5ceaeaba)
             check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
-
-    @builtins.property
-    @jsii.member(jsii_name="autoRetryRequests")
-    def auto_retry_requests(self) -> typing.Optional[builtins.bool]:
-        '''Immediately retry failed requests to AWS services once.
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        attributes = CustomerGatewayAttributes(
+            customer_gateway_id=customer_gateway_id,
+            bgp_asn=bgp_asn,
+            ip_address=ip_address,
+        )
 
-        This option does
-        not affect the normal Fluent Bit retry mechanism with backoff. Instead,
-        it enables an immediate retry with no delay for networking errors, which
-        may help improve throughput when there are transient/random networking
-        issues.
+        return typing.cast(ICustomerGateway, jsii.sinvoke(cls, "fromCustomerGatewayAttributes", [scope, id, attributes]))
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "autoRetryRequests"))
+    @jsii.member(jsii_name="fromCustomerGatewayId")
+    @builtins.classmethod
+    def from_customer_gateway_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        customer_gateway_id: builtins.str,
+    ) -> ICustomerGateway:
+        '''Imports an existing custom gateway using its CustomerGatewayId.
 
-    @builtins.property
-    @jsii.member(jsii_name="endpoint")
-    def endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom endpoint for the Firehose API.
+        :param scope: A CDK Construct that will serve as this resource's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param customer_gateway_id: The ID of the existing customer gateway being imported.
 
-        :group: Inputs
+        :return: An object representing the imported customer gateway.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endpoint"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__745b377e3c9abac41a861ca1050cfc8012b832cecc7ce152fed229d86ee5e4ae)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument customer_gateway_id", value=customer_gateway_id, expected_type=type_hints["customer_gateway_id"])
+        return typing.cast(ICustomerGateway, jsii.sinvoke(cls, "fromCustomerGatewayId", [scope, id, customer_gateway_id]))
 
     @builtins.property
-    @jsii.member(jsii_name="logKey")
-    def log_key(self) -> typing.Optional[builtins.str]:
-        '''By default, the whole log record will be sent to Firehose.
-
-        If you
-        specify a key name with this option, then only the value of that key
-        will be sent to Firehose.
+    @jsii.member(jsii_name="bgpAsn")
+    def bgp_asn(self) -> jsii.Number:
+        '''For devices that support BGP, the customer gateway's BGP ASN.
 
+        :see: `CustomerGateway BgpAsn <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-bgpasn>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logKey"))
+        return typing.cast(jsii.Number, jsii.get(self, "bgpAsn"))
 
     @builtins.property
-    @jsii.member(jsii_name="region")
-    def region(self) -> typing.Optional[builtins.str]:
-        '''The AWS region.
+    @jsii.member(jsii_name="connectionType")
+    def connection_type(self) -> VpnConnectionType:
+        '''The type of VPN connection that this customer gateway supports.
 
+        :see: `CustomerGateway Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-type>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "region"))
+        return typing.cast(VpnConnectionType, jsii.get(self, "connectionType"))
 
     @builtins.property
-    @jsii.member(jsii_name="role")
-    def role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''ARN of an IAM role to assume (for cross account access).
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "role"))
+    @jsii.member(jsii_name="customerGatewayAsn")
+    def customer_gateway_asn(self) -> jsii.Number:
+        '''The BGP ASN of the customer gateway.'''
+        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))
 
     @builtins.property
-    @jsii.member(jsii_name="stream")
-    def stream(self) -> typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream]:
-        '''The name of the Kinesis Streams Delivery stream that you want log records sent to.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream], jsii.get(self, "stream"))
+    @jsii.member(jsii_name="customerGatewayId")
+    def customer_gateway_id(self) -> builtins.str:
+        '''The ID of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))
 
     @builtins.property
-    @jsii.member(jsii_name="stsEndpoint")
-    def sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify a custom STS endpoint for the AWS STS API.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stsEndpoint"))
+    @jsii.member(jsii_name="customerGatewayIp")
+    def customer_gateway_ip(self) -> builtins.str:
+        '''The IP address of the customer gateway.'''
+        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''Add the timestamp to the record under this key.
+    @jsii.member(jsii_name="ipAddress")
+    def ip_address(self) -> builtins.str:
+        '''The Internet-routable IP address for the customer gateway's outside interface.
+
+        The address must be static.
 
+        :see: `CustomerGateway IpAddress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html#cfn-ec2-customergateway-ipaddress>`_
         :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+        return typing.cast(builtins.str, jsii.get(self, "ipAddress"))
 
     @builtins.property
-    @jsii.member(jsii_name="timeKeyFormat")
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''A strftime compliant format string for the timestamp.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnCustomerGateway:
+        '''The underlying CustomerGateway CloudFormation resource.
 
-        :group: Inputs
+        :see: `AWS::EC2::CustomerGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customergateway.html>`_
+        :group: Resources
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnCustomerGateway, jsii.get(self, "resource"))
 
 
-class FluentBitLogfmtParser(
-    FluentBitParserPluginBase,
+@jsii.implements(IRemoteVpnEndpoint)
+class CustomerGatewayConfigurationRemoteVpnEndpoint(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLogfmtParser",
+    jsii_type="cdk-extensions.ec2.CustomerGatewayConfigurationRemoteVpnEndpoint",
 ):
-    '''A Fluent Bit filter that parsed inbound messages in LTSV format.'''
+    '''Specifies a remote VPN endpoint device by directly specifyingits details.'''
 
     def __init__(
         self,
-        name: builtins.str,
         *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+        ip_address: builtins.str,
+        bgp_asn: typing.Optional[jsii.Number] = None,
+        connection_type: typing.Optional[VpnConnectionType] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
     ) -> None:
-        '''Creates a new instance of the FluentBitLogfmtParser class.
+        '''Creates a new instance of the CustomerGatewayConfigurationRemoteVpnEndpoint class.
 
-        :param name: -
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
+        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN.
+        :param connection_type: The type of VPN connection that this customer gateway supports.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__8e25b48b2e66c9db37ff8e8c3719343636a0ede774d594e4e69fefd8f541afc7)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitLogfmtParserOptions(
-            time_format=time_format, time_key=time_key, types=types
+        configuration = CustomerGatewayProps(
+            ip_address=ip_address,
+            bgp_asn=bgp_asn,
+            connection_type=connection_type,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
         )
 
-        jsii.create(self.__class__, self, [name, options])
+        jsii.create(self.__class__, self, [configuration])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
-        _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param _scope: The construct configuring logging using Fluent Bit.
-
-        :return:
+        scope: _constructs_77d1e7e8.IConstruct,
+    ) -> RemoteVpnEndpointConfiguration:
+        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :param scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__0a81c3d8601df476452f69214aca18722b70cc833bc61983875ae41787e2ce75)
-            check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__376ae140d941de56c115f01c627b230e0ffb07b7247eb9a061e389e071218f36)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(RemoteVpnEndpointConfiguration, jsii.invoke(self, "bind", [scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="timeFormat")
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
+    @jsii.member(jsii_name="configuration")
+    def configuration(self) -> CustomerGatewayProps:
+        '''The details of the device on the remote end of the VPN connection.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+        return typing.cast(CustomerGatewayProps, jsii.get(self, "configuration"))
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.'''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+    @jsii.member(jsii_name="customerGateway")
+    def customer_gateway(self) -> typing.Optional[CustomerGateway]:
+        '''The customer gateway that was created to represent the device on the remote end of the VPN connection.
 
-    @builtins.property
-    @jsii.member(jsii_name="types")
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.'''
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+        :group: Resources
+        '''
+        return typing.cast(typing.Optional[CustomerGateway], jsii.get(self, "customerGateway"))
 
 
-class FluentBitLtsvParser(
-    FluentBitParserPluginBase,
+@jsii.implements(IRemoteVpnEndpoint)
+class CustomerGatewayRemoteVpnEndpoint(
     metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitLtsvParser",
+    jsii_type="cdk-extensions.ec2.CustomerGatewayRemoteVpnEndpoint",
 ):
-    '''A Fluent Bit filter that parsed inbound messages in LTSV format.'''
+    '''Specifies a remote VPN endpoint device that has its details configured in an existing customer gateway.'''
 
-    def __init__(
-        self,
-        name: builtins.str,
-        *,
-        time_format: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitLtsvParser class.
+    def __init__(self, customer_gateway: ICustomerGateway) -> None:
+        '''Creates a new instance of the CustomerGatewayRemoteVpnEndpoint class.
 
-        :param name: -
-        :param time_format: Defines the format of the timestamp on the inbound record.
-        :param time_key: The key under which timestamp information for the inbound record is given.
-        :param types: Maps group names matched by the regex to the data types they should be interpreted as.
+        :param customer_gateway: The customer gateway that is configured with the details of the remote endpoint device.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9575880f0d90bc5de7b08966955cdc0ae58d806eef8a52a89f16c51353d5f674)
-            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
-        options = FluentBitLtsvParserOptions(
-            time_format=time_format, time_key=time_key, types=types
-        )
-
-        jsii.create(self.__class__, self, [name, options])
+            type_hints = typing.get_type_hints(_typecheckingstub__39f263303ec59ccc7954f0b56dc5825a43956cfa48fc4648959c032c858f8a2f)
+            check_type(argname="argument customer_gateway", value=customer_gateway, expected_type=type_hints["customer_gateway"])
+        jsii.create(self.__class__, self, [customer_gateway])
 
     @jsii.member(jsii_name="bind")
     def bind(
         self,
         _scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
-
-        :param _scope: The construct configuring logging using Fluent Bit.
+    ) -> RemoteVpnEndpointConfiguration:
+        '''Produces a configuration that can be used when configuring the remote end of a VPN connection.
 
-        :return:
-
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        :param _scope: The construct configuring the VPN connection that will be referencing the remote endpoint.
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__9cc473e237e03b0900368e7d87fdfbee36d9a7b81802d233cd2091e9fbeed709)
+            type_hints = typing.get_type_hints(_typecheckingstub__bd8797d122fda919f703e603d2c593c1fe151dbc800704673ccc25360cdf5d3e)
             check_type(argname="argument _scope", value=_scope, expected_type=type_hints["_scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [_scope]))
+        return typing.cast(RemoteVpnEndpointConfiguration, jsii.invoke(self, "bind", [_scope]))
 
     @builtins.property
-    @jsii.member(jsii_name="timeFormat")
-    def time_format(self) -> typing.Optional[builtins.str]:
-        '''Defines the format of the timestamp on the inbound record.
+    @jsii.member(jsii_name="customerGateway")
+    def customer_gateway(self) -> ICustomerGateway:
+        '''The customer gateway that is configured with the details of the remote endpoint device.
 
-        :default: Inputs
-
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
+        :group: Inputs
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeFormat"))
+        return typing.cast(ICustomerGateway, jsii.get(self, "customerGateway"))
 
-    @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''The key under which timestamp information for the inbound record is given.
 
-        :default: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+@jsii.implements(ILogDestination)
+class FlowLogDestination(
+    metaclass=jsii.JSIIAbstractClass,
+    jsii_type="cdk-extensions.ec2.FlowLogDestination",
+):
+    '''Represents a resource that can act as a deliver endpoint for captured flow logs.'''
 
-    @builtins.property
-    @jsii.member(jsii_name="types")
-    def types(
-        self,
-    ) -> typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]]:
-        '''Maps group names matched by the regex to the data types they should be interpreted as.
+    def __init__(self) -> None:
+        jsii.create(self.__class__, self, [])
 
-        :default: Inputs
-        '''
-        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]], jsii.get(self, "types"))
+    @jsii.member(jsii_name="toCloudWatchLogs")
+    @builtins.classmethod
+    def to_cloud_watch_logs(
+        cls,
+        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    ) -> "FlowLogDestination":
+        '''Represents a CloudWatch log group that will serve as the endpoint where flow logs should be delivered.
 
+        :param log_group: The CloudWatch LogGroup where flow logs should be delivered.
+        :param role: An IAM role that allows Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.
 
-class FluentBitOpenSearchOutput(
-    FluentBitOutputPluginBase,
-    metaclass=jsii.JSIIMeta,
-    jsii_type="cdk-extensions.k8s_aws.FluentBitOpenSearchOutput",
-):
-    def __init__(
-        self,
-        *,
-        domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
-        aws_auth: typing.Optional[builtins.bool] = None,
-        aws_external_id: typing.Optional[builtins.str] = None,
-        aws_region: typing.Optional[builtins.str] = None,
-        aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-        aws_sts_endpoint: typing.Optional[builtins.str] = None,
-        buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
-        current_time_index: typing.Optional[builtins.bool] = None,
-        generate_id: typing.Optional[builtins.bool] = None,
-        host: typing.Optional[builtins.str] = None,
-        http_passwd: typing.Optional[builtins.str] = None,
-        http_user: typing.Optional[builtins.str] = None,
-        id_key: typing.Optional[builtins.str] = None,
-        include_tag_key: typing.Optional[builtins.bool] = None,
-        index: typing.Optional[builtins.str] = None,
-        logstash_date_format: typing.Optional[builtins.str] = None,
-        logstash_format: typing.Optional[builtins.bool] = None,
-        logstash_prefix: typing.Optional[builtins.str] = None,
-        logstash_prefix_key: typing.Optional[builtins.str] = None,
-        path: typing.Optional[builtins.str] = None,
-        pipeline: typing.Optional[builtins.str] = None,
-        port: typing.Optional[jsii.Number] = None,
-        replace_dots: typing.Optional[builtins.bool] = None,
-        suppress_type_name: typing.Optional[builtins.bool] = None,
-        tag_key: typing.Optional[builtins.str] = None,
-        time_key: typing.Optional[builtins.str] = None,
-        time_key_format: typing.Optional[builtins.str] = None,
-        time_key_nanos: typing.Optional[builtins.bool] = None,
-        trace_error: typing.Optional[builtins.bool] = None,
-        trace_output: typing.Optional[builtins.bool] = None,
-        type: typing.Optional[builtins.str] = None,
-        workers: typing.Optional[jsii.Number] = None,
-        write_operation: typing.Optional[builtins.str] = None,
-        match: typing.Optional[FluentBitMatch] = None,
-    ) -> None:
-        '''Creates a new instance of the FluentBitOpenSearchOutput class.
-
-        :param domain: The Opensearch domain to which logs should be shipped.
-        :param aws_auth: Enable AWS Sigv4 Authentication for Amazon OpenSearch Service. Default: false
-        :param aws_external_id: External ID for the AWS IAM Role specified with ``awsRole``.
-        :param aws_region: Specify the AWS region for Amazon OpenSearch Service.
-        :param aws_role: AWS IAM Role to assume to put records to your Amazon cluster.
-        :param aws_sts_endpoint: Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
-        :param buffer_size: Specify the buffer size used to read the response from the OpenSearch HTTP service. This option is useful for debugging purposes where is required to read full responses, note that response size grows depending of the number of records inserted.
-        :param current_time_index: Use current time for index generation instead of message record. Default: false
-        :param generate_id: When enabled, generate ``_id`` for outgoing records. This prevents duplicate records when retrying.
-        :param host: IP address or hostname of the target OpenSearch instance.
-        :param http_passwd: Password for user defined in ``httpUser``.
-        :param http_user: Optional username credential for access.
-        :param id_key: If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
-        :param include_tag_key: When enabled, it append the Tag name to the record.
-        :param index: Index name. Default: 'fluent-bit
-        :param logstash_date_format: Time format (based on strftime) to generate the second part of the Index name. Default: '%Y.%m.%d'
-        :param logstash_format: Enable Logstash format compatibility. Default: false
-        :param logstash_prefix: When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'. The last string appended belongs to the date when the data is being generated. Default: 'logstash'
-        :param logstash_prefix_key: When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation. If the key/value is not found in the record then the ``logstashPrefix`` option will act as a fallback. Nested keys are not supported (if desired, you can use the nest filter plugin to remove nesting)
-        :param path: OpenSearch accepts new data on HTTP query path "/_bulk". But it is also possible to serve OpenSearch behind a reverse proxy on a subpath. This option defines such path on the fluent-bit side. It simply adds a path prefix in the indexing HTTP POST URI..
-        :param pipeline: OpenSearch allows to setup filters called pipelines. This option allows to define which pipeline the database should use.
-        :param port: TCP port of the target OpenSearch instance. Default: 9200
-        :param replace_dots: When enabled, replace field name dots with underscore. Default: false
-        :param suppress_type_name: When enabled, mapping types is removed and ``type`` option is ignored. Default: false
-        :param tag_key: When ``includeTagKey`` is enabled, this property defines the key name for the tag. Default: '_flb-key'
-        :param time_key: When ``logstashFormat`` is enabled, each record will get a new timestamp field. The``timeKey`` property defines the name of that field. Default: '
-        :param time_key_format: When ``logstashFormat`` is enabled, this property defines the format of the timestamp. Default: '%Y-%m-%dT%H:%M:%S'
-        :param time_key_nanos: When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps. Default: false
-        :param trace_error: When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only). Default: false
-        :param trace_output: When enabled print the OpenSearch API calls to stdout (for diag only). Default: false
-        :param type: Type name. Default: '_doc'
-        :param workers: Enables dedicated thread(s) for this output. Default: 2
-        :param write_operation: Operation to use to write in bulk requests. Default: 'create'
-        :param match: The pattern to match for records that this output should apply to.
-        '''
-        options = FluentBitOpenSearchOutputOptions(
-            domain=domain,
-            aws_auth=aws_auth,
-            aws_external_id=aws_external_id,
-            aws_region=aws_region,
-            aws_role=aws_role,
-            aws_sts_endpoint=aws_sts_endpoint,
-            buffer_size=buffer_size,
-            current_time_index=current_time_index,
-            generate_id=generate_id,
-            host=host,
-            http_passwd=http_passwd,
-            http_user=http_user,
-            id_key=id_key,
-            include_tag_key=include_tag_key,
-            index=index,
-            logstash_date_format=logstash_date_format,
-            logstash_format=logstash_format,
-            logstash_prefix=logstash_prefix,
-            logstash_prefix_key=logstash_prefix_key,
-            path=path,
-            pipeline=pipeline,
-            port=port,
-            replace_dots=replace_dots,
-            suppress_type_name=suppress_type_name,
-            tag_key=tag_key,
-            time_key=time_key,
-            time_key_format=time_key_format,
-            time_key_nanos=time_key_nanos,
-            trace_error=trace_error,
-            trace_output=trace_output,
-            type=type,
-            workers=workers,
-            write_operation=write_operation,
-            match=match,
-        )
+        :return:
 
-        jsii.create(self.__class__, self, [options])
+        A configuration object containing details on how to set up
+        logging to the log group.
 
-    @jsii.member(jsii_name="bind")
-    def bind(
-        self,
-        scope: _constructs_77d1e7e8.IConstruct,
-    ) -> ResolvedFluentBitConfiguration:
-        '''Builds a configuration for this plugin and returns the details for consumtion by a resource that is configuring logging.
+        :see: `Publish flow logs to CloudWatch Logs <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-cwl.html>`_
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__5daa8ff9c63f8f6617139a25d0c2042756ce3ab0da13e5f5a51634e4b9f7ab0c)
+            check_type(argname="argument log_group", value=log_group, expected_type=type_hints["log_group"])
+            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
+        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toCloudWatchLogs", [log_group, role]))
+
+    @jsii.member(jsii_name="toS3")
+    @builtins.classmethod
+    def to_s3(
+        cls,
+        bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
+        *,
+        file_format: typing.Optional[FlowLogFileFormat] = None,
+        hive_compatible_partitions: typing.Optional[builtins.bool] = None,
+        key_prefix: typing.Optional[builtins.str] = None,
+        per_hour_partition: typing.Optional[builtins.bool] = None,
+    ) -> "FlowLogDestination":
+        '''Represents a CloudWatch log group that will serve as the endpoint where flow logs should be delivered.
 
-        :param scope: The construct configuring logging using Fluent Bit.
+        :param bucket: The S3 Bucket where flow logs should be delivered.
+        :param file_format: The file format in which flow logs should be delivered to S3.
+        :param hive_compatible_partitions: Controls the format of partitions ("folders") when the flow logs are delivered to S3. By default, flow logs are delivered partitioned such that each part of the S3 path represents a values pertaining to details of the log. When hive compatible partitions are enabled, partitions will be structured such that keys declaring the partition name are added at each level. An example of standard partitioning:: /us-east-1/2020/03/08/log.tar.gz An example with Hive compatible partitions:: /region=us-east-1/year=2020/month=03/day=08/log.tar.gz
+        :param key_prefix: An optional prefix that will be added to the start of all flow log files delivered to the S3 bucket.
+        :param per_hour_partition: Indicates whether to partition the flow log per hour. By default, flow logs are partitioned (organized into S3 "folders") by day. Setting this to true will add an extra layer of directories splitting flow log files by the hour in which they were delivered.
 
         :return:
 
-        A configuration for the plugin that con be used by the resource
-        configuring logging.
+        A configuration object containing details on how to set up
+        logging to the bucket.
+
+        :see: `Publish flow logs to Amazon S3 <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs-s3.html>`_
         '''
         if __debug__:
-            type_hints = typing.get_type_hints(_typecheckingstub__33bba3952c545b0c433e0348981b5b24158f45f87bd95dd02431e2b4b4656a81)
-            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
-        return typing.cast(ResolvedFluentBitConfiguration, jsii.invoke(self, "bind", [scope]))
+            type_hints = typing.get_type_hints(_typecheckingstub__8d11b43c926a884fe3a73d0b44332cd0342bba0c0e2d7bcac16489f068e1191b)
+            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
+        options = FlowLogS3Options(
+            file_format=file_format,
+            hive_compatible_partitions=hive_compatible_partitions,
+            key_prefix=key_prefix,
+            per_hour_partition=per_hour_partition,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="domain")
-    def domain(self) -> _aws_cdk_aws_opensearchservice_ceddda9d.IDomain:
-        '''The Opensearch domain to which logs should be shipped.
+        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toS3", [bucket, options]))
 
-        :group: Inputs
+    @jsii.member(jsii_name="bind")
+    @abc.abstractmethod
+    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
+        '''Returns a configuration object with all the fields and resources needed to configure a flow log to write to the destination.
+
+        :param scope: The CDK Construct that will be consuming the configuration and using it to configure a flow log.
         '''
-        return typing.cast(_aws_cdk_aws_opensearchservice_ceddda9d.IDomain, jsii.get(self, "domain"))
+        ...
 
-    @builtins.property
-    @jsii.member(jsii_name="port")
-    def port(self) -> jsii.Number:
-        '''TCP port of the target OpenSearch instance.
 
-        :group: Inputs
+class _FlowLogDestinationProxy(FlowLogDestination):
+    @jsii.member(jsii_name="bind")
+    def bind(self, scope: _constructs_77d1e7e8.IConstruct) -> FlowLogDestinationConfig:
+        '''Returns a configuration object with all the fields and resources needed to configure a flow log to write to the destination.
+
+        :param scope: The CDK Construct that will be consuming the configuration and using it to configure a flow log.
         '''
-        return typing.cast(jsii.Number, jsii.get(self, "port"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e6be248e60a194fe1d0bcf9dc9398b94b088ef8e6ca462c0c85ef25246e79057)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+        return typing.cast(FlowLogDestinationConfig, jsii.invoke(self, "bind", [scope]))
 
-    @builtins.property
-    @jsii.member(jsii_name="awsAuth")
-    def aws_auth(self) -> typing.Optional[builtins.bool]:
-        '''Enable AWS Sigv4 Authentication for Amazon OpenSearch Service.
+# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
+typing.cast(typing.Any, FlowLogDestination).__jsii_proxy_class__ = lambda : _FlowLogDestinationProxy
 
-        :group: Inputs
+
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.Ipv4ConfigurationOptions",
+    jsii_struct_bases=[NetmaskLengthOptions],
+    name_mapping={
+        "default_netmask_length": "defaultNetmaskLength",
+        "max_netmask_length": "maxNetmaskLength",
+        "min_netmask_length": "minNetmaskLength",
+    },
+)
+class Ipv4ConfigurationOptions(NetmaskLengthOptions):
+    def __init__(
+        self,
+        *,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+    ) -> None:
+        '''
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "awsAuth"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__88da3a3ecf8cb4cfba6289a415667d2b6f93a9c09443c8efc4a0b18c355aca3b)
+            check_type(argname="argument default_netmask_length", value=default_netmask_length, expected_type=type_hints["default_netmask_length"])
+            check_type(argname="argument max_netmask_length", value=max_netmask_length, expected_type=type_hints["max_netmask_length"])
+            check_type(argname="argument min_netmask_length", value=min_netmask_length, expected_type=type_hints["min_netmask_length"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if default_netmask_length is not None:
+            self._values["default_netmask_length"] = default_netmask_length
+        if max_netmask_length is not None:
+            self._values["max_netmask_length"] = max_netmask_length
+        if min_netmask_length is not None:
+            self._values["min_netmask_length"] = min_netmask_length
 
     @builtins.property
-    @jsii.member(jsii_name="awsExternalId")
-    def aws_external_id(self) -> typing.Optional[builtins.str]:
-        '''External ID for the AWS IAM Role specified with ``awsRole``.
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsExternalId"))
+    @builtins.property
+    def max_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("max_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="awsRegion")
-    def aws_region(self) -> typing.Optional[builtins.str]:
-        '''Specify the AWS region for Amazon OpenSearch Service.
+    def min_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("min_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsRegion"))
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-    @builtins.property
-    @jsii.member(jsii_name="awsRole")
-    def aws_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
-        '''AWS IAM Role to assume to put records to your Amazon cluster.
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], jsii.get(self, "awsRole"))
+    def __repr__(self) -> str:
+        return "Ipv4ConfigurationOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="awsStsEndpoint")
-    def aws_sts_endpoint(self) -> typing.Optional[builtins.str]:
-        '''Specify the custom sts endpoint to be used with STS API for Amazon OpenSearch Service.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.Ipv6ConfigurationOptions",
+    jsii_struct_bases=[NetmaskLengthOptions],
+    name_mapping={
+        "default_netmask_length": "defaultNetmaskLength",
+        "max_netmask_length": "maxNetmaskLength",
+        "min_netmask_length": "minNetmaskLength",
+        "publicly_advertisable": "publiclyAdvertisable",
+    },
+)
+class Ipv6ConfigurationOptions(NetmaskLengthOptions):
+    def __init__(
+        self,
+        *,
+        default_netmask_length: typing.Optional[jsii.Number] = None,
+        max_netmask_length: typing.Optional[jsii.Number] = None,
+        min_netmask_length: typing.Optional[jsii.Number] = None,
+        publicly_advertisable: typing.Optional[builtins.bool] = None,
+    ) -> None:
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "awsStsEndpoint"))
+        :param default_netmask_length: 
+        :param max_netmask_length: 
+        :param min_netmask_length: 
+        :param publicly_advertisable: 
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__68794c4d85dd9da608a3e224ee4d5a5834dbf3e68c8329ff179fbf9358467b84)
+            check_type(argname="argument default_netmask_length", value=default_netmask_length, expected_type=type_hints["default_netmask_length"])
+            check_type(argname="argument max_netmask_length", value=max_netmask_length, expected_type=type_hints["max_netmask_length"])
+            check_type(argname="argument min_netmask_length", value=min_netmask_length, expected_type=type_hints["min_netmask_length"])
+            check_type(argname="argument publicly_advertisable", value=publicly_advertisable, expected_type=type_hints["publicly_advertisable"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {}
+        if default_netmask_length is not None:
+            self._values["default_netmask_length"] = default_netmask_length
+        if max_netmask_length is not None:
+            self._values["max_netmask_length"] = max_netmask_length
+        if min_netmask_length is not None:
+            self._values["min_netmask_length"] = min_netmask_length
+        if publicly_advertisable is not None:
+            self._values["publicly_advertisable"] = publicly_advertisable
 
     @builtins.property
-    @jsii.member(jsii_name="bufferSize")
-    def buffer_size(self) -> typing.Optional[OpenSearchOutputBufferSize]:
-        '''Specify the buffer size used to read the response from the OpenSearch HTTP service.
-
-        This option is useful for debugging purposes where is
-        required to read full responses, note that response size grows depending
-        of the number of records inserted.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[OpenSearchOutputBufferSize], jsii.get(self, "bufferSize"))
+    def default_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("default_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="currentTimeIndex")
-    def current_time_index(self) -> typing.Optional[builtins.bool]:
-        '''Use current time for index generation instead of message record.
+    def max_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("max_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "currentTimeIndex"))
+    @builtins.property
+    def min_netmask_length(self) -> typing.Optional[jsii.Number]:
+        result = self._values.get("min_netmask_length")
+        return typing.cast(typing.Optional[jsii.Number], result)
 
     @builtins.property
-    @jsii.member(jsii_name="generateId")
-    def generate_id(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, generate ``_id`` for outgoing records.
+    def publicly_advertisable(self) -> typing.Optional[builtins.bool]:
+        result = self._values.get("publicly_advertisable")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
-        This prevents duplicate
-        records when retrying.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "generateId"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
 
-    @builtins.property
-    @jsii.member(jsii_name="httpPasswd")
-    def http_passwd(self) -> typing.Optional[builtins.str]:
-        '''Password for user defined in ``httpUser``.
+    def __repr__(self) -> str:
+        return "Ipv6ConfigurationOptions(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpPasswd"))
 
-    @builtins.property
-    @jsii.member(jsii_name="httpUser")
-    def http_user(self) -> typing.Optional[builtins.str]:
-        '''Optional username credential for access.
+class TransitGatewayAttachment(
+    TransitGatewayAttachmentResource,
+    metaclass=jsii.JSIIMeta,
+    jsii_type="cdk-extensions.ec2.TransitGatewayAttachment",
+):
+    '''Attaches a VPC to a transit gateway.
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "httpUser"))
+    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC
+    that is already attached, the new VPC CIDR range is not propagated to the
+    default propagation route table.
+    '''
 
-    @builtins.property
-    @jsii.member(jsii_name="idKey")
-    def id_key(self) -> typing.Optional[builtins.str]:
-        '''If set, ``_id`` will be the value of the key from incoming record and ``generateId`` option is ignored.
+    def __init__(
+        self,
+        scope: _constructs_77d1e7e8.Construct,
+        id: builtins.str,
+        *,
+        transit_gateway: ITransitGateway,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        appliance_mode_support: typing.Optional[builtins.bool] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        ipv6_support: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+    ) -> None:
+        '''Creates a new instance of the TransitGatewayAttachment class.
 
-        :group: Inputs
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway: The transit gateway for which the attachment should be created.
+        :param vpc: The VPC where the attachment should be created.
+        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
+        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "idKey"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__e27ee6909fddcfad51f5ddc3aee4e522d6f5fdeab0a0272e67e7d62c063924d6)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+        props = TransitGatewayAttachmentProps(
+            transit_gateway=transit_gateway,
+            vpc=vpc,
+            appliance_mode_support=appliance_mode_support,
+            dns_support=dns_support,
+            ipv6_support=ipv6_support,
+            name=name,
+            subnets=subnets,
+            account=account,
+            environment_from_arn=environment_from_arn,
+            physical_name=physical_name,
+            region=region,
+        )
 
-    @builtins.property
-    @jsii.member(jsii_name="includeTagKey")
-    def include_tag_key(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, it append the Tag name to the record.
+        jsii.create(self.__class__, self, [scope, id, props])
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "includeTagKey"))
+    @jsii.member(jsii_name="fromTransitGatewayAttachmentId")
+    @builtins.classmethod
+    def from_transit_gateway_attachment_id(
+        cls,
+        scope: _constructs_77d1e7e8.IConstruct,
+        id: builtins.str,
+        transit_gateway_attachment_id: builtins.str,
+    ) -> ITransitGatewayAttachment:
+        '''Imports an existing Transit Gateway Attachment using its attachment ID.
 
-    @builtins.property
-    @jsii.member(jsii_name="index")
-    def index(self) -> typing.Optional[builtins.str]:
-        '''Index name.
+        :param scope: A CDK Construct that will serve as this resources's parent in the construct tree.
+        :param id: A name to be associated with the stack and used in resource naming. Must be unique within the context of 'scope'.
+        :param transit_gateway_attachment_id: The attachment ID of the Transit Gateway attachment being imported.
 
-        :group: Inputs
+        :return: An object representing the imported transit gateway attachment.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "index"))
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__135a7b7bec5b4b7974ff32ebff887b94cc20f2b37d6736525ec2c4e7c4b5c542)
+            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
+            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
+            check_type(argname="argument transit_gateway_attachment_id", value=transit_gateway_attachment_id, expected_type=type_hints["transit_gateway_attachment_id"])
+        return typing.cast(ITransitGatewayAttachment, jsii.sinvoke(cls, "fromTransitGatewayAttachmentId", [scope, id, transit_gateway_attachment_id]))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashDateFormat")
-    def logstash_date_format(self) -> typing.Optional[builtins.str]:
-        '''Time format (based on strftime) to generate the second part of the Index name.
+    @jsii.member(jsii_name="resource")
+    def resource(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayAttachment:
+        '''The underlying NamedQuery CloudFormation resource.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
+        :see: `AWS::EC2::TransitGatewayVpcAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html>`_
+        :group: Resources
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashDateFormat"))
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnTransitGatewayAttachment, jsii.get(self, "resource"))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashFormat")
-    def logstash_format(self) -> typing.Optional[builtins.bool]:
-        '''Enable Logstash format compatibility.
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "logstashFormat"))
+    @jsii.member(jsii_name="transitGatewayAttachmentArn")
+    def transit_gateway_attachment_arn(self) -> builtins.str:
+        '''The ARN of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentArn"))
 
     @builtins.property
-    @jsii.member(jsii_name="logstashPrefix")
-    def logstash_prefix(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, the Index name is composed using a prefix and the date, e.g: If ``logstashPrefix`` is equals to 'mydata' your index will become 'mydata-YYYY.MM.DD'.
+    @jsii.member(jsii_name="transitGatewayAttachmentId")
+    def transit_gateway_attachment_id(self) -> builtins.str:
+        '''The ID of this Transit Gateway Attachment.'''
+        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))
 
-        The last string appended belongs to the date when the data is being
-        generated.
 
-        :group: Inputs
+@jsii.data_type(
+    jsii_type="cdk-extensions.ec2.TransitGatewayAttachmentProps",
+    jsii_struct_bases=[TransitGatewayAttachmentResourceProps],
+    name_mapping={
+        "account": "account",
+        "environment_from_arn": "environmentFromArn",
+        "physical_name": "physicalName",
+        "region": "region",
+        "transit_gateway": "transitGateway",
+        "vpc": "vpc",
+        "appliance_mode_support": "applianceModeSupport",
+        "dns_support": "dnsSupport",
+        "ipv6_support": "ipv6Support",
+        "name": "name",
+        "subnets": "subnets",
+    },
+)
+class TransitGatewayAttachmentProps(TransitGatewayAttachmentResourceProps):
+    def __init__(
+        self,
+        *,
+        account: typing.Optional[builtins.str] = None,
+        environment_from_arn: typing.Optional[builtins.str] = None,
+        physical_name: typing.Optional[builtins.str] = None,
+        region: typing.Optional[builtins.str] = None,
+        transit_gateway: ITransitGateway,
+        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+        appliance_mode_support: typing.Optional[builtins.bool] = None,
+        dns_support: typing.Optional[builtins.bool] = None,
+        ipv6_support: typing.Optional[builtins.bool] = None,
+        name: typing.Optional[builtins.str] = None,
+        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    ) -> None:
+        '''Configuration for TransitGatewayAttachment resource.
+
+        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
+        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
+        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
+        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
+        :param transit_gateway: The transit gateway for which the attachment should be created.
+        :param vpc: The VPC where the attachment should be created.
+        :param appliance_mode_support: Enables appliance mode on the attachment. When appliance mode is enabled, all traffic flowing between attachments is forwarded to an appliance in a shared VPC to be inspected and processed.
+        :param dns_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param ipv6_support: Enables DNS support for the attachment. With DNS Support enabled public DNS names that resolve to a connected VPC will be translated to private IP addresses when resolved in a connected VPC.
+        :param name: The name of the Transit Gateway Attachment. Used to tag the attachment with a name that will be displayed in the AWS EC2 console.
+        :param subnets: The subnets where the attachment should be created. Can select up to one subnet per Availability Zone.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefix"))
+        if isinstance(subnets, dict):
+            subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**subnets)
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__4d1defbd3f98b5d681f7a4e30d69288e6cdc5223fef0fed304547c78510a96e2)
+            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
+            check_type(argname="argument environment_from_arn", value=environment_from_arn, expected_type=type_hints["environment_from_arn"])
+            check_type(argname="argument physical_name", value=physical_name, expected_type=type_hints["physical_name"])
+            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
+            check_type(argname="argument transit_gateway", value=transit_gateway, expected_type=type_hints["transit_gateway"])
+            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
+            check_type(argname="argument appliance_mode_support", value=appliance_mode_support, expected_type=type_hints["appliance_mode_support"])
+            check_type(argname="argument dns_support", value=dns_support, expected_type=type_hints["dns_support"])
+            check_type(argname="argument ipv6_support", value=ipv6_support, expected_type=type_hints["ipv6_support"])
+            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
+            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
+        self._values: typing.Dict[builtins.str, typing.Any] = {
+            "transit_gateway": transit_gateway,
+            "vpc": vpc,
+        }
+        if account is not None:
+            self._values["account"] = account
+        if environment_from_arn is not None:
+            self._values["environment_from_arn"] = environment_from_arn
+        if physical_name is not None:
+            self._values["physical_name"] = physical_name
+        if region is not None:
+            self._values["region"] = region
+        if appliance_mode_support is not None:
+            self._values["appliance_mode_support"] = appliance_mode_support
+        if dns_support is not None:
+            self._values["dns_support"] = dns_support
+        if ipv6_support is not None:
+            self._values["ipv6_support"] = ipv6_support
+        if name is not None:
+            self._values["name"] = name
+        if subnets is not None:
+            self._values["subnets"] = subnets
 
     @builtins.property
-    @jsii.member(jsii_name="logstashPrefixKey")
-    def logstash_prefix_key(self) -> typing.Optional[builtins.str]:
-        '''When included: the value in the record that belongs to the key will be looked up and over-write the ``logstashPrefix`` for index generation.
-
-        If
-        the key/value is not found in the record then the ``logstashPrefix`` option
-        will act as a fallback.
-
-        Nested keys are not supported (if desired, you can use the nest filter
-        plugin to remove nesting).
+    def account(self) -> typing.Optional[builtins.str]:
+        '''The AWS account ID this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same account as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logstashPrefixKey"))
+        result = self._values.get("account")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="path")
-    def path(self) -> typing.Optional[builtins.str]:
-        '''OpenSearch accepts new data on HTTP query path "/_bulk".
+    def environment_from_arn(self) -> typing.Optional[builtins.str]:
+        '''ARN to deduce region and account from.
+
+        The ARN is parsed and the account and region are taken from the ARN.
+        This should be used for imported resources.
 
-        But it is also
-        possible to serve OpenSearch behind a reverse proxy on a subpath. This
-        option defines such path on the fluent-bit side. It simply adds a path
-        prefix in the indexing HTTP POST URI.
+        Cannot be supplied together with either ``account`` or ``region``.
 
-        :group: Inputs
+        :default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "path"))
+        result = self._values.get("environment_from_arn")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="pipeline")
-    def pipeline(self) -> typing.Optional[builtins.str]:
-        '''OpenSearch allows to setup filters called pipelines.
+    def physical_name(self) -> typing.Optional[builtins.str]:
+        '''The value passed in by users to the physical name prop of the resource.
 
-        This option allows
-        to define which pipeline the database should use.
+        - ``undefined`` implies that a physical name will be allocated by
+          CloudFormation during deployment.
+        - a concrete value implies a specific physical name
+        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
+          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.
 
-        :group: Inputs
+        :default: - The physical name will be allocated by CloudFormation at deployment time
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "pipeline"))
+        result = self._values.get("physical_name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="replaceDots")
-    def replace_dots(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, replace field name dots with underscore.
+    def region(self) -> typing.Optional[builtins.str]:
+        '''The AWS region this resource belongs to.
 
-        :group: Inputs
+        :default: - the resource is in the same region as the stack it belongs to
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "replaceDots"))
+        result = self._values.get("region")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="suppressTypeName")
-    def suppress_type_name(self) -> typing.Optional[builtins.bool]:
-        '''When enabled, mapping types is removed and ``type`` option is ignored.
+    def transit_gateway(self) -> ITransitGateway:
+        '''The transit gateway for which the attachment should be created.
 
-        :group: Inputs
+        :see: `TransitGatewayVpcAttachment TransitGatewayId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "suppressTypeName"))
+        result = self._values.get("transit_gateway")
+        assert result is not None, "Required property 'transit_gateway' is missing"
+        return typing.cast(ITransitGateway, result)
 
     @builtins.property
-    @jsii.member(jsii_name="tagKey")
-    def tag_key(self) -> typing.Optional[builtins.str]:
-        '''When ``includeTagKey`` is enabled, this property defines the key name for the tag.
+    def vpc(self) -> _aws_cdk_aws_ec2_ceddda9d.IVpc:
+        '''The VPC where the attachment should be created.
 
-        :group: Inputs
+        :see: `TransitGatewayVpcAttachment VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tagKey"))
+        result = self._values.get("vpc")
+        assert result is not None, "Required property 'vpc' is missing"
+        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.IVpc, result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKey")
-    def time_key(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, each record will get a new timestamp field.
+    def appliance_mode_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables appliance mode on the attachment.
 
-        The``timeKey`` property defines the name of that field.
+        When appliance mode is enabled, all traffic flowing between attachments is
+        forwarded to an appliance in a shared VPC to be inspected and processed.
 
-        :group: Inputs
+        :see: `Appliance in a shared services VPC <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-appliance-scenario.html>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKey"))
+        result = self._values.get("appliance_mode_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="timeKeyFormat")
-    def time_key_format(self) -> typing.Optional[builtins.str]:
-        '''When ``logstashFormat`` is enabled, this property defines the format of the timestamp.
+    def dns_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-        :see: `strftime <http://man7.org/linux/man-pages/man3/strftime.3.html>`_
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "timeKeyFormat"))
-
-    @builtins.property
-    @jsii.member(jsii_name="timeKeyNanos")
-    def time_key_nanos(self) -> typing.Optional[builtins.bool]:
-        '''When ``logstashFormat`` is enabled, enabling this property sends nanosecond precision timestamps.
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
 
-        :group: Inputs
+        :see: `TransitGatewayVpcAttachment DnsSupport <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayvpcattachment-options.html#cfn-ec2-transitgatewayvpcattachment-options-dnssupport>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "timeKeyNanos"))
+        result = self._values.get("dns_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="traceError")
-    def trace_error(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the OpenSearch API calls to stdout when OpenSearch returns an error (for diag only).
-
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceError"))
+    def ipv6_support(self) -> typing.Optional[builtins.bool]:
+        '''Enables DNS support for the attachment.
 
-    @builtins.property
-    @jsii.member(jsii_name="traceOutput")
-    def trace_output(self) -> typing.Optional[builtins.bool]:
-        '''When enabled print the OpenSearch API calls to stdout (for diag only).
+        With DNS Support enabled public DNS names that resolve to a connected VPC
+        will be translated to private IP addresses when resolved in a connected VPC.
 
-        :group: Inputs
+        :see: `IPv6 connectivity with TransitGateway <https://docs.aws.amazon.com/whitepapers/latest/ipv6-on-aws/amazon-vpc-connectivity-options-for-ipv6.html#ipv6-connectivity-with-transit-gateway>`_
         '''
-        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "traceOutput"))
+        result = self._values.get("ipv6_support")
+        return typing.cast(typing.Optional[builtins.bool], result)
 
     @builtins.property
-    @jsii.member(jsii_name="type")
-    def type(self) -> typing.Optional[builtins.str]:
-        '''Type name.
+    def name(self) -> typing.Optional[builtins.str]:
+        '''The name of the Transit Gateway Attachment.
 
-        :group: Inputs
+        Used to tag the attachment with a name that will be displayed in the AWS
+        EC2 console.
+
+        :see: `TransitGatewayVpcAttachment Tags <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags>`_
         '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "type"))
+        result = self._values.get("name")
+        return typing.cast(typing.Optional[builtins.str], result)
 
     @builtins.property
-    @jsii.member(jsii_name="workers")
-    def workers(self) -> typing.Optional[jsii.Number]:
-        '''Enables dedicated thread(s) for this output.
+    def subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
+        '''The subnets where the attachment should be created.
 
-        :group: Inputs
+        Can select up to one subnet per Availability Zone.
+
+        :see: `TransitGatewayVpcAttachment SubnetIds <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids>`_
         '''
-        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "workers"))
+        result = self._values.get("subnets")
+        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)
 
-    @builtins.property
-    @jsii.member(jsii_name="writeOperation")
-    def write_operation(self) -> typing.Optional[builtins.str]:
-        '''Operation to use to write in bulk requests.
+    def __eq__(self, rhs: typing.Any) -> builtins.bool:
+        return isinstance(rhs, self.__class__) and rhs._values == self._values
 
-        :group: Inputs
-        '''
-        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "writeOperation"))
+    def __ne__(self, rhs: typing.Any) -> builtins.bool:
+        return not (rhs == self)
+
+    def __repr__(self) -> str:
+        return "TransitGatewayAttachmentProps(%s)" % ", ".join(
+            k + "=" + repr(v) for k, v in self._values.items()
+        )
 
 
 __all__ = [
-    "AdotCollector",
-    "AdotCollectorProps",
-    "AppendedRecord",
-    "AwsSecretStore",
-    "AwsSecretStoreProps",
-    "AwsServiceDiscoveryRegistry",
-    "Echoserver",
-    "EchoserverProps",
-    "ElasticsearchCompressionFormat",
-    "ElasticsearchOutputBufferSize",
-    "EmitterStorageType",
-    "ExternalDnsLogFormat",
-    "ExternalDnsLogLevel",
-    "ExternalDnsRegistry",
-    "ExternalDnsRegistryConfiguration",
-    "ExternalDnsSyncPolicy",
-    "ExternalDnsZoneTag",
-    "ExternalDnsZoneType",
-    "ExternalSecret",
-    "ExternalSecretOptions",
-    "ExternalSecretProps",
-    "ExternalSecretsOperator",
-    "ExternalSecretsOperatorProps",
-    "FargateLogger",
-    "FargateLoggerOptions",
-    "FargateLoggerProps",
-    "FluentBitCloudWatchLogsOutput",
-    "FluentBitCloudWatchLogsOutputOptions",
-    "FluentBitElasticsearchOutput",
-    "FluentBitElasticsearchOutputOptions",
-    "FluentBitFilter",
-    "FluentBitFilterPluginBase",
-    "FluentBitFilterPluginCommonOptions",
-    "FluentBitGrepFilter",
-    "FluentBitGrepFilterOptions",
-    "FluentBitGrepRegex",
-    "FluentBitJsonParser",
-    "FluentBitJsonParserOptions",
-    "FluentBitKinesisFirehoseOutput",
-    "FluentBitKinesisFirehoseOutputOptions",
-    "FluentBitKinesisOutput",
-    "FluentBitKinesisOutputOptions",
-    "FluentBitKubernetesFilter",
-    "FluentBitKubernetesFilterOptions",
-    "FluentBitLogGroupOutput",
-    "FluentBitLogStreamOutput",
-    "FluentBitLogfmtParser",
-    "FluentBitLogfmtParserOptions",
-    "FluentBitLtsvParser",
-    "FluentBitLtsvParserOptions",
-    "FluentBitMatch",
-    "FluentBitMatchEvaluator",
-    "FluentBitModifyFilter",
-    "FluentBitModifyFilterOptions",
-    "FluentBitNestFilter",
-    "FluentBitNestFilterOptions",
-    "FluentBitOpenSearchOutput",
-    "FluentBitOpenSearchOutputOptions",
-    "FluentBitOutput",
-    "FluentBitOutputPluginBase",
-    "FluentBitOutputPluginCommonOptions",
-    "FluentBitParser",
-    "FluentBitParserFilter",
-    "FluentBitParserFilterOptions",
-    "FluentBitParserPluginBase",
-    "FluentBitParserPluginCommonOptions",
-    "FluentBitPlugin",
-    "FluentBitPluginCommonOptions",
-    "FluentBitPluginType",
-    "FluentBitRecordModifierFilter",
-    "FluentBitRecordModifierFilterOptions",
-    "FluentBitRegexParser",
-    "FluentBitRegexParserOptions",
-    "FluentBitRewriteTagFilter",
-    "FluentBitRewriteTagFilterOptions",
-    "FluentBitThrottleFilter",
-    "FluentBitThrottleFilterOptions",
-    "IExternalDnsRegistry",
-    "IFluentBitFilterPlugin",
-    "IFluentBitOutputPlugin",
-    "IFluentBitParserPlugin",
-    "IFluentBitPlugin",
-    "INestFilterOperation",
-    "ISecretReference",
-    "ISecretStore",
-    "KinesisFirehoseCompressionFormat",
-    "LiftOptions",
-    "MetadataPolicy",
-    "ModifyCondition",
-    "ModifyOperation",
-    "NamespacedExternalSecretOptions",
-    "NestFilterOperation",
-    "NestFilterOperationType",
-    "NestOptions",
-    "NoopRegistry",
-    "OpenSearchOutputBufferSize",
-    "ParserPluginDataType",
-    "ResolvedFluentBitConfiguration",
-    "RewriteTagRule",
-    "Route53Dns",
-    "Route53DnsOptions",
-    "Route53DnsProps",
-    "SecretFieldReference",
-    "SecretReferenceConfiguration",
-    "SecretsManagerReference",
-    "SecretsManagerReferenceOptions",
-    "SecretsManagerSecretStore",
-    "SecretsManagerSecretStoreProps",
-    "SsmParameterReference",
-    "SsmParameterReferenceOptions",
-    "SsmParameterSecretStore",
-    "SsmParameterSecretStoreProps",
-    "TxtRegistry",
-    "TxtRegistryOptions",
+    "AddChildPoolOptions",
+    "AddCidrToPoolOptions",
+    "AddCidrToPoolResult",
+    "AddressConfiguration",
+    "AddressConfigurationProps",
+    "AllocateCidrFromPoolOptions",
+    "CidrProvider",
+    "CustomerGateway",
+    "CustomerGatewayAttributes",
+    "CustomerGatewayConfigurationRemoteVpnEndpoint",
+    "CustomerGatewayProps",
+    "CustomerGatewayRemoteVpnEndpoint",
+    "FlowLog",
+    "FlowLogDataType",
+    "FlowLogDestination",
+    "FlowLogDestinationConfig",
+    "FlowLogField",
+    "FlowLogFileFormat",
+    "FlowLogFormat",
+    "FlowLogProps",
+    "FlowLogS3Options",
+    "IAddressConfiguration",
+    "ICidrProvider",
+    "ICustomerGateway",
+    "IIpam",
+    "IIpamAllocation",
+    "IIpamAllocationConfiguration",
+    "IIpamPool",
+    "IIpamPoolCidr",
+    "IIpamPoolCidrConfiguration",
+    "IIpamResourceDiscovery",
+    "IIpamResourceDiscoveryAssociation",
+    "IIpamScope",
+    "ILocalVpnEndpoint",
+    "ILogDestination",
+    "IRemoteVpnEndpoint",
+    "ITransitGateway",
+    "ITransitGatewayAttachment",
+    "ITransitGatewayPeeringAttachment",
+    "ITransitGatewayRoute",
+    "ITransitGatewayRouteTable",
+    "Ipam",
+    "IpamAllocation",
+    "IpamAllocationConfiguration",
+    "IpamAllocationOptions",
+    "IpamAllocationProps",
+    "IpamAttributes",
+    "IpamConsumer",
+    "IpamPool",
+    "IpamPoolCidr",
+    "IpamPoolCidrConfiguration",
+    "IpamPoolCidrProps",
+    "IpamPoolOptions",
+    "IpamPoolProps",
+    "IpamProps",
+    "IpamResourceDiscovery",
+    "IpamResourceDiscoveryAssociation",
+    "IpamResourceDiscoveryAssociationProps",
+    "IpamResourceDiscoveryAttributes",
+    "IpamResourceDiscoveryProps",
+    "IpamScope",
+    "IpamScopeAttributes",
+    "IpamScopeOptions",
+    "IpamScopeProps",
+    "Ipv4ConfigurationOptions",
+    "Ipv6ConfigurationOptions",
+    "LocalVpnEndpointConfiguration",
+    "NatProvider",
+    "NetmaskLengthOptions",
+    "PublicIpSource",
+    "RemoteVpnEndpointConfiguration",
+    "ResolvedIpamAllocationConfiguration",
+    "ResolvedIpamPoolCidrConfiguration",
+    "SharingOptions",
+    "TieredSubnets",
+    "TieredSubnetsOptions",
+    "TransitGateway",
+    "TransitGatewayAttachment",
+    "TransitGatewayAttachmentBase",
+    "TransitGatewayAttachmentProps",
+    "TransitGatewayAttachmentResource",
+    "TransitGatewayAttachmentResourceProps",
+    "TransitGatewayLocalVpnEndpoint",
+    "TransitGatewayNatProvider",
+    "TransitGatewayNatProviderOptions",
+    "TransitGatewayPeeringAttachment",
+    "TransitGatewayPeeringAttachmentImportAttributes",
+    "TransitGatewayPeeringAttachmentOptions",
+    "TransitGatewayPeeringAttachmentProps",
+    "TransitGatewayProps",
+    "TransitGatewayRoute",
+    "TransitGatewayRouteOptions",
+    "TransitGatewayRouteProps",
+    "TransitGatewayRouteTable",
+    "TransitGatewayRouteTableOptions",
+    "TransitGatewayRouteTableProps",
+    "TunnelOptions",
+    "VpcAttachmentOptions",
+    "VpnAttachmentOptions",
+    "VpnConnection",
+    "VpnConnectionLocalEndpoint",
+    "VpnConnectionProps",
+    "VpnConnectionRemoteEndpoint",
+    "VpnConnectionType",
+    "VpnGatewayLocalVpnEndpoint",
 ]
 
 publication.publish()
 
-def _typecheckingstub__f74f3540f9b92e5b04d00972307fd2234b5b3488c35a04325788dc39ab7af1c1(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__cd5beb9fcc270b7b94143a1da76f2e055d3a985146435bc15a04bde77d16af22(
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    create_namespace: typing.Optional[builtins.bool] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__83410ce825ec752c0effc192594680947acd69763ae265765f04ad25b86fed2c(
+def _typecheckingstub__8b557d5630889b3b826710341420be9ea32da521b6a064c2251649dc037dc337(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    create_namespace: typing.Optional[builtins.bool] = None,
-    namespace: typing.Optional[builtins.str] = None,
+    configuration: IIpamPoolCidrConfiguration,
+    allow_inline: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__136b7ffe7a51d2c8e1beb7845cc437b6f9c909db4c6852bf9306bb992440df64(
+def _typecheckingstub__f02f76e73f9cee1844c78b045ee1860b4da77cb2b3ea7f9d760139719e314877(
     *,
-    field_name: builtins.str,
-    value: builtins.str,
+    inline: builtins.bool,
+    cidr: typing.Optional[IIpamPoolCidr] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__47bd0514e52ab251753fed926ac3aec8ea7a2344e24eb13a2eeacbcf646482c3(
-    *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    service: builtins.str,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
+def _typecheckingstub__cd7caef254218d4ebf34f9b11023b49732aa598163f909134c5a7bb044eb20cd(
+    cidr: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__60e02c2df9c0996603c08992bffb8b230ed1d150d3db1a8f557f6056710b9fda(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
-    *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
-    load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    port: typing.Optional[jsii.Number] = None,
-    replicas: typing.Optional[jsii.Number] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subdomain: typing.Optional[builtins.str] = None,
-    tag: typing.Optional[builtins.str] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__12b210002dd74d3c4489f392f3891aa197db959127d48cfc0ab81774265531fb(
+    pool: IIpamPool,
+    netmask: jsii.Number,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__03259ca27e67ce6d4b989554c5fe17209a196689cf650ff94b81215ab7406124(
-    domain: _Domain_165656f2,
+def _typecheckingstub__35eab003d889c662b910b407f8e02c5f1e0c594802680266f3389251bf5ac9d3(
+    *,
+    customer_gateway_id: builtins.str,
+    bgp_asn: typing.Optional[jsii.Number] = None,
+    ip_address: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__cabc692f43b347b0dcc6dbe743c4a7fac3e1c95cc035ff3ff3ef2509fdef86f5(
+def _typecheckingstub__e250ab0ff20773956eb3b2131200a7ee56b455ba85d22729b69f588d369a8193(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    domain_discovery: typing.Optional[_DomainDiscovery_440eb9b9] = None,
-    load_balancer_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    port: typing.Optional[jsii.Number] = None,
-    replicas: typing.Optional[jsii.Number] = None,
-    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
-    subdomain: typing.Optional[builtins.str] = None,
-    tag: typing.Optional[builtins.str] = None,
+    ip_address: builtins.str,
+    bgp_asn: typing.Optional[jsii.Number] = None,
+    connection_type: typing.Optional[VpnConnectionType] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__91e43731ac6990c08b0792ace3a0c1b48a1f889b6e8d07aca71215174e81ac73(
-    size: _DataSize_d20aaece,
+def _typecheckingstub__685f60b23d7e8e561b55bc9dca121799b9d63919b8e78b372a1fa549c234455e(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
+    destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
+    flow_log_name: typing.Optional[builtins.str] = None,
+    log_format: typing.Optional[FlowLogFormat] = None,
+    max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
+    traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9124585821a9391bca778d97002afbc3198cbd561399fa87a8e71b45d6ce6eb5(
-    value: builtins.str,
+def _typecheckingstub__11b243acaaaa5840cda314f12b7b4d009805f9002ef9847296dedc4c734cfaa8(
+    *,
+    destination_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogDestinationType,
+    bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
+    destination_options: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
+    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
+    s3_path: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__30778af9523211391b3ca0fed378de136c18bf69752f8852717af5a49e4655da(
+def _typecheckingstub__52a7eb2a067a774b7223df31becb41f1517c9aa30eb3b326b26ad7504939a991(
     name: builtins.str,
+    type: FlowLogDataType,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5f7c8fd432fc4f5005a0f643a18e84adbdbe3cd99f8b0197a9c3b88356ab4c36(
-    *,
-    registry_type: builtins.str,
-    permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
-    properties: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
+def _typecheckingstub__186041c191f59ab5a16d388d89fb358a9ce5c7c993bd90eb9e6479e368341acd(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__575b91a9d80cdb1a92d59c32aa69e6b72bae0ee5d1b726d04016341d1d05ce2b(
-    *,
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__011095d32393e36e81237f11a84f5543e965a7ff361a20975a530a17197f4a8e(
+    *fields: FlowLogField,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__49513e201186ba37d9ef6756fce415cce3648eed2fa385f3e5f55eb6a5fa9de3(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
-    *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    secret_store: ISecretStore,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    secrets: typing.Optional[typing.Sequence[ISecretReference]] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+def _typecheckingstub__5cb1f7019aee739ea8276bab9a93a7e6f40b4ebf40d15497239b2c6b1676033e(
+    template: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__19eb3b7d91a4e74eaaed7fe7ee26f9301db18656d2c4d7d673df35310e1e67f9(
-    secret: ISecretReference,
+def _typecheckingstub__79cf487bf8fa03e8840d7c2097f578bf3849b50872d93bdad4cc33d93380f5cd(
+    field: FlowLogField,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9c48bcfa2d2f0d5e393569b187f9c8953494e5941b2210c23840aa29af16ef83(
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__d11fa008f8a05b0740f0561849e56b56d7a687389f3927a388801e0c2089baa9(
+def _typecheckingstub__ab60db00df2ad42cfdeb4bac9052956c6ceecbdc94e94e83e7a5b1a8d4db724f(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    secret_store: ISecretStore,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    refresh_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    secrets: typing.Optional[typing.Sequence[ISecretReference]] = None,
+    resource_type: _aws_cdk_aws_ec2_ceddda9d.FlowLogResourceType,
+    destination: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogDestination] = None,
+    flow_log_name: typing.Optional[builtins.str] = None,
+    log_format: typing.Optional[FlowLogFormat] = None,
+    max_aggregation_interval: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogMaxAggregationInterval] = None,
+    traffic_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.FlowLogTrafficType] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__92e0a4c21b4ba5a2e251aa667f38097598f22ba362cbd427dd404bbdc22ab5f6(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__7e005d34fc5ab0b60e83479b723ba4e2e86a135e05fd16b18daaac30743245ed(
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
-    create_namespace: typing.Optional[builtins.bool] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
+    file_format: typing.Optional[FlowLogFileFormat] = None,
+    hive_compatible_partitions: typing.Optional[builtins.bool] = None,
+    key_prefix: typing.Optional[builtins.str] = None,
+    per_hour_partition: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__90685b99b2a2f337bfa2d47df40412c9b581b614b6fbaa7d3c94b067a6d562f9(
+def _typecheckingstub__a1b636be2a744fe98f3e277a800df843bb1e2f86672d166ac7ef45b182fad912(
     id: builtins.str,
-    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
     *,
-    namespace: typing.Optional[builtins.str] = None,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bb968a0fa40a926483b03cb5417298b5375e8cd4b95be82c6d873ca8dc69a994(
-    id: builtins.str,
-    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-    *,
-    namespace: typing.Optional[builtins.str] = None,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
+def _typecheckingstub__1038342f468b756d95a5fa72e9acf7a439b03b68ab6d8fa6f1f066a4d21949f8(
+    resource_discovery: IIpamResourceDiscovery,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a77b0078ad516d66ca8ca0d633ac0257b13a89e52152799cdfab2d5f1bd3e906(
-    *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.Cluster,
-    create_namespace: typing.Optional[builtins.bool] = None,
-    namespace: typing.Optional[builtins.str] = None,
+def _typecheckingstub__dece55321285f291ec77410a702ac3c08fbcf7db95c03c5bf9bedf2291da114f(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__76dae8c2dfe10754d7c019d5c1c2151516afb99c60c1df33bb81b24d3b938dd3(
-    scope: _constructs_77d1e7e8.Construct,
+def _typecheckingstub__c7b9943cf34c897a8e2e801a7d2568d247995e02adfa9ebe1c8e9b9ff66f4b83(
     id: builtins.str,
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
-    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
-    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__b703c0764bfdf16eb126c71eab2089fc0d5d0baedeb889a2ab4b2d0a6b49f59d(
-    profile: _aws_cdk_aws_eks_ceddda9d.FargateProfile,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__441c970215922062a245380ac8d1e04123624212c517def39ade49d9091b4c23(
-    filter: IFluentBitFilterPlugin,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a329165d7991851e4ec8fd63a4b82083aef71de6826a3ef2e264518b24051f2b(
-    output: IFluentBitOutputPlugin,
+def _typecheckingstub__0a3cfc72aca71117a43f300844c4498cc57a52c74a03750c5d05c818a74afac5(
+    id: builtins.str,
+    *,
+    configuration: IIpamPoolCidrConfiguration,
+    allow_inline: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f61de38bcda89dc454156432b185bbdfe377f7811aa2270afad6e3f3d5d7e4fe(
-    parser: IFluentBitParserPlugin,
+def _typecheckingstub__bc151299648c50c942a10f8ea00d0fc83b8c79aff1210095bcbe955062e51fd8(
+    id: builtins.str,
+    *,
+    scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5d9fa1ba40c2be86a241bebc6f8b6cc03215924d98659a18e99df90fd7eef185(
-    *,
-    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
-    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
-    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
+def _typecheckingstub__bfbb670dc272cc6a46a2eb1688ca556b350e710de16c3d30873f13a34d57b284(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__331f0ef39a4852c171fb3378d45e752361c5aa7515c6965a4852b6f54a58f900(
+def _typecheckingstub__ce91fde6b672209b03c5936977bcee9bb0b1a59cde007a9e22596692c19cec8c(
+    id: builtins.str,
     *,
-    fargate_profiles: typing.Optional[typing.Sequence[_aws_cdk_aws_eks_ceddda9d.FargateProfile]] = None,
-    filters: typing.Optional[typing.Sequence[IFluentBitFilterPlugin]] = None,
-    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
-    outputs: typing.Optional[typing.Sequence[IFluentBitOutputPlugin]] = None,
-    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__004c6d6190020d8cdc3eea6ba900d6bb6b67d1b06e5b2c7a8650568795e29ce3(
-    match: FluentBitMatch,
-    *records: AppendedRecord,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1e4fc805a8f96657a4f0acdced48b0a0ff8f731cc5e58787975d1636d9bea432(
-    match: FluentBitMatch,
-    *fields: builtins.str,
+def _typecheckingstub__3afa737c1c12929060efb451b5661894860392d2a80d30e86753ead777130750(
+    ipam: IIpam,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ca125ae790631ee65913aa6e968ed7113cdb3174739710fcb3e049ee05e1225b(
-    match: FluentBitMatch,
+def _typecheckingstub__3a86136ad382579c871429e414991bd17165494c17b0539dc436d1f271594b37(
+    id: builtins.str,
     *,
-    key: builtins.str,
-    regex: builtins.str,
-    exclude: typing.Optional[builtins.bool] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__e62ff1da65acb39396b806ce64d2c933f7f3b043f0f4ab5b9bcfde68b282300e(
-    match: FluentBitMatch,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__b7921055d17cd6ec5863079beb06bda4bbc0aba18764be3ca76b587d53f6a90c(
-    match: FluentBitMatch,
-    nested_under: builtins.str,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__70f785929f2989cc94f847423b39a2b6cda43109191a9c78fc4a821025615e83(
-    match: FluentBitMatch,
-    *operations: ModifyOperation,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    parent_pool: typing.Optional[IIpamPool] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0c44cc88268e3e2218cb706dfe1efc0b47f7a1d76b49addf6866c4a59ff82f54(
-    match: FluentBitMatch,
-    nest_under: builtins.str,
-    *fields: builtins.str,
+def _typecheckingstub__5f7fbf7fd0e305a60cc72790e4c2e467542eeb749b6ca114948036c7e283f4e3(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__10af575b9dbec2cd8ea9604aee8e29ee517e60f747a39b4910b6f4da1f217b83(
-    match: FluentBitMatch,
-    key: builtins.str,
-    *parsers: IFluentBitParserPlugin,
+def _typecheckingstub__31e7dac1ec2cefa56a83155a4b3ff82206bfe5b1607d5af572c5d16cf98aba7a(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7771595b84c711392921d6ddf6f6d52281f9711dd09522a93a530883167a8e3c(
-    match: FluentBitMatch,
-    *rules: RewriteTagRule,
+def _typecheckingstub__f1c8cc16017de426ad6eb532d21e5db4c058f7a279485763c47026f54ff6b02a(
+    scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c398af7ef351b52ad40eb09a1a0fcc6ae44187a82c5709af8cc8ea2d361cb61e(
-    match: FluentBitMatch,
-    interval: _aws_cdk_ceddda9d.Duration,
-    rate: jsii.Number,
-    window: jsii.Number,
+def _typecheckingstub__3c530d4e033cb58d409cbdec91a29a99e796c6b5949a8fe0b776e9a57ebda677(
+    id: builtins.str,
+    *,
+    remote_endpoint: IRemoteVpnEndpoint,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    static_routes_only: typing.Optional[builtins.bool] = None,
+    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4a171efbee53101c625ce2956a002515e474ab45a4b74604ffee5889c1053dd3(
-    match: FluentBitMatch,
-    *fields: builtins.str,
+def _typecheckingstub__7e51602274287d74df7ba0b1c9462a003ef4081742f553f9fccc7d78f9e0f591(
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    *,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0a232fab3d929b1e9cdb75a64a4f3eec377e0983c1b4e4ffd68fc95cf216ee9d(
-    *,
-    match: typing.Optional[FluentBitMatch] = None,
+def _typecheckingstub__7b44f941842017d2d4c6c21860f08701108fc8a70636475b6b9ab6eb37332692(
+    cidr: builtins.str,
+    route_table: ITransitGatewayRouteTable,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0367bee62bb2658dda6a19b32e999c85a7a98303ad453009919555866534b235(
+def _typecheckingstub__6bcaae469a83ecd464cf6ee2fdec64932121a1d626847b4286e9b571c2738345(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    pattern: typing.Union[FluentBitGrepRegex, typing.Dict[builtins.str, typing.Any]],
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7d5213db46ae4f43816c9caa03cf901d34224d6f6abfb3d42513921dd5cdbb98(
-    *,
-    key: builtins.str,
-    regex: builtins.str,
-    exclude: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__f22237c1da869dfd24c6b3bd9591ee8f4bb8b24ac263036e6bad87d6f59f290f(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__491341e10d39ab453cf8cb9ce79aa79883683ad1bef71b12d50956da0005ed71(
+def _typecheckingstub__eb571f1f21cbfaf021fd1248ccdd35a0949e39d2400dcec2e3fe7eaac35304d4(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    annotations: typing.Optional[builtins.bool] = None,
-    buffer_size: typing.Optional[_DataSize_d20aaece] = None,
-    cache_use_docker_id: typing.Optional[builtins.bool] = None,
-    dns_retries: typing.Optional[jsii.Number] = None,
-    dns_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    dummy_meta: typing.Optional[builtins.bool] = None,
-    k8s_logging_exclude: typing.Optional[builtins.bool] = None,
-    k8s_logging_parser: typing.Optional[builtins.bool] = None,
-    keep_log: typing.Optional[builtins.bool] = None,
-    kube_ca_file: typing.Optional[builtins.str] = None,
-    kube_ca_path: typing.Optional[builtins.str] = None,
-    kubelet_host: typing.Optional[builtins.str] = None,
-    kubelet_port: typing.Optional[jsii.Number] = None,
-    kube_meta_cache_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    kube_meta_preload_cache_dir: typing.Optional[builtins.str] = None,
-    kube_tag_prefix: typing.Optional[builtins.str] = None,
-    kube_token_command: typing.Optional[builtins.str] = None,
-    kube_token_file: typing.Optional[builtins.str] = None,
-    kube_token_ttl: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    kube_url: typing.Optional[builtins.str] = None,
-    labels: typing.Optional[builtins.bool] = None,
-    merge_log: typing.Optional[builtins.bool] = None,
-    merge_log_key: typing.Optional[builtins.str] = None,
-    merge_log_trim: typing.Optional[builtins.bool] = None,
-    merge_parser: typing.Optional[builtins.str] = None,
-    regex_parser: typing.Optional[builtins.str] = None,
-    tls_debug: typing.Optional[jsii.Number] = None,
-    tls_verify: typing.Optional[builtins.bool] = None,
-    use_journal: typing.Optional[builtins.bool] = None,
-    use_kubelet: typing.Optional[builtins.bool] = None,
+    ipam_arn: typing.Optional[builtins.str] = None,
+    ipam_id: typing.Optional[builtins.str] = None,
+    private_default_scope: typing.Optional[IIpamScope] = None,
+    public_default_scope: typing.Optional[IIpamScope] = None,
+    scope_count: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9e5f787f6c53b83309ad3224ae7cbd397dc281f463e865210fadeede93199ea7(
-    log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
+def _typecheckingstub__5f7d3d1a0e00906b5868c50d6ef8fecef67fbe25667614fcde04f846719061e3(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__67456e5d91f4ffd1bec1ee1e4391d0f4f5ae2b0b2d8f9151cd8a758ce8565c1d(
-    name: builtins.str,
-    create: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__b41f4e5b2750bf68e1fe11144249a54f1b8abc0145d51b5c5a5e6306100fb06e(
+    region: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bf36bc82a5087381a1e00eedb991062da3fb86e1b1b2dc82f40a25d98c830a03(
-    log_stream: _aws_cdk_aws_logs_ceddda9d.ILogStream,
+def _typecheckingstub__102b40df4c003fe21fa6f5c3eccca856cd54d3476ddd3fef7d50ecdb6f08218e(
+    id: builtins.str,
+    *,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d2d24583ddfcc8876ab533165130d5b3607247d011b36995e13163c253b6e718(
-    name: builtins.str,
+def _typecheckingstub__072bf43c0c6efdfd93d9c5feb21872c2bf837b58a9ff45374b138a5823245daf(
+    resource_discovery: IIpamResourceDiscovery,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f2176a9e11225cfa29051ee0166fd6151266cf8a3753905e128f0cb83df80178(
-    prefix: builtins.str,
+def _typecheckingstub__62b34aa15d811a8c1c7a6291d668364a570669c52080fee054ac7fca374fc959(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    ipam_pool: IIpamPool,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__42632d6e6d5ce15103cf294740e757e5f3a4db926970743e6ab114f398dea1d3(
-    pattern: builtins.str,
+def _typecheckingstub__90a5f1bf2b9d90ffe699d47216484dc1d6dc0c36521c06f33dd356324546157d(
+    cidr: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__03245bf7bb94a21d38ca01a84e1768b7dae976c76ea7c6d0c9ea4c23cb4b5063(
-    pattern: builtins.str,
+def _typecheckingstub__7f5ea0eb8eb95fb7b3817d0fd0189eb58694dac360bce4da34bba03e52edebe7(
+    length: jsii.Number,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__477fb867f089070fa5d35c4c569a7ef1cc68825359200bc94957a309491b389b(
+def _typecheckingstub__4d460bd7922658dcf43edece504384376cb5f442b4bff65f958ac6c2836ac293(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    conditions: typing.Optional[typing.Sequence[ModifyCondition]] = None,
-    operations: typing.Optional[typing.Sequence[ModifyOperation]] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__6baa844d691b01fb5358a6c2b04f16a51e81d297fb8c56fa7ba4e803056db09a(
+def _typecheckingstub__a07b8bbd3bc9b799c207889e9985ac227583d9101f33f1dcb0b174d27c62a6b7(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    operation: NestFilterOperation,
-    add_prefix: typing.Optional[builtins.str] = None,
-    remove_prefix: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
+    ipam_pool: IIpamPool,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dab26f9f432f54b43673f47359cc7da960e6d82adb6012e75be901a3f3b3ac09(
-    match: FluentBitMatch,
-    log_group: _aws_cdk_aws_logs_ceddda9d.ILogGroup,
+def _typecheckingstub__4511450bed75a1ae15c3778c31cc7035b506e40a7c9cf91f81050dd2fc0ac150(
+    *,
+    ipam_arn: typing.Optional[builtins.str] = None,
+    ipam_id: typing.Optional[builtins.str] = None,
+    private_default_scope: typing.Optional[IIpamScope] = None,
+    public_default_scope: typing.Optional[IIpamScope] = None,
+    scope_count: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__16fe7d93a8820fa1d151349582f6a63b13f332f70c5c98bb436e7cf988d6b020(
-    match: FluentBitMatch,
-    stream: _aws_cdk_aws_kinesis_ceddda9d.IStream,
+def _typecheckingstub__286c12a5ef14167a5ceeb4a61b036f35ae0e15cf700b54c3e1867aded79c8910(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__af6295291f38a712113e95369264580c73772913ba57790d0e3eb2c79bca9eec(
-    match: FluentBitMatch,
-    delivery_stream: _IDeliveryStream_cf5feed7,
+def _typecheckingstub__9c1663d7016f62377ea107cf058e68f823c75f65351209f4f0aba2cdeee51aee(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    ipam_scope: IIpamScope,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    parent_pool: typing.Optional[IIpamPool] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4131fc278e940c264cc3a359804bb213cef52ec4dcc6bc45de6275ff5acb3536(
-    match: FluentBitMatch,
-    domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
+def _typecheckingstub__a7567b7c123b03ca4fe677156bcf8da88b7b533dddd10988046466f920ffea74(
+    id: builtins.str,
+    *,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__09888332ffdc8a6865748655bd177159b31a6abfa867b1b8b5d60fdeea5c96b6(
+def _typecheckingstub__4075a35e6e1610736b7c269bed0b1519cb48461c587fa68f672112aa62765952(
+    id: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
+    configuration: IIpamPoolCidrConfiguration,
+    allow_inline: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d2a5c948730ec0b02dbff24e612c1f1729a3fb4d2997fd98def1d1a317ab67ec(
-    name: builtins.str,
+def _typecheckingstub__7c9706b72709e9a6ba823b8fe9a6152930be0d3c32bba2b5f7fe73f06ffa76fc(
+    key: builtins.str,
+    value: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d8419f19685306cef1bb083add90eeae71ca31d26fdf6ad0a5bef68d4d1ae022(
-    name: builtins.str,
+def _typecheckingstub__cd97e16b1589e82ca19d21ff1c68bd2cfba34b2982db96fd23e8b70025d0cd21(
+    id: builtins.str,
+    *,
+    scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3d4d3c46b533404bcbeba504ee2681b222c47d467e4716d8970b404167f926e8(
-    name: builtins.str,
+def _typecheckingstub__74b6a3269ad2cfdb786d1a0a8ba349a2556f673ced579f7dd6edc5d90e2338ae(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    configuration: IIpamPoolCidrConfiguration,
+    ipam_pool: IIpamPool,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__082be9a38cb65fcbef035dc44eb355e76f5cc06d81a262cf08cf37078bc2d04c(
-    name: builtins.str,
-    regex: builtins.str,
+def _typecheckingstub__dc961c0fc15b09f22e1e3c627d658e6e36ab62bae6dc22cc4e0499a1937fd464(
+    cidr: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b68a9a8afdab443320e980cd8ef61a4610a316eed4b87369d206262bcf945336(
-    *,
-    match: typing.Optional[FluentBitMatch] = None,
-    key_name: builtins.str,
-    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
-    preserve_key: typing.Optional[builtins.bool] = None,
-    reserve_data: typing.Optional[builtins.bool] = None,
+def _typecheckingstub__fbb2dcf98ee84cc749c81f534e8dd19ef41782955e44c73207733837516df3f6(
+    length: jsii.Number,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d3a289167b1afa2aa5ae024881a5a0f791281e90f1ad71f4febecc1378f28d92(
+def _typecheckingstub__664dfe67992b369ef692d99523e907081aeb4ace3eff5712a089f8c1084f86a1(
     *,
-    name: builtins.str,
-    plugin_type: FluentBitPluginType,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    configuration: IIpamPoolCidrConfiguration,
+    ipam_pool: IIpamPool,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__ba63858e40aa4f37f54576c8c109ce4f32cb4535c6c5d186705c639a22214428(
+def _typecheckingstub__061f4cc380e680b0f6b91b8e790f5e28364348b69f9e14707149af8856a32fb7(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    allow: typing.Optional[typing.Sequence[builtins.str]] = None,
-    records: typing.Optional[typing.Sequence[typing.Union[AppendedRecord, typing.Dict[builtins.str, typing.Any]]]] = None,
-    remove: typing.Optional[typing.Sequence[builtins.str]] = None,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    parent_pool: typing.Optional[IIpamPool] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__62537da56305da6b0bcb7286caa362cac36f533c837efd41b4f2abc1df3bcf11(
+def _typecheckingstub__ea5a2693388a6b25adff4e7abd9638424194ce86e7dfcc7a2334fde02f2e69d2(
     *,
-    regex: builtins.str,
-    skip_empty_values: typing.Optional[builtins.bool] = None,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    parent_pool: typing.Optional[IIpamPool] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    ipam_scope: IIpamScope,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__815f89c54e571d56f00edc236c155a23cfeab33faa1efebcf6c784af74f59f04(
+def _typecheckingstub__10b81e5f1145574ea39d7eb21e272f73536f77bb1c6c467b098554d1a8d77cb6(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    emitter_mem_buf_limit: typing.Optional[_DataSize_d20aaece] = None,
-    emitter_name: typing.Optional[builtins.str] = None,
-    emitter_storage_type: typing.Optional[EmitterStorageType] = None,
-    rules: typing.Optional[typing.Sequence[typing.Union[RewriteTagRule, typing.Dict[builtins.str, typing.Any]]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a026237a3f40e00499d4fc0204f075b1145cde7bac0b7942bed2173ce310bd9a(
+def _typecheckingstub__71027560fa4c32a65f8c9a42c4e88c7d1f32a1b5fa58598aad99b6b612744f41(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
-    print_status: typing.Optional[builtins.bool] = None,
-    rate: typing.Optional[jsii.Number] = None,
-    window: typing.Optional[jsii.Number] = None,
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__16439430780263e49cc504798dfdedbab3bf51542be52890ad92373b0d4bfc91(
+def _typecheckingstub__ea8e2af6623ebfc6fede9041108985a0e1f4bc7a068690c15426bd2051ff73d9(
     scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_resource_discovery_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0e96056912a504aeb9a5f0a9afa10c098c92a82a5580780a4d2bf3539c8205aa(
+def _typecheckingstub__57b4066a1554d13ec3de7912e54640267313c350bae201bd366576707917edbc(
     scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    is_default: typing.Optional[builtins.bool] = None,
+    owner_id: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    resource_discovery_arn: typing.Optional[builtins.str] = None,
+    resource_discovery_id: typing.Optional[builtins.str] = None,
+    state: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__acebfc903b3b22f8c30fae481f53b07f40398b43583763b7493f53134e21c720(
+def _typecheckingstub__6e99343677a106a86300ba3a771df4a8f868464d143c4fb1acd63f95313e2276(
     scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_resource_discovery_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b5737e6839ba050eaf2ff95b5004c79062ffa98eab8e21826190de020d396648(
+def _typecheckingstub__e687a9c82d39b4816bcb8181beeb34fa78ade11ccb9883598d96a6fabe978893(
+    id: builtins.str,
     *,
-    nested_under: builtins.str,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__a87c7279b95393fe143c70bd0eb03afa5a2eeadbb4e0652815e47bad81d78004(
-    regex: builtins.str,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__9c016d68c98f4a007d811c010a657245a7cb4e35e28d68271b47271fb2e7fe04(
-    key: builtins.str,
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__26a4516fb03cee3ff4649a09c795cfa145f69ca27b37c8efd99e5b120be43804(
-    key: builtins.str,
+def _typecheckingstub__7899a22c8f823f15fea279d534d9b1124d0e6dc669ea76eca0f521dfe2fd0e98(
+    region: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__fbd75e354fc9a0d46f639f296e1b4ffe3da299a7891b0381081ad9cc7bdf6631(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__711ba854c1e0329bf19749b97e1ccf49b8cf344550e5bf80368d997cad106847(
+    ipam: IIpam,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3c04874c06d71c34c233c16eca0c4b65f1a6a36f0bb05dfd69dfa0da05ffbec4(
-    key: builtins.str,
-    value: builtins.str,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__ff4b63c6ad876a769c352fa5b53d1ab44a9e4a503ccd829e1029918eb28ef3bd(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__501f8b5a36c021031daa8db977a3a96bb8f5e6f6f3800fd94f093a381bcf80ca(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    ipam: IIpam,
+    ipam_resource_discovery: IIpamResourceDiscovery,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__59be3f65de5a631f24700f05f7753e529ad70a4cb137fd5d62383abdd02bf10d(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__cdc08bda216ca133f887348a17c9ffedb62d0f71c106e0553aefe0df4a1f924d(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    ipam: IIpam,
+    ipam_resource_discovery: IIpamResourceDiscovery,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b9f14e749593d361f880d1301a695fbd3315adff4d215a08b2867f766b530f6f(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__bfe8ddca2aa37f07665bc994257efce3c571bea8f2042fba22c0e32f876e6be4(
+    *,
+    is_default: typing.Optional[builtins.bool] = None,
+    owner_id: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    resource_discovery_arn: typing.Optional[builtins.str] = None,
+    resource_discovery_id: typing.Optional[builtins.str] = None,
+    state: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__3644ef417d81a715203823624e932831fa6fab3e38086a6ff12bb88a577c0d05(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__51b5341103db45e2ba709accab3d05ff60b89051d4b3ce8eca228f2b3e64ebd0(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    description: typing.Optional[builtins.str] = None,
+    regions: typing.Optional[typing.Sequence[builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__786ab8e1494a413b4e18469e55a12839dde421149e6acea64e8a335582aa46f5(
-    regex: builtins.str,
+def _typecheckingstub__9a546cb546e1edf13cb28bf17b9775fc767dbfdc928eef8397187ce0b17dfc5b(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    ipam: IIpam,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c6cda0ccdf12bd0d94a391aeee20b8afc334828d46c7557423da8fddc68c8a5b(
-    condition: builtins.str,
-    args: typing.Sequence[builtins.str],
+def _typecheckingstub__7f98969dee71b840db4c335d87294497a204a67e6e48b2dbbb159311385c076a(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_scope_arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__88d1f6674bbdb9c882a91bf4bd456ed2e3b77d8ede0eda0335a9711e90ef10d8(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__eb421be29901d65e6749e6323366a4f5af5dfcc7d300913711cc9ee381276a94(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    ipam: typing.Optional[IIpam] = None,
+    ipam_scope_arn: typing.Optional[builtins.str] = None,
+    ipam_scope_id: typing.Optional[builtins.str] = None,
+    is_default: typing.Optional[builtins.bool] = None,
+    pool_count: typing.Optional[jsii.Number] = None,
+    scope_type: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__509195f56adc1008582dfdd1ced4b6aae5a09a204f9b120954616dbe9255a6a5(
-    original_key: builtins.str,
-    new_key: builtins.str,
+def _typecheckingstub__2dbab482810f62dc9995dde4f7df63db48fea271cb75c5366412a8b2520369b5(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    ipam_scope_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4252ab4af15f45596deb41aecff5cdf63193455fcfb6a11f50e531ae913ddc19(
-    original_key: builtins.str,
-    new_key: builtins.str,
+def _typecheckingstub__d12727c7e1919d4e36b715bbc9350697e6c18a46226953e5ecc1e34d98e666b6(
+    id: builtins.str,
+    *,
+    address_configuration: typing.Optional[AddressConfiguration] = None,
+    auto_import: typing.Optional[builtins.bool] = None,
+    consumer: typing.Optional[IpamConsumer] = None,
+    description: typing.Optional[builtins.str] = None,
+    locale: typing.Optional[builtins.str] = None,
+    name: typing.Optional[builtins.str] = None,
+    parent_pool: typing.Optional[IIpamPool] = None,
+    provisioned_cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
+    public_ip_source: typing.Optional[PublicIpSource] = None,
+    tag_restrictions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d143c72f0b1248ef3c465526d5a4bec246e11ddc44d1e7ffb9cd998bfd89a980(
-    original_key: builtins.str,
-    renamed_key: builtins.str,
+def _typecheckingstub__fa734344faca5c5ba3d617d94e6e6edb0a25134e0ec500d1a0f1583821b486ea(
+    *,
+    ipam: typing.Optional[IIpam] = None,
+    ipam_scope_arn: typing.Optional[builtins.str] = None,
+    ipam_scope_id: typing.Optional[builtins.str] = None,
+    is_default: typing.Optional[builtins.bool] = None,
+    pool_count: typing.Optional[jsii.Number] = None,
+    scope_type: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__58f39ecf984b31b6d9c63ea24ccc57cdf4154eb2c667a5e4b98bf4f0117cbe7f(
-    key: builtins.str,
+def _typecheckingstub__bd70c16717441fc94ebfa82eec86afb658add62cd41adff91da0ff31fde6f35a(
+    *,
+    description: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__21dd6a80198a6efcdd40eb3aafec20cfecfde8f707999ac8ded417642e87f43f(
-    key: builtins.str,
+def _typecheckingstub__2e5cd89563bee24b90643dbcc9bc44c2859951f5fe446c27b0edaed36160fa0b(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    description: typing.Optional[builtins.str] = None,
+    ipam: IIpam,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2d24729666ca872450b6aefe87e852b867ecabcb6e378292249754f4c529a432(
-    operation: builtins.str,
-    args: typing.Sequence[builtins.str],
+def _typecheckingstub__c283c95ccb48c40fb03d7fffd4f63ce7927ef657d47052d65ed9aa32cbd6609a(
+    *,
+    transit_gateway_id: typing.Optional[builtins.str] = None,
+    vpn_gateway_id: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d0548969ac288015caf3702a3018bc6e8a9967a958e5278991beb6b8382f6fc8(
-    key: builtins.str,
+def _typecheckingstub__5c24e074cb6c4710f3d276f35c8e07673e45a6607185bf49bf9fa23b44a6edbd(
+    *,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+    max_netmask_length: typing.Optional[jsii.Number] = None,
+    min_netmask_length: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__bd9fed6d2afdca2a8d61c87b02ec06a5728541f28c7352f673e92afe99a5efcd(
-    regex: builtins.str,
+def _typecheckingstub__fb48b402397208864dcc706e2324e2d924048520c76c7003a49c6ef760e2d942(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a06eaf6be7e3ecf8c20d87aa164edc3b0351d095aa8d571d241a99dfae13e153(
-    key: builtins.str,
+def _typecheckingstub__8914f39fbdc8cc3e17d3f0de803ae8f59bb0822173529944b495b0fe17106662(
+    *,
+    customer_gateway_asn: jsii.Number,
+    customer_gateway_id: builtins.str,
+    customer_gateway_ip: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4fada9b7497030c549640821afc49c367a7e9f8f75e21c42fc11b152b1655772(
-    original_key: builtins.str,
-    renamed_key: builtins.str,
+def _typecheckingstub__d6a6fb9ff8ed88515dc74aa71837868e0d16d8ef2ac4a3a46e432a333f40e9d0(
+    *,
+    cidr: typing.Optional[builtins.str] = None,
+    netmask_length: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2a30ee29a1bf209f7c351625daebd78e2a284fc57bc3fa2bc6d0fb94a0d6032f(
-    key: builtins.str,
-    value: builtins.str,
+def _typecheckingstub__f937d2844c2174b9db397ff6d5bf4089b68ef2d9ee3c31b6fae8baf52964476b(
+    *,
+    cidr: typing.Optional[builtins.str] = None,
+    netmask_length: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__fd3dc6435c8d865e4f7520bd4058b3d18b2d20bc9036da2f79a101b7da1409ac(
+def _typecheckingstub__5d7430c10280f3e429f967b91e374da316928ba959b852656888cb4465f871ab(
     *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
+    allow_external_principals: typing.Optional[builtins.bool] = None,
+    auto_discover_accounts: typing.Optional[builtins.bool] = None,
+    principals: typing.Optional[typing.Sequence[_ISharedPrincipal_9cde791b]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b5a146c9ddfcbd766c4313db4ff21f80ccb81d8144313200dfa63dd1bb1ff770(
+def _typecheckingstub__0ebcc1ff7b7a99559a7a9d7feb7af82f8670e1cbdb892fd154081f69de879b67(
     *,
-    nest_under: builtins.str,
-    wildcards: typing.Sequence[builtins.str],
+    provider: ICidrProvider,
+    tier_mask: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4b8fe7eff14cfd09dcf3795cb57c69d832abf797e1e50720b10706a28cf1e816(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__66b0aca7557ca99e67ff904b7cb9edf704abd3cf24b45ecad18d9ccffdb7fcdc(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    amazon_side_asn: typing.Optional[jsii.Number] = None,
+    auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
+    cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
+    default_route_table_association: typing.Optional[builtins.bool] = None,
+    default_route_table_id: typing.Optional[builtins.str] = None,
+    default_route_table_propagation: typing.Optional[builtins.bool] = None,
+    description: typing.Optional[builtins.str] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    multicast_support: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    vpn_ecmp_support: typing.Optional[builtins.bool] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d4d24a390d9eb03a06583cbc6d261f3d8de476409210bcdd7f51d4e1476eeaf4(
-    size: _DataSize_d20aaece,
+def _typecheckingstub__46c3cc263035d23bc511197c75afb01d4a672fd46f5af176fbea6a400bccd00b(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    transit_gateway_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f02160f33c5993a4b0add2859c5aaed60beda3ddc55734f5fb49997c73f69b93(
-    value: builtins.str,
+def _typecheckingstub__2efd1666acd64cb987a354787ffd07add5920ed5de7e64ad3a01aa00619b7310(
+    cidr: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7f740f5f0bbca2b649fceb0e355052b591878a5d830606365cce99d8b088caac(
-    name: builtins.str,
+def _typecheckingstub__9989ffc3141ccddce9a6e8246aa4b31bd76f3ad0a11bbc1cbee86d607e50200d(
+    id: builtins.str,
+    *,
+    remote_endpoint: IRemoteVpnEndpoint,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    static_routes_only: typing.Optional[builtins.bool] = None,
+    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c82e94df4496e54b2a8815cc2ee59fcd040f76e2dcc14bb09c3f2fc10a316803(
+def _typecheckingstub__3fca635a725c4277e8db84123074663ecf20e88af86d11cb8f03c6390d8b7bc8(
+    peer: ITransitGateway,
     *,
-    config_file: builtins.str,
-    parsers: typing.Optional[typing.Sequence[IFluentBitParserPlugin]] = None,
-    permissions: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
+    name: typing.Optional[builtins.str] = None,
+    peer_account_id: typing.Optional[builtins.str] = None,
+    peer_region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__10d3a53f3145b3b27a3099c9f07d903492e56e8258545b4251a8bc9b20c63556(
+def _typecheckingstub__ac3f5d6f3de4328a56c1673d48d7168afe72b9b6c52725fb46ee3d5121211524(
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
     *,
-    keep: builtins.bool,
-    key: builtins.str,
-    new_tag: builtins.str,
-    regex: builtins.str,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__25ed19f0f43971dfc8f3ac2b02af3d6b57e81e4bf8f903ca7a9a94030416e6df(
+def _typecheckingstub__b49d47ed81c7ffb2a1650ef26c6a7262dbfbe5b02d6a33f4521aaba40facd96b(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    api_retries: typing.Optional[jsii.Number] = None,
-    batch_change_size: typing.Optional[jsii.Number] = None,
-    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-    evaluate_target_health: typing.Optional[builtins.bool] = None,
-    log_format: typing.Optional[ExternalDnsLogFormat] = None,
-    log_level: typing.Optional[ExternalDnsLogLevel] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    prefer_cname: typing.Optional[builtins.bool] = None,
-    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-    replica_count: typing.Optional[jsii.Number] = None,
-    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-    zone_type: typing.Optional[ExternalDnsZoneType] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__b366d288dd32fbd3b7303ac861a4b96ff1f42c49b0c512768f7acdc1ace18cb1(
-    domain: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__66071158131361758043670975aa8966426ce28d558d5a62b92defe0a754f8cb(
-    *,
-    api_retries: typing.Optional[jsii.Number] = None,
-    batch_change_size: typing.Optional[jsii.Number] = None,
-    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-    evaluate_target_health: typing.Optional[builtins.bool] = None,
-    log_format: typing.Optional[ExternalDnsLogFormat] = None,
-    log_level: typing.Optional[ExternalDnsLogLevel] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    prefer_cname: typing.Optional[builtins.bool] = None,
-    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-    region: typing.Optional[builtins.str] = None,
-    replica_count: typing.Optional[jsii.Number] = None,
-    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-    zone_type: typing.Optional[ExternalDnsZoneType] = None,
+def _typecheckingstub__3c4b8aae9fc7113caa263f0a78c3a90cd7457571433a27e89da36b0ae99fc4c6(
+    cidr: builtins.str,
+    route_table: ITransitGatewayRouteTable,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__599f1713ffc48e89808216535a31c01bf2871a0c4778c26680cb34a48861c9ff(
+def _typecheckingstub__06c53aa420590eceea4fb9b075681a4977d93106ad928386f59f565ada883d5b(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
+    transit_gateway: ITransitGateway,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    appliance_mode_support: typing.Optional[builtins.bool] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    ipv6_support: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    api_retries: typing.Optional[jsii.Number] = None,
-    batch_change_size: typing.Optional[jsii.Number] = None,
-    domain_filter: typing.Optional[typing.Sequence[builtins.str]] = None,
-    evaluate_target_health: typing.Optional[builtins.bool] = None,
-    log_format: typing.Optional[ExternalDnsLogFormat] = None,
-    log_level: typing.Optional[ExternalDnsLogLevel] = None,
-    namespace: typing.Optional[builtins.str] = None,
-    prefer_cname: typing.Optional[builtins.bool] = None,
-    record_ownership_registry: typing.Optional[IExternalDnsRegistry] = None,
-    replica_count: typing.Optional[jsii.Number] = None,
-    sync_policy: typing.Optional[ExternalDnsSyncPolicy] = None,
-    zone_tags: typing.Optional[typing.Sequence[typing.Union[ExternalDnsZoneTag, typing.Dict[builtins.str, typing.Any]]]] = None,
-    zone_type: typing.Optional[ExternalDnsZoneType] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__85958058f60b5349b6efc3cb16e252dae2854865cf49f70b0877c64d7c4bf0dd(
-    *,
-    kubernetes_key: builtins.str,
-    metadata_policy: typing.Optional[MetadataPolicy] = None,
-    remote_key: typing.Optional[builtins.str] = None,
+def _typecheckingstub__d9616ce11448deda7c7f7a6abcc3dc7343fd9d23bf7197f988d750a4ed8ab7b9(
+    val: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4dc26d0199f1602801b856583653a8b0d62418efb64456ef381f7d916080559e(
-    *,
-    remote_ref: builtins.str,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__c496d6306c81ceef9b7062404bcf66ea260c45a38d3b69dc2f1f0a90fd9af9d2(
-    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__d70f039a06515082a5c4a0a4ba2130f884b4355bae0292328fb6429f6569cd96(
-    _scope: _constructs_77d1e7e8.IConstruct,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__64d4869a39ffca99e3f183351ee069c38191bab52dbb76ac1d38c8a6a23da30b(
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__c06248919a788c055f92881d2ef760cb61263eb20ab5280e286e3f0705f184a0(
+def _typecheckingstub__3d1c15189bbc90871ac0f1cb7928d7a06dc7a543bed65a3917a78189021d8767(
     *,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    transit_gateway: ITransitGateway,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    appliance_mode_support: typing.Optional[builtins.bool] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    ipv6_support: typing.Optional[builtins.bool] = None,
     name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__be97b8cc9c656627b57f3db1afef2a495b5f9ef0693be3b77dd2ab818c7a14d2(
-    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+def _typecheckingstub__085d2039b0a4b4caf19e1943608efeb5e97be1be7d732ad9e6c87845449f8c0e(
+    transit_gateway: ITransitGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7147e379832a8ca243add61c65fb60f7361f398799b43de2302e5a36758d1417(
+def _typecheckingstub__1649477704b8d5959bab11d00a58a0814e904ca0755f79fc92c902b7548831e8(
     _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__85f36849fed8daf98c94ff71f819a22287651f50ad8ac9fbde185a225ecf3d48(
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
+def _typecheckingstub__2ce5b6c12f42e572c0fd8116f08202bd45321782d0dface0d78758e8ae4afce0(
+    subnet: _aws_cdk_aws_ec2_ceddda9d.PrivateSubnet,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__34a803d3f05acbd46634594fba4d5545e3823b2171c2f1104618a9a68b51217a(
+def _typecheckingstub__3d866260e3cfdb20c411a4b77ce2ef5ed9046a68ea0356988681824395af2b48(
     *,
-    account: typing.Optional[builtins.str] = None,
-    environment_from_arn: typing.Optional[builtins.str] = None,
-    physical_name: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
+    transit_gateway: ITransitGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__105e23602b6d46260f139f3822144dac2ba3d98f3a079c87534a0c62c41eb507(
-    scope: _constructs_77d1e7e8.IConstruct,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__49d222934bd8c2c391090725600916ef04457ba131b293ef18b5254a232b8e55(
-    *,
-    owner_id: typing.Optional[builtins.str] = None,
-    prefix: typing.Optional[builtins.str] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__a5db7e3c7776867e619b3b5a59436e82e10ef7dd279ce473dba2df2bc999988b(
+def _typecheckingstub__094bd3c738b0a006e2a59600942e6cb57ce41b066d2acabef2f32729f9b6c14c(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    service: builtins.str,
+    local_transit_gateway: ITransitGateway,
+    peer_transit_gateway: ITransitGateway,
     name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
+    peer_account_id: typing.Optional[builtins.str] = None,
+    peer_region: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b365e8ec462c9d5a06a032056dcf37739fad6ac73b424fbd4e54e70dd68eca9d(
+def _typecheckingstub__d64bc0ce43e9c832901d2f4073f54276e12b588a41c623026825482bf1d43c63(
     scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0a6ddb803ae38cffafb281e286ceb82c9d46f01f71cc1c19883463d5671ffb62(
-    *,
-    match: typing.Optional[FluentBitMatch] = None,
-    auto_create_group: typing.Optional[builtins.bool] = None,
-    auto_retry_requests: typing.Optional[builtins.bool] = None,
-    endpoint: typing.Optional[builtins.str] = None,
-    log_format: typing.Optional[builtins.str] = None,
-    log_group: typing.Optional[FluentBitLogGroupOutput] = None,
-    log_group_template: typing.Optional[builtins.str] = None,
-    log_key: typing.Optional[builtins.str] = None,
-    log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
-    log_stream: typing.Optional[FluentBitLogStreamOutput] = None,
-    log_stream_template: typing.Optional[builtins.str] = None,
-    metric_dimensions: typing.Optional[typing.Sequence[builtins.str]] = None,
-    metric_namespace: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    sts_endpoint: typing.Optional[builtins.str] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__d15707b98b30fc02a4da2bf5ff3f6fab3135470fb1fbfa8644ad8ebe83173635(
+def _typecheckingstub__9b9ddfaf131e6a5091a636a0dad2dd2579ae4140b68c99fe5fee2e2506d45105(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    host: builtins.str,
-    aws_auth: typing.Optional[builtins.bool] = None,
-    aws_external_id: typing.Optional[builtins.str] = None,
-    aws_region: typing.Optional[builtins.str] = None,
-    aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    aws_sts_endpoint: typing.Optional[builtins.str] = None,
-    buffer_size: typing.Optional[ElasticsearchOutputBufferSize] = None,
-    cloud_auth: typing.Optional[builtins.str] = None,
-    cloud_id: typing.Optional[builtins.str] = None,
-    compress: typing.Optional[ElasticsearchCompressionFormat] = None,
-    current_time_index: typing.Optional[builtins.bool] = None,
-    generate_id: typing.Optional[builtins.bool] = None,
-    http_passwd: typing.Optional[builtins.str] = None,
-    http_user: typing.Optional[builtins.str] = None,
-    id_key: typing.Optional[builtins.str] = None,
-    include_tag_key: typing.Optional[builtins.bool] = None,
-    index: typing.Optional[builtins.str] = None,
-    logstash_date_format: typing.Optional[builtins.str] = None,
-    logstash_format: typing.Optional[builtins.bool] = None,
-    logstash_prefix: typing.Optional[builtins.str] = None,
-    logstash_prefix_key: typing.Optional[builtins.str] = None,
-    path: typing.Optional[builtins.str] = None,
-    pipeline: typing.Optional[builtins.str] = None,
-    port: typing.Optional[jsii.Number] = None,
-    replace_dots: typing.Optional[builtins.bool] = None,
-    suppress_type_name: typing.Optional[builtins.bool] = None,
-    tag_key: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    time_key_format: typing.Optional[builtins.str] = None,
-    time_key_nanos: typing.Optional[builtins.bool] = None,
-    trace_error: typing.Optional[builtins.bool] = None,
-    trace_output: typing.Optional[builtins.bool] = None,
-    type: typing.Optional[builtins.str] = None,
-    workers: typing.Optional[jsii.Number] = None,
-    write_operation: typing.Optional[builtins.str] = None,
+    arn: typing.Optional[builtins.str] = None,
+    attachment_id: typing.Optional[builtins.str] = None,
+    creation_time: typing.Optional[builtins.str] = None,
+    state: typing.Optional[builtins.str] = None,
+    status: typing.Optional[builtins.str] = None,
+    status_code: typing.Optional[builtins.str] = None,
+    status_message: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__676b11880e42853f892c52495c93ae1bf187c9bb63de443fc1705142de091362(
-    *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__83b0e4d7b9e83a0ce016f523fc9afe715ef0070f7415a4f5d350b20f68c2e63d(
-    *,
-    match: typing.Optional[FluentBitMatch] = None,
-    auto_retry_requests: typing.Optional[builtins.bool] = None,
-    compression: typing.Optional[KinesisFirehoseCompressionFormat] = None,
-    delivery_stream: typing.Optional[_IDeliveryStream_cf5feed7] = None,
-    endpoint: typing.Optional[builtins.str] = None,
-    log_key: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    sts_endpoint: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    time_key_format: typing.Optional[builtins.str] = None,
+def _typecheckingstub__fe35553be2f81ae71d207839c426c22b6542d57d2604a744dec33a748b8631f6(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    attachment_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b3351322b2cfd158f546c053b64876ee28f0c4c8db9d39839fa35435992b5a02(
+def _typecheckingstub__17eab9c1c0483a81bcbc3cfb19dfc9cd1902962956a39306a77b2b041a6f2182(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    auto_retry_requests: typing.Optional[builtins.bool] = None,
-    endpoint: typing.Optional[builtins.str] = None,
-    log_key: typing.Optional[builtins.str] = None,
-    region: typing.Optional[builtins.str] = None,
-    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
-    sts_endpoint: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    time_key_format: typing.Optional[builtins.str] = None,
+    arn: typing.Optional[builtins.str] = None,
+    attachment_id: typing.Optional[builtins.str] = None,
+    creation_time: typing.Optional[builtins.str] = None,
+    state: typing.Optional[builtins.str] = None,
+    status: typing.Optional[builtins.str] = None,
+    status_code: typing.Optional[builtins.str] = None,
+    status_message: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f56caf857f07fc4fcf3a9d82849abe1b6d988d15131ee141433d839c247afbab(
+def _typecheckingstub__25aee8c8ebebcfa519a0f5706458a5669157c84f5af528e93a86402ac7c50aae(
     *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    name: typing.Optional[builtins.str] = None,
+    peer_account_id: typing.Optional[builtins.str] = None,
+    peer_region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8359d0e12857464b85b7f043fe21b4c1b8581d20c4a022da8a6c0e79ee1c3386(
+def _typecheckingstub__1b477916bc8b985cd2d6731bf57489e1a7c94f20fccf7711617cdf0d1bd25beb(
     *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    name: typing.Optional[builtins.str] = None,
+    peer_account_id: typing.Optional[builtins.str] = None,
+    peer_region: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    local_transit_gateway: ITransitGateway,
+    peer_transit_gateway: ITransitGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5d8425bcc923d11b65d58b1eaf5873e22f32f3ab919ad7e37262fc57ab0df995(
+def _typecheckingstub__34be88b6da81fce37f3376e8b1fd1aff7e222c4b2fb4ab8e879c634868d58a81(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-    domain: _aws_cdk_aws_opensearchservice_ceddda9d.IDomain,
-    aws_auth: typing.Optional[builtins.bool] = None,
-    aws_external_id: typing.Optional[builtins.str] = None,
-    aws_region: typing.Optional[builtins.str] = None,
-    aws_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
-    aws_sts_endpoint: typing.Optional[builtins.str] = None,
-    buffer_size: typing.Optional[OpenSearchOutputBufferSize] = None,
-    current_time_index: typing.Optional[builtins.bool] = None,
-    generate_id: typing.Optional[builtins.bool] = None,
-    host: typing.Optional[builtins.str] = None,
-    http_passwd: typing.Optional[builtins.str] = None,
-    http_user: typing.Optional[builtins.str] = None,
-    id_key: typing.Optional[builtins.str] = None,
-    include_tag_key: typing.Optional[builtins.bool] = None,
-    index: typing.Optional[builtins.str] = None,
-    logstash_date_format: typing.Optional[builtins.str] = None,
-    logstash_format: typing.Optional[builtins.bool] = None,
-    logstash_prefix: typing.Optional[builtins.str] = None,
-    logstash_prefix_key: typing.Optional[builtins.str] = None,
-    path: typing.Optional[builtins.str] = None,
-    pipeline: typing.Optional[builtins.str] = None,
-    port: typing.Optional[jsii.Number] = None,
-    replace_dots: typing.Optional[builtins.bool] = None,
-    suppress_type_name: typing.Optional[builtins.bool] = None,
-    tag_key: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    time_key_format: typing.Optional[builtins.str] = None,
-    time_key_nanos: typing.Optional[builtins.bool] = None,
-    trace_error: typing.Optional[builtins.bool] = None,
-    trace_output: typing.Optional[builtins.bool] = None,
-    type: typing.Optional[builtins.str] = None,
-    workers: typing.Optional[jsii.Number] = None,
-    write_operation: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    amazon_side_asn: typing.Optional[jsii.Number] = None,
+    auto_accept_shared_attachments: typing.Optional[builtins.bool] = None,
+    cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
+    default_route_table_association: typing.Optional[builtins.bool] = None,
+    default_route_table_id: typing.Optional[builtins.str] = None,
+    default_route_table_propagation: typing.Optional[builtins.bool] = None,
+    description: typing.Optional[builtins.str] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    multicast_support: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    vpn_ecmp_support: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__6444197d7722391a58b5da239897ee3a742da209a160dd73058c6c54dc737cf7(
-    config: typing.Mapping[builtins.str, typing.Any],
+def _typecheckingstub__472f0a715c24828891d913514782594fd48e540d0192f96901c525a6f2c9845f(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    cidr: builtins.str,
+    route_table: ITransitGatewayRouteTable,
+    attachment: typing.Optional[ITransitGatewayAttachment] = None,
+    blackhole: typing.Optional[builtins.bool] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__acc47748e8c44554d5768c7501d9e6c9274e616d8bb24e8c9c64ec6e7ca82c4e(
+def _typecheckingstub__e915393403cdd527b11e940ce216647c74d6e6b709f726e821e12fa1b470873d(
     scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    transit_gateway_route_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__d0c3c962388492a04b5601f56b47b4dfbb0110dbd51c733afa1a9bed17ae16f9(
-    scope: _constructs_77d1e7e8.Construct,
-    id: builtins.str,
+def _typecheckingstub__eac305487ec828686fdbbd312914a754c55ca742068c194f48ac724cf9aef071(
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
-    name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
+    cidr: builtins.str,
+    attachment: typing.Optional[ITransitGatewayAttachment] = None,
+    blackhole: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__6359c3f686f0688d1026d3fd4e13f56fdd12e614640211e1a20c6764506d0bde(
-    id: builtins.str,
-    secret: _aws_cdk_aws_secretsmanager_ceddda9d.ISecret,
+def _typecheckingstub__36f603e48c36f0aabd623aee3c75f3f94dcd322957a71fb2d3539585045d2c00(
     *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    cidr: builtins.str,
+    route_table: ITransitGatewayRouteTable,
+    attachment: typing.Optional[ITransitGatewayAttachment] = None,
+    blackhole: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8a0341aaa28a58b67be791194cbc62d0dc6cb7590b8b514b48b86ddc4b19c218(
+def _typecheckingstub__bf9f0e3a9c51ac3498209cf81371557e5b56db1c03ff409740d882fde1cacda7(
     scope: _constructs_77d1e7e8.Construct,
     id: builtins.str,
     *,
-    cluster: _aws_cdk_aws_eks_ceddda9d.ICluster,
+    transit_gateway: ITransitGateway,
     name: typing.Optional[builtins.str] = None,
-    namespace: typing.Optional[builtins.str] = None,
     account: typing.Optional[builtins.str] = None,
     environment_from_arn: typing.Optional[builtins.str] = None,
     physical_name: typing.Optional[builtins.str] = None,
     region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__e4726b5ae83a114c6d9a0343261df1f71b3fb8d8712d5e1a0e9dd6ffb85ada79(
+def _typecheckingstub__7ddc972512f9b73360cad75e0fd028f815d92130c441ed49e42d40f77ebd8fff(
+    scope: _constructs_77d1e7e8.IConstruct,
     id: builtins.str,
-    parameter: _aws_cdk_aws_ssm_ceddda9d.IParameter,
-    *,
-    fields: typing.Optional[typing.Sequence[typing.Union[SecretFieldReference, typing.Dict[builtins.str, typing.Any]]]] = None,
-    name: typing.Optional[builtins.str] = None,
+    transit_gateway_route_table_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2b0341b3b1df86ed9b5aab4b4fadcc47fd710ae038076cca755f3c48acef6956(
-    name: builtins.str,
+def _typecheckingstub__ba42798c9102c3419b7c375a3d8ce27fef028001fb7cc17a2798c1aad61854ff(
     *,
-    match: typing.Optional[FluentBitMatch] = None,
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__dd92e8237c9a3e0963fb6f8aa69a0ef0b1b6cb8403264e0fdd57816a24a83f04(
-    config: typing.Mapping[builtins.str, typing.Any],
-) -> None:
-    """Type checking stubs"""
-    pass
-
-def _typecheckingstub__5ad4b94abc52cd50668ebd6e0a941de90c4ed68a322b0c4bd1bf8f5d132edd78(
-    _scope: _constructs_77d1e7e8.IConstruct,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5953f10fbafcde2546e1cf7a12bdade9d093857e166f6d1fb4bab50e2a66f14b(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__8ae02cfe78ce98fb4f7880816162efbcf405d70470d3f4d83605632beeb8a6f7(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    transit_gateway: ITransitGateway,
+    name: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__60894bd40aca48d31e52eb990ad104ed6b9b8b2602d5bae83cb8098f2ea83f1a(
-    condition: ModifyCondition,
+def _typecheckingstub__4312d41d9a05862a91818a278fa16d6a73ff75dcd46ad08d731c98c54086e195(
+    *,
+    inside_cidr: typing.Optional[builtins.str] = None,
+    pre_shared_key: typing.Optional[_aws_cdk_ceddda9d.SecretValue] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4872512d801b614d842132e607c71d6d758968a7609d124502601dd7de57178a(
-    operation: ModifyOperation,
+def _typecheckingstub__3dff1261f60aa49a2037d280e97af162d26181faeabf698640e4139891619042(
+    *,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8290d1192e5d252ca7834f51af4ac7230139ac8edc7a97b45248f244d5803b08(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__c68fcd54ad9cdc22e3838841971cc60da339a1c6b65f45abf9839c71f80a1ad8(
+    *,
+    remote_endpoint: IRemoteVpnEndpoint,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    static_routes_only: typing.Optional[builtins.bool] = None,
+    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__2ff2cbdcb80817e036a6954889caaeadf5950a28c75b5dba99ae8a9ac2313605(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__db1711f2c24c8b7a52cb1e23aa7c00f2ee31a53d068176d8b694ba413b49c85e(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    local_endpoint: ILocalVpnEndpoint,
+    remote_endpoint: IRemoteVpnEndpoint,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    static_routes_only: typing.Optional[builtins.bool] = None,
+    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__6c582e20366c46fa5a93e6085edba3cad0c3a6114b9d179929c4a21e06afd000(
-    name: builtins.str,
+def _typecheckingstub__3b1943d41246b0671229072a9d9650d8d0f9f66aaf7b458b59f96ab84ad35da3(
+    metric_name: builtins.str,
     *,
-    match: typing.Optional[FluentBitMatch] = None,
+    account: typing.Optional[builtins.str] = None,
+    color: typing.Optional[builtins.str] = None,
+    dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
+    label: typing.Optional[builtins.str] = None,
+    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
+    region: typing.Optional[builtins.str] = None,
+    statistic: typing.Optional[builtins.str] = None,
+    unit: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.Unit] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__f55ec2d6a159d7531fd899f1f3bf43e62ed11244ce1b82143887e03f2226d642(
-    config: typing.Mapping[builtins.str, typing.Any],
+def _typecheckingstub__b7ddda611ef5d00d1dbfb980664aaf365a9109585805083204f9dd201f73b937(
+    transit_gateway: ITransitGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__18b4223306efeb65c4b4c3faa3427b063444b0783b18132bf6e713a6fd9edbcb(
-    parser: IFluentBitParserPlugin,
+def _typecheckingstub__255c4f2f88d39694addb3404e05f43b66d5900dda0a83d02497e7579af1e9f87(
+    vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__c79cf71df86cb41e555b053e2f91fa72cc6a21fe3a419e03d0eeb0bbc80de8f0(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__e9f1ecffd701acc1acc5674e16c0bca0e65f2e2327e74bfb0fe4021722919ad1(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    local_endpoint: ILocalVpnEndpoint,
+    remote_endpoint: IRemoteVpnEndpoint,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    static_routes_only: typing.Optional[builtins.bool] = None,
+    tunnel_configurations: typing.Optional[typing.Sequence[typing.Union[TunnelOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8aed0e3d729344028d0f8b2dd7852c483cccc00b07ab135d6bc3adfeeb63180a(
-    name: builtins.str,
-    format: builtins.str,
+def _typecheckingstub__0ec3ce1dacbcb72f74a7ad181d5838d1e71517bb5fc661cee673e3d13cf35dbe(
+    customer_gateway: ICustomerGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__a9117f2b6ee6f3211f51ac4d139a07337fb77609903f1cdfc5d98cecfc42198b(
-    config: typing.Mapping[builtins.str, typing.Any],
+def _typecheckingstub__19c531bfa20e4b82501cd1840a34d989b2593246657ad35703dfdd6156ae409b(
+    name: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__197d11f14d745ecc6b6f0e060796ec77dba5a2371d0b974c5188eba457ace3a9(
-    tag: builtins.str,
+def _typecheckingstub__a4c9d0488d52533eda0e8e013c7c8dc98375bf35fbfb4d0119edfc6dafc3add2(
+    vpn_gateway: _aws_cdk_aws_ec2_ceddda9d.IVpnGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b1fb7025737a67bb8d4d600b93b0d5d19ecf74c9ce22d8ea64f634ad9895f200(
-    tag: builtins.str,
+def _typecheckingstub__b034f4493a7f4e0ef9f3e966d78f68321b168b61b98dda5c4dace5477a2b5d5e(
+    _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5f389e835484d35e9442fddb76443dec0a2aa164eb591d2f71cb44abf7e9b8fa(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__70829756f6d4615ae6fcf33ab20a8d6ad7c5e9441db840b515597cfad99ddef1(
+    *,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+    max_netmask_length: typing.Optional[jsii.Number] = None,
+    min_netmask_length: typing.Optional[jsii.Number] = None,
+    family: builtins.str,
+    publicly_advertisable: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4179007c95e092b6ac83f12dd7ef24c1c718db06738628257564097d17575d37(
-    name: builtins.str,
+def _typecheckingstub__55ce524183de9e545e778862db7286b6b76ac2dfa4cff44105d75e9625dec995(
     *,
-    regex: builtins.str,
-    skip_empty_values: typing.Optional[builtins.bool] = None,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    allocation: typing.Optional[IIpamAllocationConfiguration] = None,
+    description: typing.Optional[builtins.str] = None,
+    scope: typing.Optional[_constructs_77d1e7e8.IConstruct] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__b3c327e2acce81be05e692cd50cc22811413200c4697881b0ba1fbe6ce2d81d2(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__7814523b269d29ae5e2e42aa21c1f81bdc5a471fe5e300b0768c03a21b6a6f91(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
+    *,
+    ip_address: builtins.str,
+    bgp_asn: typing.Optional[jsii.Number] = None,
+    connection_type: typing.Optional[VpnConnectionType] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__7b876de72e29ff64e3f1942127300def8853d5a5fcc52fac6120aba70bdda279(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__9cee3aaa3f8d41d377b44df84c1bd31404fc3c74c1f3d4d50f41733f5ceaeaba(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    *,
+    customer_gateway_id: builtins.str,
+    bgp_asn: typing.Optional[jsii.Number] = None,
+    ip_address: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__5ddeac1f10751e613cc3decd64281d60ce8da73f21dce744a8f23bdd94d419b9(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__745b377e3c9abac41a861ca1050cfc8012b832cecc7ce152fed229d86ee5e4ae(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    customer_gateway_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4fd91daa220023ad34765844283275eab65fafb87508ac56f1d7c81195ee443b(
+def _typecheckingstub__376ae140d941de56c115f01c627b230e0ffb07b7247eb9a061e389e071218f36(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__31e06075f1184a9eaf94b720a919de0afb675ade3a9e9f7e3f9e9140cf117b1f(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__39f263303ec59ccc7954f0b56dc5825a43956cfa48fc4648959c032c858f8a2f(
+    customer_gateway: ICustomerGateway,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9667bfd8f45c5a175656e36d9ad7b4db85b5e7feb83c1e2fc34acbbea82478a0(
-    name: builtins.str,
-    *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
+def _typecheckingstub__bd8797d122fda919f703e603d2c593c1fe151dbc800704673ccc25360cdf5d3e(
+    _scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__1256282bf7828450eaecad96fbe7ce7a18dbb436f8a9946b3251e80084c75330(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__5daa8ff9c63f8f6617139a25d0c2042756ce3ab0da13e5f5a51634e4b9f7ab0c(
+    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
+    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__dcda296c8eede11fa4ddcc3c2feb2e785012111fa86135f95b451f948f97bd08(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__8d11b43c926a884fe3a73d0b44332cd0342bba0c0e2d7bcac16489f068e1191b(
+    bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
+    *,
+    file_format: typing.Optional[FlowLogFileFormat] = None,
+    hive_compatible_partitions: typing.Optional[builtins.bool] = None,
+    key_prefix: typing.Optional[builtins.str] = None,
+    per_hour_partition: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__4bf7e0507e4e17249fa3d68d625e57e70517c7cc3ef3896715e32aac5c34c20a(
+def _typecheckingstub__e6be248e60a194fe1d0bcf9dc9398b94b088ef8e6ca462c0c85ef25246e79057(
     scope: _constructs_77d1e7e8.IConstruct,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__8e25b48b2e66c9db37ff8e8c3719343636a0ede774d594e4e69fefd8f541afc7(
-    name: builtins.str,
+def _typecheckingstub__88da3a3ecf8cb4cfba6289a415667d2b6f93a9c09443c8efc4a0b18c355aca3b(
     *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+    max_netmask_length: typing.Optional[jsii.Number] = None,
+    min_netmask_length: typing.Optional[jsii.Number] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__0a81c3d8601df476452f69214aca18722b70cc833bc61983875ae41787e2ce75(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__68794c4d85dd9da608a3e224ee4d5a5834dbf3e68c8329ff179fbf9358467b84(
+    *,
+    default_netmask_length: typing.Optional[jsii.Number] = None,
+    max_netmask_length: typing.Optional[jsii.Number] = None,
+    min_netmask_length: typing.Optional[jsii.Number] = None,
+    publicly_advertisable: typing.Optional[builtins.bool] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9575880f0d90bc5de7b08966955cdc0ae58d806eef8a52a89f16c51353d5f674(
-    name: builtins.str,
+def _typecheckingstub__e27ee6909fddcfad51f5ddc3aee4e522d6f5fdeab0a0272e67e7d62c063924d6(
+    scope: _constructs_77d1e7e8.Construct,
+    id: builtins.str,
     *,
-    time_format: typing.Optional[builtins.str] = None,
-    time_key: typing.Optional[builtins.str] = None,
-    types: typing.Optional[typing.Mapping[builtins.str, ParserPluginDataType]] = None,
+    transit_gateway: ITransitGateway,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    appliance_mode_support: typing.Optional[builtins.bool] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    ipv6_support: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__9cc473e237e03b0900368e7d87fdfbee36d9a7b81802d233cd2091e9fbeed709(
-    _scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__135a7b7bec5b4b7974ff32ebff887b94cc20f2b37d6736525ec2c4e7c4b5c542(
+    scope: _constructs_77d1e7e8.IConstruct,
+    id: builtins.str,
+    transit_gateway_attachment_id: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
-def _typecheckingstub__33bba3952c545b0c433e0348981b5b24158f45f87bd95dd02431e2b4b4656a81(
-    scope: _constructs_77d1e7e8.IConstruct,
+def _typecheckingstub__4d1defbd3f98b5d681f7a4e30d69288e6cdc5223fef0fed304547c78510a96e2(
+    *,
+    account: typing.Optional[builtins.str] = None,
+    environment_from_arn: typing.Optional[builtins.str] = None,
+    physical_name: typing.Optional[builtins.str] = None,
+    region: typing.Optional[builtins.str] = None,
+    transit_gateway: ITransitGateway,
+    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
+    appliance_mode_support: typing.Optional[builtins.bool] = None,
+    dns_support: typing.Optional[builtins.bool] = None,
+    ipv6_support: typing.Optional[builtins.bool] = None,
+    name: typing.Optional[builtins.str] = None,
+    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
 ) -> None:
     """Type checking stubs"""
     pass
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/k8s_fargate/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/k8s_fargate/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/kinesis_firehose/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/kinesis_firehose/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/lambda_/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/lambda_/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/ram/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/ram/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/ram_resources/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/ram_resources/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -11,15 +11,17 @@
 from typeguard import check_type
 
 from .._jsii import *
 
 import aws_cdk.aws_codebuild as _aws_cdk_aws_codebuild_ceddda9d
 import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
 import constructs as _constructs_77d1e7e8
-from ..ec2 import ITransitGateway as _ITransitGateway_25936657
+from ..ec2 import (
+    IIpamPool as _IIpamPool_511f311d, ITransitGateway as _ITransitGateway_25936657
+)
 from ..ram import ISharable as _ISharable_ffb95c3b
 
 
 @jsii.implements(_ISharable_ffb95c3b)
 class SharedResource(
     metaclass=jsii.JSIIMeta,
     jsii_type="cdk-extensions.ram_resources.SharedResource",
@@ -31,14 +33,25 @@
         :param arn: -
         '''
         if __debug__:
             type_hints = typing.get_type_hints(_typecheckingstub__82c6e68eec0de5fca8b463c5c3b7112ef4274e8a16b3014e8a2df4d8a4578c1c)
             check_type(argname="argument arn", value=arn, expected_type=type_hints["arn"])
         return typing.cast("SharedResource", jsii.sinvoke(cls, "fromArn", [arn]))
 
+    @jsii.member(jsii_name="fromIpamPool")
+    @builtins.classmethod
+    def from_ipam_pool(cls, pool: _IIpamPool_511f311d) -> "SharedResource":
+        '''
+        :param pool: -
+        '''
+        if __debug__:
+            type_hints = typing.get_type_hints(_typecheckingstub__0576f61062c11fb38035ae71969f2682c71bdc34133398b8aba999ac1f962ff1)
+            check_type(argname="argument pool", value=pool, expected_type=type_hints["pool"])
+        return typing.cast("SharedResource", jsii.sinvoke(cls, "fromIpamPool", [pool]))
+
     @jsii.member(jsii_name="fromProject")
     @builtins.classmethod
     def from_project(
         cls,
         project: _aws_cdk_aws_codebuild_ceddda9d.IProject,
     ) -> "SharedResource":
         '''
@@ -94,14 +107,20 @@
 
 def _typecheckingstub__82c6e68eec0de5fca8b463c5c3b7112ef4274e8a16b3014e8a2df4d8a4578c1c(
     arn: builtins.str,
 ) -> None:
     """Type checking stubs"""
     pass
 
+def _typecheckingstub__0576f61062c11fb38035ae71969f2682c71bdc34133398b8aba999ac1f962ff1(
+    pool: _IIpamPool_511f311d,
+) -> None:
+    """Type checking stubs"""
+    pass
+
 def _typecheckingstub__c0d1ebb15d9bdd6b5f747b43f752477c8deb4e9208a4c3ad912068a1cca90157(
     project: _aws_cdk_aws_codebuild_ceddda9d.IProject,
 ) -> None:
     """Type checking stubs"""
     pass
 
 def _typecheckingstub__eccc4e2a5f9de8aa2100dd8c9e5bdd1c9875ad5f0fc8c5682dfc595819e80648(
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/rds/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/rds/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/route53/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/route53/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/s3_buckets/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/s3_buckets/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/sso/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/sso/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions/stacks/__init__.py` & `cdk-extensions-0.0.50/src/cdk_extensions/stacks/__init__.py`

 * *Files identical despite different names*

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions.egg-info/PKG-INFO` & `cdk-extensions-0.0.50/src/cdk_extensions.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cdk-extensions
-Version: 0.0.49
+Version: 0.0.50
 Summary: cdk-extensions
 Home-page: https://github.com/vibe-io/cdk-extensions.git
 Author: Kevin Lucas<kevinluc08@gmail.com>
 License: Apache-2.0
 Project-URL: Source, https://github.com/vibe-io/cdk-extensions.git
 Classifier: Intended Audience :: Developers
 Classifier: Operating System :: OS Independent
```

### Comparing `cdk-extensions-0.0.49/src/cdk_extensions.egg-info/SOURCES.txt` & `cdk-extensions-0.0.50/src/cdk_extensions.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -7,29 +7,30 @@
 src/cdk_extensions/py.typed
 src/cdk_extensions.egg-info/PKG-INFO
 src/cdk_extensions.egg-info/SOURCES.txt
 src/cdk_extensions.egg-info/dependency_links.txt
 src/cdk_extensions.egg-info/requires.txt
 src/cdk_extensions.egg-info/top_level.txt
 src/cdk_extensions/_jsii/__init__.py
-src/cdk_extensions/_jsii/cdk-extensions@0.0.49.jsii.tgz
+src/cdk_extensions/_jsii/cdk-extensions@0.0.50.jsii.tgz
 src/cdk_extensions/_jsii/bin/init-aws.sh
 src/cdk_extensions/aps/__init__.py
 src/cdk_extensions/asserts/__init__.py
 src/cdk_extensions/athena/__init__.py
 src/cdk_extensions/core/__init__.py
 src/cdk_extensions/ec2/__init__.py
 src/cdk_extensions/ec2_patterns/__init__.py
 src/cdk_extensions/eks_patterns/__init__.py
 src/cdk_extensions/glue/__init__.py
 src/cdk_extensions/glue_tables/__init__.py
 src/cdk_extensions/k8s_aws/__init__.py
 src/cdk_extensions/k8s_fargate/__init__.py
 src/cdk_extensions/kinesis_firehose/__init__.py
 src/cdk_extensions/lambda_/__init__.py
+src/cdk_extensions/networkmanager/__init__.py
 src/cdk_extensions/ram/__init__.py
 src/cdk_extensions/ram_resources/__init__.py
 src/cdk_extensions/rds/__init__.py
 src/cdk_extensions/route53/__init__.py
 src/cdk_extensions/s3_buckets/__init__.py
 src/cdk_extensions/sso/__init__.py
 src/cdk_extensions/stacks/__init__.py
```


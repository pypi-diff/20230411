# Comparing `tmp/solidpython2-2.0.0b4.tar.gz` & `tmp/solidpython2-2.0.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "solidpython2-2.0.0b4.tar", max compression
+gzip compressed data, was "solidpython2-2.0.1.tar", max compression
```

## Comparing `solidpython2-2.0.0b4.tar` & `solidpython2-2.0.1.tar`

### file list

```diff
@@ -1,325 +1,173 @@
--rw-r--r--   0        0        0    22930 2023-03-15 13:23:46.110122 solidpython2-2.0.0b4/README.rst
--rw-r--r--   0        0        0     1124 2023-03-23 17:50:13.249468 solidpython2-2.0.0b4/pyproject.toml
--rw-r--r--   0        0        0      108 2023-03-16 11:22:53.244444 solidpython2-2.0.0b4/solid2/__init__.py
--rw-r--r--   0        0        0     1687 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/config.py
--rw-r--r--   0        0        0      381 2023-03-15 13:33:52.945033 solidpython2-2.0.0b4/solid2/core/__init__.py
--rw-r--r--   0        0        0      554 2023-03-15 13:35:20.520880 solidpython2-2.0.0b4/solid2/core/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0      423 2022-08-12 15:59:23.591930 solidpython2-2.0.0b4/solid2/core/__pycache__/__init__.cpython-38.pyc
--rw-r--r--   0        0        0     6380 2023-03-16 18:55:30.044594 solidpython2-2.0.0b4/solid2/core/__pycache__/accessSyntaxBase.cpython-310.pyc
--rw-r--r--   0        0        0     6918 2022-09-07 12:28:16.184411 solidpython2-2.0.0b4/solid2/core/__pycache__/accessSyntaxBase.cpython-38.pyc
--rw-r--r--   0        0        0    28847 2023-03-19 13:06:07.912877 solidpython2-2.0.0b4/solid2/core/__pycache__/builtin_primitives.cpython-310.pyc
--rw-r--r--   0        0        0    29566 2022-09-01 10:40:49.372983 solidpython2-2.0.0b4/solid2/core/__pycache__/builtin_primitives.cpython-38.pyc
--rw-r--r--   0        0        0     5278 2023-03-16 18:55:29.980594 solidpython2-2.0.0b4/solid2/core/__pycache__/builtins.cpython-310.pyc
--rw-r--r--   0        0        0     1784 2022-11-04 17:06:42.583231 solidpython2-2.0.0b4/solid2/core/__pycache__/builtins.cpython-38.pyc
--rw-r--r--   0        0        0    29570 2022-09-01 10:26:41.748636 solidpython2-2.0.0b4/solid2/core/__pycache__/explicit_builtins.cpython-38.pyc
--rw-r--r--   0        0        0     1599 2022-12-15 09:17:23.706920 solidpython2-2.0.0b4/solid2/core/__pycache__/extension_manager.cpython-310.pyc
--rw-r--r--   0        0        0     1659 2022-09-04 08:54:20.584363 solidpython2-2.0.0b4/solid2/core/__pycache__/extension_manager.cpython-38.pyc
--rw-r--r--   0        0        0     9562 2023-03-16 18:55:30.036594 solidpython2-2.0.0b4/solid2/core/__pycache__/object_base.cpython-310.pyc
--rw-r--r--   0        0        0     4712 2022-11-04 17:06:42.599231 solidpython2-2.0.0b4/solid2/core/__pycache__/object_base.cpython-38.pyc
--rw-r--r--   0        0        0     2902 2022-12-15 09:17:23.690920 solidpython2-2.0.0b4/solid2/core/__pycache__/object_factory.cpython-310.pyc
--rw-r--r--   0        0        0     2906 2022-08-12 15:59:23.619930 solidpython2-2.0.0b4/solid2/core/__pycache__/object_factory.cpython-38.pyc
--rw-r--r--   0        0        0     2402 2023-03-16 18:55:30.044594 solidpython2-2.0.0b4/solid2/core/__pycache__/operatorBase.cpython-310.pyc
--rw-r--r--   0        0        0     2420 2022-09-04 09:09:46.976401 solidpython2-2.0.0b4/solid2/core/__pycache__/operatorBase.cpython-38.pyc
--rw-r--r--   0        0        0     2616 2023-03-19 17:50:38.095079 solidpython2-2.0.0b4/solid2/core/__pycache__/parse_scad.cpython-310.pyc
--rw-r--r--   0        0        0     2548 2022-08-12 15:59:23.611930 solidpython2-2.0.0b4/solid2/core/__pycache__/parse_scad.cpython-38.pyc
--rw-r--r--   0        0        0     3817 2023-03-19 17:50:38.075079 solidpython2-2.0.0b4/solid2/core/__pycache__/scad_import.cpython-310.pyc
--rw-r--r--   0        0        0     3662 2022-08-12 15:59:23.595930 solidpython2-2.0.0b4/solid2/core/__pycache__/scad_import.cpython-38.pyc
--rw-r--r--   0        0        0     2296 2023-03-21 15:30:12.280767 solidpython2-2.0.0b4/solid2/core/__pycache__/scad_render.cpython-310.pyc
--rw-r--r--   0        0        0     2185 2022-08-12 15:59:23.619930 solidpython2-2.0.0b4/solid2/core/__pycache__/scad_render.cpython-38.pyc
--rw-r--r--   0        0        0     2079 2022-12-15 09:17:23.674920 solidpython2-2.0.0b4/solid2/core/__pycache__/utils.cpython-310.pyc
--rw-r--r--   0        0        0     2063 2022-08-12 15:59:23.599930 solidpython2-2.0.0b4/solid2/core/__pycache__/utils.cpython-38.pyc
--rw-r--r--   0        0        0       53 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/__init__.py
--rw-r--r--   0        0        0      215 2023-03-21 15:30:12.248767 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0    28807 2023-03-19 17:50:38.111079 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/builtin_primitives.cpython-310.pyc
--rw-r--r--   0        0        0      364 2023-03-19 13:10:55.672767 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/builtins.cpython-310.pyc
--rw-r--r--   0        0        0      170 2023-03-20 21:07:38.219931 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/builtins_impl.cpython-310.pyc
--rw-r--r--   0        0        0     5188 2023-03-21 15:30:12.276767 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/convenience.cpython-310.pyc
--rw-r--r--   0        0        0    28808 2023-03-21 15:30:12.272767 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/openscad_primitives.cpython-310.pyc
--rw-r--r--   0        0        0      458 2023-03-21 15:30:12.252767 solidpython2-2.0.0b4/solid2/core/builtins/__pycache__/primitives.cpython-310.pyc
--rw-r--r--   0        0        0     3633 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/convenience.py
--rw-r--r--   0        0        0     1040 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/implicit.primitives
--rw-r--r--   0        0        0      754 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/openscad.mutators
--rw-r--r--   0        0        0     1968 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/openscad.primitives
--rw-r--r--   0        0        0    25400 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/openscad_primitives.py
--rw-r--r--   0        0        0      367 2023-03-20 22:35:21.713279 solidpython2-2.0.0b4/solid2/core/builtins/primitives.py
--rw-r--r--   0        0        0      938 2022-09-03 20:01:15.234639 solidpython2-2.0.0b4/solid2/core/extension_manager.py
--rw-r--r--   0        0        0       32 2023-03-19 13:30:20.199884 solidpython2-2.0.0b4/solid2/core/object_base/__init__.py
--rw-r--r--   0        0        0      201 2023-03-19 17:50:38.103079 solidpython2-2.0.0b4/solid2/core/object_base/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0     6414 2023-03-20 15:40:54.295908 solidpython2-2.0.0b4/solid2/core/object_base/__pycache__/access_syntax_mixin.cpython-310.pyc
--rw-r--r--   0        0        0     9417 2023-03-19 13:06:07.904877 solidpython2-2.0.0b4/solid2/core/object_base/__pycache__/object_base.cpython-310.pyc
--rw-r--r--   0        0        0     9636 2023-03-21 15:30:12.268767 solidpython2-2.0.0b4/solid2/core/object_base/__pycache__/object_base_impl.cpython-310.pyc
--rw-r--r--   0        0        0     2465 2023-03-20 15:40:54.295908 solidpython2-2.0.0b4/solid2/core/object_base/__pycache__/operator_mixin.cpython-310.pyc
--rw-r--r--   0        0        0     3522 2023-03-20 14:58:07.769013 solidpython2-2.0.0b4/solid2/core/object_base/access_syntax_mixin.py
--rw-r--r--   0        0        0     6839 2023-03-23 17:47:21.609266 solidpython2-2.0.0b4/solid2/core/object_base/object_base_impl.py
--rw-r--r--   0        0        0     2253 2023-03-20 14:58:07.769013 solidpython2-2.0.0b4/solid2/core/object_base/operator_mixin.py
--rw-r--r--   0        0        0     3994 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/core/object_factory.py
--rw-r--r--   0        0        0     3469 2023-03-21 17:35:24.083900 solidpython2-2.0.0b4/solid2/core/parse_scad.py
--rw-r--r--   0        0        0     5493 2023-03-19 13:30:20.199884 solidpython2-2.0.0b4/solid2/core/scad_import.py
--rw-r--r--   0        0        0     3049 2023-03-23 17:47:21.609266 solidpython2-2.0.0b4/solid2/core/scad_render.py
--rw-r--r--   0        0        0     2152 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/core/utils.py
--rwxr-xr-x   0        0        0      559 2023-03-15 22:53:12.381332 solidpython2-2.0.0b4/solid2/examples/01-basics.py
--rw-r--r--   0        0        0       75 2023-03-20 22:32:59.744979 solidpython2-2.0.0b4/solid2/examples/01-basics.scad
--rwxr-xr-x   0        0        0      846 2023-03-15 22:55:23.517187 solidpython2-2.0.0b4/solid2/examples/02-vars-and-operators.py
--rw-r--r--   0        0        0       66 2023-03-20 22:32:59.800979 solidpython2-2.0.0b4/solid2/examples/02-vars-and-operators.scad
--rwxr-xr-x   0        0        0      647 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/examples/03-debug-background.py
--rw-r--r--   0        0        0      110 2023-03-20 22:32:59.860980 solidpython2-2.0.0b4/solid2/examples/03-debug-background.scad
--rwxr-xr-x   0        0        0     1272 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/examples/04-convenience.py
--rw-r--r--   0        0        0      166 2023-03-20 22:32:59.916980 solidpython2-2.0.0b4/solid2/examples/04-convenience.scad
--rwxr-xr-x   0        0        0      934 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/examples/05-access-style-syntax.py
--rw-r--r--   0        0        0      166 2023-03-20 22:32:59.972980 solidpython2-2.0.0b4/solid2/examples/05-access-style-syntax.scad
--rwxr-xr-x   0        0        0     1182 2023-03-15 22:58:40.236989 solidpython2-2.0.0b4/solid2/examples/06-functions.py
--rw-r--r--   0        0        0     1268 2023-03-20 22:33:00.032980 solidpython2-2.0.0b4/solid2/examples/06-functions.scad
--rwxr-xr-x   0        0        0      527 2023-03-19 11:58:59.349891 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-attachable.py
--rw-r--r--   0        0        0     3047 2023-03-20 22:33:00.172980 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-attachable.scad
--rw-r--r--   0        0        0     3342 2023-03-20 14:58:07.769013 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-logo.py
--rw-r--r--   0        0        0     4669 2023-03-20 22:33:00.268980 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-logo.scad
--rwxr-xr-x   0        0        0     1762 2023-03-20 14:58:07.769013 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2.py
--rw-r--r--   0        0        0    39897 2023-03-20 22:33:00.360981 solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2.scad
--rwxr-xr-x   0        0        0      620 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/examples/07-libs.py
--rw-r--r--   0        0        0      128 2023-03-20 22:33:00.420981 solidpython2-2.0.0b4/solid2/examples/07-libs.scad
--rwxr-xr-x   0        0        0     2448 2023-03-20 14:58:07.769013 solidpython2-2.0.0b4/solid2/examples/08-extensions.py
--rw-r--r--   0        0        0      200 2023-03-20 22:33:00.476981 solidpython2-2.0.0b4/solid2/examples/08-extensions.scad
--rwxr-xr-x   0        0        0     1675 2022-12-15 10:19:43.476714 solidpython2-2.0.0b4/solid2/examples/09-code-attach-extension.py
--rw-r--r--   0        0        0     1753 2023-03-20 22:33:00.532981 solidpython2-2.0.0b4/solid2/examples/09-code-attach-extension.scad
--rwxr-xr-x   0        0        0      889 2023-03-19 12:43:05.625475 solidpython2-2.0.0b4/solid2/examples/10-customizer.py
--rw-r--r--   0        0        0      755 2023-03-20 22:33:00.588981 solidpython2-2.0.0b4/solid2/examples/10-customizer.scad
--rw-r--r--   0        0        0      158 2022-08-12 15:59:10.183877 solidpython2-2.0.0b4/solid2/examples/11-font/LICENSE_README
--rw-r--r--   0        0        0    47404 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/11-font/RichEatin.otf
--rwxr-xr-x   0        0        0      192 2023-03-15 13:23:46.114122 solidpython2-2.0.0b4/solid2/examples/11-fonts.py
--rw-r--r--   0        0        0      100 2023-03-20 22:33:00.648981 solidpython2-2.0.0b4/solid2/examples/11-fonts.scad
--rwxr-xr-x   0        0        0      335 2023-03-15 13:23:46.114122 solidpython2-2.0.0b4/solid2/examples/12-animation.py
--rw-r--r--   0        0        0      141 2023-03-20 22:33:00.700981 solidpython2-2.0.0b4/solid2/examples/12-animation.scad
--rwxr-xr-x   0        0        0     2032 2023-03-19 12:43:05.625475 solidpython2-2.0.0b4/solid2/examples/13-animated-bouncing-ball.py
--rw-r--r--   0        0        0    43939 2023-03-20 22:33:00.764981 solidpython2-2.0.0b4/solid2/examples/13-animated-bouncing-ball.scad
--rw-r--r--   0        0        0     1353 2023-03-20 22:33:00.820982 solidpython2-2.0.0b4/solid2/examples/14-implicitCAD.escad
--rwxr-xr-x   0        0        0     1381 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/14-implicitCAD.py
--rw-r--r--   0        0        0     1177 2023-03-20 22:33:00.872982 solidpython2-2.0.0b4/solid2/examples/15-implicitCAD2.escad
--rwxr-xr-x   0        0        0     1794 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/15-implicitCAD2.py
--rwxr-xr-x   0        0        0     1102 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/16-mazebox-bosl2.py
--rw-r--r--   0        0        0    10656 2023-03-20 22:33:00.952982 solidpython2-2.0.0b4/solid2/examples/16-mazebox-bosl2.scad
--rwxr-xr-x   0        0        0     2243 2023-03-15 13:23:46.114122 solidpython2-2.0.0b4/solid2/examples/17-greedy-scad-interface.py
--rw-r--r--   0        0        0      541 2023-03-20 22:33:01.012982 solidpython2-2.0.0b4/solid2/examples/17-greedy-scad-interface.scad
--rw-r--r--   0        0        0     1196 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/maze7.png
--rwxr-xr-x   0        0        0      293 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/examples/run_all_examples.py
--rw-r--r--   0        0        0        1 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/extensions/__init__.py
--rw-r--r--   0        0        0     2480 2023-03-17 15:24:05.098592 solidpython2-2.0.0b4/solid2/extensions/__pycache__/___bosl2_stub_generator.cpython-310.pyc
--rw-r--r--   0        0        0      162 2022-12-15 09:17:23.698920 solidpython2-2.0.0b4/solid2/extensions/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0      148 2022-08-12 15:59:23.623930 solidpython2-2.0.0b4/solid2/extensions/__pycache__/__init__.cpython-38.pyc
--rw-r--r--   0        0        0     4377 2022-12-15 09:17:23.702920 solidpython2-2.0.0b4/solid2/extensions/__pycache__/access_syntax.cpython-310.pyc
--rw-r--r--   0        0        0     4759 2022-11-04 17:06:42.607231 solidpython2-2.0.0b4/solid2/extensions/__pycache__/access_syntax.cpython-38.pyc
--rw-r--r--   0        0        0     2462 2023-03-17 15:22:25.114628 solidpython2-2.0.0b4/solid2/extensions/__pycache__/bosl2.cpython-310.pyc
--rw-r--r--   0        0        0     1582 2022-08-12 15:59:23.631930 solidpython2-2.0.0b4/solid2/extensions/__pycache__/bosl2.cpython-38.pyc
--rw-r--r--   0        0        0     2477 2023-03-17 15:23:27.666606 solidpython2-2.0.0b4/solid2/extensions/__pycache__/bosl2_stub_generator.cpython-310.pyc
--rw-r--r--   0        0        0     3742 2023-01-29 10:37:12.813201 solidpython2-2.0.0b4/solid2/extensions/__pycache__/convenience.cpython-310.pyc
--rw-r--r--   0        0        0     4010 2022-11-04 17:09:30.895053 solidpython2-2.0.0b4/solid2/extensions/__pycache__/convenience.cpython-38.pyc
--rw-r--r--   0        0        0    29576 2022-08-12 15:59:23.627930 solidpython2-2.0.0b4/solid2/extensions/__pycache__/explicit_builtins.cpython-38.pyc
--rw-r--r--   0        0        0     2358 2022-07-17 22:37:30.559456 solidpython2-2.0.0b4/solid2/extensions/__pycache__/exportResultAsModule.cpython-38.pyc
--rw-r--r--   0        0        0     3844 2023-03-21 16:33:13.384780 solidpython2-2.0.0b4/solid2/extensions/__pycache__/openscad_extension_generator.cpython-310.pyc
--rw-r--r--   0        0        0     1511 2022-12-15 09:17:23.698920 solidpython2-2.0.0b4/solid2/extensions/__pycache__/operators.cpython-310.pyc
--rw-r--r--   0        0        0     1489 2022-11-04 17:06:42.603231 solidpython2-2.0.0b4/solid2/extensions/__pycache__/operators.cpython-38.pyc
--rw-r--r--   0        0        0     1954 2022-06-21 12:18:20.283311 solidpython2-2.0.0b4/solid2/extensions/__pycache__/scad_interface.cpython-38.pyc
--rw-r--r--   0        0        0      210 2023-03-20 21:53:25.648477 solidpython2-2.0.0b4/solid2/extensions/bosl2/__init__.py
--rw-r--r--   0        0        0      393 2023-03-20 21:54:51.820644 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0     5373 2023-03-20 22:33:00.144980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/affine.cpython-310.pyc
--rw-r--r--   0        0        0    16062 2023-03-20 22:33:00.108980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/attachments.cpython-310.pyc
--rw-r--r--   0        0        0     9635 2023-03-20 22:33:00.260980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/beziers.cpython-310.pyc
--rw-r--r--   0        0        0    18026 2023-03-21 15:59:20.551984 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/bosl2_access_syntax_mixin.cpython-310.pyc
--rw-r--r--   0        0        0     1638 2023-03-20 15:40:54.307908 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/bosl2_base.cpython-310.pyc
--rw-r--r--   0        0        0    14715 2023-03-20 11:25:53.399813 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/bosl2_mixin.cpython-310.pyc
--rw-r--r--   0        0        0      961 2023-03-20 12:13:36.942901 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/bosl2_operator_mixin.cpython-310.pyc
--rw-r--r--   0        0        0      555 2023-03-20 15:40:54.391908 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/bosl2_patches.cpython-310.pyc
--rw-r--r--   0        0        0     2316 2023-03-20 22:33:00.104980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/color.cpython-310.pyc
--rw-r--r--   0        0        0     9435 2023-03-20 22:33:00.136980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/comparisons.cpython-310.pyc
--rw-r--r--   0        0        0     1316 2023-03-20 22:33:00.096980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/constants.cpython-310.pyc
--rw-r--r--   0        0        0     4550 2023-03-20 22:33:00.148980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/coords.cpython-310.pyc
--rw-r--r--   0        0        0     3773 2023-03-20 22:33:00.264980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/cubetruss.cpython-310.pyc
--rw-r--r--   0        0        0     6555 2023-03-20 22:33:00.100980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/distributors.cpython-310.pyc
--rw-r--r--   0        0        0     6069 2023-03-20 22:33:00.120980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/drawing.cpython-310.pyc
--rw-r--r--   0        0        0    10428 2023-03-20 22:33:00.260980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/gears.cpython-310.pyc
--rw-r--r--   0        0        0    25233 2023-03-20 22:33:00.152980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/geometry.cpython-310.pyc
--rw-r--r--   0        0        0     8569 2023-03-20 22:33:00.140980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/linalg.cpython-310.pyc
--rw-r--r--   0        0        0    10183 2023-03-20 22:33:00.136980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/lists.cpython-310.pyc
--rw-r--r--   0        0        0     4069 2023-03-20 22:33:00.124980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/masks2d.cpython-310.pyc
--rw-r--r--   0        0        0     6409 2023-03-20 22:33:00.120980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/masks3d.cpython-310.pyc
--rw-r--r--   0        0        0    18287 2023-03-20 22:33:00.128980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/math.cpython-310.pyc
--rw-r--r--   0        0        0     4984 2023-03-20 22:33:00.352981 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/metric_screws.cpython-310.pyc
--rw-r--r--   0        0        0     3361 2023-03-20 22:33:00.100980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/mutators.cpython-310.pyc
--rw-r--r--   0        0        0     8511 2023-03-21 15:59:20.547984 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/openscad.cpython-310.pyc
--rw-r--r--   0        0        0     5514 2023-03-20 22:33:00.172980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/partitions.cpython-310.pyc
--rw-r--r--   0        0        0    10384 2023-03-20 22:33:00.132980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/paths.cpython-310.pyc
--rw-r--r--   0        0        0     9518 2023-03-20 22:33:00.156980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/regions.cpython-310.pyc
--rw-r--r--   0        0        0     6037 2023-03-20 22:33:00.264980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/screws.cpython-310.pyc
--rw-r--r--   0        0        0    11568 2023-03-20 22:33:00.116980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/shapes2d.cpython-310.pyc
--rw-r--r--   0        0        0    14561 2023-03-20 22:33:00.112980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/shapes3d.cpython-310.pyc
--rw-r--r--   0        0        0    13993 2023-03-20 22:33:00.164980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/skin.cpython-310.pyc
--rw-r--r--   0        0        0      731 2023-03-21 15:59:20.543984 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/std.cpython-310.pyc
--rw-r--r--   0        0        0    10226 2023-03-20 22:33:00.160980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/strings.cpython-310.pyc
--rw-r--r--   0        0        0    11425 2023-03-20 22:33:00.100980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/transforms.cpython-310.pyc
--rw-r--r--   0        0        0     7010 2023-03-20 22:33:00.140980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/trigonometry.cpython-310.pyc
--rw-r--r--   0        0        0    11940 2023-03-20 22:33:00.168980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/utility.cpython-310.pyc
--rw-r--r--   0        0        0     6439 2023-03-20 22:33:00.144980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/vectors.cpython-310.pyc
--rw-r--r--   0        0        0     2934 2023-03-20 22:33:00.096980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/version.cpython-310.pyc
--rw-r--r--   0        0        0    11953 2023-03-20 22:33:00.164980 solidpython2-2.0.0b4/solid2/extensions/bosl2/__pycache__/vnf.cpython-310.pyc
--rw-r--r--   0        0        0     3320 2023-03-21 16:33:13.784774 solidpython2-2.0.0b4/solid2/extensions/bosl2/affine.py
--rw-r--r--   0        0        0    12499 2023-03-21 16:33:15.172751 solidpython2-2.0.0b4/solid2/extensions/bosl2/attachments.py
--rw-r--r--   0        0        0     7575 2023-03-21 16:33:13.956771 solidpython2-2.0.0b4/solid2/extensions/bosl2/beziers.py
--rw-r--r--   0        0        0    15725 2023-03-21 16:33:13.744774 solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_access_syntax_mixin.py
--rw-r--r--   0        0        0     1002 2023-03-20 14:58:07.773012 solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_base.py
--rw-r--r--   0        0        0      611 2023-03-20 14:58:07.773012 solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_patches.py
--rw-r--r--   0        0        0    10523 2023-03-21 16:33:13.876772 solidpython2-2.0.0b4/solid2/extensions/bosl2/bottlecaps.py
--rw-r--r--   0        0        0     1542 2023-03-21 16:33:14.132768 solidpython2-2.0.0b4/solid2/extensions/bosl2/color.py
--rw-r--r--   0        0        0     6384 2023-03-21 16:33:13.768774 solidpython2-2.0.0b4/solid2/extensions/bosl2/comparisons.py
--rw-r--r--   0        0        0     1140 2023-03-21 16:33:14.068769 solidpython2-2.0.0b4/solid2/extensions/bosl2/constants.py
--rw-r--r--   0        0        0     3012 2023-03-21 16:33:15.008753 solidpython2-2.0.0b4/solid2/extensions/bosl2/coords.py
--rw-r--r--   0        0        0     3619 2023-03-21 16:33:15.196750 solidpython2-2.0.0b4/solid2/extensions/bosl2/cubetruss.py
--rw-r--r--   0        0        0     5270 2023-03-21 16:33:13.984770 solidpython2-2.0.0b4/solid2/extensions/bosl2/distributors.py
--rw-r--r--   0        0        0     7950 2023-03-21 16:33:14.784757 solidpython2-2.0.0b4/solid2/extensions/bosl2/drawing.py
--rw-r--r--   0        0        0    12656 2023-03-21 16:33:13.912772 solidpython2-2.0.0b4/solid2/extensions/bosl2/fnliterals.py
--rw-r--r--   0        0        0    12640 2023-03-21 16:33:14.224766 solidpython2-2.0.0b4/solid2/extensions/bosl2/gears.py
--rw-r--r--   0        0        0    19280 2023-03-21 16:33:14.296765 solidpython2-2.0.0b4/solid2/extensions/bosl2/geometry.py
--rw-r--r--   0        0        0     2088 2023-03-21 16:33:14.620760 solidpython2-2.0.0b4/solid2/extensions/bosl2/hingesnaps.py
--rw-r--r--   0        0        0     9439 2023-03-21 16:33:15.100752 solidpython2-2.0.0b4/solid2/extensions/bosl2/joiners.py
--rw-r--r--   0        0        0     5628 2023-03-21 16:33:14.092769 solidpython2-2.0.0b4/solid2/extensions/bosl2/linalg.py
--rw-r--r--   0        0        0     1485 2023-03-21 16:33:13.832773 solidpython2-2.0.0b4/solid2/extensions/bosl2/linear_bearings.py
--rw-r--r--   0        0        0     6948 2023-03-21 16:33:13.808773 solidpython2-2.0.0b4/solid2/extensions/bosl2/lists.py
--rw-r--r--   0        0        0     4347 2023-03-21 16:33:14.972754 solidpython2-2.0.0b4/solid2/extensions/bosl2/masks2d.py
--rw-r--r--   0        0        0     7013 2023-03-21 16:33:14.736758 solidpython2-2.0.0b4/solid2/extensions/bosl2/masks3d.py
--rw-r--r--   0        0        0    12249 2023-03-21 16:33:14.916755 solidpython2-2.0.0b4/solid2/extensions/bosl2/math.py
--rw-r--r--   0        0        0     3783 2023-03-21 16:33:15.232750 solidpython2-2.0.0b4/solid2/extensions/bosl2/metric_screws.py
--rw-r--r--   0        0        0     1359 2023-03-21 16:33:15.204750 solidpython2-2.0.0b4/solid2/extensions/bosl2/modular_hose.py
--rw-r--r--   0        0        0     2335 2023-03-21 16:33:14.872756 solidpython2-2.0.0b4/solid2/extensions/bosl2/mutators.py
--rw-r--r--   0        0        0     4461 2023-03-21 16:33:15.028753 solidpython2-2.0.0b4/solid2/extensions/bosl2/nema_steppers.py
--rw-r--r--   0        0        0     6047 2023-03-21 16:33:15.268749 solidpython2-2.0.0b4/solid2/extensions/bosl2/openscad.py
--rw-r--r--   0        0        0     4057 2023-03-21 16:33:13.824773 solidpython2-2.0.0b4/solid2/extensions/bosl2/partitions.py
--rw-r--r--   0        0        0     8291 2023-03-21 16:33:14.616760 solidpython2-2.0.0b4/solid2/extensions/bosl2/paths.py
--rw-r--r--   0        0        0     3389 2023-03-21 16:33:14.128768 solidpython2-2.0.0b4/solid2/extensions/bosl2/polyhedra.py
--rw-r--r--   0        0        0     7756 2023-03-21 16:33:15.264749 solidpython2-2.0.0b4/solid2/extensions/bosl2/regions.py
--rw-r--r--   0        0        0    20576 2023-03-21 16:33:14.400763 solidpython2-2.0.0b4/solid2/extensions/bosl2/rounding.py
--rw-r--r--   0        0        0     2710 2023-03-21 16:33:14.956754 solidpython2-2.0.0b4/solid2/extensions/bosl2/screw_drive.py
--rw-r--r--   0        0        0     5826 2023-03-21 16:33:14.064769 solidpython2-2.0.0b4/solid2/extensions/bosl2/screws.py
--rw-r--r--   0        0        0    13484 2023-03-21 16:33:14.184767 solidpython2-2.0.0b4/solid2/extensions/bosl2/shapes2d.py
--rw-r--r--   0        0        0    19503 2023-03-21 16:33:14.552761 solidpython2-2.0.0b4/solid2/extensions/bosl2/shapes3d.py
--rw-r--r--   0        0        0    15362 2023-03-21 16:33:14.860756 solidpython2-2.0.0b4/solid2/extensions/bosl2/skin.py
--rw-r--r--   0        0        0     1597 2023-03-21 16:33:14.944754 solidpython2-2.0.0b4/solid2/extensions/bosl2/sliders.py
--rw-r--r--   0        0        0      679 2023-03-21 16:33:13.384780 solidpython2-2.0.0b4/solid2/extensions/bosl2/std.py
--rw-r--r--   0        0        0     7243 2023-03-21 16:33:14.996754 solidpython2-2.0.0b4/solid2/extensions/bosl2/strings.py
--rw-r--r--   0        0        0     1722 2023-03-21 16:33:14.584760 solidpython2-2.0.0b4/solid2/extensions/bosl2/structs.py
--rw-r--r--   0        0        0    18126 2023-03-21 16:33:14.660759 solidpython2-2.0.0b4/solid2/extensions/bosl2/threading.py
--rw-r--r--   0        0        0     8285 2023-03-21 16:33:14.432763 solidpython2-2.0.0b4/solid2/extensions/bosl2/transforms.py
--rw-r--r--   0        0        0     4786 2023-03-21 16:33:14.408763 solidpython2-2.0.0b4/solid2/extensions/bosl2/trigonometry.py
--rw-r--r--   0        0        0      611 2023-03-21 16:33:14.936754 solidpython2-2.0.0b4/solid2/extensions/bosl2/tripod_mounts.py
--rw-r--r--   0        0        0     3060 2023-03-21 16:33:14.580760 solidpython2-2.0.0b4/solid2/extensions/bosl2/turtle3d.py
--rw-r--r--   0        0        0     7807 2023-03-21 16:33:14.932755 solidpython2-2.0.0b4/solid2/extensions/bosl2/utility.py
--rw-r--r--   0        0        0     4396 2023-03-21 16:33:13.892772 solidpython2-2.0.0b4/solid2/extensions/bosl2/vectors.py
--rw-r--r--   0        0        0     1772 2023-03-21 16:33:14.724758 solidpython2-2.0.0b4/solid2/extensions/bosl2/version.py
--rw-r--r--   0        0        0     9048 2023-03-21 16:33:14.720758 solidpython2-2.0.0b4/solid2/extensions/bosl2/vnf.py
--rw-r--r--   0        0        0     2165 2023-03-21 16:33:15.044753 solidpython2-2.0.0b4/solid2/extensions/bosl2/walls.py
--rw-r--r--   0        0        0     1045 2023-03-21 16:33:13.772774 solidpython2-2.0.0b4/solid2/extensions/bosl2/wiring.py
--rwxr-xr-x   0        0        0     3830 2023-03-21 16:33:00.588994 solidpython2-2.0.0b4/solid2/extensions/bosl2_generator.py
--rw-r--r--   0        0        0      264 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__init__.py
--rw-r--r--   0        0        0      491 2022-12-15 09:17:23.702920 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0      475 2022-08-12 15:59:23.623930 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/__init__.cpython-38.pyc
--rw-r--r--   0        0        0     2472 2023-03-19 13:06:07.916877 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/customizer_widgets.cpython-310.pyc
--rw-r--r--   0        0        0     2602 2022-11-04 17:06:42.607231 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/customizer_widgets.cpython-38.pyc
--rw-r--r--   0        0        0     1865 2023-03-15 13:31:51.797247 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/scad_interface.cpython-310.pyc
--rw-r--r--   0        0        0     2010 2022-08-12 15:59:23.627930 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/scad_interface.cpython-38.pyc
--rw-r--r--   0        0        0     1388 2023-03-19 10:51:20.593500 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/scad_variable.cpython-310.pyc
--rw-r--r--   0        0        0     6322 2022-11-04 17:06:42.611231 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/__pycache__/scad_variable.cpython-38.pyc
--rw-r--r--   0        0        0     1647 2023-03-19 12:43:05.633475 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/customizer_widgets.py
--rw-r--r--   0        0        0      871 2023-03-15 13:23:46.114122 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/scad_interface.py
--rw-r--r--   0        0        0     1034 2023-03-19 03:02:37.644529 solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/scad_variable.py
--rwxr-xr-x   0        0        0     3570 2023-03-22 15:09:19.365226 solidpython2-2.0.0b4/solid2/extensions/openscad_extension_generator.py
--rw-r--r--   0        0        0     2142 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/CONTRIBUTING.md
--rw-r--r--   0        0        0     1323 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/LICENSE
--rw-r--r--   0        0        0     2895 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/README.md
--rw-r--r--   0        0        0    37745 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/WRITING_DOCS.md
--rw-r--r--   0        0        0    16829 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/affine.scad
--rw-r--r--   0        0        0   136954 2022-08-12 15:59:10.187877 solidpython2-2.0.0b4/solid2/libs/BOSL2/attachments.scad
--rw-r--r--   0        0        0    73284 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/beziers.scad
--rw-r--r--   0        0        0     3677 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/bosl1compat.scad
--rw-r--r--   0        0        0    46336 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/bottlecaps.scad
--rw-r--r--   0        0        0     1257 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/builtins.scad
--rw-r--r--   0        0        0     7630 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/color.scad
--rw-r--r--   0        0        0    33970 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/comparisons.scad
--rw-r--r--   0        0        0     8574 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/constants.scad
--rw-r--r--   0        0        0    18570 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/coords.scad
--rw-r--r--   0        0        0    26314 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/cubetruss.scad
--rw-r--r--   0        0        0    53512 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/distributors.scad
--rw-r--r--   0        0        0    59181 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/drawing.scad
--rw-r--r--   0        0        0    56993 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/fnliterals.scad
--rw-r--r--   0        0        0    62445 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/gears.scad
--rw-r--r--   0        0        0   125013 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/geometry.scad
--rw-r--r--   0        0        0     8985 2022-08-12 15:59:10.191877 solidpython2-2.0.0b4/solid2/libs/BOSL2/hingesnaps.scad
--rw-r--r--   0        0        0   117043 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/images/BOSL2logo.png
--rw-r--r--   0        0        0    55357 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/joiners.scad
--rw-r--r--   0        0        0    30685 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/linalg.scad
--rw-r--r--   0        0        0     5326 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/linear_bearings.scad
--rw-r--r--   0        0        0    45059 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/lists.scad
--rw-r--r--   0        0        0    21402 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/masks2d.scad
--rw-r--r--   0        0        0    21715 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/masks3d.scad
--rw-r--r--   0        0        0    54660 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/math.scad
--rw-r--r--   0        0        0    23837 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/metric_screws.scad
--rw-r--r--   0        0        0     8826 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/modular_hose.scad
--rw-r--r--   0        0        0    19913 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/mutators.scad
--rw-r--r--   0        0        0    28200 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/nema_steppers.scad
--rw-r--r--   0        0        0    23428 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/partitions.scad
--rw-r--r--   0        0        0    53553 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/paths.scad
--rw-r--r--   0        0        0    44043 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/polyhedra.scad
--rw-r--r--   0        0        0    60064 2022-08-12 15:59:10.195877 solidpython2-2.0.0b4/solid2/libs/BOSL2/regions.scad
--rw-r--r--   0        0        0   217671 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/rounding.scad
--rw-r--r--   0        0        0    11432 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/screw_drive.scad
--rw-r--r--   0        0        0    79822 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/screws.scad
--rwxr-xr-x   0        0        0      115 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/check_for_tabs.sh
--rwxr-xr-x   0        0        0     2784 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/func_coverage.py
--rwxr-xr-x   0        0        0     2345 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/img2scad.py
--rwxr-xr-x   0        0        0      545 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/increment_version.sh
--rwxr-xr-x   0        0        0      511 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/linecount.sh
--rwxr-xr-x   0        0        0      368 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/purge_wiki_history.sh
--rwxr-xr-x   0        0        0      790 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/scripts/run_tests.sh
--rw-r--r--   0        0        0    79782 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/shapes2d.scad
--rw-r--r--   0        0        0   148367 2022-08-12 15:59:10.199877 solidpython2-2.0.0b4/solid2/libs/BOSL2/shapes3d.scad
--rw-r--r--   0        0        0   161752 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/skin.scad
--rw-r--r--   0        0        0     6613 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/sliders.scad
--rw-r--r--   0        0        0     1071 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/std.scad
--rw-r--r--   0        0        0    33384 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/strings.scad
--rw-r--r--   0        0        0     5016 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/structs.scad
--rw-r--r--   0        0        0      186 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tests/README.txt
--rw-r--r--   0        0        0    61268 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/threading.scad
--rw-r--r--   0        0        0    59856 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/transforms.scad
--rw-r--r--   0        0        0    15311 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/trigonometry.scad
--rw-r--r--   0        0        0     4151 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tripod_mounts.scad
--rw-r--r--   0        0        0    47847 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/turtle3d.scad
--rw-r--r--   0        0        0    34615 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Attachments.md
--rw-r--r--   0        0        0     6240 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Distributors.md
--rw-r--r--   0        0        0     3329 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/FractalTree.md
--rw-r--r--   0        0        0     7580 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Mutators.md
--rw-r--r--   0        0        0    14849 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Paths.md
--rw-r--r--   0        0        0    19937 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Shapes2d.md
--rw-r--r--   0        0        0     9378 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Shapes3d.md
--rw-r--r--   0        0        0     6679 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/Transforms.md
--rw-r--r--   0        0        0     7054 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/tutorials/VNF.md
--rw-r--r--   0        0        0    37101 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/utility.scad
--rw-r--r--   0        0        0    25139 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/vectors.scad
--rw-r--r--   0        0        0     6047 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/version.scad
--rw-r--r--   0        0        0    73918 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/vnf.scad
--rw-r--r--   0        0        0    15623 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/walls.scad
--rw-r--r--   0        0        0     3421 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/BOSL2/wiring.scad
--rw-r--r--   0        0        0        0 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/__init__.py
--rw-r--r--   0        0        0      156 2022-12-15 10:15:59.164791 solidpython2-2.0.0b4/solid2/libs/__pycache__/__init__.cpython-310.pyc
--rw-r--r--   0        0        0      142 2022-08-12 15:59:23.631930 solidpython2-2.0.0b4/solid2/libs/__pycache__/__init__.cpython-38.pyc
--rw-r--r--   0        0        0     7048 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/py_scadparser/LICENSE
--rw-r--r--   0        0        0      640 2022-08-12 15:59:10.203877 solidpython2-2.0.0b4/solid2/libs/py_scadparser/README.md
--rw-r--r--   0        0        0    44957 2023-03-21 17:34:01.432396 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/parsetab.cpython-310.pyc
--rw-r--r--   0        0        0    34111 2022-08-12 15:50:00.790398 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/parsetab.cpython-38.pyc
--rw-r--r--   0        0        0     3335 2023-03-21 17:34:01.396396 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_ast.cpython-310.pyc
--rw-r--r--   0        0        0     2735 2022-08-12 15:59:23.635930 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_ast.cpython-38.pyc
--rw-r--r--   0        0        0    10330 2023-03-21 16:33:13.380780 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_parser.cpython-310.pyc
--rw-r--r--   0        0        0    10490 2022-08-12 15:49:20.526338 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_parser.cpython-38.pyc
--rw-r--r--   0        0        0     2848 2023-03-21 16:33:13.384780 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_tokens.cpython-310.pyc
--rw-r--r--   0        0        0     2977 2022-08-12 15:50:00.766398 solidpython2-2.0.0b4/solid2/libs/py_scadparser/__pycache__/scad_tokens.cpython-38.pyc
--rw-r--r--   0        0        0    48312 2023-03-23 17:47:21.609266 solidpython2-2.0.0b4/solid2/libs/py_scadparser/parsetab.py
--rw-r--r--   0        0        0     1229 2023-03-23 17:47:21.609266 solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_ast.py
--rw-r--r--   0        0        0     8328 2023-03-23 17:47:21.609266 solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_parser.py
--rw-r--r--   0        0        0     2745 2023-03-21 16:32:26.613592 solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_tokens.py
--rw-r--r--   0        0        0    24644 1970-01-01 00:00:00.000000 solidpython2-2.0.0b4/setup.py
--rw-r--r--   0        0        0    24248 1970-01-01 00:00:00.000000 solidpython2-2.0.0b4/PKG-INFO
+-rw-r--r--   0        0        0    22930 2023-03-15 13:23:46.110122 solidpython2-2.0.1/README.rst
+-rw-r--r--   0        0        0     1116 2023-04-11 17:10:49.921489 solidpython2-2.0.1/pyproject.toml
+-rw-r--r--   0        0        0      108 2023-03-16 11:22:53.244444 solidpython2-2.0.1/solid2/__init__.py
+-rw-r--r--   0        0        0     1687 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/config.py
+-rw-r--r--   0        0        0      381 2023-03-15 13:33:52.945033 solidpython2-2.0.1/solid2/core/__init__.py
+-rw-r--r--   0        0        0       53 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/__init__.py
+-rw-r--r--   0        0        0     3633 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/convenience.py
+-rw-r--r--   0        0        0     1040 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/implicit.primitives
+-rw-r--r--   0        0        0      754 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/openscad.mutators
+-rw-r--r--   0        0        0     1968 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/openscad.primitives
+-rw-r--r--   0        0        0    25400 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/openscad_primitives.py
+-rw-r--r--   0        0        0      367 2023-03-20 22:35:21.713279 solidpython2-2.0.1/solid2/core/builtins/primitives.py
+-rw-r--r--   0        0        0      938 2022-09-03 20:01:15.234639 solidpython2-2.0.1/solid2/core/extension_manager.py
+-rw-r--r--   0        0        0       32 2023-03-19 13:30:20.199884 solidpython2-2.0.1/solid2/core/object_base/__init__.py
+-rw-r--r--   0        0        0     3522 2023-03-20 14:58:07.769013 solidpython2-2.0.1/solid2/core/object_base/access_syntax_mixin.py
+-rw-r--r--   0        0        0     6839 2023-03-23 17:47:21.609266 solidpython2-2.0.1/solid2/core/object_base/object_base_impl.py
+-rw-r--r--   0        0        0     2253 2023-03-20 14:58:07.769013 solidpython2-2.0.1/solid2/core/object_base/operator_mixin.py
+-rw-r--r--   0        0        0     3994 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/core/object_factory.py
+-rw-r--r--   0        0        0     3469 2023-03-21 17:35:24.083900 solidpython2-2.0.1/solid2/core/parse_scad.py
+-rw-r--r--   0        0        0     5493 2023-03-19 13:30:20.199884 solidpython2-2.0.1/solid2/core/scad_import.py
+-rw-r--r--   0        0        0     3049 2023-03-23 17:47:21.609266 solidpython2-2.0.1/solid2/core/scad_render.py
+-rw-r--r--   0        0        0     2152 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/core/utils.py
+-rwxr-xr-x   0        0        0      559 2023-03-15 22:53:12.381332 solidpython2-2.0.1/solid2/examples/01-basics.py
+-rwxr-xr-x   0        0        0      846 2023-03-15 22:55:23.517187 solidpython2-2.0.1/solid2/examples/02-vars-and-operators.py
+-rwxr-xr-x   0        0        0      647 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/examples/03-debug-background.py
+-rwxr-xr-x   0        0        0     1272 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/examples/04-convenience.py
+-rwxr-xr-x   0        0        0      934 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/examples/05-access-style-syntax.py
+-rwxr-xr-x   0        0        0     1182 2023-03-15 22:58:40.236989 solidpython2-2.0.1/solid2/examples/06-functions.py
+-rwxr-xr-x   0        0        0      527 2023-03-19 11:58:59.349891 solidpython2-2.0.1/solid2/examples/07-libs-bosl2-attachable.py
+-rw-r--r--   0        0        0     3329 2023-04-11 09:39:25.912704 solidpython2-2.0.1/solid2/examples/07-libs-bosl2-logo.py
+-rwxr-xr-x   0        0        0     1762 2023-03-20 14:58:07.769013 solidpython2-2.0.1/solid2/examples/07-libs-bosl2.py
+-rwxr-xr-x   0        0        0      620 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/examples/07-libs.py
+-rwxr-xr-x   0        0        0     2448 2023-03-20 14:58:07.769013 solidpython2-2.0.1/solid2/examples/08-extensions.py
+-rwxr-xr-x   0        0        0     1675 2022-12-15 10:19:43.476714 solidpython2-2.0.1/solid2/examples/09-code-attach-extension.py
+-rwxr-xr-x   0        0        0      889 2023-03-19 12:43:05.625475 solidpython2-2.0.1/solid2/examples/10-customizer.py
+-rw-r--r--   0        0        0      158 2022-08-12 15:59:10.183877 solidpython2-2.0.1/solid2/examples/11-font/LICENSE_README
+-rw-r--r--   0        0        0    47404 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/11-font/RichEatin.otf
+-rwxr-xr-x   0        0        0      192 2023-03-15 13:23:46.114122 solidpython2-2.0.1/solid2/examples/11-fonts.py
+-rwxr-xr-x   0        0        0      335 2023-03-15 13:23:46.114122 solidpython2-2.0.1/solid2/examples/12-animation.py
+-rwxr-xr-x   0        0        0     2032 2023-03-19 12:43:05.625475 solidpython2-2.0.1/solid2/examples/13-animated-bouncing-ball.py
+-rwxr-xr-x   0        0        0     1381 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/14-implicitCAD.py
+-rwxr-xr-x   0        0        0     1794 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/15-implicitCAD2.py
+-rwxr-xr-x   0        0        0     1102 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/16-mazebox-bosl2.py
+-rwxr-xr-x   0        0        0     2243 2023-03-15 13:23:46.114122 solidpython2-2.0.1/solid2/examples/17-greedy-scad-interface.py
+-rw-r--r--   0        0        0     1196 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/maze7.png
+-rwxr-xr-x   0        0        0      293 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/examples/run_all_examples.py
+-rw-r--r--   0        0        0        1 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/extensions/__init__.py
+-rw-r--r--   0        0        0      210 2023-04-11 09:14:35.909512 solidpython2-2.0.1/solid2/extensions/bosl2/__init__.py
+-rw-r--r--   0        0        0     3320 2023-04-11 17:06:59.193743 solidpython2-2.0.1/solid2/extensions/bosl2/affine.py
+-rw-r--r--   0        0        0    13304 2023-04-11 17:07:00.797742 solidpython2-2.0.1/solid2/extensions/bosl2/attachments.py
+-rw-r--r--   0        0        0      880 2023-04-11 17:07:00.089742 solidpython2-2.0.1/solid2/extensions/bosl2/ball_bearings.py
+-rw-r--r--   0        0        0     7575 2023-04-11 17:06:59.361743 solidpython2-2.0.1/solid2/extensions/bosl2/beziers.py
+-rw-r--r--   0        0        0    17177 2023-04-11 17:07:38.985699 solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_access_syntax_mixin.py
+-rw-r--r--   0        0        0     1002 2023-04-11 09:15:15.373553 solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_base.py
+-rw-r--r--   0        0        0      611 2023-04-11 09:15:20.845559 solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_patches.py
+-rw-r--r--   0        0        0    10958 2023-04-11 17:06:59.285743 solidpython2-2.0.1/solid2/extensions/bosl2/bottlecaps.py
+-rw-r--r--   0        0        0     1542 2023-04-11 17:06:59.617743 solidpython2-2.0.1/solid2/extensions/bosl2/color.py
+-rw-r--r--   0        0        0     7216 2023-04-11 17:06:59.181743 solidpython2-2.0.1/solid2/extensions/bosl2/comparisons.py
+-rw-r--r--   0        0        0     1140 2023-04-11 17:06:59.557743 solidpython2-2.0.1/solid2/extensions/bosl2/constants.py
+-rw-r--r--   0        0        0     3012 2023-04-11 17:07:00.637742 solidpython2-2.0.1/solid2/extensions/bosl2/coords.py
+-rw-r--r--   0        0        0     3619 2023-04-11 17:07:00.817741 solidpython2-2.0.1/solid2/extensions/bosl2/cubetruss.py
+-rw-r--r--   0        0        0    10737 2023-04-11 17:07:41.925695 solidpython2-2.0.1/solid2/extensions/bosl2/distributors.py
+-rw-r--r--   0        0        0     8138 2023-04-11 17:07:00.341742 solidpython2-2.0.1/solid2/extensions/bosl2/drawing.py
+-rw-r--r--   0        0        0    12656 2023-04-11 17:06:59.321743 solidpython2-2.0.1/solid2/extensions/bosl2/fnliterals.py
+-rw-r--r--   0        0        0    12640 2023-04-11 17:06:59.725743 solidpython2-2.0.1/solid2/extensions/bosl2/gears.py
+-rw-r--r--   0        0        0    19280 2023-04-11 17:06:59.797742 solidpython2-2.0.1/solid2/extensions/bosl2/geometry.py
+-rw-r--r--   0        0        0     5048 2023-04-11 17:07:00.869741 solidpython2-2.0.1/solid2/extensions/bosl2/hinges.py
+-rw-r--r--   0        0        0     9521 2023-04-11 17:07:00.721742 solidpython2-2.0.1/solid2/extensions/bosl2/joiners.py
+-rw-r--r--   0        0        0     5628 2023-04-11 17:06:59.581743 solidpython2-2.0.1/solid2/extensions/bosl2/linalg.py
+-rw-r--r--   0        0        0     1831 2023-04-11 17:06:59.237743 solidpython2-2.0.1/solid2/extensions/bosl2/linear_bearings.py
+-rw-r--r--   0        0        0     6948 2023-04-11 17:06:59.217743 solidpython2-2.0.1/solid2/extensions/bosl2/lists.py
+-rw-r--r--   0        0        0     4347 2023-04-11 17:07:00.605742 solidpython2-2.0.1/solid2/extensions/bosl2/masks2d.py
+-rw-r--r--   0        0        0     8167 2023-04-11 17:07:00.289742 solidpython2-2.0.1/solid2/extensions/bosl2/masks3d.py
+-rw-r--r--   0        0        0    12664 2023-04-11 17:07:00.545742 solidpython2-2.0.1/solid2/extensions/bosl2/math.py
+-rw-r--r--   0        0        0     3783 2023-04-11 17:07:00.853741 solidpython2-2.0.1/solid2/extensions/bosl2/metric_screws.py
+-rw-r--r--   0        0        0     1359 2023-04-11 17:07:00.825741 solidpython2-2.0.1/solid2/extensions/bosl2/modular_hose.py
+-rw-r--r--   0        0        0     2335 2023-04-11 17:07:00.505742 solidpython2-2.0.1/solid2/extensions/bosl2/mutators.py
+-rw-r--r--   0        0        0     1189 2023-04-11 17:07:00.645742 solidpython2-2.0.1/solid2/extensions/bosl2/nema_steppers.py
+-rw-r--r--   0        0        0     6047 2023-04-11 17:07:00.905741 solidpython2-2.0.1/solid2/extensions/bosl2/openscad.py
+-rw-r--r--   0        0        0     4057 2023-04-11 17:06:59.233743 solidpython2-2.0.1/solid2/extensions/bosl2/partitions.py
+-rw-r--r--   0        0        0     7789 2023-04-11 17:07:00.153742 solidpython2-2.0.1/solid2/extensions/bosl2/paths.py
+-rw-r--r--   0        0        0     3389 2023-04-11 17:06:59.613743 solidpython2-2.0.1/solid2/extensions/bosl2/polyhedra.py
+-rw-r--r--   0        0        0     7756 2023-04-11 17:07:00.905741 solidpython2-2.0.1/solid2/extensions/bosl2/regions.py
+-rw-r--r--   0        0        0    20790 2023-04-11 17:06:59.905743 solidpython2-2.0.1/solid2/extensions/bosl2/rounding.py
+-rw-r--r--   0        0        0     3054 2023-04-11 17:07:00.589742 solidpython2-2.0.1/solid2/extensions/bosl2/screw_drive.py
+-rw-r--r--   0        0        0    14579 2023-04-11 17:06:59.557743 solidpython2-2.0.1/solid2/extensions/bosl2/screws.py
+-rw-r--r--   0        0        0    14152 2023-04-11 17:06:59.681743 solidpython2-2.0.1/solid2/extensions/bosl2/shapes2d.py
+-rw-r--r--   0        0        0    26883 2023-04-11 17:07:43.537693 solidpython2-2.0.1/solid2/extensions/bosl2/shapes3d.py
+-rw-r--r--   0        0        0    17226 2023-04-11 17:07:44.613692 solidpython2-2.0.1/solid2/extensions/bosl2/skin.py
+-rw-r--r--   0        0        0     1597 2023-04-11 17:07:00.577742 solidpython2-2.0.1/solid2/extensions/bosl2/sliders.py
+-rw-r--r--   0        0        0      679 2023-04-11 17:06:58.953744 solidpython2-2.0.1/solid2/extensions/bosl2/std.py
+-rw-r--r--   0        0        0     7258 2023-04-11 17:07:00.625742 solidpython2-2.0.1/solid2/extensions/bosl2/strings.py
+-rw-r--r--   0        0        0     1722 2023-04-11 17:07:00.121742 solidpython2-2.0.1/solid2/extensions/bosl2/structs.py
+-rw-r--r--   0        0        0    36862 2023-04-11 17:07:00.209742 solidpython2-2.0.1/solid2/extensions/bosl2/threading.py
+-rw-r--r--   0        0        0     8561 2023-04-11 17:06:59.937742 solidpython2-2.0.1/solid2/extensions/bosl2/transforms.py
+-rw-r--r--   0        0        0     4786 2023-04-11 17:06:59.909742 solidpython2-2.0.1/solid2/extensions/bosl2/trigonometry.py
+-rw-r--r--   0        0        0      611 2023-04-11 17:07:00.569742 solidpython2-2.0.1/solid2/extensions/bosl2/tripod_mounts.py
+-rw-r--r--   0        0        0     3060 2023-04-11 17:07:00.113742 solidpython2-2.0.1/solid2/extensions/bosl2/turtle3d.py
+-rw-r--r--   0        0        0     7958 2023-04-11 17:07:00.561742 solidpython2-2.0.1/solid2/extensions/bosl2/utility.py
+-rw-r--r--   0        0        0     4557 2023-04-11 17:06:59.301743 solidpython2-2.0.1/solid2/extensions/bosl2/vectors.py
+-rw-r--r--   0        0        0     1772 2023-04-11 17:07:00.277742 solidpython2-2.0.1/solid2/extensions/bosl2/version.py
+-rw-r--r--   0        0        0     9788 2023-04-11 17:07:00.273742 solidpython2-2.0.1/solid2/extensions/bosl2/vnf.py
+-rw-r--r--   0        0        0     2165 2023-04-11 17:07:00.665742 solidpython2-2.0.1/solid2/extensions/bosl2/walls.py
+-rw-r--r--   0        0        0     1045 2023-04-11 17:06:59.181743 solidpython2-2.0.1/solid2/extensions/bosl2/wiring.py
+-rwxr-xr-x   0        0        0     3867 2023-04-11 09:39:25.920704 solidpython2-2.0.1/solid2/extensions/bosl2_generator.py
+-rw-r--r--   0        0        0      264 2022-08-12 15:59:10.187877 solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/__init__.py
+-rw-r--r--   0        0        0     1647 2023-03-19 12:43:05.633475 solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/customizer_widgets.py
+-rw-r--r--   0        0        0      871 2023-03-15 13:23:46.114122 solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/scad_interface.py
+-rw-r--r--   0        0        0     1034 2023-03-19 03:02:37.644529 solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/scad_variable.py
+-rwxr-xr-x   0        0        0     3570 2023-03-22 15:09:19.365226 solidpython2-2.0.1/solid2/extensions/openscad_extension_generator.py
+-rw-r--r--   0        0        0    18422 2023-04-11 17:10:49.921489 solidpython2-2.0.1/solid2/libs/BOSL2/affine.scad
+-rw-r--r--   0        0        0   158011 2023-04-11 17:10:49.921489 solidpython2-2.0.1/solid2/libs/BOSL2/attachments.scad
+-rw-r--r--   0        0        0    10326 2023-04-11 17:10:49.921489 solidpython2-2.0.1/solid2/libs/BOSL2/ball_bearings.scad
+-rw-r--r--   0        0        0    76076 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/beziers.scad
+-rw-r--r--   0        0        0     3557 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/bosl1compat.scad
+-rw-r--r--   0        0        0    53194 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/bottlecaps.scad
+-rw-r--r--   0        0        0     1257 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/builtins.scad
+-rw-r--r--   0        0        0     8302 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/color.scad
+-rw-r--r--   0        0        0    40080 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/comparisons.scad
+-rw-r--r--   0        0        0     9779 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/constants.scad
+-rw-r--r--   0        0        0    18570 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/coords.scad
+-rw-r--r--   0        0        0    28607 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/cubetruss.scad
+-rw-r--r--   0        0        0    88642 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/distributors.scad
+-rw-r--r--   0        0        0    62214 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/drawing.scad
+-rw-r--r--   0        0        0    56985 2023-04-11 17:10:49.925489 solidpython2-2.0.1/solid2/libs/BOSL2/fnliterals.scad
+-rw-r--r--   0        0        0    65959 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/gears.scad
+-rw-r--r--   0        0        0   125434 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/geometry.scad
+-rw-r--r--   0        0        0    31047 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/hinges.scad
+-rw-r--r--   0        0        0    58197 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/joiners.scad
+-rw-r--r--   0        0        0    31481 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/linalg.scad
+-rw-r--r--   0        0        0     8378 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/linear_bearings.scad
+-rw-r--r--   0        0        0    47932 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/lists.scad
+-rw-r--r--   0        0        0    24740 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/masks2d.scad
+-rw-r--r--   0        0        0    26185 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/masks3d.scad
+-rw-r--r--   0        0        0    54569 2023-04-11 17:10:49.929489 solidpython2-2.0.1/solid2/libs/BOSL2/math.scad
+-rw-r--r--   0        0        0    23837 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/metric_screws.scad
+-rw-r--r--   0        0        0     9089 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/modular_hose.scad
+-rw-r--r--   0        0        0    21204 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/mutators.scad
+-rw-r--r--   0        0        0    10102 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/nema_steppers.scad
+-rw-r--r--   0        0        0    25544 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/partitions.scad
+-rw-r--r--   0        0        0    55148 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/paths.scad
+-rw-r--r--   0        0        0    44343 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/polyhedra.scad
+-rw-r--r--   0        0        0    62670 2023-04-11 17:10:49.933489 solidpython2-2.0.1/solid2/libs/BOSL2/regions.scad
+-rw-r--r--   0        0        0   220660 2023-04-11 17:10:49.937489 solidpython2-2.0.1/solid2/libs/BOSL2/rounding.scad
+-rw-r--r--   0        0        0    14301 2023-04-11 17:10:49.937489 solidpython2-2.0.1/solid2/libs/BOSL2/screw_drive.scad
+-rw-r--r--   0        0        0   179010 2023-04-11 17:10:49.937489 solidpython2-2.0.1/solid2/libs/BOSL2/screws.scad
+-rw-r--r--   0        0        0    91055 2023-04-11 17:10:49.937489 solidpython2-2.0.1/solid2/libs/BOSL2/shapes2d.scad
+-rw-r--r--   0        0        0   181418 2023-04-11 17:10:49.937489 solidpython2-2.0.1/solid2/libs/BOSL2/shapes3d.scad
+-rw-r--r--   0        0        0   238386 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/skin.scad
+-rw-r--r--   0        0        0     6786 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/sliders.scad
+-rw-r--r--   0        0        0     1071 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/std.scad
+-rw-r--r--   0        0        0    34155 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/strings.scad
+-rw-r--r--   0        0        0     5355 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/structs.scad
+-rw-r--r--   0        0        0   102085 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/threading.scad
+-rw-r--r--   0        0        0    63253 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/transforms.scad
+-rw-r--r--   0        0        0    15310 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/trigonometry.scad
+-rw-r--r--   0        0        0     4103 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/tripod_mounts.scad
+-rw-r--r--   0        0        0    48075 2023-04-11 17:10:49.941489 solidpython2-2.0.1/solid2/libs/BOSL2/turtle3d.scad
+-rw-r--r--   0        0        0    37770 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/utility.scad
+-rw-r--r--   0        0        0    25847 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/vectors.scad
+-rw-r--r--   0        0        0     6572 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/version.scad
+-rw-r--r--   0        0        0    85308 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/vnf.scad
+-rw-r--r--   0        0        0    16411 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/walls.scad
+-rw-r--r--   0        0        0     3545 2023-04-11 17:10:49.945489 solidpython2-2.0.1/solid2/libs/BOSL2/wiring.scad
+-rw-r--r--   0        0        0        0 2022-08-12 15:59:10.203877 solidpython2-2.0.1/solid2/libs/__init__.py
+-rw-r--r--   0        0        0     7048 2022-08-12 15:59:10.203877 solidpython2-2.0.1/solid2/libs/py_scadparser/LICENSE
+-rw-r--r--   0        0        0      640 2022-08-12 15:59:10.203877 solidpython2-2.0.1/solid2/libs/py_scadparser/README.md
+-rw-r--r--   0        0        0    48312 2023-03-23 17:47:21.609266 solidpython2-2.0.1/solid2/libs/py_scadparser/parsetab.py
+-rw-r--r--   0        0        0     1229 2023-03-23 17:47:21.609266 solidpython2-2.0.1/solid2/libs/py_scadparser/scad_ast.py
+-rw-r--r--   0        0        0     8328 2023-03-23 17:47:21.609266 solidpython2-2.0.1/solid2/libs/py_scadparser/scad_parser.py
+-rw-r--r--   0        0        0     2745 2023-03-21 16:32:26.613592 solidpython2-2.0.1/solid2/libs/py_scadparser/scad_tokens.py
+-rw-r--r--   0        0        0    24503 1970-01-01 00:00:00.000000 solidpython2-2.0.1/setup.py
+-rw-r--r--   0        0        0    24246 1970-01-01 00:00:00.000000 solidpython2-2.0.1/PKG-INFO
```

### Comparing `solidpython2-2.0.0b4/README.rst` & `solidpython2-2.0.1/README.rst`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/pyproject.toml` & `solidpython2-2.0.1/pyproject.toml`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "solidpython2"
-version = "2.0.0-beta-04"
+version = "2.0.1"
 description = "Python interface to the OpenSCAD declarative geometry language"
 authors = ["jeff"]
 homepage = "https://github.com/jeff-dh/SolidPython"
 repository = "https://github.com/jeff-dh/SolidPython"
 license = "LGPL-2.1"
 readme = "README.rst"
 keywords = [
```

### Comparing `solidpython2-2.0.0b4/solid2/config.py` & `solidpython2-2.0.1/solid2/config.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/builtins/convenience.py` & `solidpython2-2.0.1/solid2/core/builtins/convenience.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/builtins/implicit.primitives` & `solidpython2-2.0.1/solid2/core/builtins/implicit.primitives`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/builtins/openscad.mutators` & `solidpython2-2.0.1/solid2/core/builtins/openscad.mutators`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/builtins/openscad.primitives` & `solidpython2-2.0.1/solid2/core/builtins/openscad.primitives`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/builtins/openscad_primitives.py` & `solidpython2-2.0.1/solid2/core/builtins/openscad_primitives.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/extension_manager.py` & `solidpython2-2.0.1/solid2/core/extension_manager.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/object_base/access_syntax_mixin.py` & `solidpython2-2.0.1/solid2/core/object_base/access_syntax_mixin.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/object_base/object_base_impl.py` & `solidpython2-2.0.1/solid2/core/object_base/object_base_impl.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/object_base/operator_mixin.py` & `solidpython2-2.0.1/solid2/core/object_base/operator_mixin.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/object_factory.py` & `solidpython2-2.0.1/solid2/core/object_factory.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/parse_scad.py` & `solidpython2-2.0.1/solid2/core/parse_scad.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/scad_import.py` & `solidpython2-2.0.1/solid2/core/scad_import.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/scad_render.py` & `solidpython2-2.0.1/solid2/core/scad_render.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/core/utils.py` & `solidpython2-2.0.1/solid2/core/utils.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/01-basics.py` & `solidpython2-2.0.1/solid2/examples/01-basics.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/02-vars-and-operators.py` & `solidpython2-2.0.1/solid2/examples/02-vars-and-operators.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/03-debug-background.py` & `solidpython2-2.0.1/solid2/examples/03-debug-background.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/04-convenience.py` & `solidpython2-2.0.1/solid2/examples/04-convenience.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/05-access-style-syntax.py` & `solidpython2-2.0.1/solid2/examples/05-access-style-syntax.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/06-functions.py` & `solidpython2-2.0.1/solid2/examples/06-functions.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-attachable.py` & `solidpython2-2.0.1/solid2/examples/07-libs-bosl2-attachable.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2-logo.py` & `solidpython2-2.0.1/solid2/examples/07-libs-bosl2-logo.py`

 * *Files 5% similar despite different names*

```diff
@@ -93,15 +93,15 @@
 	# 			nut("M12", thickness=10, diameter=20);
 	# 	screw("M12,70", head="hex", anchor="origin", orient=BACK)
 	# 		attach(BOT,CENTER)
 	# 			nut("M12", thickness=10, diameter=20);
 	# }
 
     screw = screws.screw("M12,70", head="hex", anchor="origin", orient=BACK)
-    nut = screws.nut("M12", thickness=10, diameter=20)
+    nut = screws.nut("M12", thickness=10)
 
     screw.add(nut.attach(BOT, CENTER))
 
     return xdistribute(24)(screw, screw).recolor("#777")
 
 # xdistribute(50) { [...] }
 xdistribute(50)(B(), O(), S(), L(), II()).save_as_scad()
```

### Comparing `solidpython2-2.0.0b4/solid2/examples/07-libs-bosl2.py` & `solidpython2-2.0.1/solid2/examples/07-libs-bosl2.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/07-libs.py` & `solidpython2-2.0.1/solid2/examples/07-libs.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/08-extensions.py` & `solidpython2-2.0.1/solid2/examples/08-extensions.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/09-code-attach-extension.py` & `solidpython2-2.0.1/solid2/examples/09-code-attach-extension.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/10-customizer.py` & `solidpython2-2.0.1/solid2/examples/10-customizer.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/11-font/RichEatin.otf` & `solidpython2-2.0.1/solid2/examples/11-font/RichEatin.otf`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/13-animated-bouncing-ball.py` & `solidpython2-2.0.1/solid2/examples/13-animated-bouncing-ball.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/14-implicitCAD.py` & `solidpython2-2.0.1/solid2/examples/14-implicitCAD.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/15-implicitCAD2.py` & `solidpython2-2.0.1/solid2/examples/15-implicitCAD2.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/16-mazebox-bosl2.py` & `solidpython2-2.0.1/solid2/examples/16-mazebox-bosl2.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/17-greedy-scad-interface.py` & `solidpython2-2.0.1/solid2/examples/17-greedy-scad-interface.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/examples/maze7.png` & `solidpython2-2.0.1/solid2/examples/maze7.png`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/affine.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/affine.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/attachments.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/attachments.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,24 +26,28 @@
 EDGES_NONE = _OpenSCADConstant('EDGES_NONE')
 EDGES_ALL = _OpenSCADConstant('EDGES_ALL')
 EDGE_OFFSETS = _OpenSCADConstant('EDGE_OFFSETS')
 CORNERS_NONE = _OpenSCADConstant('CORNERS_NONE')
 CORNERS_ALL = _OpenSCADConstant('CORNERS_ALL')
 CORNER_OFFSETS = _OpenSCADConstant('CORNER_OFFSETS')
 class reorient(_Bosl2Base):
-    def __init__(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, offset=None, cp=None, anchors=None, two_d=None, axis=None, geom=None, p=None, **kwargs):
-       super().__init__("reorient", {"anchor" : anchor, "spin" : spin, "orient" : orient, "size" : size, "size2" : size2, "shift" : shift, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "path" : path, "region" : region, "extent" : extent, "offset" : offset, "cp" : cp, "anchors" : anchors, "two_d" : two_d, "axis" : axis, "geom" : geom, "p" : p, **kwargs})
+    def __init__(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, offset=None, cp=None, anchors=None, two_d=None, axis=None, override=None, geom=None, p=None, **kwargs):
+       super().__init__("reorient", {"anchor" : anchor, "spin" : spin, "orient" : orient, "size" : size, "size2" : size2, "shift" : shift, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "path" : path, "region" : region, "extent" : extent, "offset" : offset, "cp" : cp, "anchors" : anchors, "two_d" : two_d, "axis" : axis, "override" : override, "geom" : geom, "p" : p, **kwargs})
 
 class named_anchor(_Bosl2Base):
     def __init__(self, name=None, pos=None, orient=None, spin=None, **kwargs):
        super().__init__("named_anchor", {"name" : name, "pos" : pos, "orient" : orient, "spin" : spin, **kwargs})
 
+class _local_struct_val(_Bosl2Base):
+    def __init__(self, struct=None, key=None, **kwargs):
+       super().__init__("_local_struct_val", {"struct" : struct, "key" : key, **kwargs})
+
 class attach_geom(_Bosl2Base):
-    def __init__(self, size=None, size2=None, shift=None, scale=None, twist=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, **kwargs):
-       super().__init__("attach_geom", {"size" : size, "size2" : size2, "shift" : shift, "scale" : scale, "twist" : twist, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "region" : region, "extent" : extent, "cp" : cp, "offset" : offset, "anchors" : anchors, "two_d" : two_d, "axis" : axis, **kwargs})
+    def __init__(self, size=None, size2=None, shift=None, scale=None, twist=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, override=None, **kwargs):
+       super().__init__("attach_geom", {"size" : size, "size2" : size2, "shift" : shift, "scale" : scale, "twist" : twist, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "region" : region, "extent" : extent, "cp" : cp, "offset" : offset, "anchors" : anchors, "two_d" : two_d, "axis" : axis, "override" : override, **kwargs})
 
 class _attach_geom_2d(_Bosl2Base):
     def __init__(self, geom=None, **kwargs):
        super().__init__("_attach_geom_2d", {"geom" : geom, **kwargs})
 
 class _attach_geom_size(_Bosl2Base):
     def __init__(self, geom=None, **kwargs):
@@ -53,14 +57,18 @@
     def __init__(self, anchor=None, spin=None, orient=None, geom=None, p=None, **kwargs):
        super().__init__("_attach_transform", {"anchor" : anchor, "spin" : spin, "orient" : orient, "geom" : geom, "p" : p, **kwargs})
 
 class _get_cp(_Bosl2Base):
     def __init__(self, geom=None, **kwargs):
        super().__init__("_get_cp", {"geom" : geom, **kwargs})
 
+class _get_cp(_Bosl2Base):
+    def __init__(self, geom=None, **kwargs):
+       super().__init__("_get_cp", {"geom" : geom, **kwargs})
+
 class _force_anchor_2d(_Bosl2Base):
     def __init__(self, anchor=None, **kwargs):
        super().__init__("_force_anchor_2d", {"anchor" : anchor, **kwargs})
 
 class _find_anchor(_Bosl2Base):
     def __init__(self, anchor=None, geom=None, **kwargs):
        super().__init__("_find_anchor", {"anchor" : anchor, "geom" : geom, **kwargs})
@@ -126,29 +134,33 @@
        super().__init__("_corners_text", {"corners" : corners, **kwargs})
 
 class position(_Bosl2Base):
     def __init__(self, _from=None, **kwargs):
        super().__init__("position", {"_from" : _from, **kwargs})
 
 class orient(_Bosl2Base):
-    def __init__(self, dir=None, anchor=None, spin=None, **kwargs):
-       super().__init__("orient", {"dir" : dir, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, anchor=None, spin=None, **kwargs):
+       super().__init__("orient", {"anchor" : anchor, "spin" : spin, **kwargs})
 
 class attach(_Bosl2Base):
     def __init__(self, _from=None, to=None, overlap=None, norot=None, **kwargs):
        super().__init__("attach", {"_from" : _from, "to" : to, "overlap" : overlap, "norot" : norot, **kwargs})
 
 class tag(_Bosl2Base):
     def __init__(self, tag=None, **kwargs):
        super().__init__("tag", {"tag" : tag, **kwargs})
 
 class force_tag(_Bosl2Base):
     def __init__(self, tag=None, **kwargs):
        super().__init__("force_tag", {"tag" : tag, **kwargs})
 
+class default_tag(_Bosl2Base):
+    def __init__(self, tag=None, **kwargs):
+       super().__init__("default_tag", {"tag" : tag, **kwargs})
+
 class tag_scope(_Bosl2Base):
     def __init__(self, scope=None, **kwargs):
        super().__init__("tag_scope", {"scope" : scope, **kwargs})
 
 class diff(_Bosl2Base):
     def __init__(self, remove=None, keep=None, **kwargs):
        super().__init__("diff", {"remove" : remove, "keep" : keep, **kwargs})
@@ -185,14 +197,18 @@
     def __init__(self, **kwargs):
        super().__init__("show_all", {**kwargs})
 
 class show_int(_Bosl2Base):
     def __init__(self, tags=None, **kwargs):
        super().__init__("show_int", {"tags" : tags, **kwargs})
 
+class face_mask(_Bosl2Base):
+    def __init__(self, faces=None, **kwargs):
+       super().__init__("face_mask", {"faces" : faces, **kwargs})
+
 class edge_mask(_Bosl2Base):
     def __init__(self, edges=None, _except=None, **kwargs):
        super().__init__("edge_mask", {"edges" : edges, "_except" : _except, **kwargs})
 
 class corner_mask(_Bosl2Base):
     def __init__(self, corners=None, _except=None, **kwargs):
        super().__init__("corner_mask", {"corners" : corners, "_except" : _except, **kwargs})
@@ -206,24 +222,24 @@
        super().__init__("edge_profile", {"edges" : edges, "_except" : _except, "convexity" : convexity, **kwargs})
 
 class corner_profile(_Bosl2Base):
     def __init__(self, corners=None, _except=None, r=None, d=None, convexity=None, **kwargs):
        super().__init__("corner_profile", {"corners" : corners, "_except" : _except, "r" : r, "d" : d, "convexity" : convexity, **kwargs})
 
 class attachable(_Bosl2Base):
-    def __init__(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, geom=None, **kwargs):
-       super().__init__("attachable", {"anchor" : anchor, "spin" : spin, "orient" : orient, "size" : size, "size2" : size2, "shift" : shift, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "path" : path, "region" : region, "extent" : extent, "cp" : cp, "offset" : offset, "anchors" : anchors, "two_d" : two_d, "axis" : axis, "geom" : geom, **kwargs})
+    def __init__(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, override=None, geom=None, **kwargs):
+       super().__init__("attachable", {"anchor" : anchor, "spin" : spin, "orient" : orient, "size" : size, "size2" : size2, "shift" : shift, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "h" : h, "vnf" : vnf, "path" : path, "region" : region, "extent" : extent, "cp" : cp, "offset" : offset, "anchors" : anchors, "two_d" : two_d, "axis" : axis, "override" : override, "geom" : geom, **kwargs})
 
 class show_anchors(_Bosl2Base):
     def __init__(self, s=None, std=None, custom=None, **kwargs):
        super().__init__("show_anchors", {"s" : s, "std" : std, "custom" : custom, **kwargs})
 
 class anchor_arrow(_Bosl2Base):
-    def __init__(self, s=None, color=None, flag=None, _tag=None, **kwargs):
-       super().__init__("anchor_arrow", {"s" : s, "color" : color, "flag" : flag, "_tag" : _tag, **kwargs})
+    def __init__(self, s=None, color=None, flag=None, _tag=None, _fn=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("anchor_arrow", {"s" : s, "color" : color, "flag" : flag, "_tag" : _tag, "_fn" : _fn, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class anchor_arrow2d(_Bosl2Base):
     def __init__(self, s=None, color=None, _tag=None, **kwargs):
        super().__init__("anchor_arrow2d", {"s" : s, "color" : color, "_tag" : _tag, **kwargs})
 
 class expose_anchors(_Bosl2Base):
     def __init__(self, opacity=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/beziers.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/beziers.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_access_syntax_mixin.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_access_syntax_mixin.py`

 * *Files 4% similar despite different names*

```diff
@@ -106,32 +106,35 @@
 
     def zflip(self, p=None, z=None, **kwargs):
         return self._get_std().zflip(p, z, **kwargs)(self)
 
     def frame_map(self, x=None, y=None, z=None, p=None, reverse=None, **kwargs):
         return self._get_std().frame_map(x, y, z, p, reverse, **kwargs)(self)
 
-    def skew(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, **kwargs):
-        return self._get_std().skew(p, sxy, sxz, syx, syz, szx, szy, **kwargs)(self)
+    def skew(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, axy=None, axz=None, ayx=None, ayz=None, azx=None, azy=None, **kwargs):
+        return self._get_std().skew(p, sxy, sxz, syx, syz, szx, szy, axy, axz, ayx, ayz, azx, azy, **kwargs)(self)
 
     def position(self, _from=None, **kwargs):
         return self._get_std().position(_from, **kwargs)(self)
 
-    def orient(self, dir=None, anchor=None, spin=None, **kwargs):
-        return self._get_std().orient(dir, anchor, spin, **kwargs)(self)
+    def orient(self, anchor=None, spin=None, **kwargs):
+        return self._get_std().orient(anchor, spin, **kwargs)(self)
 
     def attach(self, _from=None, to=None, overlap=None, norot=None, **kwargs):
         return self._get_std().attach(_from, to, overlap, norot, **kwargs)(self)
 
     def tag(self, tag=None, **kwargs):
         return self._get_std().tag(tag, **kwargs)(self)
 
     def force_tag(self, tag=None, **kwargs):
         return self._get_std().force_tag(tag, **kwargs)(self)
 
+    def default_tag(self, tag=None, **kwargs):
+        return self._get_std().default_tag(tag, **kwargs)(self)
+
     def tag_scope(self, scope=None, **kwargs):
         return self._get_std().tag_scope(scope, **kwargs)(self)
 
     def diff(self, remove=None, keep=None, **kwargs):
         return self._get_std().diff(remove, keep, **kwargs)(self)
 
     def tag_diff(self, tag=None, remove=None, keep=None, **kwargs):
@@ -157,14 +160,17 @@
 
     def show_all(self, **kwargs):
         return self._get_std().show_all(**kwargs)(self)
 
     def show_int(self, tags=None, **kwargs):
         return self._get_std().show_int(tags, **kwargs)(self)
 
+    def face_mask(self, faces=None, **kwargs):
+        return self._get_std().face_mask(faces, **kwargs)(self)
+
     def edge_mask(self, edges=None, _except=None, **kwargs):
         return self._get_std().edge_mask(edges, _except, **kwargs)(self)
 
     def corner_mask(self, corners=None, _except=None, **kwargs):
         return self._get_std().corner_mask(corners, _except, **kwargs)(self)
 
     def face_profile(self, faces=None, r=None, d=None, convexity=None, **kwargs):
@@ -172,22 +178,22 @@
 
     def edge_profile(self, edges=None, _except=None, convexity=None, **kwargs):
         return self._get_std().edge_profile(edges, _except, convexity, **kwargs)(self)
 
     def corner_profile(self, corners=None, _except=None, r=None, d=None, convexity=None, **kwargs):
         return self._get_std().corner_profile(corners, _except, r, d, convexity, **kwargs)(self)
 
-    def attachable(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, geom=None, **kwargs):
-        return self._get_std().attachable(anchor, spin, orient, size, size2, shift, r, r1, r2, d, d1, d2, l, h, vnf, path, region, extent, cp, offset, anchors, two_d, axis, geom, **kwargs)(self)
+    def attachable(self, anchor=None, spin=None, orient=None, size=None, size2=None, shift=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, h=None, vnf=None, path=None, region=None, extent=None, cp=None, offset=None, anchors=None, two_d=None, axis=None, override=None, geom=None, **kwargs):
+        return self._get_std().attachable(anchor, spin, orient, size, size2, shift, r, r1, r2, d, d1, d2, l, h, vnf, path, region, extent, cp, offset, anchors, two_d, axis, override, geom, **kwargs)(self)
 
     def show_anchors(self, s=None, std=None, custom=None, **kwargs):
         return self._get_std().show_anchors(s, std, custom, **kwargs)(self)
 
-    def anchor_arrow(self, s=None, color=None, flag=None, _tag=None, **kwargs):
-        return self._get_std().anchor_arrow(s, color, flag, _tag, **kwargs)(self)
+    def anchor_arrow(self, s=None, color=None, flag=None, _tag=None, _fn=None, anchor=None, spin=None, orient=None, **kwargs):
+        return self._get_std().anchor_arrow(s, color, flag, _tag, _fn, anchor, spin, orient, **kwargs)(self)
 
     def anchor_arrow2d(self, s=None, color=None, _tag=None, **kwargs):
         return self._get_std().anchor_arrow2d(s, color, _tag, **kwargs)(self)
 
     def expose_anchors(self, opacity=None, **kwargs):
         return self._get_std().expose_anchors(opacity, **kwargs)(self)
 
@@ -220,29 +226,35 @@
 
     def round3d(self, r=None, _or=None, ir=None, size=None, **kwargs):
         return self._get_std().round3d(r, _or, ir, size, **kwargs)(self)
 
     def move_copies(self, a=None, **kwargs):
         return self._get_std().move_copies(a, **kwargs)(self)
 
-    def line_of(self, spacing=None, n=None, l=None, p1=None, p2=None, **kwargs):
-        return self._get_std().line_of(spacing, n, l, p1, p2, **kwargs)(self)
-
     def xcopies(self, spacing=None, n=None, l=None, sp=None, **kwargs):
         return self._get_std().xcopies(spacing, n, l, sp, **kwargs)(self)
 
     def ycopies(self, spacing=None, n=None, l=None, sp=None, **kwargs):
         return self._get_std().ycopies(spacing, n, l, sp, **kwargs)(self)
 
     def zcopies(self, spacing=None, n=None, l=None, sp=None, **kwargs):
         return self._get_std().zcopies(spacing, n, l, sp, **kwargs)(self)
 
+    def line_of(self, spacing=None, n=None, l=None, p1=None, p2=None, **kwargs):
+        return self._get_std().line_of(spacing, n, l, p1, p2, **kwargs)(self)
+
+    def line_copies(self, spacing=None, n=None, l=None, p1=None, p2=None, **kwargs):
+        return self._get_std().line_copies(spacing, n, l, p1, p2, **kwargs)(self)
+
     def grid2d(self, spacing=None, n=None, size=None, stagger=None, inside=None, nonzero=None, **kwargs):
         return self._get_std().grid2d(spacing, n, size, stagger, inside, nonzero, **kwargs)(self)
 
+    def grid_copies(self, spacing=None, n=None, size=None, stagger=None, inside=None, nonzero=None, **kwargs):
+        return self._get_std().grid_copies(spacing, n, size, stagger, inside, nonzero, **kwargs)(self)
+
     def rot_copies(self, rots=None, v=None, cp=None, n=None, sa=None, offset=None, delta=None, subrot=None, **kwargs):
         return self._get_std().rot_copies(rots, v, cp, n, sa, offset, delta, subrot, **kwargs)(self)
 
     def xrot_copies(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
         return self._get_std().xrot_copies(rots, cp, n, sa, r, d, subrot, **kwargs)(self)
 
     def yrot_copies(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
@@ -250,44 +262,53 @@
 
     def zrot_copies(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
         return self._get_std().zrot_copies(rots, cp, n, sa, r, d, subrot, **kwargs)(self)
 
     def arc_of(self, n=None, r=None, rx=None, ry=None, d=None, dx=None, dy=None, sa=None, ea=None, rot=None, **kwargs):
         return self._get_std().arc_of(n, r, rx, ry, d, dx, dy, sa, ea, rot, **kwargs)(self)
 
+    def arc_copies(self, n=None, r=None, rx=None, ry=None, d=None, dx=None, dy=None, sa=None, ea=None, rot=None, **kwargs):
+        return self._get_std().arc_copies(n, r, rx, ry, d, dx, dy, sa, ea, rot, **kwargs)(self)
+
     def ovoid_spread(self, n=None, r=None, d=None, cone_ang=None, scale=None, perp=None, **kwargs):
         return self._get_std().ovoid_spread(n, r, d, cone_ang, scale, perp, **kwargs)(self)
 
-    def path_spread(self, path=None, n=None, spacing=None, sp=None, rotate_children=None, closed=None, **kwargs):
-        return self._get_std().path_spread(path, n, spacing, sp, rotate_children, closed, **kwargs)(self)
+    def sphere_copies(self, n=None, r=None, d=None, cone_ang=None, scale=None, perp=None, **kwargs):
+        return self._get_std().sphere_copies(n, r, d, cone_ang, scale, perp, **kwargs)(self)
 
-    def mirror_copy(self, v=None, offset=None, cp=None, **kwargs):
-        return self._get_std().mirror_copy(v, offset, cp, **kwargs)(self)
+    def path_spread(self, path=None, n=None, spacing=None, sp=None, rotate_children=None, dist=None, closed=None, **kwargs):
+        return self._get_std().path_spread(path, n, spacing, sp, rotate_children, dist, closed, **kwargs)(self)
+
+    def path_copies(self, path=None, n=None, spacing=None, sp=None, dist=None, rotate_children=None, closed=None, **kwargs):
+        return self._get_std().path_copies(path, n, spacing, sp, dist, rotate_children, closed, **kwargs)(self)
 
     def xflip_copy(self, offset=None, x=None, **kwargs):
         return self._get_std().xflip_copy(offset, x, **kwargs)(self)
 
     def yflip_copy(self, offset=None, y=None, **kwargs):
         return self._get_std().yflip_copy(offset, y, **kwargs)(self)
 
     def zflip_copy(self, offset=None, z=None, **kwargs):
         return self._get_std().zflip_copy(offset, z, **kwargs)(self)
 
-    def distribute(self, spacing=None, sizes=None, dir=None, l=None, **kwargs):
-        return self._get_std().distribute(spacing, sizes, dir, l, **kwargs)(self)
+    def mirror_copy(self, v=None, offset=None, cp=None, **kwargs):
+        return self._get_std().mirror_copy(v, offset, cp, **kwargs)(self)
 
     def xdistribute(self, spacing=None, sizes=None, l=None, **kwargs):
         return self._get_std().xdistribute(spacing, sizes, l, **kwargs)(self)
 
     def ydistribute(self, spacing=None, sizes=None, l=None, **kwargs):
         return self._get_std().ydistribute(spacing, sizes, l, **kwargs)(self)
 
     def zdistribute(self, spacing=None, sizes=None, l=None, **kwargs):
         return self._get_std().zdistribute(spacing, sizes, l, **kwargs)(self)
 
+    def distribute(self, spacing=None, sizes=None, dir=None, l=None, **kwargs):
+        return self._get_std().distribute(spacing, sizes, dir, l, **kwargs)(self)
+
     def half_of(self, v=None, cp=None, s=None, planar=None, **kwargs):
         return self._get_std().half_of(v, cp, s, planar, **kwargs)(self)
 
     def left_half(self, s=None, x=None, planar=None, **kwargs):
         return self._get_std().left_half(s, x, planar, **kwargs)(self)
 
     def right_half(self, s=None, x=None, planar=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_base.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_base.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/bosl2_patches.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/bosl2_patches.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/bottlecaps.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/bottlecaps.py`

 * *Files 5% similar despite different names*

```diff
@@ -42,16 +42,16 @@
        super().__init__("bottle_adapter_cap_to_cap", {"wall" : wall, "texture" : texture, "cap_h1" : cap_h1, "cap_thread_od1" : cap_thread_od1, "tolerance" : tolerance, "cap_neck_od1" : cap_neck_od1, "cap_thread_pitch1" : cap_thread_pitch1, "cap_h2" : cap_h2, "cap_thread_od2" : cap_thread_od2, "cap_neck_od2" : cap_neck_od2, "cap_thread_pitch2" : cap_thread_pitch2, "d" : d, "neck_id1" : neck_id1, "neck_id2" : neck_id2, "taper_lead_in" : taper_lead_in, **kwargs})
 
 class bottle_adapter_neck_to_neck(_Bosl2Base):
     def __init__(self, d=None, neck_od1=None, neck_id1=None, thread_od1=None, height1=None, support_od1=None, thread_pitch1=None, neck_od2=None, neck_id2=None, thread_od2=None, height2=None, support_od2=None, pitch2=None, taper_lead_in=None, wall=None, **kwargs):
        super().__init__("bottle_adapter_neck_to_neck", {"d" : d, "neck_od1" : neck_od1, "neck_id1" : neck_id1, "thread_od1" : thread_od1, "height1" : height1, "support_od1" : support_od1, "thread_pitch1" : thread_pitch1, "neck_od2" : neck_od2, "neck_id2" : neck_id2, "thread_od2" : thread_od2, "height2" : height2, "support_od2" : support_od2, "pitch2" : pitch2, "taper_lead_in" : taper_lead_in, "wall" : wall, **kwargs})
 
 class _sp_thread_profile(_Bosl2Base):
-    def __init__(self, tpi=None, a=None, S=None, style=None, **kwargs):
-       super().__init__("_sp_thread_profile", {"tpi" : tpi, "a" : a, "S" : S, "style" : style, **kwargs})
+    def __init__(self, tpi=None, a=None, S=None, style=None, flip=None, **kwargs):
+       super().__init__("_sp_thread_profile", {"tpi" : tpi, "a" : a, "S" : S, "style" : style, "flip" : flip, **kwargs})
 
 class sp_neck(_Bosl2Base):
     def __init__(self, diam=None, type=None, wall=None, id=None, style=None, bead=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("sp_neck", {"diam" : diam, "type" : type, "wall" : wall, "id" : id, "style" : style, "bead" : bead, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class sp_diameter(_Bosl2Base):
     def __init__(self, diam=None, type=None, **kwargs):
@@ -93,7 +93,11 @@
     def __init__(self, d=None, neck_od1=None, neck_id1=None, thread_od1=None, height1=None, support_od1=None, thread_pitch1=None, neck_od2=None, neck_id2=None, thread_od2=None, height2=None, support_od2=None, pitch2=None, taper_lead_in=None, wall=None, **kwargs):
        super().__init__("bottle_adapter_neck_to_neck", {"d" : d, "neck_od1" : neck_od1, "neck_id1" : neck_id1, "thread_od1" : thread_od1, "height1" : height1, "support_od1" : support_od1, "thread_pitch1" : thread_pitch1, "neck_od2" : neck_od2, "neck_id2" : neck_id2, "thread_od2" : thread_od2, "height2" : height2, "support_od2" : support_od2, "pitch2" : pitch2, "taper_lead_in" : taper_lead_in, "wall" : wall, **kwargs})
 
 class sp_neck(_Bosl2Base):
     def __init__(self, diam=None, type=None, wall=None, id=None, style=None, bead=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("sp_neck", {"diam" : diam, "type" : type, "wall" : wall, "id" : id, "style" : style, "bead" : bead, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
+class sp_cap(_Bosl2Base):
+    def __init__(self, diam=None, type=None, wall=None, style=None, top_adj=None, bot_adj=None, texture=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("sp_cap", {"diam" : diam, "type" : type, "wall" : wall, "style" : style, "top_adj" : top_adj, "bot_adj" : bot_adj, "texture" : texture, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/color.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/color.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/comparisons.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/comparisons.py`

 * *Files 5% similar despite different names*

```diff
@@ -34,14 +34,18 @@
     def __init__(self, x=None, eps=None, **kwargs):
        super().__init__("all_nonnegative", {"x" : x, "eps" : eps, **kwargs})
 
 class all_equal(_Bosl2Base):
     def __init__(self, vec=None, eps=None, **kwargs):
        super().__init__("all_equal", {"vec" : vec, "eps" : eps, **kwargs})
 
+class are_ends_equal(_Bosl2Base):
+    def __init__(self, list=None, eps=None, **kwargs):
+       super().__init__("are_ends_equal", {"list" : list, "eps" : eps, **kwargs})
+
 class is_increasing(_Bosl2Base):
     def __init__(self, list=None, strict=None, **kwargs):
        super().__init__("is_increasing", {"list" : list, "strict" : strict, **kwargs})
 
 class is_decreasing(_Bosl2Base):
     def __init__(self, list=None, strict=None, **kwargs):
        super().__init__("is_decreasing", {"list" : list, "strict" : strict, **kwargs})
@@ -78,14 +82,30 @@
     def __init__(self, list=None, closed=None, eps=None, **kwargs):
        super().__init__("deduplicate", {"list" : list, "closed" : closed, "eps" : eps, **kwargs})
 
 class deduplicate_indexed(_Bosl2Base):
     def __init__(self, list=None, indices=None, closed=None, eps=None, **kwargs):
        super().__init__("deduplicate_indexed", {"list" : list, "indices" : indices, "closed" : closed, "eps" : eps, **kwargs})
 
+class list_wrap(_Bosl2Base):
+    def __init__(self, list=None, eps=None, **kwargs):
+       super().__init__("list_wrap", {"list" : list, "eps" : eps, **kwargs})
+
+class cleanup_path(_Bosl2Base):
+    def __init__(self, list=None, eps=None, **kwargs):
+       super().__init__("cleanup_path", {"list" : list, "eps" : eps, **kwargs})
+
+class close_path(_Bosl2Base):
+    def __init__(self, list=None, eps=None, **kwargs):
+       super().__init__("close_path", {"list" : list, "eps" : eps, **kwargs})
+
+class list_unwrap(_Bosl2Base):
+    def __init__(self, list=None, eps=None, **kwargs):
+       super().__init__("list_unwrap", {"list" : list, "eps" : eps, **kwargs})
+
 class unique(_Bosl2Base):
     def __init__(self, list=None, **kwargs):
        super().__init__("unique", {"list" : list, **kwargs})
 
 class _unique_sort(_Bosl2Base):
     def __init__(self, l=None, **kwargs):
        super().__init__("_unique_sort", {"l" : l, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/constants.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/constants.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/coords.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/coords.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/cubetruss.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/cubetruss.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -10,39 +10,39 @@
 _cubetruss_strut_size = _OpenSCADConstant('_cubetruss_strut_size')
 _cubetruss_bracing = _OpenSCADConstant('_cubetruss_bracing')
 _cubetruss_clip_thickness = _OpenSCADConstant('_cubetruss_clip_thickness')
 class cubetruss_dist(_Bosl2Base):
     def __init__(self, cubes=None, gaps=None, size=None, strut=None, **kwargs):
        super().__init__("cubetruss_dist", {"cubes" : cubes, "gaps" : gaps, "size" : size, "strut" : strut, **kwargs})
 
-class cubetruss_segment(_Bosl2Base):
-    def __init__(self, size=None, strut=None, bracing=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cubetruss_segment", {"size" : size, "strut" : strut, "bracing" : bracing, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+class cubetruss(_Bosl2Base):
+    def __init__(self, extents=None, clips=None, bracing=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cubetruss", {"extents" : extents, "clips" : clips, "bracing" : bracing, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class cubetruss_corner(_Bosl2Base):
+    def __init__(self, h=None, extents=None, bracing=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cubetruss_corner", {"h" : h, "extents" : extents, "bracing" : bracing, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cubetruss_support(_Bosl2Base):
     def __init__(self, size=None, strut=None, extents=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cubetruss_support", {"size" : size, "strut" : strut, "extents" : extents, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
-class cubetruss_clip(_Bosl2Base):
-    def __init__(self, extents=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cubetruss_clip", {"extents" : extents, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
 class cubetruss_foot(_Bosl2Base):
     def __init__(self, w=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cubetruss_foot", {"w" : w, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cubetruss_joiner(_Bosl2Base):
     def __init__(self, w=None, vert=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cubetruss_joiner", {"w" : w, "vert" : vert, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cubetruss_uclip(_Bosl2Base):
     def __init__(self, dual=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cubetruss_uclip", {"dual" : dual, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
-class cubetruss(_Bosl2Base):
-    def __init__(self, extents=None, clips=None, bracing=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cubetruss", {"extents" : extents, "clips" : clips, "bracing" : bracing, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+class cubetruss_segment(_Bosl2Base):
+    def __init__(self, size=None, strut=None, bracing=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cubetruss_segment", {"size" : size, "strut" : strut, "bracing" : bracing, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
-class cubetruss_corner(_Bosl2Base):
-    def __init__(self, h=None, extents=None, bracing=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cubetruss_corner", {"h" : h, "extents" : extents, "bracing" : bracing, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+class cubetruss_clip(_Bosl2Base):
+    def __init__(self, extents=None, size=None, strut=None, clipthick=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cubetruss_clip", {"extents" : extents, "size" : size, "strut" : strut, "clipthick" : clipthick, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/distributors.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/openscad.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,96 +1,134 @@
-from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
-from solid2.core.scad_import import extra_scad_include as _extra_scad_include
-from pathlib import Path as _Path
-
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
-_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/distributors.scad'}", use_not_include=False)
-
-class line_of(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, l=None, p1=None, p2=None, **kwargs):
-       super().__init__("line_of", {"spacing" : spacing, "n" : n, "l" : l, "p1" : p1, "p2" : p2, **kwargs})
-
-class move_copies(_Bosl2Base):
-    def __init__(self, a=None, **kwargs):
-       super().__init__("move_copies", {"a" : a, **kwargs})
-
-class line_of(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, l=None, p1=None, p2=None, **kwargs):
-       super().__init__("line_of", {"spacing" : spacing, "n" : n, "l" : l, "p1" : p1, "p2" : p2, **kwargs})
-
-class xcopies(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, l=None, sp=None, **kwargs):
-       super().__init__("xcopies", {"spacing" : spacing, "n" : n, "l" : l, "sp" : sp, **kwargs})
-
-class ycopies(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, l=None, sp=None, **kwargs):
-       super().__init__("ycopies", {"spacing" : spacing, "n" : n, "l" : l, "sp" : sp, **kwargs})
-
-class zcopies(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, l=None, sp=None, **kwargs):
-       super().__init__("zcopies", {"spacing" : spacing, "n" : n, "l" : l, "sp" : sp, **kwargs})
-
-class grid2d(_Bosl2Base):
-    def __init__(self, spacing=None, n=None, size=None, stagger=None, inside=None, nonzero=None, **kwargs):
-       super().__init__("grid2d", {"spacing" : spacing, "n" : n, "size" : size, "stagger" : stagger, "inside" : inside, "nonzero" : nonzero, **kwargs})
-
-class rot_copies(_Bosl2Base):
-    def __init__(self, rots=None, v=None, cp=None, n=None, sa=None, offset=None, delta=None, subrot=None, **kwargs):
-       super().__init__("rot_copies", {"rots" : rots, "v" : v, "cp" : cp, "n" : n, "sa" : sa, "offset" : offset, "delta" : delta, "subrot" : subrot, **kwargs})
-
-class xrot_copies(_Bosl2Base):
-    def __init__(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
-       super().__init__("xrot_copies", {"rots" : rots, "cp" : cp, "n" : n, "sa" : sa, "r" : r, "d" : d, "subrot" : subrot, **kwargs})
-
-class yrot_copies(_Bosl2Base):
-    def __init__(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
-       super().__init__("yrot_copies", {"rots" : rots, "cp" : cp, "n" : n, "sa" : sa, "r" : r, "d" : d, "subrot" : subrot, **kwargs})
-
-class zrot_copies(_Bosl2Base):
-    def __init__(self, rots=None, cp=None, n=None, sa=None, r=None, d=None, subrot=None, **kwargs):
-       super().__init__("zrot_copies", {"rots" : rots, "cp" : cp, "n" : n, "sa" : sa, "r" : r, "d" : d, "subrot" : subrot, **kwargs})
-
-class arc_of(_Bosl2Base):
-    def __init__(self, n=None, r=None, rx=None, ry=None, d=None, dx=None, dy=None, sa=None, ea=None, rot=None, **kwargs):
-       super().__init__("arc_of", {"n" : n, "r" : r, "rx" : rx, "ry" : ry, "d" : d, "dx" : dx, "dy" : dy, "sa" : sa, "ea" : ea, "rot" : rot, **kwargs})
-
-class ovoid_spread(_Bosl2Base):
-    def __init__(self, n=None, r=None, d=None, cone_ang=None, scale=None, perp=None, **kwargs):
-       super().__init__("ovoid_spread", {"n" : n, "r" : r, "d" : d, "cone_ang" : cone_ang, "scale" : scale, "perp" : perp, **kwargs})
-
-class path_spread(_Bosl2Base):
-    def __init__(self, path=None, n=None, spacing=None, sp=None, rotate_children=None, closed=None, **kwargs):
-       super().__init__("path_spread", {"path" : path, "n" : n, "spacing" : spacing, "sp" : sp, "rotate_children" : rotate_children, "closed" : closed, **kwargs})
-
-class mirror_copy(_Bosl2Base):
-    def __init__(self, v=None, offset=None, cp=None, **kwargs):
-       super().__init__("mirror_copy", {"v" : v, "offset" : offset, "cp" : cp, **kwargs})
-
-class xflip_copy(_Bosl2Base):
-    def __init__(self, offset=None, x=None, **kwargs):
-       super().__init__("xflip_copy", {"offset" : offset, "x" : x, **kwargs})
-
-class yflip_copy(_Bosl2Base):
-    def __init__(self, offset=None, y=None, **kwargs):
-       super().__init__("yflip_copy", {"offset" : offset, "y" : y, **kwargs})
-
-class zflip_copy(_Bosl2Base):
-    def __init__(self, offset=None, z=None, **kwargs):
-       super().__init__("zflip_copy", {"offset" : offset, "z" : z, **kwargs})
-
-class distribute(_Bosl2Base):
-    def __init__(self, spacing=None, sizes=None, dir=None, l=None, **kwargs):
-       super().__init__("distribute", {"spacing" : spacing, "sizes" : sizes, "dir" : dir, "l" : l, **kwargs})
-
-class xdistribute(_Bosl2Base):
-    def __init__(self, spacing=None, sizes=None, l=None, **kwargs):
-       super().__init__("xdistribute", {"spacing" : spacing, "sizes" : sizes, "l" : l, **kwargs})
-
-class ydistribute(_Bosl2Base):
-    def __init__(self, spacing=None, sizes=None, l=None, **kwargs):
-       super().__init__("ydistribute", {"spacing" : spacing, "sizes" : sizes, "l" : l, **kwargs})
-
-class zdistribute(_Bosl2Base):
-    def __init__(self, spacing=None, sizes=None, l=None, **kwargs):
-       super().__init__("zdistribute", {"spacing" : spacing, "sizes" : sizes, "l" : l, **kwargs})
+class union(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("union", {**kwargs})
+
+class difference(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("difference", {**kwargs})
+
+class intersection(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("intersection", {**kwargs})
+
+class intersection_for(_Bosl2Base):
+    def __init__(self, n=None, **kwargs):
+       super().__init__("intersection_for", {"n" : n, **kwargs})
+
+class translate(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("translate", {"v" : v, **kwargs})
+
+class scale(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("scale", {"v" : v, **kwargs})
+
+class rotate(_Bosl2Base):
+    def __init__(self, a=None, v=None, **kwargs):
+       super().__init__("rotate", {"a" : a, "v" : v, **kwargs})
+
+class mirror(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("mirror", {"v" : v, **kwargs})
+
+class resize(_Bosl2Base):
+    def __init__(self, newsize=None, auto=None, **kwargs):
+       super().__init__("resize", {"newsize" : newsize, "auto" : auto, **kwargs})
+
+class color(_Bosl2Base):
+    def __init__(self, c=None, alpha=None, **kwargs):
+       super().__init__("color", {"c" : c, "alpha" : alpha, **kwargs})
+
+class minkowski(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("minkowski", {**kwargs})
+
+class offset(_Bosl2Base):
+    def __init__(self, r=None, delta=None, chamfer=None, _fn=None, **kwargs):
+       super().__init__("offset", {"r" : r, "delta" : delta, "chamfer" : chamfer, "_fn" : _fn, **kwargs})
+
+class hull(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("hull", {**kwargs})
+
+class render(_Bosl2Base):
+    def __init__(self, convexity=None, **kwargs):
+       super().__init__("render", {"convexity" : convexity, **kwargs})
+
+class linear_extrude(_Bosl2Base):
+    def __init__(self, height=None, center=None, convexity=None, twist=None, slices=None, scale=None, **kwargs):
+       super().__init__("linear_extrude", {"height" : height, "center" : center, "convexity" : convexity, "twist" : twist, "slices" : slices, "scale" : scale, **kwargs})
+
+class rotate_extrude(_Bosl2Base):
+    def __init__(self, angle=None, convexity=None, _fn=None, **kwargs):
+       super().__init__("rotate_extrude", {"angle" : angle, "convexity" : convexity, "_fn" : _fn, **kwargs})
+
+class projection(_Bosl2Base):
+    def __init__(self, cut=None, **kwargs):
+       super().__init__("projection", {"cut" : cut, **kwargs})
+
+class surface(_Bosl2Base):
+    def __init__(self, file=None, center=None, convexity=None, invert=None, **kwargs):
+       super().__init__("surface", {"file" : file, "center" : center, "convexity" : convexity, "invert" : invert, **kwargs})
+
+class child(_Bosl2Base):
+    def __init__(self, index=None, vector=None, range=None, **kwargs):
+       super().__init__("child", {"index" : index, "vector" : vector, "range" : range, **kwargs})
+
+class children(_Bosl2Base):
+    def __init__(self, index=None, vector=None, range=None, **kwargs):
+       super().__init__("children", {"index" : index, "vector" : vector, "range" : range, **kwargs})
+
+class import_stl(_Bosl2Base):
+    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
+       super().__init__("import_stl", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
+
+class import_dxf(_Bosl2Base):
+    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
+       super().__init__("import_dxf", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
+
+class _import(_Bosl2Base):
+    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
+       super().__init__("_import", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
+
+class assign(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("assign", {**kwargs})
+
+class multmatrix(_Bosl2Base):
+    def __init__(self, m=None, **kwargs):
+       super().__init__("multmatrix", {"m" : m, **kwargs})
+
+class polygon(_Bosl2Base):
+    def __init__(self, points=None, paths=None, convexity=None, **kwargs):
+       super().__init__("polygon", {"points" : points, "paths" : paths, "convexity" : convexity, **kwargs})
+
+class circle(_Bosl2Base):
+    def __init__(self, r=None, d=None, _fn=None, **kwargs):
+       super().__init__("circle", {"r" : r, "d" : d, "_fn" : _fn, **kwargs})
+
+class square(_Bosl2Base):
+    def __init__(self, size=None, center=None, **kwargs):
+       super().__init__("square", {"size" : size, "center" : center, **kwargs})
+
+class sphere(_Bosl2Base):
+    def __init__(self, r=None, d=None, _fn=None, **kwargs):
+       super().__init__("sphere", {"r" : r, "d" : d, "_fn" : _fn, **kwargs})
+
+class cube(_Bosl2Base):
+    def __init__(self, size=None, center=None, **kwargs):
+       super().__init__("cube", {"size" : size, "center" : center, **kwargs})
+
+class cylinder(_Bosl2Base):
+    def __init__(self, r=None, h=None, r1=None, r2=None, d=None, d1=None, d2=None, center=None, _fn=None, **kwargs):
+       super().__init__("cylinder", {"r" : r, "h" : h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "center" : center, "_fn" : _fn, **kwargs})
+
+class polyhedron(_Bosl2Base):
+    def __init__(self, points=None, faces=None, convexity=None, triangles=None, **kwargs):
+       super().__init__("polyhedron", {"points" : points, "faces" : faces, "convexity" : convexity, "triangles" : triangles, **kwargs})
+
+class text(_Bosl2Base):
+    def __init__(self, text=None, size=None, font=None, halign=None, valign=None, spacing=None, direction=None, language=None, script=None, _fn=None, **kwargs):
+       super().__init__("text", {"text" : text, "size" : size, "font" : font, "halign" : halign, "valign" : valign, "spacing" : spacing, "direction" : direction, "language" : language, "script" : script, "_fn" : _fn, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/drawing.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/drawing.py`

 * *Files 6% similar despite different names*

```diff
@@ -3,20 +3,20 @@
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
 _extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/drawing.scad'}", use_not_include=False)
 
 class stroke(_Bosl2Base):
-    def __init__(self, path=None, width=None, closed=None, endcaps=None, endcap1=None, endcap2=None, joints=None, dots=None, endcap_width=None, endcap_width1=None, endcap_width2=None, joint_width=None, dots_width=None, endcap_length=None, endcap_length1=None, endcap_length2=None, joint_length=None, dots_length=None, endcap_extent=None, endcap_extent1=None, endcap_extent2=None, joint_extent=None, dots_extent=None, endcap_angle=None, endcap_angle1=None, endcap_angle2=None, joint_angle=None, dots_angle=None, endcap_color=None, endcap_color1=None, endcap_color2=None, joint_color=None, dots_color=None, color=None, trim=None, trim1=None, trim2=None, convexity=None, hull=None, **kwargs):
-       super().__init__("stroke", {"path" : path, "width" : width, "closed" : closed, "endcaps" : endcaps, "endcap1" : endcap1, "endcap2" : endcap2, "joints" : joints, "dots" : dots, "endcap_width" : endcap_width, "endcap_width1" : endcap_width1, "endcap_width2" : endcap_width2, "joint_width" : joint_width, "dots_width" : dots_width, "endcap_length" : endcap_length, "endcap_length1" : endcap_length1, "endcap_length2" : endcap_length2, "joint_length" : joint_length, "dots_length" : dots_length, "endcap_extent" : endcap_extent, "endcap_extent1" : endcap_extent1, "endcap_extent2" : endcap_extent2, "joint_extent" : joint_extent, "dots_extent" : dots_extent, "endcap_angle" : endcap_angle, "endcap_angle1" : endcap_angle1, "endcap_angle2" : endcap_angle2, "joint_angle" : joint_angle, "dots_angle" : dots_angle, "endcap_color" : endcap_color, "endcap_color1" : endcap_color1, "endcap_color2" : endcap_color2, "joint_color" : joint_color, "dots_color" : dots_color, "color" : color, "trim" : trim, "trim1" : trim1, "trim2" : trim2, "convexity" : convexity, "hull" : hull, **kwargs})
+    def __init__(self, path=None, width=None, closed=None, endcaps=None, endcap1=None, endcap2=None, joints=None, dots=None, endcap_width=None, endcap_width1=None, endcap_width2=None, joint_width=None, dots_width=None, endcap_length=None, endcap_length1=None, endcap_length2=None, joint_length=None, dots_length=None, endcap_extent=None, endcap_extent1=None, endcap_extent2=None, joint_extent=None, dots_extent=None, endcap_angle=None, endcap_angle1=None, endcap_angle2=None, joint_angle=None, dots_angle=None, endcap_color=None, endcap_color1=None, endcap_color2=None, joint_color=None, dots_color=None, color=None, trim=None, trim1=None, trim2=None, singleton_scale=None, convexity=None, **kwargs):
+       super().__init__("stroke", {"path" : path, "width" : width, "closed" : closed, "endcaps" : endcaps, "endcap1" : endcap1, "endcap2" : endcap2, "joints" : joints, "dots" : dots, "endcap_width" : endcap_width, "endcap_width1" : endcap_width1, "endcap_width2" : endcap_width2, "joint_width" : joint_width, "dots_width" : dots_width, "endcap_length" : endcap_length, "endcap_length1" : endcap_length1, "endcap_length2" : endcap_length2, "joint_length" : joint_length, "dots_length" : dots_length, "endcap_extent" : endcap_extent, "endcap_extent1" : endcap_extent1, "endcap_extent2" : endcap_extent2, "joint_extent" : joint_extent, "dots_extent" : dots_extent, "endcap_angle" : endcap_angle, "endcap_angle1" : endcap_angle1, "endcap_angle2" : endcap_angle2, "joint_angle" : joint_angle, "dots_angle" : dots_angle, "endcap_color" : endcap_color, "endcap_color1" : endcap_color1, "endcap_color2" : endcap_color2, "joint_color" : joint_color, "dots_color" : dots_color, "color" : color, "trim" : trim, "trim1" : trim1, "trim2" : trim2, "singleton_scale" : singleton_scale, "convexity" : convexity, **kwargs})
 
 class dashed_stroke(_Bosl2Base):
-    def __init__(self, path=None, dashpat=None, closed=None, **kwargs):
-       super().__init__("dashed_stroke", {"path" : path, "dashpat" : dashpat, "closed" : closed, **kwargs})
+    def __init__(self, path=None, dashpat=None, closed=None, fit=None, mindash=None, **kwargs):
+       super().__init__("dashed_stroke", {"path" : path, "dashpat" : dashpat, "closed" : closed, "fit" : fit, "mindash" : mindash, **kwargs})
 
 class arc(_Bosl2Base):
     def __init__(self, n=None, r=None, angle=None, d=None, cp=None, points=None, corner=None, width=None, thickness=None, start=None, wedge=None, long=None, cw=None, ccw=None, endpoint=None, **kwargs):
        super().__init__("arc", {"n" : n, "r" : r, "angle" : angle, "d" : d, "cp" : cp, "points" : points, "corner" : corner, "width" : width, "thickness" : thickness, "start" : start, "wedge" : wedge, "long" : long, "cw" : cw, "ccw" : ccw, "endpoint" : endpoint, **kwargs})
 
 class helix(_Bosl2Base):
     def __init__(self, l=None, h=None, turns=None, angle=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, **kwargs):
@@ -43,20 +43,20 @@
        super().__init__("_turtle", {"commands" : commands, "state" : state, "full_state" : full_state, "index" : index, **kwargs})
 
 class _turtle_command(_Bosl2Base):
     def __init__(self, command=None, parm=None, parm2=None, state=None, index=None, **kwargs):
        super().__init__("_turtle_command", {"command" : command, "parm" : parm, "parm2" : parm2, "state" : state, "index" : index, **kwargs})
 
 class stroke(_Bosl2Base):
-    def __init__(self, path=None, width=None, closed=None, endcaps=None, endcap1=None, endcap2=None, joints=None, dots=None, endcap_width=None, endcap_width1=None, endcap_width2=None, joint_width=None, dots_width=None, endcap_length=None, endcap_length1=None, endcap_length2=None, joint_length=None, dots_length=None, endcap_extent=None, endcap_extent1=None, endcap_extent2=None, joint_extent=None, dots_extent=None, endcap_angle=None, endcap_angle1=None, endcap_angle2=None, joint_angle=None, dots_angle=None, endcap_color=None, endcap_color1=None, endcap_color2=None, joint_color=None, dots_color=None, color=None, trim=None, trim1=None, trim2=None, convexity=None, hull=None, **kwargs):
-       super().__init__("stroke", {"path" : path, "width" : width, "closed" : closed, "endcaps" : endcaps, "endcap1" : endcap1, "endcap2" : endcap2, "joints" : joints, "dots" : dots, "endcap_width" : endcap_width, "endcap_width1" : endcap_width1, "endcap_width2" : endcap_width2, "joint_width" : joint_width, "dots_width" : dots_width, "endcap_length" : endcap_length, "endcap_length1" : endcap_length1, "endcap_length2" : endcap_length2, "joint_length" : joint_length, "dots_length" : dots_length, "endcap_extent" : endcap_extent, "endcap_extent1" : endcap_extent1, "endcap_extent2" : endcap_extent2, "joint_extent" : joint_extent, "dots_extent" : dots_extent, "endcap_angle" : endcap_angle, "endcap_angle1" : endcap_angle1, "endcap_angle2" : endcap_angle2, "joint_angle" : joint_angle, "dots_angle" : dots_angle, "endcap_color" : endcap_color, "endcap_color1" : endcap_color1, "endcap_color2" : endcap_color2, "joint_color" : joint_color, "dots_color" : dots_color, "color" : color, "trim" : trim, "trim1" : trim1, "trim2" : trim2, "convexity" : convexity, "hull" : hull, **kwargs})
+    def __init__(self, path=None, width=None, closed=None, endcaps=None, endcap1=None, endcap2=None, joints=None, dots=None, endcap_width=None, endcap_width1=None, endcap_width2=None, joint_width=None, dots_width=None, endcap_length=None, endcap_length1=None, endcap_length2=None, joint_length=None, dots_length=None, endcap_extent=None, endcap_extent1=None, endcap_extent2=None, joint_extent=None, dots_extent=None, endcap_angle=None, endcap_angle1=None, endcap_angle2=None, joint_angle=None, dots_angle=None, endcap_color=None, endcap_color1=None, endcap_color2=None, joint_color=None, dots_color=None, color=None, trim=None, trim1=None, trim2=None, singleton_scale=None, convexity=None, **kwargs):
+       super().__init__("stroke", {"path" : path, "width" : width, "closed" : closed, "endcaps" : endcaps, "endcap1" : endcap1, "endcap2" : endcap2, "joints" : joints, "dots" : dots, "endcap_width" : endcap_width, "endcap_width1" : endcap_width1, "endcap_width2" : endcap_width2, "joint_width" : joint_width, "dots_width" : dots_width, "endcap_length" : endcap_length, "endcap_length1" : endcap_length1, "endcap_length2" : endcap_length2, "joint_length" : joint_length, "dots_length" : dots_length, "endcap_extent" : endcap_extent, "endcap_extent1" : endcap_extent1, "endcap_extent2" : endcap_extent2, "joint_extent" : joint_extent, "dots_extent" : dots_extent, "endcap_angle" : endcap_angle, "endcap_angle1" : endcap_angle1, "endcap_angle2" : endcap_angle2, "joint_angle" : joint_angle, "dots_angle" : dots_angle, "endcap_color" : endcap_color, "endcap_color1" : endcap_color1, "endcap_color2" : endcap_color2, "joint_color" : joint_color, "dots_color" : dots_color, "color" : color, "trim" : trim, "trim1" : trim1, "trim2" : trim2, "singleton_scale" : singleton_scale, "convexity" : convexity, **kwargs})
 
 class dashed_stroke(_Bosl2Base):
-    def __init__(self, path=None, dashpat=None, width=None, closed=None, **kwargs):
-       super().__init__("dashed_stroke", {"path" : path, "dashpat" : dashpat, "width" : width, "closed" : closed, **kwargs})
+    def __init__(self, path=None, dashpat=None, width=None, closed=None, fit=None, roundcaps=None, **kwargs):
+       super().__init__("dashed_stroke", {"path" : path, "dashpat" : dashpat, "width" : width, "closed" : closed, "fit" : fit, "roundcaps" : roundcaps, **kwargs})
 
 class arc(_Bosl2Base):
     def __init__(self, n=None, r=None, angle=None, d=None, cp=None, points=None, corner=None, width=None, thickness=None, start=None, wedge=None, anchor=None, spin=None, **kwargs):
        super().__init__("arc", {"n" : n, "r" : r, "angle" : angle, "d" : d, "cp" : cp, "points" : points, "corner" : corner, "width" : width, "thickness" : thickness, "start" : start, "wedge" : wedge, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class helix(_Bosl2Base):
     def __init__(self, l=None, h=None, turns=None, angle=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/fnliterals.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/fnliterals.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/gears.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/gears.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,16 +27,16 @@
        super().__init__("bevel_gear", {"pitch" : pitch, "teeth" : teeth, "face_width" : face_width, "pitch_angle" : pitch_angle, "mate_teeth" : mate_teeth, "hide" : hide, "pressure_angle" : pressure_angle, "clearance" : clearance, "backlash" : backlash, "cutter_radius" : cutter_radius, "spiral_angle" : spiral_angle, "left_handed" : left_handed, "slices" : slices, "interior" : interior, "mod" : mod, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class worm(_Bosl2Base):
     def __init__(self, pitch=None, d=None, l=None, starts=None, left_handed=None, pressure_angle=None, backlash=None, clearance=None, mod=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("worm", {"pitch" : pitch, "d" : d, "l" : l, "starts" : starts, "left_handed" : left_handed, "pressure_angle" : pressure_angle, "backlash" : backlash, "clearance" : clearance, "mod" : mod, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class worm_gear(_Bosl2Base):
-    def __init__(self, pitch=None, teeth=None, worm_diam=None, worm_starts=None, worm_arc=None, crowning=None, left_handed=None, pressure_angle=None, backlash=None, clearance=None, mod=None, slices=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("worm_gear", {"pitch" : pitch, "teeth" : teeth, "worm_diam" : worm_diam, "worm_starts" : worm_starts, "worm_arc" : worm_arc, "crowning" : crowning, "left_handed" : left_handed, "pressure_angle" : pressure_angle, "backlash" : backlash, "clearance" : clearance, "mod" : mod, "slices" : slices, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, pitch=None, teeth=None, worm_diam=None, worm_starts=None, worm_arc=None, crowning=None, left_handed=None, pressure_angle=None, backlash=None, clearance=None, slices=None, mod=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("worm_gear", {"pitch" : pitch, "teeth" : teeth, "worm_diam" : worm_diam, "worm_starts" : worm_starts, "worm_arc" : worm_arc, "crowning" : crowning, "left_handed" : left_handed, "pressure_angle" : pressure_angle, "backlash" : backlash, "clearance" : clearance, "slices" : slices, "mod" : mod, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _gear_tooth_profile(_Bosl2Base):
     def __init__(self, pitch=None, teeth=None, pressure_angle=None, clearance=None, backlash=None, interior=None, valleys=None, center=None, mod=None, **kwargs):
        super().__init__("_gear_tooth_profile", {"pitch" : pitch, "teeth" : teeth, "pressure_angle" : pressure_angle, "clearance" : clearance, "backlash" : backlash, "interior" : interior, "valleys" : valleys, "center" : center, "mod" : mod, **kwargs})
 
 class circular_pitch(_Bosl2Base):
     def __init__(self, pitch=None, mod=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/geometry.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/geometry.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/joiners.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/joiners.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,16 +23,16 @@
        super().__init__("joiner_clear", {"l" : l, "w" : w, "ang" : ang, "clearance" : clearance, "overlap" : overlap, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class joiner(_Bosl2Base):
     def __init__(self, l=None, w=None, base=None, ang=None, screwsize=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("joiner", {"l" : l, "w" : w, "base" : base, "ang" : ang, "screwsize" : screwsize, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class dovetail(_Bosl2Base):
-    def __init__(self, gender=None, width=None, height=None, slide=None, h=None, w=None, angle=None, slope=None, taper=None, back_width=None, chamfer=None, extra=None, r=None, radius=None, round=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("dovetail", {"gender" : gender, "width" : width, "height" : height, "slide" : slide, "h" : h, "w" : w, "angle" : angle, "slope" : slope, "taper" : taper, "back_width" : back_width, "chamfer" : chamfer, "extra" : extra, "r" : r, "radius" : radius, "round" : round, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, gender=None, width=None, height=None, slide=None, h=None, w=None, angle=None, slope=None, thickness=None, taper=None, back_width=None, chamfer=None, extra=None, r=None, radius=None, round=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("dovetail", {"gender" : gender, "width" : width, "height" : height, "slide" : slide, "h" : h, "w" : w, "angle" : angle, "slope" : slope, "thickness" : thickness, "taper" : taper, "back_width" : back_width, "chamfer" : chamfer, "extra" : extra, "r" : r, "radius" : radius, "round" : round, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _pin_size(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
        super().__init__("_pin_size", {"size" : size, **kwargs})
 
 class snap_pin(_Bosl2Base):
     def __init__(self, size=None, r=None, radius=None, d=None, diameter=None, l=None, length=None, nub_depth=None, snap=None, thickness=None, clearance=None, preload=None, pointed=None, anchor=None, spin=None, orient=None, center=None, **kwargs):
@@ -63,16 +63,16 @@
        super().__init__("joiner_clear", {"l" : l, "w" : w, "ang" : ang, "clearance" : clearance, "overlap" : overlap, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class joiner(_Bosl2Base):
     def __init__(self, l=None, w=None, base=None, ang=None, screwsize=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("joiner", {"l" : l, "w" : w, "base" : base, "ang" : ang, "screwsize" : screwsize, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class dovetail(_Bosl2Base):
-    def __init__(self, gender=None, width=None, height=None, slide=None, h=None, w=None, angle=None, slope=None, taper=None, back_width=None, chamfer=None, extra=None, r=None, radius=None, round=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("dovetail", {"gender" : gender, "width" : width, "height" : height, "slide" : slide, "h" : h, "w" : w, "angle" : angle, "slope" : slope, "taper" : taper, "back_width" : back_width, "chamfer" : chamfer, "extra" : extra, "r" : r, "radius" : radius, "round" : round, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, gender=None, width=None, height=None, slide=None, h=None, w=None, angle=None, slope=None, thickness=None, taper=None, back_width=None, chamfer=None, extra=None, r=None, radius=None, round=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("dovetail", {"gender" : gender, "width" : width, "height" : height, "slide" : slide, "h" : h, "w" : w, "angle" : angle, "slope" : slope, "thickness" : thickness, "taper" : taper, "back_width" : back_width, "chamfer" : chamfer, "extra" : extra, "r" : r, "radius" : radius, "round" : round, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _pin_nub(_Bosl2Base):
     def __init__(self, r=None, nub=None, h=None, **kwargs):
        super().__init__("_pin_nub", {"r" : r, "nub" : nub, "h" : h, **kwargs})
 
 class _pin_slot(_Bosl2Base):
     def __init__(self, l=None, r=None, t=None, d=None, nub=None, depth=None, stretch=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/linalg.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/linalg.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/linear_bearings.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/linear_bearings.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,23 +2,27 @@
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
 _extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/linear_bearings.scad'}", use_not_include=False)
 
-class get_lmXuu_bearing_diam(_Bosl2Base):
+class lmXuu_info(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
-       super().__init__("get_lmXuu_bearing_diam", {"size" : size, **kwargs})
-
-class get_lmXuu_bearing_length(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("get_lmXuu_bearing_length", {"size" : size, **kwargs})
+       super().__init__("lmXuu_info", {"size" : size, **kwargs})
 
 class linear_bearing_housing(_Bosl2Base):
     def __init__(self, d=None, l=None, tab=None, gap=None, wall=None, tabwall=None, screwsize=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("linear_bearing_housing", {"d" : d, "l" : l, "tab" : tab, "gap" : gap, "wall" : wall, "tabwall" : tabwall, "screwsize" : screwsize, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
+class linear_bearing(_Bosl2Base):
+    def __init__(self, l=None, od=None, id=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("linear_bearing", {"l" : l, "od" : od, "id" : id, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
 class lmXuu_housing(_Bosl2Base):
     def __init__(self, size=None, tab=None, gap=None, wall=None, tabwall=None, screwsize=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("lmXuu_housing", {"size" : size, "tab" : tab, "gap" : gap, "wall" : wall, "tabwall" : tabwall, "screwsize" : screwsize, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
+class lmXuu_bearing(_Bosl2Base):
+    def __init__(self, size=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("lmXuu_bearing", {"size" : size, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/lists.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/lists.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/masks2d.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/masks2d.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/masks3d.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/regions.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,96 +1,136 @@
 from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
-_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/masks3d.scad'}", use_not_include=False)
+_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/regions.scad'}", use_not_include=False)
 
-class chamfer_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, chamfer=None, excess=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_edge_mask", {"l" : l, "chamfer" : chamfer, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class chamfer_corner_mask(_Bosl2Base):
-    def __init__(self, chamfer=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_corner_mask", {"chamfer" : chamfer, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class chamfer_cylinder_mask(_Bosl2Base):
-    def __init__(self, r=None, chamfer=None, d=None, ang=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_cylinder_mask", {"r" : r, "chamfer" : chamfer, "d" : d, "ang" : ang, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, excess=None, anchor=None, spin=None, orient=None, h=None, **kwargs):
-       super().__init__("rounding_edge_mask", {"l" : l, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, "h" : h, **kwargs})
-
-class rounding_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, d=None, style=None, excess=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_corner_mask", {"r" : r, "d" : d, "style" : style, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_angled_edge_mask(_Bosl2Base):
-    def __init__(self, h=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, ang=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_angled_edge_mask", {"h" : h, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "ang" : ang, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_angled_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, ang=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_angled_corner_mask", {"r" : r, "ang" : ang, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_cylinder_mask(_Bosl2Base):
-    def __init__(self, r=None, rounding=None, d=None, **kwargs):
-       super().__init__("rounding_cylinder_mask", {"r" : r, "rounding" : rounding, "d" : d, **kwargs})
-
-class rounding_hole_mask(_Bosl2Base):
-    def __init__(self, r=None, rounding=None, excess=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_hole_mask", {"r" : r, "rounding" : rounding, "excess" : excess, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class teardrop_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, r=None, angle=None, excess=None, d=None, **kwargs):
-       super().__init__("teardrop_edge_mask", {"l" : l, "r" : r, "angle" : angle, "excess" : excess, "d" : d, **kwargs})
-
-class teardrop_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, angle=None, excess=None, d=None, **kwargs):
-       super().__init__("teardrop_corner_mask", {"r" : r, "angle" : angle, "excess" : excess, "d" : d, **kwargs})
-
-class chamfer_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, chamfer=None, excess=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_edge_mask", {"l" : l, "chamfer" : chamfer, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class chamfer_corner_mask(_Bosl2Base):
-    def __init__(self, chamfer=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_corner_mask", {"chamfer" : chamfer, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class chamfer_cylinder_mask(_Bosl2Base):
-    def __init__(self, r=None, chamfer=None, d=None, ang=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("chamfer_cylinder_mask", {"r" : r, "chamfer" : chamfer, "d" : d, "ang" : ang, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, excess=None, anchor=None, spin=None, orient=None, h=None, **kwargs):
-       super().__init__("rounding_edge_mask", {"l" : l, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, "h" : h, **kwargs})
-
-class rounding_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, d=None, style=None, excess=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_corner_mask", {"r" : r, "d" : d, "style" : style, "excess" : excess, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_angled_edge_mask(_Bosl2Base):
-    def __init__(self, h=None, r=None, r1=None, r2=None, d=None, d1=None, d2=None, ang=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_angled_edge_mask", {"h" : h, "r" : r, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "ang" : ang, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_angled_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, ang=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_angled_corner_mask", {"r" : r, "ang" : ang, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class rounding_cylinder_mask(_Bosl2Base):
-    def __init__(self, r=None, rounding=None, d=None, **kwargs):
-       super().__init__("rounding_cylinder_mask", {"r" : r, "rounding" : rounding, "d" : d, **kwargs})
-
-class rounding_hole_mask(_Bosl2Base):
-    def __init__(self, r=None, rounding=None, excess=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("rounding_hole_mask", {"r" : r, "rounding" : rounding, "excess" : excess, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class teardrop_edge_mask(_Bosl2Base):
-    def __init__(self, l=None, r=None, angle=None, excess=None, d=None, **kwargs):
-       super().__init__("teardrop_edge_mask", {"l" : l, "r" : r, "angle" : angle, "excess" : excess, "d" : d, **kwargs})
-
-class teardrop_corner_mask(_Bosl2Base):
-    def __init__(self, r=None, angle=None, excess=None, d=None, **kwargs):
-       super().__init__("teardrop_corner_mask", {"r" : r, "angle" : angle, "excess" : excess, "d" : d, **kwargs})
+class is_region(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_region", {"x" : x, **kwargs})
+
+class is_valid_region(_Bosl2Base):
+    def __init__(self, region=None, eps=None, **kwargs):
+       super().__init__("is_valid_region", {"region" : region, "eps" : eps, **kwargs})
+
+class _polygon_crosses_region(_Bosl2Base):
+    def __init__(self, region=None, poly=None, eps=None, **kwargs):
+       super().__init__("_polygon_crosses_region", {"region" : region, "poly" : poly, "eps" : eps, **kwargs})
+
+class is_region_simple(_Bosl2Base):
+    def __init__(self, region=None, eps=None, **kwargs):
+       super().__init__("is_region_simple", {"region" : region, "eps" : eps, **kwargs})
+
+class make_region(_Bosl2Base):
+    def __init__(self, polys=None, nonzero=None, eps=None, **kwargs):
+       super().__init__("make_region", {"polys" : polys, "nonzero" : nonzero, "eps" : eps, **kwargs})
+
+class force_region(_Bosl2Base):
+    def __init__(self, poly=None, **kwargs):
+       super().__init__("force_region", {"poly" : poly, **kwargs})
+
+class point_in_region(_Bosl2Base):
+    def __init__(self, point=None, region=None, eps=None, **kwargs):
+       super().__init__("point_in_region", {"point" : point, "region" : region, "eps" : eps, **kwargs})
+
+class _point_in_region(_Bosl2Base):
+    def __init__(self, point=None, region=None, eps=None, i=None, cnt=None, **kwargs):
+       super().__init__("_point_in_region", {"point" : point, "region" : region, "eps" : eps, "i" : i, "cnt" : cnt, **kwargs})
+
+class region_area(_Bosl2Base):
+    def __init__(self, region=None, **kwargs):
+       super().__init__("region_area", {"region" : region, **kwargs})
+
+class _clockwise_region(_Bosl2Base):
+    def __init__(self, r=None, **kwargs):
+       super().__init__("_clockwise_region", {"r" : r, **kwargs})
+
+class are_regions_equal(_Bosl2Base):
+    def __init__(self, region1=None, region2=None, either_winding=None, **kwargs):
+       super().__init__("are_regions_equal", {"region1" : region1, "region2" : region2, "either_winding" : either_winding, **kwargs})
+
+class __are_regions_equal(_Bosl2Base):
+    def __init__(self, region1=None, region2=None, i=None, **kwargs):
+       super().__init__("__are_regions_equal", {"region1" : region1, "region2" : region2, "i" : i, **kwargs})
+
+class _region_region_intersections(_Bosl2Base):
+    def __init__(self, region1=None, region2=None, closed1=None, closed2=None, eps=None, **kwargs):
+       super().__init__("_region_region_intersections", {"region1" : region1, "region2" : region2, "closed1" : closed1, "closed2" : closed2, "eps" : eps, **kwargs})
+
+class split_region_at_region_crossings(_Bosl2Base):
+    def __init__(self, region1=None, region2=None, closed1=None, closed2=None, eps=None, **kwargs):
+       super().__init__("split_region_at_region_crossings", {"region1" : region1, "region2" : region2, "closed1" : closed1, "closed2" : closed2, "eps" : eps, **kwargs})
+
+class region_parts(_Bosl2Base):
+    def __init__(self, region=None, **kwargs):
+       super().__init__("region_parts", {"region" : region, **kwargs})
+
+class _offset_chamfer(_Bosl2Base):
+    def __init__(self, center=None, points=None, delta=None, **kwargs):
+       super().__init__("_offset_chamfer", {"center" : center, "points" : points, "delta" : delta, **kwargs})
+
+class _shift_segment(_Bosl2Base):
+    def __init__(self, segment=None, d=None, **kwargs):
+       super().__init__("_shift_segment", {"segment" : segment, "d" : d, **kwargs})
+
+class _segment_extension(_Bosl2Base):
+    def __init__(self, s1=None, s2=None, **kwargs):
+       super().__init__("_segment_extension", {"s1" : s1, "s2" : s2, **kwargs})
+
+class _makefaces(_Bosl2Base):
+    def __init__(self, direction=None, startind=None, good=None, pointcount=None, closed=None, **kwargs):
+       super().__init__("_makefaces", {"direction" : direction, "startind" : startind, "good" : good, "pointcount" : pointcount, "closed" : closed, **kwargs})
+
+class _makefaces_recurse(_Bosl2Base):
+    def __init__(self, startind1=None, startind2=None, numfirst=None, numsecond=None, lenlist=None, closed=None, firstind=None, secondind=None, faces=None, **kwargs):
+       super().__init__("_makefaces_recurse", {"startind1" : startind1, "startind2" : startind2, "numfirst" : numfirst, "numsecond" : numsecond, "lenlist" : lenlist, "closed" : closed, "firstind" : firstind, "secondind" : secondind, "faces" : faces, **kwargs})
+
+class _good_segments(_Bosl2Base):
+    def __init__(self, path=None, d=None, shiftsegs=None, closed=None, quality=None, **kwargs):
+       super().__init__("_good_segments", {"path" : path, "d" : d, "shiftsegs" : shiftsegs, "closed" : closed, "quality" : quality, **kwargs})
+
+class _segment_good(_Bosl2Base):
+    def __init__(self, path=None, pathseg_unit=None, pathseg_len=None, d=None, seg=None, alpha=None, index=None, **kwargs):
+       super().__init__("_segment_good", {"path" : path, "pathseg_unit" : pathseg_unit, "pathseg_len" : pathseg_len, "d" : d, "seg" : seg, "alpha" : alpha, "index" : index, **kwargs})
+
+class _point_dist(_Bosl2Base):
+    def __init__(self, path=None, pathseg_unit=None, pathseg_len=None, pt=None, **kwargs):
+       super().__init__("_point_dist", {"path" : path, "pathseg_unit" : pathseg_unit, "pathseg_len" : pathseg_len, "pt" : pt, **kwargs})
+
+class offset(_Bosl2Base):
+    def __init__(self, path=None, r=None, delta=None, chamfer=None, closed=None, check_valid=None, quality=None, return_faces=None, firstface_index=None, flip_faces=None, same_length=None, **kwargs):
+       super().__init__("offset", {"path" : path, "r" : r, "delta" : delta, "chamfer" : chamfer, "closed" : closed, "check_valid" : check_valid, "quality" : quality, "return_faces" : return_faces, "firstface_index" : firstface_index, "flip_faces" : flip_faces, "same_length" : same_length, **kwargs})
+
+class _filter_region_parts(_Bosl2Base):
+    def __init__(self, region1=None, region2=None, keep=None, eps=None, **kwargs):
+       super().__init__("_filter_region_parts", {"region1" : region1, "region2" : region2, "keep" : keep, "eps" : eps, **kwargs})
+
+class _list_three(_Bosl2Base):
+    def __init__(self, a=None, b=None, c=None, **kwargs):
+       super().__init__("_list_three", {"a" : a, "b" : b, "c" : c, **kwargs})
+
+class union(_Bosl2Base):
+    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
+       super().__init__("union", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+
+class difference(_Bosl2Base):
+    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
+       super().__init__("difference", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+
+class intersection(_Bosl2Base):
+    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
+       super().__init__("intersection", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+
+class exclusive_or(_Bosl2Base):
+    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
+       super().__init__("exclusive_or", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+
+class region(_Bosl2Base):
+    def __init__(self, r=None, anchor=None, spin=None, cp=None, atype=None, **kwargs):
+       super().__init__("region", {"r" : r, "anchor" : anchor, "spin" : spin, "cp" : cp, "atype" : atype, **kwargs})
+
+class exclusive_or(_Bosl2Base):
+    def __init__(self, **kwargs):
+       super().__init__("exclusive_or", {**kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/math.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/math.py`

 * *Files 0% similar despite different names*

```diff
@@ -86,22 +86,34 @@
     def __init__(self, x=None, **kwargs):
        super().__init__("atanh", {"x" : x, **kwargs})
 
 class quant(_Bosl2Base):
     def __init__(self, x=None, y=None, **kwargs):
        super().__init__("quant", {"x" : x, "y" : y, **kwargs})
 
+class _roundall(_Bosl2Base):
+    def __init__(self, data=None, **kwargs):
+       super().__init__("_roundall", {"data" : data, **kwargs})
+
 class quantdn(_Bosl2Base):
     def __init__(self, x=None, y=None, **kwargs):
        super().__init__("quantdn", {"x" : x, "y" : y, **kwargs})
 
+class _floorall(_Bosl2Base):
+    def __init__(self, data=None, **kwargs):
+       super().__init__("_floorall", {"data" : data, **kwargs})
+
 class quantup(_Bosl2Base):
     def __init__(self, x=None, y=None, **kwargs):
        super().__init__("quantup", {"x" : x, "y" : y, **kwargs})
 
+class _ceilall(_Bosl2Base):
+    def __init__(self, data=None, **kwargs):
+       super().__init__("_ceilall", {"data" : data, **kwargs})
+
 class constrain(_Bosl2Base):
     def __init__(self, v=None, minval=None, maxval=None, **kwargs):
        super().__init__("constrain", {"v" : v, "minval" : minval, "maxval" : maxval, **kwargs})
 
 class posmod(_Bosl2Base):
     def __init__(self, x=None, m=None, **kwargs):
        super().__init__("posmod", {"x" : x, "m" : m, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/metric_screws.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/metric_screws.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/modular_hose.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/modular_hose.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/mutators.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/mutators.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/nema_steppers.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/vectors.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,76 +1,104 @@
 from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
-_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/nema_steppers.scad'}", use_not_include=False)
+_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/vectors.scad'}", use_not_include=False)
 
-class nema_motor_width(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_width", {"size" : size, **kwargs})
-
-class nema_motor_plinth_height(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_plinth_height", {"size" : size, **kwargs})
-
-class nema_motor_plinth_diam(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_plinth_diam", {"size" : size, **kwargs})
-
-class nema_motor_screw_spacing(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_screw_spacing", {"size" : size, **kwargs})
-
-class nema_motor_screw_size(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_screw_size", {"size" : size, **kwargs})
-
-class nema_motor_screw_depth(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("nema_motor_screw_depth", {"size" : size, **kwargs})
-
-class nema11_stepper(_Bosl2Base):
-    def __init__(self, h=None, shaft=None, shaft_len=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema11_stepper", {"h" : h, "shaft" : shaft, "shaft_len" : shaft_len, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema14_stepper(_Bosl2Base):
-    def __init__(self, h=None, shaft=None, shaft_len=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema14_stepper", {"h" : h, "shaft" : shaft, "shaft_len" : shaft_len, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema17_stepper(_Bosl2Base):
-    def __init__(self, h=None, shaft=None, shaft_len=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema17_stepper", {"h" : h, "shaft" : shaft, "shaft_len" : shaft_len, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema23_stepper(_Bosl2Base):
-    def __init__(self, h=None, shaft=None, shaft_len=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema23_stepper", {"h" : h, "shaft" : shaft, "shaft_len" : shaft_len, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema34_stepper(_Bosl2Base):
-    def __init__(self, h=None, shaft=None, shaft_len=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema34_stepper", {"h" : h, "shaft" : shaft, "shaft_len" : shaft_len, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema_mount_holes(_Bosl2Base):
-    def __init__(self, size=None, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema_mount_holes", {"size" : size, "depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema11_mount_holes(_Bosl2Base):
-    def __init__(self, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema11_mount_holes", {"depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema14_mount_holes(_Bosl2Base):
-    def __init__(self, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema14_mount_holes", {"depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema17_mount_holes(_Bosl2Base):
-    def __init__(self, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema17_mount_holes", {"depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema23_mount_holes(_Bosl2Base):
-    def __init__(self, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema23_mount_holes", {"depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class nema34_mount_holes(_Bosl2Base):
-    def __init__(self, depth=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("nema34_mount_holes", {"depth" : depth, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+class is_vector(_Bosl2Base):
+    def __init__(self, v=None, length=None, zero=None, all_nonzero=None, eps=None, **kwargs):
+       super().__init__("is_vector", {"v" : v, "length" : length, "zero" : zero, "all_nonzero" : all_nonzero, "eps" : eps, **kwargs})
+
+class add_scalar(_Bosl2Base):
+    def __init__(self, v=None, s=None, **kwargs):
+       super().__init__("add_scalar", {"v" : v, "s" : s, **kwargs})
+
+class v_mul(_Bosl2Base):
+    def __init__(self, v1=None, v2=None, **kwargs):
+       super().__init__("v_mul", {"v1" : v1, "v2" : v2, **kwargs})
+
+class v_div(_Bosl2Base):
+    def __init__(self, v1=None, v2=None, **kwargs):
+       super().__init__("v_div", {"v1" : v1, "v2" : v2, **kwargs})
+
+class v_abs(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("v_abs", {"v" : v, **kwargs})
+
+class v_floor(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("v_floor", {"v" : v, **kwargs})
+
+class v_ceil(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("v_ceil", {"v" : v, **kwargs})
+
+class v_lookup(_Bosl2Base):
+    def __init__(self, x=None, v=None, **kwargs):
+       super().__init__("v_lookup", {"x" : x, "v" : v, **kwargs})
+
+class unit(_Bosl2Base):
+    def __init__(self, v=None, error=None, **kwargs):
+       super().__init__("unit", {"v" : v, "error" : error, **kwargs})
+
+class v_theta(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("v_theta", {"v" : v, **kwargs})
+
+class vector_angle(_Bosl2Base):
+    def __init__(self, v1=None, v2=None, v3=None, **kwargs):
+       super().__init__("vector_angle", {"v1" : v1, "v2" : v2, "v3" : v3, **kwargs})
+
+class vector_axis(_Bosl2Base):
+    def __init__(self, v1=None, v2=None, v3=None, **kwargs):
+       super().__init__("vector_axis", {"v1" : v1, "v2" : v2, "v3" : v3, **kwargs})
+
+class vector_bisect(_Bosl2Base):
+    def __init__(self, v1=None, v2=None, **kwargs):
+       super().__init__("vector_bisect", {"v1" : v1, "v2" : v2, **kwargs})
+
+class pointlist_bounds(_Bosl2Base):
+    def __init__(self, pts=None, **kwargs):
+       super().__init__("pointlist_bounds", {"pts" : pts, **kwargs})
+
+class closest_point(_Bosl2Base):
+    def __init__(self, pt=None, points=None, **kwargs):
+       super().__init__("closest_point", {"pt" : pt, "points" : points, **kwargs})
+
+class furthest_point(_Bosl2Base):
+    def __init__(self, pt=None, points=None, **kwargs):
+       super().__init__("furthest_point", {"pt" : pt, "points" : points, **kwargs})
+
+class vector_search(_Bosl2Base):
+    def __init__(self, query=None, r=None, target=None, **kwargs):
+       super().__init__("vector_search", {"query" : query, "r" : r, "target" : target, **kwargs})
+
+class _bt_search(_Bosl2Base):
+    def __init__(self, query=None, r=None, points=None, tree=None, **kwargs):
+       super().__init__("_bt_search", {"query" : query, "r" : r, "points" : points, "tree" : tree, **kwargs})
+
+class vector_search_tree(_Bosl2Base):
+    def __init__(self, points=None, leafsize=None, treemin=None, **kwargs):
+       super().__init__("vector_search_tree", {"points" : points, "leafsize" : leafsize, "treemin" : treemin, **kwargs})
+
+class _bt_tree(_Bosl2Base):
+    def __init__(self, points=None, ind=None, leafsize=None, **kwargs):
+       super().__init__("_bt_tree", {"points" : points, "ind" : ind, "leafsize" : leafsize, **kwargs})
+
+class vector_nearest(_Bosl2Base):
+    def __init__(self, query=None, k=None, target=None, **kwargs):
+       super().__init__("vector_nearest", {"query" : query, "k" : k, "target" : target, **kwargs})
+
+class _bt_nearest(_Bosl2Base):
+    def __init__(self, p=None, k=None, points=None, tree=None, answers=None, **kwargs):
+       super().__init__("_bt_nearest", {"p" : p, "k" : k, "points" : points, "tree" : tree, "answers" : answers, **kwargs})
+
+class _insert_sorted(_Bosl2Base):
+    def __init__(self, list=None, k=None, new=None, **kwargs):
+       super().__init__("_insert_sorted", {"list" : list, "k" : k, "new" : new, **kwargs})
+
+class _insert_many(_Bosl2Base):
+    def __init__(self, list=None, k=None, newlist=None, i=None, **kwargs):
+       super().__init__("_insert_many", {"list" : list, "k" : k, "newlist" : newlist, "i" : i, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/openscad.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/strings.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,134 +1,160 @@
+from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
+from solid2.core.scad_import import extra_scad_include as _extra_scad_include
+from pathlib import Path as _Path
+
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
-class union(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("union", {**kwargs})
-
-class difference(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("difference", {**kwargs})
-
-class intersection(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("intersection", {**kwargs})
-
-class intersection_for(_Bosl2Base):
-    def __init__(self, n=None, **kwargs):
-       super().__init__("intersection_for", {"n" : n, **kwargs})
-
-class translate(_Bosl2Base):
-    def __init__(self, v=None, **kwargs):
-       super().__init__("translate", {"v" : v, **kwargs})
-
-class scale(_Bosl2Base):
-    def __init__(self, v=None, **kwargs):
-       super().__init__("scale", {"v" : v, **kwargs})
-
-class rotate(_Bosl2Base):
-    def __init__(self, a=None, v=None, **kwargs):
-       super().__init__("rotate", {"a" : a, "v" : v, **kwargs})
-
-class mirror(_Bosl2Base):
-    def __init__(self, v=None, **kwargs):
-       super().__init__("mirror", {"v" : v, **kwargs})
-
-class resize(_Bosl2Base):
-    def __init__(self, newsize=None, auto=None, **kwargs):
-       super().__init__("resize", {"newsize" : newsize, "auto" : auto, **kwargs})
-
-class color(_Bosl2Base):
-    def __init__(self, c=None, alpha=None, **kwargs):
-       super().__init__("color", {"c" : c, "alpha" : alpha, **kwargs})
-
-class minkowski(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("minkowski", {**kwargs})
-
-class offset(_Bosl2Base):
-    def __init__(self, r=None, delta=None, chamfer=None, _fn=None, **kwargs):
-       super().__init__("offset", {"r" : r, "delta" : delta, "chamfer" : chamfer, "_fn" : _fn, **kwargs})
-
-class hull(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("hull", {**kwargs})
-
-class render(_Bosl2Base):
-    def __init__(self, convexity=None, **kwargs):
-       super().__init__("render", {"convexity" : convexity, **kwargs})
-
-class linear_extrude(_Bosl2Base):
-    def __init__(self, height=None, center=None, convexity=None, twist=None, slices=None, scale=None, **kwargs):
-       super().__init__("linear_extrude", {"height" : height, "center" : center, "convexity" : convexity, "twist" : twist, "slices" : slices, "scale" : scale, **kwargs})
-
-class rotate_extrude(_Bosl2Base):
-    def __init__(self, angle=None, convexity=None, _fn=None, **kwargs):
-       super().__init__("rotate_extrude", {"angle" : angle, "convexity" : convexity, "_fn" : _fn, **kwargs})
-
-class projection(_Bosl2Base):
-    def __init__(self, cut=None, **kwargs):
-       super().__init__("projection", {"cut" : cut, **kwargs})
-
-class surface(_Bosl2Base):
-    def __init__(self, file=None, center=None, convexity=None, invert=None, **kwargs):
-       super().__init__("surface", {"file" : file, "center" : center, "convexity" : convexity, "invert" : invert, **kwargs})
-
-class child(_Bosl2Base):
-    def __init__(self, index=None, vector=None, range=None, **kwargs):
-       super().__init__("child", {"index" : index, "vector" : vector, "range" : range, **kwargs})
-
-class children(_Bosl2Base):
-    def __init__(self, index=None, vector=None, range=None, **kwargs):
-       super().__init__("children", {"index" : index, "vector" : vector, "range" : range, **kwargs})
-
-class import_stl(_Bosl2Base):
-    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
-       super().__init__("import_stl", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
-
-class import_dxf(_Bosl2Base):
-    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
-       super().__init__("import_dxf", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
-
-class _import(_Bosl2Base):
-    def __init__(self, file=None, origin=None, convexity=None, layer=None, **kwargs):
-       super().__init__("_import", {"file" : file, "origin" : origin, "convexity" : convexity, "layer" : layer, **kwargs})
-
-class assign(_Bosl2Base):
-    def __init__(self, **kwargs):
-       super().__init__("assign", {**kwargs})
-
-class multmatrix(_Bosl2Base):
-    def __init__(self, m=None, **kwargs):
-       super().__init__("multmatrix", {"m" : m, **kwargs})
-
-class polygon(_Bosl2Base):
-    def __init__(self, points=None, paths=None, convexity=None, **kwargs):
-       super().__init__("polygon", {"points" : points, "paths" : paths, "convexity" : convexity, **kwargs})
-
-class circle(_Bosl2Base):
-    def __init__(self, r=None, d=None, _fn=None, **kwargs):
-       super().__init__("circle", {"r" : r, "d" : d, "_fn" : _fn, **kwargs})
-
-class square(_Bosl2Base):
-    def __init__(self, size=None, center=None, **kwargs):
-       super().__init__("square", {"size" : size, "center" : center, **kwargs})
-
-class sphere(_Bosl2Base):
-    def __init__(self, r=None, d=None, _fn=None, **kwargs):
-       super().__init__("sphere", {"r" : r, "d" : d, "_fn" : _fn, **kwargs})
-
-class cube(_Bosl2Base):
-    def __init__(self, size=None, center=None, **kwargs):
-       super().__init__("cube", {"size" : size, "center" : center, **kwargs})
-
-class cylinder(_Bosl2Base):
-    def __init__(self, r=None, h=None, r1=None, r2=None, d=None, d1=None, d2=None, center=None, _fn=None, **kwargs):
-       super().__init__("cylinder", {"r" : r, "h" : h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "center" : center, "_fn" : _fn, **kwargs})
-
-class polyhedron(_Bosl2Base):
-    def __init__(self, points=None, faces=None, convexity=None, triangles=None, **kwargs):
-       super().__init__("polyhedron", {"points" : points, "faces" : faces, "convexity" : convexity, "triangles" : triangles, **kwargs})
-
-class text(_Bosl2Base):
-    def __init__(self, text=None, size=None, font=None, halign=None, valign=None, spacing=None, direction=None, language=None, script=None, _fn=None, **kwargs):
-       super().__init__("text", {"text" : text, "size" : size, "font" : font, "halign" : halign, "valign" : valign, "spacing" : spacing, "direction" : direction, "language" : language, "script" : script, "_fn" : _fn, **kwargs})
+_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/strings.scad'}", use_not_include=False)
+
+class substr(_Bosl2Base):
+    def __init__(self, str=None, pos=None, len=None, **kwargs):
+       super().__init__("substr", {"str" : str, "pos" : pos, "len" : len, **kwargs})
+
+class _substr(_Bosl2Base):
+    def __init__(self, str=None, pos=None, len=None, substr=None, **kwargs):
+       super().__init__("_substr", {"str" : str, "pos" : pos, "len" : len, "substr" : substr, **kwargs})
+
+class suffix(_Bosl2Base):
+    def __init__(self, str=None, len=None, **kwargs):
+       super().__init__("suffix", {"str" : str, "len" : len, **kwargs})
+
+class str_find(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, start=None, last=None, all=None, **kwargs):
+       super().__init__("str_find", {"str" : str, "pattern" : pattern, "start" : start, "last" : last, "all" : all, **kwargs})
+
+class _str_find_first(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, max_sindex=None, sindex=None, **kwargs):
+       super().__init__("_str_find_first", {"str" : str, "pattern" : pattern, "max_sindex" : max_sindex, "sindex" : sindex, **kwargs})
+
+class _str_find_last(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, sindex=None, **kwargs):
+       super().__init__("_str_find_last", {"str" : str, "pattern" : pattern, "sindex" : sindex, **kwargs})
+
+class _str_find_all(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, **kwargs):
+       super().__init__("_str_find_all", {"str" : str, "pattern" : pattern, **kwargs})
+
+class substr_match(_Bosl2Base):
+    def __init__(self, str=None, start=None, pattern=None, **kwargs):
+       super().__init__("substr_match", {"str" : str, "start" : start, "pattern" : pattern, **kwargs})
+
+class _substr_match_recurse(_Bosl2Base):
+    def __init__(self, str=None, sindex=None, pattern=None, plen=None, pindex=None, **kwargs):
+       super().__init__("_substr_match_recurse", {"str" : str, "sindex" : sindex, "pattern" : pattern, "plen" : plen, "pindex" : pindex, **kwargs})
+
+class starts_with(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, **kwargs):
+       super().__init__("starts_with", {"str" : str, "pattern" : pattern, **kwargs})
+
+class ends_with(_Bosl2Base):
+    def __init__(self, str=None, pattern=None, **kwargs):
+       super().__init__("ends_with", {"str" : str, "pattern" : pattern, **kwargs})
+
+class str_split(_Bosl2Base):
+    def __init__(self, str=None, sep=None, keep_nulls=None, **kwargs):
+       super().__init__("str_split", {"str" : str, "sep" : sep, "keep_nulls" : keep_nulls, **kwargs})
+
+class _str_split_recurse(_Bosl2Base):
+    def __init__(self, str=None, sep=None, i=None, result=None, **kwargs):
+       super().__init__("_str_split_recurse", {"str" : str, "sep" : sep, "i" : i, "result" : result, **kwargs})
+
+class _remove_empty_strs(_Bosl2Base):
+    def __init__(self, list=None, **kwargs):
+       super().__init__("_remove_empty_strs", {"list" : list, **kwargs})
+
+class str_join(_Bosl2Base):
+    def __init__(self, list=None, sep=None, _i=None, _result=None, **kwargs):
+       super().__init__("str_join", {"list" : list, "sep" : sep, "_i" : _i, "_result" : _result, **kwargs})
+
+class _str_count_leading(_Bosl2Base):
+    def __init__(self, s=None, c=None, _i=None, **kwargs):
+       super().__init__("_str_count_leading", {"s" : s, "c" : c, "_i" : _i, **kwargs})
+
+class _str_count_trailing(_Bosl2Base):
+    def __init__(self, s=None, c=None, _i=None, **kwargs):
+       super().__init__("_str_count_trailing", {"s" : s, "c" : c, "_i" : _i, **kwargs})
+
+class str_strip(_Bosl2Base):
+    def __init__(self, s=None, c=None, start=None, end=None, **kwargs):
+       super().__init__("str_strip", {"s" : s, "c" : c, "start" : start, "end" : end, **kwargs})
+
+class str_pad(_Bosl2Base):
+    def __init__(self, str=None, length=None, char=None, left=None, **kwargs):
+       super().__init__("str_pad", {"str" : str, "length" : length, "char" : char, "left" : left, **kwargs})
+
+class str_replace_char(_Bosl2Base):
+    def __init__(self, str=None, char=None, replace=None, **kwargs):
+       super().__init__("str_replace_char", {"str" : str, "char" : char, "replace" : replace, **kwargs})
+
+class downcase(_Bosl2Base):
+    def __init__(self, str=None, **kwargs):
+       super().__init__("downcase", {"str" : str, **kwargs})
+
+class upcase(_Bosl2Base):
+    def __init__(self, str=None, **kwargs):
+       super().__init__("upcase", {"str" : str, **kwargs})
+
+class rand_str(_Bosl2Base):
+    def __init__(self, n=None, charset=None, seed=None, **kwargs):
+       super().__init__("rand_str", {"n" : n, "charset" : charset, "seed" : seed, **kwargs})
+
+class parse_int(_Bosl2Base):
+    def __init__(self, str=None, base=None, **kwargs):
+       super().__init__("parse_int", {"str" : str, "base" : base, **kwargs})
+
+class _parse_int_recurse(_Bosl2Base):
+    def __init__(self, str=None, base=None, i=None, **kwargs):
+       super().__init__("_parse_int_recurse", {"str" : str, "base" : base, "i" : i, **kwargs})
+
+class parse_float(_Bosl2Base):
+    def __init__(self, str=None, **kwargs):
+       super().__init__("parse_float", {"str" : str, **kwargs})
+
+class parse_frac(_Bosl2Base):
+    def __init__(self, str=None, mixed=None, improper=None, signed=None, **kwargs):
+       super().__init__("parse_frac", {"str" : str, "mixed" : mixed, "improper" : improper, "signed" : signed, **kwargs})
+
+class parse_num(_Bosl2Base):
+    def __init__(self, str=None, **kwargs):
+       super().__init__("parse_num", {"str" : str, **kwargs})
+
+class format_int(_Bosl2Base):
+    def __init__(self, i=None, mindigits=None, **kwargs):
+       super().__init__("format_int", {"i" : i, "mindigits" : mindigits, **kwargs})
+
+class format_fixed(_Bosl2Base):
+    def __init__(self, f=None, digits=None, **kwargs):
+       super().__init__("format_fixed", {"f" : f, "digits" : digits, **kwargs})
+
+class format_float(_Bosl2Base):
+    def __init__(self, f=None, sig=None, **kwargs):
+       super().__init__("format_float", {"f" : f, "sig" : sig, **kwargs})
+
+class _format_matrix(_Bosl2Base):
+    def __init__(self, M=None, sig=None, sep=None, eps=None, **kwargs):
+       super().__init__("_format_matrix", {"M" : M, "sig" : sig, "sep" : sep, "eps" : eps, **kwargs})
+
+class format(_Bosl2Base):
+    def __init__(self, fmt=None, vals=None, **kwargs):
+       super().__init__("format", {"fmt" : fmt, "vals" : vals, **kwargs})
+
+class is_lower(_Bosl2Base):
+    def __init__(self, s=None, **kwargs):
+       super().__init__("is_lower", {"s" : s, **kwargs})
+
+class is_upper(_Bosl2Base):
+    def __init__(self, s=None, **kwargs):
+       super().__init__("is_upper", {"s" : s, **kwargs})
+
+class is_digit(_Bosl2Base):
+    def __init__(self, s=None, **kwargs):
+       super().__init__("is_digit", {"s" : s, **kwargs})
+
+class is_hexdigit(_Bosl2Base):
+    def __init__(self, s=None, **kwargs):
+       super().__init__("is_hexdigit", {"s" : s, **kwargs})
+
+class is_letter(_Bosl2Base):
+    def __init__(self, s=None, **kwargs):
+       super().__init__("is_letter", {"s" : s, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/partitions.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/partitions.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/paths.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/paths.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,26 +14,14 @@
     def __init__(self, path=None, name=None, **kwargs):
        super().__init__("is_1region", {"path" : path, "name" : name, **kwargs})
 
 class force_path(_Bosl2Base):
     def __init__(self, path=None, name=None, **kwargs):
        super().__init__("force_path", {"path" : path, "name" : name, **kwargs})
 
-class is_closed_path(_Bosl2Base):
-    def __init__(self, path=None, eps=None, **kwargs):
-       super().__init__("is_closed_path", {"path" : path, "eps" : eps, **kwargs})
-
-class close_path(_Bosl2Base):
-    def __init__(self, path=None, eps=None, **kwargs):
-       super().__init__("close_path", {"path" : path, "eps" : eps, **kwargs})
-
-class cleanup_path(_Bosl2Base):
-    def __init__(self, path=None, eps=None, **kwargs):
-       super().__init__("cleanup_path", {"path" : path, "eps" : eps, **kwargs})
-
 class _path_select(_Bosl2Base):
     def __init__(self, path=None, s1=None, u1=None, s2=None, u2=None, closed=None, **kwargs):
        super().__init__("_path_select", {"path" : path, "s1" : s1, "u1" : u1, "s2" : s2, "u2" : u2, "closed" : closed, **kwargs})
 
 class path_merge_collinear(_Bosl2Base):
     def __init__(self, path=None, closed=None, eps=None, **kwargs):
        super().__init__("path_merge_collinear", {"path" : path, "closed" : closed, "eps" : eps, **kwargs})
@@ -86,21 +74,29 @@
     def __init__(self, path=None, closed=None, **kwargs):
        super().__init__("path_curvature", {"path" : path, "closed" : closed, **kwargs})
 
 class path_torsion(_Bosl2Base):
     def __init__(self, path=None, closed=None, **kwargs):
        super().__init__("path_torsion", {"path" : path, "closed" : closed, **kwargs})
 
-class _path_cut_points(_Bosl2Base):
-    def __init__(self, path=None, dists=None, closed=None, direction=None, **kwargs):
-       super().__init__("_path_cut_points", {"path" : path, "dists" : dists, "closed" : closed, "direction" : direction, **kwargs})
+class path_cut(_Bosl2Base):
+    def __init__(self, path=None, cutdist=None, closed=None, **kwargs):
+       super().__init__("path_cut", {"path" : path, "cutdist" : cutdist, "closed" : closed, **kwargs})
+
+class _path_cut_getpaths(_Bosl2Base):
+    def __init__(self, path=None, cutlist=None, closed=None, **kwargs):
+       super().__init__("_path_cut_getpaths", {"path" : path, "cutlist" : cutlist, "closed" : closed, **kwargs})
+
+class path_cut_points(_Bosl2Base):
+    def __init__(self, path=None, cutdist=None, closed=None, direction=None, **kwargs):
+       super().__init__("path_cut_points", {"path" : path, "cutdist" : cutdist, "closed" : closed, "direction" : direction, **kwargs})
 
-class _path_cut_points_recurse(_Bosl2Base):
+class path_cut_points_recurse(_Bosl2Base):
     def __init__(self, path=None, dists=None, closed=None, pind=None, dtotal=None, dind=None, result=None, **kwargs):
-       super().__init__("_path_cut_points_recurse", {"path" : path, "dists" : dists, "closed" : closed, "pind" : pind, "dtotal" : dtotal, "dind" : dind, "result" : result, **kwargs})
+       super().__init__("path_cut_points_recurse", {"path" : path, "dists" : dists, "closed" : closed, "pind" : pind, "dtotal" : dtotal, "dind" : dind, "result" : result, **kwargs})
 
 class _path_cut_single(_Bosl2Base):
     def __init__(self, path=None, dist=None, closed=None, ind=None, eps=None, **kwargs):
        super().__init__("_path_cut_single", {"path" : path, "dist" : dist, "closed" : closed, "ind" : ind, "eps" : eps, **kwargs})
 
 class _path_cuts_normals(_Bosl2Base):
     def __init__(self, path=None, cuts=None, dirs=None, closed=None, **kwargs):
@@ -110,22 +106,14 @@
     def __init__(self, path=None, ind=None, i=None, closed=None, **kwargs):
        super().__init__("_path_plane", {"path" : path, "ind" : ind, "i" : i, "closed" : closed, **kwargs})
 
 class _path_cuts_dir(_Bosl2Base):
     def __init__(self, path=None, cuts=None, closed=None, eps=None, **kwargs):
        super().__init__("_path_cuts_dir", {"path" : path, "cuts" : cuts, "closed" : closed, "eps" : eps, **kwargs})
 
-class path_cut(_Bosl2Base):
-    def __init__(self, path=None, cutdist=None, closed=None, **kwargs):
-       super().__init__("path_cut", {"path" : path, "cutdist" : cutdist, "closed" : closed, **kwargs})
-
-class _path_cut_getpaths(_Bosl2Base):
-    def __init__(self, path=None, cutlist=None, closed=None, **kwargs):
-       super().__init__("_path_cut_getpaths", {"path" : path, "cutlist" : cutlist, "closed" : closed, **kwargs})
-
 class _cut_to_seg_u_form(_Bosl2Base):
     def __init__(self, pathcut=None, path=None, closed=None, **kwargs):
        super().__init__("_cut_to_seg_u_form", {"pathcut" : pathcut, "path" : path, "closed" : closed, **kwargs})
 
 class split_path_at_self_crossings(_Bosl2Base):
     def __init__(self, path=None, closed=None, eps=None, **kwargs):
        super().__init__("split_path_at_self_crossings", {"path" : path, "closed" : closed, "eps" : eps, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/polyhedra.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/polyhedra.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/regions.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/utility.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,136 +1,204 @@
 from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
-_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/regions.scad'}", use_not_include=False)
+_extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/utility.scad'}", use_not_include=False)
 
-class is_region(_Bosl2Base):
+class typeof(_Bosl2Base):
     def __init__(self, x=None, **kwargs):
-       super().__init__("is_region", {"x" : x, **kwargs})
+       super().__init__("typeof", {"x" : x, **kwargs})
 
-class is_valid_region(_Bosl2Base):
-    def __init__(self, region=None, eps=None, **kwargs):
-       super().__init__("is_valid_region", {"region" : region, "eps" : eps, **kwargs})
+class is_type(_Bosl2Base):
+    def __init__(self, x=None, types=None, **kwargs):
+       super().__init__("is_type", {"x" : x, "types" : types, **kwargs})
 
-class _polygon_crosses_region(_Bosl2Base):
-    def __init__(self, region=None, poly=None, eps=None, **kwargs):
-       super().__init__("_polygon_crosses_region", {"region" : region, "poly" : poly, "eps" : eps, **kwargs})
+class is_def(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_def", {"x" : x, **kwargs})
 
-class is_region_simple(_Bosl2Base):
-    def __init__(self, region=None, eps=None, **kwargs):
-       super().__init__("is_region_simple", {"region" : region, "eps" : eps, **kwargs})
+class is_str(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_str", {"x" : x, **kwargs})
 
-class make_region(_Bosl2Base):
-    def __init__(self, polys=None, nonzero=None, eps=None, **kwargs):
-       super().__init__("make_region", {"polys" : polys, "nonzero" : nonzero, "eps" : eps, **kwargs})
+class is_int(_Bosl2Base):
+    def __init__(self, n=None, **kwargs):
+       super().__init__("is_int", {"n" : n, **kwargs})
 
-class force_region(_Bosl2Base):
-    def __init__(self, poly=None, **kwargs):
-       super().__init__("force_region", {"poly" : poly, **kwargs})
+class is_integer(_Bosl2Base):
+    def __init__(self, n=None, **kwargs):
+       super().__init__("is_integer", {"n" : n, **kwargs})
 
-class point_in_region(_Bosl2Base):
-    def __init__(self, point=None, region=None, eps=None, **kwargs):
-       super().__init__("point_in_region", {"point" : point, "region" : region, "eps" : eps, **kwargs})
+class all_integer(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("all_integer", {"x" : x, **kwargs})
 
-class _point_in_region(_Bosl2Base):
-    def __init__(self, point=None, region=None, eps=None, i=None, cnt=None, **kwargs):
-       super().__init__("_point_in_region", {"point" : point, "region" : region, "eps" : eps, "i" : i, "cnt" : cnt, **kwargs})
+class is_nan(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_nan", {"x" : x, **kwargs})
 
-class region_area(_Bosl2Base):
-    def __init__(self, region=None, **kwargs):
-       super().__init__("region_area", {"region" : region, **kwargs})
+class is_finite(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_finite", {"x" : x, **kwargs})
 
-class _clockwise_region(_Bosl2Base):
-    def __init__(self, r=None, **kwargs):
-       super().__init__("_clockwise_region", {"r" : r, **kwargs})
+class is_range(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_range", {"x" : x, **kwargs})
+
+class valid_range(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("valid_range", {"x" : x, **kwargs})
+
+class is_func(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("is_func", {"x" : x, **kwargs})
+
+class is_consistent(_Bosl2Base):
+    def __init__(self, list=None, pattern=None, **kwargs):
+       super().__init__("is_consistent", {"list" : list, "pattern" : pattern, **kwargs})
+
+class _list_pattern(_Bosl2Base):
+    def __init__(self, list=None, **kwargs):
+       super().__init__("_list_pattern", {"list" : list, **kwargs})
 
-class are_regions_equal(_Bosl2Base):
-    def __init__(self, region1=None, region2=None, either_winding=None, **kwargs):
-       super().__init__("are_regions_equal", {"region1" : region1, "region2" : region2, "either_winding" : either_winding, **kwargs})
+class same_shape(_Bosl2Base):
+    def __init__(self, a=None, b=None, **kwargs):
+       super().__init__("same_shape", {"a" : a, "b" : b, **kwargs})
 
-class __are_regions_equal(_Bosl2Base):
-    def __init__(self, region1=None, region2=None, i=None, **kwargs):
-       super().__init__("__are_regions_equal", {"region1" : region1, "region2" : region2, "i" : i, **kwargs})
+class is_bool_list(_Bosl2Base):
+    def __init__(self, list=None, length=None, **kwargs):
+       super().__init__("is_bool_list", {"list" : list, "length" : length, **kwargs})
 
-class _region_region_intersections(_Bosl2Base):
-    def __init__(self, region1=None, region2=None, closed1=None, closed2=None, eps=None, **kwargs):
-       super().__init__("_region_region_intersections", {"region1" : region1, "region2" : region2, "closed1" : closed1, "closed2" : closed2, "eps" : eps, **kwargs})
+class any(_Bosl2Base):
+    def __init__(self, l=None, func=None, **kwargs):
+       super().__init__("any", {"l" : l, "func" : func, **kwargs})
 
-class split_region_at_region_crossings(_Bosl2Base):
-    def __init__(self, region1=None, region2=None, closed1=None, closed2=None, eps=None, **kwargs):
-       super().__init__("split_region_at_region_crossings", {"region1" : region1, "region2" : region2, "closed1" : closed1, "closed2" : closed2, "eps" : eps, **kwargs})
+class _any_func(_Bosl2Base):
+    def __init__(self, l=None, func=None, i=None, out=None, **kwargs):
+       super().__init__("_any_func", {"l" : l, "func" : func, "i" : i, "out" : out, **kwargs})
 
-class region_parts(_Bosl2Base):
-    def __init__(self, region=None, **kwargs):
-       super().__init__("region_parts", {"region" : region, **kwargs})
+class _any_bool(_Bosl2Base):
+    def __init__(self, l=None, i=None, out=None, **kwargs):
+       super().__init__("_any_bool", {"l" : l, "i" : i, "out" : out, **kwargs})
 
-class _offset_chamfer(_Bosl2Base):
-    def __init__(self, center=None, points=None, delta=None, **kwargs):
-       super().__init__("_offset_chamfer", {"center" : center, "points" : points, "delta" : delta, **kwargs})
+class all(_Bosl2Base):
+    def __init__(self, l=None, func=None, **kwargs):
+       super().__init__("all", {"l" : l, "func" : func, **kwargs})
 
-class _shift_segment(_Bosl2Base):
-    def __init__(self, segment=None, d=None, **kwargs):
-       super().__init__("_shift_segment", {"segment" : segment, "d" : d, **kwargs})
+class _all_func(_Bosl2Base):
+    def __init__(self, l=None, func=None, i=None, out=None, **kwargs):
+       super().__init__("_all_func", {"l" : l, "func" : func, "i" : i, "out" : out, **kwargs})
 
-class _segment_extension(_Bosl2Base):
-    def __init__(self, s1=None, s2=None, **kwargs):
-       super().__init__("_segment_extension", {"s1" : s1, "s2" : s2, **kwargs})
+class _all_bool(_Bosl2Base):
+    def __init__(self, l=None, i=None, out=None, **kwargs):
+       super().__init__("_all_bool", {"l" : l, "i" : i, "out" : out, **kwargs})
 
-class _makefaces(_Bosl2Base):
-    def __init__(self, direction=None, startind=None, good=None, pointcount=None, closed=None, **kwargs):
-       super().__init__("_makefaces", {"direction" : direction, "startind" : startind, "good" : good, "pointcount" : pointcount, "closed" : closed, **kwargs})
+class num_true(_Bosl2Base):
+    def __init__(self, l=None, func=None, **kwargs):
+       super().__init__("num_true", {"l" : l, "func" : func, **kwargs})
 
-class _makefaces_recurse(_Bosl2Base):
-    def __init__(self, startind1=None, startind2=None, numfirst=None, numsecond=None, lenlist=None, closed=None, firstind=None, secondind=None, faces=None, **kwargs):
-       super().__init__("_makefaces_recurse", {"startind1" : startind1, "startind2" : startind2, "numfirst" : numfirst, "numsecond" : numsecond, "lenlist" : lenlist, "closed" : closed, "firstind" : firstind, "secondind" : secondind, "faces" : faces, **kwargs})
+class default(_Bosl2Base):
+    def __init__(self, v=None, dflt=None, **kwargs):
+       super().__init__("default", {"v" : v, "dflt" : dflt, **kwargs})
 
-class _good_segments(_Bosl2Base):
-    def __init__(self, path=None, d=None, shiftsegs=None, closed=None, quality=None, **kwargs):
-       super().__init__("_good_segments", {"path" : path, "d" : d, "shiftsegs" : shiftsegs, "closed" : closed, "quality" : quality, **kwargs})
+class first_defined(_Bosl2Base):
+    def __init__(self, v=None, recursive=None, _i=None, **kwargs):
+       super().__init__("first_defined", {"v" : v, "recursive" : recursive, "_i" : _i, **kwargs})
 
-class _segment_good(_Bosl2Base):
-    def __init__(self, path=None, pathseg_unit=None, pathseg_len=None, d=None, seg=None, alpha=None, index=None, **kwargs):
-       super().__init__("_segment_good", {"path" : path, "pathseg_unit" : pathseg_unit, "pathseg_len" : pathseg_len, "d" : d, "seg" : seg, "alpha" : alpha, "index" : index, **kwargs})
+class one_defined(_Bosl2Base):
+    def __init__(self, vals=None, names=None, dflt=None, **kwargs):
+       super().__init__("one_defined", {"vals" : vals, "names" : names, "dflt" : dflt, **kwargs})
 
-class _point_dist(_Bosl2Base):
-    def __init__(self, path=None, pathseg_unit=None, pathseg_len=None, pt=None, **kwargs):
-       super().__init__("_point_dist", {"path" : path, "pathseg_unit" : pathseg_unit, "pathseg_len" : pathseg_len, "pt" : pt, **kwargs})
+class num_defined(_Bosl2Base):
+    def __init__(self, v=None, **kwargs):
+       super().__init__("num_defined", {"v" : v, **kwargs})
 
-class offset(_Bosl2Base):
-    def __init__(self, path=None, r=None, delta=None, chamfer=None, closed=None, check_valid=None, quality=None, return_faces=None, firstface_index=None, flip_faces=None, same_length=None, **kwargs):
-       super().__init__("offset", {"path" : path, "r" : r, "delta" : delta, "chamfer" : chamfer, "closed" : closed, "check_valid" : check_valid, "quality" : quality, "return_faces" : return_faces, "firstface_index" : firstface_index, "flip_faces" : flip_faces, "same_length" : same_length, **kwargs})
+class any_defined(_Bosl2Base):
+    def __init__(self, v=None, recursive=None, **kwargs):
+       super().__init__("any_defined", {"v" : v, "recursive" : recursive, **kwargs})
 
-class _filter_region_parts(_Bosl2Base):
-    def __init__(self, region1=None, region2=None, keep=None, eps=None, **kwargs):
-       super().__init__("_filter_region_parts", {"region1" : region1, "region2" : region2, "keep" : keep, "eps" : eps, **kwargs})
+class all_defined(_Bosl2Base):
+    def __init__(self, v=None, recursive=None, **kwargs):
+       super().__init__("all_defined", {"v" : v, "recursive" : recursive, **kwargs})
 
-class _list_three(_Bosl2Base):
-    def __init__(self, a=None, b=None, c=None, **kwargs):
-       super().__init__("_list_three", {"a" : a, "b" : b, "c" : c, **kwargs})
+class u_add(_Bosl2Base):
+    def __init__(self, a=None, b=None, **kwargs):
+       super().__init__("u_add", {"a" : a, "b" : b, **kwargs})
 
-class union(_Bosl2Base):
-    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
-       super().__init__("union", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+class u_sub(_Bosl2Base):
+    def __init__(self, a=None, b=None, **kwargs):
+       super().__init__("u_sub", {"a" : a, "b" : b, **kwargs})
 
-class difference(_Bosl2Base):
-    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
-       super().__init__("difference", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+class u_mul(_Bosl2Base):
+    def __init__(self, a=None, b=None, **kwargs):
+       super().__init__("u_mul", {"a" : a, "b" : b, **kwargs})
 
-class intersection(_Bosl2Base):
-    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
-       super().__init__("intersection", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+class u_div(_Bosl2Base):
+    def __init__(self, a=None, b=None, **kwargs):
+       super().__init__("u_div", {"a" : a, "b" : b, **kwargs})
 
-class exclusive_or(_Bosl2Base):
-    def __init__(self, regions=None, b=None, c=None, eps=None, **kwargs):
-       super().__init__("exclusive_or", {"regions" : regions, "b" : b, "c" : c, "eps" : eps, **kwargs})
+class get_anchor(_Bosl2Base):
+    def __init__(self, anchor=None, center=None, uncentered=None, dflt=None, **kwargs):
+       super().__init__("get_anchor", {"anchor" : anchor, "center" : center, "uncentered" : uncentered, "dflt" : dflt, **kwargs})
 
-class region(_Bosl2Base):
-    def __init__(self, r=None, anchor=None, spin=None, cp=None, atype=None, **kwargs):
-       super().__init__("region", {"r" : r, "anchor" : anchor, "spin" : spin, "cp" : cp, "atype" : atype, **kwargs})
+class get_radius(_Bosl2Base):
+    def __init__(self, r1=None, r2=None, r=None, d1=None, d2=None, d=None, dflt=None, **kwargs):
+       super().__init__("get_radius", {"r1" : r1, "r2" : r2, "r" : r, "d1" : d1, "d2" : d2, "d" : d, "dflt" : dflt, **kwargs})
 
-class exclusive_or(_Bosl2Base):
+class scalar_vec3(_Bosl2Base):
+    def __init__(self, v=None, dflt=None, **kwargs):
+       super().__init__("scalar_vec3", {"v" : v, "dflt" : dflt, **kwargs})
+
+class segs(_Bosl2Base):
+    def __init__(self, r=None, **kwargs):
+       super().__init__("segs", {"r" : r, **kwargs})
+
+class no_function(_Bosl2Base):
+    def __init__(self, name=None, **kwargs):
+       super().__init__("no_function", {"name" : name, **kwargs})
+
+class _valstr(_Bosl2Base):
+    def __init__(self, x=None, **kwargs):
+       super().__init__("_valstr", {"x" : x, **kwargs})
+
+class looping(_Bosl2Base):
+    def __init__(self, state=None, **kwargs):
+       super().__init__("looping", {"state" : state, **kwargs})
+
+class loop_while(_Bosl2Base):
+    def __init__(self, state=None, _continue=None, **kwargs):
+       super().__init__("loop_while", {"state" : state, "_continue" : _continue, **kwargs})
+
+class loop_done(_Bosl2Base):
+    def __init__(self, state=None, **kwargs):
+       super().__init__("loop_done", {"state" : state, **kwargs})
+
+class no_children(_Bosl2Base):
+    def __init__(self, count=None, **kwargs):
+       super().__init__("no_children", {"count" : count, **kwargs})
+
+class req_children(_Bosl2Base):
+    def __init__(self, count=None, **kwargs):
+       super().__init__("req_children", {"count" : count, **kwargs})
+
+class no_module(_Bosl2Base):
     def __init__(self, **kwargs):
-       super().__init__("exclusive_or", {**kwargs})
+       super().__init__("no_module", {**kwargs})
+
+class deprecate(_Bosl2Base):
+    def __init__(self, new_name=None, **kwargs):
+       super().__init__("deprecate", {"new_name" : new_name, **kwargs})
+
+class assert_approx(_Bosl2Base):
+    def __init__(self, got=None, expected=None, info=None, **kwargs):
+       super().__init__("assert_approx", {"got" : got, "expected" : expected, "info" : info, **kwargs})
+
+class assert_equal(_Bosl2Base):
+    def __init__(self, got=None, expected=None, info=None, **kwargs):
+       super().__init__("assert_equal", {"got" : got, "expected" : expected, "info" : info, **kwargs})
+
+class shape_compare(_Bosl2Base):
+    def __init__(self, eps=None, **kwargs):
+       super().__init__("shape_compare", {"eps" : eps, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/rounding.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/rounding.py`

 * *Files 1% similar despite different names*

```diff
@@ -43,16 +43,16 @@
        super().__init__("path_join", {"paths" : paths, "joint" : joint, "k" : k, "relocate" : relocate, "closed" : closed, **kwargs})
 
 class _path_join(_Bosl2Base):
     def __init__(self, paths=None, joint=None, k=None, i=None, result=None, relocate=None, closed=None, **kwargs):
        super().__init__("_path_join", {"paths" : paths, "joint" : joint, "k" : k, "i" : i, "result" : result, "relocate" : relocate, "closed" : closed, **kwargs})
 
 class offset_stroke(_Bosl2Base):
-    def __init__(self, path=None, width=None, rounded=None, start=None, end=None, check_valid=None, quality=None, chamfer=None, closed=None, **kwargs):
-       super().__init__("offset_stroke", {"path" : path, "width" : width, "rounded" : rounded, "start" : start, "end" : end, "check_valid" : check_valid, "quality" : quality, "chamfer" : chamfer, "closed" : closed, **kwargs})
+    def __init__(self, path=None, width=None, rounded=None, start=None, end=None, check_valid=None, quality=None, chamfer=None, closed=None, atype=None, anchor=None, spin=None, cp=None, **kwargs):
+       super().__init__("offset_stroke", {"path" : path, "width" : width, "rounded" : rounded, "start" : start, "end" : end, "check_valid" : check_valid, "quality" : quality, "chamfer" : chamfer, "closed" : closed, "atype" : atype, "anchor" : anchor, "spin" : spin, "cp" : cp, **kwargs})
 
 class os_pointed(_Bosl2Base):
     def __init__(self, dist=None, loc=None, **kwargs):
        super().__init__("os_pointed", {"dist" : dist, "loc" : loc, **kwargs})
 
 class os_round(_Bosl2Base):
     def __init__(self, cut=None, angle=None, abs_angle=None, k=None, r=None, **kwargs):
@@ -203,16 +203,16 @@
        super().__init__("smooth_path", {"path" : path, "tangents" : tangents, "size" : size, "relsize" : relsize, "splinesteps" : splinesteps, "uniform" : uniform, "closed" : closed, **kwargs})
 
 class path_join(_Bosl2Base):
     def __init__(self, paths=None, joint=None, k=None, relocate=None, closed=None, **kwargs):
        super().__init__("path_join", {"paths" : paths, "joint" : joint, "k" : k, "relocate" : relocate, "closed" : closed, **kwargs})
 
 class offset_stroke(_Bosl2Base):
-    def __init__(self, path=None, width=None, rounded=None, start=None, end=None, check_valid=None, quality=None, chamfer=None, closed=None, **kwargs):
-       super().__init__("offset_stroke", {"path" : path, "width" : width, "rounded" : rounded, "start" : start, "end" : end, "check_valid" : check_valid, "quality" : quality, "chamfer" : chamfer, "closed" : closed, **kwargs})
+    def __init__(self, path=None, width=None, rounded=None, start=None, end=None, check_valid=None, quality=None, chamfer=None, closed=None, atype=None, anchor=None, spin=None, cp=None, **kwargs):
+       super().__init__("offset_stroke", {"path" : path, "width" : width, "rounded" : rounded, "start" : start, "end" : end, "check_valid" : check_valid, "quality" : quality, "chamfer" : chamfer, "closed" : closed, "atype" : atype, "anchor" : anchor, "spin" : spin, "cp" : cp, **kwargs})
 
 class offset_sweep(_Bosl2Base):
     def __init__(self, path=None, height=None, bottom=None, top=None, h=None, l=None, offset=None, r=None, steps=None, quality=None, check_valid=None, extra=None, cut=None, chamfer_width=None, chamfer_height=None, joint=None, k=None, angle=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("offset_sweep", {"path" : path, "height" : height, "bottom" : bottom, "top" : top, "h" : h, "l" : l, "offset" : offset, "r" : r, "steps" : steps, "quality" : quality, "check_valid" : check_valid, "extra" : extra, "cut" : cut, "chamfer_width" : chamfer_width, "chamfer_height" : chamfer_height, "joint" : joint, "k" : k, "angle" : angle, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class convex_offset_extrude(_Bosl2Base):
     def __init__(self, height=None, bottom=None, top=None, h=None, l=None, length=None, offset=None, r=None, steps=None, extra=None, cut=None, chamfer_width=None, chamfer_height=None, joint=None, k=None, angle=None, convexity=None, thickness=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/screw_drive.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/screw_drive.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,38 +22,38 @@
     def __init__(self, size=None, d=None, **kwargs):
        super().__init__("phillips_depth", {"size" : size, "d" : d, **kwargs})
 
 class phillips_diam(_Bosl2Base):
     def __init__(self, size=None, depth=None, **kwargs):
        super().__init__("phillips_diam", {"size" : size, "depth" : depth, **kwargs})
 
-class torx_diam(_Bosl2Base):
+class hex_drive_mask(_Bosl2Base):
+    def __init__(self, size=None, length=None, l=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("hex_drive_mask", {"size" : size, "length" : length, "l" : l, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class torx_info(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
-       super().__init__("torx_diam", {"size" : size, **kwargs})
+       super().__init__("torx_info", {"size" : size, **kwargs})
 
-class _torx_inner_diam(_Bosl2Base):
+class torx_diam(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
-       super().__init__("_torx_inner_diam", {"size" : size, **kwargs})
+       super().__init__("torx_diam", {"size" : size, **kwargs})
 
 class torx_depth(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
        super().__init__("torx_depth", {"size" : size, **kwargs})
 
-class _torx_tip_radius(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("_torx_tip_radius", {"size" : size, **kwargs})
-
-class _torx_rounding_radius(_Bosl2Base):
-    def __init__(self, size=None, **kwargs):
-       super().__init__("_torx_rounding_radius", {"size" : size, **kwargs})
-
 class phillips_mask(_Bosl2Base):
     def __init__(self, size=None, _fn=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("phillips_mask", {"size" : size, "_fn" : _fn, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
+class hex_drive_mask(_Bosl2Base):
+    def __init__(self, size=None, length=None, l=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("hex_drive_mask", {"size" : size, "length" : length, "l" : l, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
 class torx_mask(_Bosl2Base):
     def __init__(self, size=None, l=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("torx_mask", {"size" : size, "l" : l, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class torx_mask2d(_Bosl2Base):
     def __init__(self, size=None, **kwargs):
        super().__init__("torx_mask2d", {"size" : size, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/shapes2d.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/shapes2d.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,16 +7,16 @@
 _extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/shapes2d.scad'}", use_not_include=False)
 
 class square(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, **kwargs):
        super().__init__("square", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class rect(_Bosl2Base):
-    def __init__(self, size=None, rounding=None, chamfer=None, atype=None, anchor=None, spin=None, **kwargs):
-       super().__init__("rect", {"size" : size, "rounding" : rounding, "chamfer" : chamfer, "atype" : atype, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, size=None, rounding=None, chamfer=None, atype=None, anchor=None, spin=None, _return_override=None, **kwargs):
+       super().__init__("rect", {"size" : size, "rounding" : rounding, "chamfer" : chamfer, "atype" : atype, "anchor" : anchor, "spin" : spin, "_return_override" : _return_override, **kwargs})
 
 class circle(_Bosl2Base):
     def __init__(self, r=None, d=None, points=None, corner=None, anchor=None, spin=None, **kwargs):
        super().__init__("circle", {"r" : r, "d" : d, "points" : points, "corner" : corner, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class _ellipse_refine(_Bosl2Base):
     def __init__(self, a=None, b=None, N=None, _theta=None, **kwargs):
@@ -46,45 +46,49 @@
     def __init__(self, r=None, d=None, _or=None, od=None, ir=None, id=None, side=None, rounding=None, realign=None, align_tip=None, align_side=None, anchor=None, spin=None, **kwargs):
        super().__init__("octagon", {"r" : r, "d" : d, "_or" : _or, "od" : od, "ir" : ir, "id" : id, "side" : side, "rounding" : rounding, "realign" : realign, "align_tip" : align_tip, "align_side" : align_side, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class right_triangle(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, **kwargs):
        super().__init__("right_triangle", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, **kwargs})
 
+class _trapezoid_dims(_Bosl2Base):
+    def __init__(self, h=None, w1=None, w2=None, shift=None, ang=None, **kwargs):
+       super().__init__("_trapezoid_dims", {"h" : h, "w1" : w1, "w2" : w2, "shift" : shift, "ang" : ang, **kwargs})
+
 class trapezoid(_Bosl2Base):
-    def __init__(self, h=None, w1=None, w2=None, angle=None, shift=None, chamfer=None, rounding=None, flip=None, anchor=None, spin=None, **kwargs):
-       super().__init__("trapezoid", {"h" : h, "w1" : w1, "w2" : w2, "angle" : angle, "shift" : shift, "chamfer" : chamfer, "rounding" : rounding, "flip" : flip, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, h=None, w1=None, w2=None, ang=None, shift=None, chamfer=None, rounding=None, flip=None, anchor=None, spin=None, atype=None, _return_override=None, angle=None, **kwargs):
+       super().__init__("trapezoid", {"h" : h, "w1" : w1, "w2" : w2, "ang" : ang, "shift" : shift, "chamfer" : chamfer, "rounding" : rounding, "flip" : flip, "anchor" : anchor, "spin" : spin, "atype" : atype, "_return_override" : _return_override, "angle" : angle, **kwargs})
 
 class star(_Bosl2Base):
     def __init__(self, n=None, r=None, ir=None, d=None, _or=None, od=None, id=None, step=None, realign=None, align_tip=None, align_pit=None, anchor=None, spin=None, atype=None, _mat=None, _anchs=None, **kwargs):
        super().__init__("star", {"n" : n, "r" : r, "ir" : ir, "d" : d, "_or" : _or, "od" : od, "id" : id, "step" : step, "realign" : realign, "align_tip" : align_tip, "align_pit" : align_pit, "anchor" : anchor, "spin" : spin, "atype" : atype, "_mat" : _mat, "_anchs" : _anchs, **kwargs})
 
 class _path_add_jitter(_Bosl2Base):
     def __init__(self, path=None, dist=None, closed=None, **kwargs):
        super().__init__("_path_add_jitter", {"path" : path, "dist" : dist, "closed" : closed, **kwargs})
 
 class teardrop2d(_Bosl2Base):
-    def __init__(self, r=None, ang=None, cap_h=None, d=None, anchor=None, spin=None, **kwargs):
-       super().__init__("teardrop2d", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, r=None, ang=None, cap_h=None, d=None, circum=None, realign=None, anchor=None, spin=None, _extrapt=None, **kwargs):
+       super().__init__("teardrop2d", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "circum" : circum, "realign" : realign, "anchor" : anchor, "spin" : spin, "_extrapt" : _extrapt, **kwargs})
 
 class egg(_Bosl2Base):
     def __init__(self, length=None, r1=None, r2=None, R=None, d1=None, d2=None, D=None, anchor=None, spin=None, **kwargs):
        super().__init__("egg", {"length" : length, "r1" : r1, "r2" : r2, "R" : R, "d1" : d1, "d2" : d2, "D" : D, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class glued_circles(_Bosl2Base):
     def __init__(self, r=None, spread=None, tangent=None, d=None, anchor=None, spin=None, **kwargs):
        super().__init__("glued_circles", {"r" : r, "spread" : spread, "tangent" : tangent, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class _superformula(_Bosl2Base):
     def __init__(self, theta=None, m1=None, m2=None, n1=None, n2=None, n3=None, a=None, b=None, **kwargs):
        super().__init__("_superformula", {"theta" : theta, "m1" : m1, "m2" : m2, "n1" : n1, "n2" : n2, "n3" : n3, "a" : a, "b" : b, **kwargs})
 
 class supershape(_Bosl2Base):
-    def __init__(self, step=None, m1=None, m2=None, n1=None, n2=None, n3=None, a=None, b=None, r=None, d=None, anchor=None, spin=None, atype=None, **kwargs):
-       super().__init__("supershape", {"step" : step, "m1" : m1, "m2" : m2, "n1" : n1, "n2" : n2, "n3" : n3, "a" : a, "b" : b, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "atype" : atype, **kwargs})
+    def __init__(self, step=None, n=None, m1=None, m2=None, n1=None, n2=None, n3=None, a=None, b=None, r=None, d=None, anchor=None, spin=None, atype=None, **kwargs):
+       super().__init__("supershape", {"step" : step, "n" : n, "m1" : m1, "m2" : m2, "n1" : n1, "n2" : n2, "n3" : n3, "a" : a, "b" : b, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "atype" : atype, **kwargs})
 
 class reuleaux_polygon(_Bosl2Base):
     def __init__(self, n=None, r=None, d=None, anchor=None, spin=None, **kwargs):
        super().__init__("reuleaux_polygon", {"n" : n, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class square(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, **kwargs):
@@ -119,40 +123,40 @@
        super().__init__("octagon", {"r" : r, "d" : d, "_or" : _or, "od" : od, "ir" : ir, "id" : id, "side" : side, "rounding" : rounding, "realign" : realign, "align_tip" : align_tip, "align_side" : align_side, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class right_triangle(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, **kwargs):
        super().__init__("right_triangle", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class trapezoid(_Bosl2Base):
-    def __init__(self, h=None, w1=None, w2=None, angle=None, shift=None, chamfer=None, rounding=None, flip=None, anchor=None, spin=None, **kwargs):
-       super().__init__("trapezoid", {"h" : h, "w1" : w1, "w2" : w2, "angle" : angle, "shift" : shift, "chamfer" : chamfer, "rounding" : rounding, "flip" : flip, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, h=None, w1=None, w2=None, ang=None, shift=None, chamfer=None, rounding=None, flip=None, anchor=None, spin=None, atype=None, angle=None, **kwargs):
+       super().__init__("trapezoid", {"h" : h, "w1" : w1, "w2" : w2, "ang" : ang, "shift" : shift, "chamfer" : chamfer, "rounding" : rounding, "flip" : flip, "anchor" : anchor, "spin" : spin, "atype" : atype, "angle" : angle, **kwargs})
 
 class star(_Bosl2Base):
     def __init__(self, n=None, r=None, ir=None, d=None, _or=None, od=None, id=None, step=None, realign=None, align_tip=None, align_pit=None, anchor=None, spin=None, atype=None, **kwargs):
        super().__init__("star", {"n" : n, "r" : r, "ir" : ir, "d" : d, "_or" : _or, "od" : od, "id" : id, "step" : step, "realign" : realign, "align_tip" : align_tip, "align_pit" : align_pit, "anchor" : anchor, "spin" : spin, "atype" : atype, **kwargs})
 
 class jittered_poly(_Bosl2Base):
     def __init__(self, path=None, dist=None, **kwargs):
        super().__init__("jittered_poly", {"path" : path, "dist" : dist, **kwargs})
 
 class teardrop2d(_Bosl2Base):
-    def __init__(self, r=None, ang=None, cap_h=None, d=None, anchor=None, spin=None, **kwargs):
-       super().__init__("teardrop2d", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
+    def __init__(self, r=None, ang=None, cap_h=None, d=None, circum=None, realign=None, anchor=None, spin=None, **kwargs):
+       super().__init__("teardrop2d", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "circum" : circum, "realign" : realign, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class egg(_Bosl2Base):
     def __init__(self, length=None, r1=None, r2=None, R=None, d1=None, d2=None, D=None, anchor=None, spin=None, **kwargs):
        super().__init__("egg", {"length" : length, "r1" : r1, "r2" : r2, "R" : R, "d1" : d1, "d2" : d2, "D" : D, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class glued_circles(_Bosl2Base):
     def __init__(self, r=None, spread=None, tangent=None, d=None, anchor=None, spin=None, **kwargs):
        super().__init__("glued_circles", {"r" : r, "spread" : spread, "tangent" : tangent, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class supershape(_Bosl2Base):
-    def __init__(self, step=None, m1=None, m2=None, n1=None, n2=None, n3=None, a=None, b=None, r=None, d=None, anchor=None, spin=None, atype=None, **kwargs):
-       super().__init__("supershape", {"step" : step, "m1" : m1, "m2" : m2, "n1" : n1, "n2" : n2, "n3" : n3, "a" : a, "b" : b, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "atype" : atype, **kwargs})
+    def __init__(self, step=None, n=None, m1=None, m2=None, n1=None, n2=None, n3=None, a=None, b=None, r=None, d=None, anchor=None, spin=None, atype=None, **kwargs):
+       super().__init__("supershape", {"step" : step, "n" : n, "m1" : m1, "m2" : m2, "n1" : n1, "n2" : n2, "n3" : n3, "a" : a, "b" : b, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "atype" : atype, **kwargs})
 
 class reuleaux_polygon(_Bosl2Base):
     def __init__(self, n=None, r=None, d=None, anchor=None, spin=None, **kwargs):
        super().__init__("reuleaux_polygon", {"n" : n, "r" : r, "d" : d, "anchor" : anchor, "spin" : spin, **kwargs})
 
 class text(_Bosl2Base):
     def __init__(self, text=None, size=None, font=None, halign=None, valign=None, spacing=None, direction=None, language=None, script=None, anchor=None, spin=None, **kwargs):
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/shapes3d.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/shapes3d.py`

 * *Files 17% similar despite different names*

```diff
@@ -11,40 +11,64 @@
        super().__init__("cube", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cuboid(_Bosl2Base):
     def __init__(self, size=None, p1=None, p2=None, chamfer=None, rounding=None, edges=None, except_edges=None, trimcorners=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cuboid", {"size" : size, "p1" : p1, "p2" : p2, "chamfer" : chamfer, "rounding" : rounding, "edges" : edges, "except_edges" : except_edges, "trimcorners" : trimcorners, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class prismoid(_Bosl2Base):
-    def __init__(self, size1=None, size2=None, h=None, shift=None, rounding=None, rounding1=None, rounding2=None, chamfer=None, chamfer1=None, chamfer2=None, l=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("prismoid", {"size1" : size1, "size2" : size2, "h" : h, "shift" : shift, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "l" : l, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, size1=None, size2=None, h=None, shift=None, rounding=None, rounding1=None, rounding2=None, chamfer=None, chamfer1=None, chamfer2=None, l=None, height=None, length=None, center=None, anchor=None, spin=None, orient=None, xang=None, yang=None, _return_dim=None, **kwargs):
+       super().__init__("prismoid", {"size1" : size1, "size2" : size2, "h" : h, "shift" : shift, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "l" : l, "height" : height, "length" : length, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, "xang" : xang, "yang" : yang, "_return_dim" : _return_dim, **kwargs})
 
 class octahedron(_Bosl2Base):
     def __init__(self, size=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("octahedron", {"size" : size, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
+class _rect_tube_rounding(_Bosl2Base):
+    def __init__(self, factor=None, ir=None, r=None, alternative=None, size=None, isize=None, **kwargs):
+       super().__init__("_rect_tube_rounding", {"factor" : factor, "ir" : ir, "r" : r, "alternative" : alternative, "size" : size, "isize" : isize, **kwargs})
+
 class rect_tube(_Bosl2Base):
-    def __init__(self, h=None, size=None, isize=None, center=None, shift=None, wall=None, size1=None, size2=None, isize1=None, isize2=None, rounding=None, rounding1=None, rounding2=None, irounding=None, irounding1=None, irounding2=None, chamfer=None, chamfer1=None, chamfer2=None, ichamfer=None, ichamfer1=None, ichamfer2=None, anchor=None, spin=None, orient=None, l=None, **kwargs):
-       super().__init__("rect_tube", {"h" : h, "size" : size, "isize" : isize, "center" : center, "shift" : shift, "wall" : wall, "size1" : size1, "size2" : size2, "isize1" : isize1, "isize2" : isize2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "irounding" : irounding, "irounding1" : irounding1, "irounding2" : irounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "ichamfer" : ichamfer, "ichamfer1" : ichamfer1, "ichamfer2" : ichamfer2, "anchor" : anchor, "spin" : spin, "orient" : orient, "l" : l, **kwargs})
+    def __init__(self, h=None, size=None, isize=None, center=None, shift=None, wall=None, size1=None, size2=None, isize1=None, isize2=None, rounding=None, rounding1=None, rounding2=None, irounding=None, irounding1=None, irounding2=None, chamfer=None, chamfer1=None, chamfer2=None, ichamfer=None, ichamfer1=None, ichamfer2=None, anchor=None, spin=None, orient=None, l=None, length=None, height=None, **kwargs):
+       super().__init__("rect_tube", {"h" : h, "size" : size, "isize" : isize, "center" : center, "shift" : shift, "wall" : wall, "size1" : size1, "size2" : size2, "isize1" : isize1, "isize2" : isize2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "irounding" : irounding, "irounding1" : irounding1, "irounding2" : irounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "ichamfer" : ichamfer, "ichamfer1" : ichamfer1, "ichamfer2" : ichamfer2, "anchor" : anchor, "spin" : spin, "orient" : orient, "l" : l, "length" : length, "height" : height, **kwargs})
 
 class wedge(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("wedge", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cylinder(_Bosl2Base):
-    def __init__(self, h=None, r1=None, r2=None, center=None, l=None, r=None, d=None, d1=None, d2=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cylinder", {"h" : h, "r1" : r1, "r2" : r2, "center" : center, "l" : l, "r" : r, "d" : d, "d1" : d1, "d2" : d2, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r1=None, r2=None, center=None, r=None, d=None, d1=None, d2=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cylinder", {"h" : h, "r1" : r1, "r2" : r2, "center" : center, "r" : r, "d" : d, "d1" : d1, "d2" : d2, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class cyl(_Bosl2Base):
+    def __init__(self, h=None, r=None, center=None, l=None, r1=None, r2=None, d=None, d1=None, d2=None, length=None, height=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, shift=None, from_end=None, from_end1=None, from_end2=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, tex_taper=None, tex_style=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cyl", {"h" : h, "r" : r, "center" : center, "l" : l, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "length" : length, "height" : height, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "shift" : shift, "from_end" : from_end, "from_end1" : from_end1, "from_end2" : from_end2, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "tex_taper" : tex_taper, "tex_style" : tex_style, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class xcyl(_Bosl2Base):
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("xcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class ycyl(_Bosl2Base):
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, height=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("ycyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "height" : height, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class zcyl(_Bosl2Base):
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("zcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class tube(_Bosl2Base):
+    def __init__(self, h=None, _or=None, ir=None, center=None, od=None, id=None, wall=None, or1=None, or2=None, od1=None, od2=None, ir1=None, ir2=None, id1=None, id2=None, realign=None, l=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("tube", {"h" : h, "_or" : _or, "ir" : ir, "center" : center, "od" : od, "id" : id, "wall" : wall, "or1" : or1, "or2" : or2, "od1" : od1, "od2" : od2, "ir1" : ir1, "ir2" : ir2, "id1" : id1, "id2" : id2, "realign" : realign, "l" : l, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class pie_slice(_Bosl2Base):
-    def __init__(self, h=None, r=None, ang=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("pie_slice", {"h" : h, "r" : r, "ang" : ang, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, ang=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("pie_slice", {"h" : h, "r" : r, "ang" : ang, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class sphere(_Bosl2Base):
-    def __init__(self, r=None, d=None, circum=None, style=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("sphere", {"r" : r, "d" : d, "circum" : circum, "style" : style, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, r=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("sphere", {"r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _subsample_triangle(_Bosl2Base):
     def __init__(self, p=None, N=None, **kwargs):
        super().__init__("_subsample_triangle", {"p" : p, "N" : N, **kwargs})
 
 class _dual_vertices(_Bosl2Base):
     def __init__(self, vnf=None, **kwargs):
@@ -55,122 +79,126 @@
        super().__init__("spheroid", {"r" : r, "style" : style, "d" : d, "circum" : circum, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class torus(_Bosl2Base):
     def __init__(self, r_maj=None, r_min=None, center=None, d_maj=None, d_min=None, _or=None, od=None, ir=None, id=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("torus", {"r_maj" : r_maj, "r_min" : r_min, "center" : center, "d_maj" : d_maj, "d_min" : d_min, "_or" : _or, "od" : od, "ir" : ir, "id" : id, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class teardrop(_Bosl2Base):
-    def __init__(self, h=None, r=None, ang=None, cap_h=None, r1=None, r2=None, d=None, d1=None, d2=None, cap_h1=None, cap_h2=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("teardrop", {"h" : h, "r" : r, "ang" : ang, "cap_h" : cap_h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "cap_h1" : cap_h1, "cap_h2" : cap_h2, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, ang=None, cap_h=None, r1=None, r2=None, d=None, d1=None, d2=None, cap_h1=None, cap_h2=None, chamfer=None, chamfer1=None, chamfer2=None, circum=None, realign=None, l=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("teardrop", {"h" : h, "r" : r, "ang" : ang, "cap_h" : cap_h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "cap_h1" : cap_h1, "cap_h2" : cap_h2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "circum" : circum, "realign" : realign, "l" : l, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class onion(_Bosl2Base):
     def __init__(self, r=None, ang=None, cap_h=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("onion", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _cut_interp(_Bosl2Base):
     def __init__(self, pathcut=None, path=None, data=None, **kwargs):
        super().__init__("_cut_interp", {"pathcut" : pathcut, "path" : path, "data" : data, **kwargs})
 
 class heightfield(_Bosl2Base):
     def __init__(self, data=None, size=None, bottom=None, maxz=None, xrange=None, yrange=None, style=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("heightfield", {"data" : data, "size" : size, "bottom" : bottom, "maxz" : maxz, "xrange" : xrange, "yrange" : yrange, "style" : style, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cylindrical_heightfield(_Bosl2Base):
-    def __init__(self, data=None, l=None, r=None, base=None, transpose=None, aspect=None, style=None, maxh=None, xrange=None, yrange=None, r1=None, r2=None, d=None, d1=None, d2=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cylindrical_heightfield", {"data" : data, "l" : l, "r" : r, "base" : base, "transpose" : transpose, "aspect" : aspect, "style" : style, "maxh" : maxh, "xrange" : xrange, "yrange" : yrange, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, data=None, l=None, r=None, base=None, transpose=None, aspect=None, style=None, maxh=None, xrange=None, yrange=None, r1=None, r2=None, d=None, d1=None, d2=None, h=None, height=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cylindrical_heightfield", {"data" : data, "l" : l, "r" : r, "base" : base, "transpose" : transpose, "aspect" : aspect, "style" : style, "maxh" : maxh, "xrange" : xrange, "yrange" : yrange, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "h" : h, "height" : height, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cube(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cube", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cuboid(_Bosl2Base):
     def __init__(self, size=None, p1=None, p2=None, chamfer=None, rounding=None, edges=None, _except=None, except_edges=None, trimcorners=None, teardrop=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("cuboid", {"size" : size, "p1" : p1, "p2" : p2, "chamfer" : chamfer, "rounding" : rounding, "edges" : edges, "_except" : _except, "except_edges" : except_edges, "trimcorners" : trimcorners, "teardrop" : teardrop, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class prismoid(_Bosl2Base):
-    def __init__(self, size1=None, size2=None, h=None, shift=None, rounding=None, rounding1=None, rounding2=None, chamfer=None, chamfer1=None, chamfer2=None, l=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("prismoid", {"size1" : size1, "size2" : size2, "h" : h, "shift" : shift, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "l" : l, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, size1=None, size2=None, h=None, shift=None, xang=None, yang=None, rounding=None, rounding1=None, rounding2=None, chamfer=None, chamfer1=None, chamfer2=None, l=None, height=None, length=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("prismoid", {"size1" : size1, "size2" : size2, "h" : h, "shift" : shift, "xang" : xang, "yang" : yang, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "l" : l, "height" : height, "length" : length, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class octahedron(_Bosl2Base):
     def __init__(self, size=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("octahedron", {"size" : size, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class rect_tube(_Bosl2Base):
-    def __init__(self, h=None, size=None, isize=None, center=None, shift=None, wall=None, size1=None, size2=None, isize1=None, isize2=None, rounding=None, rounding1=None, rounding2=None, irounding=None, irounding1=None, irounding2=None, chamfer=None, chamfer1=None, chamfer2=None, ichamfer=None, ichamfer1=None, ichamfer2=None, anchor=None, spin=None, orient=None, l=None, **kwargs):
-       super().__init__("rect_tube", {"h" : h, "size" : size, "isize" : isize, "center" : center, "shift" : shift, "wall" : wall, "size1" : size1, "size2" : size2, "isize1" : isize1, "isize2" : isize2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "irounding" : irounding, "irounding1" : irounding1, "irounding2" : irounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "ichamfer" : ichamfer, "ichamfer1" : ichamfer1, "ichamfer2" : ichamfer2, "anchor" : anchor, "spin" : spin, "orient" : orient, "l" : l, **kwargs})
+    def __init__(self, h=None, size=None, isize=None, center=None, shift=None, wall=None, size1=None, size2=None, isize1=None, isize2=None, rounding=None, rounding1=None, rounding2=None, irounding=None, irounding1=None, irounding2=None, chamfer=None, chamfer1=None, chamfer2=None, ichamfer=None, ichamfer1=None, ichamfer2=None, anchor=None, spin=None, orient=None, l=None, length=None, height=None, **kwargs):
+       super().__init__("rect_tube", {"h" : h, "size" : size, "isize" : isize, "center" : center, "shift" : shift, "wall" : wall, "size1" : size1, "size2" : size2, "isize1" : isize1, "isize2" : isize2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "irounding" : irounding, "irounding1" : irounding1, "irounding2" : irounding2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "ichamfer" : ichamfer, "ichamfer1" : ichamfer1, "ichamfer2" : ichamfer2, "anchor" : anchor, "spin" : spin, "orient" : orient, "l" : l, "length" : length, "height" : height, **kwargs})
 
 class wedge(_Bosl2Base):
     def __init__(self, size=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("wedge", {"size" : size, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cylinder(_Bosl2Base):
-    def __init__(self, h=None, r1=None, r2=None, center=None, l=None, r=None, d=None, d1=None, d2=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cylinder", {"h" : h, "r1" : r1, "r2" : r2, "center" : center, "l" : l, "r" : r, "d" : d, "d1" : d1, "d2" : d2, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r1=None, r2=None, center=None, r=None, d=None, d1=None, d2=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cylinder", {"h" : h, "r1" : r1, "r2" : r2, "center" : center, "r" : r, "d" : d, "d1" : d1, "d2" : d2, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cyl(_Bosl2Base):
-    def __init__(self, h=None, r=None, center=None, l=None, r1=None, r2=None, d=None, d1=None, d2=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cyl", {"h" : h, "r" : r, "center" : center, "l" : l, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, center=None, l=None, r1=None, r2=None, d=None, d1=None, d2=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, shift=None, from_end=None, from_end1=None, from_end2=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, length=None, height=None, tex_taper=None, tex_style=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cyl", {"h" : h, "r" : r, "center" : center, "l" : l, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "shift" : shift, "from_end" : from_end, "from_end1" : from_end1, "from_end2" : from_end2, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "length" : length, "height" : height, "tex_taper" : tex_taper, "tex_style" : tex_style, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class xcyl(_Bosl2Base):
-    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("xcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("xcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class ycyl(_Bosl2Base):
-    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("ycyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, height=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("ycyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "height" : height, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class zcyl(_Bosl2Base):
-    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("zcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, d=None, r1=None, r2=None, d1=None, d2=None, l=None, chamfer=None, chamfer1=None, chamfer2=None, chamfang=None, chamfang1=None, chamfang2=None, rounding=None, rounding1=None, rounding2=None, circum=None, realign=None, from_end=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("zcyl", {"h" : h, "r" : r, "d" : d, "r1" : r1, "r2" : r2, "d1" : d1, "d2" : d2, "l" : l, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "chamfang" : chamfang, "chamfang1" : chamfang1, "chamfang2" : chamfang2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "circum" : circum, "realign" : realign, "from_end" : from_end, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class tube(_Bosl2Base):
-    def __init__(self, h=None, _or=None, ir=None, center=None, od=None, id=None, wall=None, or1=None, or2=None, od1=None, od2=None, ir1=None, ir2=None, id1=None, id2=None, realign=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("tube", {"h" : h, "_or" : _or, "ir" : ir, "center" : center, "od" : od, "id" : id, "wall" : wall, "or1" : or1, "or2" : or2, "od1" : od1, "od2" : od2, "ir1" : ir1, "ir2" : ir2, "id1" : id1, "id2" : id2, "realign" : realign, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, _or=None, ir=None, center=None, od=None, id=None, wall=None, or1=None, or2=None, od1=None, od2=None, ir1=None, ir2=None, id1=None, id2=None, realign=None, l=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("tube", {"h" : h, "_or" : _or, "ir" : ir, "center" : center, "od" : od, "id" : id, "wall" : wall, "or1" : or1, "or2" : or2, "od1" : od1, "od2" : od2, "ir1" : ir1, "ir2" : ir2, "id1" : id1, "id2" : id2, "realign" : realign, "l" : l, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class pie_slice(_Bosl2Base):
-    def __init__(self, h=None, r=None, ang=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("pie_slice", {"h" : h, "r" : r, "ang" : ang, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, ang=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, l=None, length=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("pie_slice", {"h" : h, "r" : r, "ang" : ang, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "l" : l, "length" : length, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class sphere(_Bosl2Base):
-    def __init__(self, r=None, d=None, circum=None, style=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("sphere", {"r" : r, "d" : d, "circum" : circum, "style" : style, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, r=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("sphere", {"r" : r, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class spheroid(_Bosl2Base):
     def __init__(self, r=None, style=None, d=None, circum=None, dual=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("spheroid", {"r" : r, "style" : style, "d" : d, "circum" : circum, "dual" : dual, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class torus(_Bosl2Base):
     def __init__(self, r_maj=None, r_min=None, center=None, d_maj=None, d_min=None, _or=None, od=None, ir=None, id=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("torus", {"r_maj" : r_maj, "r_min" : r_min, "center" : center, "d_maj" : d_maj, "d_min" : d_min, "_or" : _or, "od" : od, "ir" : ir, "id" : id, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class teardrop(_Bosl2Base):
-    def __init__(self, h=None, r=None, ang=None, cap_h=None, r1=None, r2=None, d=None, d1=None, d2=None, cap_h1=None, cap_h2=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("teardrop", {"h" : h, "r" : r, "ang" : ang, "cap_h" : cap_h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "cap_h1" : cap_h1, "cap_h2" : cap_h2, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, h=None, r=None, ang=None, cap_h=None, r1=None, r2=None, d=None, d1=None, d2=None, cap_h1=None, cap_h2=None, l=None, length=None, height=None, circum=None, realign=None, chamfer=None, chamfer1=None, chamfer2=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("teardrop", {"h" : h, "r" : r, "ang" : ang, "cap_h" : cap_h, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "cap_h1" : cap_h1, "cap_h2" : cap_h2, "l" : l, "length" : length, "height" : height, "circum" : circum, "realign" : realign, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class onion(_Bosl2Base):
-    def __init__(self, r=None, ang=None, cap_h=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("onion", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, r=None, ang=None, cap_h=None, d=None, circum=None, realign=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("onion", {"r" : r, "ang" : ang, "cap_h" : cap_h, "d" : d, "circum" : circum, "realign" : realign, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class text3d(_Bosl2Base):
-    def __init__(self, text=None, h=None, size=None, font=None, halign=None, valign=None, spacing=None, direction=None, language=None, script=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("text3d", {"text" : text, "h" : h, "size" : size, "font" : font, "halign" : halign, "valign" : valign, "spacing" : spacing, "direction" : direction, "language" : language, "script" : script, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, text=None, h=None, size=None, font=None, spacing=None, direction=None, language=None, script=None, height=None, thickness=None, atype=None, center=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("text3d", {"text" : text, "h" : h, "size" : size, "font" : font, "spacing" : spacing, "direction" : direction, "language" : language, "script" : script, "height" : height, "thickness" : thickness, "atype" : atype, "center" : center, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class path_text(_Bosl2Base):
-    def __init__(self, path=None, text=None, font=None, size=None, thickness=None, lettersize=None, offset=None, reverse=None, normal=None, top=None, center=None, textmetrics=None, kern=None, **kwargs):
-       super().__init__("path_text", {"path" : path, "text" : text, "font" : font, "size" : size, "thickness" : thickness, "lettersize" : lettersize, "offset" : offset, "reverse" : reverse, "normal" : normal, "top" : top, "center" : center, "textmetrics" : textmetrics, "kern" : kern, **kwargs})
+    def __init__(self, path=None, text=None, font=None, size=None, thickness=None, lettersize=None, offset=None, reverse=None, normal=None, top=None, center=None, textmetrics=None, kern=None, height=None, h=None, valign=None, language=None, script=None, **kwargs):
+       super().__init__("path_text", {"path" : path, "text" : text, "font" : font, "size" : size, "thickness" : thickness, "lettersize" : lettersize, "offset" : offset, "reverse" : reverse, "normal" : normal, "top" : top, "center" : center, "textmetrics" : textmetrics, "kern" : kern, "height" : height, "h" : h, "valign" : valign, "language" : language, "script" : script, **kwargs})
 
 class interior_fillet(_Bosl2Base):
-    def __init__(self, l=None, r=None, ang=None, overlap=None, d=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("interior_fillet", {"l" : l, "r" : r, "ang" : ang, "overlap" : overlap, "d" : d, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, l=None, r=None, ang=None, overlap=None, d=None, length=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("interior_fillet", {"l" : l, "r" : r, "ang" : ang, "overlap" : overlap, "d" : d, "length" : length, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class fillet(_Bosl2Base):
+    def __init__(self, l=None, r=None, ang=None, overlap=None, d=None, length=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("fillet", {"l" : l, "r" : r, "ang" : ang, "overlap" : overlap, "d" : d, "length" : length, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class heightfield(_Bosl2Base):
     def __init__(self, data=None, size=None, bottom=None, maxz=None, xrange=None, yrange=None, style=None, convexity=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("heightfield", {"data" : data, "size" : size, "bottom" : bottom, "maxz" : maxz, "xrange" : xrange, "yrange" : yrange, "style" : style, "convexity" : convexity, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class cylindrical_heightfield(_Bosl2Base):
-    def __init__(self, data=None, l=None, r=None, base=None, transpose=None, aspect=None, style=None, convexity=None, xrange=None, yrange=None, maxh=None, r1=None, r2=None, d=None, d1=None, d2=None, h=None, height=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("cylindrical_heightfield", {"data" : data, "l" : l, "r" : r, "base" : base, "transpose" : transpose, "aspect" : aspect, "style" : style, "convexity" : convexity, "xrange" : xrange, "yrange" : yrange, "maxh" : maxh, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "h" : h, "height" : height, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, data=None, l=None, r=None, base=None, transpose=None, aspect=None, style=None, convexity=None, xrange=None, yrange=None, maxh=None, r1=None, r2=None, d=None, d1=None, d2=None, h=None, height=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("cylindrical_heightfield", {"data" : data, "l" : l, "r" : r, "base" : base, "transpose" : transpose, "aspect" : aspect, "style" : style, "convexity" : convexity, "xrange" : xrange, "yrange" : yrange, "maxh" : maxh, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "h" : h, "height" : height, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class ruler(_Bosl2Base):
     def __init__(self, length=None, width=None, thickness=None, depth=None, labels=None, pipscale=None, maxscale=None, colors=None, alpha=None, unit=None, inch=None, anchor=None, spin=None, orient=None, **kwargs):
        super().__init__("ruler", {"length" : length, "width" : width, "thickness" : thickness, "depth" : depth, "labels" : labels, "pipscale" : pipscale, "maxscale" : maxscale, "colors" : colors, "alpha" : alpha, "unit" : unit, "inch" : inch, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/skin.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/skin.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,40 +2,45 @@
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
 
 _extra_scad_include(f"{_Path(__file__).parent.parent / '../libs/BOSL2/skin.scad'}", use_not_include=False)
 
+_leadin_ogive = _OpenSCADConstant('_leadin_ogive')
+_leadin_cut = _OpenSCADConstant('_leadin_cut')
+_leadin_sqrt = _OpenSCADConstant('_leadin_sqrt')
+_leadin_linear = _OpenSCADConstant('_leadin_linear')
+_lead_in_table = _OpenSCADConstant('_lead_in_table')
 _MAP_DIAG = _OpenSCADConstant('_MAP_DIAG')
 _MAP_LEFT = _OpenSCADConstant('_MAP_LEFT')
 _MAP_UP = _OpenSCADConstant('_MAP_UP')
 class skin(_Bosl2Base):
     def __init__(self, profiles=None, slices=None, refine=None, method=None, sampling=None, caps=None, closed=None, z=None, style=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("skin", {"profiles" : profiles, "slices" : slices, "refine" : refine, "method" : method, "sampling" : sampling, "caps" : caps, "closed" : closed, "z" : z, "style" : style, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class linear_sweep(_Bosl2Base):
-    def __init__(self, region=None, height=None, center=None, twist=None, scale=None, shift=None, slices=None, maxseg=None, style=None, cp=None, atype=None, h=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("linear_sweep", {"region" : region, "height" : height, "center" : center, "twist" : twist, "scale" : scale, "shift" : shift, "slices" : slices, "maxseg" : maxseg, "style" : style, "cp" : cp, "atype" : atype, "h" : h, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, region=None, height=None, center=None, twist=None, scale=None, shift=None, slices=None, maxseg=None, style=None, caps=None, cp=None, atype=None, h=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, l=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("linear_sweep", {"region" : region, "height" : height, "center" : center, "twist" : twist, "scale" : scale, "shift" : shift, "slices" : slices, "maxseg" : maxseg, "style" : style, "caps" : caps, "cp" : cp, "atype" : atype, "h" : h, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "l" : l, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
-class _taperfunc(_Bosl2Base):
-    def __init__(self, x=None, **kwargs):
-       super().__init__("_taperfunc", {"x" : x, **kwargs})
+class rotate_sweep(_Bosl2Base):
+    def __init__(self, shape=None, angle=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, tex_taper=None, shift=None, closed=None, style=None, cp=None, atype=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("rotate_sweep", {"shape" : shape, "angle" : angle, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "tex_taper" : tex_taper, "shift" : shift, "closed" : closed, "style" : style, "cp" : cp, "atype" : atype, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class _ss_polygon_r(_Bosl2Base):
     def __init__(self, N=None, theta=None, **kwargs):
        super().__init__("_ss_polygon_r", {"N" : N, "theta" : theta, **kwargs})
 
 class spiral_sweep(_Bosl2Base):
-    def __init__(self, poly=None, h=None, r=None, turns=None, higbee=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, higbee1=None, higbee2=None, internal=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("spiral_sweep", {"poly" : poly, "h" : h, "r" : r, "turns" : turns, "higbee" : higbee, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "higbee1" : higbee1, "higbee2" : higbee2, "internal" : internal, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, poly=None, h=None, r=None, turns=None, taper=None, r1=None, r2=None, d=None, d1=None, d2=None, internal=None, lead_in_shape=None, lead_in_shape1=None, lead_in_shape2=None, lead_in=None, lead_in1=None, lead_in2=None, lead_in_ang=None, lead_in_ang1=None, lead_in_ang2=None, height=None, l=None, length=None, lead_in_sample=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("spiral_sweep", {"poly" : poly, "h" : h, "r" : r, "turns" : turns, "taper" : taper, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "internal" : internal, "lead_in_shape" : lead_in_shape, "lead_in_shape1" : lead_in_shape1, "lead_in_shape2" : lead_in_shape2, "lead_in" : lead_in, "lead_in1" : lead_in1, "lead_in2" : lead_in2, "lead_in_ang" : lead_in_ang, "lead_in_ang1" : lead_in_ang1, "lead_in_ang2" : lead_in_ang2, "height" : height, "l" : l, "length" : length, "lead_in_sample" : lead_in_sample, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class path_sweep(_Bosl2Base):
-    def __init__(self, shape=None, path=None, method=None, normal=None, closed=None, twist=None, twist_by_length=None, symmetry=None, last_normal=None, tangent=None, uniform=None, relaxed=None, caps=None, style=None, transforms=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
-       super().__init__("path_sweep", {"shape" : shape, "path" : path, "method" : method, "normal" : normal, "closed" : closed, "twist" : twist, "twist_by_length" : twist_by_length, "symmetry" : symmetry, "last_normal" : last_normal, "tangent" : tangent, "uniform" : uniform, "relaxed" : relaxed, "caps" : caps, "style" : style, "transforms" : transforms, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
+    def __init__(self, shape=None, path=None, method=None, normal=None, closed=None, twist=None, twist_by_length=None, scale=None, scale_by_length=None, symmetry=None, last_normal=None, tangent=None, uniform=None, relaxed=None, caps=None, style=None, transforms=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
+       super().__init__("path_sweep", {"shape" : shape, "path" : path, "method" : method, "normal" : normal, "closed" : closed, "twist" : twist, "twist_by_length" : twist_by_length, "scale" : scale, "scale_by_length" : scale_by_length, "symmetry" : symmetry, "last_normal" : last_normal, "tangent" : tangent, "uniform" : uniform, "relaxed" : relaxed, "caps" : caps, "style" : style, "transforms" : transforms, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class path_sweep2d(_Bosl2Base):
     def __init__(self, shape=None, path=None, closed=None, caps=None, quality=None, style=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("path_sweep2d", {"shape" : shape, "path" : path, "closed" : closed, "caps" : caps, "quality" : quality, "style" : style, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class _ofs_vmap(_Bosl2Base):
     def __init__(self, ofs=None, closed=None, **kwargs):
@@ -97,59 +102,63 @@
     def __init__(self, curve=None, edge=None, curve_offset=None, closed=None, **kwargs):
        super().__init__("_find_one_tangent", {"curve" : curve, "edge" : edge, "curve_offset" : curve_offset, "closed" : closed, **kwargs})
 
 class associate_vertices(_Bosl2Base):
     def __init__(self, polygons=None, split=None, curpoly=None, **kwargs):
        super().__init__("associate_vertices", {"polygons" : polygons, "split" : split, "curpoly" : curpoly, **kwargs})
 
-class _get_texture(_Bosl2Base):
-    def __init__(self, tex=None, n=None, m=None, **kwargs):
-       super().__init__("_get_texture", {"tex" : tex, "n" : n, "m" : m, **kwargs})
-
-class textured_linear_sweep(_Bosl2Base):
-    def __init__(self, path=None, texture=None, tex_size=None, h=None, counts=None, inset=None, rot=None, tscale=None, caps=None, col_wrap=None, twist=None, scale=None, shift=None, style=None, reverse=None, l=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("textured_linear_sweep", {"path" : path, "texture" : texture, "tex_size" : tex_size, "h" : h, "counts" : counts, "inset" : inset, "rot" : rot, "tscale" : tscale, "caps" : caps, "col_wrap" : col_wrap, "twist" : twist, "scale" : scale, "shift" : shift, "style" : style, "reverse" : reverse, "l" : l, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class textured_revolution(_Bosl2Base):
-    def __init__(self, path=None, texture=None, tex_size=None, tscale=None, inset=None, rot=None, caps=None, wrap=None, shift=None, style=None, reverse=None, counts=None, **kwargs):
-       super().__init__("textured_revolution", {"path" : path, "texture" : texture, "tex_size" : tex_size, "tscale" : tscale, "inset" : inset, "rot" : rot, "caps" : caps, "wrap" : wrap, "shift" : shift, "style" : style, "reverse" : reverse, "counts" : counts, **kwargs})
-
-class textured_cylinder(_Bosl2Base):
-    def __init__(self, h=None, r=None, texture=None, tex_size=None, counts=None, tscale=None, inset=None, rot=None, caps=None, style=None, reverse=None, shift=None, l=None, r1=None, r2=None, d=None, d1=None, d2=None, chamfer=None, chamfer1=None, chamfer2=None, rounding=None, rounding1=None, rounding2=None, **kwargs):
-       super().__init__("textured_cylinder", {"h" : h, "r" : r, "texture" : texture, "tex_size" : tex_size, "counts" : counts, "tscale" : tscale, "inset" : inset, "rot" : rot, "caps" : caps, "style" : style, "reverse" : reverse, "shift" : shift, "l" : l, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, **kwargs})
+class texture(_Bosl2Base):
+    def __init__(self, tex=None, n=None, inset=None, gap=None, roughness=None, **kwargs):
+       super().__init__("texture", {"tex" : tex, "n" : n, "inset" : inset, "gap" : gap, "roughness" : roughness, **kwargs})
+
+class _get_vnf_tile_edges(_Bosl2Base):
+    def __init__(self, texture=None, **kwargs):
+       super().__init__("_get_vnf_tile_edges", {"texture" : texture, **kwargs})
+
+class _validate_texture(_Bosl2Base):
+    def __init__(self, texture=None, **kwargs):
+       super().__init__("_validate_texture", {"texture" : texture, **kwargs})
+
+class _textured_linear_sweep(_Bosl2Base):
+    def __init__(self, region=None, texture=None, tex_size=None, h=None, counts=None, inset=None, rot=None, tex_scale=None, twist=None, scale=None, shift=None, style=None, l=None, caps=None, height=None, length=None, samples=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("_textured_linear_sweep", {"region" : region, "texture" : texture, "tex_size" : tex_size, "h" : h, "counts" : counts, "inset" : inset, "rot" : rot, "tex_scale" : tex_scale, "twist" : twist, "scale" : scale, "shift" : shift, "style" : style, "l" : l, "caps" : caps, "height" : height, "length" : length, "samples" : samples, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class _find_vnf_tile_edge_path(_Bosl2Base):
+    def __init__(self, vnf=None, val=None, **kwargs):
+       super().__init__("_find_vnf_tile_edge_path", {"vnf" : vnf, "val" : val, **kwargs})
+
+class _textured_revolution(_Bosl2Base):
+    def __init__(self, shape=None, texture=None, tex_size=None, tex_scale=None, inset=None, rot=None, shift=None, taper=None, closed=None, angle=None, counts=None, samples=None, style=None, atype=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("_textured_revolution", {"shape" : shape, "texture" : texture, "tex_size" : tex_size, "tex_scale" : tex_scale, "inset" : inset, "rot" : rot, "shift" : shift, "taper" : taper, "closed" : closed, "angle" : angle, "counts" : counts, "samples" : samples, "style" : style, "atype" : atype, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class skin(_Bosl2Base):
     def __init__(self, profiles=None, slices=None, refine=None, method=None, sampling=None, caps=None, closed=None, z=None, style=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("skin", {"profiles" : profiles, "slices" : slices, "refine" : refine, "method" : method, "sampling" : sampling, "caps" : caps, "closed" : closed, "z" : z, "style" : style, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class linear_sweep(_Bosl2Base):
-    def __init__(self, region=None, height=None, center=None, twist=None, scale=None, shift=None, slices=None, maxseg=None, style=None, convexity=None, cp=None, atype=None, h=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("linear_sweep", {"region" : region, "height" : height, "center" : center, "twist" : twist, "scale" : scale, "shift" : shift, "slices" : slices, "maxseg" : maxseg, "style" : style, "convexity" : convexity, "cp" : cp, "atype" : atype, "h" : h, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, region=None, height=None, center=None, twist=None, scale=None, shift=None, slices=None, maxseg=None, style=None, convexity=None, caps=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, cp=None, atype=None, h=None, l=None, length=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("linear_sweep", {"region" : region, "height" : height, "center" : center, "twist" : twist, "scale" : scale, "shift" : shift, "slices" : slices, "maxseg" : maxseg, "style" : style, "convexity" : convexity, "caps" : caps, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "cp" : cp, "atype" : atype, "h" : h, "l" : l, "length" : length, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+
+class rotate_sweep(_Bosl2Base):
+    def __init__(self, shape=None, angle=None, texture=None, tex_size=None, tex_counts=None, tex_inset=None, tex_rot=None, tex_scale=None, tex_samples=None, tex_taper=None, shift=None, style=None, closed=None, cp=None, convexity=None, atype=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("rotate_sweep", {"shape" : shape, "angle" : angle, "texture" : texture, "tex_size" : tex_size, "tex_counts" : tex_counts, "tex_inset" : tex_inset, "tex_rot" : tex_rot, "tex_scale" : tex_scale, "tex_samples" : tex_samples, "tex_taper" : tex_taper, "shift" : shift, "style" : style, "closed" : closed, "cp" : cp, "convexity" : convexity, "atype" : atype, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class spiral_sweep(_Bosl2Base):
-    def __init__(self, poly=None, h=None, r=None, turns=None, higbee=None, center=None, r1=None, r2=None, d=None, d1=None, d2=None, higbee1=None, higbee2=None, internal=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("spiral_sweep", {"poly" : poly, "h" : h, "r" : r, "turns" : turns, "higbee" : higbee, "center" : center, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "higbee1" : higbee1, "higbee2" : higbee2, "internal" : internal, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+    def __init__(self, poly=None, h=None, r=None, turns=None, taper=None, r1=None, r2=None, d=None, d1=None, d2=None, internal=None, lead_in_shape=None, lead_in_shape1=None, lead_in_shape2=None, lead_in=None, lead_in1=None, lead_in2=None, lead_in_ang=None, lead_in_ang1=None, lead_in_ang2=None, height=None, l=None, length=None, lead_in_sample=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("spiral_sweep", {"poly" : poly, "h" : h, "r" : r, "turns" : turns, "taper" : taper, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "internal" : internal, "lead_in_shape" : lead_in_shape, "lead_in_shape1" : lead_in_shape1, "lead_in_shape2" : lead_in_shape2, "lead_in" : lead_in, "lead_in1" : lead_in1, "lead_in2" : lead_in2, "lead_in_ang" : lead_in_ang, "lead_in_ang1" : lead_in_ang1, "lead_in_ang2" : lead_in_ang2, "height" : height, "l" : l, "length" : length, "lead_in_sample" : lead_in_sample, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
 
 class path_sweep(_Bosl2Base):
-    def __init__(self, shape=None, path=None, method=None, normal=None, closed=None, twist=None, twist_by_length=None, symmetry=None, last_normal=None, tangent=None, uniform=None, relaxed=None, caps=None, style=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, profiles=None, width=None, **kwargs):
-       super().__init__("path_sweep", {"shape" : shape, "path" : path, "method" : method, "normal" : normal, "closed" : closed, "twist" : twist, "twist_by_length" : twist_by_length, "symmetry" : symmetry, "last_normal" : last_normal, "tangent" : tangent, "uniform" : uniform, "relaxed" : relaxed, "caps" : caps, "style" : style, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, "profiles" : profiles, "width" : width, **kwargs})
+    def __init__(self, shape=None, path=None, method=None, normal=None, closed=None, twist=None, twist_by_length=None, scale=None, scale_by_length=None, symmetry=None, last_normal=None, tangent=None, uniform=None, relaxed=None, caps=None, style=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, profiles=None, width=None, **kwargs):
+       super().__init__("path_sweep", {"shape" : shape, "path" : path, "method" : method, "normal" : normal, "closed" : closed, "twist" : twist, "twist_by_length" : twist_by_length, "scale" : scale, "scale_by_length" : scale_by_length, "symmetry" : symmetry, "last_normal" : last_normal, "tangent" : tangent, "uniform" : uniform, "relaxed" : relaxed, "caps" : caps, "style" : style, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, "profiles" : profiles, "width" : width, **kwargs})
 
 class path_sweep2d(_Bosl2Base):
     def __init__(self, profile=None, path=None, closed=None, caps=None, quality=None, style=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("path_sweep2d", {"profile" : profile, "path" : path, "closed" : closed, "caps" : caps, "quality" : quality, "style" : style, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class sweep(_Bosl2Base):
     def __init__(self, shape=None, transforms=None, closed=None, caps=None, style=None, convexity=None, anchor=None, cp=None, spin=None, orient=None, atype=None, **kwargs):
        super().__init__("sweep", {"shape" : shape, "transforms" : transforms, "closed" : closed, "caps" : caps, "style" : style, "convexity" : convexity, "anchor" : anchor, "cp" : cp, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
-class textured_linear_sweep(_Bosl2Base):
-    def __init__(self, path=None, texture=None, tex_size=None, h=None, inset=None, rot=None, tscale=None, twist=None, scale=None, shift=None, style=None, reverse=None, l=None, counts=None, anchor=None, spin=None, orient=None, convexity=None, **kwargs):
-       super().__init__("textured_linear_sweep", {"path" : path, "texture" : texture, "tex_size" : tex_size, "h" : h, "inset" : inset, "rot" : rot, "tscale" : tscale, "twist" : twist, "scale" : scale, "shift" : shift, "style" : style, "reverse" : reverse, "l" : l, "counts" : counts, "anchor" : anchor, "spin" : spin, "orient" : orient, "convexity" : convexity, **kwargs})
-
-class textured_revolution(_Bosl2Base):
-    def __init__(self, path=None, texture=None, tex_size=None, tscale=None, inset=None, rot=None, caps=None, wrap=None, shift=None, style=None, reverse=None, atype=None, convexity=None, counts=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("textured_revolution", {"path" : path, "texture" : texture, "tex_size" : tex_size, "tscale" : tscale, "inset" : inset, "rot" : rot, "caps" : caps, "wrap" : wrap, "shift" : shift, "style" : style, "reverse" : reverse, "atype" : atype, "convexity" : convexity, "counts" : counts, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
-
-class textured_cylinder(_Bosl2Base):
-    def __init__(self, h=None, r=None, texture=None, tex_size=None, counts=None, tscale=None, inset=None, rot=None, style=None, reverse=None, shift=None, l=None, r1=None, r2=None, d=None, d1=None, d2=None, chamfer=None, chamfer1=None, chamfer2=None, rounding=None, rounding1=None, rounding2=None, convexity=None, anchor=None, spin=None, orient=None, **kwargs):
-       super().__init__("textured_cylinder", {"h" : h, "r" : r, "texture" : texture, "tex_size" : tex_size, "counts" : counts, "tscale" : tscale, "inset" : inset, "rot" : rot, "style" : style, "reverse" : reverse, "shift" : shift, "l" : l, "r1" : r1, "r2" : r2, "d" : d, "d1" : d1, "d2" : d2, "chamfer" : chamfer, "chamfer1" : chamfer1, "chamfer2" : chamfer2, "rounding" : rounding, "rounding1" : rounding1, "rounding2" : rounding2, "convexity" : convexity, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
+class _textured_revolution(_Bosl2Base):
+    def __init__(self, shape=None, texture=None, tex_size=None, tex_scale=None, inset=None, rot=None, shift=None, taper=None, closed=None, angle=None, style=None, atype=None, convexity=None, counts=None, samples=None, anchor=None, spin=None, orient=None, **kwargs):
+       super().__init__("_textured_revolution", {"shape" : shape, "texture" : texture, "tex_size" : tex_size, "tex_scale" : tex_scale, "inset" : inset, "rot" : rot, "shift" : shift, "taper" : taper, "closed" : closed, "angle" : angle, "style" : style, "atype" : atype, "convexity" : convexity, "counts" : counts, "samples" : samples, "anchor" : anchor, "spin" : spin, "orient" : orient, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/sliders.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/sliders.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/std.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/std.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/structs.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/structs.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/transforms.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/transforms.py`

 * *Files 2% similar despite different names*

```diff
@@ -100,16 +100,16 @@
        super().__init__("zflip", {"p" : p, "z" : z, **kwargs})
 
 class frame_map(_Bosl2Base):
     def __init__(self, x=None, y=None, z=None, p=None, reverse=None, **kwargs):
        super().__init__("frame_map", {"x" : x, "y" : y, "z" : z, "p" : p, "reverse" : reverse, **kwargs})
 
 class skew(_Bosl2Base):
-    def __init__(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, **kwargs):
-       super().__init__("skew", {"p" : p, "sxy" : sxy, "sxz" : sxz, "syx" : syx, "syz" : syz, "szx" : szx, "szy" : szy, **kwargs})
+    def __init__(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, axy=None, axz=None, ayx=None, ayz=None, azx=None, azy=None, **kwargs):
+       super().__init__("skew", {"p" : p, "sxy" : sxy, "sxz" : sxz, "syx" : syx, "syz" : syz, "szx" : szx, "szy" : szy, "axy" : axy, "axz" : axz, "ayx" : ayx, "ayz" : ayz, "azx" : azx, "azy" : azy, **kwargs})
 
 class is_2d_transform(_Bosl2Base):
     def __init__(self, t=None, **kwargs):
        super().__init__("is_2d_transform", {"t" : t, **kwargs})
 
 class apply(_Bosl2Base):
     def __init__(self, transform=None, points=None, **kwargs):
@@ -200,10 +200,10 @@
        super().__init__("zflip", {"p" : p, "z" : z, **kwargs})
 
 class frame_map(_Bosl2Base):
     def __init__(self, x=None, y=None, z=None, p=None, reverse=None, **kwargs):
        super().__init__("frame_map", {"x" : x, "y" : y, "z" : z, "p" : p, "reverse" : reverse, **kwargs})
 
 class skew(_Bosl2Base):
-    def __init__(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, **kwargs):
-       super().__init__("skew", {"p" : p, "sxy" : sxy, "sxz" : sxz, "syx" : syx, "syz" : syz, "szx" : szx, "szy" : szy, **kwargs})
+    def __init__(self, p=None, sxy=None, sxz=None, syx=None, syz=None, szx=None, szy=None, axy=None, axz=None, ayx=None, ayz=None, azx=None, azy=None, **kwargs):
+       super().__init__("skew", {"p" : p, "sxy" : sxy, "sxz" : sxz, "syx" : syx, "syz" : syz, "szx" : szx, "szy" : szy, "axy" : axy, "axz" : axz, "ayx" : ayx, "ayz" : ayz, "azx" : azx, "azy" : azy, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/trigonometry.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/trigonometry.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/tripod_mounts.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/tripod_mounts.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/turtle3d.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/turtle3d.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/version.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/version.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/vnf.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/vnf.py`

 * *Files 2% similar despite different names*

```diff
@@ -84,18 +84,26 @@
     def __init__(self, l=None, imin=None, imax=None, **kwargs):
        super().__init__("_link_indicator", {"l" : l, "imin" : imin, "imax" : imax, **kwargs})
 
 class vnf_triangulate(_Bosl2Base):
     def __init__(self, vnf=None, **kwargs):
        super().__init__("vnf_triangulate", {"vnf" : vnf, **kwargs})
 
+class _vnf_sort_vertices(_Bosl2Base):
+    def __init__(self, vnf=None, idx=None, **kwargs):
+       super().__init__("_vnf_sort_vertices", {"vnf" : vnf, "idx" : idx, **kwargs})
+
 class vnf_slice(_Bosl2Base):
     def __init__(self, vnf=None, dir=None, cuts=None, **kwargs):
        super().__init__("vnf_slice", {"vnf" : vnf, "dir" : dir, "cuts" : cuts, **kwargs})
 
+class _shift_cut_plane(_Bosl2Base):
+    def __init__(self, vnf=None, dir=None, cut=None, off=None, **kwargs):
+       super().__init__("_shift_cut_plane", {"vnf" : vnf, "dir" : dir, "cut" : cut, "off" : off, **kwargs})
+
 class _split_polygon_at_x(_Bosl2Base):
     def __init__(self, poly=None, x=None, **kwargs):
        super().__init__("_split_polygon_at_x", {"poly" : poly, "x" : x, **kwargs})
 
 class _split_2dpolygons_at_each_x(_Bosl2Base):
     def __init__(self, polys=None, xs=None, _i=None, **kwargs):
        super().__init__("_split_2dpolygons_at_each_x", {"polys" : polys, "xs" : xs, "_i" : _i, **kwargs})
@@ -113,16 +121,16 @@
        super().__init__("vnf_area", {"vnf" : vnf, **kwargs})
 
 class _vnf_centroid(_Bosl2Base):
     def __init__(self, vnf=None, eps=None, **kwargs):
        super().__init__("_vnf_centroid", {"vnf" : vnf, "eps" : eps, **kwargs})
 
 class vnf_halfspace(_Bosl2Base):
-    def __init__(self, plane=None, vnf=None, closed=None, **kwargs):
-       super().__init__("vnf_halfspace", {"plane" : plane, "vnf" : vnf, "closed" : closed, **kwargs})
+    def __init__(self, plane=None, vnf=None, closed=None, boundary=None, **kwargs):
+       super().__init__("vnf_halfspace", {"plane" : plane, "vnf" : vnf, "closed" : closed, "boundary" : boundary, **kwargs})
 
 class _assemble_paths(_Bosl2Base):
     def __init__(self, vertices=None, edges=None, paths=None, i=None, **kwargs):
        super().__init__("_assemble_paths", {"vertices" : vertices, "edges" : edges, "paths" : paths, "i" : i, **kwargs})
 
 class _vnfcut(_Bosl2Base):
     def __init__(self, plane=None, vertices=None, vertexmap=None, inside=None, faces=None, vertcount=None, newfaces=None, newedges=None, newvertices=None, i=None, **kwargs):
@@ -132,17 +140,17 @@
     def __init__(self, polys=None, **kwargs):
        super().__init__("_triangulate_planar_convex_polygons", {"polys" : polys, **kwargs})
 
 class vnf_bend(_Bosl2Base):
     def __init__(self, vnf=None, r=None, d=None, axis=None, **kwargs):
        super().__init__("vnf_bend", {"vnf" : vnf, "r" : r, "d" : d, "axis" : axis, **kwargs})
 
-class vnf_validate(_Bosl2Base):
+class _vnf_validate(_Bosl2Base):
     def __init__(self, vnf=None, show_warns=None, check_isects=None, **kwargs):
-       super().__init__("vnf_validate", {"vnf" : vnf, "show_warns" : show_warns, "check_isects" : check_isects, **kwargs})
+       super().__init__("_vnf_validate", {"vnf" : vnf, "show_warns" : show_warns, "check_isects" : check_isects, **kwargs})
 
 class _vnf_validate_err(_Bosl2Base):
     def __init__(self, name=None, extra=None, **kwargs):
        super().__init__("_vnf_validate_err", {"name" : name, "extra" : extra, **kwargs})
 
 class _pts_not_reported(_Bosl2Base):
     def __init__(self, pts=None, varr=None, reports=None, **kwargs):
@@ -157,22 +165,22 @@
        super().__init__("vnf_polyhedron", {"vnf" : vnf, "convexity" : convexity, "extent" : extent, "cp" : cp, "anchor" : anchor, "spin" : spin, "orient" : orient, "atype" : atype, **kwargs})
 
 class vnf_wireframe(_Bosl2Base):
     def __init__(self, vnf=None, width=None, **kwargs):
        super().__init__("vnf_wireframe", {"vnf" : vnf, "width" : width, **kwargs})
 
 class _show_vertices(_Bosl2Base):
-    def __init__(self, vertices=None, size=None, **kwargs):
-       super().__init__("_show_vertices", {"vertices" : vertices, "size" : size, **kwargs})
+    def __init__(self, vertices=None, size=None, filter=None, **kwargs):
+       super().__init__("_show_vertices", {"vertices" : vertices, "size" : size, "filter" : filter, **kwargs})
 
 class _show_faces(_Bosl2Base):
-    def __init__(self, vertices=None, faces=None, size=None, **kwargs):
-       super().__init__("_show_faces", {"vertices" : vertices, "faces" : faces, "size" : size, **kwargs})
+    def __init__(self, vertices=None, faces=None, size=None, filter=None, **kwargs):
+       super().__init__("_show_faces", {"vertices" : vertices, "faces" : faces, "size" : size, "filter" : filter, **kwargs})
 
 class debug_vnf(_Bosl2Base):
-    def __init__(self, vnf=None, faces=None, vertices=None, opacity=None, size=None, convexity=None, **kwargs):
-       super().__init__("debug_vnf", {"vnf" : vnf, "faces" : faces, "vertices" : vertices, "opacity" : opacity, "size" : size, "convexity" : convexity, **kwargs})
+    def __init__(self, vnf=None, faces=None, vertices=None, opacity=None, size=None, convexity=None, filter=None, **kwargs):
+       super().__init__("debug_vnf", {"vnf" : vnf, "faces" : faces, "vertices" : vertices, "opacity" : opacity, "size" : size, "convexity" : convexity, "filter" : filter, **kwargs})
 
 class vnf_validate(_Bosl2Base):
-    def __init__(self, vnf=None, size=None, show_warns=None, check_isects=None, **kwargs):
-       super().__init__("vnf_validate", {"vnf" : vnf, "size" : size, "show_warns" : show_warns, "check_isects" : check_isects, **kwargs})
+    def __init__(self, vnf=None, size=None, show_warns=None, check_isects=None, opacity=None, adjacent=None, label_verts=None, label_faces=None, wireframe=None, **kwargs):
+       super().__init__("vnf_validate", {"vnf" : vnf, "size" : size, "show_warns" : show_warns, "check_isects" : check_isects, "opacity" : opacity, "adjacent" : adjacent, "label_verts" : label_verts, "label_faces" : label_faces, "wireframe" : wireframe, **kwargs})
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/walls.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/walls.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2/wiring.py` & `solidpython2-2.0.1/solid2/extensions/bosl2/wiring.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/bosl2_generator.py` & `solidpython2-2.0.1/solid2/extensions/bosl2_generator.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #! /usr/bin/env python
 
 from pathlib import Path
 
 from solid2.core.utils import escape_openscad_identifier as escape
 from solid2.libs.py_scadparser import scad_parser
 
-from openscad_extension_generator import generateStub
+from openscad_extension_generator import generateStub, makePackage
 
 headerTemplate = """\
 from solid2.core.object_base import OpenSCADConstant as _OpenSCADConstant
 from solid2.core.scad_import import extra_scad_include as _extra_scad_include
 from pathlib import Path as _Path
 
 from .bosl2_base import Bosl2Base as _Bosl2Base
@@ -98,14 +98,15 @@
             if c.name.startswith("_"):
                 continue
             f.write(generateCallable(c))
 
 bosl2_dir = Path("../libs/BOSL2")
 output_dir = Path(__file__).parent / "bosl2"
 
+makePackage(output_dir)
 generateBosl2Std(bosl2_dir)
 generateBosl2AccessSyntaxMixin(bosl2_dir, output_dir)
 
 for f in bosl2_dir.iterdir():
     if not f.suffix == ".scad":
         continue
     if f.name in ["std.scad", "builtins.scad", "bosl1compat.scad"]:
```

### Comparing `solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/customizer_widgets.py` & `solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/customizer_widgets.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/scad_interface.py` & `solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/scad_interface.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/greedy_scad_interface/scad_variable.py` & `solidpython2-2.0.1/solid2/extensions/greedy_scad_interface/scad_variable.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/extensions/openscad_extension_generator.py` & `solidpython2-2.0.1/solid2/extensions/openscad_extension_generator.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/affine.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/affine.scad`

 * *Files 10% similar despite different names*

```diff
@@ -6,35 +6,38 @@
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Affine2d 3x3 Transformation Matrices
 
 
 // Function: affine2d_identity()
+// Synopsis: Returns a 2D (3x3) identity transformation matrix.
+// Topics: Affine, Matrices, Transforms
+// See Also: affine3d_identity(), ident(), IDENT
 // Usage:
 //   mat = affine2d_identify();
-// Topics: Affine, Matrices, Transforms
 // Description:
 //   Create a 3x3 affine2d identity matrix.
 // Example:
 //   mat = affine2d_identity();
 //   // Returns:
 //   //   [
 //   //     [1, 0, 0],
 //   //     [0, 1, 0],
 //   //     [0, 0, 1]
 //   //   ]
 function affine2d_identity() = ident(3);
 
 
 // Function: affine2d_translate()
+// Synopsis: Returns a 2D (3x3) translation transformation matrix.
+// Topics: Affine, Matrices, Transforms, Translation
+// See Also: affine3d_translate(), move(), translate(), left(), right(), fwd(), back(), down(), up()
 // Usage:
 //   mat = affine2d_translate(v);
-// Topics: Affine, Matrices, Transforms, Translation
-// See Also: move(), affine3d_translate()
 // Description:
 //   Returns the 3x3 affine2d matrix to perform a 2D translation.
 // Arguments:
 //   v = 2D Offset to translate by.  [X,Y]
 // Example:
 //   mat = affine2d_translate([30,40]);
 //   // Returns:
@@ -49,18 +52,19 @@
         [1, 0, v.x],
         [0, 1, v.y],
         [0 ,0,   1]
     ];
 
 
 // Function: affine2d_scale()
+// Synopsis: Returns a 2D (3x3) scaling transformation matrix.
+// Topics: Affine, Matrices, Transforms, Scaling
+// See Also: affine3d_scale(), scale(), xscale(), yscale(), zscale(), affine3d_scale()
 // Usage:
 //   mat = affine2d_scale(v);
-// Topics: Affine, Matrices, Transforms, Scaling
-// See Also: scale(), xscale(), yscale(), zscale(), affine3d_scale()
 // Description:
 //   Returns the 3x3 affine2d matrix to perform a 2D scaling transformation.
 // Arguments:
 //   v = 2D vector of scaling factors.  [X,Y]
 // Example:
 //   mat = affine2d_scale([3,4]);
 //   // Returns:
@@ -75,18 +79,19 @@
         [v.x,   0, 0],
         [  0, v.y, 0],
         [  0,   0, 1]
     ];
 
 
 // Function: affine2d_zrot()
-// Usage:
-//   mat = affine2d_zrot(ang);
+// Synopsis: Returns a 2D (3x3) rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine3d_zrot()
+// Usage:
+//   mat = affine2d_zrot(ang);
 // Description:
 //   Returns the 3x3 affine2d matrix to perform a rotation of a 2D vector around the Z axis.
 // Arguments:
 //   ang = Number of degrees to rotate.
 // Example:
 //   mat = affine2d_zrot(90);
 //   // Returns:
@@ -101,18 +106,19 @@
         [cos(ang), -sin(ang), 0],
         [sin(ang),  cos(ang), 0],
         [       0,         0, 1]
     ];
 
 
 // Function: affine2d_mirror()
-// Usage:
-//   mat = affine2d_mirror(v);
+// Synopsis: Returns a 2D (3x3) reflection transformation matrix.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: mirror(), xflip(), yflip(), zflip(), affine3d_mirror()
+// Usage:
+//   mat = affine2d_mirror(v);
 // Description:
 //   Returns the 3x3 affine2d matrix to perform a reflection of a 2D vector across the line given by its normal vector.
 // Arguments:
 //   v = The normal vector of the line to reflect across.
 // Example:
 //   mat = affine2d_mirror([0,1]);
 //   // Returns:
@@ -144,20 +150,21 @@
         [1-2*a*a, 0-2*a*b, 0],
         [0-2*a*b, 1-2*b*b, 0],
         [      0,       0, 1]
     ];
 
 
 // Function: affine2d_skew()
+// Synopsis: Returns a 2D (3x3) skewing transformation matrix.
+// Topics: Affine, Matrices, Transforms, Skewing
+// See Also: skew(), affine3d_skew()
 // Usage:
 //   mat = affine2d_skew(xa);
 //   mat = affine2d_skew(ya=);
 //   mat = affine2d_skew(xa, ya);
-// Topics: Affine, Matrices, Transforms, Skewing
-// See Also: skew(), affine3d_skew()
 // Description:
 //   Returns the 3x3 affine2d matrix to skew a 2D vector along the XY plane.
 // Arguments:
 //   xa = Skew angle, in degrees, in the direction of the X axis. Default: 0
 //   ya = Skew angle, in degrees, in the direction of the Y axis. Default: 0
 // Example:
 //   mat = affine2d_skew(xa=45,ya=-45);
@@ -178,17 +185,19 @@
 
 
 
 // Section: Affine3d 4x4 Transformation Matrices
 
 
 // Function: affine3d_identity()
+// Synopsis: Returns a 3D (4x4) identity transformation matrix.
+// Topics: Affine, Matrices, Transforms
+// See Also: affine2d_identity(), ident(), IDENT
 // Usage:
 //   mat = affine3d_identity();
-// Topics: Affine, Matrices, Transforms
 // Description:
 //   Create a 4x4 affine3d identity matrix.
 // Example:
 //   mat = affine2d_identity();
 //   // Returns:
 //   //   [
 //   //     [1, 0, 0, 0],
@@ -196,18 +205,19 @@
 //   //     [0, 0, 1, 0],
 //   //     [0, 0, 0, 1]
 //   //   ]
 function affine3d_identity() = ident(4);
 
 
 // Function: affine3d_translate()
+// Synopsis: Returns a 3D (4x4) translation transformation matrix.
+// Topics: Affine, Matrices, Transforms, Translation
+// See Also: move(), translate(), left(), right(), fwd(), back(), down(), up(), affine2d_translate()
 // Usage:
 //   mat = affine3d_translate(v);
-// Topics: Affine, Matrices, Transforms, Translation
-// See Also: move(), affine2d_translate()
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a 3D translation.
 // Arguments:
 //   v = 3D offset to translate by.  [X,Y,Z]
 // Example:
 //   mat = affine2d_translate([30,40,50]);
 //   // Returns:
@@ -225,18 +235,19 @@
         [0, 1, 0, v.y],
         [0, 0, 1, v.z],
         [0 ,0, 0,   1]
     ];
 
 
 // Function: affine3d_scale()
-// Usage:
-//   mat = affine3d_scale(v);
+// Synopsis: Returns a 3D (4x4) scaling transformation matrix.
 // Topics: Affine, Matrices, Transforms, Scaling
 // See Also: scale(), affine2d_scale()
+// Usage:
+//   mat = affine3d_scale(v);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a 3D scaling transformation.
 // Arguments:
 //   v = 3D vector of scaling factors.  [X,Y,Z]
 // Example:
 //   mat = affine3d_scale([3,4,5]);
 //   // Returns:
@@ -254,18 +265,19 @@
         [  0, v.y,   0, 0],
         [  0,   0, v.z, 0],
         [  0,   0,   0, 1]
     ];
 
 
 // Function: affine3d_xrot()
-// Usage:
-//   mat = affine3d_xrot(ang);
+// Synopsis: Returns a 3D (4x4) X-axis rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()
+// Usage:
+//   mat = affine3d_xrot(ang);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the X axis.
 // Arguments:
 //   ang = number of degrees to rotate.
 // Example:
 //   mat = affine3d_xrot(90);
 //   // Returns:
@@ -282,18 +294,19 @@
         [0, cos(ang), -sin(ang),   0],
         [0, sin(ang),  cos(ang),   0],
         [0,        0,         0,   1]
     ];
 
 
 // Function: affine3d_yrot()
-// Usage:
-//   mat = affine3d_yrot(ang);
+// Synopsis: Returns a 3D (4x4) Y-axis rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()
+// Usage:
+//   mat = affine3d_yrot(ang);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the Y axis.
 // Arguments:
 //   ang = Number of degrees to rotate.
 // Example:
 //   mat = affine3d_yrot(90);
 //   // Returns:
@@ -310,18 +323,19 @@
         [        0, 1,        0,   0],
         [-sin(ang), 0, cos(ang),   0],
         [        0, 0,        0,   1]
     ];
 
 
 // Function: affine3d_zrot()
-// Usage:
-//   mat = affine3d_zrot(ang);
+// Synopsis: Returns a 3D (4x4) Z-axis rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()
+// Usage:
+//   mat = affine3d_zrot(ang);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the Z axis.
 // Arguments:
 //   ang = number of degrees to rotate.
 // Example:
 //   mat = affine3d_zrot(90);
 //   // Returns:
@@ -338,18 +352,19 @@
         [sin(ang),  cos(ang), 0, 0],
         [       0,         0, 1, 0],
         [       0,         0, 0, 1]
     ];
 
 
 // Function: affine3d_rot_by_axis()
-// Usage:
-//   mat = affine3d_rot_by_axis(u, ang);
+// Synopsis: Returns a 3D (4x4) arbitrary-axis rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()
+// Usage:
+//   mat = affine3d_rot_by_axis(u, ang);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around an axis.
 // Arguments:
 //   u = 3D axis vector to rotate around.
 //   ang = number of degrees to rotate.
 // Example:
 //   mat = affine3d_rot_by_axis([1,1,1], 120);
@@ -374,18 +389,19 @@
         [u.y*u.x*c2+u.z*s, u.y*u.y*c2+c    , u.y*u.z*c2-u.x*s, 0],
         [u.z*u.x*c2-u.y*s, u.z*u.y*c2+u.x*s, u.z*u.z*c2+c    , 0],
         [               0,                0,                0, 1]
     ];
 
 
 // Function: affine3d_rot_from_to()
-// Usage:
-//   mat = affine3d_rot_from_to(from, to);
+// Synopsis: Returns a 3D (4x4) tilt rotation transformation matrix.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()
+// Usage:
+//   mat = affine3d_rot_from_to(from, to);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector from one vector direction to another.
 // Arguments:
 //   from = 3D axis vector to rotate from.
 //   to = 3D axis vector to rotate to.
 // Example:
 //   mat = affine3d_rot_from_to(UP, RIGHT);
@@ -420,18 +436,19 @@
     ];
 
 
 
 
 
 // Function: affine3d_mirror()
-// Usage:
-//   mat = affine3d_mirror(v);
+// Synopsis: Returns a 3D (4x4) reflection transformation matrix.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: mirror(), xflip(), yflip(), zflip(), affine2d_mirror()
+// Usage:
+//   mat = affine3d_mirror(v);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a reflection of a 3D vector across the plane given by its normal vector.
 // Arguments:
 //   v = The normal vector of the plane to reflect across.
 // Example:
 //   mat = affine3d_mirror([1,0,0]);
 //   // Returns:
@@ -460,18 +477,19 @@
         [ -2*b*a, 1-2*b*b,  -2*b*c, 0],
         [ -2*c*a,  -2*c*b, 1-2*c*c, 0],
         [      0,       0,       0, 1]
     ];
 
 
 // Function: affine3d_skew()
-// Usage:
-//   mat = affine3d_skew([sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]);
+// Synopsis: Returns a 3D (4x4) skewing transformation matrix.
 // Topics: Affine, Matrices, Transforms, Skewing
 // See Also: skew(), affine3d_skew_xy(), affine3d_skew_xz(), affine3d_skew_yz(), affine2d_skew()
+// Usage:
+//   mat = affine3d_skew([sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]);
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a skew transformation.
 // Arguments:
 //   sxy = Skew factor multiplier for skewing along the X axis as you get farther from the Y axis.  Default: 0
 //   sxz = Skew factor multiplier for skewing along the X axis as you get farther from the Z axis.  Default: 0
 //   syx = Skew factor multiplier for skewing along the Y axis as you get farther from the X axis.  Default: 0
 //   syz = Skew factor multiplier for skewing along the Y axis as you get farther from the Z axis.  Default: 0
@@ -491,20 +509,21 @@
     [syx,   1, syz, 0],
     [szx, szy,   1, 0],
     [  0,   0,   0, 1]
 ];
 
 
 // Function: affine3d_skew_xy()
+// Synopsis: Returns a 3D (4x4) XY-plane skewing transformation matrix.
+// Topics: Affine, Matrices, Transforms, Skewing
+// See Also: skew(), affine3d_skew(), affine3d_skew_xz(), affine3d_skew_yz(), affine2d_skew()
 // Usage:
 //   mat = affine3d_skew_xy(xa);
 //   mat = affine3d_skew_xy(ya=);
 //   mat = affine3d_skew_xy(xa, ya);
-// Topics: Affine, Matrices, Transforms, Skewing
-// See Also: skew(), affine3d_skew(), affine3d_skew_xz(), affine3d_skew_yz(), affine2d_skew()
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a skew transformation along the XY plane.
 // Arguments:
 //   xa = Skew angle, in degrees, in the direction of the X axis.  Default: 0
 //   ya = Skew angle, in degrees, in the direction of the Y axis.  Default: 0
 // Example:
 //   mat = affine3d_skew_xy(xa=45,ya=-45);
@@ -515,28 +534,29 @@
 //   //     [ 0, 0, 1, 0],
 //   //     [ 0, 0, 0, 1]
 //   //   ]
 function affine3d_skew_xy(xa=0, ya=0) =
     assert(is_finite(xa))
     assert(is_finite(ya))
     [
-        [1, 0, tan(xa), 0],
-        [0, 1, tan(ya), 0],
-        [0, 0,       1, 0],
-        [0, 0,       0, 1]
+        [      1, tan(xa), 0, 0],
+        [tan(ya),       1, 0, 0],
+        [      0,       0, 1, 0],
+        [      0,       0, 0, 1]
     ];
 
 
 // Function: affine3d_skew_xz()
+// Synopsis: Returns a 3D (4x4) XZ-plane skewing transformation matrix.
+// Topics: Affine, Matrices, Transforms, Skewing
+// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_yz(), affine2d_skew()
 // Usage:
 //   mat = affine3d_skew_xz(xa);
 //   mat = affine3d_skew_xz(za=);
 //   mat = affine3d_skew_xz(xa, za);
-// Topics: Affine, Matrices, Transforms, Skewing
-// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_yz(), affine2d_skew()
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a skew transformation along the XZ plane.
 // Arguments:
 //   xa = Skew angle, in degrees, in the direction of the X axis.  Default: 0
 //   za = Skew angle, in degrees, in the direction of the Z axis.  Default: 0
 // Example:
 //   mat = affine3d_skew_xz(xa=45,za=-45);
@@ -547,28 +567,29 @@
 //   //     [ 0,-1, 1, 0],
 //   //     [ 0, 0, 0, 1]
 //   //   ]
 function affine3d_skew_xz(xa=0, za=0) =
     assert(is_finite(xa))
     assert(is_finite(za))
     [
-        [1, tan(xa), 0, 0],
-        [0,       1, 0, 0],
-        [0, tan(za), 1, 0],
-        [0,       0, 0, 1]
+        [      1, 0, tan(xa), 0],
+        [      0, 1,       0, 0],
+        [tan(za), 0,       1, 0],
+        [      0, 0,       0, 1]
     ];
 
 
 // Function: affine3d_skew_yz()
+// Synopsis: Returns a 3D (4x4) YZ-plane skewing transformation matrix.
+// Topics: Affine, Matrices, Transforms, Skewing
+// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_xz(), affine2d_skew()
 // Usage:
 //   mat = affine3d_skew_yz(ya);
 //   mat = affine3d_skew_yz(za=);
 //   mat = affine3d_skew_yz(ya, za);
-// Topics: Affine, Matrices, Transforms, Skewing
-// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_xz(), affine2d_skew()
 // Description:
 //   Returns the 4x4 affine3d matrix to perform a skew transformation along the YZ plane.
 // Arguments:
 //   ya = Skew angle, in degrees, in the direction of the Y axis.  Default: 0
 //   za = Skew angle, in degrees, in the direction of the Z axis.  Default: 0
 // Example:
 //   mat = affine3d_skew_yz(ya=45,za=-45);
@@ -579,16 +600,16 @@
 //   //     [-1, 0, 1, 0],
 //   //     [ 0, 0, 0, 1]
 //   //   ]
 function affine3d_skew_yz(ya=0, za=0) =
     assert(is_finite(ya))
     assert(is_finite(za))
     [
-        [      1, 0, 0, 0],
-        [tan(ya), 1, 0, 0],
-        [tan(za), 0, 1, 0],
-        [      0, 0, 0, 1]
+        [1,       0,       0, 0],
+        [0,       1, tan(ya), 0],
+        [0, tan(za),       1, 0],
+        [0,       0,       0, 1]
     ];
 
 
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/attachments.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/attachments.scad`

 * *Files 14% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 //////////////////////////////////////////////////////////////////////
 // LibFile: attachments.scad
 //   The modules in this file allows you to attach one object to another by making one object the child of another object.
 //   You can place the child object in relation to its parent object and control the position and orientation
-//   relative to the parent.  The modifiers allow you to treat children in different ways that simple union, such
+//   relative to the parent.  The modifiers allow you to treat children in ways different from simple union, such
 //   as differencing them from the parent, or changing their color.  Attachment only works when the parent and child
 //   are both written to support attachment.  Also included in this file  are the tools to make your own "attachable" objects.
 // Includes:
 //   include <BOSL2/std.scad>
 // FileGroup: Basic Modeling
 // FileSummary: Positioning objects on or relative to other objects.  Making your own objects support attachment.
 // FileFootnotes: STD=Included in std.scad
@@ -14,15 +14,15 @@
 
 
 // Default values for attachment code.
 $tags=undef;      // for backward compatibility
 $tag = "";
 $tag_prefix = "";
 $overlap = 0;
-$color = "default";          
+$color = "default";
 $save_color = undef;         // Saved color to revert back for children
 
 $attach_to = undef;
 $attach_anchor = [CENTER, CENTER, UP, 0];
 $attach_norot = false;
 
 $parent_anchor = BOTTOM;
@@ -38,88 +38,88 @@
 _ANCHOR_TYPES = ["intersect","hull"];
 
 
 // Section: Terminology and Shortcuts
 //   This library adds the concept of anchoring, spin and orientation to the `cube()`, `cylinder()`
 //   and `sphere()` builtins, as well as to most of the shapes provided by this library itself.
 //   - An anchor is a place on an object which you can align the object to, or attach other objects
-//     to using `attach()` or `position()`.  An anchor has a position, a direction, and a spin.
+//     to using `attach()` or `position()`. An anchor has a position, a direction, and a spin.
 //     The direction and spin are used to orient other objects to match when using `attach()`.
 //   - Spin is a simple rotation around the Z axis.
 //   - Orientation is rotating an object so that its top is pointed towards a given vector.
 //   An object will first be translated to its anchor position, then spun, then oriented.
 //   For a detailed step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 //   .
 //   For describing directions, faces, edges, and corners the library provides a set of shortcuts
 //   all based on combinations of unit direction vectors.  You can use these for anchoring and orienting
 //   attachable objects.  You can also them to specify edge sets for rounding or chamfering cuboids,
-//   or for placing edge, face and corner masks.  
+//   or for placing edge, face and corner masks.
 // Subsection: Anchor
 //   Anchoring is specified with the `anchor` argument in most shape modules.  Specifying `anchor`
 //   when creating an object will translate the object so that the anchor point is at the origin
 //   (0,0,0).  Anchoring always occurs before spin and orientation are applied.
 //   .
 //   An anchor can be referred to in one of two ways; as a directional vector, or as a named anchor string.
 //   .
 //   When given as a vector, it points, in a general way, towards the face, edge, or corner of the
 //   object that you want the anchor for, relative to the center of the object.  You can simply
-//   specify a vector like `[0,0,1]` to anchor an object at the Z+ end, but you can also use 
+//   specify a vector like `[0,0,1]` to anchor an object at the Z+ end, but you can also use
 //   directional constants with names like `TOP`, `BOTTOM`, `LEFT`, `RIGHT` and `BACK` that you can add together
-//   to specify anchor points.  See [specifying directions](attachments.scad#subsection-specifying-directions) 
-//   below for the full list of pre-defined directional constants. 
+//   to specify anchor points.  See [specifying directions](attachments.scad#subsection-specifying-directions)
+//   below for the full list of pre-defined directional constants.
 //   .
 //   For example:
 //   - `[0,0,1]` is the same as `TOP` and refers to the center of the top face.
 //   - `[-1,0,1]` is the same as `TOP+LEFT`, and refers to the center of the top-left edge.
 //   - `[1,1,-1]` is the same as `BOTTOM+BACK+RIGHT`, and refers to the bottom-back-right corner.
 //   .
 //   When the object is cubical or rectangular in shape the anchors must have zero or one values
 //   for their components and they refer to the face centers, edge centers, or corners of the object.
 //   The direction of a face anchor will be perpendicular to the face, pointing outward.  The direction of a edge anchor
 //   will be the average of the anchor directions of the two faces the edge is between.  The direction
 //   of a corner anchor will be the average of the anchor directions of the three faces the corner is
-//   on. 
+//   on.
 //   .
 //   When the object is cylindrical, conical, or spherical in nature, the anchors will be located
 //   around the surface of the cylinder, cone, or sphere, relative to the center.
 //   You can generally use an arbitrary vector to get an anchor positioned anywhere on the curved
 //   surface of such an object, and the anchor direction will be the surface normal at the anchor location.
 //   However, for anchor component pointing toward the flat face should be either -1, 1, or 0, and
 //   anchors that point diagonally toward one of the flat faces will select a point on the edge.
 //   .
 //   For objects in two dimensions, the natural expectation is for TOP and BOTTOM to refer to the Y direction
 //   of the shape.  To support this, if you give an anchor in 2D that has anchor.y=0 then the Z component
 //   will be mapped to the Y direction.  This  means you can use TOP and BOTTOM for anchors of 2D objects.
 //   But remember that TOP and BOTTOM are three dimensional vectors and this is a special interpretation
-//   for 2d anchoring.  
+//   for 2d anchoring.
 //   .
 //   Some more complex objects, like screws and stepper motors, have named anchors to refer to places
 //   on the object that are not at one of the standard faces, edges or corners.  For example, stepper
 //   motors have anchors for `"screw1"`, `"screw2"`, etc. to refer to the various screwholes on the
 //   stepper motor shape.  The names, positions, directions, and spins of these anchors are
 //   specific to the object, and are documented when they exist.
 // Subsection: Spin
 //   Spin is specified with the `spin` argument in most shape modules.  Specifying a scalar `spin`
 //   when creating an object will rotate the object counter-clockwise around the Z axis by the given
 //   number of degrees.  If given as a 3D vector, the object will be rotated around each of the X, Y, Z
 //   axes by the number of degrees in each component of the vector.  Spin is always applied after
 //   anchoring, and before orientation.  Since spin is applied after anchoring it is not what
-//   you might think of intuitively as spinning the shape.  To do that, apply `zrot()` to the shape before anchoring.  
+//   you might think of intuitively as spinning the shape.  To do that, apply `zrot()` to the shape before anchoring.
 // Subsection: Orient
 //   Orientation is specified with the `orient` argument in most shape modules.  Specifying `orient`
 //   when creating an object will rotate the object such that the top of the object will be pointed
 //   at the vector direction given in the `orient` argument.  Orientation is always applied after
 //   anchoring and spin.  The constants `UP`, `DOWN`, `FRONT`, `BACK`, `LEFT`, and `RIGHT` can be
 //   added together to form the directional vector for this.  ie: `LEFT+BACK`
 // Subsection: Specifying Directions
 //   You can use direction vectors to specify anchors for objects or to specify edges, faces, and
 //   corners of cubes.  You can simply specify these direction vectors numerically, but another
 //   option is to use named constants for direction vectors.  These constants define unit vectors
 //   for the six axis directions as shown below.
-// Figure(3D,Big,VPD=6): Named constants for direction vectors.  Some directions have more than one name.  
+// Figure(3D,Big,VPD=6): Named constants for direction vectors.  Some directions have more than one name.
 //   $fn=12;
 //   stroke([[0,0,0],RIGHT], endcap2="arrow2", width=.05);
 //   color("black")right(.05)up(.05)move(RIGHT) text3d("RIGHT",size=.1,h=.01,anchor=LEFT,orient=FRONT);
 //   stroke([[0,0,0],LEFT], endcap2="arrow2", width=.05);
 //   color("black")left(.05)up(.05)move(LEFT) text3d("LEFT",size=.1,h=.01,anchor=RIGHT,orient=FRONT);
 //   stroke([[0,0,0],FRONT], endcap2="arrow2", width=.05);
 //   color("black")
@@ -139,15 +139,15 @@
 //   down(.12)move(BOT) text3d("BOT",size=.1,h=.01,anchor=LEFT,orient=FRONT);
 //   }
 //   stroke([[0,0,0],TOP], endcap2="arrow2", width=.05);
 //   color("black")left(.05){
 //   up(.12)move(TOP) text3d("TOP",size=.1,h=.01,anchor=RIGHT,orient=FRONT);
 //   move(TOP) text3d("UP",size=.1,h=.01,anchor=RIGHT,orient=FRONT);
 //   }
-// Figure(2D,Big): Named constants for direction vectors in 2D.  For anchors the TOP and BOTTOM directions are collapsed into 2D as shown here, but do not try to use TOP or BOTTOM as 2D directions in other situations.  
+// Figure(2D,Big): Named constants for direction vectors in 2D.  For anchors the TOP and BOTTOM directions are collapsed into 2D as shown here, but do not try to use TOP or BOTTOM as 2D directions in other situations.
 //   $fn=12;
 //   stroke(path2d([[0,0,0],RIGHT]), endcap2="arrow2", width=.05);
 //   color("black")fwd(.22)left(.05)move(RIGHT) text("RIGHT",size=.1,anchor=RIGHT);
 //   stroke(path2d([[0,0,0],LEFT]), endcap2="arrow2", width=.05);
 //   color("black")right(.05)fwd(.22)move(LEFT) text("LEFT",size=.1,anchor=LEFT);
 //   stroke(path2d([[0,0,0],FRONT]), endcap2="arrow2", width=.05);
 //   color("black")
@@ -156,42 +156,42 @@
 //   color("black")move(BACK) { text("BACK",size=.1,anchor=LEFT); back(.14) text("(TOP)", size=.1, anchor=LEFT);}
 //   color("black")
 //   left(.15)back(.2+.14)move(FRONT){
 //   back(.14) text("FRONT",size=.1,anchor=RIGHT);
 //       text("FWD",size=.1,anchor=RIGHT);
 //   fwd(.14) text("FORWARD",size=.1,anchor=RIGHT);
 //   fwd(.28) text("(BOTTOM)",size=.1,anchor=RIGHT);
-//   fwd(.14*3) text("(BOT)",size=.1,anchor=RIGHT);   
+//   fwd(.14*3) text("(BOT)",size=.1,anchor=RIGHT);
 //   }
 //   stroke(path2d([[0,0,0],BACK]), endcap2="arrow2", width=.05);
 // Subsection: Specifying Faces
 //   Modules operating on faces accept a list of faces to describe the faces to operate on.  Each
 //   face is given by a vector that points to that face.  Attachments of cuboid objects onto their faces also
-//   work by choosing an attachment face with a single vector in the same manner.  
-// Figure(3D,Big,NoScales,VPD=275): The six faces of the cube.  Some have faces have more than one name.  
+//   work by choosing an attachment face with a single vector in the same manner.
+// Figure(3D,Big,NoScales,VPD=275): The six faces of the cube.  Some have faces have more than one name.
 //   ydistribute(50) {
 //      xdistribute(35){
 //        _show_cube_faces([BACK], botlabel=["BACK"]);
 //        _show_cube_faces([UP],botlabel=["TOP","UP"]);
-//        _show_cube_faces([RIGHT],botlabel=["RIGHT"]);  
+//        _show_cube_faces([RIGHT],botlabel=["RIGHT"]);
 //      }
 //      xdistribute(35){
 //        _show_cube_faces([FRONT],toplabel=["FRONT","FWD", "FORWARD"]);
 //        _show_cube_faces([DOWN],toplabel=["BOTTOM","BOT","DOWN"]);
-//        _show_cube_faces([LEFT],toplabel=["LEFT"]);  
-//      }  
+//        _show_cube_faces([LEFT],toplabel=["LEFT"]);
+//      }
 //   }
 // Subsection: Specifying Edges
 //   Modules operating on edges use two arguments to describe the edge set they will use: The `edges` argument
 //   is a list of edge set descriptors to include in the edge set, and the `except` argument is a list of
 //   edge set descriptors to remove from the edge set.
 //   The default value for `edges` is `"ALL"`, the set of all edges.
-//   The default value for `except` is the    empty set, meaning no edges are removed. 
+//   The default value for `except` is the    empty set, meaning no edges are removed.
 //   If either argument is just a single edge set
-//   descriptor it can be passed directly rather than in a singleton list.  
+//   descriptor it can be passed directly rather than in a singleton list.
 //   Each edge set descriptor must be one of:
 //   - A vector pointing towards an edge, indicating that single edge.
 //   - A vector pointing towards a face, indicating all edges surrounding that face.
 //   - A vector pointing towards a corner, indicating all edges touching that corner.
 //   - The string `"X"`, indicating all X axis aligned edges.
 //   - The string `"Y"`, indicating all Y axis aligned edges.
 //   - The string `"Z"`, indicating all Z axis aligned edges.
@@ -204,15 +204,15 @@
 //           [X-Z-, X+Z-, X-Z+, X+Z+],
 //           [X-Y-, X+Y-, X-Y+, X+Y+]
 //       ]
 //       ```
 //   You can specify edge descriptors directly by giving a vector, or you can use sums of the
 //   named direction vectors described above.  Below we show all of the edge sets you can
 //   describe with sums of the direction vectors, and then we show some examples of combining
-//   edge set descriptors.  
+//   edge set descriptors.
 // Figure(3D,Big,VPD=300,NoScales): Vectors pointing toward an edge select that single edge
 //   ydistribute(50) {
 //       xdistribute(30) {
 //           _show_edges(edges=BOT+RIGHT);
 //           _show_edges(edges=BOT+BACK);
 //           _show_edges(edges=BOT+LEFT);
 //           _show_edges(edges=BOT+FRONT);
@@ -266,41 +266,41 @@
 //           _show_edges(edges="Z");
 //       }
 //       xdistribute(30) {
 //           _show_edges(edges="ALL");
 //           _show_edges(edges="NONE");
 //       }
 //   }
-// Figure(3D,Big,VPD=310,NoScales):  Next are some examples showing how you can combine edge descriptors to obtain different edge sets.    You can specify the top front edge with a numerical vector or by combining the named direction vectors.  If you combine them as a list you get all the edges around the front or top faces.  Adding `except` removes an edge.  
+// Figure(3D,Big,VPD=310,NoScales):  Next are some examples showing how you can combine edge descriptors to obtain different edge sets.    You can specify the top front edge with a numerical vector or by combining the named direction vectors.  If you combine them as a list you get all the edges around the front and top faces.  Adding `except` removes an edge.
 //   xdistribute(43){
 //     _show_edges(_edges([0,-1,1]),toplabel=["edges=[0,-1,1]"]);
 //     _show_edges(_edges(TOP+FRONT),toplabel=["edges=TOP+FRONT"]);
 //     _show_edges(_edges([TOP,FRONT]),toplabel=["edges=[TOP,FRONT]"]);
-//     _show_edges(_edges([TOP,FRONT],TOP+FRONT),toplabel=["edges=[TOP,FRONT]","except=TOP+FRONT"]);      
+//     _show_edges(_edges([TOP,FRONT],TOP+FRONT),toplabel=["edges=[TOP,FRONT]","except=TOP+FRONT"]);
 //   }
-// Figure(3D,Big,VPD=310,NoScales): Using `except=BACK` removes the four edges surrounding the back face if they are present in the edge set.  In the first example only one edge needs to be removed.  In the second example we remove two of the Z-aligned edges.  The third example removes all four back edges from the default edge set of all edges.  You can explicitly give `edges="ALL"` but it is not necessary, since this is the default.  In the fourth example, the edge set of Y-aligned edges contains no back edges, so the `except` parameter has no effect.  
+// Figure(3D,Big,VPD=310,NoScales): Using `except=BACK` removes the four edges surrounding the back face if they are present in the edge set.  In the first example only one edge needs to be removed.  In the second example we remove two of the Z-aligned edges.  The third example removes all four back edges from the default edge set of all edges.  You can explicitly give `edges="ALL"` but it is not necessary, since this is the default.  In the fourth example, the edge set of Y-aligned edges contains no back edges, so the `except` parameter has no effect.
 //   xdistribute(43){
 //     _show_edges(_edges(BOT,BACK), toplabel=["edges=BOT","except=BACK"]);
 //     _show_edges(_edges("Z",BACK), toplabel=["edges=\"Z\"", "except=BACK"]);
 //     _show_edges(_edges("ALL",BACK), toplabel=["(edges=\"ALL\")", "except=BACK"]);
-//     _show_edges(_edges("Y",BACK), toplabel=["edges=\"Y\"","except=BACK"]);   
+//     _show_edges(_edges("Y",BACK), toplabel=["edges=\"Y\"","except=BACK"]);
 //   }
-// Figure(3D,Big,NoScales,VPD=310): On the left `except` is a list to remove two edges.  In the center we show a corner edge set defined by a numerical vector, and at the right we remove that same corner edge set with named direction vectors.  
+// Figure(3D,Big,NoScales,VPD=310): On the left `except` is a list to remove two edges.  In the center we show a corner edge set defined by a numerical vector, and at the right we remove that same corner edge set with named direction vectors.
 //   xdistribute(52){
 //    _show_edges(_edges("ALL",[FRONT+RIGHT,FRONT+LEFT]),
 //               toplabel=["except=[FRONT+RIGHT,","       FRONT+LEFT]"]);
-//    _show_edges(_edges([1,-1,1]),toplabel=["edges=[1,-1,1]"]);             
-//    _show_edges(_edges([TOP,BOT], TOP+RIGHT+FRONT),toplabel=["edges=[TOP,BOT]","except=TOP+RIGHT+FRONT"]); 
-//   }             
+//    _show_edges(_edges([1,-1,1]),toplabel=["edges=[1,-1,1]"]);
+//    _show_edges(_edges([TOP,BOT], TOP+RIGHT+FRONT),toplabel=["edges=[TOP,BOT]","except=TOP+RIGHT+FRONT"]);
+//   }
 // Subsection: Specifying Corners
 //   Modules operating on corners use two arguments to describe the corner set they will use: The `corners` argument
 //   is a list of corner set descriptors to include in the corner set, and the `except` argument is a list of
 //   corner set descriptors to remove from the corner set.
 //   The default value for `corners` is `"ALL"`, the set of all corners.
-//   The default value for `except` is the   empty set, meaning no corners are removed.  
+//   The default value for `except` is the   empty set, meaning no corners are removed.
 //   If either argument is just a single corner set
 //   descriptor it can be passed directly rather than in a singleton list.
 //   Each corner set descriptor must be one of:
 //   - A vector pointing towards a corner, indicating that corner.
 //   - A vector pointing towards an edge indicating both corners at the ends of that edge.
 //   - A vector pointing towards a face, indicating all the corners of that face.
 //   - The string `"ALL"`, indicating all corners.
@@ -308,15 +308,15 @@
 //   - A length 8 vector where each entry corresponds to a corner and is 1 if the corner is included and 0 if it is excluded.  The corner ordering is
 //       ```
 //       [X-Y-Z-, X+Y-Z-, X-Y+Z-, X+Y+Z-, X-Y-Z+, X+Y-Z+, X-Y+Z+, X+Y+Z+]
 //       ```
 //   You can specify corner descriptors directly by giving a vector, or you can use sums of the
 //   named direction vectors described above.  Below we show all of the corner sets you can
 //   describe with sums of the direction vectors and then we show some examples of combining
-//   corner set descriptors.  
+//   corner set descriptors.
 // Figure(3D,Big,NoScales,VPD=300): Vectors pointing toward a corner select that corner.
 //   ydistribute(55) {
 //       xdistribute(35) {
 //           _show_corners(corners=FRONT+LEFT+TOP);
 //           _show_corners(corners=FRONT+RIGHT+TOP);
 //           _show_corners(corners=FRONT+LEFT+BOT);
 //           _show_corners(corners=FRONT+RIGHT+BOT);
@@ -363,49 +363,124 @@
 //       }
 //   }
 // Figure(3D,Med,NoScales,VPD=200): Corners by name
 //   xdistribute(35) {
 //       _show_corners(corners="ALL");
 //       _show_corners(corners="NONE");
 //   }
-// Figure(3D,Big,NoScales,VPD=300):     Next are some examples showing how you can combine corner descriptors to obtain different corner sets.   You can specify corner sets numerically or by adding together named directions.  The third example shows a list of two corner specifications, giving all the corners on the front face or the right face.  
+// Figure(3D,Big,NoScales,VPD=300):     Next are some examples showing how you can combine corner descriptors to obtain different corner sets.   You can specify corner sets numerically or by adding together named directions.  The third example shows a list of two corner specifications, giving all the corners on the front face or the right face.
 //   xdistribute(52){
 //     _show_corners(_corners([1,-1,-1]),toplabel=["corners=[1,-1,-1]"]);
 //     _show_corners(_corners(BOT+RIGHT+FRONT),toplabel=["corners=BOT+RIGHT+FRONT"]);
 //     _show_corners(_corners([FRONT,RIGHT]), toplabel=["corners=[FRONT,RIGHT]"]);
 //   }
 // Figure(3D,Big,NoScales,VPD=300): Corners for one edge, two edges, and all the edges except the two on one edge.  Note that since the default is all edges, you only need to give the except argument in this case:
 //    xdistribute(52){
 //      _show_corners(_corners(FRONT+TOP), toplabel=["corners=FRONT+TOP"]);
 //       _show_corners(_corners([FRONT+TOP,BOT+BACK]), toplabel=["corners=[FRONT+TOP,","        BOT+BACK]"]);
 //       _show_corners(_corners("ALL",FRONT+TOP), toplabel=["(corners=\"ALL\")","except=FRONT+TOP"]);
 //    }
-// Figure(3D,Med,NoScales,VPD=240): The first example shows a single corner removed from the top corners using a numerical vector.  The second one shows removing a set of two corner descriptors from the implied set of all corners.  
+// Figure(3D,Med,NoScales,VPD=240): The first example shows a single corner removed from the top corners using a numerical vector.  The second one shows removing a set of two corner descriptors from the implied set of all corners.
 //    xdistribute(58){
 //       _show_corners(_corners(TOP,[1,1,1]), toplabel=["corners=TOP","except=[1,1,1]"]);
 //       _show_corners(_corners("ALL",[FRONT+RIGHT+TOP,FRONT+LEFT+BOT]),
 //                    toplabel=["except=[FRONT+RIGHT+TOP,","       FRONT+LEFT+BOT]"]);
 //    }
+// Subsection: Anchoring of Non-Rectangular Objects and Anchor Type (atype)
+//   We focused above on rectangular objects that have well-defined faces and edges aligned with the coordinate axes.
+//   Things get difficult when the objects are curved, or even when their edges are not neatly aligned with the coordinate axes.
+//   In these cases, the library may provide multiple different anchoring schemes, called the anchor types.  When a module supports
+//   multiple anchor types, use the `atype=` parameter to select the anchor type you need.
+// .
+//   First consider the case of a simple rectangle whose corners have been rounded.  Where should the anchors lie?
+//   The default anchor type puts them in the same location as the anchors of an unrounded rectangle, which means that for
+//   positive rounding radii, they are not even located on the perimeter of the object.
+// Figure(2D,Med,NoAxes): Default "box" atype anchors for a rounded {{rect()}}
+//   rect([100,50], rounding=[10,0,0,-20],chamfer=[0,10,-20,0]) show_anchors();
+// Continues:
+//   This choice enables you to position the box, or attach things to it, without regard to its rounding or chamfers.  If you need to
+//   anchor onto the roundovers or chamfers then you can use the "perim" anchor type:
+// Figure(2D,Med,NoAxes): The "perim" atype for a rounded and chamfered {{rect()}}
+//   rect([100,50], rounding=[10,0,0,-20],chamfer=[0,10,-20,0],atype="perim") show_anchors();
+// Continues:
+//   With this anchor type, the anchors are located on the perimeter.  For positive roundings they point in the standard anchor direction;
+//   for negative roundings they are parallel to the base.  As noted above, for circles, cylinders, and spheres, the anchor point is
+//   determined by choosing the point where the anchor vector intersects the shape.  On a circle, this results in an anchor whose direction
+//   matches the user provided anchor vector.  But on an ellipse, something else happens:
+// Figure(2D,Med,NoAxes): Anchors on an ellipse.  The red arrow shows a TOP+RIGHT anchor direction. 
+//   ellipse([70,30]) show_anchors();
+//   stroke([[0,0],[45,45]], color="red",endcap2="arrow2");
+// Continues:
+//   For a TOP+RIGHT anchor direction, the surface normal at the intersection point does not match the anchor direction,
+//   so the direction of the anchor shown in blue does not match the direction specified, in red.
+//   Anchors computed this way have anchor type "intersect".  When a shape is concave, intersection anchors can produce
+//   a result buried inside the shape's concavity.  Consider the RIGHT anchor of this supershape example:
+// Figure(2D,Med,NoAxes): A supershape with "intersect" anchor type:
+//   supershape(n=150,r=75, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype="intersect") show_anchors();
+// Continues:
+//   A different anchor type called "hull" finds anchors that are on the convex hull of the shape.  
+// Figure(2D,Med,NoAxes): A supershape with "hull" anchor type:
+//   supershape(n=150,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype="hull") show_anchors();
+// Continues:
+//   Hull anchoring works by creating the line (or plane in 3D) that is normal to the specified anchor direction, and
+//   finding the point farthest from the center that intersects that line (or plane).
+// Figure(2D,Med,NoAxes): Finding the RIGHT and BACK+LEFT "hull" anchors
+//   supershape(n=128,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype="hull") {
+//     position(RIGHT) color_this("red")rect([1,90],anchor=LEFT);
+//     attach(RIGHT)anchor_arrow2d(13);
+//     attach(BACK+LEFT) {
+//        anchor_arrow2d(13);
+//        color_this("red")rect([30,1]);
+//        }
+//     }
+// Continues:
+//   In the example the RIGHT anchor is found when the normal line (shown in red) is tangent to the shape at two points.
+//   The anchor is then taken to be the midpoint.  The BACK+LEFT anchor occurs with a single tangent point, and the
+//   anchor point is located at the tangent point.  For circles intersection is done to the exact circle, but for other
+//   shapes these calculations are done on the point lists that defines the shape, so if you change the number of points
+//   in the list, the precise location of the anchors can change.  You can also get surprising results if your point list is badly chosen.
+// Figure(2D,Med,NoAxes): Circle anchor in blue.  The red anchor is computed to a point list of a circle with 17 segments.  
+//   circle(r=31,$fn=128) attach(TOP)anchor_arrow2d(15);
+//   region(circle(r=33,$fn=17)) {color("red")attach(TOP)anchor_arrow2d(13);}
+// Continues:
+//   The figure shows a large horizontal offset due to a poor choice of sampling for the circular shape when using the "hull" anchor type.
+//   The determination of "hull" or "intersect" anchors may depend on the location of the centerpoint used in the computation.
+//   Some of the modules allow you to change the centerpoint using a `cp=` argument.  If you need to change the centerpoint for
+//   a module that does not provide this option, you can use the generic {{region()}} module, which will let you specify a centerpoint.
+//   The default center point is the centroid, specified by "centroid".  You can also choose "mean", which gives the mean of all
+//   the data points, or "bbox", which gives the centerpoint of the bounding box for the data.  Your last option for centerpoint is to
+//   choose an arbitrary point that meets your needs.
+// Figure(2D,Med,NoAxes): The centerpoint for "intersect" anchors is located at the red dot
+//   region(supershape(n=128,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9),atype="intersect",cp=[0,30]) show_anchors();
+//   color("red")back(30)circle(r=2,$fn=16);
+// Continues:
+//   Note that all the anchors for an object have to be determined based on one anchor type and relative to the same centerpoint.
+//   The supported anchor types for each module appear in the "Anchor Types" section of its entry.  
+
+
 
 
 
 // Section: Attachment Positioning
 
 // Module: position()
-// Usage:
-//   position(from) CHILDREN;
-//
+// Synopsis: Attaches children to a parent object at an anchor point.
 // Topics: Attachments
 // See Also: attachable(), attach(), orient()
-//
+// Usage:
+//   PARENT() position(from) CHILDREN;
 // Description:
 //   Attaches children to a parent object at an anchor point.  For a step-by-step explanation
 //   of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   from = The vector, or name of the parent anchor point to attach to.
+// Side Effects:
+//   `$attach_anchor` for each `from=` anchor given, this is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+//   `$attach_to` is set to `undef`.
+//   `$attach_norot` is set to `true`.
 // Example:
 //   spheroid(d=20) {
 //       position(TOP) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);
 //       position(RIGHT) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);
 //       position(FRONT) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);
 //   }
 module position(from)
@@ -420,112 +495,105 @@
         $attach_norot = true;
         translate(anch[1]) children();
     }
 }
 
 
 // Module: orient()
-// Usage:
-//   orient(dir, [spin=]) CHILDREN;
-//   orient(anchor=, [spin=]) CHILDREN;
+// Synopsis: Orients children's tops in the directon of the specified anchor.
 // Topics: Attachments
+// See Also: attachable(), attach(), orient()
+// Usage:
+//   PARENT() orient(anchor, [spin]) CHILDREN;
 // Description:
-//   Orients children such that their top is tilted towards the given direction, or towards the
-//   direction of a given anchor point on the parent.  For a step-by-step explanation of
-//   attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
+//   Orients children such that their top is tilted in the direction of the specified parent anchor point. 
+//   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
-//   dir = The direction to orient towards.
-//   ---
-//   anchor = The anchor on the parent which you want to match the orientation of.  Use instead of `dir`.
+//   anchor = The anchor on the parent which you want to match the orientation of.
 //   spin = The spin to add to the children.  (Overrides anchor spin.)
-// See Also: attachable(), attach(), orient()
-// Example: Orienting by Vector
-//   prismoid([50,50],[30,30],h=40) {
-//       position(TOP+RIGHT)
-//           orient(RIGHT)
-//               prismoid([30,30],[0,5],h=20,anchor=BOT+LEFT);
-//   }
+// Side Effects:
+//   `$attach_anchor` is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for the `anchor=`, if given.
+//   `$attach_to` is set to `undef`.
+//   `$attach_norot` is set to `true`.
+//
 // Example: When orienting to an anchor, the spin of the anchor may cause confusion:
 //   prismoid([50,50],[30,30],h=40) {
 //       position(TOP+RIGHT)
-//           orient(anchor=RIGHT)
+//           orient(RIGHT)
 //               prismoid([30,30],[0,5],h=20,anchor=BOT+LEFT);
 //   }
 // Example: You can override anchor spin with `spin=`.
 //   prismoid([50,50],[30,30],h=40) {
 //       position(TOP+RIGHT)
-//           orient(anchor=RIGHT,spin=0)
+//           orient(RIGHT,spin=0)
 //               prismoid([30,30],[0,5],h=20,anchor=BOT+LEFT);
 //   }
 // Example: Or you can anchor the child from the back
 //   prismoid([50,50],[30,30],h=40) {
 //       position(TOP+RIGHT)
-//           orient(anchor=RIGHT)
+//           orient(RIGHT)
 //               prismoid([30,30],[0,5],h=20,anchor=BOT+BACK);
 //   }
-module orient(dir, anchor, spin) {
+module orient(anchor, spin) {
     req_children($children);
-    if (!is_undef(dir)) {
-        assert(anchor==undef, "Only one of dir= or anchor= may be given to orient()");
-        assert(is_vector(dir));
-        spin = default(spin, 0);
-        assert(is_finite(spin));
-        two_d = _attach_geom_2d($parent_geom);
-        fromvec = two_d? BACK : UP;
-        rot(spin, from=fromvec, to=dir) children();
-    } else {
-        assert(dir==undef, "Only one of dir= or anchor= may be given to orient()");
-        assert($parent_geom != undef, "No parent to orient from!");
-        assert(is_string(anchor) || is_vector(anchor));
-        anch = _find_anchor(anchor, $parent_geom);
-        two_d = _attach_geom_2d($parent_geom);
-        fromvec = two_d? BACK : UP;
-        $attach_to = undef;
-        $attach_anchor = anch;
-        $attach_norot = true;
-        spin = default(spin, anch[3]);
-        assert(is_finite(spin));
-        rot(spin, from=fromvec, to=anch[2]) children();
-    }
+    check=
+      assert($parent_geom != undef, "No parent to orient from!")
+      assert(is_string(anchor) || is_vector(anchor));
+    anch = _find_anchor(anchor, $parent_geom);
+    two_d = _attach_geom_2d($parent_geom);
+    fromvec = two_d? BACK : UP;
+    $attach_to = undef;
+    $attach_anchor = anch;
+    $attach_norot = true;
+    spin = default(spin, anch[3]);
+    assert(is_finite(spin));
+    rot(spin, from=fromvec, to=anch[2]) children();
 }
 
 
 
 // Module: attach()
-// Usage:
-//   attach(from, [overlap=], [norot=]) CHILDREN;
-//   attach(from, to, [overlap=], [norot=]) CHILDREN;
+// Synopsis: Attaches children to a parent object at an anchor point and orientation.
 // Topics: Attachments
 // See Also: attachable(), position(), face_profile(), edge_profile(), corner_profile()
+// Usage:
+//   PARENT() attach(from, [overlap=], [norot=]) CHILDREN;
+//   PARENT() attach(from, to, [overlap=], [norot=]) CHILDREN;
 // Description:
 //   Attaches children to a parent object at an anchor point and orientation.  Attached objects will
 //   be overlapped into the parent object by a little bit, as specified by the `$overlap`
 //   value (0 by default), or by the overriding `overlap=` argument.  This is to prevent OpenSCAD
 //   from making non-manifold objects.  You can define `$overlap=` as an argument in a parent
 //   module to set the default for all attachments to it.  For a step-by-step explanation of
 //   attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   from = The vector, or name of the parent anchor point to attach to.
 //   to = Optional name of the child anchor point.  If given, orients the child such that the named anchors align together rotationally.
 //   ---
 //   overlap = Amount to sink child into the parent.  Equivalent to `down(X)` after the attach.  This defaults to the value in `$overlap`, which is `0` by default.
 //   norot = If true, don't rotate children when attaching to the anchor point.  Only translate to the anchor point.
+// Side Effects:
+//   `$idx` is set to the index number of each anchor if a list of anchors is given.  Otherwise is set to `0`.
+//   `$attach_anchor` for each `from=` anchor given, this is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+//   `$attach_to` is set to the value of the `to=` argument, if given.  Otherwise, `undef`
+//   `$attach_norot` is set to the value of the `norot=` argument.
 // Example:
 //   spheroid(d=20) {
 //       attach(TOP) down(1.5) cyl(l=11.5, d1=10, d2=5, anchor=BOTTOM);
 //       attach(RIGHT, BOTTOM) down(1.5) cyl(l=11.5, d1=10, d2=5);
 //       attach(FRONT, BOTTOM, overlap=1.5) cyl(l=11.5, d1=10, d2=5);
 //   }
 module attach(from, to, overlap, norot=false)
 {
     req_children($children);
     assert($parent_geom != undef, "No object to attach to!");
     overlap = (overlap!=undef)? overlap : $overlap;
     anchors = (is_vector(from)||is_string(from))? [from] : from;
-    for (anchr = anchors) {
+    for ($idx = idx(anchors)) {
+        anchr = anchors[$idx];
         anch = _find_anchor(anchr, $parent_geom);
         two_d = _attach_geom_2d($parent_geom);
         $attach_to = to;
         $attach_anchor = anch;
         $attach_norot = norot;
         olap = two_d? [0,-overlap,0] : [0,0,-overlap];
         if (norot || (norm(anch[2]-UP)<1e-9 && anch[3]==0)) {
@@ -533,64 +601,67 @@
         } else {
             fromvec = two_d? BACK : UP;
             translate(anch[1]) rot(anch[3],from=fromvec,to=anch[2]) translate(olap) children();
         }
     }
 }
 
-// Section: Attachment Modifiers
+// Section: Tagging
 
 // Module: tag()
-// Usage:
-//   tag(tag) CHILDREN;
+// Synopsis: Assigns a tag to an object
 // Topics: Attachments
 // See Also: force_tag(), recolor(), hide(), show_only(), diff(), intersect()
+// Usage:
+//   PARENT() tag(tag) CHILDREN;
 // Description:
 //   Assigns the specified tag to all of the children. Note that if you want
 //   to apply a tag to non-tag-aware objects you need to use {{force_tag()}} instead.
 //   This works by setting the `$tag` variable, but it provides extra error checking and
-//   handling of scopes.  You may set `$tag` directly yourself, but this is not recommended. 
+//   handling of scopes.  You may set `$tag` directly yourself, but this is not recommended.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   tag = tag string, which must not contain any spaces.
 // Side Effects:
-//   Sets `$tag` to the tag you specify. 
-// Example(3D):  Applies the tag to both cuboids instead of having to repeat `$tag="remove"` for each one. 
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
+// Example(3D):  Applies the tag to both cuboids instead of having to repeat `$tag="remove"` for each one.
 //   diff("remove")
 //     cuboid(10){
 //       position(TOP) cuboid(3);
 //       tag("remove")
 //       {
 //         position(FRONT) cuboid(3);
 //         position(RIGHT) cuboid(3);
 //       }
-//     }  
+//     }
 module tag(tag)
 {
     req_children($children);
-    assert(is_string(tag),"tag must be a string");
-    assert(undef==str_find($tag," "),str("Tag string \"",$tag,"\" contains a space, which is not allowed"))    ;
+    check=
+      assert(is_string(tag),"tag must be a string")
+      assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));
     $tag = str($tag_prefix,tag);
     children();
 }
 
 
 // Module: force_tag()
-// Usage:
-//   force_tag([tag]) CHILDREN;
+// Synopsis: Assigns a tag to a non-attachable object.
 // Topics: Attachments
 // See Also: tag(), recolor(), hide(), show_only(), diff(), intersect()
+// Usage:
+//   PARENT() force_tag([tag]) CHILDREN;
 // Description:
 //   You use this module when you want to make a non-attachable or non-BOSL2 module respect tags.
 //   It applies to its children the tag specified (or the tag currently in force if you don't specify a tag),
 //   making a final determination about whether to show or hide the children.
 //   This means that tagging in children's children will be ignored.
 //   This module is specifically provided for operating on children that are not tag aware such as modules
-//   that don't use {{attachable()}} or built in modules such as 
+//   that don't use {{attachable()}} or built in modules such as
 //   - `polygon()`
 //   - `projection()`
 //   - `polyhedron()`  (or use [`vnf_polyhedron()`](vnf.scad#vnf_polyhedron))
 //   - `linear_extrude()`  (or use [`linear_sweep()`](regions.scad#linear_sweep))
 //   - `rotate_extrude()`
 //   - `surface()`
 //   - `import()`
@@ -605,48 +676,95 @@
 //   get the correct behavior, every non-attachable module needs an invocation of force_tag, even ones
 //   that are not tagged.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   tag = tag string, which must not contain any spaces
 // Side Effects:
-//   Sets `$tag` to the tag you specify. 
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
 // Example(2D): This example produces the full square without subtracting the "remove" item.  When you use non-attachable modules with tags, results are unpredictable.
 //   diff()
 //   {
 //     polygon(square(10));
 //     move(-[.01,.01])polygon(square(5),$tag="remove");
 //   }
-// Example(2D): Adding force_tag() fixes the model.  Note you need to add it to *every* non-attachable module, even the untagged ones, as shown here.  
+// Example(2D): Adding force_tag() fixes the model.  Note you need to add it to *every* non-attachable module, even the untagged ones, as shown here.
 //   diff()
 //   {
 //     force_tag()
 //       polygon(square(10));
 //     force_tag("remove")
 //       move(-[.01,.01])polygon(square(5));
 //   }
 module force_tag(tag)
 {
     req_children($children);
-    assert(is_undef(tag) || is_string(tag),"tag must be a string");
+    check1=assert(is_undef(tag) || is_string(tag),"tag must be a string");
+    $tag = str($tag_prefix,default(tag,$tag));
     assert(undef==str_find($tag," "),str("Tag string \"",$tag,"\" contains a space, which is not allowed"));
-    $tag = str($tag_prefix,is_def(tag) ? tag : $tag);
     if(_is_shown())
       show_all()
         children();
 }
 
+
+
+// Module: default_tag()
+// Synopsis: Sets a default tag for all children.
+// Topics: Attachments
+// See Also: force_tag(), recolor(), hide(), show_only(), diff(), intersect()
+// Usage:
+//   PARENT() default_tag(tag) CHILDREN;
+// Description:
+//   Sets a default tag for all of the children.  This is intended to be used to set a tag for a whole module
+//   that is then used outside the module, such as setting the tag to "remove" for easy operation with {{diff()}}.
+//   The default_tag() module sets the `$tag` variable only if it is not already
+//   set so you can have a module set a default tag of "remove" but that tag can be overridden by a {{tag()}}
+//   in force from a parent.  If you use {{tag()}} it will override any previously
+//   specified tag from a parent, which can be very confusing to a user trying to change the tag on a module.
+//   .
+//   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
+// Arguments:
+//   tag = tag string, which must not contain any spaces.
+// Side Effects:
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
+// Example(3D):  The module thing() is defined with {{tag()}} and the user applied tag of "keep_it" is ignored, leaving the user puzzled.
+//   module thing() { tag("remove") cuboid(10);}
+//   diff()
+//     cuboid(20){
+//       position(TOP) thing();
+//       position(RIGHT) tag("keep_it") thing();
+//   }
+// Example(3D):  Using default_tag() fixes this problem: the user applied tag does not get overridden by the tag hidden in the module definition.
+//   module thing() { default_tag("remove") cuboid(10);}
+//   diff()
+//     cuboid(20){
+//       position(TOP) thing();
+//       position(RIGHT) tag("keep_it") thing();
+//   }
+module default_tag(tag)
+{
+    if ($tag=="") tag(tag) children();
+    else children();
+}
+
+
 // Module: tag_scope()
+// Synopsis: Creates a new tag scope.
+// See Also: tag(), force_tag(), default_tag()
+// Topics: Attachments
 // Usage:
 //   tag_scope([scope]) CHILDREN;
 // Description:
 //   Creates a tag scope with locally altered tag names to avoid tag name conflict with other code.
 //   This is necessary when writing modules because the module's caller might happen to use the same tags.
-//   Note that if you directly set the `$tag` variable then tag scoping will not work correctly.  
-// Example: In this example the ring module uses "remove" tags which will conflict with use of the same tags by the parent.  
+//   Note that if you directly set the `$tag` variable then tag scoping will not work correctly.
+// Side Effects:
+//   `$tag_prefix` is set to the value of `scope=` if given, otherwise is set to a random string.
+// Example: In this example the ring module uses "remove" tags which will conflict with use of the same tags by the parent.
 //   module ring(r,h,w=1,anchor,spin,orient)
 //   {
 //     tag_scope("ringscope")
 //       attachable(anchor,spin,orient,r=r,h=h){
 //         diff()
 //           cyl(r=r,h=h)
 //             tag("remove") cyl(r=r-w,h=h+1);
@@ -665,48 +783,59 @@
 //          tag("rem")ring(9.5,8,w=.3);
 //       }
 //     }
 module tag_scope(scope){
   req_children($children);
   scope = is_undef(scope) ? rand_str(20) : scope;
   assert(is_string(scope), "scope must be a string");
+  assert(undef==str_find(scope," "),str("Scope string \"",scope,"\" contains a space, which is not allowed"));
   $tag_prefix=scope;
   children();
-}  
+}
+
 
+// Section: Attachment Modifiers
 
 // Module: diff()
-// Usage:
-//   diff([remove], [keep]) CHILDREN;
+// Synopsis: Performs a differencing operation using tags rather than hierarchy to control what happens.
 // Topics: Attachments
 // See Also: tag(), force_tag(), recolor(), show_only(), hide(), tag_diff(), intersect(), tag_intersect()
+// Usage:
+//   diff([remove], [keep]) PARENT() CHILDREN;
 // Description:
-//   Perform a differencing operation using tags to control what happens.  This is specifically intended to
+//   Performs a differencing operation using tags to control what happens.  This is specifically intended to
 //   address the situation where you want differences between a parent and child object, something
-//   that is impossible with the native difference() module.  
+//   that is impossible with the native difference() module.
 //   The children to diff are grouped into three categories, regardless of nesting level.
 //   The `remove` argument is a space delimited list of tags specifying objects to
 //   subtract.  The `keep` argument is a similar list of tags giving objects to be kept.
 //   Objects not matching either the `remove` or `keep` lists form the third category of base objects.
-//   To produce its output, diff() forms the union of all the base objects and then 
+//   To produce its output, diff() forms the union of all the base objects and then
 //   subtracts all the objects with tags in `remove`.  Finally it adds in objects listed in `keep`.
 //   Attachable objects should be tagged using {{tag()}}
-//   and non-attachable objects with {{force_tag()}}.  
-//   . 
+//   and non-attachable objects with {{force_tag()}}.
+//   .
+//   Remember when using tagged operations with that the operations don't happen in hierarchical order, since
+//   the point of tags is to break the hierarchy.  If you tag an object with a keep tag, nothing will be
+//   subtracted from it, no matter where it appears because kept objects are unioned in at the end.
+//   If you want a child of an object tagged with a remove tag to stay in the model it may be
+//   better to give it a tag that is not a remove tag or a keep tag.  Such an object *will* be subject to
+//   subtractions from other remove-tagged objects.  
+//   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   remove = String containing space delimited set of tag names of children to difference away.  Default: `"remove"`
 //   keep = String containing space delimited set of tag names of children to keep; that is, to union into the model after differencing is completed.  Default: `"keep"`
 // Example: Diffing using default tags
 //   diff()
 //   cuboid(50) {
 //       tag("remove") attach(TOP) sphere(d=40);
 //       tag("keep") attach(CTR) cylinder(h=40, d=10);
 //   }
-// Example: The "hole" items are subtracted from everything else.  The other tags can be anything you find convenient.  
+// Example: The "hole" items are subtracted from everything else.  The other tags can be anything you find convenient.
 //   diff("hole")
 //     tag("body")sphere(d=100) {
 //       tag("pole") zcyl(d=55, h=100);  // attach() not needed for center-to-center.
 //       tag("hole") {
 //          xcyl(d=55, h=101);
 //          ycyl(d=55, h=101);
 //       }
@@ -715,20 +844,20 @@
 // Example:
 //   diff(keep="axle")
 //   sphere(d=100) {
 //       tag("axle")xcyl(d=40, l=120);
 //       tag("remove")cuboid([40,120,100]);
 //   }
 // Example: Masking
-//   diff("mask")
+//   diff()
 //   cube([80,90,100], center=true) {
 //       edge_mask(FWD)
 //           rounding_edge_mask(l=max($parent_size)*1.01, r=25);
 //   }
-// Example: Here we subtract the parent object from the child.  Because tags propagate to children we need to clear the "remove" tag from the child. 
+// Example: Here we subtract the parent object from the child.  Because tags propagate to children we need to clear the "remove" tag from the child.
 //  diff()
 //     tag("remove")cuboid(10)
 //       tag("")position(RIGHT+BACK)cyl(r=8,h=9);
 // Example(3D,VPR=[104,0,200], VPT=[-0.9,3.03, -0.74], VPD=19,NoAxes,NoScales): A pipe module that subtracts its interior when you call it using diff().  Normally if you union two pipes together, you'll get interfering walls at the intersection, but not here:
 //   $fn=16;
 //   // This module must be called by subtracting with "diff"
 //   module pipe(length, od, id) {
@@ -743,15 +872,15 @@
 //       pipe(length=5, od=2, id=1.9);
 //       zrot(10)xrot(75)
 //         pipe(length=5, od=2, id=1.9);
 //     }
 //     // The orange bar has its center removed
 //     color("orange") down(1) xcyl(h=8, d=1);
 //     // "keep" prevents interior of the blue bar intact
-//     tag("keep") recolor("blue") up(1) xcyl(h=8, d=1);  
+//     tag("keep") recolor("blue") up(1) xcyl(h=8, d=1);
 //   }
 //   // Objects outside the diff don't have pipe interiors removed
 //   color("purple") down(2.2) ycyl(h=8, d=0.3);
 // Example(3D,NoScales,NoAxes): Nested diff() calls work as expected, but be careful of reusing tag names, even hidden in submodules.
 //   $fn=32;
 //   diff("rem1")
 //   cyl(r=10,h=10){
@@ -774,29 +903,29 @@
 //              tag("remA")diff("remB")
 //                left(.2)position(LEFT)cyl(r=6,h=8,anchor=LEFT)
 //                  tag("remB")diff("remA")
 //                    right(.2)position(RIGHT)cyl(r=5,h=9,anchor=RIGHT)
 //                      tag("remA")diff("remB")
 //                        right(.2)position(RIGHT)cyl(r=4,h=10,anchor=RIGHT)
 //                          tag("remB")left(.2)position(LEFT)cyl(r=3,h=11,anchor=LEFT);
-// Example(3D,NoAxes,NoScales): When working with Non-Attachables like rotate_extrude() you must apply {{force_tag()}} to every non-attachable object.  
+// Example(3D,NoAxes,NoScales): When working with Non-Attachables like rotate_extrude() you must apply {{force_tag()}} to every non-attachable object.
 //   back_half()
 //     diff("remove")
 //       cuboid(40) {
 //         attach(TOP)
 //           recolor("lightgreen")
 //             cyl(l=10,d=30);
 //         position(TOP+RIGHT)
 //           force_tag("remove")
 //             xrot(90)
 //               rotate_extrude()
 //                 right(20)
 //                   circle(5);
 //       }
-// Example: Here is another example where two children are intersected using the native intersection operator, and then tagged with {{force_tag()}}.  Note that because the children are at the save level, you don't need to use a tagged operator for their intersection.  
+// Example: Here is another example where two children are intersected using the native intersection operator, and then tagged with {{force_tag()}}.  Note that because the children are at the same level, you don't need to use a tagged operator for their intersection.
 //  $fn=32;
 //  diff()
 //    cuboid(10){
 //      force_tag("remove")intersection()
 //        {
 //          position(RIGHT) cyl(r=7,h=15);
 //          position(LEFT) cyl(r=7,h=15);
@@ -807,15 +936,15 @@
 //   $fn=32;
 //   diff()
 //     cuboid(10){
 //       tag("remove")cyl(r=4,h=11)
 //         tag("keep")cyl(r=3,h=17)
 //           tag("remove")position(RIGHT)cyl(r=2,h=18);
 //     }
-// Example: Combining tag operators can be tricky.  Here the `diff()` operation keeps two tags, "fullkeep" and "keep".  Then {{intersect()}} intersects the "keep" tagged item with everything else, but keeps the "fullkeep" object.  
+// Example: Combining tag operators can be tricky.  Here the `diff()` operation keeps two tags, "fullkeep" and "keep".  Then {{intersect()}} intersects the "keep" tagged item with everything else, but keeps the "fullkeep" object.
 //   $fn=32;
 //   intersect("keep","fullkeep")
 //     diff(keep="fullkeep keep")
 //       cuboid(10){
 //         tag("remove")cyl(r=4,h=11);
 //         tag("keep") position(RIGHT)cyl(r=8,h=12);
 //         tag("fullkeep")cyl(r=1,h=12);
@@ -839,45 +968,46 @@
 //           cyl(r=2,h=10,anchor=CTR);
 //         tag("remove") cyl(r=3,h=15);
 //       }
 module diff(remove="remove", keep="keep")
 {
     req_children($children);
     assert(is_string(remove),"remove must be a string of tags");
-    assert(is_string(keep),"keep must be a string of tags"); 
+    assert(is_string(keep),"keep must be a string of tags");
     if (_is_shown())
-    {      
+    {
         difference() {
             hide(str(remove," ",keep)) children();
             show_only(remove) children();
         }
     }
-    show_int(keep)children();        
+    show_int(keep)children();
 }
 
 
 // Module: tag_diff()
-// Usage:
-//   tag_diff(tag, [remove], [keep]) CHILDREN;
+// Synopsis: Performs a {{diff()}} and then sets a tag on the result.
 // Topics: Attachments
 // See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), intersect(), tag_intersect()
+// Usage:
+//   tag_diff(tag, [remove], [keep]) PARENT() CHILDREN;
 // Description:
 //   Perform a differencing operation in the manner of {{diff()}} using tags to control what happens,
 //   and then tag the resulting difference object with the specified tag.  This forces the specified
 //   tag to be resolved at the level of the difference operation.  In most cases, this is not necessary,
 //   but if you have kept objects and want to operate on this difference object as a whole object using
-//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.  
-//   . 
+//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.
+//   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   tag = Tag string to apply to this difference object
 //   remove = String containing space delimited set of tag names of children to difference away.  Default: `"remove"`
 //   keep = String containing space delimited set of tag names of children to keep; that is, to union into the model after differencing is completed.  Default: `"keep"`
 // Side Effects:
-//   Sets `$tag` to the tag you specify. 
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
 // Example: In this example we have a difference with a kept object that is then subtracted from a cube, but we don't want the kept object to appear in the final output, so this result is wrong:
 //   diff("rem"){
 //     cuboid([20,10,30],anchor=FRONT);
 //     tag("rem")diff("remove","keep"){
 //       cuboid([10,10,20]);
 //       tag("remove")cuboid([11,11,5]);
 //       tag("keep")cuboid([2,2,20]);
@@ -888,78 +1018,78 @@
 //     cuboid([20,10,30],anchor=FRONT);
 //       tag_diff("rem","remove","keep"){
 //         cuboid([10,10,20]);
 //         tag("remove")cuboid([11,11,5]);
 //         tag("keep")cuboid([2,2,20]);
 //       }
 //   }
-// Example: This concentric cylinder example uses "keep" and produces the wrong result.  The kept cylinder gets kept in the final output instead of subtracted.  This happens even when we make sure to change the `keep` argument at the top level {{diff()}} call.  
+// Example: This concentric cylinder example uses "keep" and produces the wrong result.  The kept cylinder gets kept in the final output instead of subtracted.  This happens even when we make sure to change the `keep` argument at the top level {{diff()}} call.
 //   diff("rem","nothing")
 //     cyl(r=8,h=6)
 //       tag("rem")diff()
 //         cyl(r=7,h=7)
 //           tag("remove")cyl(r=6,h=8)
 //           tag("keep")cyl(r=5,h=9);
 // Example: Changing to tag_diff() causes the kept cylinder to be subtracted, producing the desired result:
 //   diff("rem")
 //     cyl(r=8,h=6)
 //       tag_diff("rem")
 //         cyl(r=7,h=7)
 //           tag("remove")cyl(r=6,h=8)
 //           tag("keep")cyl(r=5,h=9);
-// 
 module tag_diff(tag,remove="remove", keep="keep")
 {
     req_children($children);
     assert(is_string(remove),"remove must be a string of tags");
     assert(is_string(keep),"keep must be a string of tags");
     assert(is_string(tag),"tag must be a string");
-    assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));   
-    $tag=tag;
+    assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));
+    $tag=str($tag_prefix,tag);
     if (_is_shown())
       show_all(){
          difference() {
             hide(str(remove," ",keep)) children();
             show_only(remove) children();
          }
-         show_only(keep)children();        
+         show_only(keep)children();
       }
 }
 
 
 // Module: intersect()
-// Usage:
-//   intersect([intersect], [keep]) CHILDREN;
+// Synopsis: Perform an intersection operation on children using tags rather than hierarchy to control what happens.
 // Topics: Attachments
 // See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), tag_diff(), tag_intersect()
+// Usage:
+//   intersect([intersect], [keep]) PARENT() CHILDREN;
 // Description:
 //   Performs an intersection operation on its children, using tags to
 //   determine what happens.  This is specifically intended to address
 //   the situation where you want intersections involving a parent and
 //   child object, something that is impossible with the native
 //   intersection() module.  This module treats the children in three
 //   groups: objects matching the tags listed in `intersect`, objects
 //   matching tags listed in `keep`, and the remaining objects that
 //   don't match any of the listed tags.  The intersection is computed
 //   between the union of the `intersect` tagged objects and union of the objects that don't
 //   match any of the listed tags.  Finally the objects listed in `keep` are
 //   unioned with the result.  Attachable objects should be tagged using {{tag()}}
-//   and non-attachable objects with {{force_tag()}}.  
+//   and non-attachable objects with {{force_tag()}}.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   intersect = String containing space delimited set of tag names of children to intersect.  Default: "intersect"
 //   keep = String containing space delimited set of tag names of children to keep whole.  Default: "keep"
 // Example:
 //   intersect("mask", keep="axle")
 //     sphere(d=100) {
 //         tag("mask")cuboid([40,100,100]);
 //         tag("axle")xcyl(d=40, l=100);
-//     } 
-// Example: Combining tag operators can be tricky.  Here the {{diff()}} operation keeps two tags, "fullkeep" and "keep".  Then `intersect()` intersects the "keep" tagged item with everything else, but keeps the "fullkeep" object.  
+//     }
+// Example: Combining tag operators can be tricky.  Here the {{diff()}} operation keeps two tags, "fullkeep" and "keep".  Then `intersect()` intersects the "keep" tagged item with everything else, but keeps the "fullkeep" object.
 //   $fn=32;
 //   intersect("keep","fullkeep")
 //     diff(keep="fullkeep keep")
 //       cuboid(10){
 //         tag("remove")cyl(r=4,h=11);
 //         tag("keep") position(RIGHT)cyl(r=8,h=12);
 //         tag("fullkeep")cyl(r=1,h=12);
@@ -988,378 +1118,451 @@
    assert(is_string(intersect),"intersect must be a string of tags");
    assert(is_string(keep),"keep must be a string of tags");
    intersection(){
       show_only(intersect) children();
       hide(str(intersect," ",keep)) children();
    }
    show_int(keep) children();
-}   
+}
 
 
 // Module: tag_intersect()
-// Usage:
-//   tag_intersect(tag, [intersect], [keep]) CHILDREN;
+// Synopsis: Performs an {{intersect()}} and then tags the result.
 // Topics: Attachments
 // See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), tag_diff(), intersect()
+// Usage:
+//   tag_intersect(tag, [intersect], [keep]) PARENT() CHILDREN;
 // Description:
 //   Perform an intersection operation in the manner of {{intersect()}} using tags to control what happens,
 //   and then tag the resulting difference object with the specified tag.  This forces the specified
 //   tag to be resolved at the level of the intersect operation.  In most cases, this is not necessary,
 //   but if you have kept objects and want to operate on this difference object as a whole object using
-//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.  
+//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   tag = Tag to set for the intersection
 //   intersect = String containing space delimited set of tag names of children to intersect.  Default: "intersect"
 //   keep = String containing space delimited set of tag names of children to keep whole.  Default: "keep"
 // Side Effects:
-//   Sets `$tag` to the tag you specify. 
-// Example:  Without `tag_intersect()` the kept object is not included in the difference.  
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
+// Example:  Without `tag_intersect()` the kept object is not included in the difference.
 //   $fn=32;
 //   diff()
 //     cuboid([20,15,9])
 //     tag("remove")intersect()
 //       cuboid(10){
 //         tag("intersect")position(RIGHT) cyl(r=7,h=10);
 //         tag("keep")position(LEFT)cyl(r=4,h=10);
 //       }
-// Example: Using tag_intersect corrects the problem. 
+// Example: Using tag_intersect corrects the problem.
 //   $fn=32;
 //   diff()
 //     cuboid([20,15,9])
 //     tag_intersect("remove")
 //       cuboid(10){
 //         tag("intersect")position(RIGHT) cyl(r=7,h=10);
 //         tag("keep")position(LEFT)cyl(r=4,h=10);
-//       } 
+//       }
 module tag_intersect(tag,intersect="intersect",keep="keep")
 {
    assert(is_string(intersect),"intersect must be a string of tags");
    assert(is_string(keep),"keep must be a string of tags");
    assert(is_string(tag),"tag must be a string");
-   assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));   
-   $tag=tag;
+   assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));
+   $tag=str($tag_prefix,tag);
    if (_is_shown())
      show_all(){
        intersection(){
           show_only(intersect) children();
           hide(str(intersect," ",keep)) children();
        }
        show_only(keep) children();
    }
-}   
+}
 
 
 // Module: conv_hull()
-// Usage:
-//   conv_hull([keep]) CHILDREN;
+// Synopsis:  Performs a hull operation on the children using tags to determine what happens.
 // Topics: Attachments
 // See Also: tag(), recolor(), show_only(), hide(), diff(), intersect()
+// Usage:
+//   conv_hull([keep]) CHILDREN;
 // Description:
 //   Performs a hull operation on the children using tags to determine what happens.  The items
 //   not tagged with the `keep` tags are combined into a convex hull, and the children tagged with the keep tags
-//   are unioned with the result.  
+//   are unioned with the result.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   keep = String containing space delimited set of tag names of children to keep out of the hull.  Default: "keep"
-// Example:  
+// Example:
 //   conv_hull("keep")
 //      sphere(d=100, $fn=64) {
-//        cuboid([40,90,90]); 
+//        cuboid([40,90,90]);
 //        tag("keep")xcyl(d=40, l=120);
 //      }
 // Example: difference combined with hull where all objects are relative to each other.
 //   $fn=32;
 //   diff()
 //     conv_hull("remove")
 //       cuboid(10)
 //         position(RIGHT+BACK)cyl(r=4,h=10)
 //           tag("remove")cyl(r=2,h=12);
 module conv_hull(keep="keep")
-{  
+{
     req_children($children);
     assert(is_string(keep),"keep must be a string of tags");
     if (_is_shown())
         hull() hide(keep) children();
     show_int(keep) children();
 }
 
 
 // Module: tag_conv_hull()
-// Usage:
-//   tag,conv_hull(tag, [keep]) CHILDREN;
+// Synopsis: Performs a {{conv_hull()}} and then sets a tag on the result.
 // Topics: Attachments
 // See Also: tag(), recolor(), show_only(), hide(), diff(), intersect()
+// Usage:
+//   tag_conv_hull(tag, [keep]) CHILDREN;
 // Description:
 //   Perform a convex hull operation in the manner of {{conv_hull()}} using tags to control what happens,
 //   and then tag the resulting hull object with the specified tag.  This forces the specified
 //   tag to be resolved at the level of the hull operation.  In most cases, this is not necessary,
 //   but if you have kept objects and want to operate on the hull object as a whole object using
-//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.  
+//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.
 //   .
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   keep = String containing space delimited set of tag names of children to keep out of the hull.  Default: "keep"
 // Side Effects:
-//   Sets `$tag` to the tag you specify. 
+//   Sets `$tag` to the tag you specify, possibly with a scope prefix.
 // Example: With a regular tag, the kept object is not handled as desired:
 //   diff(){
 //      cuboid([30,30,9])
-//        tag("remove")conv_hull("remove")       
+//        tag("remove")conv_hull("remove")
 //          cuboid(10,anchor=LEFT+FRONT){
 //            position(RIGHT+BACK)cyl(r=4,h=10);
-//            tag("keep")position(FRONT+LEFT)cyl(r=4,h=10);         
+//            tag("keep")position(FRONT+LEFT)cyl(r=4,h=10);
 //          }
 //   }
 // Example: Using `tag_conv_hull()` fixes the problem:
 //   diff(){
 //      cuboid([30,30,9])
-//        tag_conv_hull("remove")       
+//        tag_conv_hull("remove")
 //          cuboid(10,anchor=LEFT+FRONT){
 //            position(RIGHT+BACK)cyl(r=4,h=10);
-//            tag("keep")position(FRONT+LEFT)cyl(r=4,h=10);         
+//            tag("keep")position(FRONT+LEFT)cyl(r=4,h=10);
 //          }
 //   }
 module tag_conv_hull(tag,keep="keep")
 {
     req_children($children);
     assert(is_string(keep),"keep must be a string of tags");
     assert(is_string(tag),"tag must be a string");
-    assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));   
-    $tag=tag;
+    assert(undef==str_find(tag," "),str("Tag string \"",tag,"\" contains a space, which is not allowed"));
+    $tag=str($tag_prefix,tag);
     if (_is_shown())
       show_all(){
         hull() hide(keep) children();
         show_only(keep) children();
       }
-}    
+}
 
 
 // Module: hide()
+// Synopsis: Hides attachable children with the given tags.
+// Topics: Attachments
+// See Also: tag(), recolor(), show_only(), show_all(), show_int(), diff(), intersect()
 // Usage:
 //   hide(tags) CHILDREN;
-// Topics: Attachments
-// See Also: tag(), recolor(), show_only(), diff(), intersect()
 // Description:
-//   Hides all attachable children with the given tags, which you supply as a space separated string. Previously hidden objects remain hidden, so hiding is cumulative, unlike `show_only()`.  
+//   Hides all attachable children with the given tags, which you supply as a space separated string. Previously hidden objects remain hidden, so hiding is cumulative, unlike `show_only()`.
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Side Effects:
-//   Sets `$tags_hidden` to include the tags you specify. 
-// Example:  Hides part of the model.  
+//   Sets `$tags_hidden` to include the tags you specify.
+// Example:  Hides part of the model.
 //   hide("A")
 //     tag("main") cube(50, anchor=CENTER, $tag="Main") {
-//       tag("A")attach(LEFT, BOTTOM) cylinder(d=30, l=30);
-//       tag("B")attach(RIGHT, BOTTOM) cylinder(d=30, l=30);
+//       tag("A")attach(LEFT, BOTTOM) cylinder(d=30, h=30);
+//       tag("B")attach(RIGHT, BOTTOM) cylinder(d=30, h=30);
 //     }
 // Example: Use an invisible parent to position children.  Note that children must be retagged because they inherit the parent tag.
 //   $fn=16;
 //   hide("hidden")
 //     tag("hidden")cuboid(10)
 //       tag("visible") {
 //         position(RIGHT) cyl(r=1,h=12);
 //         position(LEFT) cyl(r=1,h=12);
-//       }  
+//       }
 module hide(tags)
 {
     req_children($children);
-    assert(is_string(tags), "tags must be a string");
+    dummy=assert(is_string(tags), "tags must be a string");
     taglist = [for(s=str_split(tags," ",keep_nulls=false)) str($tag_prefix,s)];
     $tags_hidden = concat($tags_hidden,taglist);
     children();
 }
 
 
 // Module: show_only()
+// Synopsis: Show only the children with the listed tags.
+// See Also: tag(), recolor(), show_all(), show_int(), diff(), intersect()
+// Topics: Attachments
 // Usage:
 //   show_only(tags) CHILDREN;
-// Topics: Attachments
-// See Also: tag(), recolor(), hide(), diff(), intersect()
 // Description:
-//   Show only the children with the listed tags, which you sply as a space separated string.  Only unhidden objects will be shown, so if an object is hidden either before or after the `show_only()` call then it will remain hidden.  This overrides any previous `show_only()` calls.  Unlike `hide()`, calls to `show_only()` are not cumulative.  
+//   Show only the children with the listed tags, which you sply as a space separated string.  Only unhidden objects will be shown, so if an object is hidden either before or after the `show_only()` call then it will remain hidden.  This overrides any previous `show_only()` calls.  Unlike `hide()`, calls to `show_only()` are not cumulative.
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Side Effects:
-//   Sets `$tags_shown` to the tag you specify. 
+//   Sets `$tags_shown` to the tag you specify.
 // Example:  Display the attachments but not the parent
 //   show_only("visible")
-//     cube(50, anchor=CENTER) 
+//     cube(50, anchor=CENTER)
 //       tag("visible"){
-//         attach(LEFT, BOTTOM) cylinder(d=30, l=30);
-//         attach(RIGHT, BOTTOM) cylinder(d=30, l=30);
+//         attach(LEFT, BOTTOM) cylinder(d=30, h=30);
+//         attach(RIGHT, BOTTOM) cylinder(d=30, h=30);
 //       }
 module show_only(tags)
 {
     req_children($children);
-    assert(is_string(tags), str("tags must be a string",tags));
+    dummy=assert(is_string(tags), str("tags must be a string",tags));
     taglist = [for(s=str_split(tags," ",keep_nulls=false)) str($tag_prefix,s)];
-    $tags_shown = taglist;    
+    $tags_shown = taglist;
     children();
 }
 
 // Module: show_all()
+// Synopsis: Shows all children and clears tags.
+// See Also: tag(), recolor(), show_only(), show_int(), diff(), intersect()
+// Topics: Attachments
 // Usage;
 //   show_all() CHILDREN;
 // Description:
 //   Shows all children.  Clears the list of hidden tags and shown tags so that all child objects will be
 //   fully displayed.
 // Side Effects:
 //   Sets `$tags_shown="ALL"`
 //   Sets `$tags_hidden=[]`
 module show_all()
 {
    req_children($children);
    $tags_shown="ALL";
    $tags_hidden=[];
    children();
-}   
+}
 
 
 // Module: show_int()
+// Synopsis: Shows children with the listed tags which were already shown in the parent context.
+// See Also: tag(), recolor(), show_only(), show_all(), show_int(), diff(), intersect()
+// Topics: Attachments
 // Usage:
 //   show_int(tags) CHILDREN;
 // Description:
 //   Show only the children with the listed tags which were already shown in the parent context.
 //   This intersects the current show list with the list of tags you provide.
 // Arguments:
 //   tags = list of tags to show
 // Side Effects:
 //   Sets `$tags_shown`
 module show_int(tags)
 {
     req_children($children);
-    assert(is_string(tags), str("tags must be a string",tags));
+    dummy=assert(is_string(tags), str("tags must be a string",tags));
     taglist = [for(s=str_split(tags," ",keep_nulls=false)) str($tag_prefix,s)];
     $tags_shown = $tags_shown == "ALL" ? taglist : set_intersection($tags_shown,taglist);
     children();
 }
 
 
-// Section: Attachable Masks
+// Section: Mask Attachment
+
+
+// Module: face_mask()
+// Synopsis: Ataches a 3d mask shape to the given faces of the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), edge_mask(), corner_mask(), face_profile(), edge_profile(), corner_profile()
+// Usage:
+//   PARENT() face_mask(faces) CHILDREN;
+// Description:
+//   Takes a 3D mask shape, and attaches it to the given faces, with the appropriate orientation to be
+//   differenced away.  The mask shape should be vertically oriented (Z-aligned) with the bottom half
+//   (Z-) shaped to be diffed away from the face of parent attachable shape.  If no tag is set then
+//   `face_mask()` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
+//   For details on specifying the faces to mask see [Specifying Faces](attachments.scad#subsection-specifying-faces).
+//   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
+// Arguments:
+//   edges = Faces to mask.  See  [Specifying Faces](attachments.scad#subsection-specifying-faces) for information on specifying faces.  Default: All faces
+// Side Effects:
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+//   `$idx` is set to the index number of each face in the list of faces given.
+//   `$attach_anchor` is set for each face given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+// Example:
+//   diff()
+//   cylinder(r=30, h=60)
+//       face_mask(TOP) {
+//           rounding_cylinder_mask(r=30,rounding=5);
+//           cuboid([5,61,10]);
+//       }
+// Example: Using `$idx`
+//   diff()
+//   cylinder(r=30, h=60)
+//       face_mask([TOP, BOT])
+//           zrot(45*$idx) zrot_copies([0,90]) cuboid([5,61,10]);
+module face_mask(faces=[LEFT,RIGHT,FRONT,BACK,BOT,TOP]) {
+    req_children($children);
+    faces = is_vector(faces)? [faces] : faces;
+    assert(all([for (face=faces) is_vector(face) && sum([for (x=face) x!=0? 1 : 0])==1]), "Vector in faces doesn't point at a face.");
+    assert($parent_geom != undef, "No object to attach to!");
+    attach(faces) {
+       if ($tag=="") tag("remove") children();
+       else children();
+    }
+}
 
 
 // Module: edge_mask()
+// Synopsis: Attaches a 3D mask shape to the given edges of the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), face_mask(), corner_mask(), face_profile(), edge_profile(), corner_profile()
 // Usage:
-//   edge_mask([edges], [except]) CHILDREN;
-// Topics: Attachments
-// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_mask()
+//   PARENT() edge_mask([edges], [except]) CHILDREN;
 // Description:
 //   Takes a 3D mask shape, and attaches it to the given edges, with the appropriate orientation to be
-//   `diff()`ed away.  The mask shape should be vertically oriented (Z-aligned) with the back-right
-//   quadrant (X+Y+) shaped to be diffed away from the edge of parent attachable shape.
+//   differenced away.  The mask shape should be vertically oriented (Z-aligned) with the back-right
+//   quadrant (X+Y+) shaped to be diffed away from the edge of parent attachable shape.  If no tag is set
+//   then `edge_mask` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
 //   For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Figure: A Typical Edge Rounding Mask
 //   module roundit(l,r) difference() {
 //       translate([-1,-1,-l/2])
 //           cube([r+1,r+1,l]);
 //       translate([r,r])
 //           cylinder(h=l+1,r=r,center=true, $fn=quantup(segs(r),4));
 //   }
 //   roundit(l=30,r=10);
 // Arguments:
 //   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.
 //   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.
 // Side Effects:
-//   Sets `$tag = "mask"` for all children.
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+// Side Effects:
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+//   `$idx` is set to the index number of each edge.
+//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
 // Example:
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_mask([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           rounding_edge_mask(l=71,r=10);
 module edge_mask(edges=EDGES_ALL, except=[]) {
     req_children($children);
     assert($parent_geom != undef, "No object to attach to!");
     edges = _edges(edges, except=except);
     vecs = [
         for (i = [0:3], axis=[0:2])
         if (edges[axis][i]>0)
         EDGE_OFFSETS[axis][i]
     ];
-    for (vec = vecs) {
+    for ($idx = idx(vecs)) {
+        vec = vecs[$idx];
         vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);
-        assert(vcount == 2, "Not an edge vector!");
+        dummy=assert(vcount == 2, "Not an edge vector!");
         anch = _find_anchor(vec, $parent_geom);
         $attach_to = undef;
         $attach_anchor = anch;
         $attach_norot = true;
-        $tag = "mask";
         rotang =
             vec.z<0? [90,0,180+v_theta(vec)] :
             vec.z==0 && sign(vec.x)==sign(vec.y)? 135+v_theta(vec) :
             vec.z==0 && sign(vec.x)!=sign(vec.y)? [0,180,45+v_theta(vec)] :
             [-90,0,180+v_theta(vec)];
-        translate(anch[1]) rot(rotang) children();
+        translate(anch[1]) rot(rotang)
+           if ($tag=="") tag("remove") children();
+           else children();
     }
 }
 
 
 // Module: corner_mask()
+// Synopsis: Attaches a 3d mask shape to the given corners of the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), face_mask(), edge_mask(), face_profile(), edge_profile(), corner_profile()
 // Usage:
-//   corner_mask([corners], [except]) CHILDREN;
-// Topics: Attachments
-// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), edge_mask()
+//   PARENT() corner_mask([corners], [except]) CHILDREN;
 // Description:
 //   Takes a 3D mask shape, and attaches it to the specified corners, with the appropriate orientation to
-//   be `diff()`ed away.  The 3D corner mask shape should be designed to mask away the X+Y+Z+ octant.
-//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.  
+//   be differenced away.  The 3D corner mask shape should be designed to mask away the X+Y+Z+ octant.  If no tag is set
+//   then `corner_mask` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
+//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   corners = Corners to mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: All corners.
 //   except = Corners to explicitly NOT mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: No corners.
 // Side Effects:
-//   Sets `$tag = "mask"` for all children.
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+//   `$idx` is set to the index number of each corner.
+//   `$attach_anchor` is set for each corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
 // Example:
-//   diff("mask")
+//   diff()
 //   cube(100, center=true)
 //       corner_mask([TOP,FRONT],LEFT+FRONT+TOP)
 //           difference() {
 //               translate(-0.01*[1,1,1]) cube(20);
 //               translate([20,20,20]) sphere(r=20);
 //           }
 module corner_mask(corners=CORNERS_ALL, except=[]) {
     req_children($children);
     assert($parent_geom != undef, "No object to attach to!");
     corners = _corners(corners, except=except);
     vecs = [for (i = [0:7]) if (corners[i]>0) CORNER_OFFSETS[i]];
-    for (vec = vecs) {
+    for ($idx = idx(vecs)) {
+        vec = vecs[$idx];
         vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);
-        assert(vcount == 3, "Not an edge vector!");
+        dummy=assert(vcount == 3, "Not an edge vector!");
         anch = _find_anchor(vec, $parent_geom);
         $attach_to = undef;
         $attach_anchor = anch;
         $attach_norot = true;
-        $tag = "mask";
         rotang = vec.z<0?
             [  0,0,180+v_theta(vec)-45] :
             [180,0,-90+v_theta(vec)-45];
-        translate(anch[1]) rot(rotang) children();
+        translate(anch[1]) rot(rotang)
+           if ($tag=="") tag("remove") children();
+           else children();
     }
 }
 
 
 // Module: face_profile()
-// Usage:
-//   face_profile(faces, r|d=, [convexity=]) CHILDREN;
-// Topics: Attachments
-// See Also: attachable(), position(), attach(), edge_profile(), corner_profile()
-// Description:
-//   Given a 2D edge profile, extrudes it into a mask for all edges and corners bounding each given face.
-//   See  [Specifying Faces](attachments.scad#subsection-specifying-faces) for information on specifying faces.  
+// Synopsis: Extrudes a 2D edge profile into a mask for all edges and corners of the given faces on the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), edge_profile(), corner_profile(), face_mask(), edge_mask(), corner_mask()
+// Usage:
+//   PARENT() face_profile(faces, r|d=, [convexity=]) CHILDREN;
+// Description:
+//   Given a 2D edge profile, extrudes it into a mask for all edges and corners bounding each given face. If no tag is set
+//   then `face_profile` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
+//   See  [Specifying Faces](attachments.scad#subsection-specifying-faces) for information on specifying faces.
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   faces = Faces to mask edges and corners of.
 //   r = Radius of corner mask.
 //   ---
 //   d = Diameter of corner mask.
 //   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10
 // Side Effects:
-//   Sets `$tag = "mask"` for all children.
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+//   `$idx` is set to the index number of each face.
+//   `$attach_anchor` is set for each edge or corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+//   `$profile_type` is set to `"edge"` or `"corner"`, depending on what is being masked.
 // Example:
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       face_profile(TOP,r=10)
 //           mask2d_roundover(r=10);
 module face_profile(faces=[], r, d, convexity=10) {
     req_children($children);
     faces = is_vector(faces)? [faces] : faces;
     assert(all([for (face=faces) is_vector(face) && sum([for (x=face) x!=0? 1 : 0])==1]), "Vector in faces doesn't point at a face.");
@@ -1367,112 +1570,125 @@
     assert(is_num(r) && r>0);
     edge_profile(faces) children();
     corner_profile(faces, convexity=convexity, r=r) children();
 }
 
 
 // Module: edge_profile()
+// Synopsis: Extrudes a 2d edge profile into a mask on the given edges of the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), face_profile(), corner_profile(), edge_mask(), face_mask(), corner_mask()
 // Usage:
-//   edge_profile([edges], [except], [convexity]) CHILDREN;
-// Topics: Attachments
-// See Also: attachable(), position(), attach(), face_profile(), corner_profile()
+//   PARENT() edge_profile([edges], [except], [convexity]) CHILDREN;
 // Description:
 //   Takes a 2D mask shape and attaches it to the selected edges, with the appropriate orientation and
-//   extruded length to be `diff()`ed away, to give the edge a matching profile.
+//   extruded length to be `diff()`ed away, to give the edge a matching profile.  If no tag is set
+//   then `edge_profile` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
 //   For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).
 //   For a step-by-step
 //   explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.
 //   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.
 //   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10
 // Side Effects:
-//   Sets `$tag = "mask"` for all children.
+//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
+//   `$idx` is set to the index number of each edge.
+//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+//   `$profile_type` is set to `"edge"`.
 // Example:
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_roundover(r=10, inset=2);
 module edge_profile(edges=EDGES_ALL, except=[], convexity=10) {
     req_children($children);
     assert($parent_geom != undef, "No object to attach to!");
     edges = _edges(edges, except=except);
     vecs = [
         for (i = [0:3], axis=[0:2])
         if (edges[axis][i]>0)
         EDGE_OFFSETS[axis][i]
     ];
-    for (vec = vecs) {
+    for ($idx = idx(vecs)) {
+        vec = vecs[$idx];
         vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);
-        assert(vcount == 2, "Not an edge vector!");
+        dummy=assert(vcount == 2, "Not an edge vector!");
         anch = _find_anchor(vec, $parent_geom);
         $attach_to = undef;
         $attach_anchor = anch;
         $attach_norot = true;
-        $tag = "mask";
+        $profile_type = "edge";
         psize = point3d($parent_size);
         length = [for (i=[0:2]) if(!vec[i]) psize[i]][0]+0.1;
         rotang =
             vec.z<0? [90,0,180+v_theta(vec)] :
             vec.z==0 && sign(vec.x)==sign(vec.y)? 135+v_theta(vec) :
             vec.z==0 && sign(vec.x)!=sign(vec.y)? [0,180,45+v_theta(vec)] :
             [-90,0,180+v_theta(vec)];
         translate(anch[1]) {
             rot(rotang) {
                 linear_extrude(height=length, center=true, convexity=convexity) {
-                    children();
+                   if ($tag=="") tag("remove") children();
+                   else children();
                 }
             }
         }
     }
 }
 
 // Module: corner_profile()
+// Synopsis: Rotationally extrudes a 2d edge profile into corner mask on the given corners of the parent.
+// Topics: Attachments, Masking
+// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_mask(), face_mask(), edge_mask()
 // Usage:
-//   corner_profile([corners], [except], [r=|d=], [convexity=]) CHILDREN;
-// Topics: Attachments
-// See Also: attachable(), position(), attach(), face_profile(), edge_profile()
+//   PARENT() corner_profile([corners], [except], [r=|d=], [convexity=]) CHILDREN;
 // Description:
 //   Takes a 2D mask shape, rotationally extrudes and converts it into a corner mask, and attaches it
-//   to the selected corners with the appropriate orientation.  Tags it as a "mask" to allow it to be
-//   `diff()`ed away, to give the corner a matching profile.
-//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.  
+//   to the selected corners with the appropriate orientation. If no tag is set
+//   then `corner_profile` sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
+//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.
 //   For a step-by-step explanation of attachments, see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   corners = Corners to mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: All corners.
 //   except = Corners to explicitly NOT mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: No corners.
 //   ---
 //   r = Radius of corner mask.
 //   d = Diameter of corner mask.
 //   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10
 // Side Effects:
-//   Sets `$tag = "mask"` for all children.
+//   Tags the children with "remove" (and hence sets $tag) if no tag is already set.
+//   `$idx` is set to the index number of each corner.
+//   `$attach_anchor` is set for each corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
+//   `$profile_type` is set to `"corner"`.
 // Example:
-//   diff("mask")
+//   diff()
 //   cuboid([50,60,70],rounding=10,edges="Z",anchor=CENTER) {
-//       corner_profile(BOT,r=10)
+//       corner_profile(TOP,r=10)
 //           mask2d_teardrop(r=10, angle=40);
 //   }
 module corner_profile(corners=CORNERS_ALL, except=[], r, d, convexity=10) {
     assert($parent_geom != undef, "No object to attach to!");
     r = get_radius(r=r, d=d, dflt=undef);
     assert(is_num(r));
     corners = _corners(corners, except=except);
     vecs = [for (i = [0:7]) if (corners[i]>0) CORNER_OFFSETS[i]];
-    for (vec = vecs) {
+    for ($idx = idx(vecs)) {
+        vec = vecs[$idx];
         vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);
-        assert(vcount == 3, "Not an edge vector!");
+        dummy=assert(vcount == 3, "Not an edge vector!");
         anch = _find_anchor(vec, $parent_geom);
         $attach_to = undef;
         $attach_anchor = anch;
         $attach_norot = true;
-        $tag = "mask";
+        $profile_type = "corner";
         rotang = vec.z<0?
             [  0,0,180+v_theta(vec)-45] :
             [180,0,-90+v_theta(vec)-45];
+        $tag = $tag=="" ? str($tag_prefix,"remove") : $tag;
         translate(anch[1]) {
             rot(rotang) {
                 render(convexity=convexity)
                 difference() {
                     translate(-0.1*[1,1,1]) cube(r+0.1, center=false);
                     right(r) back(r) zrot(180) {
                         rotate_extrude(angle=90, convexity=convexity) {
@@ -1491,17 +1707,19 @@
 }
 
 
 // Section: Making your objects attachable
 
 
 // Module: attachable()
-//
+// Synopsis: Manages the anchoring, spin, orientation, and attachments for an object.
+// Topics: Attachments
+// See Also: reorient()
 // Usage: Square/Trapezoid Geometry
-//   attachable(anchor, spin, two_d=true, size=, [size2=], [shift=], ...) {OBJECT; children();}
+//   attachable(anchor, spin, two_d=true, size=, [size2=], [shift=], [override=], ...) {OBJECT; children();}
 // Usage: Circle/Oval Geometry
 //   attachable(anchor, spin, two_d=true, r=|d=, ...) {OBJECT; children();}
 // Usage: 2D Path/Polygon Geometry
 //   attachable(anchor, spin, two_d=true, path=, [extent=], ...) {OBJECT; children();}
 // Usage: 2D Region Geometry
 //   attachable(anchor, spin, two_d=true, region=, [extent=], ...) {OBJECT; children();}
 // Usage: Cubical/Prismoidal Geometry
@@ -1517,17 +1735,14 @@
 // Usage: Extruded Region Geometry
 //   attachable(anchor, spin, region=, l=|h=, [extent=], ...) {OBJECT; children();}
 // Usage: VNF Geometry
 //   attachable(anchor, spin, [orient], vnf=, [extent=], ...) {OBJECT; children();}
 // Usage: Pre-Specified Geometry
 //   attachable(anchor, spin, [orient], geom=) {OBJECT; children();}
 //
-// Topics: Attachments
-// See Also: reorient()
-//
 // Description:
 //   Manages the anchoring, spin, orientation, and attachments for OBJECT, located in a 3D volume or 2D area.
 //   A managed 3D volume is assumed to be vertically (Z-axis) oriented, and centered.
 //   A managed 2D area is just assumed to be centered.  The shape to be managed is given
 //   as the first child to this module, and the second child should be given as `children()`.
 //   For example, to manage a conical shape:
 //   ```openscad
@@ -1573,14 +1788,15 @@
 //   region = The region to generate a shape from.
 //   extent = If true, calculate anchors by extents, rather than intersection, for VNFs and paths.  Default: true.
 //   cp = If given, specifies the centerpoint of the volume.  Default: `[0,0,0]`
 //   offset = If given, offsets the perimeter of the volume around the centerpoint.
 //   anchors = If given as a list of anchor points, allows named anchor points.
 //   two_d = If true, the attachable shape is 2D.  If false, 3D.  Default: false (3D)
 //   axis = The vector pointing along the axis of a geometry.  Default: UP
+//   override = Function that takes an anchor and returns a pair `[position,direction]` to use for that anchor to override the normal one.  You can also supply a lookup table that is a list of `[anchor, [position, direction]]` entries.  If the direction/position that is returned is undef then the default will be used.
 //   geom = If given, uses the pre-defined (via {{attach_geom()}} geometry.
 //
 // Side Effects:
 //   `$parent_anchor` is set to the parent object's `anchor` value.
 //   `$parent_spin` is set to the parent object's `spin` value.
 //   `$parent_orient` is set to the parent object's `orient` value.
 //   `$parent_geom` is set to the parent object's `geom` value.
@@ -1714,25 +1930,58 @@
 //       atype=="extents"? attach_geom(two_d=true, path=path, extent=true) :
 //       atype=="circle"? attach_geom(two_d=true, r=r) :
 //       assert(false, "Bad atype");
 //   attachable(anchor, spin, orient, geom=geom) {
 //       polygon(path);
 //       children();
 //   }
+//
+// Example: An object can be designed to attach as negative space using {{diff()}}, but if you want an object to include both positive and negative space then you need to call attachable() twice, because tags inside the attachable() call don't work as expected.  This example shows how you can call attachable twice to create an object with positive and negative space.  Note, however, that children in the negative space are differenced away: the highlighted little cube does not survive into the final model.
+//   module thing(anchor,spin,orient) {
+//      tag("remove") attachable(size=[15,15,15],anchor=anchor,spin=spin,orient=orient){
+//        cuboid([10,10,16]);
+//        union(){}   // dummy children
+//      }
+//      attachable(size=[15,15,15], anchor=anchor, spin=spin, orient=orient){
+//        cuboid([15,15,15]);
+//        children();
+//      }
+//   }
+//   diff()
+//     cube([19,10,19])
+//       attach([FRONT],overlap=-4)
+//         thing(anchor=TOP)
+//           # attach(TOP) cuboid(2,anchor=TOP);
+// Example: Here is an example where the "keep" tag allows children to appear in the negative space.  That tag is also needed for this module to produce the desired output.  As above, the tag must be applied outside the attachable() call.
+//   module thing(anchor = CENTER, spin = 0, orient = UP) {
+//      tag("remove") attachable(anchor, spin, orient, d1=0,d2=95,h=33) {
+//          cylinder(h = 33.1, d1 = 0, d2 = 95, anchor=CENTER);
+//          union(){}  // dummy children
+//      }
+//      tag("keep") attachable(anchor, spin, orient,d1=0,d2=95,h=33) {
+//            cylinder(h = 33, d = 10,anchor=CENTER);
+//            children();
+//        }
+//    }
+//    diff()
+//      cube(100)
+//        attach([FRONT,TOP],overlap=-4)
+//          thing(anchor=TOP)
+//            tube(ir=12,h=10);
 module attachable(
     anchor, spin, orient,
     size, size2, shift,
     r,r1,r2, d,d1,d2, l,h,
     vnf, path, region,
     extent=true,
     cp=[0,0,0],
     offset=[0,0,0],
     anchors=[],
     two_d=false,
-    axis=UP,
+    axis=UP,override,
     geom
 ) {
     dummy1 =
         assert($children==2, "attachable() expects exactly two children; the shape to manage, and the union of all attachment candidates.")
         assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str("Got: ",anchor))
         assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str("Got: ",spin))
         assert(is_undef(orient) || is_vector(orient,3), str("Got: ",orient));
@@ -1745,15 +1994,15 @@
     geom = is_def(geom)? geom :
         attach_geom(
             size=size, size2=size2, shift=shift,
             r=r, r1=r1, r2=r2, h=h,
             d=d, d1=d1, d2=d2, l=l,
             vnf=vnf, region=region, extent=extent,
             cp=cp, offset=offset, anchors=anchors,
-            two_d=two_d, axis=axis
+            two_d=two_d, axis=axis, override=override
         );
     m = _attach_transform(anchor,spin,orient,geom);
     multmatrix(m) {
         $parent_anchor = anchor;
         $parent_spin   = spin;
         $parent_orient = orient;
         $parent_geom   = geom;
@@ -1767,15 +2016,17 @@
             children(1);
         }
         else children(1);
     }
 }
 
 // Function: reorient()
-//
+// Synopsis: Calculates the transformation matrix needed to reorient an object.
+// Topics: Attachments
+// See Also: reorient(), attachable()
 // Usage: Square/Trapezoid Geometry
 //   mat = reorient(anchor, spin, [orient], two_d=true, size=, [size2=], [shift=], ...);
 //   pts = reorient(anchor, spin, [orient], two_d=true, size=, [size2=], [shift=], p=, ...);
 // Usage: Circle/Oval Geometry
 //   mat = reorient(anchor, spin, [orient], two_d=true, r=|d=, ...);
 //   pts = reorient(anchor, spin, [orient], two_d=true, r=|d=, p=, ...);
 // Usage: 2D Path/Polygon Geometry
@@ -1802,17 +2053,14 @@
 // Usage: Extruded Region Geometry
 //   mat = reorient(anchor, spin, [orient], region=, l=|h=, [extent=], ...);
 //   pts = reorient(anchor, spin, [orient], region=, l=|h=, [extent=], p=, ...);
 // Usage: VNF Geometry
 //   mat = reorient(anchor, spin, [orient], vnf, [extent], ...);
 //   pts = reorient(anchor, spin, [orient], vnf, [extent], p=, ...);
 //
-// Topics: Attachments
-// See Also: reorient(), attachable()
-//
 // Description:
 //   Given anchor, spin, orient, and general geometry info for a managed volume, this calculates
 //   the transformation matrix needed to be applied to the contents of that volume.  A managed 3D
 //   volume is assumed to be vertically (Z-axis) oriented, and centered.  A managed 2D area is just
 //   assumed to be centered.
 //   .
 //   If `p` is not given, then the transformation matrix will be returned.
@@ -1864,62 +2112,64 @@
     r,r1,r2, d,d1,d2, l,h,
     vnf, path, region,
     extent=true,
     offset=[0,0,0],
     cp=[0,0,0],
     anchors=[],
     two_d=false,
-    axis=UP,
+    axis=UP, override, 
     geom,
     p=undef
-) = 
+) =
     assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str("Got: ",anchor))
     assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str("Got: ",spin))
     assert(is_undef(orient) || is_vector(orient,3), str("Got: ",orient))
     let(
         anchor = default(anchor, CENTER),
         spin =   default(spin,   0),
         orient = default(orient, UP),
         region = !is_undef(region)? region :
             !is_undef(path)? [path] :
-            undef
-    )
-    (anchor==CENTER && spin==0 && orient==UP && p!=undef)? p :
-    let(
+            undef,
         geom = is_def(geom)? geom :
             attach_geom(
                 size=size, size2=size2, shift=shift,
                 r=r, r1=r1, r2=r2, h=h,
                 d=d, d1=d1, d2=d2, l=l,
                 vnf=vnf, region=region, extent=extent,
                 cp=cp, offset=offset, anchors=anchors,
-                two_d=two_d, axis=axis
+                two_d=two_d, axis=axis, override=override
             ),
         $attach_to = undef
     ) _attach_transform(anchor,spin,orient,geom,p);
 
 
 // Function: named_anchor()
-// Usage:
-//   a = named_anchor(name, pos, [orient], [spin]);
+// Synopsis: Creates an anchro data structure.
 // Topics: Attachments
 // See Also: reorient(), attachable()
+// Usage:
+//   a = named_anchor(name, pos, [orient], [spin]);
 // Description:
 //   Creates an anchor data structure.  For a step-by-step explanation of attachments,
 //   see the [[Attachments Tutorial|Tutorial-Attachments]].
 // Arguments:
 //   name = The string name of the anchor.  Lowercase.  Words separated by single dashes.  No spaces.
 //   pos = The [X,Y,Z] position of the anchor.
 //   orient = A vector pointing in the direction parts should project from the anchor position.  Default: UP
 //   spin = If needed, the angle to rotate the part around the direction vector.  Default: 0
 function named_anchor(name, pos, orient=UP, spin=0) = [name, pos, orient, spin];
 
 
 // Function: attach_geom()
-//
+// Synopsis: Returns the internal geometry description of an attachable object.
+// Topics: Attachments
+// See Also: reorient(), attachable()
+// Usage: Null/Point Geometry
+//   geom = attach_geom(...);
 // Usage: Square/Trapezoid Geometry
 //   geom = attach_geom(two_d=true, size=, [size2=], [shift=], ...);
 // Usage: Circle/Oval Geometry
 //   geom = attach_geom(two_d=true, r=|d=, ...);
 // Usage: 2D Path/Polygon/Region Geometry
 //   geom = attach_geom(two_d=true, region=, [extent=], ...);
 // Usage: Cubical/Prismoidal Geometry
@@ -1931,17 +2181,14 @@
 // Usage: Spheroid/Ovoid Geometry
 //   geom = attach_geom(r=|d=, ...);
 // Usage: Extruded 2D Path/Polygon/Region Geometry
 //   geom = attach_geom(region=, l=|h=, [extent=], [shift=], [scale=], [twist=], ...);
 // Usage: VNF Geometry
 //   geom = attach_geom(vnf=, [extent=], ...);
 //
-// Topics: Attachments
-// See Also: reorient(), attachable()
-//
 // Description:
 //   Given arguments that describe the geometry of an attachable object, returns the internal geometry description.
 //   This will probably not not ever need to be called by the end user.
 //
 // Arguments:
 //   ---
 //   size = If given as a 3D vector, contains the XY size of the bottom of the cuboidal/prismoidal volume, and the Z height.  If given as a 2D vector, contains the front X width of the rectangular/trapezoidal shape, and the Y length.
@@ -1960,14 +2207,18 @@
 //   region = The region to generate a shape from.
 //   extent = If true, calculate anchors by extents, rather than intersection.  Default: true.
 //   cp = If given, specifies the centerpoint of the volume.  Default: `[0,0,0]`
 //   offset = If given, offsets the perimeter of the volume around the centerpoint.
 //   anchors = If given as a list of anchor points, allows named anchor points.
 //   two_d = If true, the attachable shape is 2D.  If false, 3D.  Default: false (3D)
 //   axis = The vector pointing along the axis of a geometry.  Default: UP
+//   override = Function that takes an anchor and returns a pair `[position,direction]` to use for that anchor to override the normal one.  You can also supply a lookup table that is a list of `[anchor, [position, direction]]` entries.  If the direction/position that is returned is undef then the default will be used.
+//
+// Example(NORENDER): Null/Point Shape
+//   geom = attach_geom();
 //
 // Example(NORENDER): Cubical Shape
 //   geom = attach_geom(size=size);
 //
 // Example(NORENDER): Prismoidal Shape
 //   geom = attach_geom(
 //       size=point3d(botsize,h),
@@ -2004,15 +2255,15 @@
 // Example(NORENDER): Arbitrary VNF Shape, Anchored by Intersection
 //   geom = attach_geom(vnf=vnf, extent=false);
 //
 // Example(NORENDER): 2D Rectangular Shape
 //   geom = attach_geom(two_d=true, size=size);
 //
 // Example(NORENDER): 2D Trapezoidal Shape
-//   geom = attach_geom(two_d=true, size=[x1,y], size2=x2, shift=shift);
+//   geom = attach_geom(two_d=true, size=[x1,y], size2=x2, shift=shift, override=override);
 //
 // Example(NORENDER): 2D Circular Shape
 //   geom = attach_geom(two_d=true, r=r);
 //
 // Example(NORENDER): 2D Oval Shape
 //   geom = attach_geom(two_d=true, r=[r_x, r_y]);
 //
@@ -2024,42 +2275,52 @@
 //
 // Example(NORENDER): Extruded Region, Anchored by Extents
 //   geom = attach_geom(region=region, l=height);
 //
 // Example(NORENDER): Extruded Region, Anchored by Intersection
 //   geom = attach_geom(region=region, l=length, extent=false);
 //
+
+function _local_struct_val(struct, key)=
+    assert(is_def(key),"key is missing")
+    let(ind = search([key],struct)[0])
+    ind == [] ? undef : struct[ind][1];
+
+
 function attach_geom(
     size, size2,
     shift, scale, twist,
     r,r1,r2, d,d1,d2, l,h,
     vnf, region,
     extent=true,
     cp=[0,0,0],
     offset=[0,0,0],
     anchors=[],
     two_d=false,
-    axis=UP
+    axis=UP, override
 ) =
     assert(is_bool(extent))
     assert(is_vector(cp) || is_string(cp))
     assert(is_vector(offset))
     assert(is_list(anchors))
     assert(is_bool(two_d))
     assert(is_vector(axis))
     !is_undef(size)? (
         two_d? (
             let(
                 size2 = default(size2, size.x),
-                shift = default(shift, 0)
+                shift = default(shift, 0),
+                over_f = is_undef(override) ? function(anchor) [undef,undef]
+                       : is_func(override) ? override
+                       : function(anchor) _local_struct_val(override,anchor)
             )
             assert(is_vector(size,2))
             assert(is_num(size2))
             assert(is_num(shift))
-            ["trapezoid", point2d(size), size2, shift, cp, offset, anchors]
+            ["trapezoid", point2d(size), size2, shift, over_f, cp, offset, anchors]
         ) : (
             let(
                 size2 = default(size2, point2d(size)),
                 shift = default(shift, [0,0])
             )
             assert(is_vector(size,3))
             assert(is_vector(size2,2))
@@ -2085,16 +2346,16 @@
                 scale = is_num(scale)? [scale,scale] : default(scale, [1,1]),
                 twist = default(twist, 0)
             )
             assert(is_vector(shift,2))
             assert(is_vector(scale,2))
             assert(is_num(twist))
             extent==true
-              ? ["xrgn_extent", region, l, twist, scale, shift, cp, offset, anchors]
-              : ["xrgn_isect",  region, l, twist, scale, shift, cp, offset, anchors]
+              ? ["extrusion_extent", region, l, twist, scale, shift, cp, offset, anchors]
+              : ["extrusion_isect",  region, l, twist, scale, shift, cp, offset, anchors]
     ) :
     let(
         r1 = get_radius(r1=r1,d1=d1,r=r,d=d,dflt=undef)
     )
     !is_undef(r1)? (
         let( l = default(l, h) )
         !is_undef(l)? (
@@ -2113,48 +2374,49 @@
                 ["ellipse", r1, cp, offset, anchors]
             ) : (
                 assert(is_num(r1) || is_vector(r1,3))
                 ["spheroid", r1, cp, offset, anchors]
             )
         )
     ) :
-    assert(false, "Unrecognizable geometry description.");
+    ["point", cp, offset, anchors];
 
 
 
 
 
 
 //////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //
 // Attachment internal functions
 
 
 /// Internal Function: _attach_geom_2d()
-// Usage:
-//   bool = _attach_geom_2d(geom);
 /// Topics: Attachments
 /// See Also: reorient(), attachable()
-// Description:
-//   Returns true if the given attachment geometry description is for a 2D shape.
+/// Usage:
+///   bool = _attach_geom_2d(geom);
+/// Description:
+///   Returns true if the given attachment geometry description is for a 2D shape.
 function _attach_geom_2d(geom) =
     let( type = geom[0] )
     type == "trapezoid" || type == "ellipse" ||
     type == "rgn_isect" || type == "rgn_extent";
 
 
 /// Internal Function: _attach_geom_size()
-// Usage:
-//   bounds = _attach_geom_size(geom);
+/// Usage:
+///   bounds = _attach_geom_size(geom);
 /// Topics: Attachments
 /// See Also: reorient(), attachable()
-// Description:
-//   Returns the `[X,Y,Z]` bounding size for the given attachment geometry description.
+/// Description:
+///   Returns the `[X,Y,Z]` bounding size for the given attachment geometry description.
 function _attach_geom_size(geom) =
     let( type = geom[0] )
+    type == "point"? [0,0,0] :
     type == "prismoid"? ( //size, size2, shift, axis
         let(
             size=geom[1], size2=geom[2], shift=point2d(geom[3]),
             maxx = max(size.x,size2.x),
             maxy = max(size.y,size2.y),
             z = size.z
         ) [maxx, maxy, z]
@@ -2180,15 +2442,15 @@
         let(
             vnf = geom[1]
         ) vnf==EMPTY_VNF? [0,0,0] :
         let(
             mm = pointlist_bounds(geom[1][0]),
             delt = mm[1]-mm[0]
         ) delt
-    ) : type == "xrgn_isect" || type == "xrgn_extent"? ( //path, l
+    ) : type == "extrusion_isect" || type == "extrusion_extent"? ( //path, l
         let(
             mm = pointlist_bounds(flatten(geom[1])),
             delt = mm[1]-mm[0]
         ) [delt.x, delt.y, geom[2]]
     ) : type == "trapezoid"? ( //size, size2
         let(
             size=geom[1], size2=geom[2], shift=geom[3],
@@ -2203,29 +2465,29 @@
             delt = mm[1]-mm[0]
         ) [delt.x, delt.y]
     ) :
     assert(false, "Unknown attachment geometry type.");
 
 
 /// Internal Function: _attach_transform()
-// Usage: To Get a Transformation Matrix
-//   mat = _attach_transform(anchor, spin, orient, geom);
-// Usage: To Transform Points, Paths, Patches, or VNFs
-//   new_p = _attach_transform(anchor, spin, orient, geom, p);
+/// Usage: To Get a Transformation Matrix
+///   mat = _attach_transform(anchor, spin, orient, geom);
+/// Usage: To Transform Points, Paths, Patches, or VNFs
+///   new_p = _attach_transform(anchor, spin, orient, geom, p);
 /// Topics: Attachments
 /// See Also: reorient(), attachable()
-// Description:
-//   Returns the affine3d transformation matrix needed to `anchor`, `spin`, and `orient`
-//   the given geometry `geom` shape into position.
-// Arguments:
-//   anchor = Anchor point to translate to the origin `[0,0,0]`.  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
-//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-//   geom = The geometry description of the shape.
-//   p = If given as a VNF, path, or point, applies the affine3d transformation matrix to it and returns the result.
+/// Description:
+///   Returns the affine3d transformation matrix needed to `anchor`, `spin`, and `orient`
+///   the given geometry `geom` shape into position.
+/// Arguments:
+///   anchor = Anchor point to translate to the origin `[0,0,0]`.  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+///   geom = The geometry description of the shape.
+///   p = If given as a VNF, path, or point, applies the affine3d transformation matrix to it and returns the result.
 function _attach_transform(anchor, spin, orient, geom, p) =
     assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str("Got: ",anchor))
     assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str("Got: ",spin))
     assert(is_undef(orient) || is_vector(orient,3), str("Got: ",orient))
     let(
         anchor = default(anchor, CENTER),
         spin   = default(spin,   0),
@@ -2281,63 +2543,80 @@
         )
     ) is_undef(p)? m :
     is_vnf(p)? [(p==EMPTY_VNF? p : apply(m, p[0])), p[1]] :
     apply(m, p);
 
 
 function _get_cp(geom) =
-    
     let(cp=select(geom,-3))
     is_vector(cp) ? cp
   : let(
         type = in_list(geom[0],["vnf_extent","vnf_isect"]) ? "vnf"
              : in_list(geom[0],["rgn_extent","rgn_isect"]) ? "path"
-             : in_list(geom[0],["xrgn_extent","xrgn_isect"]) ? "xpath"
+             : in_list(geom[0],["extrusion_extent","extrusion_isect"]) ? "xpath"
              : "other"
     )
     assert(type!="other", "Invalid cp value")
     cp=="centroid" ? (
        type=="vnf" && (len(geom[1][0])==0 || len(geom[1][1])==0) ? [0,0,0] :
        [each centroid(geom[1]), if (type=="xpath") 0]
     )
   : let(points = type=="vnf"?geom[1][0]:flatten(force_region(geom[1])))
-    cp=="mean" ? [each mean(points), if (type=="xpath") geom[2]/2]
-  : cp=="box" ?[each  mean(pointlist_bounds(points)), if (type=="xpath") geom[2]/2]
+    cp=="mean" ? [each mean(points), if (type=="xpath") 0]
+  : cp=="box" ?[each  mean(pointlist_bounds(points)), if (type=="xpath") 0]
+  : assert(false,"Invalid cp specification");
+
+
+function _get_cp(geom) =
+    let(cp=select(geom,-3))
+    is_vector(cp) ? cp
+  : let(
+        is_vnf = in_list(geom[0],["vnf_extent","vnf_isect"])
+    )
+    cp == "centroid" ? (
+       is_vnf && len(geom[1][1])==0
+          ? [0,0,0]
+          : centroid(geom[1])
+    )
+  : let(points = is_vnf?geom[1][0]:flatten(force_region(geom[1])))
+    cp=="mean" ? mean(points)
+  : cp=="box" ? mean(pointlist_bounds(points))
   : assert(false,"Invalid cp specification");
 
 
+
 function _force_anchor_2d(anchor) =
   assert(anchor.y==0 || anchor.z==0, "Anchor for a 2D shape cannot be fully 3D.  It must have either Y or Z component equal to zero.")
   anchor.y==0 ? [anchor.x,anchor.z] : point2d(anchor);
 
 
 /// Internal Function: _find_anchor()
-// Usage:
-//   anchorinfo = _find_anchor(anchor, geom);
+/// Usage:
+///   anchorinfo = _find_anchor(anchor, geom);
 /// Topics: Attachments
 /// See Also: reorient(), attachable()
-// Description:
-//   Calculates the anchor data for the given `anchor` vector or name, in the given attachment
-//   geometry.  Returns `[ANCHOR, POS, VEC, ANG]` where `ANCHOR` is the requested anchorname
-//   or vector, `POS` is the anchor position, `VEC` is the direction vector of the anchor, and
-//   `ANG` is the angle to align with around the rotation axis of th anchor direction vector.
-// Arguments:
-//   anchor = Vector or named anchor string.
-//   geom = The geometry description of the shape.
+/// Description:
+///   Calculates the anchor data for the given `anchor` vector or name, in the given attachment
+///   geometry.  Returns `[ANCHOR, POS, VEC, ANG]` where `ANCHOR` is the requested anchorname
+///   or vector, `POS` is the anchor position, `VEC` is the direction vector of the anchor, and
+///   `ANG` is the angle to align with around the rotation axis of th anchor direction vector.
+/// Arguments:
+///   anchor = Vector or named anchor string.
+///   geom = The geometry description of the shape.
 function _find_anchor(anchor, geom) =
-    is_string(anchor)? (  
+    is_string(anchor)? (
           anchor=="origin"? [anchor, CENTER, UP, 0]
         : let(
               anchors = last(geom),
               found = search([anchor], anchors, num_returns_per_match=1)[0]
           )
           assert(found!=[], str("Unknown anchor: ",anchor))
           anchors[found]
     ) :
-    let( 
+    let(
         cp = _get_cp(geom),
         offset_raw = select(geom,-2),
         offset = [for (i=[0:2]) anchor[i]==0? 0 : offset_raw[i]],  // prevents bad centering.
         type = geom[0]
     )
     assert(is_vector(anchor),str("Invalid anchor: anchor=",anchor))
     let(
@@ -2357,20 +2636,33 @@
             offset = rot(from=axis, to=UP, p=offset),
             h = size.z,
             u = (anch.z + 1) / 2,  // u is one of 0, 0.5, or 1
             axy = point2d(anch),
             bot = point3d(v_mul(point2d(size )/2, axy), -h/2),
             top = point3d(v_mul(point2d(size2)/2, axy) + shift, h/2),
             pos = point3d(cp) + lerp(bot,top,u) + offset,
-            vecs = [
-                if (anch.x!=0) unit(rot(from=UP, to=[(top-bot).x,0,h], p=[axy.x,0,0]), UP),
-                if (anch.y!=0) unit(rot(from=UP, to=[0,(top-bot).y,h], p=[0,axy.y,0]), UP),
-                if (anch.z!=0) anch==CENTER? UP : unit([0,0,anch.z],UP)
-            ],
-            vec = anchor==CENTER? UP : rot(from=UP, to=axis, p=unit(sum(vecs) / len(vecs))),
+            vecs = anchor==CENTER? [UP]
+              : [
+                    if (anch.x!=0) unit(rot(from=UP, to=[(top-bot).x,0,h], p=[axy.x,0,0]), UP),
+                    if (anch.y!=0) unit(rot(from=UP, to=[0,(top-bot).y,h], p=[0,axy.y,0]), UP),
+                    if (anch.z!=0) unit([0,0,anch.z],UP)
+                ],
+            vec2 = anchor==CENTER? UP
+              : len(vecs)==1? unit(vecs[0],UP)
+              : len(vecs)==2? vector_bisect(vecs[0],vecs[1])
+              : let(
+                    v1 = vector_bisect(vecs[0],vecs[2]),
+                    v2 = vector_bisect(vecs[1],vecs[2]),
+                    p1 = plane_from_normal(yrot(90,p=v1)),
+                    p2 = plane_from_normal(xrot(-90,p=v2)),
+                    line = plane_intersection(p1,p2),
+                    v3 = unit(line[1]-line[0],UP) * anch.z
+                )
+                unit(v3,UP),
+            vec = rot(from=UP, to=axis, p=vec2),
             pos2 = rot(from=UP, to=axis, p=pos)
         ) [anchor, pos2, vec, oang]
     ) : type == "conoid"? ( //r1, r2, l, shift
         assert(anchor.z == sign(anchor.z), "The Z component of an anchor for a cylinder/cone must be -1, 0, or 1")
         let(
             rr1=geom[1], rr2=geom[2], l=geom[3],
             shift=point2d(geom[4]), axis=point3d(geom[5]),
@@ -2379,23 +2671,29 @@
             anch = rot(from=axis, to=UP, p=anchor),
             offset = rot(from=axis, to=UP, p=offset),
             u = (anch.z+1)/2,
             axy = unit(point2d(anch),[0,0]),
             bot = point3d(v_mul(r1,axy), -l/2),
             top = point3d(v_mul(r2,axy)+shift, l/2),
             pos = point3d(cp) + lerp(bot,top,u) + offset,
-            sidevec = rot(from=UP, to=top-bot, p=point3d(axy)),
+            sidevec = rot(from=UP, to=top==bot?UP:top-bot, p=point3d(axy)),
             vvec = anch==CENTER? UP : unit([0,0,anch.z],UP),
             vec = anch==CENTER? CENTER :
                 approx(axy,[0,0])? unit(anch,UP) :
                 approx(anch.z,0)? sidevec :
                 unit((sidevec+vvec)/2,UP),
             pos2 = rot(from=UP, to=axis, p=pos),
             vec2 = anch==CENTER? UP : rot(from=UP, to=axis, p=vec)
         ) [anchor, pos2, vec2, oang]
+    ) : type == "point"? (
+        let(
+            anchor = unit(point3d(anchor),CENTER),
+            pos = point3d(cp) + point3d(offset),
+            vec = unit(anchor,UP)
+        ) [anchor, pos, vec, oang]
     ) : type == "spheroid"? ( //r
         let(
             rr = geom[1],
             r = is_num(rr)? [rr,rr,rr] : point3d(rr),
             anchor = unit(point3d(anchor),CENTER),
             pos = point3d(cp) + v_mul(r,anchor) + point3d(offset),
             vec = unit(v_mul(r,anchor),UP)
@@ -2458,36 +2756,30 @@
             rpts = apply(rot(from=anchor, to=RIGHT) * move(point3d(-cp)), vnf[0]),
             maxx = max(column(rpts,0)),
             idxs = [for (i = idx(rpts)) if (approx(rpts[i].x, maxx)) i],
             avep = sum(select(rpts,idxs))/len(idxs),
             mpt = approx(point2d(anchor),[0,0])? [maxx,0,0] : avep,
             pos = point3d(cp) + rot(from=RIGHT, to=anchor, p=mpt)
         ) [anchor, pos, anchor, oang]
-    ) : type == "trapezoid"? ( //size, size2, shift
+    ) : type == "trapezoid"? ( //size, size2, shift, override
         let(all_comps_good = [for (c=anchor) if (c!=sign(c)) 1]==[])
         assert(all_comps_good, "All components of an anchor for a rectangle/trapezoid must be -1, 0, or 1")
         let(
             anchor=_force_anchor_2d(anchor),
             size=geom[1], size2=geom[2], shift=geom[3],
             u = (anchor.y+1)/2,  // 0<=u<=1
             frpt = [size.x/2*anchor.x, -size.y/2],
             bkpt = [size2/2*anchor.x+shift,  size.y/2],
-            pos = point2d(cp) + lerp(frpt, bkpt, u) + point2d(offset),
+            override = geom[4](anchor),
+            pos = default(override[0],point2d(cp) + lerp(frpt, bkpt, u) + point2d(offset)),
             svec = point3d(line_normal(bkpt,frpt)*anchor.x),
-            vec = anchor.y < 0? (
-                    anchor.x == 0? FWD :
-                    size.x == 0? unit(-[shift,size.y], FWD) :
-                    unit((point3d(svec) + FWD) / 2, FWD)
-                ) :
-                anchor.y == 0? ( anchor.x == 0? BACK : svec ) :
-                (  // anchor.y > 0
-                    anchor.x == 0? BACK :
-                    size2 == 0? unit([shift,size.y], BACK) :
-                    unit((point3d(svec) + BACK) / 2, BACK)
-                )
+            vec = is_def(override[1]) ? override[1]
+                : anchor.y == 0? ( anchor.x == 0? BACK : svec )
+                : anchor.x == 0? [0,anchor.y,0]
+                : unit((svec + [0,anchor.y,0]) / 2, [0,anchor.y,0])
         ) [anchor, pos, vec, 0]
     ) : type == "ellipse"? ( //r
         let(
             anchor = unit(_force_anchor_2d(anchor),[0,0]),
             r = force_list(geom[1],2),
             pos = approx(anchor.x,0) ? [0,sign(anchor.y)*r.y]
                       : let(
@@ -2527,67 +2819,66 @@
     ) : type == "rgn_extent"? ( //region
         let( anchor = _force_anchor_2d(anchor) )
         approx(anchor,[0,0])? [anchor, [0,0,0], BACK, 0] :
         let(
             rgn = force_region(geom[1]),
             rpts = rot(from=anchor, to=RIGHT, p=flatten(rgn)),
             maxx = max(column(rpts,0)),
-            ys = [for (pt=rpts) if (approx(pt.x, maxx)) pt.y],            
+            ys = [for (pt=rpts) if (approx(pt.x, maxx)) pt.y],
             midy = (min(ys)+max(ys))/2,
             pos = rot(from=RIGHT, to=anchor, p=[maxx,midy])
         ) [anchor, pos, unit(anchor,BACK), 0]
-    ) : type=="xrgn_extent" || type=="xrgn_isect" ? (  // extruded region
+    ) : type=="extrusion_extent" || type=="extrusion_isect" ? (  // extruded region
         assert(in_list(anchor.z,[-1,0,1]), "The Z component of an anchor for an extruded 2D shape must be -1, 0, or 1.")
         let(
             anchor_xy = point2d(anchor),
             rgn = geom[1],
             L = geom[2],
             twist = geom[3],
             scale = geom[4],
             shift = geom[5],
             u = (anchor.z + 1) / 2,
             shmat = move(lerp([0,0], shift, u)),
             scmat = scale(lerp([1,1], scale, u)),
             twmat = zrot(lerp(0, -twist, u)),
             mat = shmat * scmat * twmat
         )
-        approx(anchor_xy,[0,0]) ? [anchor, apply(mat, up(anchor.z*L/2,cp)), unit(anchor, UP), oang] :
+        approx(anchor_xy,[0,0]) ? [anchor, apply(mat, point3d(cp,anchor.z*L/2)), unit(anchor, UP), oang] :
         let(
             newrgn = apply(mat, rgn),
-            newgeom = attach_geom(two_d=true, region=newrgn, extent=type=="xrgn_extent", cp=cp),
+            newgeom = attach_geom(two_d=true, region=newrgn, extent=type=="extrusion_extent", cp=cp),
             result2d = _find_anchor(anchor_xy, newgeom),
-            pos = point3d(result2d[1], cp.z+anchor.z*L/2),
+            pos = point3d(result2d[1], anchor.z*L/2),
             vec = unit(point3d(result2d[2], anchor.z),UP),
             oang = atan2(vec.y,vec.x) + 90
         )
         [anchor, pos, vec, oang]
     ) :
     assert(false, "Unknown attachment geometry type.");
 
 
 /// Internal Function: _is_shown()
-// Usage:
-//   bool = _is_shown();
+/// Usage:
+///   bool = _is_shown();
 /// Topics: Attachments
 /// See Also: reorient(), attachable()
-// Description:
-//   Returns true if objects should currently be shown based on the tag settings.  
+/// Description:
+///   Returns true if objects should currently be shown based on the tag settings.
 function _is_shown() =
     assert(is_list($tags_shown) || $tags_shown=="ALL")
     assert(is_list($tags_hidden))
     let(
         dummy=is_undef($tags) ? 0 : echo("Use tag() instead of $tags for specifying an object's tag."),
-        $tags = default($tag,$tags)
+        $tag = default($tag,$tags)
     )
     assert(is_string($tag), str("Tag value (",$tag,") is not a string"))
     assert(undef==str_find($tag," "),str("Tag string \"",$tag,"\" contains a space, which is not allowed"))
     let(
-        fulltag = $tag,
-        shown  = $tags_shown=="ALL" || in_list(fulltag,$tags_shown),
-        hidden = in_list(fulltag, $tags_hidden)
+        shown  = $tags_shown=="ALL" || in_list($tag,$tags_shown),
+        hidden = in_list($tag, $tags_hidden)
     )
     shown && !hidden;
 
 
 // Section: Visualizing Anchors
 
 /// Internal Function: _standard_anchors()
@@ -2608,27 +2899,30 @@
         xv = [LEFT, CENTER, RIGHT]
     ) xv+yv+zv
 ];
 
 
 
 // Module: show_anchors()
+// Synopsis: Shows anchors for the parent object.
+// Topics: Attachments
+// See Also: expose_anchors(), anchor_arrow(), anchor_arrow2d(), frame_ref()
 // Usage:
-//   ... show_anchors([s], [std=], [custom=]);
+//   PARENT() show_anchors([s], [std=], [custom=]);
 // Description:
 //   Show all standard anchors for the parent object.
 // Arguments:
 //   s = Length of anchor arrows.
 //   ---
-//   std = If true (default), show standard anchors.
-//   custom = If true (default), show custom anchors.
+//   std = If true show standard anchors.  Default: true
+//   custom = If true show named anchors.  Default: true
 // Example(FlatSpin,VPD=333):
 //   cube(50, center=true) show_anchors();
 module show_anchors(s=10, std=true, custom=true) {
-    check = assert($parent_geom != undef) 1;
+    check = assert($parent_geom != undef);
     two_d = _attach_geom_2d($parent_geom);
     if (std) {
         for (anchor=_standard_anchors(two_d=two_d)) {
             if(two_d) {
                 attach(anchor) anchor_arrow2d(s);
             } else {
                 attach(anchor) anchor_arrow(s);
@@ -2667,45 +2961,56 @@
             }
         }
     }
     children();
 }
 
 
-
 // Module: anchor_arrow()
+// Synopsis: Shows a 3d anchor orientation arrow.
+// Topics: Attachments
+// See Also: anchor_arrow2d(), show_anchors(), expose_anchors(), frame_ref()
 // Usage:
-//   anchor_arrow([s], [color], [flag]);
+//   anchor_arrow([s], [color], [flag], [anchor=], [orient=], [spin=]) [ATTACHMENTS];
 // Description:
 //   Show an anchor orientation arrow.  By default, tagged with the name "anchor-arrow".
 // Arguments:
 //   s = Length of the arrows.  Default: `10`
 //   color = Color of the arrow.  Default: `[0.333, 0.333, 1]`
 //   flag = If true, draw the orientation flag on the arrowhead.  Default: true
+//   ---
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   anchor_arrow(s=20);
-module anchor_arrow(s=10, color=[0.333,0.333,1], flag=true, $tag="anchor-arrow") {
-    $fn=12;
-    recolor("gray") spheroid(d=s/6) {
-        attach(CENTER,BOT) recolor(color) cyl(h=s*2/3, d=s/15) {
-            attach(TOP,BOT) cyl(h=s/3, d1=s/5, d2=0) {
-                if(flag) {
-                    position(BOT)
-                        recolor([1,0.5,0.5])
-                            cuboid([s/100, s/6, s/4], anchor=FRONT+BOT);
+module anchor_arrow(s=10, color=[0.333,0.333,1], flag=true, $tag="anchor-arrow", $fn=12, anchor=BOT, spin=0, orient=UP) {
+    attachable(anchor,spin,orient, r=s/6, l=s) {
+        down(s/2)
+        recolor("gray") spheroid(d=s/6) {
+            attach(CENTER,BOT) recolor(color) cyl(h=s*2/3, d=s/15) {
+                attach(TOP,BOT) cyl(h=s/3, d1=s/5, d2=0) {
+                    if(flag) {
+                        position(BOT)
+                            recolor([1,0.5,0.5])
+                                cuboid([s/100, s/6, s/4], anchor=FRONT+BOT);
+                    }
                 }
-                children();
             }
         }
+        children();
     }
 }
 
 
 
 // Module: anchor_arrow2d()
+// Synopsis: Shows a 2d anchor orientation arrow.
+// Topics: Attachments
+// See Also: anchor_arrow(), show_anchors(), expose_anchors(), frame_ref()
 // Usage:
 //   anchor_arrow2d([s], [color], [flag]);
 // Description:
 //   Show an anchor orientation arrow.
 // Arguments:
 //   s = Length of the arrows.
 //   color = Color of the arrow.
@@ -2714,37 +3019,43 @@
 module anchor_arrow2d(s=15, color=[0.333,0.333,1], $tag="anchor-arrow") {
     color(color) stroke([[0,0],[0,s]], width=s/10, endcap1="butt", endcap2="arrow2");
 }
 
 
 
 // Module: expose_anchors()
+// Synopsis: Used to show a transparent object with solid color anchor arrows.
+// Topics: Attachments
+// See Also: anchor_arrow2d(), show_anchors(), show_anchors(), frame_ref()
 // Usage:
 //   expose_anchors(opacity) {child1() show_anchors(); child2() show_anchors(); ...}
 // Description:
 //   Used in combination with show_anchors() to display an object in transparent gray with its anchors in solid color.
-//   Children will appear transparent and any anchor arrows drawn with will appear in solid color.  
+//   Children will appear transparent and any anchor arrows drawn with will appear in solid color.
 // Arguments:
 //   opacity = The opacity of the children.  0.0 is invisible, 1.0 is opaque.  Default: 0.2
 // Example(FlatSpin,VPD=333):
 //   expose_anchors() cube(50, center=true) show_anchors();
 module expose_anchors(opacity=0.2) {
     show_only("anchor-arrow")
         children();
     hide("anchor-arrow")
         color(is_undef($color) || $color=="default" ? [0,0,0] :
-              is_string($color) ? $color 
+              is_string($color) ? $color
                                 : point3d($color),
               opacity)
             children();
 }
 
 
 
 // Module: frame_ref()
+// Synopsis: Shows axis orientation arrows.
+// Topics: Attachments
+// See Also: anchor_arrow(), anchor_arrow2d(), show_anchors(), expose_anchors()
 // Usage:
 //   frame_ref(s, opacity);
 // Description:
 //   Displays X,Y,Z axis arrows in red, green, and blue respectively.
 // Arguments:
 //   s = Length of the arrows.
 //   opacity = The opacity of the arrows.  0.0 is invisible, 1.0 is opaque.  Default: 1.0
@@ -2931,15 +3242,15 @@
 /// Topics: Edges
 /// Usage:
 ///   edgs = _edges(v);
 ///   edgs = _edges(v, except);
 ///
 /// Description:
 ///   Takes a list of edge set descriptors, and returns a normalized edges array
-///   that represents all those given edges.  
+///   that represents all those given edges.
 /// Arguments:
 ///   v = The edge set to include.
 ///   except = The edge set to specifically exclude, even if they are in `v`.
 ///
 /// See Also:  EDGES_NONE, EDGES_ALL
 ///
 function _edges(v, except=[]) =
@@ -3164,15 +3475,14 @@
 
 module _show_cube_faces(faces, size=20, toplabel,botlabel) {
    color("red")
      for(f=faces){
           move(f*size/2) rot(from=UP,to=f)
              cuboid([size,size,.1]);
      }
-    
    vpr = [55,0,25];
    color("black"){
    if (is_def(toplabel))
      for(h=idx(toplabel)) up(21+6*h)rot(vpr) text3d(select(toplabel,-h-1),size=3.3,h=.1,orient=UP,anchor=FRONT);
    if (is_def(botlabel))
      for(h=idx(botlabel)) down(26+6*h)rot(vpr) text3d(botlabel[h],size=3.3,h=.1,orient=UP,anchor=FRONT);
    }
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/beziers.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/beziers.scad`

 * *Files 4% similar despite different names*

```diff
@@ -24,19 +24,21 @@
 //   Bezier Surface = A surface defined by a list of one or more bezier patches.
 //   Spline Steps = The number of straight-line segments used to approximate a Bezier curve.  The more spline steps, the better the approximation to the curve, but the slower it will be to generate.  This plays a role analogous to `$fn` for circles.  Usually defaults to 16.
 
 
 // Section: Bezier Curves
 
 // Function: bezier_points()
+// Synopsis: Computes one or more specified points along a bezier curve.
+// Topics: Bezier Curves
+// See Also: bezier_curve(), bezier_curvature(), bezier_tangent(), bezier_derivative(), bezier_points()
 // Usage:
 //   pt = bezier_points(bezier, u);
 //   ptlist = bezier_points(bezier, RANGE);
 //   ptlist = bezier_points(bezier, LIST);
-// Topics: Bezier Curves
 // Description:
 //   Computes points on a bezier curve with control points specified by `bezier` at parameter values
 //   specified by `u`, which can be a scalar or a list.  The value `u=0` gives the first endpoint; `u=1` gives the final endpoint,
 //   and intermediate values of `u` fill in the curve in a non-uniform fashion.  This function uses an optimized method which
 //   is best when `u` is a long list and the bezier degree is 10 or less.  The degree of the bezier
 //   curve is `len(bezier)-1`.
 // Arguments:
@@ -172,18 +174,19 @@
 // Not public.
 function _bezier_matrix(N) =
     N>10 ? _compute_bezier_matrix(N) :
     _bezier_matrix_table[N];
 
 
 // Function: bezier_curve()
+// Synopsis: Computes a number of uniformly distributed points along a bezier curve.
+// Topics: Bezier Curves
+// See Also: bezier_curve(), bezier_curvature(), bezier_tangent(), bezier_derivative(), bezier_points()
 // Usage:
 //   path = bezier_curve(bezier, [splinesteps], [endpoint]);
-// Topics: Bezier Curves
-// See Also: bezier_curvature(), bezier_tangent(), bezier_derivative(), bezier_points()
 // Description:
 //   Takes a list of bezier control points and generates splinesteps segments (splinesteps+1 points)
 //   along the bezier curve they define.
 //   Points start at the first control point and are sampled uniformly along the bezier parameter.
 //   The endpoints of the output will be *exactly* equal to the first and last bezier control points
 //   when endpoint is true.  If endpoint is false the sampling stops one step before the final point
 //   of the bezier curve, but you still get the same number of (more tightly spaced) points.  
@@ -206,20 +209,21 @@
 //   move_copies(bezier_curve(bez, 8)) sphere(r=1.5, $fn=12);
 //   debug_bezier(bez, N=len(bez)-1);
 function bezier_curve(bezier,splinesteps=16,endpoint=true) =
     bezier_points(bezier, lerpn(0,1,splinesteps+1,endpoint));
 
 
 // Function: bezier_derivative()
+// Synopsis: Evaluates the derivative of the bezier curve at the given point or points.
+// Topics: Bezier Curves
+// See Also: bezier_curvature(), bezier_tangent(), bezier_points()
 // Usage:
 //   deriv = bezier_derivative(bezier, u, [order]);
 //   derivs = bezier_derivative(bezier, LIST, [order]);
 //   derivs = bezier_derivative(bezier, RANGE, [order]);
-// Topics: Bezier Curves
-// See Also: bezier_curvature(), bezier_tangent(), bezier_points()
 // Description:
 //   Evaluates the derivative of the bezier curve at the given parameter value or values, `u`.  The `order` gives the order of the derivative. 
 //   The degree of the bezier curve is one less than the number of points in `bezier`.
 // Arguments:
 //   bezier = The list of control points that define the Bezier curve. 
 //   u = Parameter values for evaluating the curve, given as a single value, a list or a range.
 //   order = The order of the derivative to return.  Default: 1 (for the first derivative)
@@ -230,40 +234,42 @@
         dpts = N * deltas(bezier)
     ) order==1? bezier_points(dpts, u) :
     bezier_derivative(dpts, u, order-1);
 
 
 
 // Function: bezier_tangent()
+// Synopsis: Calculates unit tangent vectors along the bezier curve at one or more given positions.
+// Topics: Bezier Curves
+// See Also: bezier_curvature(), bezier_derivative(), bezier_points()
 // Usage:
 //   tanvec = bezier_tangent(bezier, u);
 //   tanvecs = bezier_tangent(bezier, LIST);
 //   tanvecs = bezier_tangent(bezier, RANGE);
-// Topics: Bezier Curves
-// See Also: bezier_curvature(), bezier_derivative(), bezier_points()
 // Description:
 //   Returns the unit tangent vector at the given parameter values on a bezier curve with control points `bezier`.
 // Arguments:
 //   bezier = The list of control points that define the Bezier curve. 
 //   u = Parameter values for evaluating the curve, given as a single value, a list or a range.
 function bezier_tangent(bezier, u) =
     let(
         res = bezier_derivative(bezier, u)
     ) is_vector(res)? unit(res) :
     [for (v=res) unit(v)];
 
 
 
 // Function: bezier_curvature()
+// Synopsis: Returns the curvature values at one or more given positions along a bezier curve.
+// Topics: Bezier Curves
+// See Also: bezier_tangent(), bezier_derivative(), bezier_points()
 // Usage:
 //   crv = bezier_curvature(curve, u);
 //   crvlist = bezier_curvature(curve, LIST);
 //   crvlist = bezier_curvature(curve, RANGE);
-// Topics: Bezier Curves
-// See Also: bezier_tangent(), bezier_derivative(), bezier_points()
 // Description:
 //   Returns the curvature value for the given parameters `u` on the bezier curve with control points `bezier`. 
 //   The curvature is the inverse of the radius of the tangent circle at the given point.
 //   Thus, the tighter the curve, the larger the curvature value.  Curvature will be 0 for
 //   a position with no curvature, since 1/0 is not a number.
 // Arguments:
 //   bezier = The list of control points that define the Bezier curve.
@@ -280,18 +286,19 @@
             sqr(d1[i]*d2[i])
         ) / pow(norm(d1[i]),3)
     ];
 
 
 
 // Function: bezier_closest_point()
-// Usage:
-//   u = bezier_closest_point(bezier, pt, [max_err]);
+// Synopsis: Finds the closest position on a bezier curve to a given point.
 // Topics: Bezier Curves
 // See Also: bezier_points()
+// Usage:
+//   u = bezier_closest_point(bezier, pt, [max_err]);
 // Description:
 //   Finds the closest part of the given bezier curve to point `pt`.
 //   The degree of the curve, N, is one less than the number of points in `curve`.
 //   Returns `u` for the closest position on the bezier curve to the given point `pt`.
 // Arguments:
 //   bezier = The list of control points that define the Bezier curve. 
 //   pt = The point to find the closest curve point to.
@@ -329,18 +336,19 @@
         pp = bezier_points(bezier, minima),
         err = norm(pp[1]-pp[0])
     ) err<max_err? mean(minima) :
     bezier_closest_point(bezier, pt, max_err=max_err, u=minima[0], end_u=minima[1]);
 
 
 // Function: bezier_length()
-// Usage:
-//   pathlen = bezier_length(bezier, [start_u], [end_u], [max_deflect]);
+// Synopsis: Approximate the length of part of a bezier curve.
 // Topics: Bezier Curves
 // See Also: bezier_points()
+// Usage:
+//   pathlen = bezier_length(bezier, [start_u], [end_u], [max_deflect]);
 // Description:
 //   Approximates the length of the portion of the bezier curve between start_u and end_u.
 // Arguments:
 //   bezier = The list of control points that define the Bezier curve. 
 //   start_u = The Bezier parameter to start measuring measuring from.  Between 0 and 1.
 //   end_u = The Bezier parameter to end measuring at.  Between 0 and 1.  Greater than start_u.
 //   max_deflect = The largest amount of deflection from the true curve to allow for approximation.
@@ -366,18 +374,19 @@
             eu = lerp(start_u, end_u, (i+1)/segs)
         ) bezier_length(bezier, su, eu, max_deflect)
     ]);
 
 
 
 // Function: bezier_line_intersection()
-// Usage: 
-//   u = bezier_line_intersection(bezier, line);
+// Synopsis: Calculates where a bezier curve intersects a line.
 // Topics: Bezier Curves, Geometry, Intersection
 // See Also: bezier_points(), bezier_length(), bezier_closest_point()
+// Usage: 
+//   u = bezier_line_intersection(bezier, line);
 // Description:
 //   Finds the intersection points of the 2D Bezier curve with control points `bezier` and the given line, specified as a pair of points.  
 //   Returns the intersection as a list of `u` values for the Bezier.  
 // Arguments:
 //   bezier = The list of control points that define a 2D Bezier curve. 
 //   line = a list of two distinct 2d points defining a line
 function bezier_line_intersection(bezier, line) =
@@ -400,40 +409,42 @@
 //   We interpret a degree N Bezier path as groups of N+1 control points that
 //   share endpoints, so they overlap by one point.  So if you have an order 3 bezier path `[p0,p1,p2,p3,p4,p5,p6]` then the first
 //   Bezier curve control point set is `[p0,p1,p2,p3]` and the second one is `[p3,p4,p5,p6]`.  The endpoint, `p3`, is shared between the control point sets.
 //   The Bezier degree, which must be known to interpret the Bezier path, defaults to 3. 
 
 
 // Function: bezpath_points()
+// Synopsis: Computes one or more specified points along a bezier path.
+// Topics: Bezier Paths
+// See Also: bezier_points(), bezier_curve()
 // Usage:
 //   pt = bezpath_points(bezpath, curveind, u, [N]);
 //   ptlist = bezpath_points(bezpath, curveind, LIST, [N]);
 //   path = bezpath_points(bezpath, curveind, RANGE, [N]);
-// Topics: Bezier Paths
-// See Also: bezier_points(), bezier_curve()
 // Description:
 //   Extracts from the Bezier path `bezpath` the control points for the Bezier curve whose index is `curveind` and
 //   computes the point or points on the corresponding Bezier curve specified by `u`.  If `curveind` is zero you
 //   get the first curve.  The number of curves is `(len(bezpath)-1)/N` so the maximum index is that number minus one.  
 // Arguments:
 //   bezpath = A Bezier path path to approximate.
 //   curveind = Curve number along the path.  
 //   u = Parameter values for evaluating the curve, given as a single value, a list or a range.
 //   N = The degree of the Bezier path curves.  Default: 3
 function bezpath_points(bezpath, curveind, u, N=3) =
     bezier_points(select(bezpath,curveind*N,(curveind+1)*N), u);
 
 
 // Function: bezpath_curve()
+// Synopsis: Takes a bezier path and converts it into a path of points.
+// Topics: Bezier Paths
+// See Also: bezier_points(), bezier_curve(), bezpath_points()
 // Usage:
 //   path = bezpath_curve(bezpath, [splinesteps], [N], [endpoint])
-// Topics: Bezier Paths
-// See Also: bezier_points(), bezier_curve()
 // Description:
-//   Takes a bezier path and converts it into a path of points.
+//   Computes a number of uniformly distributed points along a bezier path.
 // Arguments:
 //   bezpath = A bezier path to approximate.
 //   splinesteps = Number of straight lines to split each bezier curve into. default=16
 //   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
 //   endpoint = If true, include the very last point of the bezier path.  Default: true
 // Example(2D):
 //   bez = [
@@ -455,18 +466,19 @@
         for (seg = [0:1:segs-1])
             each bezier_points(select(bezpath, seg*N, (seg+1)*N), [0:step:1-step/2]),
         if (endpoint) last(bezpath)
     ];
 
 
 // Function: bezpath_closest_point()
+// Synopsis: Finds the closest part of a bezier path to a give point.
+// Topics: Bezier Paths
+// See Also: bezpath_points(), bezpath_curve(), bezier_points(), bezier_curve(), bezier_closest_point()
 // Usage:
 //   res = bezpath_closest_point(bezpath, pt, [N], [max_err]);
-// Topics: Bezier Paths
-// See Also: bezier_points(), bezier_curve(), bezier_closest_point()
 // Description:
 //   Finds an approximation to the closest part of the given bezier path to point `pt`.
 //   Returns [segnum, u] for the closest position on the bezier path to the given point `pt`.
 // Arguments:
 //   bezpath = A bezier path to approximate.
 //   pt = The point to find the closest curve point to.
 //   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
@@ -500,18 +512,19 @@
         )
         bezpath_closest_point(bezpath, pt, N, max_err, seg+1, mseg, mu, mdist)
     );
 
 
 
 // Function: bezpath_length()
-// Usage:
-//   plen = bezpath_length(path, [N], [max_deflect]);
+// Synopsis: Approximate the length of a bezier path.
 // Topics: Bezier Paths
 // See Also: bezier_points(), bezier_curve(), bezier_length()
+// Usage:
+//   plen = bezpath_length(path, [N], [max_deflect]);
 // Description:
 //   Approximates the length of the bezier path.
 // Arguments:
 //   path = A bezier path to approximate.
 //   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
 //   max_deflect = The largest amount of deflection from the true curve to allow for approximation.
 function bezpath_length(bezpath, N=3, max_deflect=0.001) =
@@ -526,18 +539,19 @@
             )
         )
     ]);
 
 
 
 // Function: path_to_bezpath()
-// Usage:
-//   bezpath = path_to_bezpath(path, [closed], [tangents], [uniform], [size=]|[relsize=]);
+// Synopsis: Generates a bezier path that passes through all points in a given linear path.
 // Topics: Bezier Paths, Rounding
 // See Also: path_tangents()
+// Usage:
+//   bezpath = path_to_bezpath(path, [closed], [tangents], [uniform], [size=]|[relsize=]);
 // Description:
 //   Given a 2d or 3d input path and optional list of tangent vectors, computes a cubic (degree 3) bezier
 //   path that passes through every point on the input path and matches the tangent vectors.  If you do
 //   not supply the tangent it will be computed using `path_tangents()`.  If the path is closed specify this
 //   by setting `closed=true`.  The size or relsize parameter determines how far the curve can deviate from
 //   the input path.  In the case where the curve has a single hump, the size specifies the exact distance
 //   between the specified path and the bezier.  If you give relsize then it is relative to the segment
@@ -612,18 +626,19 @@
         select(path,lastpt)
     ];
 
 
 
 
 // Function: bezpath_close_to_axis()
-// Usage:
-//   bezpath = bezpath_close_to_axis(bezpath, [axis], [N]);
+// Synopsis: Closes a 2D bezier path to the specified axis.
 // Topics: Bezier Paths
 // See Also: bezpath_offset()
+// Usage:
+//   bezpath = bezpath_close_to_axis(bezpath, [axis], [N]);
 // Description:
 //   Takes a 2D bezier path and closes it to the specified axis.
 // Arguments:
 //   bezpath = The 2D bezier path to close to the axis.
 //   axis = The axis to close to, "X", or "Y".  Default: "X"
 //   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
 // Example(2D):
@@ -655,18 +670,19 @@
         lerpn([0,ep.y], [0,sp.y], N+1)
     ) : (
         assert(in_list(axis, ["X","Y"]))
     );
 
 
 // Function: bezpath_offset()
-// Usage:
-//   bezpath = bezpath_offset(offset, bezier, [N]);
+// Synopsis: Forms a closed bezier path loop with a translated and reversed copy of itself.
 // Topics: Bezier Paths
 // See Also: bezpath_close_to_axis()
+// Usage:
+//   bezpath = bezpath_offset(offset, bezier, [N]);
 // Description:
 //   Takes a 2D bezier path and closes it with a matching reversed path that is offset by the given `offset` [X,Y] distance.
 // Arguments:
 //   offset = Amount to offset second path by.
 //   bezier = The 2D bezier path.
 //   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
 // Example(2D):
@@ -693,14 +709,15 @@
     );
 
 
 
 // Section: Cubic Bezier Path Construction
 
 // Function: bez_begin()
+// Synopsis: Calculates starting bezier path control points.
 // Topics: Bezier Paths
 // See Also: bez_tang(), bez_joint(), bez_end()
 // Usage:
 //   pts = bez_begin(pt, a, r, [p=]);
 //   pts = bez_begin(pt, VECTOR, [r], [p=]);
 // Description:
 //   This is used to create the first endpoint and control point of a cubic bezier path.
@@ -763,14 +780,15 @@
     assert(len(pt)==3 || is_undef(p))
     is_vector(a)? [pt, pt+(is_undef(r)? a : r*unit(a))] :
     is_finite(a)? [pt, pt+spherical_to_xyz(r,a,default(p,90))] :
     assert(false, "Bad arguments.");
 
 
 // Function: bez_tang()
+// Synopsis: Calculates control points for a smooth bezier path joint.
 // Topics: Bezier Paths
 // See Also: bez_begin(), bez_joint(), bez_end()
 // Usage:
 //   pts = bez_tang(pt, a, r1, r2, [p=]);
 //   pts = bez_tang(pt, VECTOR, [r1], [r2], [p=]);
 // Description:
 //   This creates a smooth joint in a cubic bezier path.  It creates three points, being the
@@ -798,14 +816,15 @@
         pt,
         pt+spherical_to_xyz(r2,a,p)
     ] :
     assert(false, "Bad arguments.");
 
 
 // Function: bez_joint()
+// Synopsis: Calculates control points for a disjointed corner bezier path joint.
 // Topics: Bezier Paths
 // See Also: bez_begin(), bez_tang(), bez_end()
 // Usage:
 //   pts = bez_joint(pt, a1, a2, r1, r2, [p1=], [p2=]);
 //   pts = bez_joint(pt, VEC1, VEC2, [r1=], [r2=], [p1=], [p2=]);
 // Description:
 //   This creates a disjoint corner joint in a cubic bezier path.  It creates three points, being
@@ -838,14 +857,15 @@
         if (is_vector(a2)) (pt+r2*unit(a2))
         else if (is_finite(a2)) (pt+spherical_to_xyz(r2,a2,p2))
         else assert(false, "Bad Arguments")
     ];
 
 
 // Function: bez_end()
+// Synopsis: Calculates ending bezier path control points.
 // Topics: Bezier Paths
 // See Also: bez_tang(), bez_joint(), bez_end()
 // Usage:
 //   pts = bez_end(pt, a, r, [p=]);
 //   pts = bez_end(pt, VECTOR, [r], [p=]);
 // Description:
 //   This is used to create the approaching control point, and the endpoint of a cubic bezier path.
@@ -864,74 +884,82 @@
 
 
 
 // Section: Bezier Surfaces
 
 
 // Function: is_bezier_patch()
+// Synopsis: Returns true if the given item is a bezier patch.
+// Topics: Bezier Patches, Type Checking
 // Usage:
 //   bool = is_bezier_patch(x);
-// Topics: Bezier Patches, Type Checking
 // Description:
-//   Returns true if the given item is a bezier patch.
+//   Returns true if the given item is a bezier patch. (a 2D array of 3D points.)
 // Arguments:
 //   x = The value to check the type of.
 function is_bezier_patch(x) =
     is_list(x) && is_list(x[0]) && is_vector(x[0][0]) && len(x[0]) == len(x[len(x)-1]);  
 
 
 // Function: bezier_patch_flat()
-// Usage:
-//   patch = bezier_patch_flat(size, [N=], [spin=], [orient=], [trans=]);
+// Synopsis: Creates a flat bezier patch.
 // Topics: Bezier Patches
 // See Also: bezier_patch_points()
+// Usage:
+//   patch = bezier_patch_flat(size, [N=], [spin=], [orient=], [trans=]);
 // Description:
 //   Returns a flat rectangular bezier patch of degree `N`, centered on the XY plane.
 // Arguments:
-//   size = 2D XY size of the patch.
+//   size = scalar or 2-vector giving the X and Y dimensions of the patch. 
 //   ---
-//   N = Degree of the patch to generate.  Since this is flat, a degree of 1 should usually be sufficient.
-//   orient = The orientation to rotate the edge patch into.  Given as an [X,Y,Z] rotation angle list.
-//   trans = Amount to translate patch, after rotating to `orient`.
+//   N = Degree of the patch to generate.  Since this is flat, a degree of 1 should usually be sufficient.  Default: 1
+//   orient = A direction vector.  Point the patch normal in this direction.  
+//   spin = Spin angle to apply to the patch
+//   trans = Amount to translate patch, after orient and spin. 
 // Example(3D):
-//   patch = bezier_patch_flat(size=[100,100], N=3);
+//   patch = bezier_patch_flat(size=[100,100]);
 //   debug_bezier_patches([patch], size=1, showcps=true);
-function bezier_patch_flat(size=[100,100], N=4, spin=0, orient=UP, trans=[0,0,0]) =
+function bezier_patch_flat(size, N=1, spin=0, orient=UP, trans=[0,0,0]) =
+    assert(N>0)
+    let(size = force_list(size,2))
+    assert(is_vector(size,2))
     let(
         patch = [
             for (x=[0:1:N]) [
                 for (y=[0:1:N])
                 v_mul(point3d(size), [x/N-0.5, 0.5-y/N, 0])
             ]
         ],
         m = move(trans) * rot(a=spin, from=UP, to=orient)
     ) [for (row=patch) apply(m, row)];
 
 
 
 // Function: bezier_patch_reverse()
-// Usage:
-//   rpatch = bezier_patch_reverse(patch);
+// Synopsis: Reverses the orientation of a bezier patch.
 // Topics: Bezier Patches
 // See Also: bezier_patch_points(), bezier_patch_flat()
+// Usage:
+//   rpatch = bezier_patch_reverse(patch);
 // Description:
 //   Reverses the patch, so that the faces generated from it are flipped back to front.
 // Arguments:
 //   patch = The patch to reverse.
 function bezier_patch_reverse(patch) =
     [for (row=patch) reverse(row)];
 
 
 // Function: bezier_patch_points()
+// Synopsis: Computes one or more specified points across a bezier surface patch.
+// Topics: Bezier Patches
+// See Also: bezier_patch_normals(), bezier_points(), bezier_curve(), bezpath_curve()
 // Usage:
 //   pt = bezier_patch_points(patch, u, v);
 //   ptgrid = bezier_patch_points(patch, LIST, LIST);
 //   ptgrid = bezier_patch_points(patch, RANGE, RANGE);
-// Topics: Bezier Patches
-// See Also: bezier_patch_normals(), bezier_points(), bezier_curve(), bezpath_curve()
 // Description:
 //   Sample a bezier patch on a listed point set.  The bezier patch must be a rectangular array of
 //   points, and it will be sampled at all the (u,v) pairs that you specify.  If you give u and v
 //   as single numbers you'll get a single point back.  If you give u and v as lists or ranges you'll
 //   get a 2d rectangular array of points.  If one but not both of u and v is a list or range then you'll
 //   get a list of points.  
 // Arguments:
@@ -979,25 +1007,27 @@
         vvals = lerpn(1,0,splinesteps.y+1),
         pts = bezier_patch_points(patch, uvals, vvals)
     )
     vnf_vertex_array(pts, style=style, reverse=false);
 
 
 // Function: bezier_vnf()
-// Usage:
-//   vnf = bezier_vnf(patches, [splinesteps], [style]);
+// Synopsis: Generates a (probably non-manifold) VNF for one or more bezier surface patches.
 // Topics: Bezier Patches
 // See Also: bezier_patch_points(), bezier_patch_flat()
+// Usage:
+//   vnf = bezier_vnf(patches, [splinesteps], [style]);
 // Description:
 //   Convert a patch or list of patches into the corresponding Bezier surface, representing the
 //   result as a [VNF structure](vnf.scad).  The `splinesteps` argument specifies the sampling grid of
 //   the surface for each patch by specifying the number of segments on the borders of the surface.
 //   It can be a scalar, which gives a uniform grid, or
 //   it can be [USTEPS, VSTEPS], which gives difference spacing in the U and V parameters. 
 //   Note that the surface you produce may be disconnected and is not necessarily a valid manifold in OpenSCAD.
+//   You must also ensure that the patches mate exactly along their edges, or the VNF will be invalid.  
 // Arguments:
 //   patches = The bezier patch or list of bezier patches to convert into a vnf.
 //   splinesteps = Number of segments on the border of the bezier surface.  You can specify [USTEPS,VSTEPS].  Default: 16
 //   style = The style of subdividing the quads into faces.  Valid options are "default", "alt", "min_edge", "quincunx", "convex" and "concave".  See {{vnf_vertex_array()}}.  Default: "default"
 // Example(3D):
 //   patch = [
 //       // u=0,v=0                                         u=1,v=0
@@ -1006,29 +1036,31 @@
 //       [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],
 //       [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],
 //       // u=0,v=1                                         u=1,v=1
 //   ];
 //   vnf = bezier_vnf(patch, splinesteps=16);
 //   vnf_polyhedron(vnf);
 // Example(3D,FlatSpin,VPD=444): Combining multiple patches
-//   patch = [
+//   patch = 100*[
 //       // u=0,v=0                                u=1,v=0
-//       [[0,  0,0], [33,  0,  0], [67,  0,  0], [100,  0,0]],
-//       [[0, 33,0], [33, 33, 33], [67, 33, 33], [100, 33,0]],
-//       [[0, 67,0], [33, 67, 33], [67, 67, 33], [100, 67,0]],
-//       [[0,100,0], [33,100,  0], [67,100,  0], [100,100,0]],
+//       [[0,  0,0], [1/3,  0,  0], [2/3,  0,  0], [1,  0,0]],
+//       [[0,1/3,0], [1/3,1/3,1/3], [2/3,1/3,1/3], [1,1/3,0]],
+//       [[0,2/3,0], [1/3,2/3,1/3], [2/3,2/3,1/3], [1,2/3,0]],
+//       [[0,  1,0], [1/3,  1,  0], [2/3,  1,  0], [1,  1,0]],
 //       // u=0,v=1                                u=1,v=1
 //   ];
+//   fpatch = bezier_patch_flat([100,100]);
 //   tpatch = translate([-50,-50,50], patch);
+//   flatpatch = translate([0,0,50], fpatch);
 //   vnf = bezier_vnf([
 //                     tpatch,
 //                     xrot(90, tpatch),
 //                     xrot(-90, tpatch),
 //                     xrot(180, tpatch),
-//                     yrot(90, tpatch),
+//                     yrot(90, flatpatch),
 //                     yrot(-90, tpatch)]);
 //   vnf_polyhedron(vnf);
 // Example(3D):
 //   patch1 = [
 //       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],
 //       [[ 0,40,0], [ 0,  0,100], [100,  0, 20], [100, 40,0]],
 //       [[ 0,60,0], [ 0,100,100], [100,100, 20], [100, 60,0]],
@@ -1102,14 +1134,17 @@
         : assert(false,"Invalid patch list")
       ]
     );
           
 
 
 // Function: bezier_vnf_degenerate_patch()
+// Synopsis: Generates a VNF for a degenerate bezier surface patch.
+// Topics: Bezier Patches
+// See Also: bezier_patch_points(), bezier_patch_flat(), bezier_vnf()
 // Usage:
 //   vnf = bezier_vnf_degenerate_patch(patch, [splinesteps], [reverse]);
 //   vnf_edges = bezier_vnf_degenerate_patch(patch, [splinesteps], [reverse], return_edges=true);
 // Description:
 //   Returns a VNF for a degenerate rectangular bezier patch where some of the corners of the patch are
 //   equal.  If the resulting patch has no faces then returns an empty VNF.  Note that due to the degeneracy,
 //   the shape of the surface can be triangular even though the underlying patch is a rectangle.  
@@ -1286,20 +1321,21 @@
       )
       [result[0],
        select(result[1],[2,3,0,1])
       ];
 
 
 // Function: bezier_patch_normals()
+// Synopsis: Computes surface normals for one or more places on a bezier surface patch.
+// Topics: Bezier Patches
+// See Also: bezier_patch_points(), bezier_points(), bezier_curve(), bezpath_curve()
 // Usage:
 //   n = bezier_patch_normals(patch, u, v);
 //   ngrid = bezier_patch_normals(patch, LIST, LIST);
 //   ngrid = bezier_patch_normals(patch, RANGE, RANGE);
-// Topics: Bezier Patches
-// See Also: bezier_patch_points(), bezier_points(), bezier_curve(), bezpath_curve()
 // Description:
 //   Compute the unit normal vector to a bezier patch at the listed point set.  The bezier patch must be a rectangular array of
 //   points, and the normal will be computed at all the (u,v) pairs that you specify.  If you give u and v
 //   as single numbers you'll get a single point back.  If you give u and v as lists or ranges you'll
 //   get a 2d rectangular array of points.  If one but not both of u and v is a list or range then you'll
 //   get a list of points.
 //   .
@@ -1365,15 +1401,15 @@
 //    }
 // Example(3D,Med,NoAxes,VPR=[48,0,23.6],VPD=32.0275,VPT=[-0.145727,-0.0532125,1.74224]): This example has a singularities where the tangent lines don't exist, so the normal will be undef at those points.  
 //    pts1 = [ [-5,0,0], [5,0,5], [-5,0,5], [5,0,0] ];
 //    pts2 = [ [0,-5,0], [0,5,5], [0,-5,5], [0,5,0] ];
 //    patch = [for(i=[0:3])
 //            [for(j=[0:3]) pts1[i]+pts2[j] ] ];
 //    vnf_polyhedron(bezier_vnf(patch, 163));
-//    uv = [0,.1,.2,.3,,.7,.8,.9,1];//lerpn(0,1,8);
+//    uv = [0,.1,.2,.3,.7,.8,.9,1];//lerpn(0,1,8);
 //    pts = bezier_patch_points(patch, uv, uv);
 //    normals = bezier_patch_normals(patch, uv, uv);
 //    for(i=idx(uv),j=idx(uv))
 //      stroke([pts[i][j],pts[i][j]+2*normals[i][j]], width=0.08,
 //               endcap1="dot",endcap2="arrow2",color="blue");
   
 function bezier_patch_normals(patch, u, v) =
@@ -1398,18 +1434,19 @@
 
 
 
 // Section: Debugging Beziers
 
 
 // Module: debug_bezier()
-// Usage:
-//   debug_bezier(bez, [size], [N=]);
+// Synopsis: Shows a bezier path and it's associated control points.
 // Topics: Bezier Paths, Debugging
 // See Also: bezpath_curve()
+// Usage:
+//   debug_bezier(bez, [size], [N=]);
 // Description:
 //   Renders 2D or 3D bezier paths and their associated control points.
 //   Useful for debugging bezier paths.
 // Arguments:
 //   bez = the array of points in the bezier.
 //   size = diameter of the lines drawn.
 //   ---
@@ -1420,17 +1457,18 @@
 //       [ -5, -10],  [  0, -10],  [ 5, -10],
 //       [ 14,  -5],  [ 15,   0],  [16,   5],
 //       [  5,  10],  [  0,  10]
 //   ];
 //   debug_bezier(bez, N=3, width=0.5);
 module debug_bezier(bezpath, width=1, N=3) {
     no_children($children);
-    assert(is_path(bezpath));
-    assert(is_int(N));
-    assert(len(bezpath)%N == 1, str("A degree ",N," bezier path shound have a multiple of ",N," points in it, plus 1."));
+    check = 
+      assert(is_path(bezpath),"bezpath must be a path")
+      assert(is_int(N) && N>0, "N must be a positive integer")
+      assert(len(bezpath)%N == 1, str("A degree ",N," bezier path shound have a multiple of ",N," points in it, plus 1."));
     $fn=8;
     stroke(bezpath_curve(bezpath, N=N), width=width, color="cyan");
     color("green")
       if (N!=3) 
            stroke(bezpath, width=width);
       else 
            for(i=[1:3:len(bezpath)]) stroke(select(bezpath,max(0,i-2), min(len(bezpath)-1,i)), width=width);
@@ -1450,18 +1488,19 @@
         if (twodim) circle(d=width*2.25); else sphere(d=width*2.25);
     if (twodim) color("red") move_copies(bezpath)
       if ($idx % N !=0) circle(d=width/2);
 }
 
 
 // Module: debug_bezier_patches()
-// Usage:
-//   debug_bezier_patches(patches, [size=], [splinesteps=], [showcps=], [showdots=], [showpatch=], [convexity=], [style=]);
+// Synopsis: Shows a bezier surface patch and its associated control points.
 // Topics: Bezier Patches, Debugging
 // See Also: bezier_patch_points(), bezier_patch_flat(), bezier_vnf()
+// Usage:
+//   debug_bezier_patches(patches, [size=], [splinesteps=], [showcps=], [showdots=], [showpatch=], [convexity=], [style=]);
 // Description:
 //   Shows the surface, and optionally, control points of a list of bezier patches.
 // Arguments:
 //   patches = A list of rectangular bezier patches.
 //   ---
 //   splinesteps = Number of segments to divide each bezier curve into. Default: 16
 //   showcps = If true, show the controlpoints as well as the surface.  Default: true.
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/bosl1compat.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/bosl1compat.scad`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,14 @@
 module translate_copies(a=[[0,0,0]]) move_copies(a) children();
-module xmove(x) right(x) children();
-module ymove(y) back(y) children();
-module zmove(z) up(z) children();
 
 module xspread(spacing, n, l, sp) xcopies(spacing=spacing, n=n, l=l, sp=sp) children();
 module yspread(spacing, n, l, sp) ycopies(spacing=spacing, n=n, l=l, sp=sp) children();
 module zspread(spacing, n, l, sp) zcopies(spacing=spacing, n=n, l=l, sp=sp) children();
 
-module spread(p1=[0,0,0], p2=[10,0,0], spacing, l, n=2) line_of(p1=p1, p2=p2, spacing=spacing, l=l, n=n) children();
+module spread(p1=[0,0,0], p2=[10,0,0], spacing, l, n=2) line_copies(p1=p1, p2=p2, spacing=spacing, l=l, n=n) children();
 module grid_of(xa=[0],ya=[0],za=[0],count,spacing) grid3d(xa=xa, ya=ya, za=za, n=count, spacing=spacing) children();
 
 module xring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) xrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();
 module yring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) yrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();
 module zring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) zrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();
 
 module leftcube(size) cube(size, anchor=RIGHT);
@@ -25,19 +22,19 @@
 module offsetcube(size=[1,1,1],v=[0,0,0]) cuboid(size,anchor=-v);
 module rrect(size=[1,1,1], r=0.25, center=false) cuboid(size,rounding=r,edges="Z",anchor=center?CENTER:BOT);
 module rcube(size=[1,1,1], r=0.25, center=false) cuboid(size,rounding=r,anchor=center?CENTER:BOT);
 module chamfcube(size=[1,1,1],chamfer=0.25,chamfaxes=[1,1,1],chamfcorners=false) {
     cuboid(
         size=size, chamfer=chamfer,
         trimcorners=chamfcorners,
-        edges=concat(
-            chamfaxes[0]? ["X"] : [],
-            chamfaxes[1]? ["Y"] : [],
-            chamfaxes[2]? ["Z"] : []
-        )
+        edges=[
+            if (chamfaxes.x) "X",
+            if (chamfaxes.y) "Y",
+            if (chamfaxes.z) "Z",
+        ]
     );
 }
 
 module trapezoid(size1=[1,1], size2=[1,1], h=1, shift=[0,0], align=CTR, orient=0, center)
     prismoid(size1=size1, size2=size2, h=h, shift=shift, spin=orient, anchor=center==undef? -align : center?CENTER:BOT);
 
 module pyramid(n=4, h=1, l=1, r, d, circum=false) {
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/bottlecaps.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/bottlecaps.scad`

 * *Files 4% similar despite different names*

```diff
@@ -13,14 +13,17 @@
 include <structs.scad>
 include <rounding.scad>
 
 // Section: PCO-1810 Bottle Threading
 
 
 // Module: pco1810_neck()
+// Synopsis: Creates a neck for a PCO1810 standard bottle.
+// Topics: Bottles, Threading
+// See Also: pco1810_cap()
 // Usage:
 //   pco1810_neck([wall]) [ATTACHMENTS];
 // Description:
 //   Creates an approximation of a standard PCO-1810 threaded beverage bottle neck.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   ---
@@ -113,15 +116,15 @@
                     difference() {
                         thread_helix(
                             d=threadbase_d-0.1,
                             pitch=thread_pitch,
                             thread_depth=thread_h+0.1,
                             flank_angle=flank_angle,
                             turns=810/360,
-                            higbee=thread_h*2,
+                            lead_in=-thread_h*2,
                             anchor=TOP
                         );
                         zrot_copies(rots=[90,270]) {
                             zrot_copies(rots=[-28,28], r=threadbase_d/2) {
                                 prismoid([20,1.82], [20,1.82+2*sin(29)*thread_h], h=thread_h+0.1, anchor=BOT, orient=RIGHT);
                             }
                         }
@@ -134,14 +137,17 @@
 }
 
 function  pco1810_neck(wall=2, anchor="support-ring", spin=0, orient=UP) =
     no_function("pco1810_neck");
 
 
 // Module: pco1810_cap()
+// Synopsis: Creates a cap for a PCO1810 standard bottle.
+// Topics: Bottles, Threading
+// See Also: pco1810_neck()
 // Usage:
 //   pco1810_cap([wall], [texture]) [ATTACHMENTS];
 // Description:
 //   Creates a basic cap for a PCO1810 threaded beverage bottle.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   texture = The surface texture of the cap.  Valid values are "none", "knurled", or "ribbed".  Default: "none"
@@ -177,38 +183,41 @@
         named_anchor("inside-top", [0,0,-(h/2-wall)])
     ];
     attachable(anchor,spin,orient, d=w, l=h, anchors=anchors) {
         down(h/2) zrot(45) {
             difference() {
                 union() {
                     if (texture == "knurled") {
-                        textured_cylinder(d=w, h=h, texture="diamonds", tex_size=[3,3], style="concave", anchor=BOT);
+                        cyl(d=w, h=h, texture="diamonds", tex_size=[3,3], tex_style="concave", anchor=BOT);
                     } else if (texture == "ribbed") {
-                        textured_cylinder(d=w, h=h, texture="ribs", tex_size=[3,3], style="min_edge", anchor=BOT);
+                        cyl(d=w, h=h, texture="ribs", tex_size=[3,3], tex_style="min_edge", anchor=BOT);
                     } else {
                         cyl(d=w, l=tamper_ring_h+wall, anchor=BOTTOM);
                     }
                 }
                 up(wall) cyl(d=cap_id, h=tamper_ring_h+wall, anchor=BOTTOM);
             }
-            up(wall+2) thread_helix(d=thread_od-thread_depth*2, pitch=thread_pitch, thread_depth=thread_depth, flank_angle=flank_angle, turns=810/360, higbee=thread_depth, internal=true, anchor=BOTTOM);
+            up(wall+2) thread_helix(d=thread_od-thread_depth*2, pitch=thread_pitch, thread_depth=thread_depth, flank_angle=flank_angle, turns=810/360, lead_in=-thread_depth, internal=true, anchor=BOTTOM);
         }
         children();
     }
 }
 
 function pco1810_cap(wall=2, texture="none", anchor=BOTTOM, spin=0, orient=UP) =
     no_function("pco1810_cap");
 
 
 
 // Section: PCO-1881 Bottle Threading
 
 
 // Module: pco1881_neck()
+// Synopsis: Creates a neck for a PCO1881 standard bottle.
+// Topics: Bottles, Threading
+// See Also: pco1881_cap()
 // Usage:
 //   pco1881_neck([wall]) [ATTACHMENTS];
 // Description:
 //   Creates an approximation of a standard PCO-1881 threaded beverage bottle neck.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   ---
@@ -302,15 +311,15 @@
                 difference() {
                     thread_helix(
                         d=threadbase_d-0.1,
                         pitch=thread_pitch,
                         thread_depth=thread_h+0.1,
                         flank_angle=flank_angle,
                         turns=650/360,
-                        higbee=thread_h*2,
+                        lead_in=-thread_h*2,
                         anchor=TOP
                     );
                     zrot_copies(rots=[90,270]) {
                         zrot_copies(rots=[-28,28], r=threadbase_d/2) {
                             prismoid([20,1.82], [20,1.82+2*sin(29)*thread_h], h=thread_h+0.1, anchor=BOT, orient=RIGHT);
                         }
                     }
@@ -322,14 +331,17 @@
 }
 
 function pco1881_neck(wall=2, anchor="support-ring", spin=0, orient=UP) =
     no_function("pco1881_neck");
 
 
 // Module: pco1881_cap()
+// Synopsis: Creates a cap for a PCO1881 standard bottle.
+// Topics: Bottles, Threading
+// See Also: pco1881_neck()
 // Usage:
 //   pco1881_cap(wall, [texture]) [ATTACHMENTS];
 // Description:
 //   Creates a basic cap for a PCO1881 threaded beverage bottle.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   texture = The surface texture of the cap.  Valid values are "none", "knurled", or "ribbed".  Default: "none"
@@ -358,37 +370,40 @@
         named_anchor("inside-top", [0,0,-(h/2-wall)])
     ];
     attachable(anchor,spin,orient, d=w, l=h, anchors=anchors) {
         down(h/2) zrot(45) {
             difference() {
                 union() {
                     if (texture == "knurled") {
-                        textured_cylinder(d=w, h=11.2+wall, texture="diamonds", tex_size=[3,3], style="concave", anchor=BOT);
+                        cyl(d=w, h=11.2+wall, texture="diamonds", tex_size=[3,3], tex_style="concave", anchor=BOT);
                     } else if (texture == "ribbed") {
-                        textured_cylinder(d=w, h=11.2+wall, texture="ribs", tex_size=[3,3], style="min_edge", anchor=BOT);
+                        cyl(d=w, h=11.2+wall, texture="ribs", tex_size=[3,3], tex_style="min_edge", anchor=BOT);
                     } else {
                         cyl(d=w, l=11.2+wall, anchor=BOTTOM);
                     }
                 }
                 up(wall) cyl(d=28.58, h=11.2+wall, anchor=BOTTOM);
             }
-            up(wall+2) thread_helix(d=25.5, pitch=2.7, thread_depth=1.6, flank_angle=15, turns=650/360, higbee=1.6, internal=true, anchor=BOTTOM);
+            up(wall+2) thread_helix(d=25.5, pitch=2.7, thread_depth=1.6, flank_angle=15, turns=650/360, lead_in=-1.6, internal=true, anchor=BOTTOM);
         }
         children();
     }
 }
 
 function pco1881_cap(wall=2, texture="none", anchor=BOTTOM, spin=0, orient=UP) =
     no_function("pco1881_cap");
 
 
 
 // Section: Generic Bottle Connectors
 
 // Module: generic_bottle_neck()
+// Synopsis: Creates a generic neck for a bottle.
+// Topics: Bottles, Threading
+// See Also: generic_bottle_cap()
 // Usage:
 //   generic_bottle_neck([wall], ...) [ATTACHMENTS];
 // Description:
 //   Creates a bottle neck given specifications.
 // Arguments:
 //   wall = distance between ID and any wall that may be below the support
 //   ---
@@ -471,15 +486,15 @@
                 difference() {
                     thread_helix(
                         d = threadbase_d - 0.1 * diamMagMult,
                         pitch = thread_pitch,
                         thread_depth = thread_h + 0.1 * diamMagMult,
                         flank_angle = flank_angle,
                         turns = (height - pitch - lip_roundover_r) * .6167 / pitch,
-                        higbee = thread_h * 2,
+                        lead_in = -thread_h * 2,
                         anchor = TOP
                     );
                     zrot_copies(rots = [90, 270]) {
                         zrot_copies(rots = [-28, 28], r = threadbase_d / 2) {
                             prismoid(
                                 [20 * heightMagMult, 1.82 * diamMagMult],
                                 [20 * heightMagMult, 1.82 * diamMagMult * .6 + 2 * sin(29) * thread_h],
@@ -506,14 +521,17 @@
     round_supp,
     wall,
     anchor, spin, orient
 ) = no_function("generic_bottle_neck");
 
 
 // Module: generic_bottle_cap()
+// Synopsis: Creates a generic cap for a bottle.
+// Topics: Bottles, Threading
+// See Also: generic_bottle_neck()
 // Usage:
 //   generic_bottle_cap(wall, [texture], ...) [ATTACHMENTS];
 // Description:
 //   Creates a basic threaded cap given specifications.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   texture = The surface texture of the cap.  Valid values are "none", "knurled", or "ribbed".  Default: "none"
@@ -563,26 +581,27 @@
         down(h / 2) {
             difference() {
                 union() {
                     // For the knurled and ribbed caps the PCO caps in BOSL2 cut into the wall
                     // thickness so the wall+texture are the specified wall thickness.  That
                     // seems wrong so this does specified thickness+texture
                     if (texture == "knurled") {
-                        textured_cylinder(d=w + 1.5*diamMagMult, l=h, texture="diamonds", tex_size=[3,3], style="concave", anchor=BOT);
+                        cyl(d=w + 1.5*diamMagMult, l=h, texture="diamonds", tex_size=[3,3], tex_style="concave", anchor=BOT);
                     } else if (texture == "ribbed") {
-                        textured_cylinder(d=w + 1.5*diamMagMult, l=h, texture="ribs", tex_size=[3,3], style="min_edge", anchor=BOT);
+                        cyl(d=w + 1.5*diamMagMult, l=h, texture="ribs", tex_size=[3,3], tex_style="min_edge", anchor=BOT);
                     } else {
                         cyl(d = w, l = h, anchor = BOTTOM);
                     }
                 }
                 up(wall) cyl(d = threadOuterDTol, h = h, anchor = BOTTOM);
             }
             difference(){
                 up(wall + pitch / 2) {
-                    thread_helix(d = neckOuterDTol, pitch = pitch, thread_depth = threadDepth, flank_angle = flank_angle, turns = ((height - pitch) / pitch), higbee = threadDepth, internal = true, anchor = BOTTOM);
+                    thread_helix(d = neckOuterDTol, pitch = pitch, thread_depth = threadDepth, flank_angle = flank_angle,
+                                 turns = ((height - pitch) / pitch), lead_in = -threadDepth, internal = true, anchor = BOTTOM);
                 }
             }
         }
         children();
     }
 }
 
@@ -591,14 +610,17 @@
     thread_od, tolerance,
     neck_od, flank_angle, pitch,
     anchor, spin, orient
 ) = no_function("generic_bottle_cap");
 
 
 // Module: bottle_adapter_neck_to_cap()
+// Synopsis: Creates a generic adaptor between a neck and a cap.
+// Topics: Bottles, Threading
+// See Also: bottle_adapter_neck_to_neck()
 // Usage:
 //   bottle_adapter_neck_to_cap(wall, [texture], ...) [ATTACHMENTS];
 // Description:
 //   Creates a threaded neck to cap adapter
 // Arguments:
 //   wall = Thickness of wall between neck and cap when d=0.  Leave undefined to have the outside of the tube go from the OD of the neck support ring to the OD of the cap.  Default: undef
 //   texture = The surface texture of the cap.  Valid values are "none", "knurled", or "ribbed".  Default: "none"
@@ -704,14 +726,17 @@
     tolerance, cap_neck_od, cap_neck_id, cap_thread_taper,
     cap_thread_pitch, neck_d, neck_id, neck_thread_od,
     neck_h, neck_thread_pitch, neck_support_od, d, taper_lead_in
 ) = no_fuction("bottle_adapter_neck_to_cap");
 
 
 // Module: bottle_adapter_cap_to_cap()
+// Synopsis: Creates a generic adaptor between a cap and a cap.
+// Topics: Bottles, Threading
+// See Also: bottle_adapter_neck_to_cap(), bottle_adapter_neck_to_neck()
 // Usage:
 //   bottle_adapter_cap_to_cap(wall, [texture]);
 // Description:
 //   Creates a threaded cap to cap adapter.
 // Arguments:
 //   wall = Wall thickness in mm.
 //   texture = The surface texture of the cap.  Valid values are "none", "knurled", or "ribbed".  Default: "none"
@@ -817,14 +842,17 @@
     wall, texture, cap_h1, cap_thread_od1, tolerance,
     cap_neck_od1, cap_thread_pitch1, cap_h2, cap_thread_od2,
     cap_neck_od2, cap_thread_pitch2, d, neck_id1, neck_id2, taper_lead_in
 ) = no_function("bottle_adapter_cap_to_cap");
 
 
 // Module: bottle_adapter_neck_to_neck()
+// Synopsis: Creates a generic adaptor between a neck and a neck.
+// Topics: Bottles, Threading
+// See Also: bottle_adapter_neck_to_cap(), bottle_adapter_cap_to_cap()
 // Usage:
 //   bottle_adapter_neck_to_neck(...);
 // Description:
 //   Creates a threaded neck to neck adapter.
 // Arguments:
 //   ---
 //   d = Distance between bottoms of necks
@@ -941,24 +969,28 @@
 
 
 
 // Section: SPI Bottle Threading
 
 
 // Module: sp_neck()
+// Synopsis: Creates an SPI threaded bottle neck.
+// Topics: Bottles, Threading
+// See Also: sp_cap()
 // Usage:
 //   sp_neck(diam, type, wall|id=, [style=], [bead=]) [ATTACHMENTS];
 // Description:
 //   Make a SPI (Society of Plastics Industry) threaded bottle neck.  You must
 //   supply the nominal outer diameter of the threads and the thread type, one of
 //   400, 410 and 415.  The 400 type neck has 360 degrees of thread, the 410
 //   neck has 540 degrees of thread, and the 415 neck has 720 degrees of thread.
 //   You can also choose between the L style thread, which is symmetric and
-//   the M style thread, which is an asymmetric buttress thread.  You can
-//   specify the wall thickness (measured from the base of the threads) or
+//   the M style thread, which is an asymmetric buttress thread.  The M style
+//   may be good for 3d printing if printed with the flat face up.  
+//   You can specify the wall thickness (measured from the base of the threads) or
 //   the inner diameter, and you can specify an optional bead at the base of the threads.
 // Arguments:
 //   diam = nominal outer diameter of threads
 //   type = thread type, one of 400, 410 and 415
 //   wall = wall thickness
 //   ---
 //   id = inner diameter
@@ -974,14 +1006,19 @@
 //   sp_neck(22,410,2,bead=true);
 //   sp_neck(28,415,id=20,style="M");
 //   sp_neck(13,415,wall=1,style="M",bead=true);
 
 
 // Thread specs from https://www.isbt.com/threadspecs-downloads.asp
 
+//  T = peak to peak diameter (outer diameter)
+//  I = Inner diameter
+//  S = space above top thread
+//  H = total height of neck
+
 _sp_specs = [
   [400, //diam     T      I      H     S    tpi
         [[ 18, [ 17.68,  8.26,  9.42, 0.94, 8]],
          [ 20, [ 19.69, 10.26,  9.42, 0.94, 8]],
          [ 22, [ 21.69, 12.27,  9.42, 0.94, 8]],
          [ 24, [ 23.67, 13.11, 10.16, 1.17, 8]],
          [ 28, [ 27.38, 15.60, 10.16, 1.17, 6]],
@@ -1038,41 +1075,42 @@
                 [5, 3.05],
                 [6, 2.39],
                 [8, 2.13],
                 [12, 1.14],  // But note style M is different
                ];
 
 
-function _sp_thread_profile(tpi, a, S, style) = 
+function _sp_thread_profile(tpi, a, S, style, flip=false) = 
     let(
         pitch = 1/tpi*INCH,
         cL = a*(1-1/sqrt(3)),
         cM = (1-tan(10))*a/2,
         // SP specified roundings for the thread profile have special case for tpi=12
         roundings = style=="L" && tpi < 12 ? 0.5 
                   : style=="M" && tpi < 12 ? [0.25, 0.25, 0.75, 0.75]
                   : style=="L" ? [0.38, 0.13, 0.13, 0.38]
                   : /* style=="M" */  [0.25, 0.25, 0.2, 0.5],
-        path = style=="L"
+        path1 = style=="L"
                   ? round_corners([[-1/2*pitch,-a/2],
                                    [-a/2,-a/2],
                                    [-cL/2,0],
                                    [cL/2,0],
                                    [a/2,-a/2],
                                    [1/2*pitch,-a/2]], radius=roundings, closed=false,$fn=24)
                   : round_corners(
                        [[-1/2*pitch,-a/2],
                                    [-a/2, -a/2],
                                    [-cM, 0],
                                    [0,0],
                                    [a/2,-a/2],
-                                   [1/2*pitch,-a/2]], radius=roundings, closed=false, $fn=24)
+                                   [1/2*pitch,-a/2]], radius=roundings, closed=false, $fn=24),
+        path2 = flip ? reverse(xflip(path1)) : path1
    )
    // Shift so that the profile is S mm from the right end to create proper length S top gap
-   select(right(-a/2+1/2-S,p=path),1,-2)/pitch;
+   select(right(-a/2+1/2-S,p=path2),1,-2)/pitch;
 
 
 function sp_neck(diam,type,wall,id,style="L",bead=false, anchor, spin, orient) = no_function("sp_neck");
 module sp_neck(diam,type,wall,id,style="L",bead=false, anchor, spin, orient)
 {
     assert(num_defined([wall,id])==1, "Must define exactly one of wall and id");
     
@@ -1083,23 +1121,24 @@
          assert(style=="L" || style=="M", "style must be \"L\" or \"M\"");
 
     T = entry[0];
     I = entry[1];
     H = entry[2];
     S = entry[3];
     tpi = entry[4];
+
+    // a is the width of the thread 
     a = (style=="M" && tpi==12) ? 1.3 : struct_val(_sp_thread_width,tpi);
 
     twist = struct_val(_sp_twist, type);
 
     profile = _sp_thread_profile(tpi,a,S,style);
 
     depth = a/2;
-    higlen = 2*a;
-    higang = higlen / ((T-2*depth)*PI) * 360;
+    taperlen = 2*a;
 
     beadmax = type==400 ? (T/2-depth)+depth*1.25
             : diam <=15 ? (T-.15)/2 : (T-.05)/2;
     
     W = type==400 ? a*1.5      // arbitrary decision for type 400
                   : entry[6];  // specified width for 410 and 415
 
@@ -1116,30 +1155,132 @@
     extra_bot = type==400 && bead ? -min(column(beadpts,1))+max(isect400) : 0;
     bead_shift = type==400 ? H+max(isect400) : entry[5]+W/2;  // entry[5] is L
     
     attachable(anchor,spin,orient,r=bead ? beadmax : T/2, l=H+extra_bot){
         up((H+extra_bot)/2){
             difference(){
                 union(){
-                    thread_helix(d=T-.01, profile=profile, pitch = INCH/tpi, turns=(twist+2*higang)/360, higbee=higlen, anchor=TOP);
-                    cylinder(d=T-depth*2,l=H,anchor=TOP);
+                    thread_helix(d=T-.01, profile=profile, pitch = INCH/tpi, turns=twist/360, lead_in=taperlen, anchor=TOP);
+                    cylinder(d=T-depth*2,h=H,anchor=TOP);
                     if (bead)
                       down(bead_shift)
                          rotate_extrude()
                             polygon(beadpts);
                 }
                 up(.5)cyl(d=is_def(id) ? id : T-a-2*wall, l=H-extra_bot+1, anchor=TOP);
             }
         }
         children();
     }
-}  
+}
+
+
+
+// Module: sp_cap()
+// Synopsis: Creates an SPI threaded bottle cap.
+// Topics: Bottles, Threading
+// See Also: sp_neck()
+// Usage:
+//   sp_cap(diam, type, wall, [style=], [top_adj=], [bot_adj=], [texture=], [$slop]) [ATTACHMENTS];
+// Description:
+//   Make a SPI (Society of Plastics Industry) threaded bottle neck.  You must
+//   supply the nominal outer diameter of the threads and the thread type, one of
+//   400, 410 and 415.  The 400 type neck has 360 degrees of thread, the 410
+//   neck has 540 degrees of thread, and the 415 neck has 720 degrees of thread.
+//   You can also choose between the L style thread, which is symmetric and
+//   the M style thread, which is an asymmetric buttress thread.  Note that it
+//   is OK to mix styles, so you can put an L-style cap onto an M-style neck.  
+//   .
+//   The 410 and 415 caps have very long unthreaded sections at the bottom.
+//   The bot_adj parameter specifies an amount to reduce that bottom extension, which might be
+//   necessary if the cap bottoms out on the bead.  Be careful that you don't shrink past the threads,
+//   especially if making adjustments to 400 caps which have a very small bottom extension.  
+//   These caps often contain a cardboard or foam sealer disk, which can be as much as 1mm thick, and
+//   would cause the cap to stop in a higher position.
+//   .
+//   You can also adjust the space between the top of the cap and the threads using top_adj.  This
+//   will change how the threads engage when the cap is fully seated.
+//   .
+//   The inner diameter of the cap is set to allow 10% of the thread depth in clearance.  The diameter
+//   is further increased by `2 * $slop` so you can increase clearance if necessary. 
+//   .
+//   Note: there is a published SPI standard for necks, but absolutely nothing for caps.  This
+//   cap module was designed based on the neck standard to mate reasonably well, but if you
+//   find ways that it does the wrong thing, file a report.  
+// Arguments:
+//   diam = nominal outer diameter of threads
+//   type = thread type, one of 400, 410 and 415
+//   wall = wall thickness
+//   ---
+//   style = Either "L" or "M" to specify the thread style.  Default: "L"
+//   top_adj = Amount to reduce top space in the cap, which means it doesn't screw down as far.  Default: 0
+//   bot_adj = Amount to reduce extension of cap at the bottom, which also means it doesn't screw down as far.  Default: 0
+//   texture = texture for outside of cap, one of "knurled", "ribbed" or "none.  Default: "none"
+//   $slop = Increase inner diameter by `2 * $slop`.  
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+// Examples:
+//   sp_cap(48,400,2);
+//   sp_cap(22,400,2);
+//   sp_cap(22,410,2);
+//   sp_cap(28,415,1.5,style="M");
+module sp_cap(diam,type,wall,style="L",top_adj=0, bot_adj=0, texture="none", anchor, spin, orient)
+{
+    table = struct_val(_sp_specs,type);
+    dum1=assert(is_def(table),"Unknown SP closure type.  Type must be one of 400, 410, or 415");
+    entry = struct_val(table, diam);
+    dum2=assert(is_def(entry), str("Unknown closure nominal diameter.  Allowed diameters for SP",type,": ",struct_keys(table)))
+         assert(style=="L" || style=="M", "style must be \"L\" or \"M\"");
+
+    T = entry[0];
+    I = entry[1];
+    H = entry[2]-0.5;
+    S = entry[3];
+    tpi = entry[4];
+    a = (style=="M" && tpi==12) ? 1.3 : struct_val(_sp_thread_width,tpi);
+
+    twist = struct_val(_sp_twist, type);
+
+    echo(top_adj=top_adj,bot_adj=bot_adj);
+    dum3=assert(top_adj<S+0.75*a, str("The top_adj value is too large so the thread won't fit.  It must be smaller than ",S+0.75*a));
+    oprofile = _sp_thread_profile(tpi,a,S+0.75*a-top_adj,style,flip=true);
+    bounds=pointlist_bounds(oprofile);
+    profile = fwd(-bounds[0].y,yflip(oprofile));
+
+    depth = a/2;
+    taperlen = 2*a;
+    assert(in_list(texture, ["none","knurled","ribbed"]));
+    space=2*depth/10+2*get_slop();
+    attachable(anchor,spin,orient,r= (T+space)/2+wall, l=H-bot_adj+wall){
+        xrot(180)
+        up((H-bot_adj)/2-wall/2){
+            difference(){
+                up(wall){
+                   if (texture=="knurled")
+                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,texture="trunc_pyramids", tex_size=[3,3], tex_style="convex");
+                   else if (texture == "ribbed") 
+                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,chamfer2=.8,tex_taper=0,texture="trunc_ribs", tex_size=[3,3], tex_style="min_edge");
+                   else
+                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,chamfer2=.8);
+                }
+                cyl(d=T+space, l=H-bot_adj+1, anchor=TOP);
+            }
+            thread_helix(d=T+space-.01, profile=profile, pitch = INCH/tpi, turns=twist/360, lead_in=taperlen, anchor=TOP, internal=true);
+        }
+        children();
+    }
+}
+
 
 
 // Function: sp_diameter()
+// Synopsis: Returns the base diameter of an SPI bottle neck from the nominal diameter and type number.
+// Topics: Bottles, Threading
+// See Also: sp_neck(), sp_cap()
 // Usage:
 //   true_diam = sp_diameter(diam,type)
 // Description:
 //   Returns the actual base diameter (root of the threads) for a SPI plastic bottle neck given the nominal diameter and type number (400, 410, 415). 
 // Arguments:
 //   diam = nominal diameter
 //   type = closure type number (400, 410 or 415)
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/builtins.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/builtins.scad`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/color.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/color.scad`

 * *Files 6% similar despite different names*

```diff
@@ -12,18 +12,19 @@
 
 
 use <builtins.scad>
 
 // Section: Coloring Objects
 
 // Module: recolor()
+// Synopsis:  Sets the color for attachable children and all their descendants.
+// Topics: Attachments
+// See Also: color_this(), hsl(), hsv()
 // Usage:
 //   recolor([c]) CHILDREN;
-// Topics: Attachments
-// See Also: color_this()
 // Description:
 //   Sets the color for attachable children and all their descendants.  This only works with attachables and you cannot
 //   have any color() modules above it in any parents, only other recolor() or color_this() modules.
 //   This works by setting the special `$color` variable, which attachable objects make use of to set the color. 
 // Arguments:
 //   c = Color name or RGBA vector.  Default: The default color in your color scheme. 
 // Example:
@@ -39,18 +40,19 @@
     req_children($children);  
     $color=c;
     children();
 }
 
 
 // Module: color_this()
+// Synopsis: Sets the color for children at the current level only.
+// Topics: Attachments
+// See Also: recolor(), hsl(), hsv()
 // Usage:
 //   color_this([c]) CHILDREN;
-// Topics: Attachments
-// See Also: recolor()
 // Description:
 //   Sets the color for children at one level, reverting to the previous color for further descendants.
 //   This works only with attachables and you cannot have any color() modules above it in any parents,
 //   only recolor() or other color_this() modules.  This works using the `$color` and `$save_color` variables,
 //   which attachable objects make use of to set the color. 
 // Arguments:
 //   c = Color name or RGBA vector.  Default: the default color in your color scheme
@@ -68,14 +70,17 @@
   $save_color=default($color,"default");
   $color=c;
   children();
 }
 
 
 // Module: rainbow()
+// Synopsis: Iterates through a list, displaying children in different colors.
+// Topics: List Handling
+// See Also: hsl(), hsv()
 // Usage:
 //   rainbow(list,[stride],[maxhues],[shuffle],[seed]) CHILDREN;
 // Description:
 //   Iterates the list, displaying children in different colors for each list item.  The color
 //   is set using the color() module, so this module is not compatible with {{recolor()}} or
 //   {{color_this()}}.  This is useful for debugging regions or lists of paths. 
 // Arguments:
@@ -107,14 +112,17 @@
     }
 }
 
 
 // Section: Colorspace Conversion
 
 // Function&Module: hsl()
+// Synopsis: Sets the color of children to a specified hue, saturation, lightness and optional alpha channel value.
+// See Also: hsv(), recolor(), color_this()
+// Topics: Colors, Colorspace
 // Usage:
 //   hsl(h,[s],[l],[a]) CHILDREN;
 //   rgb = hsl(h,[s],[l],[a]);
 // Description:
 //   When called as a function, returns the [R,G,B] color for the given hue `h`, saturation `s`, and lightness `l` from the HSL colorspace. If you supply
 //   the `a` value then you'll get a length 4 list [R,G,B,A].  
 //   When called as a module, sets the color using the color() module to the given hue `h`, saturation `s`, and lightness `l` from the HSL colorspace.
@@ -142,14 +150,17 @@
 {
   req_children($children);  
   color(hsl(h,s,l),a) children();
 }
 
 
 // Function&Module: hsv()
+// Synopsis: Sets the color of children to a hue, saturation, value and optional alpha channel value.
+// See Also: hsl(), recolor(), color_this()
+// Topics: Colors, Colorspace
 // Usage:
 //   hsv(h,[s],[v],[a]) CHILDREN;
 //   rgb = hsv(h,[s],[v],[a]);
 // Description:
 //   When called as a function, returns the [R,G,B] color for the given hue `h`, saturation `s`, and value `v` from the HSV colorspace.  If you supply
 //   the `a` value then you'll get a length 4 list [R,G,B,A].  
 //   When called as a module, sets the color using the color() module to the given hue `h`, saturation `s`, and value `v` from the HSV colorspace.
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/comparisons.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/comparisons.scad`

 * *Files 14% similar despite different names*

```diff
@@ -8,14 +8,17 @@
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: List comparison operations
 
 // Function: approx()
+// Synopsis: Returns true if two values are equal to within a small epsilon value.
+// Topics: Comparisons
+// See Also: all_zero(), all_nonzero()
 // Usage:
 //   test = approx(a, b, [eps])
 // Description:
 //   Compares two numbers, vectors, or matrices.  Returns true if they are closer than `eps` to each other.
 //   Results are undefined if `a` and `b` are of different types, or if vectors or matrices contain non-numbers.
 // Arguments:
 //   a = First value.
@@ -40,14 +43,17 @@
                 !approx(aa,bb,eps=eps)
             ) 1
         ]
     ) : false;
 
 
 // Function: all_zero()
+// Synopsis: Returns true if the value(s) given are aproximately zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero()
 // Usage:
 //   x = all_zero(x, [eps]);
 // Description:
 //   Returns true if its argument is approximately zero, to within `eps`.
 //   If passed a list returns true if all its entries are approximately equal to zero. 
 //   Otherwise, returns false.
 // Arguments:
@@ -60,14 +66,17 @@
 //   d = all_zero([0,0,1e-3]);  // Returns: false.
 function all_zero(x, eps=EPSILON) =
     is_finite(x)? abs(x)<eps :
     is_vector(x) && [for (xx=x) if(abs(xx)>eps) 1] == [];
 
 
 // Function: all_nonzero()
+// Synopsis: Returns true if the value(s) given are not aproximately zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero()
 // Usage:
 //   test = all_nonzero(x, [eps]);
 // Description:
 //   Returns true if its argument is finite and different from zero by `eps`.
 //   If passed a list returns true if all the entries of the list are finite numbers that are different from zero by `eps`.  
 //   Otherwise, returns false.
 // Arguments:
@@ -81,14 +90,17 @@
 //   e = all_nonzero([1e-3,1e-3,1e-3]);  // Returns: true.
 function all_nonzero(x, eps=EPSILON) =
     is_finite(x)? abs(x)>eps :
     is_vector(x) && [for (xx=x) if(abs(xx)<eps) 1] == [];
 
 
 // Function: all_positive()
+// Synopsis: Returns true if the value(s) given are greater than zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_negative(), all_nonpositive(), all_nonnegative()
 // Usage:
 //   test = all_positive(x,[eps]);
 // Description:
 //   Returns true if the argument is finite and greater than zero, within epsilon tolerance if desired.
 //   If passed a list returns true if all the entries are finite positive numbers.
 //   Otherwise, returns false.
 // Arguments:
@@ -104,14 +116,17 @@
 //   g = all_positive([3,-1,2]);  // Returns: false.
 function all_positive(x,eps=0) =
     is_finite(x)? x>eps :
     is_vector(x) && [for (xx=x) if(xx<=0) 1] == [];
 
 
 // Function: all_negative()
+// Synopsis: Returns true if the value(s) given are less than zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_nonpositive(), all_nonnegative()
 // Usage:
 //   test = all_negative(x, [eps]);
 // Description:
 //   Returns true if the argument is finite and less than zero, within epsilon tolerance if desired.
 //   If passed a list, returns true if all the elements are finite negative numbers. 
 //   Otherwise, returns false.
 // Arguments:
@@ -128,14 +143,17 @@
 //   h = all_negative([-3,-1,-2]);  // Returns: true.
 function all_negative(x, eps=0) =
     is_finite(x)? x<-eps :
     is_vector(x) && [for (xx=x) if(xx>=-eps) 1] == [];
 
 
 // Function: all_nonpositive()
+// Synopsis: Returns true if the value(s) given are less than or equal to zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()
 // Usage:
 //   all_nonpositive(x, [eps]);
 // Description:
 //   Returns true if its argument is finite and less than or equal to zero.
 //   If passed a list, returns true if all the elements are finite non-positive numbers.
 //   Otherwise, returns false. 
 // Arguments:
@@ -152,14 +170,17 @@
 //   h = all_nonpositive([-3,-1,-2]);  // Returns: true.
 function all_nonpositive(x,eps=0) =
     is_num(x)? x<=eps :
     is_vector(x) && [for (xx=x) if(xx>eps) 1] == []; 
 
 
 // Function: all_nonnegative()
+// Synopsis: Returns true if the value(s) given are greater than or equal to zero.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()
 // Usage:
 //   all_nonnegative(x, [eps]);
 // Description:
 //   Returns true if the finite number passed to it is greater than or equal to zero.
 //   If passed a list, returns true if all the elements are finite non-negative numbers. 
 //   Otherwise, returns false.
 // Arguments:
@@ -177,32 +198,52 @@
 //   i = all_nonnegative([-3,-1,-2]);  // Returns: false.
 function all_nonnegative(x,eps=0) =
     is_num(x)? x>=-eps :
     is_vector(x) && [for (xx=x) if(xx<-eps) 1] == [];
 
 
 // Function: all_equal()
+// Synopsis: Returns true if all items in a list are approximately equal to each other.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()
 // Usage:
 //   b = all_equal(vec, [eps]);
 // Description:
 //   Returns true if all of the entries in vec are equal to each other, or approximately equal to each other if eps is set.
 // Arguments:
 //   vec = vector to check
 //   eps = Set to tolerance for approximate equality.  Default: 0
 function all_equal(vec,eps=0) =
    eps==0 ? [for(v=vec) if (v!=vec[0]) v] == []
           : [for(v=vec) if (!approx(v,vec[0],eps)) v] == [];
 
 
 
+// Function: are_ends_equal()
+// Synopsis: Returns true if the first and last items in a list are approximately equal.
+// Topics: Comparisons, List Handling
+// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()
+// Usage:
+//   are_ends_equal(list, [eps]);
+// Description:
+//   Returns true if the first and last points in the given list are equal to within epsilon.
+// Arguments:
+//   list = list to check
+//   eps = Tolerance for approximate equality.  Default: `EPSILON` (1e-9)
+function are_ends_equal(list, eps=EPSILON) =
+  assert(is_list(list) && len(list)>0, "Must give a nonempty list")
+  approx(list[0], list[len(list)-1], eps=eps);
+
+
 // Function: is_increasing()
+// Synopsis: Returns true if exery item in a list is greater than the previous item. 
+// Topics: Comparisons, List Handling
+// See Also: max_index(), min_index(), is_increasing(), is_decreasing()
 // Usage:
 //    bool = is_increasing(list, [strict]);
-// Topics: List Handling
-// See Also: max_index(), min_index(), is_decreasing()
 // Description:
 //   Returns true if the list is (non-strictly) increasing, or strictly increasing if strict is set to true.
 //   The list can be a list of any items that OpenSCAD can compare, or it can be a string which will be
 //   evaluated character by character.
 // Arguments:
 //   list = list (or string) to check
 //   strict = set to true to test that list is strictly increasing.  Default: false
@@ -215,18 +256,19 @@
 function is_increasing(list,strict=false) =
     assert(is_list(list)||is_string(list))
     strict ? len([for (p=pair(list)) if(p.x>=p.y) true])==0
            : len([for (p=pair(list)) if(p.x>p.y) true])==0;
 
 
 // Function: is_decreasing()
+// Synopsis: Returns true if exery item in a list is less than the previous item. 
+// Topics: Comparisons, List Handling
+// See Also: max_index(), min_index(), is_increasing(), is_decreasing()
 // Usage:
 //   bool = is_decreasing(list, [strict]);
-// Topics: List Handling
-// See Also: max_index(), min_index(), is_increasing()
 // Description:
 //   Returns true if the list is (non-strictly) decreasing, or strictly decreasing if strict is set to true.
 //   The list can be a list of any items that OpenSCAD can compare, or it can be a string which will be
 //   evaluated character by character.  
 // Arguments:
 //   list = list (or string) to check
 //   strict = set to true to test that list is strictly decreasing.  Default: false
@@ -248,14 +290,17 @@
     is_num(x)?    2 :
     is_nan(x)?    3 :
     is_string(x)? 4 :
     is_list(x)?   5 : 6;
 
 
 // Function: compare_vals()
+// Synopsis: Compares two values, possibly of different type.
+// Topics: Comparisons, List Handling
+// See Also: approx(), is_increasing(), is_decreasing()
 // Usage:
 //   test = compare_vals(a, b);
 // Description:
 //   Compares two values.  Lists are compared recursively.
 //   Returns a negative value if a<b.  Returns a positive value if a>b.  Returns 0 if a==b.
 //   If types are not the same, then undef < bool < nan < num < str < list < range.
 // Arguments:
@@ -266,14 +311,17 @@
     let(t1=_type_num(a), t2=_type_num(b)) (t1!=t2)? (t1-t2) :
     is_list(a)? compare_lists(a,b) :
     is_nan(a)? 0 :
     (a<b)? -1 : (a>b)? 1 : 0;
 
 
 // Function: compare_lists()
+// Synopsis: Compares two lists of values, possibly of different type.
+// Topics: Comparisons, List Handling
+// See Also: compare_vals(), approx(), is_increasing(), is_decreasing()
 // Usage:
 //   test = compare_lists(a, b)
 // Description:
 //   Compare contents of two lists using `compare_vals()`.
 //   Returns a negative number if `a`<`b`.
 //   Returns 0 if `a`==`b`.
 //   Returns a positive number if `a`>`b`.
@@ -293,19 +341,20 @@
 
 
 
 // Section: Finding the index of the minimum or maximum of a list
 
 
 // Function: min_index()
+// Synopsis: Returns the index of the minimal value in the given list.
+// Topics: List Handling
+// See Also: max_index(), is_increasing(), is_decreasing()
 // Usage:
 //   idx = min_index(vals);
 //   idxlist = min_index(vals, all=true);
-// Topics: List Handling
-// See Also: max_index(), is_increasing(), is_decreasing()
 // Description:
 //   Returns the index of the first occurrence of the minimum value in the given list. 
 //   If `all` is true then returns a list of all indices where the minimum value occurs.
 // Arguments:
 //   vals = vector of values
 //   all = set to true to return indices of all occurences of the minimum.  Default: false
 // Example:
@@ -313,19 +362,20 @@
 //   b = min_index([5,3,9,6,2,7,8,2,7],all=true); // Returns: [4,7]
 function min_index(vals, all=false) =
     assert( is_vector(vals), "Invalid or list of numbers.")
     all ? search(min(vals),vals,0) : search(min(vals), vals)[0];
 
 
 // Function: max_index()
+// Synopsis: Returns the index of the minimal value in the given list.
+// Topics: List Handling
+// See Also: min_index(), is_increasing(), is_decreasing()
 // Usage:
 //   idx = max_index(vals);
 //   idxlist = max_index(vals, all=true);
-// Topics: List Handling
-// See Also: min_index(), is_increasing(), is_decreasing()
 // Description:
 //   Returns the index of the first occurrence of the maximum value in the given list. 
 //   If `all` is true then returns a list of all indices where the maximum value occurs.
 // Arguments:
 //   vals = vector of values
 //   all = set to true to return indices of all occurences of the maximum.  Default: false
 // Example:
@@ -336,14 +386,15 @@
     all ? search(max(vals),vals,0) : search(max(vals), vals)[0];
 
 
 // Section: Dealing with duplicate list entries
 
 
 // Function: find_approx()
+// Synopsis: Finds the indexes of the item(s) in the given list that are aproximately the given value.
 // Topics: List Handling
 // See Also: in_list()
 // Usage:
 //   idx = find_approx(val, list, [start=], [eps=]);
 //   indices = find_approx(val, list, all=true, [start=], [eps=]);
 // Description:
 //   Finds the first item in `list` that matches `val` to within `eps` tolerance, returning the index.  Returns `undef` if there is no match.
@@ -369,18 +420,19 @@
     approx(val, list[i], eps=eps)
           ? i
           : __find_approx(val, list, eps=eps, i=i+1);
 
 
 
 // Function: deduplicate()
-// Usage:
-//   list = deduplicate(list, [closed], [eps]);
+// Synopsis: Returns a list with all consecutive duplicate values removed.
 // Topics: List Handling
 // See Also: deduplicate_indexed()
+// Usage:
+//   list = deduplicate(list, [closed], [eps]);
 // Description:
 //   Removes consecutive duplicate items in a list.
 //   When `eps` is zero, the comparison between consecutive items is exact.
 //   Otherwise, when all list items and subitems are numbers, the comparison is within the tolerance `eps`.
 //   Unlike `unique()` only consecutive duplicates are removed and the list is *not* sorted.
 //   If `closed` is set to true then the first and last entries in `list` are treated as adjacent,
 //   so all trailing items that match `list[0]` are dropped.  
@@ -402,18 +454,19 @@
     )
     is_string(list) ? str_join([for (i=[0:1:l-1]) if (i==end || list[i] != list[(i+1)%l]) list[i]]) :
     eps==0 ? [for (i=[0:1:l-1]) if (i==end || list[i] != list[(i+1)%l]) list[i]] :
     [for (i=[0:1:l-1]) if (i==end || !approx(list[i], list[(i+1)%l], eps)) list[i]];
 
 
 // Function: deduplicate_indexed()
-// Usage:
-//   new_idxs = deduplicate_indexed(list, indices, [closed], [eps]);
+// Synopsis: Takes a list of indices into a list of values, and returns a list of indices whose values are not consecutively the same.
 // Topics: List Handling
 // See Also: deduplicate()
+// Usage:
+//   new_idxs = deduplicate_indexed(list, indices, [closed], [eps]);
 // Description:
 //   Given a list, and a list of indices, removes consecutive indices corresponding to list values that are equal
 //   or approximately equal.  
 // Arguments:
 //   list = The list that the indices index into.
 //   indices = The list of indices to deduplicate.
 //   closed = If true, drops trailing indices if their list value matches the list value corresponding to the first index. 
@@ -447,19 +500,66 @@
         ) 
         if (i==end || !eq) indices[i]
     ];
 
 
 
 
-// Function: unique()
+// Function: list_wrap()
+// Synopsis: Returns a list whose last value is the same as the first.
+// Topics: List Handling, Paths
+// See Also: list_unwrap(), deduplicate()
 // Usage:
-//   ulist = unique(list);
+//   list_wrap(path, [eps]);
+// Description:
+//   Force a list to wrap around so that its last point is equal to its first point:  if the first and last entries are equal, simply returns the list unchanged.
+//   Otherwise returns the list with the first point duplicated at the end of the list.  Comparisons are done to the tolerance `eps`.  Lists of length 0 or
+//   1 are returned unchanged.  
+// Arguments:
+//   list = list to unwrap
+//   eps = epsilon for comparison.  Default: EPSILON (1e-9)
+
+function list_wrap(list, eps=EPSILON) =
+    assert(is_list(list))
+    len(list)<2 || are_ends_equal(list,eps=eps)? list : [each list, list[0]];
+
+
+function cleanup_path(list,eps=EPSILON) =
+  echo("***** Function cleanup_path() has been replaced by list_unwrap() and will be removed in a future version *****")
+  list_unwrap(list,eps);
+
+function close_path(list,eps=EPSILON) =
+  echo("***** Function close_path() has been replaced by list_wrap() and will be removed in a future version *****")
+  list_wrap(list,eps);
+
+// Function: list_unwrap()
+// Synopsis: Removes the last item of a list if it's first and last values are equal.
+// Topics: List Handling, Paths
+// See Also: list_wrap(), deduplicate()
+// Usage:
+//   list_unwrap(list, [eps]);
+// Description:
+//   If a list's last point matches its first point then delete the last point.  Inverse operation to {{list_wrap()}}.  Note that if the first/last points
+//   are repeated then the output may still have the first point equal to the last point.  Comparisons are done to the tolerance `eps`.  If the list has
+//   length 0 or 1 it is returned unchanged.  
+// Arguments:
+//   list = list to unwrap
+//   eps = epsilon for comparison.  Default: EPSILON (1e-9)
+function list_unwrap(list, eps=EPSILON) =
+    assert(is_list(list))
+    len(list)>=2 && are_ends_equal(list,eps=eps)? [for (i=[0:1:len(list)-2]) list[i]] : list;
+
+
+
+// Function: unique()
+// Synopsis: Returns a sorted list with all duplicates removed.
 // Topics: List Handling
 // See Also: shuffle(), sort(), sortidx(), unique_count()
+// Usage:
+//   ulist = unique(list);
 // Description:
 //   Given a string or a list returns the sorted string or the sorted list with all repeated items removed.
 //   The sorting order of non homogeneous lists is the function `sort` order.
 // Arguments:
 //   list = The list to process.
 // Example:
 //   sorted = unique([5,2,8,3,1,3,8,7,5]);  // Returns: [1,2,3,5,7,8]
@@ -490,18 +590,19 @@
         _unique_sort(lesser), 
         equal[0], 
         _unique_sort(greater)
     );    
 
 
 // Function: unique_count()
-// Usage:
-//   sorted_counts = unique_count(list);
+// Synopsis: Returns a sorted list of unique items with counts.
 // Topics: List Handling
 // See Also: shuffle(), sort(), sortidx(), unique()
+// Usage:
+//   sorted_counts = unique_count(list);
 // Description:
 //   Returns `[sorted,counts]` where `sorted` is a sorted list of the unique items in `list` and `counts` is a list such 
 //   that `count[i]` gives the number of times that `sorted[i]` appears in `list`.  
 // Arguments:
 //   list = The list to analyze. 
 // Example:
 //   sorted = unique([5,2,8,3,1,3,8,3,5]);  // Returns: [ [1,2,3,5,8], [1,1,3,2,2] ]
@@ -652,20 +753,22 @@
         equal   = [ for (entry=arrind) if (compare_vals(entry[1], pivot)==0 ) entry[0] ],
         greater = [ for (entry=arrind) if (compare_vals(entry[1], pivot) >0 ) entry ]
       )
     concat(_indexed_sort(lesser), equal, _indexed_sort(greater));
 
 
 // Function: sort()
-// Usage:
-//   slist = sort(list, [idx]);
+// Synopsis: Returns a sorted list.
 // Topics: List Handling
 // See Also: shuffle(), sortidx(), unique(), unique_count(), group_sort()
+// Usage:
+//   slist = sort(list, [idx]);
 // Description:
-//   Sorts the given list in lexicographic order. If the input is a homogeneous simple list or a homogeneous 
+//   Sorts the given list in lexicographic order. The sort is stable, meaning equivalent items will not change order. 
+//   If the input is a homogeneous simple list or a homogeneous 
 //   list of vectors (see function is_homogeneous), the sorting method uses the native comparison operator and is faster. 
 //   When sorting non homogeneous list the elements are compared with `compare_vals`, with types ordered according to
 //   `undef < boolean < number < string < list`.  Comparison of lists is recursive. 
 //   When comparing vectors, homogeneous or not, the parameter `idx` may be used to select the components to compare.
 //   Note that homogeneous lists of vectors may contain mixed types provided that for any two list elements
 //   list[i] and list[j] satisfies  type(list[i][k])==type(list[j][k]) for all k. 
 //   Strings are allowed as any list element and are compared with the native operators although no substring
@@ -693,21 +796,23 @@
         : is_undef(idx) ? _sort_vectors(list)
         : assert( _valid_idx(idx) , "Invalid indices.")
           _sort_vectors(list,[for(i=idx) i])        
     : _sort_general(list,idx);
         
 
 // Function: sortidx()
-// Usage:
-//   idxlist = sortidx(list, [idx]);
+// Synopsis: Returns a list of sorted indices into a list.
 // Topics: List Handling
 // See Also: shuffle(), sort(), group_sort(), unique(), unique_count()
+// Usage:
+//   idxlist = sortidx(list, [idx]);
 // Description:
 //   Given a list, sort it as function `sort()`, and returns
 //   a list of indexes into the original list in that sorted order.
+//   The sort is stable, so equivalent items will not change order.  
 //   If you iterate the returned list in order, and use the list items
 //   to index into the original list, you will be iterating the original
 //   values in sorted order.
 // Arguments:
 //   list = The list to sort.
 //   idx = If given, do the comparison based just on the specified index, range or list of indices.  
 // Example:
@@ -722,15 +827,14 @@
 //       ["qux", 23, [1,1,1], true]
 //   ];
 //   idxs1 = sortidx(lst, idx=1); // Returns: [3,0,2,1]
 //   idxs2 = sortidx(lst, idx=0); // Returns: [1,2,0,3]
 //   idxs3 = sortidx(lst, idx=[1,3]); // Returns: [3,0,2,1]
 function sortidx(list, idx=undef) = 
     assert(is_list(list)||is_string(list), "Invalid list." )
-    !is_list(list) || len(list)<=1 ? list :
     is_homogeneous(list,1)
     ?   let( 
             size = list_shape(list[0]),
             aug  = ! (size==0 || len(size)==1) ? 0 // for general sorting
                    : [for(i=[0:len(list)-1]) concat(i,list[i])], // for scalar or vector sorting
             lidx = size==0? [1] :                                // scalar sorting
                    len(size)==1 
@@ -747,18 +851,19 @@
         :   _sort_general(list,idx,indexed=true)
     : _sort_general(list,idx,indexed=true);
 
 
 
 
 // Function: group_sort()
+// Synopsis: Returns a sorted list of groups of values.
+// Topics: List Handling
+// See Also: group_data(), shuffle(), sort(), sortidx(), unique(), unique_count()
 // Usage:
 //   ulist = group_sort(list,[idx]);
-// Topics: List Handling
-// See Also: shuffle(), sort(), sortidx(), unique(), unique_count()
 // Description:
 //   Given a list of numbers, sorts the list into a sequence of lists, where each list contains any repeated values.
 //   If there are no repeated values the output will be a list of singleton lists.  
 //   If you apply {{flatten()}} to the output, the result will be a simple sorted list.  
 //   .
 //   When the input is a list of lists, the sorting is done based on index `idx` of the entries in `list`.
 //   In this case, `list[i][idx]` must be a number for every `i`, and the entries in `list` are grouped
@@ -780,17 +885,19 @@
     assert( [for(entry=list) if(!is_list(entry) || len(entry)<idx || !is_num(entry[idx]) ) 1]==[],
         "Some entry of the list is a list shorter than `idx` or the indexed entry of it is not a number.")
     _group_sort_by_index(list,idx);
         
 
 
 // Function: group_data()
+// Synopsis: Groups list data by integer group numbers.
+// Topics: List Handling
+// See Also: group_sort(), shuffle(), sort(), sortidx(), unique(), unique_count()
 // Usage:
 //   groupings = group_data(groups, values);
-// Topics: List Handling
 // Description:
 //   Given a list of integer group numbers, and an equal-length list of values,
 //   returns a list of groups with the values sorted into the corresponding groups.
 //   Ie: if you have a groups index list of [2,3,2] and values of ["A","B","C"], then
 //   the values "A" and "C" will be put in group 2, and "B" will be in group 3.
 //   Groups that have no values grouped into them will be an empty list.  So the
 //   above would return [[], [], ["A","C"], ["B"]]
@@ -818,14 +925,17 @@
             for (j = [a:1:g0[0][0]-1]) [],
             [for (g1 = g0) g1[1]]
         ]
     ];
 
 
 // Function: list_smallest()
+// Synopsis: Returns the `k` smallest values in the list, in arbitrary order.
+// Topics: List Handling
+// See Also: group_sort(), shuffle(), sort(), sortidx(), unique(), unique_count()
 // Usage:
 //   small = list_smallest(list, k)
 // Description:
 //   Returns a set of the k smallest items in list in arbitrary order.  The items must be
 //   mutually comparable with native OpenSCAD comparison operations.  You will get "undefined operation"
 //   errors if you provide invalid input. 
 // Arguments:
@@ -841,8 +951,10 @@
     )
     len(smaller)   == k ? smaller :
     len(smaller)<k && len(smaller)+len(equal) >= k ? [ each smaller, for(i=[1:k-len(smaller)]) v ] :
     len(smaller)   >  k ? list_smallest(smaller, k) :
     let( bigger  = [for(li=list) if(li>v) li ] )
     concat(smaller, equal, list_smallest(bigger, k-len(smaller) -len(equal)));
 
+
+
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/constants.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/constants.scad`

 * *Files 10% similar despite different names*

```diff
@@ -11,14 +11,16 @@
 // a value that the user should never enter randomly;
 // result of `dd if=/dev/random bs=32 count=1 |base64` :
 _UNDEF="LRG+HX7dy89RyHvDlAKvb9Y04OTuaikpx205CTh8BSI";
 
 // Section: General Constants
 
 // Constant: $slop
+// Synopsis: The slop amount to make printed items fit closely. `0.0` by default.
+// Topics: Constants
 // Description:
 //   A number of printers, particularly FDM/FFF printers, tend to be a bit sloppy in their printing.
 //   This has made it so that some parts won't fit together without adding a bit of extra slop space.
 //   That is what the `$slop` value is for.  The value for this will vary from printer to printer.
 //   By default, we use a value of 0.00 so that parts should fit exactly for resin and other precision
 //   printers.  This value is measured in millimeters.  When making your own parts, you should add
 //   `$slop` to both sides of a hole that another part is to fit snugly into. For a loose fit, add
@@ -98,94 +100,106 @@
 //     xcopies(21) back(10.5) {
 //         back(1.8) text("$slop", size=1.5, halign="center");
 //         text("gap", size=1.5, halign="center");
 //     }
 //   }
 
 // Function: get_slop()
+// Synopsis: Returns the $slop value.
+// Topics: Slop
+// See Also: $slop
 // Usage:
 //    slop = get_slop();
 // Description:
 //    Returns the current $slop value, or the default value if the user did not set $slop.
 //    Always acess the `$slop` variable using this function.  
 function get_slop() = is_undef($slop) ? 0 : $slop;
 
 
 // Constant: INCH
+// Synopsis: A constant containing the  number of millimeters in an inch. `25.4`
+// Topics: Constants
 // Description:
 //   The number of millimeters in an inch.
 // Example(2D):
 //   square(2*INCH, center=true);
 // Example(3D):
 //   cube([4,3,2.5]*INCH, center=true);
 INCH = 25.4;
 
 
 
 // Section: Directional Vectors
 //   Vectors useful for `rotate()`, `mirror()`, and `anchor` arguments for `cuboid()`, `cyl()`, etc.
 
 // Constant: LEFT
+// Synopsis: The left-wards (X-) direction vector constant `[-1,0,0]`.
 // Topics: Constants, Vectors
 // See Also: RIGHT, FRONT, BACK, UP, DOWN, CENTER
 // Description: Vector pointing left.  [-1,0,0]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=LEFT);
 LEFT  = [-1,  0,  0];
 
 // Constant: RIGHT
+// Synopsis: The right-wards (X+) direction vector constant `[1,0,0]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, FRONT, BACK, UP, DOWN, CENTER
 // Description: Vector pointing right.  [1,0,0]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=RIGHT);
 RIGHT = [ 1,  0,  0];
 
 // Constant: FRONT
 // Aliases: FWD, FORWARD
+// Synopsis: The front-wards (Y-) direction vector constant `[0,-1,0]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, RIGHT, BACK, UP, DOWN, CENTER
 // Description: Vector pointing forward.  [0,-1,0]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=FRONT);
 FRONT = [ 0, -1,  0];
 FWD = FRONT;
 FORWARD = FRONT;
 
 // Constant: BACK
+// Synopsis: The back-wards (Y+) direction vector constant `[0,1,0]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, RIGHT, FRONT, UP, DOWN, CENTER
 // Description: Vector pointing back.  [0,1,0]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=BACK);
 BACK  = [ 0,  1,  0];
 
 // Constant: BOTTOM
 // Aliases: BOT, DOWN
+// Synopsis: The down-wards (Z-) direction vector constant `[0,0,-1]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, RIGHT, FRONT, BACK, UP, CENTER
 // Description: Vector pointing down.  [0,0,-1]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=BOTTOM);
 BOTTOM  = [ 0,  0, -1];
 BOT = BOTTOM;
 DOWN = BOTTOM;
 
 // Constant: TOP
 // Aliases: UP
+// Synopsis: The top-wards (Z+) direction vector constant `[0,0,1]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, RIGHT, FRONT, BACK, DOWN, CENTER
 // Description: Vector pointing up.  [0,0,1]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=TOP);
 TOP = [ 0,  0,  1];
 UP = TOP;
 
 // Constant: CENTER
 // Aliases: CTR, CENTRE
+// Synopsis: The center vector constant `[0,0,0]`.
 // Topics: Constants, Vectors
 // See Also: LEFT, RIGHT, FRONT, BACK, UP, DOWN
 // Description: Zero vector.  Centered.  [0,0,0]
 // Example(3D): Usage with `anchor`
 //   cuboid(20, anchor=CENTER);
 CENTER = [ 0,  0,  0];  // Centered zero vector.
 CTR = CENTER;
@@ -194,45 +208,51 @@
 
 // Section: Line specifiers
 //   Used by functions in geometry.scad for specifying whether two points
 //   are treated as an unbounded line, a ray with one endpoint, or a segment
 //   with two endpoints.  
 
 // Constant: SEGMENT
+// Synopsis: A constant for specifying a line segment in various geometry.scad functions.  `[true,true]`
 // Topics: Constants, Lines
 // See Also: RAY, LINE
 // Description: Treat a line as a segment.  [true, true]
 // Example: Usage with line_intersection:
 //    line1 = 10*[[9, 4], [5, 7]];
 //    line2 = 10*[[2, 3], [6, 5]];
 //    isect = line_intersection(line1, line2, SEGMENT, SEGMENT);
 SEGMENT = [true,true];
 
 
 // Constant: RAY
+// Synopsis: A constant for specifying a ray line in various geometry.scad functions.  `[true,false]`
 // Topics: Constants, Lines
 // See Also: SEGMENT, LINE
 // Description: Treat a line as a ray, based at the first point.  [true, false]
 // Example: Usage with line_intersection:
 //    line = [[-30,0],[30,30]];
 //    pt = [40,25];
 //    closest = line_closest_point(line,pt,RAY);
 RAY = [true, false];
 
 
 // Constant: LINE
+// Synopsis: A constant for specifying an unbounded line in various geometry.scad functions.  `[false,false]`
 // Topics: Constants, Lines
 // See Also: RAY, SEGMENT
 // Description: Treat a line as an unbounded line.  [false, false]
 // Example: Usage with line_intersection:
 //    line1 = 10*[[9, 4], [5, 7]];
 //    line2 = 10*[[2, 3], [6, 5]];
 //    isect = line_intersection(line1, line2, LINE, SEGMENT);
 LINE = [false, false];
 
 
 // Constant: IDENT
+// Synopsis: A constant containing the 3D identity transformation matrix.
+// Topics: Affine, Matrices, Transforms
+// See Also: ident()
 // Description: Identity transformation matrix for three-dimensional transforms.  Equal to `ident(4)`.  
 IDENT=ident(4);
 
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/coords.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/coords.scad`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/cubetruss.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/cubetruss.scad`

 * *Files 6% similar despite different names*

```diff
@@ -12,104 +12,169 @@
 $cubetruss_strut_size = 3;
 $cubetruss_bracing = true;
 $cubetruss_clip_thickness = 1.6;
 
 
 // Section: Cube Trusses
 
-// Function: cubetruss_dist()
+// Module: cubetruss()
+// Synopsis: Creates a multi-cube straight cubetruss shape.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_dist(cubes, gaps, [size], [strut]);
+//   cubetruss(extents, [clips=], [bracing=], [size=], [strut=], [clipthick=], ...) [ATTACHMENTS];
 // Description:
-//   Function to calculate the length of a cubetruss truss.
+//   Creates a cubetruss truss, assembled out of one or more cubical segments.
 // Arguments:
-//   cubes = The number of cubes along the truss's length.
-//   gaps = The number of extra strut widths to add in, corresponding to each time a truss butts up against another.
+//   extents = The number of cubes in length to make the truss.  If given as a [X,Y,Z] vector, specifies the number of cubes in each dimension.
+//   clips = List of vectors pointing towards the sides to add clips to.
+//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
-// Topics: Trusses
-function cubetruss_dist(cubes=0, gaps=0, size, strut) =
-    let(
-        size = is_undef(size)? $cubetruss_size : size,
-        strut = is_undef(strut)? $cubetruss_strut_size : strut
-    ) cubes*(size-strut)+gaps*strut;
+//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
+//   ---
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+// Topics: Attachable, Trusses
+// Examples:
+//   cubetruss(extents=3);
+//   cubetruss(extents=3, clips=FRONT);
+//   cubetruss(extents=3, clips=[FRONT,BACK]);
+//   cubetruss(extents=[2,3]);
+//   cubetruss(extents=[1,4,2]);
+//   cubetruss(extents=[1,4,2], bracing=false);
+module cubetruss(extents=6, clips=[], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
+    clips = is_vector(clips)? [clips] : clips;
+    size = is_undef(size)? $cubetruss_size : size;
+    strut = is_undef(strut)? $cubetruss_strut_size : strut;
+    bracing = is_undef(bracing)? $cubetruss_bracing : bracing;
+    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;
+    extents = is_vector(extents)? point3d(extents,fill=1) : [1,extents,1];
+    w = extents[0];
+    l = extents[1];
+    h = extents[2];
+    s = [cubetruss_dist(w,1), cubetruss_dist(l,1), cubetruss_dist(h,1)];
+    attachable(anchor,spin,orient, size=s) {
+        union() {
+            for (zrow = [0:h-1]) {
+                up((zrow-(h-1)/2)*(size-strut)) {
+                    for (xcol = [0:w-1]) {
+                        right((xcol-(w-1)/2)*(size-strut)) {
+                            for (ycol = [0:l-1]) {
+                                back((ycol-(l-1)/2)*(size-strut)) {
+                                    cubetruss_segment(size=size, strut=strut, bracing=bracing);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if (clipthick > 0) {
+                for (vec = clips) {
+                    exts = v_abs(rot(from=FWD, to=vec, p=extents));
+                    rot(from=FWD,to=vec) {
+                        for (zrow = [0:1:exts.z-1]) {
+                            up((zrow-(exts.z-1)/2)*(size-strut)) {
+                                fwd((exts.y*(size-strut)+strut)/2) {
+                                    cubetruss_clip(size=size, strut=strut, extents=exts.x, clipthick=clipthick);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        children();
+    }
+}
 
 
-// Module: cubetruss_segment()
+// Module: cubetruss_corner()
+// Synopsis: Creates a multi-cube corner cubetruss shape.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_segment([size], [strut], [bracing]);
+//   cubetruss_corner(h, extents, [bracing=], [size=], [strut=], [clipthick=]);
 // Description:
-//   Creates a single cubetruss cube segment.
+//   Creates a corner cubetruss with extents jutting out in one or more directions.
 // Arguments:
+//   h = The number of cubes high to make the base and horizontal extents.
+//   extents = The number of cubes to extend beyond the corner.  If given as a vector of cube counts, gives the number of cubes to extend right, back, left, front, and up in order.  If the vector is shorter than length 5 the extra cube counts are taken to be zero.  
+//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
-//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)
+//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
-//   cubetruss_segment(bracing=false);
-//   cubetruss_segment(bracing=true);
-//   cubetruss_segment(strut=4);
-//   cubetruss_segment(size=40);
-module cubetruss_segment(size, strut, bracing, anchor=CENTER, spin=0, orient=UP) {
+//   cubetruss_corner(extents=2);
+//   cubetruss_corner(extents=2, h=2);
+//   cubetruss_corner(extents=[3,3,0,0,2]);
+//   cubetruss_corner(extents=[3,0,3,0,2]);
+//   cubetruss_corner(extents=[3,3,3,3,2]);
+module cubetruss_corner(h=1, extents=[1,1,0,0,1], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
     size = is_undef(size)? $cubetruss_size : size;
     strut = is_undef(strut)? $cubetruss_strut_size : strut;
     bracing = is_undef(bracing)? $cubetruss_bracing : bracing;
-    h = size;
-    crossthick = strut/sqrt(2);
-    voffset = 0.333;
-    attachable(anchor,spin,orient, size=[size,size,size]) {
-        render(convexity=10)
+    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;
+    exts = is_vector(extents)? list_pad(extents,5,fill=0) : [extents, extents, 0, 0, extents];
+    dummy = assert(len(exts)==5, "Input extents must be a scalar or vector with length 5 or less.");
+    s = [cubetruss_dist(exts[0]+1+exts[2],1), cubetruss_dist(exts[1]+1+exts[3],1), cubetruss_dist(h+exts[4],1)];
+    offset = [cubetruss_dist(exts[0]-exts[2],0), cubetruss_dist(exts[1]-exts[3],0), cubetruss_dist(h+exts[4]-1,0)]/2;
+    attachable(anchor,spin,orient, size=s, offset=offset) {
         union() {
-            difference() {
-                // Start with a cube.
-                cube([size, size, h], center=true);
-
-                cube([size-strut*2, size-strut*2, h-strut*2], center=true);
-
-                // Hollow out octogons in X and Y axes.
-                zrot_copies([0,90]) {
-                    xrot(90) zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);
+            for (zcol = [0:h-1]) {
+                up((size-strut)*zcol) {
+                    cubetruss_segment(size=size, strut=strut, bracing=bracing);
                 }
-
-                // Hollow out octogon vertically.
-                zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);
             }
-
-            // Interior cross-supports
-            if (bracing) {
-                for (i = [-1,1]) {
-                    zrot(i*45) {
-                        difference() {
-                            cube([crossthick, (size-strut)*sqrt(2), h], center=true);
-                            up(i*voffset) {
-                                yscale(1.3) {
-                                    yrot(90) {
-                                        zrot(180/6) {
-                                            cylinder(h=crossthick+1, d=(min(h,size)-2*strut)/cos(180/6)-2*voffset, center=true, $fn=6);
-                                        }
+            for (dir = [0:3]) {
+                if (exts[dir] != undef && exts[dir] > 0) {
+                    zrot(dir*90) {
+                        for (zcol = [0:h-1]) {
+                            up((size-strut+0.01)*zcol) {
+                                for (i = [1:exts[dir]]) {
+                                    right((size-strut+0.01)*i) cubetruss_segment(size=size, strut=strut, bracing=bracing);
+                                }
+                                if (clipthick > 0) {
+                                    right(exts[dir]*(size-strut)+size/2) {
+                                        zrot(90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);
                                     }
                                 }
                             }
                         }
                     }
                 }
             }
+            if (exts[4] != undef && exts[4] > 0) {
+                for (i = [1:exts[4]]) {
+                    up((size-strut+0.01)*(i+h-1)) cubetruss_segment(size=size, strut=strut, bracing=bracing);
+                }
+                if (clipthick > 0) {
+                    up((exts[4]+h-1)*(size-strut)+size/2) {
+                        xrot(-90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);
+                    }
+                }
+            }
         }
         children();
     }
 }
 
 
 // Module: cubetruss_support()
+// Synopsis: Creates a cubetruss support structure shape.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_support([size], [strut]);
+//   cubetruss_support([size=], [strut=], [extents=]) [ATTACHMENTS];
 // Description:
 //   Creates a single cubetruss support.
 // Arguments:
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
 //   extents = If given as an integer, specifies the number of vertical segments for the support.  If given as a list of 3 integers, specifies the number of segments in the X, Y, and Z directions.  Default: 1.
 //   ---
@@ -129,17 +194,18 @@
 //   cubetruss_support(strut=4);
 // Example(VPT=[0,0,0],VPD=260):
 //   cubetruss_support(extents=2) show_anchors();
 module cubetruss_support(size, strut, extents=1, anchor=CENTER, spin=0, orient=UP) {
     extents = is_num(extents)? [1,1,extents] : extents;
     size = is_undef(size)? $cubetruss_size : size;
     strut = is_undef(strut)? $cubetruss_strut_size : strut;
-    assert(is_int(extents.x) && extents.x > 0);
-    assert(is_int(extents.y) && extents.y > 0);
-    assert(is_int(extents.z) && extents.z > 0);
+    check =
+      assert(is_int(extents.x) && extents.x > 0)
+      assert(is_int(extents.y) && extents.y > 0)
+      assert(is_int(extents.z) && extents.z > 0);
     w = (size-strut) * extents.x + strut;
     l = (size-strut) * extents.y + strut;
     h = (size-strut) * extents.z + strut;
     attachable(anchor,spin,orient, size=[w,l,h], size2=[l,0], shift=[0,l/2], axis=DOWN) {
         xcopies(size-strut, n=extents.x) {
             difference() {
                 half_of(BACK/extents.y + UP/extents.z, s=size*(max(extents)+1))
@@ -159,89 +225,32 @@
             }
         }
         children();
     }
 }
 
 
-// Module: cubetruss_clip()
-// Usage:
-//   cubetruss_clip(extents, [size], [strut], [clipthick]);
-// Description:
-//   Creates a pair of clips to add onto the end of a truss.
-// Arguments:
-//   extents = How many cubes to separate the clips by.
-//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
-//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
-//   clipthick = The thickness of the clip.  Default: `$cubetruss_clip_thickness` (usually 1.6)
-//   ---
-//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
-//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// Topics: Attachable, Trusses
-// Examples:
-//   cubetruss_clip(extents=2);
-//   cubetruss_clip(extents=1);
-//   cubetruss_clip(clipthick=2.5);
-module cubetruss_clip(extents=1, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
-    size = is_undef(size)? $cubetruss_size : size;
-    strut = is_undef(strut)? $cubetruss_strut_size : strut;
-    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;
-    cliplen = strut * 2.6;
-    clipheight = min(size+strut, size/3+2*strut*2.6);
-    clipsize = 0.5;
-    s = [extents*(size-strut)+strut+2*clipthick, strut*2, clipheight-2*strut];
-    attachable(anchor,spin,orient, size=s) {
-        xflip_copy(offset=(extents*(size-strut)+strut)/2) {
-            difference() {
-                union() {
-                    difference() {
-                        right(clipthick/2-0.01) {
-                            back(strut) {
-                                difference() {
-                                    xrot(90) prismoid([clipthick, clipheight], [clipthick, clipheight-cliplen*2], h=cliplen);
-                                    right(clipthick/2) chamfer_edge_mask(l=clipheight+0.1, chamfer=clipthick);
-                                }
-                            }
-                        }
-                        fwd(strut*3/2) {
-                            cube([get_slop(), strut*3, size], center=true);
-                        }
-                    }
-                    right(get_slop()/2+0.01) {
-                        fwd(strut*1.25+get_slop()) {
-                            yrot(-90) prismoid([clipheight-cliplen*2, strut/2], [clipheight-cliplen*2-2*clipsize, strut/2], h=clipsize+0.01);
-                        }
-                    }
-                }
-                fwd(strut*1.6) {
-                    left(clipsize) {
-                        yscale(1.5) chamfer_edge_mask(l=size+1, chamfer=clipsize+clipthick/3);
-                    }
-                }
-                zcopies(clipheight-strut) cube([clipthick*3, cliplen*2, strut], center=true);
-                zcopies(clipheight-2*strut) right(clipthick) chamfer_edge_mask(l=cliplen*2, chamfer=clipthick, orient=BACK);
-            }
-        }
-        children();
-    }
-}
 
+// Section: Cubetruss Support
 
 // Module: cubetruss_foot()
+// Synopsis: Creates a foot that can connect two cubetrusses.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_foot(w, [size], [strut], [clipthick]);
+//   cubetruss_foot(w, [size=], [strut=], [clipthick=]) [ATTACHMENTS];
 // Description:
 //   Creates a foot that can be clipped onto the bottom of a truss for support.
 // Arguments:
 //   w = The number of cube segments to span between the clips.  Default: 1
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
 //   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
+//   $slop = make fit looser to allow for printer overextrusion
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
 //   cubetruss_foot(w=1);
 //   cubetruss_foot(w=3);
@@ -300,25 +309,29 @@
         }
         children();
     }
 }
 
 
 // Module: cubetruss_joiner()
+// Synopsis: Creates a joiner that can connect two cubetrusses end-to-end.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_joiner([w], [vert], [size], [strut], [clipthick]);
+//   cubetruss_joiner([w=], [vert=], [size=], [strut=], [clipthick=]) [ATTACHMENTS];
 // Description:
 //   Creates a part to join two cubetruss trusses end-to-end.
 // Arguments:
 //   w = The number of cube segments to span between the clips.  Default: 1
 //   vert = If true, add vertical risers to clip to the ends of the cubetruss trusses.  Default: true
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
 //   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
+//   $slop = Make fit looser by this amount to allow for printer overextrusion
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
 //   cubetruss_joiner(w=1, vert=false);
 //   cubetruss_joiner(w=1, vert=true);
@@ -367,24 +380,28 @@
         }
         children();
     }
 }
 
 
 // Module: cubetruss_uclip()
+// Synopsis: Creates a joiner that can connect two cubetrusses end-to-end.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_uclip(dual, [size], [strut], [clipthick]);
+//   cubetruss_uclip(dual, [size=], [strut=], [clipthick=]) [ATTACHMENTS];
 // Description:
 //   Creates a small clip that can snap around one or two adjacent struts.
 // Arguments:
 //   dual = If true, create a clip to clip around two adjacent struts.  If false, just fit around one strut.  Default: true
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
 //   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
+//   $slop = Make fit looser by this amount
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
 //   cubetruss_uclip(dual=false);
 //   cubetruss_uclip(dual=true);
@@ -411,152 +428,173 @@
             }
         }
         children();
     }
 }
 
 
-// Module: cubetruss()
+
+// Section: Cubetruss Primitives
+
+// Module: cubetruss_segment()
+// Synopsis: Creates a single cubetruss cube.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss(extents, [clips], [bracing], [size], [strut], [clipthick]);
+//   cubetruss_segment([size=], [strut=], [bracing=]);
 // Description:
-//   Creates a cubetruss truss, assembled out of one or more cubical segments.
+//   Creates a single cubetruss cube segment.
 // Arguments:
-//   extents = The number of cubes in length to make the truss.  If given as a [X,Y,Z] vector, specifies the number of cubes in each dimension.
-//   clips = List of vectors pointing towards the sides to add clips to.
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
 //   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)
-//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
-//   cubetruss(extents=3);
-//   cubetruss(extents=3, clips=FRONT);
-//   cubetruss(extents=3, clips=[FRONT,BACK]);
-//   cubetruss(extents=[2,3]);
-//   cubetruss(extents=[1,4,2]);
-//   cubetruss(extents=[1,4,2], bracing=false);
-module cubetruss(extents=6, clips=[], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
-    clips = is_vector(clips)? [clips] : clips;
+//   cubetruss_segment(bracing=false);
+//   cubetruss_segment(bracing=true);
+//   cubetruss_segment(strut=4);
+//   cubetruss_segment(size=40);
+module cubetruss_segment(size, strut, bracing, anchor=CENTER, spin=0, orient=UP) {
     size = is_undef(size)? $cubetruss_size : size;
     strut = is_undef(strut)? $cubetruss_strut_size : strut;
     bracing = is_undef(bracing)? $cubetruss_bracing : bracing;
-    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;
-    extents = is_vector(extents)? point3d(extents,fill=1) : [1,extents,1];
-    w = extents[0];
-    l = extents[1];
-    h = extents[2];
-    s = [cubetruss_dist(w,1), cubetruss_dist(l,1), cubetruss_dist(h,1)];
-    attachable(anchor,spin,orient, size=s) {
+    h = size;
+    crossthick = strut/sqrt(2);
+    voffset = 0.333;
+    attachable(anchor,spin,orient, size=[size,size,size]) {
+        render(convexity=10)
         union() {
-            for (zrow = [0:h-1]) {
-                up((zrow-(h-1)/2)*(size-strut)) {
-                    for (xcol = [0:w-1]) {
-                        right((xcol-(w-1)/2)*(size-strut)) {
-                            for (ycol = [0:l-1]) {
-                                back((ycol-(l-1)/2)*(size-strut)) {
-                                    cubetruss_segment(size=size, strut=strut, bracing=bracing);
-                                }
-                            }
-                        }
-                    }
+            difference() {
+                // Start with a cube.
+                cube([size, size, h], center=true);
+
+                cube([size-strut*2, size-strut*2, h-strut*2], center=true);
+
+                // Hollow out octogons in X and Y axes.
+                zrot_copies([0,90]) {
+                    xrot(90) zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);
                 }
+
+                // Hollow out octogon vertically.
+                zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);
             }
-            if (clipthick > 0) {
-                for (vec = clips) {
-                    exts = v_abs(rot(from=FWD, to=vec, p=extents));
-                    rot(from=FWD,to=vec) {
-                        for (zrow = [0:1:exts.z-1]) {
-                            up((zrow-(exts.z-1)/2)*(size-strut)) {
-                                fwd((exts.y*(size-strut)+strut)/2) {
-                                    cubetruss_clip(size=size, strut=strut, extents=exts.x, clipthick=clipthick);
+
+            // Interior cross-supports
+            if (bracing) {
+                for (i = [-1,1]) {
+                    zrot(i*45) {
+                        difference() {
+                            cube([crossthick, (size-strut)*sqrt(2), h], center=true);
+                            up(i*voffset) {
+                                yscale(1.3) {
+                                    yrot(90) {
+                                        zrot(180/6) {
+                                            cylinder(h=crossthick+1, d=(min(h,size)-2*strut)/cos(180/6)-2*voffset, center=true, $fn=6);
+                                        }
+                                    }
                                 }
                             }
                         }
                     }
                 }
             }
         }
         children();
     }
 }
 
 
-// Module: cubetruss_corner()
+// Module: cubetruss_clip()
+// Synopsis: Creates a clip for the end of a cubetruss to snap-lock it to another cubetruss.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
 // Usage:
-//   cubetruss_corner(h, extents, [bracing], [size], [strut], [clipthick]);
+//   cubetruss_clip(extents, [size=], [strut=], [clipthick=]) [ATTACHMENTS];
 // Description:
-//   Creates a corner cubetruss with extents jutting out in one or more directions.
+//   Creates a pair of clips to add onto the end of a truss.
 // Arguments:
-//   h = The number of cubes high to make the base and horizontal extents.
-//   extents = The number of cubes to extend beyond the corner.  If given as a vector of cube counts, gives the number of cubes to extend right, back, left, front, and up in order.  If the vector is shorter than length 5 the extra cube counts are taken to be zero.  
+//   extents = How many cubes to separate the clips by.
 //   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
 //   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
-//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)
-//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)
+//   clipthick = The thickness of the clip.  Default: `$cubetruss_clip_thickness` (usually 1.6)
 //   ---
+//   $slop = allowance for printer overextrusion
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Topics: Attachable, Trusses
 // Examples:
-//   cubetruss_corner(extents=2);
-//   cubetruss_corner(extents=2, h=2);
-//   cubetruss_corner(extents=[3,3,0,0,2]);
-//   cubetruss_corner(extents=[3,0,3,0,2]);
-//   cubetruss_corner(extents=[3,3,3,3,2]);
-module cubetruss_corner(h=1, extents=[1,1,0,0,1], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
+//   cubetruss_clip(extents=2);
+//   cubetruss_clip(extents=1);
+//   cubetruss_clip(clipthick=2.5);
+module cubetruss_clip(extents=1, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {
     size = is_undef(size)? $cubetruss_size : size;
     strut = is_undef(strut)? $cubetruss_strut_size : strut;
-    bracing = is_undef(bracing)? $cubetruss_bracing : bracing;
     clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;
-    exts = is_vector(extents)? list_pad(extents,5,fill=0) : [extents, extents, 0, 0, extents];
-    dummy = assert(len(exts)==5, "Input extents must be a scalar or vector with length 5 or less.");
-    s = [cubetruss_dist(exts[0]+1+exts[2],1), cubetruss_dist(exts[1]+1+exts[3],1), cubetruss_dist(h+exts[4],1)];
-    offset = [cubetruss_dist(exts[0]-exts[2],0), cubetruss_dist(exts[1]-exts[3],0), cubetruss_dist(h+exts[4]-1,0)]/2;
-    attachable(anchor,spin,orient, size=s, offset=offset) {
-        union() {
-            for (zcol = [0:h-1]) {
-                up((size-strut)*zcol) {
-                    cubetruss_segment(size=size, strut=strut, bracing=bracing);
-                }
-            }
-            for (dir = [0:3]) {
-                if (exts[dir] != undef && exts[dir] > 0) {
-                    zrot(dir*90) {
-                        for (zcol = [0:h-1]) {
-                            up((size-strut+0.01)*zcol) {
-                                for (i = [1:exts[dir]]) {
-                                    right((size-strut+0.01)*i) cubetruss_segment(size=size, strut=strut, bracing=bracing);
-                                }
-                                if (clipthick > 0) {
-                                    right(exts[dir]*(size-strut)+size/2) {
-                                        zrot(90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);
-                                    }
+    cliplen = strut * 2.6;
+    clipheight = min(size+strut, size/3+2*strut*2.6);
+    clipsize = 0.5;
+    s = [extents*(size-strut)+strut+2*clipthick, strut*2, clipheight-2*strut];
+    attachable(anchor,spin,orient, size=s) {
+        xflip_copy(offset=(extents*(size-strut)+strut)/2) {
+            difference() {
+                union() {
+                    difference() {
+                        right(clipthick/2-0.01) {
+                            back(strut) {
+                                difference() {
+                                    xrot(90) prismoid([clipthick, clipheight], [clipthick, clipheight-cliplen*2], h=cliplen);
+                                    right(clipthick/2) chamfer_edge_mask(l=clipheight+0.1, chamfer=clipthick);
                                 }
                             }
                         }
+                        fwd(strut*3/2) {
+                            cube([get_slop(), strut*3, size], center=true);
+                        }
+                    }
+                    right(get_slop()/2+0.01) {
+                        fwd(strut*1.25+get_slop()) {
+                            yrot(-90) prismoid([clipheight-cliplen*2, strut/2], [clipheight-cliplen*2-2*clipsize, strut/2], h=clipsize+0.01);
+                        }
                     }
                 }
-            }
-            if (exts[4] != undef && exts[4] > 0) {
-                for (i = [1:exts[4]]) {
-                    up((size-strut+0.01)*(i+h-1)) cubetruss_segment(size=size, strut=strut, bracing=bracing);
-                }
-                if (clipthick > 0) {
-                    up((exts[4]+h-1)*(size-strut)+size/2) {
-                        xrot(-90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);
+                fwd(strut*1.6) {
+                    left(clipsize) {
+                        yscale(1.5) chamfer_edge_mask(l=size+1, chamfer=clipsize+clipthick/3);
                     }
                 }
+                zcopies(clipheight-strut) cube([clipthick*3, cliplen*2, strut], center=true);
+                zcopies(clipheight-2*strut) right(clipthick) chamfer_edge_mask(l=cliplen*2, chamfer=clipthick, orient=BACK);
             }
         }
         children();
     }
 }
 
 
+// Function: cubetruss_dist()
+// Synopsis: Returns the length of a cubetruss truss.
+// Topics: Trusses, CubeTruss, FDM Optimized, Parts
+// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()
+// Usage:
+//   length = cubetruss_dist(cubes, [gaps], [size=], [strut=]);
+// Description:
+//   Function to calculate the length of a cubetruss truss.
+// Arguments:
+//   cubes = The number of cubes along the truss's length.
+//   gaps = The number of extra strut widths to add in, corresponding to each time a truss butts up against another.
+//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)
+//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)
+// Topics: Trusses
+function cubetruss_dist(cubes=0, gaps=0, size, strut) =
+    let(
+        size = is_undef(size)? $cubetruss_size : size,
+        strut = is_undef(strut)? $cubetruss_strut_size : strut
+    ) cubes*(size-strut)+gaps*strut;
+
+
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/drawing.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/drawing.scad`

 * *Files 2% similar despite different names*

```diff
@@ -13,23 +13,34 @@
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Line Drawing
 
 // Module: stroke()
+// Synopsis: Draws a line along a path or region boundry.
+// Topics: Paths (2D), Paths (3D), Drawing Tools
+// See Also: offset_stroke(), path_sweep()
 // Usage:
 //   stroke(path, [width], [closed], [endcaps], [endcap_width], [endcap_length], [endcap_extent], [trim]);
 //   stroke(path, [width], [closed], [endcap1], [endcap2], [endcap_width1], [endcap_width2], [endcap_length1], [endcap_length2], [endcap_extent1], [endcap_extent2], [trim1], [trim2]);
-// Topics: Paths (2D), Paths (3D), Drawing Tools
 // Description:
 //   Draws a 2D or 3D path with a given line width.  Joints and each endcap can be replaced with
 //   various marker shapes, and can be assigned different colors.  If passed a region instead of
 //   a path, draws each path in the region as a closed polygon by default. If `closed=false` is
-//   given with a region, each subpath is drawn as an un-closed line path.
+//   given with a region or list of paths, then each path is drawn without the closing line segment.
+//   To facilitate debugging, stroke() accepts "paths" that have a single point.  These are drawn with
+//   the style of endcap1, but have their own scale parameter, `singleton_scale`, which defaults to 2
+//   so that singleton dots with endcap "round" are clearly visible.
+//   .
+//   In 2d the stroke module works by creating a sequence of rectangles (or trapezoids if line width varies) and
+//   filling in the gaps with rounded wedges.  This is fast and produces a good result.  In 3d the modules
+//   creates a cylinders (or cones) and fills the gaps with rounded wedges made using rotate_extrude.  This process will be slow for
+//   long paths due to the 3d unions, and the faces on sequential cylinders may not line up.  In many cases, {{path_sweep()}} will be
+//   a better choice, both running faster and producing superior output, when working in three dimensions. 
 // Figure(Med,NoAxes,2D,VPR=[0,0,0],VPD=250): Endcap Types
 //   cap_pairs = [
 //       ["butt",  "chisel" ],
 //       ["round", "square" ],
 //       ["line",  "cross"  ],
 //       ["x",     "diamond"],
 //       ["dot",   "block"  ],
@@ -80,16 +91,16 @@
 //   trim2 = Trim the the ending line segment by this much, to keep it from interfering with a custom endcap.
 //   color = If given, sets the color of the line segments, joints and endcap.
 //   endcap_color = If given, sets the color of both endcaps.  Overrides `color=` and `dots_color=`.
 //   endcap_color1 = If give, sets the color of the starting endcap.  Overrides `color=`, `dots_color=`,  and `endcap_color=`.
 //   endcap_color2 = If given, sets the color of the ending endcap.  Overrides `color=`, `dots_color=`,  and `endcap_color=`.
 //   joint_color = If given, sets the color of the joints.  Overrides `color=` and `dots_color=`.
 //   dots_color = If given, sets the color of the endcaps and joints.  Overrides `color=`.
+//   singleton_scale = Change the scale of the endcap shape drawn for singleton paths.  Default: 2.  
 //   convexity = Max number of times a line could intersect a wall of an endcap.
-//   hull = If true, use `hull()` to make higher quality joints between segments, at the cost of being much slower.  Default: true
 // Example(2D): Drawing a Path
 //   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];
 //   stroke(path, width=20);
 // Example(2D): Closing a Path
 //   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];
 //   stroke(path, width=20, endcaps=true, closed=true);
 // Example(2D): Fancy Arrow Endcaps
@@ -97,15 +108,15 @@
 //   stroke(path, width=10, endcaps="arrow2");
 // Example(2D): Modified Fancy Arrow Endcaps
 //   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];
 //   stroke(path, width=10, endcaps="arrow2", endcap_width=6, endcap_length=3, endcap_extent=2);
 // Example(2D): Mixed Endcaps
 //   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];
 //   stroke(path, width=10, endcap1="tail2", endcap2="arrow2");
-// Example(2D): Plotting Points
+// Example(2D): Plotting Points.  Setting endcap_angle to zero results in the weird arrow orientation. 
 //   path = [for (a=[0:30:360]) [a-180, 60*sin(a)]];
 //   stroke(path, width=3, joints="diamond", endcaps="arrow2", endcap_angle=0, endcap_width=5, joint_angle=0, joint_width=5);
 // Example(2D): Joints and Endcaps
 //   path = [for (a=[0:30:360]) [a-180, 60*sin(a)]];
 //   stroke(path, width=8, joints="dot", endcaps="arrow2");
 // Example(2D): Custom Endcap Shapes
 //   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];
@@ -144,37 +155,43 @@
 //   paths = [
 //       for (y=[-60:60:60]) [
 //           for (a=[-180:15:180])
 //           [a, 2*y+60*sin(a+y)]
 //       ]
 //   ];
 //   stroke(paths, closed=false, width=5);
+// Example(2D): Paths with a singleton.  Note that the singleton is not a single point, but a list containing a single point.  
+//   stroke([
+//           [[0,0],[1,1]],
+//           [[1.5,1.5]],
+//           [[2,2],[3,3]]
+//          ],width=0.2,closed=false,$fn=16);
 function stroke(
     path, width=1, closed,
     endcaps,       endcap1,        endcap2,        joints,       dots,
     endcap_width,  endcap_width1,  endcap_width2,  joint_width,  dots_width,
     endcap_length, endcap_length1, endcap_length2, joint_length, dots_length,
     endcap_extent, endcap_extent1, endcap_extent2, joint_extent, dots_extent,
     endcap_angle,  endcap_angle1,  endcap_angle2,  joint_angle,  dots_angle,
     endcap_color,  endcap_color1,  endcap_color2,  joint_color,  dots_color, color,
-    trim, trim1, trim2,
-    convexity=10, hull=true
+    trim, trim1, trim2, singleton_scale=2,
+    convexity=10
 ) = no_function("stroke");
 
 
 module stroke(
     path, width=1, closed,
     endcaps,       endcap1,        endcap2,        joints,       dots,
     endcap_width,  endcap_width1,  endcap_width2,  joint_width,  dots_width,
     endcap_length, endcap_length1, endcap_length2, joint_length, dots_length,
     endcap_extent, endcap_extent1, endcap_extent2, joint_extent, dots_extent,
     endcap_angle,  endcap_angle1,  endcap_angle2,  joint_angle,  dots_angle,
     endcap_color,  endcap_color1,  endcap_color2,  joint_color,  dots_color, color,
-    trim, trim1, trim2,
-    convexity=10, hull=true
+    trim, trim1, trim2, singleton_scale=2,
+    convexity=10
 ) {
     no_children($children);
     module setcolor(clr) {
         if (clr==undef) {
             children();
         } else {
             color(clr) children();
@@ -198,16 +215,16 @@
         cap=="arrow2"?  [3.50, 1.00, 0.14] :
         cap=="tail"?    [3.50, 0.47, 0.50] :
         cap=="tail2"?   [3.50, 0.28, 0.50] :
         is_path(cap)?   [0.00, 0.00, 0.00] :
         assert(false, str("Invalid cap or joint: ",cap));
 
     function _shape_path(cap,linewidth,w,l,l2) = (
-        (cap=="butt" || cap==false || cap==undef)? [] : 
-        (cap=="round" || cap==true)? scale([w,l], p=circle(d=1, $fn=max(8, segs(w/2)))) :
+        cap=="butt" || cap==false || cap==undef ? [] : 
+        cap=="round" || cap==true ? scale([w,l], p=circle(d=1, $fn=max(8, segs(w/2)))) :
         cap=="chisel"?  scale([w,l], p=circle(d=1,$fn=4)) :
         cap=="diamond"? circle(d=w,$fn=4) :
         cap=="square"?  scale([w,l], p=square(1,center=true)) :
         cap=="block"?   scale([w,l], p=square(1,center=true)) :
         cap=="dot"?     circle(d=w, $fn=max(12, segs(w*3/2))) :
         cap=="x"?       [for (a=[0:90:270]) each rot(a,p=[[w+l/2,w-l/2]/2, [w-l/2,w+l/2]/2, [0,l/2]]) ] :
         cap=="cross"?   [for (a=[0:90:270]) each rot(a,p=[[l,w]/2, [-l,w]/2, [-l,l]/2]) ] :
@@ -217,101 +234,101 @@
         cap=="tail"?    [[0,0], [w/2,l2], [w/2,l2-l], [0,-l], [-w/2,l2-l], [-w/2,l2]] :
         cap=="tail2"?   [[w/2,0], [w/2,-l], [0,-l-l2], [-w/2,-l], [-w/2,0]] :
         is_path(cap)? cap :
         assert(false, str("Invalid endcap: ",cap))
     ) * linewidth;
 
     closed = default(closed, is_region(path));
-    assert(is_bool(closed));
+    check1 = assert(is_bool(closed));
 
     dots = dots==true? "dot" : dots;
 
     endcap1 = first_defined([endcap1, endcaps, dots, "round"]);
     endcap2 = first_defined([endcap2, endcaps, if (!closed) dots, "round"]);
     joints  = first_defined([joints, dots, "round"]);
-    assert(is_bool(endcap1) || is_string(endcap1) || is_path(endcap1));
-    assert(is_bool(endcap2) || is_string(endcap2) || is_path(endcap2));
-    assert(is_bool(joints)  || is_string(joints)  || is_path(joints));
+    check2 = 
+      assert(is_bool(endcap1) || is_string(endcap1) || is_path(endcap1))
+      assert(is_bool(endcap2) || is_string(endcap2) || is_path(endcap2))
+      assert(is_bool(joints)  || is_string(joints)  || is_path(joints));
 
     endcap1_dflts = _shape_defaults(endcap1);
     endcap2_dflts = _shape_defaults(endcap2);
     joint_dflts   = _shape_defaults(joints);
 
     endcap_width1 = first_defined([endcap_width1, endcap_width, dots_width, endcap1_dflts[0]]);
     endcap_width2 = first_defined([endcap_width2, endcap_width, dots_width, endcap2_dflts[0]]);
     joint_width   = first_defined([joint_width, dots_width, joint_dflts[0]]);
-    assert(is_num(endcap_width1));
-    assert(is_num(endcap_width2));
-    assert(is_num(joint_width));
 
     endcap_length1 = first_defined([endcap_length1, endcap_length, dots_length, endcap1_dflts[1]*endcap_width1]);
     endcap_length2 = first_defined([endcap_length2, endcap_length, dots_length, endcap2_dflts[1]*endcap_width2]);
     joint_length   = first_defined([joint_length, dots_length, joint_dflts[1]*joint_width]);
-    assert(is_num(endcap_length1));
-    assert(is_num(endcap_length2));
-    assert(is_num(joint_length));
 
     endcap_extent1 = first_defined([endcap_extent1, endcap_extent, dots_extent, endcap1_dflts[2]*endcap_width1]);
     endcap_extent2 = first_defined([endcap_extent2, endcap_extent, dots_extent, endcap2_dflts[2]*endcap_width2]);
     joint_extent   = first_defined([joint_extent, dots_extent, joint_dflts[2]*joint_width]);
-    assert(is_num(endcap_extent1));
-    assert(is_num(endcap_extent2));
-    assert(is_num(joint_extent));
 
     endcap_angle1 = first_defined([endcap_angle1, endcap_angle, dots_angle]);
     endcap_angle2 = first_defined([endcap_angle2, endcap_angle, dots_angle]);
     joint_angle = first_defined([joint_angle, dots_angle]);
-    assert(is_undef(endcap_angle1)||is_num(endcap_angle1));
-    assert(is_undef(endcap_angle2)||is_num(endcap_angle2));
-    assert(is_undef(joint_angle)||is_num(joint_angle));
-
+    
+    check3 =
+      assert(all_nonnegative([endcap_length1]))
+      assert(all_nonnegative([endcap_length2]))
+      assert(all_nonnegative([joint_length]));
+      assert(all_nonnegative([endcap_extent1]))
+      assert(all_nonnegative([endcap_extent2]))
+      assert(all_nonnegative([joint_extent]));
+      assert(is_undef(endcap_angle1)||is_finite(endcap_angle1))
+      assert(is_undef(endcap_angle2)||is_finite(endcap_angle2))
+      assert(is_undef(joint_angle)||is_finite(joint_angle))
+      assert(all_positive([singleton_scale]))
+      assert(all_positive(width));
+      
     endcap_color1 = first_defined([endcap_color1, endcap_color, dots_color, color]);
     endcap_color2 = first_defined([endcap_color2, endcap_color, dots_color, color]);
     joint_color = first_defined([joint_color, dots_color, color]);
 
-    paths = force_region(path);
-    assert(is_region(paths),"The path argument must be a list of 2D or 3D points, or a region.");
-        for (path = paths) {
-        assert(is_list(path));
-        if (len(path) > 1) {
-            assert(is_path(path,[2,3]), "The path argument must be a list of 2D or 3D points, or a region.");
-        }
-        path = deduplicate( closed? close_path(path) : path );
+    // We want to allow "paths" with length 1, so we can't use the normal path/region checks
+    paths = is_matrix(path) ? [path] : path;
+    assert(is_list(paths),"The path argument must be a list of 2D or 3D points, or a region.");
+    for (path = paths) {
+        pathvalid = is_path(path,[2,3]) || same_shape(path,[[0,0]]) || same_shape(path,[[0,0,0]]);
+        assert(pathvalid,"The path argument must be a list of 2D or 3D points, or a region.");
+        path = deduplicate( closed? list_wrap(path) : path );
 
-        assert(is_num(width) || (is_vector(width) && len(width)==len(path)));
+        check4 = assert(is_num(width) || len(width)==len(path),
+                        "width must be a number or a vector the same length as the path (or all components of a region)");
         width = is_num(width)? [for (x=path) width] : width;
-        assert(all([for (w=width) w>0]));
 
         endcap_shape1 = _shape_path(endcap1, width[0], endcap_width1, endcap_length1, endcap_extent1);
         endcap_shape2 = _shape_path(endcap2, last(width), endcap_width2, endcap_length2, endcap_extent2);
 
         trim1 = width[0] * first_defined([
             trim1, trim,
             (endcap1=="arrow")? endcap_length1-0.01 :
             (endcap1=="arrow2")? endcap_length1*3/4 :
             0
         ]);
-        assert(is_num(trim1));
 
         trim2 = last(width) * first_defined([
             trim2, trim,
             (endcap2=="arrow")? endcap_length2-0.01 :
             (endcap2=="arrow2")? endcap_length2*3/4 :
             0
         ]);
-        assert(is_num(trim2));
-
+        check10 = assert(is_finite(trim1))
+                  assert(is_finite(trim2));
 
         if (len(path) == 1) {
             if (len(path[0]) == 2) {
                 // Endcap1
                 setcolor(endcap_color1) {
                     translate(path[0]) {
                         mat = is_undef(endcap_angle1)? ident(3) : zrot(endcap_angle1);
-                        multmatrix(mat) polygon(endcap_shape1);
+                        multmatrix(mat) polygon(scale(singleton_scale,endcap_shape1));
                     }
                 }
             } else {
                 // Endcap1
                 setcolor(endcap_color1) {
                     translate(path[0]) {
                         $fn = segs(width[0]/2);
@@ -329,15 +346,15 @@
                             }
                         }
                     }
                 }
             }
         } else {
             dummy=assert(trim1<path_length(path)-trim2, "Path is too short for endcap(s).  Try a smaller width, or set endcap_length to a smaller value.");
-            pathcut = _path_cut_points(path, [trim1, path_length(path)-trim2], closed=false);
+            pathcut = path_cut_points(path, [trim1, path_length(path)-trim2], closed=false);
             pathcut_su = _cut_to_seg_u_form(pathcut,path);
             path2 = _path_cut_getpaths(path, pathcut, closed=false)[1];
             widths = _path_select(width, pathcut_su[0][0], pathcut_su[0][1], pathcut_su[1][0], pathcut_su[1][1]);
             start_vec = path[0] - path[1];
             end_vec = last(path) - select(path,-2);
 
             if (len(path[0]) == 2) {
@@ -355,39 +372,38 @@
                 }
 
                 // Joints
                 setcolor(joint_color) {
                     for (i = [1:1:len(path2)-2]) {
                         $fn = quantup(segs(widths[i]/2),4);
                         translate(path2[i]) {
-                            if (joints != undef) {
+                            if (joints != undef && joints != "round") {
                                 joint_shape = _shape_path(
                                     joints, width[i],
                                     joint_width,
                                     joint_length,
                                     joint_extent
                                 );
                                 v1 = unit(path2[i] - path2[i-1]);
                                 v2 = unit(path2[i+1] - path2[i]);
                                 mat = is_undef(joint_angle)
                                   ? rot(from=BACK,to=v1)
                                   : zrot(joint_angle);
                                 multmatrix(mat) polygon(joint_shape);
-                            } else if (hull) {
-                                hull() {
-                                    rot(from=BACK, to=path2[i]-path2[i-1])
-                                        circle(d=widths[i]);
-                                    rot(from=BACK, to=path2[i+1]-path2[i])
-                                        circle(d=widths[i]);
-                                }
                             } else {
-                                rot(from=BACK, to=path2[i]-path2[i-1])
-                                    circle(d=widths[i]);
-                                rot(from=BACK, to=path2[i+1]-path2[i])
-                                    circle(d=widths[i]);
+                                // These are parallel to the path
+                                v1 = path2[i] - path2[i-1];
+                                v2 = path2[i+1] - path2[i];
+                                ang = modang(v_theta(v2) - v_theta(v1));
+                                // Need 90 deg offset to make wedge perpendicular to path, and the wedge
+                                // position depends on whether we turn left (ang<0) or right (ang>0)
+                                theta = v_theta(v1) - sign(ang)*90;
+                                ang_eps = 0.1;
+                                if (!approx(ang,0))
+                                  arc(d=widths[i], angle=[theta-ang_eps, theta+ang+ang_eps], wedge=true);
                             }
                         }
                     }
                 }
 
                 // Endcap1
                 setcolor(endcap_color1) {
@@ -435,15 +451,15 @@
                 }
 
                 // Joints
                 setcolor(joint_color) {
                     for (i = [1:1:len(path2)-2]) {
                         $fn = sides[i];
                         translate(path2[i]) {
-                            if (joints != undef) {
+                            if (joints != undef && joints != "round") {
                                 joint_shape = _shape_path(
                                     joints, width[i],
                                     joint_width,
                                     joint_length,
                                     joint_extent
                                 );
                                 multmatrix(rotmats[i] * xrot(180)) {
@@ -458,29 +474,26 @@
                                         rotate([90,0,joint_angle]) {
                                             linear_extrude(height=max(widths[i],0.001), center=true, convexity=convexity) {
                                                 polygon(joint_shape);
                                             }
                                         }
                                     }
                                 }
-                            } else if (hull) {
-                                hull(){
-                                    multmatrix(rotmats[i]) {
-                                        sphere(d=widths[i],style="aligned");
-                                    }
-                                    multmatrix(rotmats[i-1]) {
-                                        sphere(d=widths[i],style="aligned");
-                                    }
-                                }
                             } else {
-                                multmatrix(rotmats[i]) {
-                                    sphere(d=widths[i],style="aligned");
-                                }
-                                multmatrix(rotmats[i-1]) {
-                                    sphere(d=widths[i],style="aligned");
+                                corner = select(path2,i-1,i+1);
+                                axis = vector_axis(corner);
+                                ang = vector_angle(corner);
+                                if (!approx(ang,0)) {
+                                    frame_map(x=path2[i-1]-path2[i], z=-axis) {
+                                        zrot(90-0.5) {
+                                            rotate_extrude(angle=180-ang+1) {
+                                                arc(d=widths[i], start=-90, angle=180);
+                                            }
+                                        }
+                                    }
                                 }
                             }
                         }
                     }
                 }
 
                 // Endcap1
@@ -529,75 +542,95 @@
             }
         }
     }
 }
 
 
 // Function&Module: dashed_stroke()
+// Synopsis: Draws a dashed line along a path or region boundry.
+// Topics: Paths, Drawing Tools
+// See Also: stroke(), path_cut()
 // Usage: As a Module
 //   dashed_stroke(path, dashpat, [width=], [closed=]);
 // Usage: As a Function
 //   dashes = dashed_stroke(path, dashpat, [closed=]);
-// Topics: Paths, Drawing Tools
-// See Also: stroke(), path_cut()
 // Description:
 //   Given a path (or region) and a dash pattern, creates a dashed line that follows that
 //   path or region boundary with the given dash pattern.
 //   - When called as a function, returns a list of dash sub-paths.
 //   - When called as a module, draws all those subpaths using `stroke()`.
 //   When called as a module the dash pattern is multiplied by the line width.  When called as
 //   a function the dash pattern applies as you specify it.  
 // Arguments:
 //   path = The path or region to subdivide into dashes.
 //   dashpat = A list of alternating dash lengths and space lengths for the dash pattern.  This will be scaled by the width of the line.
 //   ---
 //   width = The width of the dashed line to draw.  Module only.  Default: 1
 //   closed = If true, treat path as a closed polygon.  Default: false
+//   fit = If true, shrink or stretch the dash pattern so that the path ends ofter a logical dash.  Default: true
+//   roundcaps = (Module only) If true, draws dashes with rounded caps.  This often looks better.  Default: true
+//   mindash = (Function only) Specifies the minimal dash length to return at the end of a path when fit is false.  Default: 0.5
 // Example(2D): Open Path
 //   path = [for (a=[-180:10:180]) [a/3,20*sin(a)]];
 //   dashed_stroke(path, [3,2], width=1);
 // Example(2D): Closed Polygon
 //   path = circle(d=100,$fn=72);
-//   dashpat = [10,2,3,2,3,2];
+//   dashpat = [10,2, 3,2, 3,2];
 //   dashed_stroke(path, dashpat, width=1, closed=true);
 // Example(FlatSpin,VPD=250): 3D Dashed Path
 //   path = [for (a=[-180:5:180]) [a/3, 20*cos(3*a), 20*sin(3*a)]];
 //   dashed_stroke(path, [3,2], width=1);
-function dashed_stroke(path, dashpat=[3,3], closed=false) =
-    is_region(path) ? [for(p=path) each dashed_stroke(p,dashpat,closed=true)] : 
+function dashed_stroke(path, dashpat=[3,3], closed=false, fit=true, mindash=0.5) =
+    is_region(path) ? [
+        for (p = path)
+        each dashed_stroke(p, dashpat, closed=true, fit=fit)
+    ] : 
     let(
-        path = closed? close_path(path) : path,
+        path = closed? list_wrap(path) : path,
         dashpat = len(dashpat)%2==0? dashpat : concat(dashpat,[0]),
         plen = path_length(path),
         dlen = sum(dashpat),
         doff = cumsum(dashpat),
-        reps = floor(plen / dlen),
-        step = plen / reps,
+        freps = plen / dlen,
+        reps = max(1, fit? round(freps) : floor(freps)),
+        tlen = !fit? plen :
+            reps * dlen + (closed? 0 : dashpat[0]),
+        sc = plen / tlen,
         cuts = [
-            for (i=[0:1:reps-1], off=doff)
-            let (st=i*step, x=st+off)
-            if (x>0 && x<plen) x
+            for (i = [0:1:reps], off = doff*sc)
+            let (x = i*dlen*sc + off)
+            if (x > 0 && x < plen) x
         ],
         dashes = path_cut(path, cuts, closed=false),
-        evens = [for (i=idx(dashes)) if (i%2==0) dashes[i]]
+        dcnt = len(dashes),
+        evens = [
+            for (i = idx(dashes))
+            if (i % 2 == 0)
+            let( dash = dashes[i] )
+            if (i < dcnt-1 || path_length(dash) > mindash)
+            dashes[i]
+        ]
     ) evens;
 
 
-module dashed_stroke(path, dashpat=[3,3], width=1, closed=false) {
+module dashed_stroke(path, dashpat=[3,3], width=1, closed=false, fit=true, roundcaps=false) {
     no_children($children);
-    segs = dashed_stroke(path, dashpat=dashpat*width, closed=closed);
+    segs = dashed_stroke(path, dashpat=dashpat*width, closed=closed, fit=fit, mindash=0.5*width);
     for (seg = segs)
-        stroke(seg, width=width, endcaps=false);
+        stroke(seg, width=width, endcaps=roundcaps? "round" : false);
 }
 
 
 
 // Section: Computing paths
 
 // Function&Module: arc()
+// Synopsis: Draws a 2d pie-slice or returns 2D or 3D path forming an arc.
+// Topics: Shapes (2D), Path Generators (2D)
+//
 // Usage: 2D arc from 0º to `angle` degrees.
 //   path=arc(n, r|d=, angle);
 // Usage: 2D arc from START to END degrees.
 //   path=arc(n, r|d=, angle=[START,END]);
 // Usage: 2D arc from `start` to `start+angle` degrees.
 //   path=arc(n, r|d=, start=, angle=);
 // Usage: 2D circle segment by `width` and `thickness`, starting and ending on the X axis.
@@ -625,15 +658,15 @@
 //   corner = A path of two segments to fit an arc tangent to.
 //   long = if given with cp and points takes the long arc instead of the default short arc.  Default: false
 //   cw = if given with cp and 2 points takes the arc in the clockwise direction.  Default: false
 //   ccw = if given with cp and 2 points takes the arc in the counter-clockwise direction.  Default: false
 //   width = If given with `thickness`, arc starts and ends on X axis, to make a circle segment.
 //   thickness = If given with `width`, arc starts and ends on X axis, to make a circle segment.
 //   start = Start angle of arc.
-//   wedge = If true, include centerpoint `cp` in output to form pie slice shape.
+//   wedge = If true, include centerpoint `cp` in output to form pie slice shape.  Default: false
 //   endpoint = If false exclude the last point (function only).  Default: true
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  (Module only) Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  (Module only) Default: `0`
 // Examples(2D):
 //   arc(n=4, r=30, angle=30, wedge=true);
 //   arc(r=30, angle=30, wedge=true);
 //   arc(d=60, angle=30, wedge=true);
@@ -669,15 +702,15 @@
         assert(width>0, "Width must be postive")
         assert(thickness>0, "Thickness must be positive")
         arc(n,points=[[width/2,0], [0,thickness], [-width/2,0]],wedge=wedge)
     ) :
     is_def(angle)? (
         let(
             parmok = !any_defined([points,width,thickness]) &&
-                ((is_vector(angle,2) && is_undef(start)) || is_num(angle))
+                ((is_vector(angle,2) && is_undef(start)) || is_finite(angle))
         )
         assert(parmok,"Invalid parameters in arc")
         let(
             cp = first_defined([cp,[0,0]]),
             start = is_def(start)? start : is_vector(angle) ? angle[0] : 0,
             angle = is_vector(angle)? angle[1]-angle[0] : angle,
             r = get_radius(r=r, d=d)
@@ -782,14 +815,17 @@
         polygon(path);
         children();
     }
 }
 
 
 // Function: helix()
+// Synopsis: Creates a 2d spiral or 3d helical path.
+// Topics: Path Generators, Paths, Drawing Tools
+//
 // Usage:
 //   path = helix(l|h, [turns=], [angle=], r=|r1=|r2=, d=|d1=|d2=);
 // Description:
 //   Returns a 3D helical path on a cone, including the degerate case of flat spirals.
 //   You can specify start and end radii.  You can give the length, the helix angle, or the number of turns: two
 //   of these three parameters define the helix.  For a flat helix you must give length 0 and a turn count.
 //   Helix will be right handed if turns is positive and left handed if it is negative.
@@ -834,20 +870,21 @@
 
 function _normal_segment(p1,p2) =
     let(center = (p1+p2)/2)
     [center, center + norm(p1-p2)/2 * line_normal(p1,p2)];
 
 
 // Function: turtle()
-// Usage:
-//   turtle(commands, [state], [full_state=], [repeat=])
+// Synopsis: Uses [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) to generate a 2D path.
 // Topics: Shapes (2D), Path Generators (2D), Mini-Language
 // See Also: turtle3d()
+// Usage:
+//   turtle(commands, [state], [full_state=], [repeat=])
 // Description:
-//   Use a sequence of turtle graphics commands to generate a path.  The parameter `commands` is a list of
+//   Use a sequence of [turtle graphics]{https://en.wikipedia.org/wiki/Turtle_graphics} commands to generate a path.  The parameter `commands` is a list of
 //   turtle commands and optional parameters for each command.  The turtle state has a position, movement direction,
 //   movement distance, and default turn angle.  If you do not give `state` as input then the turtle starts at the
 //   origin, pointed along the positive x axis with a movement distance of 1.  By default, `turtle` returns just
 //   the computed turtle path.  If you set `full_state` to true then it instead returns the full turtle state.
 //   You can invoke `turtle` again with this full state to continue the turtle path where you left off.
 //   .
 //   The turtle state is a list with three entries: the path constructed so far, the current step as a 2-vector, the current default angle,
@@ -1096,14 +1133,17 @@
     assert(false,str("Unknown turtle command \"",command,"\" at index",index))
     [];
 
 
 // Section: Debugging polygons
 
 // Module: debug_polygon()
+// Synopsis: Draws an annotated polygon.
+// Topics: Shapes (2D)
+//
 // Usage:
 //   debug_polygon(points, paths, [vertices=], [edges=], [convexity=], [size=]);
 // Description:
 //   A drop-in replacement for `polygon()` that renders and labels the path points and
 //   edges.  The start of each path is marked with a blue circle and the end with a pink diamond.
 //   You can suppress the display of vertex or edge labeling using the `vertices` and `edges` arguments.
 // Arguments:
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/fnliterals.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/fnliterals.scad`

 * *Files 0% similar despite different names*

```diff
@@ -544,15 +544,15 @@
 //   passing the first argument along to the wrapped function.
 // Arguments:
 //   target_func = The function of signature (x) to wrap.
 // FunctionLiteral Args:
 //   a = The argument that will be passed through.
 //   b = The argumen that will be discarded.
 // Example:
-//   x = while(0, ival(f_lt(5)), xval(fngen_add(1)));
+//   x = while(0, ival(f_lt(5)), xval(f_add(1)));
 function ival(target_func) = function(a,b) target_func(a);
 
 
 // Function: xval()
 // Usage:
 //   newfunc = xval(func);
 // Description:
@@ -560,15 +560,15 @@
 //   passing the first argument along to the wrapped function.
 // Arguments:
 //   target_func = The function of signature (x) to wrap.
 // FunctionLiteral Args:
 //   a = The argument that will be passed through.
 //   b = The argumen that will be discarded.
 // Example:
-//   x = while(0, ival(f_lt(5)), xval(fngen_add(1)));
+//   x = while(0, ival(f_lt(5)), xval(f_add(1)));
 function xval(target_func) = function(a,b) target_func(b);
 
 
 
 //////////////////////////////////////////////////////////////////////
 // Section: Comparator Generators
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/gears.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/gears.scad`

 * *Files 3% similar despite different names*

```diff
@@ -22,22 +22,23 @@
 //   then slowly unwound.  That shape is an "involute", which gives this
 //   type of gear its name.
 
 
 // Section: Gears
 
 // Function&Module: spur_gear()
+// Synopsis: Creates a spur gear shape.
+// Topics: Gears, Parts
+// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()
 // Usage: As a Module
 //   spur_gear(pitch, teeth, thickness, [shaft_diam], [hide=], [pressure_angle=], [clearance=], [backlash=], [helical=], [slices=], [interior=]) [ATTACHMENTS];
 //   spur_gear(mod=, teeth=, thickness=, [shaft_diam=], ...) [ATTACHMENTS];
 // Usage: As a Function
-//   vnf = spur_gear(pitch, teeth, thickness, [shaft_diam], ...);
-//   vnf = spur_gear(mod=, teeth=, thickness=, [shaft_diam], ...);
-// Topics: Gears
-// See Also: rack()
+//   vnf = spur_gear(pitch, teeth, thickness, [shaft_diam=], ...);
+//   vnf = spur_gear(mod=, teeth=, thickness=, [shaft_diam=], ...);
 // Description:
 //   Creates a (potentially helical) involute spur gear.  The module `spur_gear()` gives an involute
 //   spur gear, with reasonable defaults for all the parameters.  Normally, you should just choose the
 //   first 4 parameters, and let the rest be default values.  The module `spur_gear()` gives a gear in
 //   the XY plane, centered on the origin, with one tooth centered on the positive Y axis.  The most
 //   important is `pitch_radius()`, which tells how far apart to space gears that are meshing, and
 //   `outer_radius()`, which gives the size of the region filled by the gear.  A gear has a "pitch
@@ -187,22 +188,23 @@
         }
         children();
     }
 }
 
 
 // Function&Module: spur_gear2d()
+// Synopsis: Creates a 2D spur gear shape.
+// Topics: Gears, Parts
+// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()
 // Usage: As Module
 //   spur_gear2d(pitch, teeth, [hide=], [pressure_angle=], [clearance=], [backlash=], [interior=]) [ATTACHMENTS];
 //   spur_gear2d(mod=, teeth=, [hide=], [pressure_angle=], [clearance=], [backlash=], [interior=]) [ATTACHMENTS];
 // Usage: As Function
 //   poly = spur_gear2d(pitch, teeth, [hide=], [pressure_angle=], [clearance=], [backlash=], [interior=]);
 //   poly = spur_gear2d(mod=, teeth=, [hide=], [pressure_angle=], [clearance=], [backlash=], [interior=]);
-// Topics: Gears
-// See Also: spur_gear()
 // Description:
 //   When called as a module, creates a 2D involute spur gear.  When called as a function, returns a
 //   2D path for the perimeter of a 2D involute spur gear.  Normally, you should just specify the
 //   first 2 parameters `pitch` and `teeth`, and let the rest be default values.
 //   Meshing gears must match in `pitch`, `pressure_angle`, and `helical`, and be separated by
 //   the sum of their pitch radii, which can be found with `pitch_radius()`.
 // Arguments:
@@ -287,22 +289,23 @@
         children();
     }
 }
 
 
 
 // Function&Module: rack()
+// Synopsis: Creates a gear rack shape.
+// Topics: Gears, Parts
+// See Also: rack2d(), spur_gear(), spur_gear2d(), bevel_gear()
 // Usage: As a Module
-//   rack(pitch, teeth, thickness, height, [pressure_angle=], [backlash=]) [ATTACHMENTS];
-//   rack(mod=, teeth=, thickness=, height=, [pressure_angle=], [backlash]=) [ATTACHMENTS];
+//   rack(pitch, teeth, thickness, height, [pressure_angle=], [backlash=], [clearance=], [helical=]) [ATTACHMENTS];
+//   rack(mod=, teeth=, thickness=, height=, [pressure_angle=], [backlash]=, [clearance=], [helical=]) [ATTACHMENTS];
 // Usage: As a Function
-//   vnf = rack(pitch, teeth, thickness, height, [pressure_angle=], [backlash=]);
-//   vnf = rack(mod=, teeth=, thickness=, height=, [pressure_angle=], [backlash=]);
-// Topics: Gears
-// See Also: spur_gear()
+//   vnf = rack(pitch, teeth, thickness, height, [pressure_angle=], [backlash=], [clearance=], [helical=]);
+//   vnf = rack(mod=, teeth=, thickness=, height=, [pressure_angle=], [backlash=], [clearance=], [helical=]);
 // Description:
 //   This is used to create a 3D rack, which is a linear bar with teeth that a gear can roll along.
 //   A rack can mesh with any gear that has the same `pitch` and `pressure_angle`.
 //   When called as a function, returns a 3D [VNF](vnf.scad) for the rack.
 //   When called as a module, creates a 3D rack shape.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm. Default: 5
@@ -435,22 +438,23 @@
         out = helical==0? vnf : skew(sxy=tan(helical), p=vnf)
     ) reorient(anchor,spin,orient, size=[l, thickness, 2*abs(a-height)], anchors=anchors, p=out);
 
 
 
 
 // Function&Module: rack2d()
+// Synopsis: Creates a 2D gear rack shape.
+// Topics: Gears, Parts
+// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()
 // Usage: As a Module
-//   path = rack2d(pitch, teeth, height, [pressure_angle=], [backlash=]) [ATTACHMENTS];
-//   path = rack2d(mod=, teeth=, height=, [pressure_angle=], [backlash=]) [ATTACHMENTS];
+//   rack2d(pitch, teeth, height, [pressure_angle=], [backlash=], [clearance=]) [ATTACHMENTS];
+//   rack2d(mod=, teeth=, height=, [pressure_angle=], [backlash=], [clearance=]) [ATTACHMENTS];
 // Usage: As a Function
-//   path = rack2d(pitch, teeth, height, [pressure_angle=], [backlash=]);
-//   path = rack2d(mod=, teeth=, height=, [pressure_angle=], [backlash=]);
-// Topics: Gears
-// See Also: spur_gear2d()
+//   path = rack2d(pitch, teeth, height, [pressure_angle=], [backlash=], [clearance=]);
+//   path = rack2d(mod=, teeth=, height=, [pressure_angle=], [backlash=], [clearance=]);
 // Description:
 //   This is used to create a 2D rack, which is a linear bar with teeth that a gear can roll along.
 //   A rack can mesh with any gear that has the same `pitch` and `pressure_angle`.
 //   When called as a function, returns a 2D path for the outline of the rack.
 //   When called as a module, creates a 2D rack shape.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
@@ -557,20 +561,23 @@
     }
 }
 
 
 
 
 // Function&Module: bevel_gear()
+// Synopsis: Creates a possibly spiral beveled gear shape.
+// Topics: Gears, Parts
+// See Also: rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()
 // Usage: As a Module
-//   bevel_gear(pitch|mod, teeth, face_width, pitch_angle, [shaft_diam], [hide], [pressure_angle], [clearance], [backlash], [cutter_radius], [spiral_angle], [slices], [interior]);
+//   bevel_gear(pitch, teeth, face_width, [pitch_angle=]|[mate_teeth=], [shaft_diam=], [hide=], [pressure_angle=], [clearance=], [backlash=], [cutter_radius=], [spiral_angle=], [left_handed=], [slices=], [interior=]);
+//   bevel_gear(mod=, teeth=, face_width=, [pitch_angle=]|[mate_teeth=], [shaft_diam=], [hide=], [pressure_angle=], [clearance=], [backlash=], [cutter_radius=], [spiral_angle=], [left_handed=], [slices=], [interior=]);
 // Usage: As a Function
-//   vnf = bevel_gear(pitch|mod, teeth, face_width, pitch_angle, [hide], [pressure_angle], [clearance], [backlash], [cutter_radius], [spiral_angle], [slices], [interior]);
-// Topics: Gears
-// See Also: bevel_pitch_angle()
+//   vnf = bevel_gear(pitch, teeth, face_width, [pitch_angle=]|[mate_teeth=], [hide=], [pressure_angle=], [clearance=], [backlash=], [cutter_radius=], [spiral_angle=], [left_handed=], [slices=], [interior=]);
+//   vnf = bevel_gear(mod=, teeth=, face_width=, [pitch_angle=]|[mate_teeth=], [hide=], [pressure_angle=], [clearance=], [backlash=], [cutter_radius=], [spiral_angle=], [left_handed=], [slices=], [interior=]);
 // Description:
 //   Creates a (potentially spiral) bevel gear.  The module `bevel_gear()` gives a bevel gear, with
 //   reasonable defaults for all the parameters.  Normally, you should just choose the first 4
 //   parameters, and let the rest be default values.  The module `bevel_gear()` gives a gear in the XY
 //   plane, centered on the origin, with one tooth centered on the positive Y axis.  The various
 //   functions below it take the same parameters, and return various measurements for the gear.  The
 //   most important is `pitch_radius()`, which tells how far apart to space gears that are meshing,
@@ -590,14 +597,15 @@
 //   wear.  So coprime numbers of teeth are good.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.  Default: 5
 //   teeth = Total number of teeth around the entire perimeter.  Default: 20
 //   face_width = Width of the toothed surface in mm, from inside to outside.  Default: 10
 //   pitch_angle = Angle of beveled gear face.  Default: 45
 //   mate_teeth = The number of teeth in the gear that this gear will mate with.  Overrides `pitch_angle` if given.
+//   ---
 //   shaft_diam = Diameter of the hole in the center, in mm.  Module use only.  Default: 0 (no shaft hole)
 //   hide = Number of teeth to delete to make this only a fraction of a circle.  Default: 0
 //   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 28
 //   clearance = Clearance gap at the bottom of the inter-tooth valleys.
 //   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0
 //   cutter_radius = Radius of spiral arc for teeth.  If 0, then gear will not be spiral.  Default: 0
 //   spiral_angle = The base angle for spiral teeth.  Default: 0
@@ -813,20 +821,23 @@
 }
 
 
 
 
 
 // Function&Module: worm()
+// Synopsis: Creates a worm shape that will mate with a worm gear.
+// Topics: Gears, Parts
+// See Also: worm(), worm_gear(), rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()
 // Usage: As a Module
-//   worm(pitch|mod, d, l, [starts], [left_handed], [pressure_angle], [backlash], [clearance]);
+//   worm(pitch, d, l, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);
+//   worm(mod=, d=, l=, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);
 // Usage: As a Function
-//   vnf = worm(pitch|mod, d, l, [starts], [left_handed], [pressure_angle], [backlash], [clearance]);
-// Topics: Gears
-// See Also: worm_gear()
+//   vnf = worm(pitch, d, l, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);
+//   vnf = worm(mod=, d=, l=, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);
 // Description:
 //   Creates a worm shape that can be matched to a worm gear.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.  Default: 5
 //   d = The diameter of the worm.  Default: 30
 //   l = The length of the worm.  Default: 100
 //   starts = The number of lead starts.  Default: 1
@@ -930,20 +941,23 @@
         vnf_polyhedron(vnf, convexity=ceil(l/pitch)*2);
         children();
     }
 }
 
 
 // Function&Module: worm_gear()
+// Synopsis: Creates a worm gear shape that will mate with a worm.
+// Topics: Gears, Parts
+// See Also: worm(), worm_gear(), rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()
 // Usage: As a Module
-//   worm_gear(pitch|mod, teeth, worm_diam, [worm_starts], [crowning], [left_handed], [pressure_angle], [backlash], [slices], [clearance], [shaft_diam]);
+//   worm_gear(pitch, teeth, worm_diam, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=], [shaft_diam=]) [ATTACHMENTS];
+//   worm_gear(mod=, teeth=, worm_diam=, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=], [shaft_diam=]) [ATTACHMENTS];
 // Usage: As a Function
-//   vnf = worm_gear(pitch|mod, teeth, worm_diam, [worm_starts], [crowning], [left_handed], [pressure_angle], [backlash], [slices], [clearance]);
-// Topics: Gears
-// See Also: worm()
+//   vnf = worm_gear(pitch, teeth, worm_diam, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=]);
+//   vnf = worm_gear(mod=, teeth=, worm_diam=, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=]);
 // Description:
 //   Creates a worm gear to match with a worm.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.  Default: 5
 //   teeth = Total number of teeth along the rack.  Default: 30
 //   worm_diam = The pitch diameter of the worm gear to match to.  Default: 30
 //   worm_starts = The number of lead starts on the worm gear to match to.  Default: 1
@@ -996,16 +1010,16 @@
     worm_starts = 1,
     worm_arc = 60,
     crowning = 1,
     left_handed = false,
     pressure_angle = 20,
     backlash = 0,
     clearance,
-    mod,
     slices = 10,
+    mod,
     anchor = CENTER,
     spin = 0,
     orient = UP
 ) =
     assert(worm_arc >= 10 && worm_arc <= 60)
     let(
         pitch = is_undef(mod) ? pitch : pitch_value(mod),
@@ -1223,63 +1237,73 @@
 // Section: Computing Gear Dimensions
 //   These functions let the user find the derived dimensions of the gear.
 //   A gear fits within a circle of radius outer_radius, and two gears should have
 //   their centers separated by the sum of their pitch_radius.
 
 
 // Function: circular_pitch()
+// Synopsis: Returns tooth density expressed as "circular pitch".
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value()
 // Usage:
-//   circp = circular_pitch(pitch|mod);
-// Topics: Gears
+//   circp = circular_pitch(pitch);
+//   circp = circular_pitch(mod=);
 // Description:
 //   Get tooth density expressed as "circular pitch".
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
 //   mod = The metric module/modulus of the gear.
 // Example:
 //   circp = circular_pitch(pitch=5);
 //   circp = circular_pitch(mod=2);
 function circular_pitch(pitch=5, mod) =
     let( pitch = is_undef(mod) ? pitch : pitch_value(mod) )
     pitch;
 
 
 // Function: diametral_pitch()
+// Synopsis: Returns tooth density expressed as "diametral pitch".
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value()
 // Usage:
-//   dp = diametral_pitch(pitch|mod);
-// Topics: Gears
+//   dp = diametral_pitch(pitch);
+//   dp = diametral_pitch(mod=);
 // Description:
 //   Get tooth density expressed as "diametral pitch".
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
 //   mod = The metric module/modulus of the gear.
 // Example:
 //   dp = diametral_pitch(pitch=5);
 //   dp = diametral_pitch(mod=2);
 function diametral_pitch(pitch=5, mod) =
     let( pitch = is_undef(mod) ? pitch : pitch_value(mod) )
     PI / pitch;
 
 
 // Function: pitch_value()
+// Synopsis: Returns circular pitch in mm from module/modulus.
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value(), module_value()
 // Usage:
 //   pitch = pitch_value(mod);
-// Topics: Gears
 // Description:
 //   Get circular pitch in mm from module/modulus.  The circular pitch of a gear is the number of
 //   millimeters per tooth around the pitch radius circle.
 // Arguments:
 //   mod = The module/modulus of the gear.
 function pitch_value(mod) = mod * PI;
 
 
 // Function: module_value()
+// Synopsis: Returns tooth density expressed as "module" or "modulus" in millimeters.
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value(), module_value()
 // Usage:
 //   mod = module_value(pitch);
-// Topics: Gears
 // Description:
 //   Get tooth density expressed as "module" or "modulus" in millimeters.  The module is the pitch
 //   diameter of the gear divided by the number of teeth on it.  For example, a gear with a pitch
 //   diameter of 40mm, with 20 teeth on it will have a modulus of 2.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
 function module_value(pitch=5) = pitch / PI;
@@ -1336,17 +1360,20 @@
 function _dedendum(pitch=5, clearance, mod) =
     let( pitch = is_undef(mod) ? pitch : pitch_value(mod) )
     is_undef(clearance)? (1.25 * module_value(pitch)) :
     (module_value(pitch) + clearance);
 
 
 // Function: pitch_radius()
+// Synopsis: Returns the pitch radius for a gear.
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value(), module_value(), outer_radius()
 // Usage:
-//   pr = pitch_radius(pitch|mod, teeth);
-// Topics: Gears
+//   pr = pitch_radius(pitch, teeth);
+//   pr = pitch_radius(mod=, teeth=);
 // Description:
 //   Calculates the pitch radius for the gear.  Two mated gears will have their centers spaced apart
 //   by the sum of the two gear's pitch radii.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
 //   teeth = The number of teeth on the gear.
 //   mod = The metric module/modulus of the gear.
@@ -1360,17 +1387,20 @@
 //       stroke(circle(r=pr),width=0.1,closed=true);
 function pitch_radius(pitch=5, teeth=11, mod) =
     let( pitch = is_undef(mod) ? pitch : pitch_value(mod) )
     pitch * teeth / PI / 2;
 
 
 // Function: outer_radius()
+// Synopsis: Returns the outer radius for a gear.
+// Topics: Gears, Parts
+// See Also: spur_gear(), diametral_pitch(), circular_pitch(), pitch_value(), module_value(), pitch_radius(), outer_radius()
 // Usage:
-//   or = outer_radius(pitch|mod, teeth, [clearance], [interior]);
-// Topics: Gears
+//   or = outer_radius(pitch, teeth, [clearance=], [interior=]);
+//   or = outer_radius(mod=, teeth=, [clearance=], [interior=]);
 // Description:
 //   Calculates the outer radius for the gear. The gear fits entirely within a cylinder of this radius.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.
 //   teeth = The number of teeth on the gear.
 //   clearance = If given, sets the clearance between meshing teeth.
 //   interior = If true, calculate for an interior gear.
@@ -1436,20 +1466,21 @@
 ///       stroke(circle(r=pr),width=0.1,closed=true);
 function _base_radius(pitch=5, teeth=11, pressure_angle=28, mod) =
     let( pitch = is_undef(mod) ? pitch : pitch_value(mod) )
     pitch_radius(pitch, teeth) * cos(pressure_angle);
 
 
 // Function: bevel_pitch_angle()
+// Synopsis: Returns the pitch cone angle for a bevel gear.
+// Topics: Gears, Parts
+// See Also: bevel_gear(), pitch_radius(), outer_radius()
 // Usage:
-//   ang = bevel_pitch_angle(teeth, mate_teeth, [drive_angle]);
-// Topics: Gears
-// See Also: bevel_gear()
+//   ang = bevel_pitch_angle(teeth, mate_teeth, [drive_angle=]);
 // Description:
-//   Returns the correct pitch angle for a bevel gear with a given number of tooth, that is
+//   Returns the correct pitch cone angle for a bevel gear with a given number of teeth, that is
 //   matched to another bevel gear with a (possibly different) number of teeth.
 // Arguments:
 //   teeth = Number of teeth that this gear has.
 //   mate_teeth = Number of teeth that the matching gear has.
 //   drive_angle = Angle between the drive shafts of each gear.  Default: 90º.
 // Example:
 //   ang = bevel_pitch_angle(teeth=18, mate_teeth=30);
@@ -1467,26 +1498,28 @@
 //       slices=12, anchor="apex", orient=BACK
 //   );
 function bevel_pitch_angle(teeth, mate_teeth, drive_angle=90) =
     atan(sin(drive_angle)/((mate_teeth/teeth)+cos(drive_angle)));
 
 
 // Function: worm_gear_thickness()
+// Synopsis: Returns the thickness for a worm gear.
+// Topics: Gears, Parts
+// See Also: worm(), worm_gear(), pitch_radius(), outer_radius()
 // Usage:
-//   thick = worm_gear_thickness(pitch|mod, teeth, worm_diam, [worm_arc], [crowning], [clearance]);
-// Topics: Gears
-// See Also: worm(), worm_gear()
+//   thick = worm_gear_thickness(pitch, teeth, worm_diam, [worm_arc=], [crowning=], [clearance=]);
+//   thick = worm_gear_thickness(mod=, teeth=, worm_diam=, [worm_arc=], [crowning=], [clearance=]);
 // Description:
 //   Calculate the thickness of the worm gear.
 // Arguments:
 //   pitch = The circular pitch, or distance between teeth around the pitch circle, in mm.  Default: 5
 //   teeth = Total number of teeth along the rack.  Default: 30
 //   worm_diam = The pitch diameter of the worm gear to match to.  Default: 30
 //   worm_arc = The arc of the worm to mate with, in degrees. Default: 60 degrees
-//   crowning = The amount to oversize the virtual hobbing cutter used to make the teeth, to add a slight crowning to the teeth to make them fir the work easier.  Default: 1
+//   crowning = The amount to oversize the virtual hobbing cutter used to make the teeth, to add a slight crowning to the teeth to make them fit the work easier.  Default: 1
 //   clearance = Clearance gap at the bottom of the inter-tooth valleys.
 //   mod = The metric module/modulus of the gear.
 // Example:
 //   thick = worm_gear_thickness(pitch=5, teeth=36, worm_diam=30);
 //   thick = worm_gear_thickness(mod=2, teeth=28, worm_diam=25);
 // Example(2D):
 //   pitch = 5;  teeth=17;
@@ -1517,9 +1550,8 @@
 function _gear_polar(r,t) = r*[sin(t),cos(t)];
 function _gear_iang(r1,r2) = sqrt((r2/r1)*(r2/r1) - 1)/PI*180 - acos(r1/r2);  //unwind a string this many degrees to go from radius r1 to radius r2
 function _gear_q6(b,s,t,d) = _gear_polar(d,s*(_gear_iang(b,d)+t));            //point at radius d on the involute curve
 function _gear_q7(f,r,b,r2,t,s) = _gear_q6(b,s,t,(1-f)*max(b,r)+f*r2);        //radius a fraction f up the curved side of the tooth
 
 
 
-
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/geometry.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/geometry.scad`

 * *Files 0% similar despite different names*

```diff
@@ -438,25 +438,27 @@
         _pointlist_greatest_distance(points,plane) < eps;
 
 
 
 // Function: plane3pt()
 // Usage:
 //   plane = plane3pt(p1, p2, p3);
+//   plane = plane3pt([p1, p2, p3]);
 // Topics: Geometry, Planes
 // Description:
 //   Generates the normalized cartesian equation of a plane from three 3d points.
 //   Returns [A,B,C,D] where Ax + By + Cz = D is the equation of a plane.
 //   Returns undef, if the points are collinear.
 // Arguments:
 //   p1 = The first point on the plane.
 //   p2 = The second point on the plane.
 //   p3 = The third point on the plane.
 function plane3pt(p1, p2, p3) =
-    assert( is_path([p1,p2,p3],dim=3) && len(p1)==3,
+    is_undef(p2) && is_undef(p3) && is_path(p1,dim=3) ? plane3pt(p1[0],p1[1],p1[2])
+  : assert( is_path([p1,p2,p3],dim=3) && len(p1)==3,
             "Invalid points or incompatible dimensions." )
     let(
         crx = cross(p3-p1, p2-p1),
         nrm = norm(crx)
     ) approx(nrm,0) ? undef :
     concat(crx, crx*p1)/nrm;
 
@@ -472,14 +474,16 @@
 //   If they are collinear, returns [].
 // Arguments:
 //   points = A list of points.
 //   i1 = The index into `points` of the first point on the plane.
 //   i2 = The index into `points` of the second point on the plane.
 //   i3 = The index into `points` of the third point on the plane.
 function plane3pt_indexed(points, i1, i2, i3) =
+    is_undef(i3) && is_undef(i2) && is_vector(i1) ? plane3pt_indexed(points, i1[0], i1[1], i1[2])
+  :
     assert( is_vector([i1,i2,i3]) && min(i1,i2,i3)>=0 && is_list(points) && max(i1,i2,i3)<len(points),
             "Invalid or out of range indices." )
     assert( is_path([points[i1], points[i2], points[i3]],dim=3),
             "Improper points or improper dimensions." )
     let(
         p1 = points[i1],
         p2 = points[i2],
@@ -1065,15 +1069,15 @@
 //   color("red") move(circ[0]) cyl(h=10, r=rad, orient=circ[1]);
 // Example(3D):
 //   path = yrot(20, p=path3d(star(d=100, n=5, step=2)));
 //   stroke(path, closed=true);
 //   for (i = [0:1:5]) {
 //       crn = select(path, i*2-1, i*2+1);
 //       ci = circle_2tangents(5, crn[0], crn[1], crn[2]);
-//       move(ci[0]) cyl(h=10,r=5,,orient=ci[1]);
+//       move(ci[0]) cyl(h=10,r=5,orient=ci[1]);
 //   }
 function circle_2tangents(r, pt1, pt2, pt3, tangents=false, d) =
     let(r = get_radius(r=r, d=d, dflt=undef))
     assert(r!=undef, "Must specify either r or d.")
     assert( ( is_path(pt1) && len(pt1)==3 && is_undef(pt2) && is_undef(pt3))
             || (is_matrix([pt1,pt2,pt3]) && (len(pt1)==2 || len(pt1)==3) ),
             "Invalid input points." )
@@ -1187,16 +1191,16 @@
 
 // Function: circle_circle_tangents()
 // Usage:
 //   segs = circle_circle_tangents(r1|d1=, cp1, r2|d2=, cp2);
 // Topics: Geometry, Circles, Tangents
 // Description:
 //   Computes 2d lines tangents to a pair of circles in 2d.  Returns a list of line endpoints [p1,p2] where
-//   p2 is the tangent point on circle 1 and p2 is the tangent point on circle 2.
-//   If four tangents exist then the first one the left hand exterior tangent as regarded looking from
+//   p1 is the tangent point on circle 1 and p2 is the tangent point on circle 2.
+//   If four tangents exist then the first one is the left hand exterior tangent as regarded looking from
 //   circle 1 toward circle 2.  The second value is the right hand exterior tangent.  The third entry
 //   gives the interior tangent that starts on the left of circle 1 and crosses to the right side of
 //   circle 2.  And the fourth entry is the last interior tangent that starts on the right side of
 //   circle 1.  If the circles intersect then the interior tangents don't exist and the function
 //   returns only two entries.  If one circle is inside the other one then no tangents exist
 //   so the function returns the empty set.  When the circles are tangent a degenerate tangent line
 //   passes through the point of tangency of the two circles:  this degenerate line is NOT returned.
@@ -1382,15 +1386,17 @@
 // Topics: Geometry, Polygons, Centroid
 // Description:
 //   Given a simple 2D polygon, returns the 2D coordinates of the polygon's centroid.
 //   Given a simple 3D planar polygon, returns the 3D coordinates of the polygon's centroid.
 //   If you provide a non-planar or collinear polygon you will get an error.  For self-intersecting
 //   polygons you may get an error or you may get meaningless results.
 //   .
-//   If object is a manifold VNF then returns the 3d centroid of the polyhedron.  The VNF must
+//   Given a [[region|regions.scad]], returns the 2D coordinates of the region's centroid.
+//   .
+//   Given a manifold [[VNF|vnf.scad]] then returns the 3D centroid of the polyhedron.  The VNF must
 //   describe a valid polyhedron with consistent face direction and no holes in the mesh; otherwise
 //   the results are undefined.
 // Arguments:
 //   object = object to compute the centroid of
 //   eps = epsilon value for identifying degenerate cases
 // Example(2D):
 //   path = [
@@ -2207,16 +2213,16 @@
 // Example(NORENDER):
 //    are_polygons_equal(pentagon(r=4),
 //                   rot(360/5, p=pentagon(r=4))); // returns true
 //    are_polygons_equal(pentagon(r=4),
 //                   rot(90, p=pentagon(r=4)));    // returns false
 function are_polygons_equal(poly1, poly2, eps=EPSILON) =
     let(
-        poly1 = cleanup_path(poly1),
-        poly2 = cleanup_path(poly2),
+        poly1 = list_unwrap(poly1),
+        poly2 = list_unwrap(poly2),
         l1 = len(poly1),
         l2 = len(poly2)
     ) l1 != l2 ? false :
     let( maybes = find_approx(poly1[0], poly2, eps=eps, all=true) )
     maybes == []? false :
     [for (i=maybes) if (_are_polygons_equal(poly1, poly2, eps, i)) 1] != [];
 
@@ -2284,34 +2290,37 @@
 //   pts = [[-10,-10], [0,10], [10,10], [12,-10]];
 //   hull_points(pts);
 // Example(3D):
 //   pts = [for (phi = [30:60:150], theta = [0:60:359]) spherical_to_xyz(10, theta, phi)];
 //   hull_points(pts);
 module hull_points(points, fast=false) {
     no_children($children);
-    assert(is_path(points))
-    assert(len(points)>=3, "Point list must contain 3 points")
-    if (len(points[0])==2)
-       hull() polygon(points=points);
-    else {
-      if (fast) {
-         extra = len(points)%3;
-         faces = [
-                   [for(i=[0:1:extra+2])i], // If vertex count not divisible by 3, combine extras with first 3
-                   for(i=[extra+3:3:len(points)-3])[i,i+1,i+2]
-                 ];
-         hull() polyhedron(points=points, faces=faces);
-      } else {
-        faces = hull(points);
-        if (is_num(faces[0])){
-          if (len(faces)<=2) echo("Hull contains only two points");
-          else polyhedron(points=points, faces=[faces]);
+    check = assert(is_path(points))
+            assert(len(points)>=3, "Point list must contain 3 points");
+    attachable(){
+      if (len(points[0])==2)
+         hull() polygon(points=points);
+      else {
+        if (fast) {
+           extra = len(points)%3;
+           faces = [
+                     [for(i=[0:1:extra+2])i], // If vertex count not divisible by 3, combine extras with first 3
+                     for(i=[extra+3:3:len(points)-3])[i,i+1,i+2]
+                   ];
+           hull() polyhedron(points=points, faces=faces);
+        } else {
+          faces = hull(points);
+          if (is_num(faces[0])){
+            if (len(faces)<=2) echo("Hull contains only two points");
+            else polyhedron(points=points, faces=[faces]);
+          }
+          else polyhedron(points=points, faces=faces);
         }
-        else polyhedron(points=points, faces=faces);
       }
+      union();
     }
 }
 
 
 
 function _backtracking(i,points,h,t,m,all) =
     m<t || _is_cw(points[i], points[h[m-1]], points[h[m-2]],all) ? m :
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/joiners.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/joiners.scad`

 * *Files 3% similar despite different names*

```diff
@@ -12,32 +12,33 @@
 include <rounding.scad>
 
 
 // Section: Half Joiners
 
 
 // Function&Module: half_joiner_clear()
+// Synopsis: Creates a mask to clear space for a {{half_joiner()}}.
+// Topics: Joiners, Parts
+// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()
 // Usage: As Module
 //   half_joiner_clear(l, w, [ang=], [clearance=], [overlap=]) [ATTACHMENTS];
 // Usage: As Function
 //   vnf = half_joiner_clear(l, w, [ang=], [clearance=], [overlap=]);
-// Topics: Joiners, Parts
 // Description:
 //   Creates a mask to clear an area so that a half_joiner can be placed there.
 // Arguments:
 //   l = Length of the joiner to clear space for.
 //   w = Width of the joiner to clear space for.
 //   ang = Overhang angle of the joiner.
 //   ---
 //   clearance = Extra width to clear.
 //   overlap = Extra depth to clear.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner()
 // Example:
 //   half_joiner_clear();
 function half_joiner_clear(l=20, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP) =
     let(
         guide = [w/3-get_slop()*2, ang_adj_to_opp(ang, l/3)*2, l/3],
         path = [
             [ l/2,-overlap], [ guide.z/2, -guide.y/2-overlap],
@@ -56,33 +57,34 @@
         vnf_polyhedron(vnf, convexity=2);
         children();
     }
 }
 
 
 // Function&Module: half_joiner()
+// Synopsis: Creates a half-joiner shape to mate with a {{half_joiner2()}} shape..
+// Topics: Joiners, Parts
+// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()
 // Usage: As Module
 //   half_joiner(l, w, [base=], [ang=], [screwsize=], [$slop=]) [ATTACHMENTS];
 // Usage: As Function
 //   vnf = half_joiner(l, w, [base=], [ang=], [screwsize=], [$slop=]);
-// Topics: Joiners, Parts
 // Description:
 //   Creates a half_joiner object that can be attached to a matching half_joiner2 object.
 // Arguments:
 //   l = Length of the half_joiner.
 //   w = Width of the half_joiner.
 //   ---
 //   base = Length of the backing to the half_joiner.
 //   ang = Overhang angle of the half_joiner.
 //   screwsize = If given, diameter of screwhole.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 //   $slop = Printer specific slop value to make parts fit more closely.
-// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner()
 // Examples(FlatSpin,VPD=75):
 //   half_joiner(screwsize=3);
 //   half_joiner(l=20,w=10,base=10);
 // Example(3D):
 //   diff()
 //   cuboid(40)
 //       attach([FWD,TOP,RIGHT])
@@ -237,32 +239,33 @@
             children();
         }
     }
 }
 
 
 // Function&Module: half_joiner2()
+// Synopsis: Creates a half_joiner2 shape to mate with a {{half_joiner()}} shape..
+// Topics: Joiners, Parts
+// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()
 // Usage: As Module
 //   half_joiner2(l, w, [base=], [ang=], [screwsize=])
 // Usage: As Function
 //   vnf = half_joiner2(l, w, [base=], [ang=], [screwsize=])
-// Topics: Joiners, Parts
 // Description:
 //   Creates a half_joiner2 object that can be attached to half_joiner object.
 // Arguments:
 //   l = Length of the half_joiner.
 //   w = Width of the half_joiner.
 //   ---
 //   base = Length of the backing to the half_joiner.
 //   ang = Overhang angle of the half_joiner.
 //   screwsize = Diameter of screwhole.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner()
 // Examples(FlatSpin,VPD=75):
 //   half_joiner2(screwsize=3);
 //   half_joiner2(w=10,base=10,l=20);
 // Example(3D):
 //   diff()
 //   cuboid(40)
 //       attach([FWD,TOP,RIGHT])
@@ -440,30 +443,31 @@
 
 
 
 // Section: Full Joiners
 
 
 // Module: joiner_clear()
+// Synopsis: Creates a mask to clear space for a {{joiner()}} shape.
+// Topics: Joiners, Parts
+// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()
 // Description:
 //   Creates a mask to clear an area so that a joiner can be placed there.
 // Usage:
 //   joiner_clear(l, w, [ang=], [clearance=], [overlap=]) [ATTACHMENTS];
-// Topics: Joiners, Parts
 // Arguments:
 //   l = Length of the joiner to clear space for.
 //   w = Width of the joiner to clear space for.
 //   ang = Overhang angle of the joiner.
 //   ---
 //   clearance = Extra width to clear.
 //   overlap = Extra depth to clear.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner()
 // Example:
 //   joiner_clear();
 function joiner_clear(l=40, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP) = no_function("joiner_clear");
 module joiner_clear(l=40, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP)
 {
     dmnd_height = l*0.5;
     dmnd_width = dmnd_height*tan(ang);
@@ -478,31 +482,32 @@
         children();
     }
 }
 
 
 
 // Module: joiner()
+// Synopsis: Creates a joiner shape that can mate with another rotated joiner shape.
+// Topics: Joiners, Parts
+// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()
 // Usage:
 //   joiner(l, w, base, [ang=], [screwsize=], [$slop=]) [ATTACHMENTS];
-// Topics: Joiners, Parts
 // Description:
 //   Creates a joiner object that can be attached to another joiner object.
 // Arguments:
 //   l = Length of the joiner.
 //   w = Width of the joiner.
 //   base = Length of the backing to the joiner.
 //   ang = Overhang angle of the joiner.
 //   ---
 //   screwsize = If given, diameter of screwhole.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 //   $slop = Printer specific slop value to make parts fit more closely.
-// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner()
 // Examples(FlatSpin,VPD=125):
 //   joiner(screwsize=3);
 //   joiner(l=40, w=10, base=10);
 // Example(3D):
 //   diff()
 //   cuboid(50)
 //     attach([FWD,TOP,RIGHT])
@@ -528,43 +533,48 @@
 }
 
 
 
 // Section: Dovetails
 
 // Module: dovetail()
+// Synopsis: Creates a possibly tapered dovetail shape.
+// Topics: Joiners, Parts
+// See Also: joiner(), snap_pin(), rabbit_clip()
 //
 // Usage:
-//   dovetail(gender, w=|width, h=|height, slide, [slope=|angle=], [taper=|back_width=], [chamfer=], [r=|radius=], [round=], [extra=], [$slop=])
+//   dovetail(gender, w=|width, h=|height, slide|thickness=, [slope=|angle=], [taper=|back_width=], [chamfer=], [r=|radius=], [round=], [extra=], [$slop=])
 //
 // Description:
 //   Produces a possibly tapered dovetail joint shape to attach to or subtract from two parts you wish to join together.
 //   The tapered dovetail is particularly advantageous for long joints because the joint assembles without binding until
 //   it is fully closed, and then wedges tightly.  You can chamfer or round the corners of the dovetail shape for better
 //   printing and assembly, or choose a fully rounded joint that looks more like a puzzle piece.  The dovetail appears 
 //   parallel to the Y axis and projecting upwards, so in its default orientation it will slide together with a translation
 //   in the positive Y direction.  The gender determines whether the shape is meant to be added to your model or
 //   differenced, and it also changes the anchor and orientation.  The default anchor for dovetails is BOTTOM;
 //   the default orientation depends on the gender, with male dovetails oriented UP and female ones DOWN.  The dovetails by default
 //   have extra extension of 0.01 for unions and differences.  You should ensure that attachment is done with overlap=0 to ensure that
-//   the sizing and positioning is correct.
+//   the sizing and positioning is correct.  To adjust the fit, use the $slop variable, which increases the depth and width of
+//   the female part of the joint to allow a clearance gap of $slop on each of the three sides.  
 //
 // Arguments:
 //   gender = A string, "male" or "female", to specify the gender of the dovetail.
 //   w / width = Width (at the wider, top end) of the dovetail before tapering
 //   h / height = Height of the dovetail (the amount it projects from its base)
-//   slide = Distance the dovetail slides when you assemble it (length of sliding dovetails, thickness of regular dovetails)
+//   slide / thickness = Distance the dovetail slides when you assemble it (length of sliding dovetails, thickness of regular dovetails)
 //   ---
 //   slope = slope of the dovetail.  Standard woodworking slopes are 4, 6, or 8.  Default: 6.  
 //   angle = angle (in degrees) of the dovetail.  Specify only one of slope and angle.
 //   taper = taper angle (in degrees). Dovetail gets narrower by this angle.  Default: no taper
 //   back_width = width of right hand end of the dovetail.  This alternate method of specifying the taper may be easier to manage.  Specify only one of `taper` and `back_width`.  Note that `back_width` should be smaller than `width` to taper in the customary direction, with the smaller end at the back.  
 //   chamfer = amount to chamfer the corners of the joint (Default: no chamfer)
 //   r / radius = amount to round over the corners of the joint (Default: no rounding)
-//   round = true to round both corners of the dovetail and give it a puzzle piece look.  Default: false.  
+//   round = true to round both corners of the dovetail and give it a puzzle piece look.  Default: false.
+//   $slop = Increase the width of socket by double this amount and depth by this amount to allow adjustment of the fit. 
 //   extra = amount of extra length and base extension added to dovetails for unions and differences.  Default: 0.01
 // Example: Ordinary straight dovetail, male version (sticking up) and female version (below the xy plane)
 //   dovetail("male", width=15, height=8, slide=30);
 //   right(20) dovetail("female", width=15, height=8, slide=30);
 // Example: Adding a 6 degree taper (Such a big taper is usually not necessary, but easier to see for the example.)
 //   dovetail("male", w=15, h=8, slide=30, taper=6);
 //   right(20) dovetail("female", 15, 8, 30, taper=6);  // Same as above
@@ -609,72 +619,98 @@
 // Example: A series of dovetails forming a tail board, with the inside of the joint up.  A standard wood joint would have a zero taper. 
 //   cuboid([50,30,10])
 //     attach(BACK) xcopies(10,5) dovetail("male", slide=10, width=7, taper=4, height=4);
 // Example: Mating pin board for a half-blind right angle joint, where the joint only shows on the side but not the front.  Note that the anchor method and use of `spin` ensures that the joint works even with a taper.
 //   diff("remove")
 //     cuboid([50,30,10])
 //       tag("remove")position(TOP+BACK) xcopies(10,5) dovetail("female", slide=10, width=7, taper=4, height=4, anchor=BOTTOM+FRONT,spin=180);
-function dovetail(gender, width, height, slide, h, w, angle, slope, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient) = no_function("dovetail");
-module dovetail(gender, width, height, slide, h, w, angle, slope, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient)
+function dovetail(gender, width, height, slide, h, w, angle, slope, thickness, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient) = no_function("dovetail");
+module dovetail(gender, width, height, slide, h, w, angle, slope, thickness, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient)
 {
     radius = get_radius(r1=radius,r2=r);
-    hcount = num_defined([h,height]);
-    wcount = num_defined([w,width]);
-    assert(is_def(slide), "Must define slide");
-    assert(hcount==1, "Must define exactly one of h and height");
-    assert(wcount==1, "Must define exactly one of w and width");
-    h = first_defined([h,height]);
-    w = first_defined([w,width]);
-    orient = is_def(orient) ? orient :
-        gender == "female" ? DOWN : UP;
+    slide = one_defined([slide,thickness],"slide,thickness");
+    h = one_defined([h,height],"h,height");
+    w = one_defined([w,width],"w,width");
+    orient = is_def(orient) ? orient
+           : gender == "female" ? DOWN
+           : UP;
     count = num_defined([angle,slope]);
-    assert(count<=1, "Do not specify both angle and slope");
     count2 = num_defined([taper,back_width]);
-    assert(count2<=1, "Do not specify both taper and back_width");
     count3 = num_defined([chamfer, radius]);
-    assert(count3<=1 || (radius==0 && chamfer==0), "Do not specify both chamfer and radius");
-    slope = is_def(slope) ? slope :
-        is_def(angle) ? 1/tan(angle) :  6;
-    extra_slop = gender == "female" ? 2*get_slop() : 0;
-    width = w + extra_slop;
-    height = h + extra_slop;
-    back_width = u_add(back_width, extra_slop);
-
-    front_offset = is_def(taper) ? -extra * tan(taper) :
-        is_def(back_width) ? extra * (back_width-width)/slide/2 : 0;
-
-    size = is_def(chamfer) && chamfer>0 ? chamfer :
-        is_def(radius) && radius>0 ? radius : 0;
+    dummy = 
+        assert(count<=1, "Do not specify both angle and slope")
+        assert(count2<=1, "Do not specify both taper and back_width")
+        assert(count3<=1 || (radius==0 && chamfer==0), "Do not specify both chamfer and radius");
+    slope = is_def(slope) ? slope
+          : is_def(angle) ? 1/tan(angle)
+          :  6;
+    height_slop = gender == "female" ? get_slop() : 0;
+
+    // Need taper angle for computing width adjustment, but not used elsewhere
+    taper_ang = is_def(taper) ? taper
+              : is_def(back_width) ? atan((back_width-width)/2/slide)
+              : 0;
+    // This is the adjustment factor for width to grow in the direction normal to the dovetail face
+    wfactor = sqrt( 1/slope^2 + 1/cos(taper_ang)^2 );
+             // adjust width for increased height    adjust for normal to dovetail surface
+    width_slop = 2*height_slop/slope                + 2* height_slop * wfactor;
+    width = w + width_slop;
+    height = h + height_slop;
+    back_width = u_add(back_width, width_slop);
+
+    extra_offset = is_def(taper) ? -extra * tan(taper)
+                 : is_def(back_width) ? extra * (back_width-width)/slide/2
+                 : 0;
+
+    size = is_def(chamfer) && chamfer>0 ? chamfer
+         : is_def(radius) && radius>0 ? radius
+         : 0;
+    fullsize = round ? [size,size]
+             : gender == "male" ? [size,0]
+             : [0,size];
+    
     type = is_def(chamfer) && chamfer>0 ? "chamfer" : "circle";
 
-    fullsize = round ? [size,size] :
-        gender == "male" ? [size,0] : [0,size];
-
     smallend_half = round_corners(
         move(
             [0,-slide/2-extra,0],
             p=[
-                [0                     , 0, height],
-                [width/2-front_offset  , 0, height],
-                [width/2 - height/slope - front_offset, 0, 0 ],
-                [width/2 - front_offset + height, 0, 0]
+                [0,                                     0, height],
+                [width/2 - extra_offset,                0, height],
+                [width/2 - extra_offset - height/slope, 0, 0     ],
+                [width/2 - extra_offset + height,       0, 0     ]
             ]
         ),
         method=type, cut = fullsize, closed=false
     );
+
     smallend_points = concat(select(smallend_half, 1, -2), [down(extra,p=select(smallend_half, -2))]);
-    offset = is_def(taper) ? -(slide+extra) * tan(taper) :
-        is_def(back_width) ? (back_width-width) / 2 : 0;
-    bigend_points = move([offset,slide+2*extra,0], p=smallend_points);
+    offset = is_def(taper) ? -slide * tan(taper)
+           : is_def(back_width) ? (back_width-width) / 2
+           : 0;
+    bigend_points = move([offset+2*extra_offset,slide+2*extra,0], p=smallend_points);
 
+    bigenough = all_nonnegative(column(smallend_half,0)) && all_nonnegative(column(bigend_points,0));
+    
+    assert(bigenough, "Width of dovetail is not large enough for its geometry (angle and taper");
+    
     //adjustment = $overlap * (gender == "male" ? -1 : 1);  // Adjustment for default overlap in attach()
     adjustment = 0;    // Default overlap is assumed to be zero
-    
+
+    // This code computes the true normal from which the exact width factor can be obtained
+    // as the x component.  Comparing to wfactor above shows that they agree.  
+    //   pts = [smallend_points[0], smallend_points[1], bigend_points[1],bigend_points[0]];
+    //   n = -polygon_normal(pts);
+    //   echo(n=n);
+    //   echo(invwfactor = 1/wfactor, error = n.x-1/wfactor);
+
     attachable(anchor,spin,orient, size=[width+2*offset, slide, height]) {
         down(height/2+adjustment) {
+            //color("red")stroke([pts],width=.1);
+
             skin(
                 [
                     reverse(concat(smallend_points, xflip(p=reverse(smallend_points)))),
                     reverse(concat(bigend_points, xflip(p=reverse(bigend_points))))
                 ],
                 slices=0, convexity=4
             );
@@ -722,16 +758,18 @@
 {
    extra = 0.02;         // This sets the extra extension below the socket bottom
                          // so that difference() works without issues
    rPoint = r / sqrt(2);
    down(extra) cylinder(r = r, h = lStraight + extra);
    up(lStraight) {
       zscale(stretch) {
-         sphere(r = r);
-         if (pointed) up(rPoint) cylinder(r1 = rPoint, r2 = 0, h = rPoint);
+         hull() {
+            sphere(r = r);
+            if (pointed) up(rPoint) cylinder(r1 = rPoint, r2 = 0, h = rPoint/stretch);
+         }
       }
    }
    up(d) yscale(nubscale) _pin_nub(r = r, nub = nub, h = lStraight - d);
 }
 
 function _pin_size(size) =
   is_undef(size) ? [] :
@@ -765,14 +803,17 @@
                      "nub_depth", 0.9,
                      "thickness", 0.8,
                      "preload", 0.1]):
   undef;
 
 
 // Module: snap_pin()
+// Synopsis: Creates a snap-pin that can slot into a {{snap_pin_socket()}} to join two parts.
+// Topics: Joiners, Parts
+// See Also: snap_pin_socket(), joiner(), dovetail(), snap_pin(), rabbit_clip()
 // Usage:
 //    snap_pin(size, [pointed=], [anchor=], [spin=], [orient]=) [ATTACHMENTS];
 //    snap_pin(r=|radius=|d=|diameter=, l=|length=, nub_depth=, snap=, thickness=, [clearance=], [preload=], [pointed=]) [ATTACHMENTS];
 // Description:
 //    Creates a snap pin that can be inserted into an appropriate socket to connect two objects together.  You can choose from some standard
 //    pin dimensions by giving a size, or you can specify all the pin geometry parameters yourself.  If you use a standard size you can
 //    override the standard parameters by specifying other ones.  The pins have flat sides so they can
@@ -835,14 +876,17 @@
         _pin_slot(l = lStraight, r = rInner - thickness, t = thickness, d = nub_depth - preload, nub = snap, depth = 2 * radius + 0.02, stretch = stretch);
       }
   children();
   }
 }
 
 // Module: snap_pin_socket()
+// Synopsis: Creates a snap-pin socket for a {{snap_pin()}} to slot into.
+// Topics: Joiners, Parts
+// See Also: snap_pin(), joiner(), dovetail(), snap_pin(), rabbit_clip()
 // Usage:
 //   snap_pin_socket(size, [fixed=], [fins=], [pointed=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];
 //   snap_pin_socket(r=|radius=|d=|diameter=, l=|length=, nub_depth=, snap=, [fixed=], [pointed=], [fins=]) [ATTACHMENTS];
 // Description:
 //   Constructs a socket suitable for a snap_pin with the same parameters.   If `fixed` is true then the socket has flat walls and the
 //   pin will not rotate in the socket.  If `fixed` is false then the socket is round and the pin will rotate, particularly well
 //   if you add a lubricant.  If `pointed` is true the socket is pointed to receive a pointed pin, otherwise it has a rounded and and
@@ -905,14 +949,17 @@
   children();
   } 
 }
 
 
 
 // Module: rabbit_clip()
+// Synopsis: Creates a rabbit-eared clip that can snap into a slot.
+// Topics: Joiners, Parts
+// See Also: snap_pin(), joiner(), dovetail(), snap_pin(), rabbit_clip()
 // Usage:
 //   rabbit_clip(type, length, width, snap, thickness, depth, [compression=], [clearance=], [lock=], [lock_clearance=], [splineteps=], [anchor=], [orient=], [spin=]) [ATTACHMENTS];
 // Description:
 //   Creates a clip with two flexible ears to lock into a mating socket, or create a mask to produce the appropriate
 //   mating socket.  The clip can be made to insert and release easily, or to hold much better, or it can be
 //   created with locking flanges that will make it very hard or impossible to remove.  Unlike the snap pin, this clip
 //   is rectangular and can be made at any height, so a suitable clip could be very thin.  It's also possible to get a
@@ -1044,25 +1091,25 @@
 
 function rabbit_clip(type, length, width,  snap, thickness, depth, compression=0.1,  clearance=.1, lock=false, lock_clearance=0,
                    splinesteps=8, anchor, orient, spin=0) = no_function("rabbit_clip");
 
 module rabbit_clip(type, length, width,  snap, thickness, depth, compression=0.1,  clearance=.1, lock=false, lock_clearance=0,
                    splinesteps=8, anchor, orient, spin=0)
 {
-  assert(is_num(width) && width>0,"Width must be a positive value");
-  assert(is_num(length) && length>0, "Length must be a positive value");
-  assert(is_num(thickness) && thickness>0, "Thickness must be a positive value");  
-  assert(is_num(snap) && snap>=0, "Snap must be a non-negative value");
-  assert(is_num(depth) && depth>0, "Depth must be a positive value");
-  assert(is_num(compression) && compression >= 0, "Compression must be a nonnegative value");
-  assert(is_bool(lock));
-  assert(is_num(lock_clearance));
   legal_types = ["pin","socket","male","female","double"];
-  assert(in_list(type,legal_types),str("type must be one of ",legal_types));
-  
+  check = 
+    assert(is_num(width) && width>0,"Width must be a positive value")
+    assert(is_num(length) && length>0, "Length must be a positive value")
+    assert(is_num(thickness) && thickness>0, "Thickness must be a positive value")  
+    assert(is_num(snap) && snap>=0, "Snap must be a non-negative value")
+    assert(is_num(depth) && depth>0, "Depth must be a positive value")
+    assert(is_num(compression) && compression >= 0, "Compression must be a nonnegative value")
+    assert(is_bool(lock))
+    assert(is_num(lock_clearance))
+    assert(in_list(type,legal_types),str("type must be one of ",legal_types));
   if (type=="double") {
     attachable(size=[width+2*compression, depth, 2*length], anchor=default(anchor,BACK), spin=spin, orient=default(orient,BACK)){
       union(){
         rabbit_clip("pin", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,
                     lock=lock, anchor=BOTTOM, orient=UP);
         rabbit_clip("pin", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,
                     lock=lock, anchor=BOTTOM, orient=DOWN);
@@ -1097,15 +1144,15 @@
                inside_pt
               ];
     fullpath = concat(
                       sidepath,
                       [bottom_pt], 
                       reverse(apply(xflip(),sidepath))
                       );
-    assert(fullpath[4].y < fullpath[3].y, "Pin is too wide for its length");
+    dummy2 = assert(fullpath[4].y < fullpath[3].y, "Pin is too wide for its length");
     
     snapmargin = -snap + last(sidepath).x;// - compression;
     if (is_pin){
       if (snapmargin<0) echo("WARNING: The snap is too large for the clip to squeeze to fit its socket")
       echo(snapmargin=snapmargin);
     }
     // Force tangent to be vertical at the outer edge of the clip to avoid overshoot
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/linalg.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/linalg.scad`

 * *Files 7% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 
 
 // Section: Matrix testing and display
 
 // Function: is_matrix()
 // Usage:
 //   test = is_matrix(A, [m], [n], [square])
+// Topics: Matrices
 // Description:
 //   Returns true if A is a numeric matrix of height m and width n with finite entries.  If m or n
 //   are omitted or set to undef then true is returned for any positive dimension.
 // Arguments:
 //   A = The matrix to test.
 //   m = If given, requires the matrix to have this height.
 //   n = Is given, requires the matrix to have this width.
@@ -48,27 +49,29 @@
    && is_vector(A[0],n)
    && is_consistent(A);
 
 
 // Function: is_matrix_symmetric()
 // Usage:
 //   b = is_matrix_symmetric(A, [eps])
+// Topics: Matrices
 // Description:
 //   Returns true if the input matrix is symmetric, meaning it approximately equals its transpose.  
 //   The matrix can have arbitrary entries.  
 // Arguments:
 //   A = matrix to test
 //   eps = epsilon for comparing equality.  Default: 1e-12
 function is_matrix_symmetric(A,eps=1e-12) =
     approx(A,transpose(A), eps);
 
 
 // Function: is_rotation()
 // Usage:
 //   b = is_rotation(A, [dim], [centered])
+// Topics: Affine, Matrices, Transforms
 // Description:
 //   Returns true if the input matrix is a square affine matrix that is a rotation around any point,
 //   or around the origin if `centered` is true. 
 //   The matrix must be 3x3 (representing a 2d transformation) or 4x4 (representing a 3d transformation).
 //   You can set `dim` to 2 to require a 2d transform (3x3 matrix) or to 3 to require a 3d transform (4x4 matrix).
 // Arguments:
 //   A = matrix to test
@@ -89,14 +92,15 @@
     (!centered || [for(row=[0:n-2]) if (!approx(A[row][n-1],0)) row]==[]);
   
 
 // Function&Module: echo_matrix()
 // Usage:
 //    echo_matrix(M, [description], [sig], [sep], [eps]);
 //    dummy = echo_matrix(M, [description], [sig], [sep], [eps]),
+// Topics: Matrices
 // Description:
 //    Display a numerical matrix in a readable columnar format with `sig` significant
 //    digits.  Values smaller than eps display as zero.  If you give a description
 //    it is displayed at the top.  You can change the space between columns by
 //    setting `sep` to a number of spaces, which will use wide figure spaces the same
 //    width as digits, or you can set it to any string to separate the columns.
 //    Values that are NaN or INF will display as "nan" and "inf".  Values which are
@@ -125,15 +129,15 @@
 
 
 // Section: Matrix indexing
 
 // Function: column()
 // Usage:
 //   list = column(M, i);
-// Topics: Matrices, List Handling
+// Topics: Matrices, List Handling, Arrays
 // See Also: select(), slice()
 // Description:
 //   Extracts entry `i` from each list in M, or equivalently column i from the matrix M, and returns it as a vector.  
 //   This function will return `undef` at all entry positions indexed by i not found in M.
 // Arguments:
 //   M = The given list of lists.
 //   i = The index to fetch
@@ -151,15 +155,15 @@
     assert( is_int(i) && i>=0, "Invalid index")
     [for(row=M) row[i]];
 
 
 // Function: submatrix()
 // Usage:
 //   mat = submatrix(M, idx1, idx2);
-// Topics: Matrices
+// Topics: Matrices, Arrays
 // See Also: column(), block_matrix(), submatrix_set()
 // Description:
 //   The input must be a list of lists (a matrix or 2d array).  Returns a submatrix by selecting the rows listed in idx1 and columns listed in idx2.
 // Arguments:
 //   M = Given list of lists
 //   idx1 = rows index list or range
 //   idx2 = column index list or range
@@ -184,15 +188,15 @@
 
 
 // Section: Matrix construction and modification
 
 // Function: ident()
 // Usage:
 //   mat = ident(n);
-// Topics: Affine, Matrices
+// Topics: Affine, Matrices, Transforms
 // Description:
 //   Create an `n` by `n` square identity matrix.
 // Arguments:
 //   n = The size of the identity matrix square, `n` by `n`.
 // Example:
 //   mat = ident(3);
 //   // Returns:
@@ -216,15 +220,15 @@
     ]
 ];
 
 
 // Function: diagonal_matrix()
 // Usage:
 //   mat = diagonal_matrix(diag, [offdiag]);
-// Topics: Matrices
+// Topics: Affine, Matrices
 // See Also: column(), submatrix()
 // Description:
 //   Creates a square matrix with the items in the list `diag` on
 //   its diagonal.  The off diagonal entries are set to offdiag,
 //   which is zero by default. 
 // Arguments:
 //   diag = A list of items to put in the diagnal cells of the matrix.
@@ -233,15 +237,15 @@
   assert(is_list(diag) && len(diag)>0)
   [for(i=[0:1:len(diag)-1]) [for(j=[0:len(diag)-1]) i==j?diag[i] : offdiag]];
 
 
 // Function: transpose()
 // Usage:
 //    M = transpose(M, [reverse]);
-// Topics: Matrices
+// Topics: Linear Algebra, Matrices
 // See Also: submatrix(), block_matrix(), hstack(), flatten()
 // Description:
 //    Returns the transpose of the given input matrix.  The input can be a matrix with arbitrary entries or
 //    a numerical vector.  If you give a vector then transpose returns it unchanged.  
 //    When reverse=true, the transpose is done across to the secondary diagonal.  (See example below.)
 //    By default, reverse=false.
 // Example:
@@ -311,31 +315,32 @@
     :  assert( is_vector(M), "Input to transpose must be a vector or list of lists.")
            M;
 
 
 // Function: outer_product()
 // Usage:
 //   x = outer_product(u,v);
+// Topics: Linear Algebra, Matrices
 // Description:
 //   Compute the outer product of two vectors, a matrix.  
 // Usage:
 //   M = outer_product(u,v);
 function outer_product(u,v) =
   assert(is_vector(u) && is_vector(v), "The inputs must be vectors.")
   [for(ui=u) ui*v];
 
 // Function: submatrix_set()
 // Usage:
 //   mat = submatrix_set(M, A, [m], [n]);
-// Topics: Matrices
+// Topics: Matrices, Arrays
 // See Also: column(), submatrix()
 // Description:
 //   Sets a submatrix of M equal to the matrix A.  By default the top left corner of M is set to A, but
 //   you can specify offset coordinates m and n.  If A (as adjusted by m and n) extends beyond the bounds
-//   of M then the extra entries are ignored.  You can pass in A=[[]], a null matrix, and M will be
+//   of M then the extra entries are ignored.  You can pass in `A=[[]]`, a null matrix, and M will be
 //   returned unchanged.  This function works on arbitrary lists of lists and the input M need not be rectangular in shape.  
 // Arguments:
 //   M = Original matrix.
 //   A = Submatrix of new values to write into M
 //   m = Row number of upper-left corner to place A at.  Default: 0
 //   n = Column number of upper-left corner to place A at.  Default: 0 
 function submatrix_set(M,A,m=0,n=0) =
@@ -352,15 +357,15 @@
 
 
 // Function: hstack()
 // Usage: 
 //   A = hstack(M1, M2)
 //   A = hstack(M1, M2, M3)
 //   A = hstack([M1, M2, M3, ...])
-// Topics: Matrices
+// Topics: Matrices, Arrays
 // See Also: column(), submatrix(), block_matrix()
 // Description:
 //   Constructs a matrix by horizontally "stacking" together compatible matrices or vectors.  Vectors are treated as columsn in the stack.
 //   This command is the inverse of `column`.  Note: strings given in vectors are broken apart into lists of characters.  Strings given
 //   in matrices are preserved as strings.  If you need to combine vectors of strings use {{list_to_matrix()}} as shown below to convert the
 //   vector into a column matrix.  Also note that vertical stacking can be done directly with concat.  
 // Arguments:
@@ -404,15 +409,15 @@
         ]
     ];
 
 
 // Function: block_matrix()
 // Usage:
 //    bmat = block_matrix([[M11, M12,...],[M21, M22,...], ... ]);
-// Topics: Matrices
+// Topics: Matrices, Arrays
 // See Also: column(), submatrix()
 // Description:
 //    Create a block matrix by supplying a matrix of matrices, which will
 //    be combined into one unified matrix.  Every matrix in one row
 //    must have the same height, and the combined width of the matrices
 //    in each row must be equal. Strings will stay strings. 
 // Example:
@@ -451,23 +456,24 @@
 
 
 // Section: Solving Linear Equations and Matrix Factorizations
 
 // Function: linear_solve()
 // Usage:
 //   solv = linear_solve(A,b,[pivot])
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Solves the linear system Ax=b.  If `A` is square and non-singular the unique solution is returned.  If `A` is overdetermined
 //   the least squares solution is returned. If `A` is underdetermined, the minimal norm solution is returned.
 //   If `A` is rank deficient or singular then linear_solve returns `[]`.  If `b` is a matrix that is compatible with `A`
 //   then the problem is solved for the matrix valued right hand side and a matrix is returned.  Note that if you 
 //   want to solve Ax=b1 and Ax=b2 that you need to form the matrix `transpose([b1,b2])` for the right hand side and then
 //   transpose the returned value.  The solution is computed using QR factorization.  If `pivot` is set to true (the default) then
 //   pivoting is used in the QR factorization, which is slower but expected to be more accurate.
-// Usage:
+// Arguments:
 //   A = Matrix describing the linear system, which need not be square
 //   b = right hand side for linear system, which can be a matrix to solve several cases simultaneously.  Must be consistent with A.
 //   pivot = if true use pivoting when computing the QR factorization.  Default: true
 function linear_solve(A,b,pivot=true) =
     assert(is_matrix(A), "Input should be a matrix.")
     let(
         m = len(A),
@@ -487,14 +493,15 @@
     m<n ? Q*back_substitute(R,transpose(P)*b,transpose=true) // Too messy to avoid input checks here
         : P*_back_substitute(R, transpose(Q)*b);             // Calling internal version skips input checks
 
 
 // Function: linear_solve3()
 // Usage:
 //   x = linear_solve3(A,b)
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Fast solution to a 3x3 linear system using Cramer's rule (which appears to be the fastest
 //   method in OpenSCAD).  The input `A` must be a 3x3 matrix.  Returns undef if `A` is singular.
 //   The input `b` must be a 3-vector.  Note that Cramer's rule is not a stable algorithm, so for
 //   the highest accuracy on ill-conditioned problems you may want to use the general solver, which is about ten times slower.
 // Arguments:
 //   A = 3x3 matrix for linear system
@@ -511,27 +518,29 @@
   )
   detA==0 ? undef : [det3(Ax), det3(Ay), det3(Az)] / detA;
 
 
 // Function: matrix_inverse()
 // Usage:
 //    mat = matrix_inverse(A)
+// Topics: Matrices, Linear Algebra
 // Description:
 //    Compute the matrix inverse of the square matrix `A`.  If `A` is singular, returns `undef`.
 //    Note that if you just want to solve a linear system of equations you should NOT use this function.
 //    Instead use {{linear_solve()}}, or use {{qr_factor()}}.  The computation
 //    will be faster and more accurate.  
 function matrix_inverse(A) =
     assert(is_matrix(A) && len(A)==len(A[0]),"Input to matrix_inverse() must be a square matrix")
     linear_solve(A,ident(len(A)));
 
 
 // Function: rot_inverse()
 // Usage:
 //   B = rot_inverse(A)
+// Topics: Matrices, Linear Algebra, Affine
 // Description:
 //   Inverts a 2d (3x3) or 3d (4x4) rotation matrix.  The matrix can be a rotation around any center,
 //   so it may include a translation.  This is faster and likely to be more accurate than using `matrix_inverse()`.  
 function rot_inverse(T) =
     assert(is_matrix(T,square=true),"Matrix must be square")
     let( n = len(T))
     assert(n==3 || n==4, "Matrix must be 3x3 or 4x4")
@@ -544,14 +553,15 @@
 
 
 
 
 // Function: null_space()
 // Usage:
 //   x = null_space(A)
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Returns an orthonormal basis for the null space of `A`, namely the vectors {x} such that Ax=0.
 //   If the null space is just the origin then returns an empty list. 
 function null_space(A,eps=1e-12) =
     assert(is_matrix(A))
     let(
         Q_R = qr_factor(transpose(A),pivot=true),
@@ -560,14 +570,15 @@
     )
     len(zrows)==0 ? [] :
     select(transpose(Q_R[0]), zrows);
 
 // Function: qr_factor()
 // Usage:
 //   qr = qr_factor(A,[pivot]);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Calculates the QR factorization of the input matrix A and returns it as the list [Q,R,P].  This factorization can be
 //   used to solve linear systems of equations.  The factorization is `A = Q*R*transpose(P)`.  If pivot is false (the default)
 //   then P is the identity matrix and A = Q*R.  If pivot is true then column pivoting results in an R matrix where the diagonal
 //   is non-decreasing.  The use of pivoting is supposed to increase accuracy for poorly conditioned problems, and is necessary
 //   for rank estimation or computation of the null space, but it may be slower.  
 function qr_factor(A, pivot=false) =
@@ -610,14 +621,15 @@
    : x==y ? 1 : 0]];
 
 
 
 // Function: back_substitute()
 // Usage:
 //   x = back_substitute(R, b, [transpose]);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Solves the problem Rx=b where R is an upper triangular square matrix.  The lower triangular entries of R are
 //   ignored.  If transpose==true then instead solve transpose(R)*x=b.
 //   You can supply a compatible matrix b and it will produce the solution for every column of b.  Note that if you want to
 //   solve Rx=b1 and Rx=b2 you must set b to transpose([b1,b2]) and then take the transpose of the result.  If the matrix
 //   is singular (e.g. has a zero on the diagonal) then it returns [].  
 function back_substitute(R, b, transpose = false) =
@@ -641,14 +653,15 @@
       _back_substitute(R, b, concat([newvalue],x));
 
 
 
 // Function: cholesky()
 // Usage:
 //   L = cholesky(A);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Compute the cholesky factor, L, of the symmetric positive definite matrix A.
 //   The matrix L is lower triangular and `L * transpose(L) = A`.  If the A is
 //   not symmetric then an error is displayed.  If the matrix is symmetric but
 //   not positive definite then undef is returned.  
 function cholesky(A) =
   assert(is_matrix(A,square=true),"A must be a square matrix")
@@ -676,14 +689,15 @@
 
 
 // Section: Matrix Properties: Determinants, Norm, Trace
 
 // Function: det2()
 // Usage:
 //   d = det2(M);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Rturns the determinant for the given 2x2 matrix.
 // Arguments:
 //   M = The 2x2 matrix to get the determinant of.
 // Example:
 //   M = [ [6,-2], [1,8] ];
 //   det = det2(M);  // Returns: 50
@@ -691,14 +705,15 @@
     assert(is_def(M) && M*0==[[0,0],[0,0]], "Expected square matrix (2x2)")
     cross(M[0],M[1]);
 
 
 // Function: det3()
 // Usage:
 //   d = det3(M);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Returns the determinant for the given 3x3 matrix.
 // Arguments:
 //   M = The 3x3 square matrix to get the determinant of.
 // Example:
 //   M = [ [6,4,-2], [1,-2,8], [1,5,7] ];
 //   det = det3(M);  // Returns: -334
@@ -707,14 +722,15 @@
     M[0][0] * (M[1][1]*M[2][2]-M[2][1]*M[1][2]) -
     M[1][0] * (M[0][1]*M[2][2]-M[2][1]*M[0][2]) +
     M[2][0] * (M[0][1]*M[1][2]-M[1][1]*M[0][2]);
 
 // Function: det4()
 // Usage:
 //   d = det4(M);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Returns the determinant for the given 4x4 matrix.
 // Arguments:
 //   M = The 4x4 square matrix to get the determinant of.
 // Example:
 //   M = [ [6,4,-2,1], [1,-2,8,-3], [1,5,7,4], [2,3,4,7] ];
 //   det = det4(M);  // Returns: -1773
@@ -728,14 +744,15 @@
     - M[0][1]*M[1][0]*M[2][2]*M[3][3] - M[0][1]*M[1][2]*M[2][3]*M[3][0] - M[0][1]*M[1][3]*M[2][0]*M[3][2]
     - M[0][2]*M[1][0]*M[2][3]*M[3][1] - M[0][2]*M[1][1]*M[2][0]*M[3][3] - M[0][2]*M[1][3]*M[2][1]*M[3][0]
     - M[0][3]*M[1][0]*M[2][1]*M[3][2] - M[0][3]*M[1][1]*M[2][2]*M[3][0] - M[0][3]*M[1][2]*M[2][0]*M[3][1];
 
 // Function: determinant()
 // Usage:
 //   d = determinant(M);
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Returns the determinant for the given square matrix.
 // Arguments:
 //   M = The NxN square matrix to get the determinant of.
 // Example:
 //   M = [ [6,4,-2,9], [1,-2,8,3], [1,5,7,6], [4,2,5,1] ];
 //   det = determinant(M);  // Returns: 2267
@@ -760,24 +777,31 @@
         ]
     );
 
 
 // Function: norm_fro()
 // Usage:
 //    norm_fro(A)
+// Topics: Matrices, Linear Algebra
 // Description:
 //    Computes frobenius norm of input matrix.  The frobenius norm is the square root of the sum of the
 //    squares of all of the entries of the matrix.  On vectors it is the same as the usual 2-norm.
 //    This is an easily computed norm that is convenient for comparing two matrices.  
 function norm_fro(A) =
     assert(is_matrix(A) || is_vector(A))
     norm(flatten(A));
 
 
 // Function: matrix_trace()
 // Usage:
 //   matrix_trace(M)
+// Topics: Matrices, Linear Algebra
 // Description:
 //   Computes the trace of a square matrix, the sum of the entries on the diagonal.  
 function matrix_trace(M) =
    assert(is_matrix(M,square=true), "Input to trace must be a square matrix")
    [for(i=[0:1:len(M)-1])1] * [for(i=[0:1:len(M)-1]) M[i][i]];
+
+
+
+// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
+
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/lists.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/lists.scad`

 * *Files 3% similar despite different names*

```diff
@@ -14,18 +14,19 @@
 //   **Vector** = A list of numbers. ie: `[4, 5, 6]`
 //   **Set** = A list of unique items.
 
 // Section: List Query Operations
 
 // Function: is_homogeneous()
 // Alias: is_homogenous()
-// Usage:
-//   bool = is_homogeneous(list, [depth]);
+// Synopsis: Returns true if all members of a list are of the same type.
 // Topics: List Handling, Type Checking
 // See Also: is_vector(), is_matrix()
+// Usage:
+//   bool = is_homogeneous(list, [depth]);
 // Description:
 //   Returns true when the list has elements of same type up to the depth `depth`.
 //   Booleans and numbers are not distinguinshed as of distinct types. 
 // Arguments:
 //   l = the list to check
 //   depth = the lowest level the check is done.  Default: 10
 // Example:
@@ -49,34 +50,36 @@
     (is_num(a) && is_num(b)) ||
     (is_string(a) && is_string(b)) ||
     (is_list(a) && is_list(b) && len(a)==len(b) 
           && []==[for(i=idx(a)) if( ! _same_type(a[i],b[i],depth-1) ) 0] ); 
   
 
 // Function: min_length()
-// Usage:
-//   llen = min_length(list);
+// Synopsis: Given a list of sublists, returns the length of the shortest sublist.
 // Topics: List Handling
 // See Also: max_length()
+// Usage:
+//   llen = min_length(list);
 // Description:
 //   Returns the length of the shortest sublist in a list of lists.
 // Arguments:
 //   list = A list of lists.
 // Example:
 //   slen = min_length([[3,4,5],[6,7,8,9]]);  // Returns: 3
 function min_length(list) =
     assert(is_list(list), "Invalid input." )
     min([for (v = list) len(v)]);
 
 
 // Function: max_length()
-// Usage:
-//   llen = max_length(list);
+// Synopsis: Given a list of sublists, returns the length of the longest sublist.
 // Topics: List Handling
 // See Also: min_length()
+// Usage:
+//   llen = max_length(list);
 // Description:
 //   Returns the length of the longest sublist in a list of lists.
 // Arguments:
 //   list = A list of lists.
 // Example:
 //   llen = max_length([[3,4,5],[6,7,8,9]]);  // Returns: 4
 function max_length(list) =
@@ -103,17 +106,19 @@
     let( alen = [for(vi=v) is_list(vi) ? len(vi): -1] )
     v==[] || max(alen)==-1 ? [] :
     let( add = max(alen)!=min(alen) ? undef : alen[0] ) 
     concat( add, _list_shape_recurse(flatten(v)));
 
 
 // Function: list_shape()
+// Synopsis: Returns the dimensions of an array.
+// Topics: Matrices, List Handling
+// See Also: is_homogenous()
 // Usage:
 //   dims = list_shape(v, [depth]);
-// Topics: Matrices, List Handling
 // Description:
 //   Returns the size of a multi-dimensional array, a list of the lengths at each depth.
 //   If the returned value has `dims[i] = j` then it means the ith index ranges of j items.
 //   The return `dims[0]` is equal to the length of v.  Then `dims[1]` is equal to the
 //   length of the lists in v, and in general, `dims[i]` is equal to the length of the items
 //   nested to depth i in the list v.  If the length of items at that depth is inconsistent, then
 //   `undef` is returned.  If no items exist at that depth then `0` is returned.  Note that
@@ -135,17 +140,19 @@
         ?  len(v)
         :  let( dimlist = _list_shape_recurse(v))
            (depth > len(dimlist))? 0 : dimlist[depth-1] ;
 
 
 
 // Function: in_list()
+// Synopsis: Returns true if a value is in a list.
+// Topics: List Handling
+// See Also: select(), slice()
 // Usage:
 //   bool = in_list(val, list, [idx]);
-// Topics: List Handling
 // Description:
 //   Returns true if value `val` is in list `list`. When `val==NAN` the answer will be false for any list.
 // Arguments:
 //   val = The simple value to search for.
 //   list = The list to search.
 //   idx = If given, searches the given columns for matches for `val`.
 // Example:
@@ -173,15 +180,17 @@
     : [for(hit=allhits) if (list[hit][idx]==val) 1] != [];
 
 
 
 // Section: List Indexing
 
 // Function: select()
+// Synopsis: Returns one or more items from a list, with wrapping.
 // Topics: List Handling
+// See Also: slice(), column(), last()
 // Description:
 //   Returns a portion of a list, wrapping around past the beginning, if end<start. 
 //   The first item is index 0. Negative indexes are counted back from the end.
 //   The last item is -1.  If only the `start` index is given, returns just the value
 //   at that position when `start` is a number or the selected list of entries when `start` is
 //   a list of indices or a range.
 // Usage:
@@ -189,15 +198,14 @@
 //   item = select(list, [s:d:e]);
 //   item = select(list, [i0,i1...,ik]);
 //   list = select(list, start, end);
 // Arguments:
 //   list = The list to get the portion of.
 //   start = Either the index of the first item or an index range or a list of indices.
 //   end = The index of the last item when `start` is a number. When `start` is a list or a range, `end` should not be given.
-// See Also: slice(), column(), last()
 // Example:
 //   l = [3,4,5,6,7,8,9];
 //   a = select(l, 5, 6);   // Returns [8,9]
 //   b = select(l, 5, 8);   // Returns [8,9,3,4]
 //   c = select(l, 5, 2);   // Returns [8,9,3,4,5]
 //   d = select(l, -3, -1); // Returns [7,8,9]
 //   e = select(l, 3, 3);   // Returns [6]
@@ -221,66 +229,72 @@
             (s <= e)
               ? [ for (i = [s:1:e])   list[i] ]
               : [ for (i = [s:1:l-1]) list[i], 
                   for (i = [0:1:e])   list[i] ] ;
 
 
 // Function: slice()
+// Synopsis: Returns part of a list without wrapping.
+// Topics: List Handling
+// See Also: select(), column(), last()
 // Usage:
 //   list = slice(list, s, e);
 // Description:
 //   Returns a slice of a list, from the first position `s` up to and including the last position `e`.
-//   The first item in the list is at index 0.  Negative indexes are counted back from the end.
-//   An index of -1 refers to the last list item.
+//   The first item in the list is at index 0.  Negative indexes are counted back from the end, with
+//   -1 referring to the last list item.  If `s` is after `e` then the empty list is returned.
+//   If an index is off the start/end of the list it will refer to the list start/end.  
 // Arguments:
 //   list = The list to get the slice of.
 //   start = The index of the first item to return.  Default: 0
 //   end = The index of the last item to return.  Default: -1 (last item)
-// See Also: select(), column(), last()
 // Example:
 //   a = slice([3,4,5,6,7,8,9], 3, 5);   // Returns [6,7,8]
 //   b = slice([3,4,5,6,7,8,9], 2, -1);  // Returns [5,6,7,8,9]
 //   c = slice([3,4,5,6,7,8,9], 1, 1);   // Returns [4]
 //   d = slice([3,4,5,6,7,8,9], 5);      // Returns [8,9]
 //   e = slice([3,4,5,6,7,8,9], 2, -2);  // Returns [5,6,7,8]
 //   f = slice([3,4,5,6,7,8,9], 4, 3;    // Returns []
+//   g = slice([3,4,5], 1, 5;            // Returns [4,5]
+//   h = slice([3,4,5], 5, 7);           // Returns []
 function slice(list,start=0,end=-1) =
     assert(is_list(list))
     assert(is_int(start))
     assert(is_int(end))
     !list? [] :
     let(
         l = len(list),
-        start = constrain(start + (start<0? l : 0), 0, l-1),
-        end = constrain(end + (end<0? l : 0), 0, l-1)
+        start = start+(start<0 ? l : 0),
+        end = end + (end<0? l : 0)
     )
-    [if (end>=start) for (i=[start:1:end]) list[i]];
-
+    [if (start<=end && end>=0 && start<=l) for (i=[max(start,0):1:min(end,l-1)]) list[i]];
 
 // Function: last()
-// Usage:
-//   item = last(list);
+// Synopsis: Returns the last item of a list.
 // Topics: List Handling
 // See Also: select(), slice(), column()
+// Usage:
+//   item = last(list);
 // Description:
 //   Returns the last element of a list, or undef if empty.
 // Arguments:
 //   list = The list to get the last element of.
 // Example:
 //   l = [3,4,5,6,7,8,9];
 //   x = last(l);  // Returns 9.
 function last(list) =
     list[len(list)-1];
 
 
 // Function: list_head()
-// Usage:
-//   list = list_head(list, [to]);
+// Synopsis: Returns the elements at the beginning of a list.
 // Topics: List Handling
 // See Also: select(), slice(), list_tail(), last()
+// Usage:
+//   list = list_head(list, [to]);
 // Description:
 //   Returns the head of the given list, from the first item up until the `to` index, inclusive.
 //   By default returns all but the last element of the list.  
 //   If the `to` index is negative, then the length of the list is added to it, such that
 //   `-1` is the last list item.  `-2` is the second from last.  `-3` is third from last, etc.
 //   If the list is shorter than the given index, then the full list is returned.
 // Arguments:
@@ -297,18 +311,19 @@
    assert(is_finite(to))
    to<0? [for (i=[0:1:len(list)+to]) list[i]] :
    to<len(list)? [for (i=[0:1:to]) list[i]] :
    list;
 
 
 // Function: list_tail()
-// Usage:
-//   list = list_tail(list, [from]);
+// Synopsis: Returns the elements at the end of a list.
 // Topics: List Handling
 // See Also: select(), slice(), list_tail(), last()
+// Usage:
+//   list = list_tail(list, [from]);
 // Description:
 //   Returns the tail of the given list, from the `from` index up until the end of the list, inclusive.
 //   By default returns all but the first item.  
 //   If the `from` index is negative, then the length of the list is added to it, such that
 //   `-1` is the last list item.  `-2` is the second from last.  `-3` is third from last, etc.
 //   If you want it to return the last three items of the list, use `from=-3`.
 // Arguments:
@@ -327,43 +342,42 @@
    let(from = from + len(list))
    from>=0? [for (i=[from:1:len(list)-1]) list[i]] :
    list;
 
 
 
 // Function: bselect()
-// Usage:
-//   sublist = bselect(list, index);
+// Synopsis: Select list items using boolean index list.
 // Topics: List Handling
 // See Also: list_bset()
+// Usage:
+//   sublist = bselect(list, index);
 // Description:
-//   Returns the items in `list` whose matching element in `index` is true.
+//   Returns the items in `list` whose matching element in `index` evaluates as true.  
 // Arguments:
-//   list = Initial list to extract items from.
-//   index = List of booleans.
+//   list = Initial list (or string) to extract items from.
+//   index = List of values that will be evaluated as boolean, same length as `list`.  
 // Example:
 //   a = bselect([3,4,5,6,7], [false,true,true,false,true]);  // Returns: [4,5,7]
 function bselect(list,index) =
-    assert(is_list(list)||is_string(list), "Improper list." )
-    assert(is_list(index) && len(index)>=len(list) , "Improper index list." )
+    assert(is_list(list)||is_string(list), "First argument must be a list or string." )
+    assert(is_list(index) && len(index)==len(list) , "Second argument must have same length as the first." )
     is_string(list)? str_join(bselect( [for (x=list) x], index)) :
-    [for(i=[0:len(list)-1]) if (index[i]) list[i]];
-
-
-
+    [for(i=idx(list)) if (index[i]) list[i]];
 
 
 // Section: List Construction
 
 
 // Function: repeat()
-// Usage:
-//   list = repeat(val, n);
+// Synopsis: Returns a list of repeated copies of a value.
 // Topics: List Handling
 // See Also: count(), lerpn()
+// Usage:
+//   list = repeat(val, n);
 // Description:
 //   Generates a list of `n` copies of the given value `val`.
 //   If the count `n` is given as a list of counts, then this creates a
 //   multi-dimensional array, filled with `val`.
 // Arguments:
 //   val = The value to repeat to make the list or array.
 //   n = The number of copies to make of `val`.  Can be a list to make an array of copies.
@@ -377,18 +391,19 @@
     assert( is_list(n), "Invalid count number.")
     (i>=len(n))? val :
     [for (j=[1:1:n[i]]) repeat(val, n, i+1)];
 
 
 
 // Function: list_bset()
-// Usage:
-//   arr = list_bset(indexset, valuelist, [dflt]);
+// Synopsis: Returns a list where values are spread to locations indicated by a boolean index list.
 // Topics: List Handling
 // See Also: bselect()
+// Usage:
+//   arr = list_bset(indexset, valuelist, [dflt]);
 // Description:
 //   Opposite of `bselect()`.  Returns a list the same length as `indexlist`, where each item will
 //   either be 0 if the corresponding item in `indexset` is false, or the next sequential value
 //   from `valuelist` if the item is true.  The number of `true` values in `indexset` must be equal 
 //   to the length of `valuelist`.
 // Arguments:
 //   indexset = A list of boolean values.
@@ -407,36 +422,38 @@
         list_set([],trueind, valuelist, dflt=dflt),    // Fill in all of the values
         repeat(dflt,len(indexset)-max(trueind)-1)  // Add trailing values so length matches indexset
     );
 
 
 
 // Function: list()
+// Synopsis: Expands a range into a full list.
 // Topics: List Handling, Type Conversion
+// See Also: scalar_vec3(), force_list()
 // Usage:
 //   list = list(l)
 // Description:
 //   Expands a range into a full list.  If given a list, returns it verbatim.
 //   If given a string, explodes it into a list of single letters.
 // Arguments:
 //   l = The value to expand.
-// See Also: scalar_vec3(), force_list()
 // Example:
 //   l1 = list([3:2:9]);  // Returns: [3,5,7,9]
 //   l2 = list([3,4,5]);  // Returns: [3,4,5]
 //   l3 = list("Foo");    // Returns: ["F","o","o"]
 //   l4 = list(23);       // Returns: [23]
 function list(l) = is_list(l)? l : [for (x=l) x];
 
 
 // Function: force_list()
-// Usage:
-//   list = force_list(value, [n], [fill]);
+// Synopsis: Coerces non-list values into a list.
 // Topics: List Handling
 // See Also: scalar_vec3()
+// Usage:
+//   list = force_list(value, [n], [fill]);
 // Description:
 //   Coerces non-list values into a list.  Makes it easy to treat a scalar input
 //   consistently as a singleton list, as well as list inputs.
 //   - If `value` is a list, then that list is returned verbatim.
 //   - If `value` is not a list, and `fill` is not given, then a list of `n` copies of `value` will be returned.
 //   - If `value` is not a list, and `fill` is given, then a list `n` items long will be returned where `value` will be the first item, and the rest will contain the value of `fill`.
 // Arguments:
@@ -452,35 +469,37 @@
     is_list(value) ? value :
     is_undef(fill)? [for (i=[1:1:n]) value] : [value, for (i=[2:1:n]) fill];
 
 
 // Section: List Modification
 
 // Function: reverse()
-// Usage:
-//   rlist = reverse(list);
+// Synopsis: Reverses the elements of a list.
 // Topics: List Handling
 // See Also: select(), list_rotate()
+// Usage:
+//   rlist = reverse(list);
 // Description:
 //   Reverses a list or string.
 // Arguments:
 //   list = The list or string to reverse.
 // Example:
 //   reverse([3,4,5,6]);  // Returns [6,5,4,3]
 function reverse(list) =
     assert(is_list(list)||is_string(list), str("Input to reverse must be a list or string. Got: ",list))
     let (elems = [ for (i = [len(list)-1 : -1 : 0]) list[i] ])
     is_string(list)? str_join(elems) : elems;
 
 
 // Function: list_rotate()
-// Usage:
-//   rlist = list_rotate(list, [n]);
+// Synopsis: Rotates the ordering of a list.
 // Topics: List Handling
 // See Also: select(), reverse()
+// Usage:
+//   rlist = list_rotate(list, [n]);
 // Description:
 //   Rotates the contents of a list by `n` positions left, so that list[n] becomes the first entry of the list.
 //   If `n` is negative, then the rotation is `abs(n)` positions to the right.
 //   If `list` is a string, then a string is returned with the characters rotates within the string.
 // Arguments:
 //   list = The list to rotate.
 //   n = The number of positions to rotate by.  If negative, rotated to the right.  Positive rotates to the left.  Default: 1
@@ -506,18 +525,19 @@
         ]
     )
     is_string(list)? str_join(elems) : elems;
 
     
 
 // Function: shuffle()
-// Usage:
-//   shuffled = shuffle(list, [seed]);
+// Synopsis: Randomizes the order of a list.
 // Topics: List Handling
 // See Also: sort(), sortidx(), unique(), unique_count()
+// Usage:
+//   shuffled = shuffle(list, [seed]);
 // Description:
 //   Shuffles the input list into random order.
 //   If given a string, shuffles the characters within the string.
 //   If you give a numeric seed value then the permutation
 //   will be repeatable.
 // Arguments:
 //   list = The list to shuffle.
@@ -539,18 +559,19 @@
         right = [for (i=[0:len(list)-1]) if (rval[i]>=0.5) list[i]]
     ) 
     concat(shuffle(left), shuffle(right));
 
 
 
 // Function: repeat_entries()
-// Usage:
-//   newlist = repeat_entries(list, N, [exact]);
+// Synopsis: Repeats list entries (as uniformly as possible) to make list of specified length.
 // Topics: List Handling
 // See Also: repeat()
+// Usage:
+//   newlist = repeat_entries(list, N, [exact]);
 // Description:
 //   Takes a list as input and duplicates some of its entries to produce a list
 //   with length `N`.  If the requested `N` is not a multiple of the list length then
 //   the entries will be duplicated as uniformly as possible.  You can also set `N` to a vector,
 //   in which case len(N) must equal len(list) and the output repeats the ith entry N[i] times.
 //   In either case, the result will be a list of length `N`.  The `exact` option requires
 //   that the final length is exactly as requested.  If you set it to `false` then the
@@ -580,18 +601,19 @@
                  _sum_preserving_round(reps_guess) 
                : [for (val=reps_guess) round(val)]
     )
     [for(i=[0:length-1]) each repeat(list[i],reps[i])];
 
 
 // Function: list_pad()
-// Usage:
-//   newlist = list_pad(list, minlen, [fill]);
+// Synopsis: Extend list to specified length.
 // Topics: List Handling
 // See Also: force_list(), scalar_vec3()
+// Usage:
+//   newlist = list_pad(list, minlen, [fill]);
 // Description:
 //   If the list `list` is shorter than `minlen` length, pad it to length with the value given in `fill`.
 // Arguments:
 //   list = A list.
 //   minlen = The minimum length to pad the list to.
 //   fill = The value to pad the list with.  Default: `undef`
 // Example:
@@ -599,18 +621,19 @@
 //   nlist = list_pad(list,5,23);  // Returns: [3,4,5,23,23]
 function list_pad(list, minlen, fill) =
     assert(is_list(list), "Invalid input." )
     concat(list,repeat(fill,minlen-len(list)));
 
 
 // Function: list_set()
-// Usage:
-//   list = list_set(list, indices, values, [dflt], [minlen]);
+// Synopsis: Sets the value of specific list items.
 // Topics: List Handling
 // See Also: list_insert(), list_remove(), list_remove_values()
+// Usage:
+//   list = list_set(list, indices, values, [dflt], [minlen]);
 // Description:
 //   Takes the input list and returns a new list such that `list[indices[i]] = values[i]` for all of
 //   the (index,value) pairs supplied and unchanged for other indices.  If you supply `indices` that are 
 //   beyond the length of the list then the list is extended and filled in with the `dflt` value.  
 //   If you set `minlen` then the list is lengthed, if necessary, by padding with `dflt` to that length.  
 //   Repetitions in `indices` are not allowed. The lists `indices` and `values` must have the same length.  
 //   If `indices` is given as a scalar, then that index of the given `list` will be set to the scalar value of `values`.
@@ -645,18 +668,19 @@
               ? values[k]
               : i<len(list) ? list[i] : dflt,
             each repeat(dflt, minlen-max(len(list),max(indices)))
         ];
 
 
 // Function: list_insert()
-// Usage:
-//   list = list_insert(list, indices, values);
+// Synopsis: Inserts values into the middle of a list.
 // Topics: List Handling
 // See Also: list_set(), list_remove(), list_remove_values()
+// Usage:
+//   list = list_insert(list, indices, values);
 // Description:
 //   Insert `values` into `list` before position `indices`.  The indices for insertion 
 //   are based on the original list, before any insertions have occurred.  
 // Arguments:
 //   list = list to insert items into
 //   indices = index or list of indices where values are inserted
 //   values = value or list of values to insert
@@ -689,18 +713,19 @@
             ) each ( k != undef  ? [ values[k], list[i] ] : [ list[i] ] ),
         for ( i = [min(maxidx, len(list)-1)+1 : 1 : len(list)-1] ) list[i],
         if (maxidx == len(list)) values[max_index(indices)]
     ];
 
 
 // Function: list_remove()
-// Usage:
-//   list = list_remove(list, ind);
+// Synopsis: Removes items by index from a list.
 // Topics: List Handling
 // See Also: list_set(), list_insert(), list_remove_values()
+// Usage:
+//   list = list_remove(list, ind);
 // Description:
 //   If `ind` is a number remove `list[ind]` from the list.  If `ind` is a list of indices
 //   remove from the list the item all items whose indices appear in `ind`.  If you give
 //   indices that are not in the list they are ignored.  
 // Arguments:
 //   list = The list to remove items from.
 //   ind = index or list of indices of items to remove. 
@@ -731,18 +756,19 @@
 // This method is faster for long lists with few values to remove
 //     let(   rem = list_set([], indices, repeat(1,len(indices)), minlen=len(list)))
 //     [for(i=idx(list)) if (rem[i]==0) list[i]];
 
 
 
 // Function: list_remove_values()
-// Usage:
-//   list = list_remove_values(list, values, [all]);
+// Synopsis: Removes items by value from a list.
 // Topics: List Handling
 // See Also: list_set(), list_insert(), list_remove()
+// Usage:
+//   list = list_remove_values(list, values, [all]);
 // Description:
 //   Removes the first, or all instances of the given value or list of values from the list.
 //   If you specify `all=false` and list a value twice then the first two instances will be removed.  
 //   Note that if you want to remove a list value such as `[3,4]` then you must give it as
 //   a singleton list, or it will be interpreted as a list of two scalars to remove.  
 // Arguments:
 //   list = The list to modify.
@@ -795,25 +821,27 @@
           else
             let(check = [for(j=hit) if (values[j]==list[i]) 1])
             if (check==[]) list[i]
     ];
 
 
 
-
-// Section: Lists of Subsets
+// Section: List Iteration Index Helper
 
 // Function: idx()
+// Synopsis: Returns a range useful for iterating over a list.
+// Topics: List Handling, Iteration
+// See Also: count()
 // Usage:
-//   rng = idx(list, [s=], [e=], [step=]);
+//   range = idx(list, [s=], [e=], [step=]);
 //   for(i=idx(list, [s=], [e=], [step=])) ...
-// Topics: List Handling, Iteration
-// See Also: pair(), triplet(), combinations(), permutations()
 // Description:
-//   Returns the range of indexes for the given list.
+//   Returns the range that gives the indices for a given list.  This makes is a little bit
+//   easier to loop over a list by index, when you need the index numbers and looping of list values isn't enough.
+//   Note that the return is a **range** not a list.  
 // Arguments:
 //   list = The list to returns the index range of.
 //   ---
 //   s = The starting index.  Default: 0
 //   e = The delta from the end of the list.  Default: -1 (end of list)
 //   step = The step size to stride through the list.  Default: 1
 // Example(2D):
@@ -825,21 +853,24 @@
     ll == 0 ? [0:1:ll-1] :
     let(
         _s = posmod(s,ll),
         _e = posmod(e,ll)
     ) [_s : step : _e];
 
 
+// Section: Lists of Subsets
+
 
 // Function: pair()
+// Synopsis: Returns a list of overlapping consecutive pairs in a list.
+// Topics: List Handling, Iteration
+// See Also: idx(), triplet(), combinations(), permutations()
 // Usage:
 //   p = pair(list, [wrap]);
 //   for (p = pair(list, [wrap])) ...  // On each iteration, p contains a list of two adjacent items.
-// Topics: List Handling, Iteration
-// See Also: idx(), triplet(), combinations(), permutations()
 // Description:
 //   Returns a list of all of the pairs of adjacent items from a list, optionally wrapping back to the front.  The pairs overlap, and
 //   are returned in order starting with the first two entries in the list.  If the list has less than two elements, the empty list is returned. 
 // Arguments:
 //   list = The list to use for making pairs
 //   wrap = If true, wrap back to the start from the end.  ie: return the last and first items as the last pair.  Default: false
 // Example(2D): Does NOT wrap from end to start,
@@ -860,19 +891,20 @@
       for (i=[0:1:L-1]) [list[i], list[i+1]],
       if(wrap) [list[L], list[0]]
     ];
 
 
 
 // Function: triplet()
+// Synopsis: Returns a list of overlapping consecutive triplets in a list.
+// Topics: List Handling, Iteration
+// See Also: idx(), pair(), combinations(), permutations()
 // Usage:
 //   list = triplet(list, [wrap]);
 //   for (t = triplet(list, [wrap])) ...
-// Topics: List Handling, Iteration
-// See Also: idx(), pair(), combinations(), permutations()
 // Description:
 //   Returns a list of all adjacent triplets from a list, optionally wrapping back to the front.
 //   If you set `wrap` to true then the first triplet is the one centered on the first list element, so it includes
 //   the last element and the first two elements.  If the list has fewer than three elements then the empty list is returned.
 // Arguments:
 //   list = list to produce triplets from
 //   wrap = if true, wrap triplets around the list.  Default: false
@@ -899,18 +931,19 @@
       if(wrap) [list[L-1], list[0], list[1]],
       for (i=[0:1:L-3]) [list[i],list[i+1],list[i+2]],
       if(wrap) [list[L-2], list[L-1], list[0]]
     ];
 
 
 // Function: combinations()
-// Usage:
-//   list = combinations(l, [n]);
+// Synopsis: Returns a list of all combinations of the list entries.
 // Topics: List Handling, Iteration
 // See Also: idx(), pair(), triplet(), permutations()
+// Usage:
+//   list = combinations(l, [n]);
 // Description:
 //   Returns a list of all of the (unordered) combinations of `n` items out of the given list `l`.
 //   For the list `[1,2,3,4]`, with `n=2`, this will return `[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]`.
 //   For the list `[1,2,3,4]`, with `n=3`, this will return `[[1,2,3], [1,2,4], [1,3,4], [2,3,4]]`.
 // Arguments:
 //   l = The list to provide permutations for.
 //   n = The number of items in each combination. Default: 2
@@ -925,18 +958,19 @@
     n==1
       ? [for (i=[_s:1:len(l)-1]) [l[i]]] 
       : [for (i=[_s:1:len(l)-n], p=combinations(l,n=n-1,_s=i+1)) concat([l[i]], p)];
 
 
 
 // Function: permutations()
-// Usage:
-//   list = permutations(l, [n]);
+// Synopsis: Returns a list of all permutations of the list entries.
 // Topics: List Handling, Iteration
 // See Also: idx(), pair(), triplet(), combinations()
+// Usage:
+//   list = permutations(l, [n]);
 // Description:
 //   Returns a list of all of the (ordered) permutation `n` items out of the given list `l`.  
 //   For the list `[1,2,3]`, with `n=2`, this will return `[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]`
 //   For the list `[1,2,3]`, with `n=3`, this will return `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`
 // Arguments:
 //   l = The list to provide permutations for.
 //   n = The number of items in each permutation. Default: 2
@@ -951,56 +985,59 @@
 
 
 
 // Section: Changing List Structure
 
 
 // Function: list_to_matrix()
+// Synopsis: Groups items in a list into sublists.
+// Topics: Matrices, List Handling
+// See Also: column(), submatrix(), hstack(), flatten(), full_flatten()
 // Usage:
 //   groups = list_to_matrix(v, cnt, [dflt]);
 // Description:
 //   Takes a flat list of values, and groups items in sets of `cnt` length.
 //   The opposite of this is `flatten()`.
-// Topics: Matrices, List Handling
-// See Also: column(), submatrix(), hstack(), flatten(), full_flatten()
 // Arguments:
 //   v = The list of items to group.
 //   cnt = The number of items to put in each grouping. 
 //   dflt = The default value to fill in with if the list is not a multiple of `cnt` items long.  Default: undef
 // Example:
 //   v = [1,2,3,4,5,6];
-//   a = list_to_matrix(v,2) returns [[1,2], [3,4], [5,6]]
-//   b = list_to_matrix(v,3) returns [[1,2,3], [4,5,6]]
-//   c = list_to_matrix(v,4,0) returns [[1,2,3,4], [5,6,0,0]]
+//   a = list_to_matrix(v,2)  // returns [[1,2], [3,4], [5,6]]
+//   b = list_to_matrix(v,3)  // returns [[1,2,3], [4,5,6]]
+//   c = list_to_matrix(v,4,0)  // returns [[1,2,3,4], [5,6,0,0]]
 function list_to_matrix(v, cnt, dflt=undef) =
     [for (i = [0:cnt:len(v)-1]) [for (j = [0:1:cnt-1]) default(v[i+j], dflt)]];
 
 
 
 // Function: flatten()
-// Usage:
-//   list = flatten(l);
+// Synopsis: Flattens a list of sublists into a single list.
 // Topics: Matrices, List Handling
 // See Also: column(), submatrix(), hstack(), full_flatten()
+// Usage:
+//   list = flatten(l);
 // Description:
 //   Takes a list of lists and flattens it by one level.
 // Arguments:
 //   l = List to flatten.
 // Example:
 //   l = flatten([[1,2,3], [4,5,[6,7,8]]]);  // returns [1,2,3,4,5,[6,7,8]]
 function flatten(l) =
     !is_list(l)? l :
     [for (a=l) if (is_list(a)) (each a) else a];
 
 
 // Function: full_flatten()
-// Usage:
-//   list = full_flatten(l);
+// Synopsis: Recursively flattens nested sublists into a single list of non-list values.
 // Topics: Matrices, List Handling
 // See Also: column(), submatrix(), hstack(), flatten()
+// Usage:
+//   list = full_flatten(l);
 // Description: 
 //   Collects in a list all elements recursively found in any level of the given list.
 //   The output list is ordered in depth first order.
 // Arguments:
 //   l = List to flatten.
 // Example:
 //   l = full_flatten([[1,2,3], [4,5,[6,7,8]]]);  // returns [1,2,3,4,5,6,7,8]
@@ -1009,18 +1046,19 @@
     [for (a=l) if (is_list(a)) (each full_flatten(a)) else a];
 
 
 
 // Section: Set Manipulation
 
 // Function: set_union()
-// Usage:
-//   s = set_union(a, b, [get_indices]);
+// Synopsis: Merges two lists, returning a list of unique items.
 // Topics: Set Handling, List Handling
 // See Also: set_difference(), set_intersection()
+// Usage:
+//   s = set_union(a, b, [get_indices]);
 // Description:
 //   Given two sets (lists with unique items), returns the set of unique items that are in either `a` or `b`.
 //   If `get_indices` is true, a list of indices into the new union set are returned for each item in `b`,
 //   in addition to returning the new union set.  In this case, a 2-item list is returned, `[INDICES, NEWSET]`,
 //   where INDICES is the list of indices for items in `b`, and NEWSET is the new union set.
 // Arguments:
 //   a = One of the two sets to merge.
@@ -1051,18 +1089,19 @@
         idxs =  [ for (i=idx(b))
                     (found1[i] != [])? found1[i] : la + found3[i]
                 ]
     ) [idxs, nset];
 
 
 // Function: set_difference()
-// Usage:
-//   s = set_difference(a, b);
+// Synopsis: Returns a list of unique items that are in list A, but not in list B.
 // Topics: Set Handling, List Handling
 // See Also: set_union(), set_intersection()
+// Usage:
+//   s = set_difference(a, b);
 // Description:
 //   Given two sets (lists with unique items), returns the set of items that are in `a`, but not `b`.
 // Arguments:
 //   a = The starting set.
 //   b = The set of items to remove from set `a`.
 // Example:
 //   set_a = [2,3,5,7,11];
@@ -1072,18 +1111,19 @@
 function set_difference(a, b) =
     assert( is_list(a) && is_list(b), "Invalid sets." )
     let( found = search(a, b, num_returns_per_match=1) )
     [ for (i=idx(a)) if(found[i]==[]) a[i] ];
 
 
 // Function: set_intersection()
-// Usage:
-//   s = set_intersection(a, b);
+// Synopsis: Returns a list of unique items that are in both given lists.
 // Topics: Set Handling, List Handling
 // See Also: set_union(), set_difference()
+// Usage:
+//   s = set_intersection(a, b);
 // Description:
 //   Given two sets (lists with unique items), returns the set of items that are in both sets.
 // Arguments:
 //   a = The starting set.
 //   b = The set of items to intersect with set `a`.
 // Example:
 //   set_a = [2,3,5,7,11];
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/masks2d.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/masks2d.scad`

 * *Files 6% similar despite different names*

```diff
@@ -11,41 +11,51 @@
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: 2D Masking Shapes
 
 // Function&Module: mask2d_roundover()
+// Synopsis: Creates a 2D beading mask shape useful for rounding 90° edges.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
+// See Also: corner_profile(), edge_profile(), face_profile(), fillet()
 // Usage: As module
 //   mask2d_roundover(r|d=, [inset], [excess]) [ATTACHMENTS];
 // Usage: As function
 //   path = mask2d_roundover(r|d=, [inset], [excess]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D roundover/bead mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior fillet between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 // Arguments:
 //   r = Radius of the roundover.
 //   inset = Optional bead inset size.  Default: 0
 //   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01
 //   ---
 //   d = Diameter of the roundover.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 // Example(2D): 2D Roundover Mask
 //   mask2d_roundover(r=10);
 // Example(2D): 2D Bead Mask
 //   mask2d_roundover(r=10,inset=2);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_roundover(r=10, inset=2);
+// Example: Making an interior fillet
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_roundover(r=10);
 module mask2d_roundover(r, inset=0, excess=0.01, d, anchor=CENTER,spin=0) {
     path = mask2d_roundover(r=r,d=d,excess=excess,inset=inset);
     attachable(anchor,spin, two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
@@ -65,41 +75,51 @@
             [-excess, r+inset.y],
             for (i=[0:1:steps]) [r,r] + inset + polar_to_xy(r,180+i*step)
         ]
     ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path);
 
 
 // Function&Module: mask2d_cove()
+// Synopsis: Creates a 2D cove (quarter-round) mask shape.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As module
 //   mask2d_cove(r|d=, [inset], [excess]) [ATTACHMENTS];
 // Usage: As function
 //   path = mask2d_cove(r|d=, [inset], [excess]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D cove mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior rounded shelf decoration between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 // Arguments:
 //   r = Radius of the cove.
 //   inset = Optional amount to inset code from corner.  Default: 0
 //   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01
 //   ---
 //   d = Diameter of the cove.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 // Example(2D): 2D Cove Mask
 //   mask2d_cove(r=10);
 // Example(2D): 2D Inset Cove Mask
 //   mask2d_cove(r=10,inset=3);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_cove(r=10, inset=2);
+// Example: Making an interior rounded shelf
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_cove(r=5, inset=5);
 module mask2d_cove(r, inset=0, excess=0.01, d, anchor=CENTER,spin=0) {
     path = mask2d_cove(r=r,d=d,excess=excess,inset=inset);
     attachable(anchor,spin, two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
@@ -119,27 +139,29 @@
             [-excess, r+inset.y],
             for (i=[0:1:steps]) inset + polar_to_xy(r,90-i*step)
         ]
     ) reorient(anchor,spin, two_d=true, path=path, p=path);
 
 
 // Function&Module: mask2d_chamfer()
+// Synopsis: Produces a 2D chamfer mask shape.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As Module
 //   mask2d_chamfer(edge, [angle], [inset], [excess]) [ATTACHMENTS];
 //   mask2d_chamfer(y=, [angle=], [inset=], [excess=]) [ATTACHMENTS];
 //   mask2d_chamfer(x=, [angle=], [inset=], [excess=]) [ATTACHMENTS];
 // Usage: As Function
 //   path = mask2d_chamfer(edge, [angle], [inset], [excess]);
 //   path = mask2d_chamfer(y=, [angle=], [inset=], [excess=]);
 //   path = mask2d_chamfer(x=, [angle=], [inset=], [excess=]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D chamfer mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior chamfer between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 //   The edge parameter specifies the length of the chamfer's slanted edge.  Alternatively you can give x or y to
 //   specify the width or height.  Only one of x, y, or width is permitted.  
 // Arguments:
 //   edge = The length of the edge of the chamfer.
 //   angle = The angle of the chamfer edge, away from vertical.  Default: 45.
 //   inset = Optional amount to inset code from corner.  Default: 0
@@ -154,18 +176,26 @@
 // Example(2D): 2D Chamfer Mask by Width.
 //   mask2d_chamfer(x=10, angle=30);
 // Example(2D): 2D Chamfer Mask by Height.
 //   mask2d_chamfer(y=10, angle=30);
 // Example(2D): 2D Inset Chamfer Mask
 //   mask2d_chamfer(x=10, inset=2);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_chamfer(x=10, inset=2);
+// Example: Making an interior chamfer
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_chamfer(edge=10);
 module mask2d_chamfer(edge, angle=45, inset=0, excess=0.01, x, y, anchor=CENTER,spin=0) {
     path = mask2d_chamfer(x=x, y=y, edge=edge, angle=angle, excess=excess, inset=inset);
     attachable(anchor,spin, two_d=true, path=path, extent=true) {
         polygon(path);
         children();
     }
 }
@@ -188,39 +218,49 @@
             [inset.x, y+inset.y],
             [x+inset.x, inset.y]
         ]
     ) reorient(anchor,spin, two_d=true, path=path, extent=true, p=path);
 
 
 // Function&Module: mask2d_rabbet()
+// Synopsis: Creates a rabbet mask shape.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As Module
 //   mask2d_rabbet(size, [excess]) [ATTACHMENTS];
 // Usage: As Function
 //   path = mask2d_rabbet(size, [excess]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D rabbet mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior shelf decoration between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 // Arguments:
 //   size = The size of the rabbet, either as a scalar or an [X,Y] list.
 //   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 // Example(2D): 2D Rabbet Mask
 //   mask2d_rabbet(size=10);
 // Example(2D): 2D Asymmetrical Rabbet Mask
 //   mask2d_rabbet(size=[5,10]);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_rabbet(size=10);
+// Example: Making an interior shelf
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_rabbet(size=[5,10]);
 module mask2d_rabbet(size, excess=0.01, anchor=CENTER,spin=0) {
     path = mask2d_rabbet(size=size, excess=excess);
     attachable(anchor,spin, two_d=true, path=path, extent=false) {
         polygon(path);
         children();
     }
 }
@@ -236,25 +276,27 @@
             [-excess, size.y],
             size
         ]
     ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path);
 
 
 // Function&Module: mask2d_dovetail()
+// Synopsis: Creates a 2D dovetail mask shape.
+// Topics: Masks (2D), Shapes (2D), Paths (2D), Path Generators, Attachable 
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As Module
 //   mask2d_dovetail(edge, [angle], [inset], [shelf], [excess], ...) [ATTACHMENTS];
 //   mask2d_dovetail(x=, [angle=], [inset=], [shelf=], [excess=], ...) [ATTACHMENTS];
 //   mask2d_dovetail(y=, [angle=], [inset=], [shelf=], [excess=], ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = mask2d_dovetail(edge, [angle], [inset], [shelf], [excess]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D dovetail mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior dovetail between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 // Arguments:
 //   edge = The length of the edge of the dovetail.
 //   angle = The angle of the chamfer edge, away from vertical.  Default: 30.
 //   inset = Optional amount to inset code from corner.  Default: 0
 //   shelf = The extra height to add to the inside corner of the dovetail.  Default: 0
 //   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01
@@ -268,18 +310,26 @@
 // Example(2D): 2D Dovetail Mask by Width.
 //   mask2d_dovetail(x=10, angle=30);
 // Example(2D): 2D Dovetail Mask by Height.
 //   mask2d_dovetail(y=10, angle=30);
 // Example(2D): 2D Inset Dovetail Mask
 //   mask2d_dovetail(x=10, inset=2);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile([TOP,"Z"],except=[BACK,TOP+LEFT])
 //           mask2d_dovetail(x=10, inset=2);
+// Example: Making an interior dovetail
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_dovetail(x=10);
 module mask2d_dovetail(edge, angle=30, inset=0, shelf=0, excess=0.01, x, y, anchor=CENTER, spin=0) {
     path = mask2d_dovetail(x=x, y=y, edge=edge, angle=angle, inset=inset, shelf=shelf, excess=excess);
     attachable(anchor,spin, two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
@@ -304,23 +354,25 @@
             inset+[x,y],
             inset
         ]
     ) reorient(anchor,spin, two_d=true, path=path, p=path);
 
 
 // Function&Module: mask2d_teardrop()
+// Synopsis: Creates a 2D teardrop mask shape with a controllable maximum angle from vertical.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D), FDM Optimized
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As Module
 //   mask2d_teardrop(r|d=, [angle], [excess]) [ATTACHMENTS];
 // Usage: As Function
 //   path = mask2d_teardrop(r|d=, [angle], [excess]);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 // Description:
 //   Creates a 2D teardrop mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior teardrop fillet between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 //   This is particularly useful to make partially rounded bottoms, that don't need support to print.
 // Arguments:
 //   r = Radius of the rounding.
 //   angle = The maximum angle from vertical.
 //   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01
 //   ---
@@ -328,18 +380,26 @@
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 // Example(2D): 2D Teardrop Mask
 //   mask2d_teardrop(r=10);
 // Example(2D): Using a Custom Angle
 //   mask2d_teardrop(r=10,angle=30);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile(BOT)
 //           mask2d_teardrop(r=10, angle=40);
+// Example: Making an interior teardrop fillet
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_teardrop(r=10);
 function mask2d_teardrop(r, angle=45, excess=0.01, d, anchor=CENTER, spin=0) =  
     assert(is_finite(angle))
     assert(angle>0 && angle<90)
     assert(is_finite(excess))
     let(
         r = get_radius(r=r, d=d, dflt=1),
         n = ceil(segs(r) * angle/360),
@@ -358,24 +418,26 @@
     attachable(anchor,spin, two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
 
 // Function&Module: mask2d_ogee()
+// Synopsis: Creates a 2D ogee mask shape.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
+// See Also: corner_profile(), edge_profile(), face_profile()
 // Usage: As Module
 //   mask2d_ogee(pattern, [excess], ...) [ATTAHCMENTS];
 // Usage: As Function
 //   path = mask2d_ogee(pattern, [excess], ...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)
-// See Also: corner_profile(), edge_profile(), face_profile()
 //
 // Description:
 //   Creates a 2D Ogee mask shape that is useful for extruding into a 3D mask for a 90° edge.
-//   This 2D mask is designed to be `difference()`d  away from the edge of a shape that is in the first (X+Y+) quadrant.
+//   Conversely, you can use that same extruded shape to make an interior ogee decoration between two walls at a 90º angle.
+//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.
 //   Since there are a number of shapes that fall under the name ogee, the shape of this mask is given as a pattern.
 //   Patterns are given as TYPE, VALUE pairs.  ie: `["fillet",10, "xstep",2, "step",[5,5], ...]`.  See Patterns below.
 //   If called as a function, this just returns a 2D path of the outline of the mask shape.
 //   .
 //   ### Patterns
 //   .
 //   Type     | Argument  | Description
@@ -396,22 +458,34 @@
 // Example(2D): 2D Ogee Mask
 //   mask2d_ogee([
 //       "xstep",1,  "ystep",1,  // Starting shoulder.
 //       "fillet",5, "round",5,  // S-curve.
 //       "ystep",1,  "xstep",1   // Ending shoulder.
 //   ]);
 // Example: Masking by Edge Attachment
-//   diff("mask")
+//   diff()
 //   cube([50,60,70],center=true)
 //       edge_profile(TOP)
 //           mask2d_ogee([
 //               "xstep",1,  "ystep",1,  // Starting shoulder.
 //               "fillet",5, "round",5,  // S-curve.
 //               "ystep",1,  "xstep",1   // Ending shoulder.
 //           ]);
+// Example: Making an interior ogee
+//   %render() difference() {
+//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
+//       cube(310, anchor=BOT+LEFT);
+//   }
+//   xrot(90)
+//       linear_extrude(height=30, center=true)
+//           mask2d_ogee([
+//               "xstep", 1, "round",5,
+//               "ystep",1, "fillet",5,
+//               "xstep", 1, "ystep", 1,
+//           ]);
 module mask2d_ogee(pattern, excess=0.01, anchor=CENTER,spin=0) {
     path = mask2d_ogee(pattern, excess=excess);
     attachable(anchor,spin, two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
@@ -481,7 +555,8 @@
                 ]
         ],
         path2 = deduplicate(path)
     ) reorient(anchor,spin, two_d=true, path=path2, p=path2);
 
 
 
+// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/masks3d.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/masks3d.scad`

 * *Files 10% similar despite different names*

```diff
@@ -10,55 +10,62 @@
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Chamfer Masks
 
 
 // Module: chamfer_edge_mask()
+// Synopsis: Creates a shape to chamfer a 90° edge.
+// Topics: Masking, Chamfers, Shapes (3D)
+// See Also: chamfer_corner_mask()
 // Usage:
-//   chamfer_edge_mask(l, chamfer, [excess]) [ATTACHMENTS];
+//   chamfer_edge_mask(l|h=|length=|height=, chamfer, [excess]) [ATTACHMENTS];
 // Description:
-//   Creates a shape that can be used to chamfer a 90 degree edge.
+//   Creates a shape that can be used to chamfer a 90° edge.
 //   Difference it from the object to be chamfered.  The center of
 //   the mask object should align exactly with the edge to be chamfered.
 // Arguments:
-//   l = Length of mask.
+//   l/h/length/height = Length of mask.
 //   chamfer = Size of chamfer.
 //   excess = The extra amount to add to the length of the mask so that it differences away from other shapes cleanly.  Default: `0.1`
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   chamfer_edge_mask(l=50, chamfer=10);
 // Example:
 //   difference() {
 //       cube(50, anchor=BOTTOM+FRONT);
 //       #chamfer_edge_mask(l=50, chamfer=10, orient=RIGHT);
 //   }
 // Example: Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cube(50, center=true) {
 //       edge_mask(TOP+RIGHT)
 //           #chamfer_edge_mask(l=50, chamfer=10);
 //   }
-function chamfer_edge_mask(l=1, chamfer=1, excess=0.1, anchor=CENTER, spin=0, orient=UP) = no_function("chamfer_edge_mask");
-module chamfer_edge_mask(l=1, chamfer=1, excess=0.1, anchor=CENTER, spin=0, orient=UP) {
+function chamfer_edge_mask(l, chamfer=1, excess=0.1, h, length, height, anchor=CENTER, spin=0, orient=UP) = no_function("chamfer_edge_mask");
+module chamfer_edge_mask(l, chamfer=1, excess=0.1, h, length, height, anchor=CENTER, spin=0, orient=UP) {
+    l = one_defined([l, h, height, length], "l,h,height,length");
     attachable(anchor,spin,orient, size=[chamfer*2, chamfer*2, l]) {
         cylinder(r=chamfer, h=l+excess, center=true, $fn=4);
         children();
     }
 }
 
 
 // Module: chamfer_corner_mask()
+// Synopsis: Creates a shape to chamfer a 90° corner.
+// Topics: Masking, Chamfers, Shapes (3D)
+// See Also: chamfer_edge_mask()
 // Usage:
 //   chamfer_corner_mask(chamfer) [ATTACHMENTS];
 // Description:
-//   Creates a shape that can be used to chamfer a 90 degree corner.
+//   Creates a shape that can be used to chamfer a 90° corner.
 //   Difference it from the object to be chamfered.  The center of
 //   the mask object should align exactly with the corner to be chamfered.
 // Arguments:
 //   chamfer = Size of chamfer.
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
@@ -67,85 +74,105 @@
 //   chamfer_corner_mask(chamfer=10);
 // Example:
 //   difference() {
 //       cuboid(50, chamfer=10, trimcorners=false);
 //       move(25*[1,-1,1]) #chamfer_corner_mask(chamfer=10);
 //   }
 // Example: Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cuboid(100, chamfer=20, trimcorners=false) {
 //       corner_mask(TOP+FWD+RIGHT)
 //           chamfer_corner_mask(chamfer=20);
 //   }
 // Example: Anchors
 //   chamfer_corner_mask(chamfer=20)
 //       show_anchors();
 function chamfer_corner_mask(chamfer=1, anchor=CENTER, spin=0, orient=UP) = no_function("chamfer_corner_mask");
 module chamfer_corner_mask(chamfer=1, anchor=CENTER, spin=0, orient=UP) {
     octahedron(chamfer*4, anchor=anchor, spin=spin, orient=orient) children();
 }
 
 
 // Module: chamfer_cylinder_mask()
+// Synopsis: Creates a shape to chamfer the end of a cylinder.
+// Topics: Masking, Chamfers, Cylinders
 // Usage:
 //   chamfer_cylinder_mask(r|d=, chamfer, [ang], [from_end]) [ATTACHMENTS];
 // Description:
 //   Create a mask that can be used to bevel/chamfer the end of a cylindrical region.
 //   Difference it from the end of the region to be chamfered.  The center of the mask
 //   object should align exactly with the center of the end of the cylindrical region
 //   to be chamfered.
 // Arguments:
 //   r = Radius of cylinder to chamfer.
 //   chamfer = Size of the edge chamfered, inset from edge.
 //   ---
 //   d = Diameter of cylinder to chamfer. Use instead of r.
-//   ang = Angle of chamfer in degrees from vertical.  (Default: 45)
+//   ang = Angle of chamfer in degrees from the horizontal.  (Default: 45)
 //   from_end = If true, chamfer size is measured from end of cylinder.  If false, chamfer is measured outset from the radius of the cylinder.  (Default: false)
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   difference() {
 //       cylinder(r=50, h=100, center=true);
 //       up(50) #chamfer_cylinder_mask(r=50, chamfer=10);
 //   }
 // Example:
 //   difference() {
 //       cylinder(r=50, h=100, center=true);
 //       up(50) chamfer_cylinder_mask(r=50, chamfer=10);
 //   }
+// Example: Changing the chamfer angle
+//   difference() {
+//       cylinder(r=50, h=100, center=true);
+//       up(50) #chamfer_cylinder_mask(r=50, chamfer=10, ang=70);
+//   }
+// Example:
+//   difference() {
+//       cylinder(r=50, h=100, center=true);
+//       up(50) chamfer_cylinder_mask(r=50, chamfer=10, ang=70);
+//   }
 // Example: Masking by Attachment
+//   diff()
+//   cyl(d=100,h=40)
+//      attach([TOP,BOT])
+//         tag("remove")chamfer_cylinder_mask(d=100, chamfer=10);
 function chamfer_cylinder_mask(r, chamfer, d, ang=45, from_end=false, anchor=CENTER, spin=0, orient=UP) = no_function("chamfer_cylinder_mask");
 module chamfer_cylinder_mask(r, chamfer, d, ang=45, from_end=false, anchor=CENTER, spin=0, orient=UP)
 {
     r = get_radius(r=r, d=d, dflt=1);
-    ch = from_end? chamfer : opp_ang_to_adj(chamfer,ang);
+    dummy = assert(all_nonnegative([chamfer]), "Chamfer must be a nonnegative number");
+    ch = from_end? chamfer : opp_ang_to_adj(chamfer,90-ang);
     attachable(anchor,spin,orient, r=r, l=ch*2) {
         difference() {
             cyl(r=r+chamfer, l=ch*2, anchor=CENTER);
             cyl(r=r, l=ch*3, chamfer=chamfer, chamfang=ang, from_end=from_end, anchor=TOP);
         }
         children();
     }
 }
 
 
 
 // Section: Rounding Masks
 
 // Module: rounding_edge_mask()
+// Synopsis: Creates a shape to round a 90° edge.
+// Topics: Masks, Rounding, Shapes (3D)
+// See Also: rounding_angled_edge_mask(), rounding_corner_mask(), rounding_angled_corner_mask() 
 // Usage:
-//   rounding_edge_mask(l|h, r|d, [excess=]) [ATTACHMENTS];
-//   rounding_edge_mask(l|h, r1=|d1=, r2=|d2=, [excess=]) [ATTACHMENTS];
+//   rounding_edge_mask(l|h=|length=|height=, r|d=, [excess=]) [ATTACHMENTS];
+//   rounding_edge_mask(l|h=|length=|height=, r1=|d1=, r2=|d2=, [excess=]) [ATTACHMENTS];
 // Description:
-//   Creates a shape that can be used to round a vertical 90 degree edge.
+//   Creates a shape that can be used to round a vertical 90° edge.
 //   Difference it from the object to be rounded.  The center of the mask
 //   object should align exactly with the edge to be rounded.
 // Arguments:
-//   l/h = Length of mask.
+//   l/h/length/height = Length of mask.
 //   r = Radius of the rounding.
 //   ---
 //   r1 = Bottom radius of rounding.
 //   r2 = Top radius of rounding.
 //   d = Diameter of the rounding.
 //   d1 = Bottom diameter of rounding.
 //   d2 = Top diameter of rounding.
@@ -162,30 +189,30 @@
 //   }
 // Example: Varying Rounding Radius
 //   difference() {
 //       cube(size=50, center=false);
 //       #rounding_edge_mask(l=50, r1=25, r2=10, orient=UP, anchor=BOTTOM);
 //   }
 // Example: Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cube(100, center=true)
 //       edge_mask(FRONT+RIGHT)
 //           #rounding_edge_mask(l=$parent_size.z+0.01, r=25);
 // Example: Multiple Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cube([80,90,100], center=true) {
 //       let(p = $parent_size*1.01) {
 //           edge_mask(TOP)
 //               rounding_edge_mask(l=p.z, r=25);
 //       }
 //   }
-function rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h=undef) = no_function("rounding_edge_mask");
-module rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h=undef)
+function rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h,height,length) = no_function("rounding_edge_mask");
+module rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h,height,length)
 {
-    l = first_defined([l, h, 1]);
+    l = one_defined([l, h, height, length], "l,h,height,length");
     r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);
     r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);
     sides = quantup(segs(max(r1,r2)),4);
     attachable(anchor,spin,orient, size=[2*r1,2*r1,l], size2=[2*r2,2*r2]) {
         if (r1<r2) {
             zflip() {
                 linear_extrude(height=l, convexity=4, center=true, scale=r1/r2) {
@@ -205,18 +232,21 @@
         }
         children();
     }
 }
 
 
 // Module: rounding_corner_mask()
+// Synopsis: Creates a shape to round 90° corners.
+// Topics: Masking, Rounding, Shapes (3D)
+// See Also: rounding_angled_corner_mask(), rounding_edge_mask(), rounding_angled_edge_mask()
 // Usage:
 //   rounding_corner_mask(r|d, [excess=], [style=]) [ATTACHMENTS];
 // Description:
-//   Creates a shape that you can use to round 90 degree corners.
+//   Creates a shape that you can use to round 90° corners.
 //   Difference it from the object to be rounded.  The center of the mask
 //   object should align exactly with the corner to be rounded.
 // Arguments:
 //   r = Radius of corner rounding.
 //   ---
 //   d = Diameter of corner rounding.
 //   excess = Extra size for the mask.  Defaults: 0.1
@@ -233,45 +263,48 @@
 //           #rounding_corner_mask(r=20, spin=90, orient=DOWN);
 //       translate([25, -30, 35])
 //           #rounding_corner_mask(r=20, orient=DOWN);
 //       translate([25, -30, -35])
 //           #rounding_corner_mask(r=20, spin=90);
 //   }
 // Example: Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cube(size=[50, 60, 70]) {
 //       corner_mask(TOP)
 //           #rounding_corner_mask(r=20);
 //   }
 function rounding_corner_mask(r, d, style="octa", excess=0.1, anchor=CENTER, spin=0, orient=UP) = no_function("rounding_corner_mask");
 module rounding_corner_mask(r, d, style="octa", excess=0.1, anchor=CENTER, spin=0, orient=UP)
 {
     r = get_radius(r=r, d=d, dflt=1);
     attachable(anchor,spin,orient, size=[2,2,2]*r) {
         difference() {
             translate(-excess*[1,1,1])
                 cube(size=r+excess, center=false);
             translate([r,r,r])
-                sphere(r=r, style=style);
+                spheroid(r=r, style=style);
         }
         children();
     }
 }
 
 
 // Module: rounding_angled_edge_mask()
+// Synopsis: Creates a shape to round edges of any angle.
+// Topics: Masks, Rounding
+// See Also: rounding_angled_corner_mask(), rounding_edge_mask(), rounding_corner_mask()
 // Usage:
-//   rounding_angled_edge_mask(h, r|d=, [ang=]) [ATTACHMENTS];
-//   rounding_angled_edge_mask(h, r1=|d1=, r2=|d2=, [ang=]) [ATTACHMENTS];
+//   rounding_angled_edge_mask(h|l=|length=|height=, r|d=, [ang=]) [ATTACHMENTS];
+//   rounding_angled_edge_mask(h|l=|length=|height=, r1=|d1=, r2=|d2=, [ang=]) [ATTACHMENTS];
 // Description:
 //   Creates a vertical mask that can be used to round the edge where two face meet, at any arbitrary
 //   angle.  Difference it from the object to be rounded.  The center of the mask should align exactly
 //   with the edge to be rounded.
 // Arguments:
-//   h = Height of vertical mask.
+//   h/l/height/length = Height of vertical mask.
 //   r = Radius of the rounding.
 //   ---
 //   r1 = Bottom radius of rounding.
 //   r2 = Top radius of rounding.
 //   d = Diameter of the rounding.
 //   d1 = Bottom diameter of rounding.
 //   d2 = Top diameter of rounding.
@@ -285,24 +318,24 @@
 //       #rounding_angled_edge_mask(h=51, r=20.0, ang=70, $fn=32);
 //   }
 // Example: Varying Rounding Radius
 //   difference() {
 //       pie_slice(ang=70, h=50, d=100, center=true);
 //       #rounding_angled_edge_mask(h=51, r1=10, r2=25, ang=70, $fn=32);
 //   }
-function rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP) = no_function("rounding_angled_edge_mask");
-module rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP)
+function rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP,l,height,length) = no_function("rounding_angled_edge_mask");
+module rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP,l,height,length)
 {
     function _mask_shape(r) = [
         for (i = [0:1:n]) let (a=90+ang+i*sweep/n) [r*cos(a)+x, r*sin(a)+r],
         for (i = [0:1:n]) let (a=90+i*sweep/n) [r*cos(a)+x, r*sin(a)-r],
         [min(-1, r*cos(270-ang)+x-1), r*sin(270-ang)-r],
         [min(-1, r*cos(90+ang)+x-1), r*sin(90+ang)+r],
     ];
-
+    h = one_defined([l, h, height, length], "l,h,height,length");
     sweep = 180-ang;
     r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);
     r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);
     n = ceil(segs(max(r1,r2))*sweep/360);
     x = sin(90-(ang/2))/sin(ang/2) * (r1<r2? r2 : r1);
     if(r1<r2) {
         attachable(anchor,spin,orient, size=[2*x*r1/r2,2*r1,h], size2=[2*x,2*r2]) {
@@ -321,14 +354,17 @@
             children();
         }
     }
 }
 
 
 // Module: rounding_angled_corner_mask()
+// Synopsis: Creates a shape to round the corner of an arbitrary angle.
+// Topics: Masks, Rounding, Shapes (3D)
+// See Also: rounding_angled_edge_mask(), rounding_corner_mask(), rounding_edge_mask()
 // Usage:
 //   rounding_angled_corner_mask(r|d=, [ang]) [ATTACHMENTS];
 // Description:
 //   Creates a shape that can be used to round the corner of an angle.
 //   Difference it from the object to be rounded.  The center of the mask
 //   object should align exactly with the point of the corner to be rounded.
 // Arguments:
@@ -369,68 +405,81 @@
         }
         children();
     }
 }
 
 
 // Module: rounding_cylinder_mask()
+// Synopsis: Creates a shape to round the end of a cylinder.
+// Topics: Masking, Rounding, Cylinders
+// See Also: rounding_hole_mask()
 // Usage:
 //   rounding_cylinder_mask(r|d=, rounding);
 // Description:
 //   Create a mask that can be used to round the end of a cylinder.
 //   Difference it from the cylinder to be rounded.  The center of the
 //   mask object should align exactly with the center of the end of the
 //   cylinder to be rounded.
 // Arguments:
 //   r = Radius of cylinder.
 //   rounding = Radius of the edge rounding.
 //   ---
 //   d = Diameter of cylinder.
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   difference() {
 //     cylinder(r=50, h=50, center=false);
 //     up(50) #rounding_cylinder_mask(r=50, rounding=10);
 //   }
 // Example:
 //   difference() {
 //     cylinder(r=50, h=50, center=false);
 //     up(50) rounding_cylinder_mask(r=50, rounding=10);
 //   }
 // Example: Masking by Attachment
-//   diff("mask")
+//   diff()
 //   cyl(h=30, d=30) {
 //       attach(TOP)
-//           #tag("mask")rounding_cylinder_mask(d=30, rounding=5);
+//         #tag("remove")
+//           rounding_cylinder_mask(d=30, rounding=5);
 //   }
-function rounding_cylinder_mask(r, rounding, d) = no_function("rounding_cylinder_mask");
-module rounding_cylinder_mask(r, rounding, d)
+function rounding_cylinder_mask(r, rounding, d, anchor, spin, orient) = no_function("rounding_cylinder_mask");
+module rounding_cylinder_mask(r, rounding, d, anchor=CENTER, spin=0, orient=UP)
 {
-    no_children($children);
     r = get_radius(r=r, d=d, dflt=1);
-    difference() {
-        cyl(r=r+rounding, l=rounding*2, anchor=CENTER);
-        cyl(r=r, l=rounding*3, rounding=rounding, anchor=TOP);
+    attachable(anchor,spin,orient, r=r+rounding, l=rounding*2) {
+        difference() {
+            cyl(r=r+rounding, l=rounding*2, anchor=CENTER);
+            cyl(r=r, l=rounding*3, rounding=rounding, anchor=TOP);
+        }
+        children();
     }
 }
 
 
 
 // Module: rounding_hole_mask()
+// Synopsis: Creates a shape to round the edge of a round hole.
+// Topics: Masking, Rounding
+// See Also: rounding_cylinder_mask()
 // Usage:
 //   rounding_hole_mask(r|d, rounding, [excess]) [ATTACHMENTS];
 // Description:
 //   Create a mask that can be used to round the edge of a circular hole.
 //   Difference it from the hole to be rounded.  The center of the
 //   mask object should align exactly with the center of the end of the
 //   hole to be rounded.
 // Arguments:
 //   r = Radius of hole.
-//   d = Diameter of hole to rounding.
 //   rounding = Radius of the rounding.
 //   excess = The extra thickness of the mask.  Default: `0.1`.
+//   ---
+//   d = Diameter of hole to rounding.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   rounding_hole_mask(r=40, rounding=20, $fa=2, $fs=2);
 // Example(Med):
 //   difference() {
@@ -459,80 +508,96 @@
     }
 }
 
 
 // Section: Teardrop Masking
 
 // Module: teardrop_edge_mask()
+// Synopsis: Creates a shape to round a 90° edge but limit the angle of overhang.
+// Topics: Masking, Rounding, Shapes (3D), FDM Optimized
+// See Also: teardrop_corner_mask()
 // Usage:
-//   teardrop_edge_mask(r|d=, [angle], [excess]);
+//   teardrop_edge_mask(l|h=|length=|height=, r|d=, [angle], [excess], [anchor], [spin], [orient]) [ATTACHMENTS];
 // Description:
-//   Makes an apropriate 3D corner rounding mask that keeps within `angle` degrees of vertical.
+//   Makes an apropriate 3D edge rounding mask that keeps within `angle` degrees of vertical.
 // Arguments:
+//   l/h/length/height = length of mask
 //   r = Radius of the mask rounding.
-//   d = Diameter of the mask rounding.
 //   angle = Maximum angle from vertical. Default: 45
 //   excess = Excess mask size.  Default: 0.1
+//   ---
+//   d = Diameter of the mask rounding.
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example(VPD=50,VPR=[55,0,120]):
 //   teardrop_edge_mask(l=20, r=10, angle=40);
 // Example(VPD=300,VPR=[75,0,25]):
-//   diff("mask")
+//   diff()
 //   cuboid([50,60,70],rounding=10,edges="Z",anchor=CENTER) {
 //       edge_mask(BOT)
 //           teardrop_edge_mask(l=max($parent_size)+1, r=10, angle=40);
 //       corner_mask(BOT)
 //           teardrop_corner_mask(r=10, angle=40);
 //   }
-function teardrop_edge_mask(l, r, angle, excess=0.1, d) = no_function("teardrop_edge_mask");
-module teardrop_edge_mask(l, r, angle, excess=0.1, d)
+function teardrop_edge_mask(l, r, angle=45, excess=0.1, d, anchor, spin, orient,h,height,length) = no_function("teardrop_edge_mask");
+module teardrop_edge_mask(l, r, angle=45, excess=0.1, d, anchor=CTR, spin=0, orient=UP,h,height,length)
 {
-    no_children($children);
-    assert(is_num(l));
-    assert(is_num(angle));
-    assert(is_num(excess));
-    assert(angle>0 && angle<90);
+    l = one_defined([l, h, height, length], "l,h,height,length");
+    check = 
+      assert(is_num(l) && l>0, "Length of mask must be positive")
+      assert(is_num(angle) && angle>0 && angle<90, "Angle must be a number between 0 and 90")
+      assert(is_num(excess));
     r = get_radius(r=r, d=d, dflt=1);
-    difference() {
-        translate(-[1,1,0]*excess) cube([r+excess,r+excess,l], anchor=FWD+LEFT);
-        translate([r,r,0]) teardrop(r=r, l=l+1, cap_h=r, ang=angle, orient=FWD);
-    }
+    path = mask2d_teardrop(r=r, angle=angle, excess=excess);
+    linear_sweep(path, height=l, center=true, atype="bbox", anchor=anchor, spin=spin, orient=orient) children();
 }
 
 
 // Module: teardrop_corner_mask()
+// Synopsis: Creates a shape to round a 90° corner but limit the angle of overhang.
+// Topics: Masking, Rounding, Shapes (3D), FDM Optimized
+// See Also: teardrop_edge_mask()
 // Usage:
-//   teardrop_corner_mask(r|d=, [angle], [excess]);
+//   teardrop_corner_mask(r|d=, [angle], [excess], [anchor], [spin], [orient]) [ATTACHMENTS];
 // Description:
 //   Makes an apropriate 3D corner rounding mask that keeps within `angle` degrees of vertical.
 // Arguments:
 //   r = Radius of the mask rounding.
 //   angle = Maximum angle from vertical. Default: 45
 //   excess = Excess mask size.  Default: 0.1
 //   ---
 //   d = Diameter of the mask rounding.
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   teardrop_corner_mask(r=20, angle=40);
 // Example:
-//   diff("mask")
+//   diff()
 //   cuboid([50,60,70],rounding=10,edges="Z",anchor=CENTER) {
 //       edge_profile(BOT)
 //           mask2d_teardrop(r=10, angle=40);
 //       corner_mask(BOT)
 //           teardrop_corner_mask(r=10, angle=40);
 //   }
-function teardrop_corner_mask(r, angle, excess=0.1, d) = no_function("teardrop_corner_mask");
-module teardrop_corner_mask(r, angle, excess=0.1, d)
+function teardrop_corner_mask(r, angle=45, excess=0.1, d, anchor, spin, orient) = no_function("teardrop_corner_mask");
+module teardrop_corner_mask(r, angle=45, excess=0.1, d, anchor=CTR, spin=0, orient=UP)
 {  
-    no_children($children);
     assert(is_num(angle));
     assert(is_num(excess));
     assert(angle>0 && angle<90);
     r = get_radius(r=r, d=d, dflt=1);
-    difference() {
-        translate(-[1,1,1]*excess) cube(r+excess, center=false);
-        translate([1,1,1]*r) onion(r=r, ang=angle, orient=DOWN);
+    size = (r+excess) * [1,1,1];
+    midpt = (r-excess)/2 * [1,1,1];
+    attachable(anchor,spin,orient, size=size, offset=midpt) {
+        difference() {
+            translate(-[1,1,1]*excess) cube(r+excess, center=false);
+            translate([1,1,1]*r) onion(r=r, ang=angle, orient=DOWN);
+        }
+        children();
     }
 }
 
 
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/math.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/math.scad`

 * *Files 1% similar despite different names*

```diff
@@ -97,15 +97,15 @@
 // Function: lerpn()
 // Usage:
 //   x = lerpn(a, b, n);
 //   x = lerpn(a, b, n, [endpoint]);
 // Description:
 //   Returns exactly `n` values, linearly interpolated between `a` and `b`.
 //   If `endpoint` is true, then the last value will exactly equal `b`.
-//   If `endpoint` is false, then the last value will about `a+(b-a)*(1-1/n)`.
+//   If `endpoint` is false, then the last value will be `a+(b-a)*(1-1/n)`.
 // Arguments:
 //   a = First value or vector.
 //   b = Second value or vector.
 //   n = The number of values to return.
 //   endpoint = If true, the last value will be exactly `b`.  If false, the last value will be one step less.
 // Example:
 //   l = lerpn(-4,4,9);        // Returns: [-4,-3,-2,-1,0,1,2,3,4]
@@ -335,16 +335,16 @@
 // Usage:
 //   num = quant(x, y);
 // Description:
 //   Quantize a value `x` to an integer multiple of `y`, rounding to the nearest multiple.
 //   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item
 //   in that list will be recursively quantized.
 // Arguments:
-//   x = The value to quantize.
-//   y = The non-zero integer quantum of the quantization.
+//   x = The value or list to quantize.
+//   y = Positive quantum to quantize to
 // Example:
 //   a = quant(12,4);    // Returns: 12
 //   b = quant(13,4);    // Returns: 12
 //   c = quant(13.1,4);  // Returns: 12
 //   d = quant(14,4);    // Returns: 16
 //   e = quant(14.1,4);  // Returns: 16
 //   f = quant(15,4);    // Returns: 16
@@ -357,31 +357,32 @@
 //   m = quant(12,3);    // Returns: 12
 //   n = quant(11,2.5);  // Returns: 10
 //   o = quant(12,2.5);  // Returns: 12.5
 //   p = quant([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,12,12,16,16,16,16]
 //   q = quant([9,10,10.4,10.5,11,12],3);      // Returns: [9,9,9,12,12,12]
 //   r = quant([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,9,9],[12,12,12]]
 function quant(x,y) =
-    assert( is_finite(y) && y>0, "The quantum `y` must be a non zero integer.")
-    is_list(x)
-    ?   [for (v=x) quant(v,y)]
-    :   assert( is_finite(x), "The input to quantize is not a number nor a list of numbers.")
-        floor(x/y+0.5)*y;
+    assert( is_finite(y) && y>0, "The quantum `y` must be a positive value.")
+    is_num(x) ? round(x/y)*y 
+              : _roundall(x/y)*y;
+
+function _roundall(data) =
+    [for(x=data) is_list(x) ? _roundall(x) : round(x)];
 
 
 // Function: quantdn()
 // Usage:
 //   num = quantdn(x, y);
 // Description:
 //   Quantize a value `x` to an integer multiple of `y`, rounding down to the previous multiple.
 //   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item in that
 //   list will be recursively quantized down.
 // Arguments:
-//   x = The value to quantize.
-//   y = The non-zero integer quantum of the quantization.
+//   x = The value or list to quantize.
+//   y = Postive quantum to quantize to. 
 // Example:
 //   a = quantdn(12,4);    // Returns: 12
 //   b = quantdn(13,4);    // Returns: 12
 //   c = quantdn(13.1,4);  // Returns: 12
 //   d = quantdn(14,4);    // Returns: 12
 //   e = quantdn(14.1,4);  // Returns: 12
 //   f = quantdn(15,4);    // Returns: 12
@@ -394,31 +395,32 @@
 //   m = quantdn(12,3);    // Returns: 12
 //   n = quantdn(11,2.5);  // Returns: 10
 //   o = quantdn(12,2.5);  // Returns: 10
 //   p = quantdn([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,12,12,12,12,12,16]
 //   q = quantdn([9,10,10.4,10.5,11,12],3);      // Returns: [9,9,9,9,9,12]
 //   r = quantdn([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,9,9],[9,9,12]]
 function quantdn(x,y) =
-    assert( is_finite(y) && y>0, "The quantum `y` must be a non zero integer.")
-    is_list(x)
-    ?   [for (v=x) quantdn(v,y)]
-    :   assert( is_finite(x), "The input to quantize must be a number or a list of numbers.")
-        floor(x/y)*y;
+    assert( is_finite(y) && y>0, "The quantum `y` must be a positive value.")
+    is_num(x) ? floor(x/y)*y 
+              : _floorall(x/y)*y;
+
+function _floorall(data) =
+    [for(x=data) is_list(x) ? _floorall(x) : floor(x)];
 
 
 // Function: quantup()
 // Usage:
 //   num = quantup(x, y);
 // Description:
 //   Quantize a value `x` to an integer multiple of `y`, rounding up to the next multiple.
 //   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item in
 //   that list will be recursively quantized up.
 // Arguments:
-//   x = The value to quantize.
-//   y = The non-zero integer quantum of the quantization.
+//   x = The value or list to quantize.
+//   y = Positive quantum to quantize to.
 // Example:
 //   a = quantup(12,4);    // Returns: 12
 //   b = quantup(13,4);    // Returns: 16
 //   c = quantup(13.1,4);  // Returns: 16
 //   d = quantup(14,4);    // Returns: 16
 //   e = quantup(14.1,4);  // Returns: 16
 //   f = quantup(15,4);    // Returns: 16
@@ -431,19 +433,20 @@
 //   m = quantup(12,3);    // Returns: 12
 //   n = quantdn(11,2.5);  // Returns: 12.5
 //   o = quantdn(12,2.5);  // Returns: 12.5
 //   p = quantup([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,16,16,16,16,16,16]
 //   q = quantup([9,10,10.4,10.5,11,12],3);      // Returns: [9,12,12,12,12,12]
 //   r = quantup([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,12,12],[12,12,12]]
 function quantup(x,y) =
-    assert( is_finite(y) && y>0, "The quantum `y` must be a non zero integer.")
-    is_list(x)
-    ?   [for (v=x) quantup(v,y)]
-    :   assert( is_finite(x), "The input to quantize must be a number or a list of numbers.")
-        ceil(x/y)*y;
+    assert( is_finite(y) && y>0, "The quantum `y` must be a positive value.")
+    is_num(x) ? ceil(x/y)*y 
+              : _ceilall(x/y)*y;
+
+function _ceilall(data) =
+    [for(x=data) is_list(x) ? _ceilall(x) : ceil(x)];
 
 
 // Section: Constraints and Modulos
 
 // Function: constrain()
 // Usage:
 //   val = constrain(v, minval, maxval);
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/metric_screws.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/metric_screws.scad`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/modular_hose.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/modular_hose.scad`

 * *Files 2% similar despite different names*

```diff
@@ -114,15 +114,19 @@
                   ],
                   state=[9.90237,0])
         ];
 
 
 _hose_waist = [1.7698, 1.8251, 3.95998];
 
+
 // Module: modular_hose()
+// Synopsis: Creates modular hose parts.
+// Topics: Modular Hose, Parts
+// See Also: modular_hose_radius(), tube()
 // Usage:
 //    modular_hose(size, type, [clearance], [waist_len], [anchor], [spin], [orient]) [ATTACHMENTS];
 // Description:
 //    Construct moduler hose segments or modular hose ends for connection to standard
 //    modular hose systems.  The 1/4", 1/2" and 3/4" sizes are supported and you can
 //    produce just one end to make a mount or end attachment to a modular hose,
 //    or you can make modular hose segments.  To make assembly possible with printed
@@ -139,15 +143,15 @@
 //    clearance = clearance to make assembly possible.  Either a scalar to apply the same to both ends or a vector [small,large] to apply different clearances to the two ends.  Default: 0
 //    waist_len = size of central "waist" of the part.  Default: standard length.
 // Example:
 //    modular_hose(1/4,"segment");
 //    right(25)modular_hose(1/2,"segment");
 //    right(60)modular_hose(3/4,"segment");
 // Example: A mount point for modular hose
-//    cylinder(l=10, r=20)
+//    cylinder(h=10, r=20)
 //       attach(TOP) modular_hose(1/2, "ball", waist_len=15);
 // Example: Mounting plate for something at the end of the hose
 //    cuboid([50,50,5])
 //       attach(TOP) modular_hose(3/4, "socket", waist_len=0);
 function modular_hose(size, type, clearance=0, waist_len, anchor=BOTTOM, spin=0,orient=UP) = no_function("modular_hose");
 module modular_hose(size, type, clearance=0, waist_len, anchor=BOTTOM, spin=0,orient=UP)
 {
@@ -159,15 +163,15 @@
   bbound = pointlist_bounds(_big_end[ind]);
   smallend =
     assert(is_vector(clearance,2), "Clearance must be a scalar or length 2 vector")
     move([-clearance[0],-sbound[0].y],p=_small_end[ind]);
   bigend = move([clearance[1], -bbound[0].y], p=_big_end[ind]);
 
   midlength = first_defined([waist_len, _hose_waist[ind]]);
-  assert(midlength>=0,"midlength must be nonnegative");
+  dummy = assert(midlength>=0,"midlength must be nonnegative");
 
   goodtypes = ["small","big","segment","socket","ball"];
   shape =
     assert(in_list(type,goodtypes), str("type must be one of ",goodtypes))
     type=="segment"? concat(back(midlength,p=smallend),yflip(p=bigend))
   : type=="small" || type=="ball" ?
           concat(back(midlength,p=smallend),
@@ -182,14 +186,17 @@
       polygon(fwd(center.y,p=shape));
     children();
   }  
 }
 
 
 // Function: modular_hose_radius()
+// Synopsis: Returns the waist radius of the given modular hose size.
+// Topics: Modular Hose, Parts
+// See Also: modular_hose(), tube()
 // Usage:
 //   r = modular_hose_radius(size, [outer]);
 // Description:
 //   Returns the inner (or outer) diameter of the waist section
 //   of the modular hose to enable hollowing out connecting channels.
 //   Note: diameter is accurate to about 1e-4.  
 // Arguments:
@@ -215,8 +222,10 @@
   assert(ind!=[], "Must specify size as 1/4, 1/2 or 3/4")
   let(
      b = select(_big_end[ind], [0,-1]),
      s = select(_small_end[ind], [0,-1])
   )
   outer ? b[1][0] : b[0][0];
 
+
+
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/mutators.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/mutators.scad`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,17 @@
 //////////////////////////////////////////////////////////////////////
 
 //////////////////////////////////////////////////////////////////////
 // Section: Bounding Box
 //////////////////////////////////////////////////////////////////////
 
 // Module: bounding_box()
+// Synopsis: Creates the smallest bounding box that contains all the children.
+// Topics: Mutators, Bounds, Bounding Boxes
+// See Also: pointlist_bounds()
 // Usage:
 //   bounding_box([excess],[planar]) CHILDREN;
 // Description:
 //   Returns the smallest axis-aligned square (or cube) shape that contains all the 2D (or 3D)
 //   children given.  The module children() must 3d when planar=false and
 //   2d when planar=true, or you will get a warning of mixing dimension
 //   or scaling by 0.
@@ -97,15 +100,17 @@
 
 //////////////////////////////////////////////////////////////////////
 // Section: Warp Mutators
 //////////////////////////////////////////////////////////////////////
 
 
 // Module: chain_hull()
-//
+// Synopsis: Performs the union of hull operations between consecutive pairs of children.
+// Topics: Mutators
+// See Also: hull()
 // Usage:
 //   chain_hull() CHILDREN;
 //
 // Description:
 //   Performs hull operations between consecutive pairs of children,
 //   then unions all of the hull results.  This can be a very slow
 //   operation, but it can provide results that are hard to get
@@ -145,14 +150,17 @@
             }
         }
     }
 }
 
 
 // Module: path_extrude2d()
+// Synopsis: Extrudes 2D children along a 2D path.
+// Topics: Mutators, Extrusion 
+// See Also: path_sweep(), path_extrude()
 // Usage:
 //   path_extrude2d(path, [caps=], [closed=], [s=], [convexity=]) 2D-CHILDREN;
 // Description:
 //   Extrudes 2D children along the given 2D path, with optional rounded endcaps.
 //   It works by constructing straight sections corresponding to each segment of the path and inserting rounded joints at each corner.
 //   If the children are symmetric across the Y axis line then you can set caps=true to produce rounded caps on the ends of the profile.
 //   If you set caps to true for asymmetric children then incorrect caps will be generated.
@@ -192,21 +200,22 @@
 //   $fn=16;
 //   spath = star(id=15,od=35,n=5);
 //   path_extrude2d(spath, caps=true, closed=false)
 //       move_copies([[-3.5,1.5],[0.0,3.0],[3.5,1.5]])
 //           circle(r=1.5);
 module path_extrude2d(path, caps=false, closed=false, s, convexity=10) {
     extra_ang = 0.1; // Extra angle for overlap of joints
-    assert(caps==false || closed==false, "Cannot have caps on a closed extrusion");
-    assert(is_path(path,2));
+    check =
+       assert(caps==false || closed==false, "Cannot have caps on a closed extrusion")
+       assert(is_path(path,2));
     path = deduplicate(path);
     s = s!=undef? s :
         let(b = pointlist_bounds(path))
         norm(b[1]-b[0]);
-    assert(is_finite(s));
+    check2 = assert(is_finite(s));
     L = len(path);
     for (i = [0:1:L-(closed?1:2)]) {
         seg = select(path, i, i+1);
         segv = seg[1] - seg[0];
         seglen = norm(segv);
         translate((seg[0]+seg[1])/2) {
             rot(from=BACK, to=segv) {
@@ -257,14 +266,17 @@
                 rotate_extrude(angle=180)
                     right_half(planar=true) children();
     }
 }
 
 
 // Module: cylindrical_extrude()
+// Synopsis: Extrudes 2D children outwards around a cylinder.
+// Topics: Mutators, Extrusion, Rotation
+// See Also: heightfield(), cylindrical_heightfield(), cyl()
 // Usage:
 //   cylindrical_extrude(ir|id=, or|od=, [size=], [convexity=], [spin=], [orient=]) 2D-CHILDREN;
 // Description:
 //   Extrudes its 2D children outwards, curved around a cylindrical shape.  Uses $fn/$fa/$fs to
 //   control the faceting of the extrusion.  
 // Arguments:
 //   ir = The inner radius to extrude from.
@@ -282,23 +294,23 @@
 // Example: Spin Around the Cylindrical Axis
 //   cylindrical_extrude(or=50, ir=45, spin=90)
 //       text(text="Hello World!", size=10, halign="center", valign="center");
 // Example: Orient to the Y Axis.
 //   cylindrical_extrude(or=40, ir=35, orient=BACK)
 //       text(text="Hello World!", size=10, halign="center", valign="center");
 module cylindrical_extrude(ir, or, od, id, size=1000, convexity=10, spin=0, orient=UP) {
-    assert(is_num(size) || is_vector(size,2));
+    check1 = assert(is_num(size) || is_vector(size,2));
     size = is_num(size)? [size,size] : size;
     ir = get_radius(r=ir,d=id);
     or = get_radius(r=or,d=od);
-    assert(all_positive([ir,or]), "Must supply positive inner and outer radius or diameter");
+    check2 = assert(all_positive([ir,or]), "Must supply positive inner and outer radius or diameter");
     index_r = or;
     circumf = 2 * PI * index_r;
     width = min(size.x, circumf);
-    assert(width <= circumf, "Shape would more than completely wrap around.");
+    check3 = assert(width <= circumf, "Shape would more than completely wrap around.");
     sides = segs(or);
     step = circumf / sides;
     steps = ceil(width / step);
     rot(from=UP, to=orient) rot(spin) {
         for (i=[0:1:steps-2]) {
             x = (i+0.5-steps/2) * step;
             zrot(360 * x / circumf) {
@@ -316,14 +328,17 @@
             }
         }
     }
 }
 
 
 // Module: extrude_from_to()
+// Extrudes 2D children between two points in 3D space.
+// Topics: Extrusion, Mutators
+// See Also: path_sweep(), path_extrude2d()
 // Usage:
 //   extrude_from_to(pt1, pt2, [convexity=], [twist=], [scale=], [slices=]) 2D-CHILDREN;
 // Description:
 //   Extrudes the 2D children linearly between the 3d points pt1 and pt2.  The origin of the 2D children are placed on
 //   pt1 and pt2, and oriented perpendicular to the line between the points.  
 // Arguments:
 //   pt1 = starting point of extrusion.
@@ -334,16 +349,17 @@
 //   scale = scale multiplier for end of extrusion compared the start.
 //   slices = Number of slices along the extrusion to break the extrusion into.  Useful for refining `twist` extrusions.
 // Example(FlatSpin,VPD=200,VPT=[0,0,15]):
 //   extrude_from_to([0,0,0], [10,20,30], convexity=4, twist=360, scale=3.0, slices=40) {
 //       xcopies(3) circle(3, $fn=32);
 //   }
 module extrude_from_to(pt1, pt2, convexity, twist, scale, slices) {
-    assert(is_vector(pt1));
-    assert(is_vector(pt2));
+    check =
+      assert(is_vector(pt1),"First point must be a vector")
+      assert(is_vector(pt2),"Second point must be a vector");
     pt1 = point3d(pt1);
     pt2 = point3d(pt2);
     rtp = xyz_to_spherical(pt2-pt1);
     translate(pt1) {
         rotate([0, rtp[2], rtp[1]]) {
             if (rtp[0] > 0) {
                 linear_extrude(height=rtp[0], convexity=convexity, center=false, slices=slices, twist=twist, scale=scale) {
@@ -353,18 +369,20 @@
         }
     }
 }
 
 
 
 // Module: path_extrude()
+// Synopsis: Extrudes 2D children along a 3D path.
+// Topics: Paths, Extrusion, Mutators
+// See Also: path_sweep(), path_extrude2d()
 // Usage: path_extrude(path, [convexity], [clipsize]) 2D-CHILDREN;
 // Description:
 //   Extrudes 2D children along a 3D path.  This may be slow and can have problems with twisting.  
-// See Also: path_sweep()
 // Arguments:
 //   path = Array of points for the bezier path to extrude along.
 //   convexity = Maximum number of walls a ray can pass through.
 //   clipsize = Increase if artifacts are left.  Default: 100
 // Example(FlatSpin,VPD=600,VPT=[75,16,20]):
 //   path = [ [0, 0, 0], [33, 33, 33], [66, 33, 40], [100, 0, 0], [150,0,0] ];
 //   path_extrude(path) circle(r=10, $fn=6);
@@ -412,14 +430,17 @@
 
 
 //////////////////////////////////////////////////////////////////////
 // Section: Offset Mutators
 //////////////////////////////////////////////////////////////////////
 
 // Module: minkowski_difference()
+// Synopsis: Removes diff shapes from base shape surface.
+// Topics: Mutators
+// See Also: offset3d()
 // Usage:
 //   minkowski_difference() { BASE; DIFF1; DIFF2; ... }
 // Description:
 //   Takes a 3D base shape and one or more 3D diff shapes, carves out the diff shapes from the
 //   surface of the base shape, in a way complementary to how `minkowski()` unions shapes to the
 //   surface of its base shape.
 // Arguments:
@@ -448,14 +469,17 @@
     }
 }
 
 
 
 
 // Module: offset3d()
+// Synopsis: Expands or contracts the surface of a 3D object.
+// Topics: Mutators
+// See Also: minkowski_difference(), round3d()
 // Usage:
 //   offset3d(r, [size], [convexity]) CHILDREN;
 // Description:
 //   Expands or contracts the surface of a 3D object by a given amount.  This is very, very slow.
 //   No really, this is unbearably slow.  It uses `minkowski()`.  Use this as a last resort.
 //   This is so slow that no example images will be rendered.
 // Arguments:
@@ -487,14 +511,17 @@
             }
         }
     }
 }
 
 
 // Module: round3d()
+// Synopsis: Rounds arbitrary 3d objects.
+// Topics: Rounding, Mutators
+// See Also: offset3d(), minkowski_difference()
 // Usage:
 //   round3d(r) CHILDREN;
 //   round3d(or) CHILDREN;
 //   round3d(ir) CHILDREN;
 //   round3d(or, ir) CHILDREN;
 // Description:
 //   Rounds arbitrary 3D objects.  Giving `r` rounds all concave and convex corners.  Giving just `ir`
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/partitions.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/partitions.scad`

 * *Files 7% similar despite different names*

```diff
@@ -8,14 +8,17 @@
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Planar Cutting
 
 // Function&Module: half_of()
+// Synopsis: Masks half of an object at a cut plane.
+// Topics: Partitions, Masking
+// See Also: back_half(), front_half(), left_half(), right_half(), top_half(), bottom_half()
 //
 // Usage: as module
 //   half_of(v, [cp], [s], [planar]) CHILDREN;
 // Usage: as function
 //   result = half_of(p,v,[cp]);
 //
 // Description:
@@ -114,14 +117,17 @@
             // create self-intersection or whiskers:
             z[i]*z[j] >= 0 ? [] : [(z[j]*p[i]-z[i]*p[j])/(z[j]-z[i])]) ]
         :
 */
 
 
 // Function&Module: left_half()
+// Synopsis: Masks the right half of an object along the Y-Z plane, leaving the left half.
+// Topics: Partitions, Masking
+// See Also: back_half(), front_half(), right_half(), top_half(), bottom_half(), half_of()
 //
 // Usage: as module
 //   left_half([s], [x]) CHILDREN;
 //   left_half(planar=true, [s], [x]) CHILDREN;
 // Usage: as function
 //   result = left_half(p, [x]);
 //
@@ -157,14 +163,17 @@
     }
 }
 function left_half(p,x=0) = half_of(p, LEFT, [x,0,0]);
 
 
 
 // Function&Module: right_half()
+// Synopsis: Masks the left half of an object along the Y-Z plane, leaving the right half.
+// Topics: Partitions, Masking
+// See Also: back_half(), front_half(), left_half(), top_half(), bottom_half(), half_of()
 //
 // Usage: as module
 //   right_half([s=], [x=]) CHILDREN;
 //   right_half(planar=true, [s=], [x=]) CHILDREN;
 // Usage: as function
 //   result = right_half(p, [x=]);
 //
@@ -198,14 +207,17 @@
     }
 }
 function right_half(p,x=0) = half_of(p, RIGHT, [x,0,0]);
 
 
 
 // Function&Module: front_half()
+// Synopsis: Masks the back half of an object along the X-Z plane, leaving the front half.
+// Topics: Partitions, Masking
+// See Also: back_half(), left_half(), right_half(), top_half(), bottom_half(), half_of()
 //
 // Usage:
 //   front_half([s], [y]) CHILDREN;
 //   front_half(planar=true, [s], [y]) CHILDREN;
 // Usage: as function
 //   result = front_half(p, [y]);
 //
@@ -240,14 +252,17 @@
     }
 }
 function front_half(p,y=0) = half_of(p, FRONT, [0,y,0]);
 
 
 
 // Function&Module: back_half()
+// Synopsis: Masks the front half of an object along the X-Z plane, leaving the back half.
+// Topics: Partitions, Masking
+// See Also: front_half(), left_half(), right_half(), top_half(), bottom_half(), half_of()
 //
 // Usage:
 //   back_half([s], [y]) CHILDREN;
 //   back_half(planar=true, [s], [y]) CHILDREN;
 // Usage: as function
 //   result = back_half(p, [y]);
 //
@@ -282,14 +297,17 @@
     }
 }
 function back_half(p,y=0) = half_of(p, BACK, [0,y,0]);
 
 
 
 // Function&Module: bottom_half()
+// Synopsis: Masks the top half of an object along the X-Y plane, leaving the bottom half.
+// Topics: Partitions, Masking
+// See Also: back_half(), front_half(), left_half(), right_half(), top_half(), half_of()
 //
 // Usage:
 //   bottom_half([s], [z]) CHILDREN;
 // Usage: as function
 //   result = bottom_half(p, [z]);
 //
 // Description:
@@ -316,14 +334,17 @@
     }
 }
 function bottom_half(p,z=0) = half_of(p,BOTTOM,[0,0,z]);
 
 
 
 // Function&Module: top_half()
+// Synopsis: Masks the bottom half of an object along the X-Y plane, leaving the top half.
+// Topics: Partitions, Masking
+// See Also: back_half(), front_half(), left_half(), right_half(), bottom_half(), half_of()
 //
 // Usage: as module
 //   top_half([s], [z]) CHILDREN;
 // Usage: as function
 //   result = top_half(p, [z]);
 //
 // Description:
@@ -394,16 +415,19 @@
         stidx = stidxs? last(stidxs) : 0,
         enidx = enidxs? enidxs[0] : -1,
         trunc = select(path, stidx, enidx)
     ) trunc;
 
 
 // Module: partition_mask()
+// Synopsis: Creates a mask to remove half an object with the remaining half suitable for reassembly.
+// Topics: Partitions, Masking, Paths
+// See Also: partition_cut_mask(), partition()
 // Usage:
-//   partition_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [spin], [orient]) [ATTACHMENTS];
+//   partition_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];
 // Description:
 //   Creates a mask that you can use to difference or intersect with an object to remove half of it, leaving behind a side designed to allow assembly of the sub-parts.
 // Arguments:
 //   l = The length of the cut axis.
 //   w = The width of the part to be masked, back from the cut plane.
 //   h = The height of the part to be masked.
 //   cutsize = The width of the cut pattern to be used.
@@ -444,30 +468,33 @@
         }
         children();
     }
 }
 
 
 // Module: partition_cut_mask()
+// Synopsis: Creates a mask to cut an object into two subparts that can be reassembled.
+// Topics: Partitions, Masking, Paths
+// See Also: partition_mask(), partition()
 // Usage:
-//   partition_cut_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [spin], [orient]) [ATTACHMENTS];
+//   partition_cut_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];
 // Description:
 //   Creates a mask that you can use to difference with an object to cut it into two sub-parts that can be assembled.
 //   The `$slop` value is important to get the proper fit and should probably be smaller than 0.2.  The examples below
 //   use larger values to make the mask easier to see.  
 // Arguments:
 //   l = The length of the cut axis.
 //   w = The width of the part to be masked, back from the cut plane.
 //   h = The height of the part to be masked.
 //   cutsize = The width of the cut pattern to be used.
 //   cutpath = The cutpath to use.  Standard named paths are "flat", "sawtooth", "sinewave", "comb", "finger", "dovetail", "hammerhead", and "jigsaw".  Alternatively, you can give a cutpath as a 2D path, where X is between 0 and 1, and Y is between -0.5 and 0.5.  Default: "jigsaw"
 //   gap = Empty gaps between cutpath iterations.  Default: 0
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-//   $slop = The width of the cut mask, to correct for printer-specific fitting.  Min: 0.05.
+//   $slop = The width of the cut mask, to correct for printer-specific fitting. 
 // Examples:
 //   partition_cut_mask(gap=0, cutpath="dovetail");
 //   partition_cut_mask(gap=30, cutpath="dovetail");
 //   partition_cut_mask(gap=30, cutsize=15, cutpath="dovetail");
 //   partition_cut_mask(gap=30, cutsize=[20,20], cutpath="dovetail");
 // Examples(2DMed):
 //   partition_cut_mask(cutpath="sawtooth",$slop=0.5);
@@ -487,25 +514,30 @@
         }
         children();
     }
 }
 
 
 // Module: partition()
+// Synopsis: Cuts an object in two with matched joining edges, then separates the parts .
+// Topics: Partitions, Masking, Paths
+// See Also: partition_cut_mask(), partition_mask()
 // Usage:
-//   partition(size, [spread], [cutsize], [cutpath], [gap], [spin]) CHILDREN;
+//   partition(size, [spread], [cutsize], [cutpath], [gap], [spin], [$slop=]) CHILDREN;
 // Description:
 //   Partitions an object into two parts, spread apart a small distance, with matched joining edges.
 // Arguments:
 //   size = The [X,Y,Z] size of the object to partition.
 //   spread = The distance to spread the two parts by.
 //   cutsize = The width of the cut pattern to be used.
 //   cutpath = The cutpath to use.  Standard named paths are "flat", "sawtooth", "sinewave", "comb", "finger", "dovetail", "hammerhead", and "jigsaw".  Alternatively, you can give a cutpath as a 2D path, where X is between 0 and 1, and Y is between -0.5 and 0.5.
 //   gap = Empty gaps between cutpath iterations.  Default: 0
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   ---
+//   $slop = Extra gap to leave to correct for printer-specific fitting. 
 // Examples(Med):
 //   partition(spread=12, cutpath="dovetail") cylinder(h=50, d=80, center=false);
 //   partition(spread=12, gap=30, cutpath="dovetail") cylinder(h=50, d=80, center=false);
 //   partition(spread=20, gap=20, cutsize=15, cutpath="dovetail") cylinder(h=50, d=80, center=false);
 //   partition(spread=25, gap=15, cutsize=[20,20], cutpath="dovetail") cylinder(h=50, d=80, center=false);
 // Examples(2DMed):
 //   partition(cutpath="sawtooth") cylinder(h=50, d=80, center=false);
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/paths.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/paths.scad`

 * *Files 3% similar despite different names*

```diff
@@ -14,14 +14,17 @@
 // FileSummary: Operations on paths: length, resampling, tangents, splitting into subpaths
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 // Section: Utility Functions
 
 // Function: is_path()
+// Synopsis: Returns True if 'list' is a path.
+// Topics: Paths
+// See Also: is_region(), is_vnf()
 // Usage:
 //   is_path(list, [dim], [fast])
 // Description:
 //   Returns true if `list` is a path.  A path is a list of two or more numeric vectors (AKA points).
 //   All vectors must of the same size, and may only contain numbers that are not inf or nan.
 //   By default the vectors in a path must be 2d or 3d.  Set the `dim` parameter to specify a list
 //   of allowed dimensions, or set it to `undef` to allow any dimension.  (Note that this function
@@ -51,14 +54,17 @@
     ?   is_list(list) && is_vector(list[0]) 
     :   is_matrix(list) 
         && len(list)>1 
         && len(list[0])>0
         && (is_undef(dim) || in_list(len(list[0]), force_list(dim)));
 
 // Function: is_1region()
+// Synopsis: Returns true if path is a region with one component.
+// Topics: Paths, Regions
+// See Also: force_path()
 // Usage:
 //   bool = is_1region(path, [name])
 // Description:
 //   If `path` is a region with one component (a 1-region) then return true.  If path is a region with more components
 //   then display an error message about the parameter `name` requiring a path or a single component region.  If the input
 //   is not a region then return false.  This function helps path functions accept 1-regions.
 // Arguments:
@@ -67,14 +73,17 @@
 function is_1region(path, name="path") = 
      !is_region(path)? false
     :assert(len(path)==1,str("Parameter \"",name,"\" must be a path or singleton region, but is a multicomponent region"))
      true;
 
 
 // Function: force_path()
+// Synopsis: Checks that path is a region with one component.
+// Topics: Paths, Regions
+// See Also: is_1region()
 // Usage:
 //   outpath = force_path(path, [name])
 // Description:
 //   If `path` is a region with one component (a 1-region) then return that component as a path.  If path is a region with more components
 //   then display an error message about the parameter `name` requiring a path or a single component region.  If the input
 //   is not a region then return the input without any checks.  This function helps path functions accept 1-regions.
 // Arguments:
@@ -83,40 +92,14 @@
 function force_path(path, name="path") =
    is_region(path) ?
        assert(len(path)==1, str("Parameter \"",name,"\" must be a path or singleton region, but is a multicomponent region"))
        path[0]
    : path;
 
 
-// Function: is_closed_path()
-// Usage:
-//   is_closed_path(path, [eps]);
-// Description:
-//   Returns true if the first and last points in the given path are coincident.
-function is_closed_path(path, eps=EPSILON) = approx(path[0], path[len(path)-1], eps=eps);
-
-
-// Function: close_path()
-// Usage:
-//   close_path(path);
-// Description:
-//   If a path's last point does not coincide with its first point, closes the path so it does.
-function close_path(path, eps=EPSILON) =
-    is_closed_path(path,eps=eps)? path : concat(path,[path[0]]);
-
-
-// Function: cleanup_path()
-// Usage:
-//   cleanup_path(path);
-// Description:
-//   If a path's last point coincides with its first point, deletes the last point in the path.
-function cleanup_path(path, eps=EPSILON) =
-    is_closed_path(path,eps=eps)? [for (i=[0:1:len(path)-2]) path[i]] : path;
-
-
 /// Internal Function: _path_select()
 /// Usage:
 ///   _path_select(path,s1,u1,s2,u2,[closed]):
 /// Description:
 ///   Returns a portion of a path, from between the `u1` part of segment `s1`, to the `u2` part of
 ///   segment `s2`.  Both `u1` and `u2` are values between 0.0 and 1.0, inclusive, where 0 is the start
 ///   of the segment, and 1 is the end.  Both `s1` and `s2` are integers, where 0 is the first segment.
@@ -141,14 +124,16 @@
             (s2<l && u2>0)? [lerp(path[s2],path[(s2+1)%lp],u2)] : []
         )
     ) pathout;
 
 
 
 // Function: path_merge_collinear()
+// Synopsis: Removes unnecessary points from a path.
+// Topics: Paths, Regions
 // Description:
 //   Takes a path and removes unnecessary sequential collinear points.
 // Usage:
 //   path_merge_collinear(path, [eps])
 // Arguments:
 //   path = A path of any dimension or a 1-region
 //   closed = treat as closed polygon.  Default: false
@@ -171,14 +156,17 @@
 
 
 
 // Section: Path length calculation
 
 
 // Function: path_length()
+// Synopsis: Returns the path length.
+// Topics: Paths
+// See Also: path_segment_lengths(), path_length_fractions()
 // Usage:
 //   path_length(path,[closed])
 // Description:
 //   Returns the length of the path.
 // Arguments:
 //   path = Path of any dimension or 1-region. 
 //   closed = true if the path is closed.  Default: false
@@ -191,14 +179,17 @@
     let(closed=default(closed,false))
     assert(is_bool(closed))
     len(path)<2? 0 :
     sum([for (i = [0:1:len(path)-2]) norm(path[i+1]-path[i])])+(closed?norm(path[len(path)-1]-path[0]):0);
 
 
 // Function: path_segment_lengths()
+// Synopsis: Returns a list of the lengths of segments in a path.
+// Topics: Paths
+// See Also: path_length(), path_length_fractions()
 // Usage:
 //   path_segment_lengths(path,[closed])
 // Description:
 //   Returns list of the length of each segment in a path
 // Arguments:
 //   path = path in any dimension or 1-region
 //   closed = true if the path is closed.  Default: false
@@ -210,14 +201,17 @@
     [
         for (i=[0:1:len(path)-2]) norm(path[i+1]-path[i]),
         if (closed) norm(path[0]-last(path))
     ]; 
 
 
 // Function: path_length_fractions()
+// Synopsis: Returns the fractional distance of each point along the length of a path.
+// Topics: Paths
+// See Also: path_length(), path_segment_lengths()
 // Usage:
 //   fracs = path_length_fractions(path, [closed]);
 // Description:
 //    Returns the distance fraction of each point in the path along the path, so the first
 //    point is zero and the final point is 1.  If the path is closed the length of the output
 //    will have one extra point because of the final connecting segment that connects the last
 //    point of the path to the first point.
@@ -264,15 +258,15 @@
 ///   ];
 ///   isects = _path_self_intersections(path, closed=true);
 ///   // isects == [[[-33.3333, 0], 0, 0.666667, 4, 0.333333], [[33.3333, 0], 1, 0.333333, 3, 0.666667]]
 ///   stroke(path, closed=true, width=1);
 ///   for (isect=isects) translate(isect[0]) color("blue") sphere(d=10);
 function _path_self_intersections(path, closed=true, eps=EPSILON) =
     let(
-        path = closed ? close_path(path,eps=eps) : path,
+        path = closed ? list_wrap(path,eps=eps) : path,
         plen = len(path)
     )
     [ for (i = [0:1:plen-3]) let(
           a1 = path[i],
           a2 = path[i+1], 
           seg_normal = unit([-(a2-a1).y, (a2-a1).x],[0,0]),
           vals = path*seg_normal,
@@ -296,15 +290,15 @@
                 && isect[1]>=-eps
                 && isect[1]<= 1+eps
                 && isect[2]>= -eps 
                 && isect[2]<= 1+eps)
                 [isect[0], i, isect[1], j, isect[2]]
     ];
 
-// Section: Resampling&mdash;changing the number of points in a path
+// Section: Resampling - changing the number of points in a path
 
 
 // Input `data` is a list that sums to an integer. 
 // Returns rounded version of input data so that every 
 // entry is rounded to an integer and the sum is the same as
 // that of the input.  Works by rounding an entry in the list
 // and passing the rounding error forward to the next entry.
@@ -317,14 +311,16 @@
     ) _sum_preserving_round(
         list_set(data, [index,index+1], [newval, data[index+1]-error]),
         index+1
     );
 
 
 // Function: subdivide_path()
+// Synopsis: Subdivides a path to produce a more finely sampled path.
+// Topics: Paths, Path Subdivision
 // See Also: subdivide_and_slice(), resample_path(), jittered_poly()
 // Usage:
 //   newpath = subdivide_path(path, n|refine=|maxlen=, [method=], [closed=], [exact=]);
 // Description:
 //   Takes a path as input (closed or open) and subdivides the path to produce a more
 //   finely sampled path.  You control the subdivision process by using the `maxlen` arg
 //   to specify a maximum segment length, or by specifying `n` or `refine`, which request
@@ -460,14 +456,17 @@
         if (!closed) last(path)
     ];
 
 
 
 
 // Function: resample_path()
+// Synopsis: Returns an equidistant set of points along a path.
+// Topics: Paths
+// See Also: subdivide_path()
 // Usage:
 //   newpath = resample_path(path, n|spacing=, [closed=]);
 // Description:
 //   Compute a uniform resampling of the input path.  If you specify `n` then the output path will have n
 //   points spaced uniformly (by linear interpolation along the input path segments).  The only points of the
 //   input path that are guaranteed to appear in the output path are the starting and ending points.
 //   If you specify `spacing` then the length you give will be rounded to the nearest spacing that gives
@@ -510,24 +509,27 @@
    let(
        length = path_length(path,closed),
        // In the open path case decrease n by 1 so that we don't try to get
        // path_cut to return the endpoint (which might fail due to rounding)
        // Add last point later
        n = is_def(n) ? n-(closed?0:1) : round(length/spacing),
        distlist = lerpn(0,length,n,false), 
-       cuts = _path_cut_points(path, distlist, closed=closed)
+       cuts = path_cut_points(path, distlist, closed=closed)
    )
    [ each column(cuts,0),
      if (!closed) last(path)     // Then add last point here
    ];
 
 
 // Section: Path Geometry
 
 // Function: is_path_simple()
+// Synopsis: Returns true if a path has no self intersections.
+// Topics: Paths
+// See Also: is_path()
 // Usage:
 //   bool = is_path_simple(path, [closed], [eps]);
 // Description:
 //   Returns true if the given 2D path is simple, meaning that it has no self-intersections.
 //   Repeated points are not considered self-intersections: a path with such points can
 //   still be simple.  
 //   If closed is set to true then treat the path as a polygon.
@@ -550,23 +552,26 @@
          if (approx(v1*v2/normv1/normv2,-1)) 1
     ]  == [] 
     &&
     _path_self_intersections(path,closed=closed,eps=eps) == [];
 
 
 // Function: path_closest_point()
+// Synopsis: Returns the closest place on a path to a given point.
+// Topics: Paths
+// See Also: point_line_distance(), line_closest_point()
 // Usage:
 //   index_pt = path_closest_point(path, pt);
 // Description:
 //   Finds the closest path segment, and point on that segment to the given point.
 //   Returns `[SEGNUM, POINT]`
 // Arguments:
-//   path = path of any dimension or a 1-region
-//   pt = the point to find the closest point to
-//   closed = 
+//   path = Path of any dimension or a 1-region.
+//   pt = The point to find the closest point to.
+//   closed = If true, the path is considered closed.
 // Example(2D):
 //   path = circle(d=100,$fn=6);
 //   pt = [20,10];
 //   closest = path_closest_point(path, pt);
 //   stroke(path, closed=true);
 //   color("blue") translate(pt) circle(d=3, $fn=12);
 //   color("red") translate(closest[1]) circle(d=3, $fn=12);
@@ -579,14 +584,17 @@
         pts = [for (seg=pair(path,closed)) line_closest_point(seg,pt,SEGMENT)],
         dists = [for (p=pts) norm(p-pt)],
         min_seg = min_index(dists)
     ) [min_seg, pts[min_seg]];
 
 
 // Function: path_tangents()
+// Synopsis: Returns tangent vectors for each point along a path.
+// Topics: Paths
+// See Also: path_normals()
 // Usage:
 //   tangs = path_tangents(path, [closed], [uniform]);
 // Description:
 //   Compute the tangent vector to the input path.  The derivative approximation is described in deriv().
 //   The returns vectors will be normalized to length 1.  If any derivatives are zero then
 //   the function fails with an error.  If you set `uniform` to false then the sampling is
 //   assumed to be non-uniform and the derivative is computed with adjustments to produce corrected
@@ -615,14 +623,17 @@
     assert(is_bool(closed))
     assert(is_path(path))
     !uniform ? [for(t=deriv(path,closed=closed, h=path_segment_lengths(path,closed))) unit(t)]
              : [for(t=deriv(path,closed=closed)) unit(t)];
 
 
 // Function: path_normals()
+// Synopsis: Returns normal vectors for each point along a path.
+// Topics: Paths
+// See Also: path_tangents()
 // Usage:
 //   norms = path_normals(path, [tangents], [closed]);
 // Description:
 //   Compute the normal vector to the input path.  This vector is perpendicular to the
 //   path tangent and lies in the plane of the curve.  For 3d paths we define the plane of the curve
 //   at path point i to be the plane defined by point i and its two neighbors.  At the endpoints of open paths
 //   we use the three end points.  For 3d paths the computed normal is the one lying in this plane that points
@@ -657,14 +668,17 @@
                  : let( v=cross(cross(pts[1]-pts[0], pts[2]-pts[0]),tangents[i]))
                    assert(norm(v)>EPSILON, "3D path contains collinear points")
                    unit(v)
     ];
 
 
 // Function: path_curvature()
+// Synopsis: Returns the estimated numerical curvature of the path.
+// Topics: Paths
+// See Also: path_tangents(), path_normals(), path_torsion()
 // Usage:
 //   curvs = path_curvature(path, [closed]);
 // Description:
 //   Numerically estimate the curvature of the path (in any dimension).
 // Arguments:
 //   path = path in any dimension or a 1-region
 //   closed = if true then treat the path as a polygon.  Default: false
@@ -682,14 +696,17 @@
             sqr(norm(d1[i])*norm(d2[i])) -
             sqr(d1[i]*d2[i])
         ) / pow(norm(d1[i]),3)
     ];
 
 
 // Function: path_torsion()
+// Synopsis: Returns the estimated numerical torsion of the path.
+// Topics: Paths
+// See Also: path_tangents(), path_normals(), path_curvature()
 // Usage:
 //   torsions = path_torsion(path, [closed]);
 // Description:
 //   Numerically estimate the torsion of a 3d path.
 // Arguments:
 //   path = 3D path
 //   closed = if true then treat path as a polygon.  Default: false
@@ -705,74 +722,139 @@
             crossterm = cross(d1[i],d2[i])
         ) crossterm * d3[i] / sqr(norm(crossterm))
     ];
 
 
 // Section: Breaking paths up into subpaths
 
-/// Internal Function: _path_cut_points()
-///
-/// Usage:
-///   cuts = _path_cut_points(path, dists, [closed=], [direction=]);
-///
-/// Description:
-///   Cuts a path at a list of distances from the first point in the path.  Returns a list of the cut
-///   points and indices of the next point in the path after that point.  So for example, a return
-///   value entry of [[2,3], 5] means that the cut point was [2,3] and the next point on the path after
-///   this point is path[5].  If the path is too short then _path_cut_points returns undef.  If you set
-///   `direction` to true then `_path_cut_points` will also return the tangent vector to the path and a normal
-///   vector to the path.  It tries to find a normal vector that is coplanar to the path near the cut
-///   point.  If this fails it will return a normal vector parallel to the xy plane.  The output with
-///   direction vectors will be `[point, next_index, tangent, normal]`.
-///   .
-///   If you give the very last point of the path as a cut point then the returned index will be
-///   one larger than the last index (so it will not be a valid index).  If you use the closed
-///   option then the returned index will be equal to the path length for cuts along the closing
-///   path segment, and if you give a point equal to the path length you will get an
-///   index of len(path)+1 for the index.  
-///
-/// Arguments:
-///   path = path to cut
-///   dists = distances where the path should be cut (a list) or a scalar single distance
-///   ---
-///   closed = set to true if the curve is closed.  Default: false
-///   direction = set to true to return direction vectors.  Default: false
-///
-/// Example(NORENDER):
-///   square=[[0,0],[1,0],[1,1],[0,1]];
-///   _path_cut_points(square, [.5,1.5,2.5]);   // Returns [[[0.5, 0], 1], [[1, 0.5], 2], [[0.5, 1], 3]]
-///   _path_cut_points(square, [0,1,2,3]);      // Returns [[[0, 0], 1], [[1, 0], 2], [[1, 1], 3], [[0, 1], 4]]
-///   _path_cut_points(square, [0,0.8,1.6,2.4,3.2], closed=true);  // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], [[0, 0.8], 4]]
-///   _path_cut_points(square, [0,0.8,1.6,2.4,3.2]);               // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], undef]
-function _path_cut_points(path, dists, closed=false, direction=false) =
+
+
+// Function: path_cut()
+// Synopsis: Cuts a path into subpaths at various points.
+// Topics: Paths, Path Subdivision
+// See Also: split_path_at_self_crossings(), path_cut_points()
+// Usage:
+//   path_list = path_cut(path, cutdist, [closed]);
+// Description:
+//   Given a list of distances in `cutdist`, cut the path into
+//   subpaths at those lengths, returning a list of paths.
+//   If the input path is closed then the final path will include the
+//   original starting point.  The list of cut distances must be
+//   in ascending order and should not include the endpoints: 0 
+//   or len(path).  If you repeat a distance you will get an
+//   empty list in that position in the output.  If you give an
+//   empty cutdist array you will get the input path as output
+//   (without the final vertex doubled in the case of a closed path).
+// Arguments:
+//   path = path of any dimension or a 1-region
+//   cutdist = Distance or list of distances where path is cut
+//   closed = If true, treat the path as a closed polygon.  Default: false
+// Example(2D,NoAxes):
+//   path = circle(d=100);
+//   segs = path_cut(path, [50, 200], closed=true);
+//   rainbow(segs) stroke($item, endcaps="butt", width=3);
+function path_cut(path,cutdist,closed) =
+  is_num(cutdist) ? path_cut(path,[cutdist],closed) :
+  is_1region(path) ? path_cut(path[0], cutdist, default(closed,true)):
+  let(closed=default(closed,false))
+  assert(is_bool(closed))
+  assert(is_vector(cutdist))
+  assert(last(cutdist)<path_length(path,closed=closed),"Cut distances must be smaller than the path length")
+  assert(cutdist[0]>0, "Cut distances must be strictly positive")
+  let(
+      cutlist = path_cut_points(path,cutdist,closed=closed)
+  )
+  _path_cut_getpaths(path, cutlist, closed);
+
+
+function _path_cut_getpaths(path, cutlist, closed) =
+  let(
+      cuts = len(cutlist)
+  )
+  [
+      [ each list_head(path,cutlist[0][1]-1),
+        if (!approx(cutlist[0][0], path[cutlist[0][1]-1])) cutlist[0][0]
+      ],
+      for(i=[0:1:cuts-2])
+          cutlist[i][0]==cutlist[i+1][0] && cutlist[i][1]==cutlist[i+1][1] ? []
+          :
+          [ if (!approx(cutlist[i][0], select(path,cutlist[i][1]))) cutlist[i][0],
+            each slice(path, cutlist[i][1], cutlist[i+1][1]-1),
+            if (!approx(cutlist[i+1][0], select(path,cutlist[i+1][1]-1))) cutlist[i+1][0],
+          ],
+      [
+        if (!approx(cutlist[cuts-1][0], select(path,cutlist[cuts-1][1]))) cutlist[cuts-1][0],
+        each select(path,cutlist[cuts-1][1],closed ? 0 : -1)
+      ]
+  ];
+
+
+
+// Function: path_cut_points()
+// Synopsis: Returns a list of cut points at a list of distances from the first point in a path.
+// Topics: Paths, Path Subdivision
+// See Also: path_cut(), split_path_at_self_crossings()
+// Usage:
+//   cuts = path_cut_points(path, cutdist, [closed=], [direction=]);
+//
+// Description:
+//   Cuts a path at a list of distances from the first point in the path.  Returns a list of the cut
+//   points and indices of the next point in the path after that point.  So for example, a return
+//   value entry of [[2,3], 5] means that the cut point was [2,3] and the next point on the path after
+//   this point is path[5].  If the path is too short then path_cut_points returns undef.  If you set
+//   `direction` to true then `path_cut_points` will also return the tangent vector to the path and a normal
+//   vector to the path.  It tries to find a normal vector that is coplanar to the path near the cut
+//   point.  If this fails it will return a normal vector parallel to the xy plane.  The output with
+//   direction vectors will be `[point, next_index, tangent, normal]`.
+//   .
+//   If you give the very last point of the path as a cut point then the returned index will be
+//   one larger than the last index (so it will not be a valid index).  If you use the closed
+//   option then the returned index will be equal to the path length for cuts along the closing
+//   path segment, and if you give a point equal to the path length you will get an
+//   index of len(path)+1 for the index.  
+//
+// Arguments:
+//   path = path to cut
+//   cutdist = distances where the path should be cut (a list) or a scalar single distance
+//   ---
+//   closed = set to true if the curve is closed.  Default: false
+//   direction = set to true to return direction vectors.  Default: false
+//
+// Example(NORENDER):
+//   square=[[0,0],[1,0],[1,1],[0,1]];
+//   path_cut_points(square, [.5,1.5,2.5]);   // Returns [[[0.5, 0], 1], [[1, 0.5], 2], [[0.5, 1], 3]]
+//   path_cut_points(square, [0,1,2,3]);      // Returns [[[0, 0], 1], [[1, 0], 2], [[1, 1], 3], [[0, 1], 4]]
+//   path_cut_points(square, [0,0.8,1.6,2.4,3.2], closed=true);  // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], [[0, 0.8], 4]]
+//   path_cut_points(square, [0,0.8,1.6,2.4,3.2]);               // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], undef]
+function path_cut_points(path, cutdist, closed=false, direction=false) =
     let(long_enough = len(path) >= (closed ? 3 : 2))
     assert(long_enough,len(path)<2 ? "Two points needed to define a path" : "Closed path must include three points")
-    is_num(dists) ? _path_cut_points(path, [dists],closed, direction)[0] :
-    assert(is_vector(dists))
-    assert(is_increasing(dists), "Cut distances must be an increasing list")
-    let(cuts = _path_cut_points_recurse(path,dists,closed))
+    is_num(cutdist) ? path_cut_points(path, [cutdist],closed, direction)[0] :
+    assert(is_vector(cutdist))
+    assert(is_increasing(cutdist), "Cut distances must be an increasing list")
+    let(cuts = path_cut_points_recurse(path,cutdist,closed))
     !direction
        ? cuts
        : let(
              dir = _path_cuts_dir(path, cuts, closed),
              normals = _path_cuts_normals(path, cuts, dir, closed)
          )
          hstack(cuts, list_to_matrix(dir,1), list_to_matrix(normals,1));
 
 // Main recursive path cut function
-function _path_cut_points_recurse(path, dists, closed=false, pind=0, dtotal=0, dind=0, result=[]) =
+function path_cut_points_recurse(path, dists, closed=false, pind=0, dtotal=0, dind=0, result=[]) =
     dind == len(dists) ? result :
     let(
         lastpt = len(result)==0? [] : last(result)[0],       // location of last cut point
         dpartial = len(result)==0? 0 : norm(lastpt-select(path,pind)),  // remaining length in segment
         nextpoint = dists[dind] < dpartial+dtotal  // Do we have enough length left on the current segment?
            ? [lerp(lastpt,select(path,pind),(dists[dind]-dtotal)/dpartial),pind] 
            : _path_cut_single(path, dists[dind]-dtotal-dpartial, closed, pind)
     ) 
-    _path_cut_points_recurse(path, dists, closed, nextpoint[1], dists[dind],dind+1, concat(result, [nextpoint]));
+    path_cut_points_recurse(path, dists, closed, nextpoint[1], dists[dind],dind+1, concat(result, [nextpoint]));
 
 
 // Search for a single cut point in the path
 function _path_cut_single(path, dist, closed=false, ind=0, eps=1e-7) =
     // If we get to the very end of the path (ind is last point or wraparound for closed case) then
     // check if we are within epsilon of the final path point.  If not we're out of path, so we fail
     ind==len(path)-(closed?0:1) ?
@@ -822,73 +904,14 @@
               : (nextind>1 || closed) && approx(cuts[ind][0],select(path,nextind-1),eps)
                    ? unit(thispath+lastpath)
               :  thispath
         ) nextdir
     ];
 
 
-// Function: path_cut()
-// Topics: Paths
-// See Also: split_path_at_self_crossings()
-// Usage:
-//   path_list = path_cut(path, cutdist, [closed]);
-// Description:
-//   Given a list of distances in `cutdist`, cut the path into
-//   subpaths at those lengths, returning a list of paths.
-//   If the input path is closed then the final path will include the
-//   original starting point.  The list of cut distances must be
-//   in ascending order and should not include the endpoints: 0 
-//   or len(path).  If you repeat a distance you will get an
-//   empty list in that position in the output.  If you give an
-//   empty cutdist array you will get the input path as output
-//   (without the final vertex doubled in the case of a closed path).
-// Arguments:
-//   path = path of any dimension or a 1-region
-//   cutdist = Distance or list of distances where path is cut
-//   closed = If true, treat the path as a closed polygon.  Default: false
-// Example(2D,NoAxes):
-//   path = circle(d=100);
-//   segs = path_cut(path, [50, 200], closed=true);
-//   rainbow(segs) stroke($item, endcaps="butt", width=3);
-function path_cut(path,cutdist,closed) =
-  is_num(cutdist) ? path_cut(path,[cutdist],closed) :
-  is_1region(path) ? path_cut(path[0], cutdist, default(closed,true)):
-  let(closed=default(closed,false))
-  assert(is_bool(closed))
-  assert(is_vector(cutdist))
-  assert(last(cutdist)<path_length(path,closed=closed),"Cut distances must be smaller than the path length")
-  assert(cutdist[0]>0, "Cut distances must be strictly positive")
-  let(
-      cutlist = _path_cut_points(path,cutdist,closed=closed)
-  )
-  _path_cut_getpaths(path, cutlist, closed);
-
-
-function _path_cut_getpaths(path, cutlist, closed) =
-  let(
-      cuts = len(cutlist)
-  )
-  [
-      [ each list_head(path,cutlist[0][1]-1),
-        if (!approx(cutlist[0][0], path[cutlist[0][1]-1])) cutlist[0][0]
-      ],
-      for(i=[0:1:cuts-2])
-          cutlist[i][0]==cutlist[i+1][0] && cutlist[i][1]==cutlist[i+1][1] ? []
-          :
-          [ if (!approx(cutlist[i][0], select(path,cutlist[i][1]))) cutlist[i][0],
-            each slice(path, cutlist[i][1], cutlist[i+1][1]-1),
-            if (!approx(cutlist[i+1][0], select(path,cutlist[i+1][1]-1))) cutlist[i+1][0],
-          ],
-      [
-        if (!approx(cutlist[cuts-1][0], select(path,cutlist[cuts-1][1]))) cutlist[cuts-1][0],
-        each select(path,cutlist[cuts-1][1],closed ? 0 : -1)
-      ]
-  ];
-
-
 // internal function
 // converts pathcut output form to a [segment, u]
 // form list that works withi path_select
 function _cut_to_seg_u_form(pathcut, path, closed) =
   let(lastind = len(path) - (closed?0:1))
   [for(entry=pathcut)
     entry[1] > lastind ? [lastind,0] :
@@ -901,14 +924,17 @@
     )
     [entry[1]-1,factor]
   ];
 
 
 
 // Function: split_path_at_self_crossings()
+// Synopsis: Split a 2D path wherever it crosses itself.
+// Topics: Paths, Path Subdivision
+// See Also: path_cut(), path_cut_points()
 // Usage:
 //   paths = split_path_at_self_crossings(path, [closed], [eps]);
 // Description:
 //   Splits a 2D path into sub-paths wherever the original path crosses itself.
 //   Splits may occur mid-segment, so new vertices will be created at the intersection points.
 //   Returns a list of the resulting subpaths.  
 // Arguments:
@@ -920,15 +946,15 @@
 //   paths = split_path_at_self_crossings(path);
 //   rainbow(paths) stroke($item, closed=false, width=3);
 function split_path_at_self_crossings(path, closed=true, eps=EPSILON) =
     let(path = force_path(path))
     assert(is_path(path,2), "Must give a 2D path")
     assert(is_bool(closed))
     let(
-        path = cleanup_path(path, eps=eps),
+        path = list_unwrap(path, eps=eps),
         isects = deduplicate(
             eps=eps,
             concat(
                 [[0, 0]],
                 sort([
                     for (
                         a = _path_self_intersections(path, closed=closed, eps=eps),
@@ -968,14 +994,17 @@
             p2in = point_in_polygon(p2, path, nonzero=nonzero) >= 0,
             tag = (p1in && p2in)? "I" : "O"
         ) [tag, subpath]
     ];
 
 
 // Function: polygon_parts()
+// Synopsis: Parses a self-intersecting polygon into a list of non-intersecting polygons.
+// Topics: Paths, Polygons
+// See Also: split_path_at_self_crossings(), path_cut(), path_cut_points()
 // Usage:
 //   splitpolys = polygon_parts(poly, [nonzero], [eps]);
 // Description:
 //   Given a possibly self-intersecting 2d polygon, constructs a representation of the original polygon as a list of
 //   non-intersecting simple polygons.  If nonzero is set to true then it uses the nonzero method for defining polygon membership.
 //   For simple cases, such as the pentagram, this will produce the outer perimeter of a self-intersecting polygon.  
 // Arguments:
@@ -1031,15 +1060,15 @@
 //   right(27)rainbow(polygon_parts(poly)) polygon($item);
 //   move([16,-14])rainbow(polygon_parts(poly,nonzero=true)) polygon($item);
 function polygon_parts(poly, nonzero=false, eps=EPSILON) =
     let(poly = force_path(poly))
     assert(is_path(poly,2), "Must give 2D polygon")
     assert(is_bool(nonzero))    
     let(
-        poly = cleanup_path(poly, eps=eps),
+        poly = list_unwrap(poly, eps=eps),
         tagged = _tag_self_crossing_subpaths(poly, nonzero=nonzero, closed=true, eps=eps),
         kept = [for (sub = tagged) if(sub[0] == "O") sub[1]],
         outregion = _assemble_path_fragments(kept, eps=eps)
     ) outregion;
 
 
 function _extreme_angle_fragment(seg, fragments, rightmost=true, eps=EPSILON) =
@@ -1085,31 +1114,32 @@
 /// Arguments:
 ///   fragments = List of paths to be assembled into complete polygons.
 ///   rightmost = If true, assemble paths using rightmost turns. Leftmost if false.
 ///   startfrag = The fragment to start with.  Default: 0
 ///   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)
 function _assemble_a_path_from_fragments(fragments, rightmost=true, startfrag=0, eps=EPSILON) =
     len(fragments)==0? [[],[]] :
+    len(fragments)==1? [fragments[0],[]] :
     let(
         path = fragments[startfrag],
         newfrags = [for (i=idx(fragments)) if (i!=startfrag) fragments[i]]
-    ) is_closed_path(path, eps=eps)? (
+    ) are_ends_equal(path, eps=eps)? (
         // starting fragment is already closed
         [path, newfrags]
     ) : let(
         // Find rightmost/leftmost continuation fragment
         seg = select(path,-2,-1),
         extrema = _extreme_angle_fragment(seg=seg, fragments=newfrags, rightmost=rightmost, eps=eps),
         foundfrag = extrema[0],
         remainder = extrema[1]
     ) is_undef(foundfrag)? (
         // No remaining fragments connect!  INCOMPLETE PATH!
         // Treat it as complete.
         [path, remainder]
-    ) : is_closed_path(foundfrag, eps=eps)? (
+    ) : are_ends_equal(foundfrag, eps=eps)? (
         // Found fragment is already closed
         [foundfrag, concat([path], remainder)]
     ) : let(
         fragend = last(foundfrag),
         hits = [for (i = idx(path,e=-2)) if(approx(path[i],fragend,eps=eps)) i]
     ) hits? (
         let(
@@ -1138,15 +1168,15 @@
 /// Description:
 ///   Given a list of paths, assembles them together into complete closed polygon paths if it can.
 ///   Polygons with area < eps will be discarded and not returned.  
 /// Arguments:
 ///   fragments = List of paths to be assembled into complete polygons.
 ///   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)
 function _assemble_path_fragments(fragments, eps=EPSILON, _finished=[]) =
-   len(fragments)==0? _finished :
+    len(fragments)==0? _finished :
     let(
         minxidx = min_index([
             for (frag=fragments) min(column(frag,0))
         ]),
         result_l = _assemble_a_path_from_fragments(
             fragments=fragments,
             startfrag=minxidx,
@@ -1158,15 +1188,15 @@
             startfrag=minxidx,
             rightmost=true,
             eps=eps
         ),
         l_area = abs(polygon_area(result_l[0])),
         r_area = abs(polygon_area(result_r[0])),
         result = l_area < r_area? result_l : result_r,
-        newpath = cleanup_path(result[0]),
+        newpath = list_unwrap(result[0]),
         remainder = result[1],
         finished = min(l_area,r_area)<eps ? _finished : concat(_finished, [newpath])
     ) _assemble_path_fragments(
         fragments=remainder,
         eps=eps,
         _finished=finished
     );
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/polyhedra.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/polyhedra.scad`

 * *Files 1% similar despite different names*

```diff
@@ -33,14 +33,17 @@
 // Support multiple inspheres/outspheres when appropriate?
 // face order for children?
 // orient faces so an edge is parallel to the x-axis
 //
 
 
 // Module: regular_polyhedron()
+// Synopsis: Creates a regular polyhedron with optional rounding.
+// Topics: Polyhedra, Shapes, Parts
+// See Also: regular_polyhedron_info()
 // Usage: Selecting a polyhedron
 //   regular_polyhedron([name],[index=],[type=],[faces=],[facetype=],[hasfaces=],...) [CHILDREN];
 // Usage: Controlling the size and position of the polyhedron
 //   regular_polyhedron(..., [or=|r=|d=],[ir=],[mr=],[side=],[facedown=],[anchor=], ...) [CHILDREN];]
 // Usage: Other options that change the polyhedron or handling of children
 //   regular_polyhedron(..., [draw=], [rounding=], [stellate=], [repeat=], [rotate_children=]) [CHILDREN];
 // Usage: options only for the trapezohedron
@@ -304,15 +307,15 @@
     facedown=true,
     draw=true,
     rotate_children=true,
     stellate = false,
     longside=undef, // special parameter for trapezohedron
     h=undef         // special parameter for trapezohedron
 ) {
-    assert(rounding>=0, "'rounding' must be nonnegative");
+    dummy=assert(is_num(rounding) && rounding>=0, "'rounding' must be nonnegative");
     entry = regular_polyhedron_info(
         "fullentry", name=name, index=index,
         type=type, faces=faces, facetype=facetype,
         hasfaces=hasfaces, side=side,
         ir=ir, mr=mr, or=or,
         r=r, d=d,
         anchor=anchor, 
@@ -546,14 +549,17 @@
     ["small stellated dodecahedron", "dodecahedron", sqrt((5+2*sqrt(5))/5)],
     ["great stellated dodecahedron", "icosahedron", sqrt(2/3+PHI)],
     ["small triambic icosahedron", "icosahedron", sqrt(3/5) - 1/sqrt(3)]
 ];
 
 
 // Function: regular_polyhedron_info()
+// Synopsis: Returns info used to create a regular polyhedron.
+// Topics: Polyhedra, Shapes, Parts
+// See Also: regular_polyhedron()
 //
 // Usage:
 //   info = regular_polyhedron_info(info, ...);
 //
 // Description:
 //   Calculate characteristics of regular polyhedra or the selection set for regular_polyhedron().
 //   Invoke with the same polyhedron selection and size arguments used by {{regular_polyhedron()}} and use the `info` argument to
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/regions.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/regions.scad`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 //////////////////////////////////////////////////////////////////////
 // LibFile: regions.scad
-//   This file provides 2D boolean set operations on polygons, where you can
+//   This file provides 2D Boolean set operations on polygons, where you can
 //   compute, for example, the intersection or union of the shape defined by point lists, producing
 //   a new point list.  Of course, such operations may produce shapes with multiple
 //   components.  To handle that, we use "regions" which are lists of paths representing the polygons.
 //   In addition to set operations, you can calculate offsets, determine whether a point is in a
 //   region and you can decompose a region into parts.  
 // Includes:
 //   include <BOSL2/std.scad>
 // FileGroup: Advanced Modeling
-// FileSummary: Offsets and boolean geometry of 2D paths and regions.
+// FileSummary: Offsets and Boolean geometry of 2D paths and regions.
 // FileFootnotes: STD=Included in std.scad
 //////////////////////////////////////////////////////////////////////
 
 
 // CommonCode:
 //   include <BOSL2/rounding.scad>
 
@@ -39,23 +39,29 @@
 //   compliant.  You can construct regions by making a suitable list of polygons, or by using
 //   set operation function such as union() or difference(), which all acccept polygons, as
 //   well as regions, as their inputs.  And if you must you can clean up an ill-formed region using make_region(),
 //   which will break up self-intersecting polygons and polygons that cross each other.  
 
 
 // Function: is_region()
+// Synopsis: Returns true if the input appears to be a region.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: is_valid_region(), is_1region(), is_region_simple()
 // Usage:
 //   bool = is_region(x);
 // Description:
 //   Returns true if the given item looks like a region.  A region is a list of non-crossing simple polygons.  This test just checks
 //   that the argument is a list whose first entry is a path.  
 function is_region(x) = is_list(x) && is_path(x.x);
 
 
 // Function: is_valid_region()
+// Synopsis: Returns true if the input is a valid region.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: is_region(), is_1region(), is_region_simple()
 // Usage:
 //   bool = is_valid_region(region, [eps]);
 // Description:
 //   Returns true if the input is a valid region, meaning that it is a list of simple polygons whose segments do not cross each other.
 //   This test can be time consuming with regions that contain many points.
 //   It differs from `is_region()` which simply checks that the object is a list whose first entry is a path
 //   because it searches all the list polygons for any self-intersections or intersections with each other.  
@@ -204,14 +210,17 @@
           )
           rel
          ])
        if (!all_equal(isect) || isect[0]==0) 1 ] != [];
 
 
 // Function: is_region_simple()
+// Synopsis: Returns true if the input is a region with no corner contact.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: is_region(), is_valid_region(), is_1region()
 // Usage:
 //   bool = is_region_simple(region, [eps]);
 // Description:
 //   We extend the notion of the simple path to regions: a simple region is entirely
 //   non-self-intersecting, meaning that it is formed from a list of simple polygons that
 //   don't intersect each other at all&mdash;not even with corner contact points.
 //   Regions with corner contact are valid but may fail CGAL.  Simple regions
@@ -234,20 +243,23 @@
    &&
    [for(i=[0:1:len(region)-2])
        if (_region_region_intersections([region[i]], list_tail(region,i+1), eps=eps)[0][0] != []) 1
    ] ==[];
   
   
 // Function: make_region()
+// Synopsis: Converts lists of intersecting polygons into valid regions.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: force_region(), region()
+// 
 // Usage:
 //   region = make_region(polys, [nonzero], [eps]);
 // Description:
 //   Takes a list of polygons that may intersect themselves or cross each other 
-//   and converts it into a properly defined region without
-//   these defects.
+//   and converts it into a properly defined region without these defects.
 // Arguments:
 //   polys = list of polygons to use
 //   nonzero = set to true to use nonzero rule for polygon membership.  Default: false
 //   eps = Epsilon for geometric comparisons.  Default: `EPSILON` (1e-9)
 // Example(2D,NoAxes):  The pentagram is self-intersecting, so it is not a region.  Here it becomes five triangles:
 //   pentagram = turtle(["move",100,"left",144], repeat=4);
 //   region = make_region(pentagram);
@@ -264,26 +276,32 @@
      let(polys=force_region(polys))
      assert(is_region(polys), "Input is not a region")
      exclusive_or(
                   [for(poly=polys) each polygon_parts(poly,nonzero,eps)],
                   eps=eps);
 
 // Function: force_region()
+// Synopsis: Given a polygon returns a region.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: make_region(), region()
 // Usage:
 //   region = force_region(poly)
 // Description:
 //   If the input is a polygon then return it as a region.  Otherwise return it unaltered.
 // Arguments:
 //   poly = polygon to turn into a region
 function force_region(poly) = is_path(poly) ? [poly] : poly;
 
 
 // Section: Turning a region into geometry
 
 // Module: region()
+// Synopsis: Creates the 2D polygons described by the given region or list of polygons.
+// Topics: Regions, Paths, Polygons, List Handling
+// See Also: make_region(), region()
 // Usage:
 //   region(r, [anchor], [spin=], [cp=], [atype=]) [ATTACHMENTS];
 // Description:
 //   Creates the 2D polygons described by the given region or list of polygons.  This module works on
 //   arbitrary lists of polygons that cross each other and hence do not define a valid region.  The
 //   displayed result is the exclusive-or of the polygons listed in the input. 
 // Arguments:
@@ -317,14 +335,17 @@
 }
 
 
 
 // Section: Gometrical calculations with regions
 
 // Function: point_in_region()
+// Synopsis: Tests if a point is inside, outside, or on the border of a region. 
+// Topics: Regions, Points, Comparison
+// See Also: region_area(), are_regions_equal()
 // Usage:
 //   check = point_in_region(point, region, [eps]);
 // Description:
 //   Tests if a point is inside, outside, or on the border of a region.  
 //   Returns -1 if the point is outside the region.
 //   Returns 0 if the point is on the boundary.
 //   Returns 1 if the point lies inside the region.
@@ -352,14 +373,16 @@
           pip = point_in_polygon(point, region[i], eps=eps)
       )
       pip == 0 ? 0
    : _point_in_region(point, region, eps=eps, i=i+1, cnt = cnt + (pip>0? 1 : 0));
 
 
 // Function: region_area()
+// Synopsis: Computes the area of the specified valid region.
+// Topics: Regions, Area
 // Usage:
 //   area = region_area(region);
 // Description:
 //   Computes the area of the specified valid region. (If the region is invalid and has self intersections
 //   the result is meaningless.)
 // Arguments:
 //   region = region whose area to compute
@@ -373,14 +396,16 @@
   -sum([for(R=parts, poly=R) polygon_area(poly,signed=true)]);
 
 
 
 function _clockwise_region(r) = [for(p=r) clockwise_polygon(p)];
 
 // Function: are_regions_equal()
+// Synopsis: Returns true if given regions are the same polygons.
+// Topics: Regions, Polygons, Comparison
 // Usage:
 //    b = are_regions_equal(region1, region2, [either_winding])
 // Description:
 //    Returns true if the components of region1 and region2 are the same polygons (in any order). 
 // Arguments:
 //    region1 = first region
 //    region2 = second region
@@ -417,15 +442,15 @@
 ///    region2 touches itself at a vertex.  (The paths are assumed to have no self crossings.
 ///    Self crossings of the paths in the regions are not returned.)
 function _region_region_intersections(region1, region2, closed1=true,closed2=true, eps=EPSILON) =
    let(
        intersections =   [
            for(p1=idx(region1))
               let(
-                  path = closed1?close_path(region1[p1]):region1[p1]
+                  path = closed1?list_wrap(region1[p1]):region1[p1]
               )
               for(i = [0:1:len(path)-2])
                   let(
                       a1 = path[i],
                       a2 = path[i+1],
                       nrm = norm(a1-a2)
                   )
@@ -438,15 +463,15 @@
                            // poly vertex j to the line [a1,a2] where near zero
                            // distances are snapped to zero;  poly edges 
                            //  with equal signs at its vertices cannot intersect
                            // the path edge [a1,a2] or they are collinear and 
                            // further tests can be discarded.
                        for(p2=idx(region2))
                            let(
-                               poly  = closed2?close_path(region2[p2]):region2[p2],
+                               poly  = closed2?list_wrap(region2[p2]):region2[p2],
                                signs = [for(v=poly*seg_normal) abs(v-ref) < eps ? 0 : sign(v-ref) ]
                            ) 
                            if(max(signs)>=0 && min(signs)<=0) // some edge intersects line [a1,a2]
                                for(j=[0:1:len(poly)-2]) 
                                    if(signs[j]!=signs[j+1])
                                         let( // exclude non-crossing and collinear segments
                                             b1 = poly[j],
@@ -479,14 +504,18 @@
        [for(i=[0:1]) [for(j=counts[i]) _sort_vectors(select(risect[i],pathind[i][j]))]];
          
 
 // Section: Breaking up regions into subregions
 
 
 // Function: split_region_at_region_crossings()
+// Synopsis: Splits regions where polygons touch and at intersections.
+// Topics: Regions, Polygons, List Handling
+// See Also: region_parts()
+// 
 // Usage:
 //   split_region = split_region_at_region_crossings(region1, region2, [closed1], [closed2], [eps])
 // Description:
 //   Splits region1 at the places where polygons in region1 touches each other at corners and at locations
 //   where region1 intersections region2.  Split region2 similarly with respect to region1.
 //   The return is a pair of results of the form [split1, split2] where split1=[frags1,frags2,...]
 //   and frags1 is a list of paths that when placed end to end (in the given order), give the first polygon of region1.
@@ -542,14 +571,17 @@
         [for(s=subpaths) if (len(s)>1) s]
        ]
     ];
                 
                 
 
 // Function: region_parts()
+// Synopsis: Splits a region into a list of regions.
+// Topics: Regions, List Handling
+// See Also: split_region_at_region_crossings()
 // Usage:
 //   rgns = region_parts(region);
 // Description:
 //   Divides a region into a list of connected regions.  Each connected region has exactly one clockwise outside boundary
 //   and zero or more counter-clockwise outlines defining internal holes.  Note that behavior is undefined on invalid regions whose
 //   components cross each other.
 // Example(2D,NoAxes):
@@ -702,14 +734,16 @@
                 projection > pathseg_len[i]? norm(pt-select(path,i+1)) :
                 norm(v-projection*pathseg_unit[i])
         ) segdist
     ]);
 
 
 // Function: offset()
+// Synopsis: Takes a 2D path, polygon or region and returns a path offset by an amount.
+// Topics: Paths, Polygons, Regions
 // Usage:
 //   offsetpath = offset(path, [r=|delta=], [chamfer=], [closed=], [check_valid=], [quality=], [same_length=])
 //   path_faces = offset(path, return_faces=true, [r=|delta=], [chamfer=], [closed=], [check_valid=], [quality=], [firstface_index=], [flip_faces=])
 // Description:
 //   Takes a 2D input path, polygon or region and returns a path offset by the specified amount.  As with the built-in
 //   offset() module, you can use `r` to specify rounded offset and `delta` to specify offset with
 //   corners.  If you used `delta` you can set `chamfer` to true to get chamfers.
@@ -849,15 +883,18 @@
     assert(rcount==1,"Must define exactly one of 'delta' and 'r'")
     assert(!same_length || (is_def(delta) && !chamfer), "Must specify delta, with chamfer=false, when same_length=true")
     assert(is_path(path), "Input must be a path or region")
     let(
         chamfer = is_def(r) ? false : chamfer,
         quality = max(0,round(quality)),
         flip_dir = closed && !is_polygon_clockwise(path)? -1 : 1,
-        d = flip_dir * (is_def(r) ? r : delta),
+        d = flip_dir * (is_def(r) ? r : delta)
+    )
+    d==0 && !return_faces ? path :
+    let(
 //        shiftsegs = [for(i=[0:len(path)-1]) _shift_segment(select(path,i,i+1), d)],
         shiftsegs = [for(i=[0:len(path)-2]) _shift_segment([path[i],path[i+1]], d),
                      if (closed) _shift_segment([last(path),path[0]],d)
                      else [path[0],path[1]]  // dummy segment, not used
                     ],
         // good segments are ones where no point on the segment is less than distance d from any point on the path
         good = check_valid ? _good_segments(path, abs(d), shiftsegs, closed, quality) : repeat(true,len(shiftsegs)),
@@ -872,15 +909,15 @@
         // Note if !closed the last corner doesn't matter, so exclude it
         parallelcheck =
             (len(sharpcorners)==2 && !closed) ||
             all_defined(closed? sharpcorners : select(sharpcorners, 1,-2))
     )
     assert(parallelcheck, "Path contains a segment that reverses direction (180 deg turn)")
     let(
-        // This is a boolean array that indicates whether a corner is an outside or inside corner
+        // This is a Boolean array that indicates whether a corner is an outside or inside corner
         // For outside corners, the newcorner is an extension (angle 0), for inside corners, it turns backward
         // If either side turns back it is an inside corner---must check both.
         // Outside corners can get rounded (if r is specified and there is space to round them)
         outsidecorner = len(sharpcorners)==2 ? [false,false]
            :
             [for(i=[0:len(goodsegs)-1])
                 let(prevseg=select(goodsegs,i-1))
@@ -1002,14 +1039,17 @@
      if (is_def(b)) b,
      if (is_def(c)) c
    ];
 
 
 
 // Function&Module: union()
+// Synopsis: Performs a Boolean union operation.
+// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D
+// See Also: difference(), intersection(), diff(), intersect(), exclusive_or()
 // Usage:
 //   union() CHILDREN;
 //   region = union(regions);
 //   region = union(REGION1,REGION2);
 //   region = union(REGION1,REGION2,REGION3);
 // Description:
 //   When called as a function and given a list of regions or 2D polygons,
@@ -1032,14 +1072,17 @@
            for (i=[2:1:len(regions)-1]) regions[i]
           ],
           eps=eps
     );
 
 
 // Function&Module: difference()
+// Synopsis: Performs a Boolean difference operation.
+// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D
+// See Also: union(), intersection(), diff(), intersect(), exclusive_or()
 // Usage:
 //   difference() CHILDREN;
 //   region = difference(regions);
 //   region = difference(REGION1,REGION2);
 //   region = difference(REGION1,REGION2,REGION3);
 // Description:
 //   When called as a function, and given a list of regions or 2D polygons, 
@@ -1064,14 +1107,17 @@
                  for (i=[2:1:len(regions)-1]) regions[i]
                 ],
                 eps=eps
      );
 
 
 // Function&Module: intersection()
+// Synopsis: Performs a Boolean intersection operation.
+// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D
+// See Also: difference(), union(), diff(), intersect(), exclusive_or()
 // Usage:
 //   intersection() CHILDREN;
 //   region = intersection(regions);
 //   region = intersection(REGION1,REGION2);
 //   region = intersection(REGION1,REGION2,REGION3);
 // Description:
 //   When called as a function, and given a list of regions or polygons returns the
@@ -1095,23 +1141,26 @@
                   ],
                   eps=eps
      );
 
 
 
 // Function&Module: exclusive_or()
+// Synopsis: Performs a Boolean exclusive-or operation.
+// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D
+// See Also: union(), difference(), intersection(), diff(), intersect()
 // Usage:
 //   exclusive_or() CHILDREN;
 //   region = exclusive_or(regions);
 //   region = exclusive_or(REGION1,REGION2);
 //   region = exclusive_or(REGION1,REGION2,REGION3);
 // Description:
 //   When called as a function and given a list of regions or 2D polygons, 
 //   returns the exclusive_or of all given regions.  Result is a single region.
-//   When called as a module, performs a boolean exclusive-or of up to 10 children.  Note that when
+//   When called as a module, performs a Boolean exclusive-or of up to 10 children.  Note that when
 //   the input regions cross each other the exclusive-or operator will produce shapes that
 //   meet at corners (non-simple regions), which do not render in CGAL.  
 // Arguments:
 //   regions = List of regions or polygons to exclusive_or
 // Example(2D): As Function.  A linear_sweep of this shape fails to render in CGAL.  
 //   shape1 = move([-8,-8,0], p=circle(d=50));
 //   shape2 = move([ 8, 8,0], p=circle(d=50));
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/rounding.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/rounding.scad`

 * *Files 1% similar despite different names*

```diff
@@ -130,18 +130,19 @@
 //         select(round_corners(example, joint=18, method="chamfer",closed=false),1,-2),
 //         width=strokewidth);
 
 
 // Section: Rounding Paths
 
 // Function: round_corners()
-//
+// Synopsis: Round or chamfer the corners of a path (clipping them off).
+// Topics: Rounding, Paths
+// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()
 // Usage:
 //   rounded_path = round_corners(path, [method], [radius=], [cut=], [joint=], [closed=], [verbose=]);
-//
 // Description:
 //   Takes a 2D or 3D path as input and rounds each corner
 //   by a specified amount.  The rounding at each point can be different and some points can have zero
 //   rounding.  The `round_corners()` function supports three types of corner treatment: chamfers, circular rounding,
 //   and continuous curvature rounding using 4th order bezier curves.  See
 //   [Types of Roundover](rounding.scad#subsection-types-of-roundover) for details on rounding types.  
 //   .
@@ -591,14 +592,17 @@
         )
   
         quant(extra > 0? concat(offsets, [last(offsets)+[0,z_dir*extra]]) : offsets, 1/1024);
 
 
 
 // Function: smooth_path()
+// Synopsis: Create smoothed path that passes through all the points of a given path.
+// Topics: Rounding, Paths
+// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()
 // Usage:
 //   smoothed = smooth_path(path, [tangents], [size=|relsize=], [splinesteps=], [closed=], [uniform=]);
 // Description:
 //   Smooths the input path using a cubic spline.  Every segment of the path will be replaced by a cubic curve
 //   with `splinesteps` points.  The cubic interpolation will pass through every input point on the path
 //   and will match the tangents at every point.  If you do not specify tangents they will be computed using
 //   path_tangents with uniform=false by default.  Note that setting uniform to true with non-uniform
@@ -674,26 +678,29 @@
 module smooth_path(path, tangents, size, relsize, splinesteps=10, uniform=false, closed=false) {no_module();}
 function smooth_path(path, tangents, size, relsize, splinesteps=10, uniform=false, closed) =
   is_1region(path) ? smooth_path(path[0], tangents, size, relsize, splinesteps, uniform, default(closed,true)) :
   let (
      bez = path_to_bezpath(path, tangents=tangents, size=size, relsize=relsize, uniform=uniform, closed=default(closed,false)),
      smoothed = bezpath_curve(bez,splinesteps=splinesteps)
   )
-  closed ? cleanup_path(smoothed) : smoothed;
+  closed ? list_unwrap(smoothed) : smoothed;
 
 
 function _scalar_to_vector(value,length,varname) = 
   is_vector(value)
     ? assert(len(value)==length, str(varname," must be length ",length))
       value
     : assert(is_num(value), str(varname, " must be a numerical value"))
       repeat(value, length);
 
 
 // Function: path_join()
+// Synopsis: Join paths end to end with optional rounding.
+// Topics: Rounding, Paths
+// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()
 // Usage:
 //   joined_path = path_join(paths, [joint], [k=], [relocate=], [closed=]);
 // Description:
 //   Connect a sequence of paths together into a single path with optional continuous curvature rounding
 //   applied at the joints.  By default the first path is taken as specified and subsequent paths are
 //   translated into position so that each path starts where the previous path ended.
 //   If you set relocate to false then this relocation is skipped.
@@ -783,15 +790,15 @@
 // Example(2D): Here relocation is off.  We have three segments (in yellow) and add the curves to the segments.  Notice that joint zero still produces a curve because it refers to the endpoints of the supplied paths.  
 //   p1 = [[0,0],[2,0]];
 //   p2 = [[3,1],[1,3]];
 //   p3 = [[0,3],[-1,1]];
 //   color("red")stroke(
 //     path_join([p1,p2,p3], joint=0, relocate=false,
 //               closed=true),
-//     width=.3,$fn=12);
+//     width=.3,$fn=48);
 //   for(x=[p1,p2,p3]) stroke(x,width=.3);
 // Example(2D): If you specify closed=true when the last path doesn't meet the first one then it is similar to using relocate=false: the function tries to close the path using a curve.  In the example below, this results in a long curve to the left, when given the unclosed three segments as input.  Note that if the segments are parallel the function fails with an error.  The extension of the curves must intersect in a corner for the rounding to be well-defined.  To get a normal rounding of the closed shape, you must include a fourth path, the last segment that closes the shape.
 //   horiz = [[0,0],[10,0]];
 //   vert = [[0,0],[0,10]];
 //   h2 = [[0,-3],[10,0]];
 //   color("red")stroke(
 //     path_join([horiz, vert, -h2],closed=true,
@@ -811,28 +818,28 @@
   )
   assert(badpath==[], str("Entries in paths are not valid paths: ",badpath))
   len(paths)==0 ? [] :
   len(paths)==1 && !closed ? paths[0] :
   let(
       paths = !closed || len(paths)>1
             ? paths
-            : [close_path(paths[0])],
+            : [list_wrap(paths[0])],
       N = len(paths) + (closed?0:-1),
       k = _scalar_to_vector(k,N),
       repjoint = is_num(joint) || (is_vector(joint,2) && len(paths)!=3),
       joint = repjoint ? repeat(joint,N) : joint
   )
   assert(all_nonnegative(k), "k must be nonnegative")
   assert(len(joint)==N,str("Input joint must be scalar or length ",N))
   let(
       bad_j = [for(j=idx(joint)) if (!is_num(joint[j]) && !is_vector(joint[j],2)) j]
   )
   assert(bad_j==[], str("Invalid joint values at indices ",bad_j))
   let(result=_path_join(paths,joint,k, relocate=relocate, closed=closed))
-  closed ? cleanup_path(result) : result;
+  closed ? list_unwrap(result) : result;
 
 function _path_join(paths,joint,k=0.5,i=0,result=[],relocate=true,closed=false) =
   let( 
       result = result==[] ? paths[0] : result,
       loop = i==len(paths)-1,
       revresult = reverse(result),
       nextpath = loop     ? result
@@ -841,16 +848,16 @@
       d_first = is_vector(joint[i]) ? joint[i][0] : joint[i],
       d_next = is_vector(joint[i]) ? joint[i][1] : joint[i]
   )
   assert(d_first>=0 && d_next>=0, str("Joint value negative when adding path ",i+1))
   assert(d_first<path_length(revresult),str("Path ",i," is too short for specified cut distance ",d_first))
   assert(d_next<path_length(nextpath), str("Path ",i+1," is too short for specified cut distance ",d_next))
   let(
-      firstcut = _path_cut_points(revresult, d_first, direction=true),
-      nextcut = _path_cut_points(nextpath, d_next, direction=true)
+      firstcut = path_cut_points(revresult, d_first, direction=true),
+      nextcut = path_cut_points(nextpath, d_next, direction=true)
   )
   assert(!loop || nextcut[1] < len(revresult)-1-firstcut[1], "Path is too short to close the loop")
   let(
      first_dir=firstcut[2],
      next_dir=nextcut[2],
      corner = line_intersection([firstcut[0], firstcut[0]-first_dir], [nextcut[0], nextcut[0]-next_dir],RAY,RAY)
   )
@@ -871,19 +878,22 @@
   i==len(paths)-(closed?1:2)
      ? new_result
      : _path_join(paths,joint,k,i+1,new_result, relocate,closed);
 
 
 
 // Function&Module: offset_stroke()
+// Synopsis: Draws a line along a path with options to specify angles and roundings at the ends.
+// Topics: Rounding, Paths
+// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()
 // Usage: as module
-//   offset_stroke(path, [width], [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=], [closed=]);
+//   offset_stroke(path, [width], [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=], [closed=],...) [ATTACHMENTS];
 // Usage: as function
-//   path = offset_stroke(path, [width], closed=false, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=]);
-//   region = offset_stroke(path, [width], closed=true, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=]);
+//   path = offset_stroke(path, [width], closed=false, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=],...);
+//   region = offset_stroke(path, [width], closed=true, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=],...);
 // Description:
 //   Uses `offset()` to compute a stroke for the input path.  Unlike `stroke`, the result does not need to be
 //   centered on the input path.  The corners can be rounded, pointed, or chamfered, and you can make the ends
 //   rounded, flat or pointed with the `start` and `end` parameters.
 //   .
 //   The `check_valid` and `quality`  parameters are passed through to `offset()`
 //   .
@@ -923,20 +933,23 @@
 //   (This means that even a quarter circle will have `$fn` segments, unlike the usual case where it would have `$fn/4` segments.)
 // Arguments:
 //   path = 2d path that defines the stroke
 //   width = width of the stroke, a scalar or a vector of 2 values giving the offset from the path.  Default: 1
 //   ---
 //   rounded = set to true to use rounded offsets, false to use sharp (delta) offsets.  Default: true
 //   chamfer = set to true to use chamfers when `rounded=false`.  Default: false
-//   start = end treatment for the start of the stroke.  See above for details.  Default: "flat"
-//   end = end treatment for the end of the stroke.  See above for details.  Default: "flat"
+//   start = end treatment for the start of the stroke when closed=false.  See above for details.  Default: "flat"
+//   end = end treatment for the end of the stroke when closed=false.  See above for details.  Default: "flat"
 //   check_valid = passed to offset().  Default: true
 //   quality = passed to offset().  Default: 1
 //   closed = true if the curve is closed, false otherwise.  Default: false
-//
+//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `"origin"`
+//   spin = Rotate this many degrees after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 2D point.  Default: "centroid"
+//   atype = Set to "hull" or "intersect" to select anchor type.  Default: "hull"
 // Example(2D):  Basic examples illustrating flat, round, and pointed ends, on a finely sampled arc and a path made from 3 segments.
 //   arc = arc(points=[[1,1],[3,4],[6,3]],n=50);
 //   path = [[0,0],[6,2],[9,7],[8,10]];
 //   xdistribute(spacing=10){
 //     offset_stroke(path, width = 2);
 //     offset_stroke(path, start="round", end="round", width = 2);
 //     offset_stroke(path, start="pointed", end="pointed", width = 2);
@@ -1024,52 +1037,61 @@
 //                   width = [1.9, 2]);
 // Example(2D): Self-intersecting paths are handled differently than with the `stroke()` module.
 //   $fn=16;
 //   path = turtle(["move",10,"left",144], repeat=4);
 //   stroke(path, closed=true);
 //   right(12)
 //     offset_stroke(path, width=1, closed=true);
-function offset_stroke(path, width=1, rounded=true, start="flat", end="flat", check_valid=true, quality=1, chamfer=false, closed=false) =
+function offset_stroke(path, width=1, rounded=true, start, end, check_valid=true, quality=1, chamfer=false, closed=false,
+                       atype="hull", anchor, spin, cp="centroid") =
         let(path = force_path(path))
         assert(is_path(path,2),"path is not a 2d path")
-        let(closedok = !closed || (is_undef(start) && is_undef(end)))
-        assert(closedok, "Parameters `start` and `end` not allowed with closed path")
         let(
-                start = closed? [] : _parse_stroke_end(default(start,"flat"),"start"),
-                end = closed? [] : _parse_stroke_end(default(end,"flat"),"end"),
-                width = is_list(width)? reverse(sort(width)) : [1,-1]*width/2,
-                left_r = !rounded? undef : width[0],
-                left_delta = rounded? undef : width[0],
-                right_r = !rounded? undef : width[1],
-                right_delta = rounded? undef : width[1],
-                left_path = offset(
-                        path, delta=left_delta, r=left_r, closed=closed,
-                        check_valid=check_valid, quality=quality,
-                        chamfer=chamfer 
-                ),
-                right_path = offset(
-                        path, delta=right_delta, r=right_r, closed=closed,
-                        check_valid=check_valid, quality=quality,
-                        chamfer=chamfer 
-                )
+            closedok = !closed || (is_undef(start) && is_undef(end)),
+            start = default(start,"flat"),
+            end = default(end,"flat")
         )
-        closed? [left_path, right_path] :
+        assert(closedok, "Parameters `start` and `end` not allowed with closed path")
         let(
-                startpath = _stroke_end(width,left_path, right_path, start),
-                endpath = _stroke_end(reverse(width),reverse(right_path), reverse(left_path),end),
-                clipping_ok = startpath[1]+endpath[2]<=len(left_path) && startpath[2]+endpath[1]<=len(right_path)
-        )
-        assert(clipping_ok, "End treatment removed the whole stroke")
-        concat(
-                slice(left_path,startpath[1],-1-endpath[2]),
-                endpath[0],
-                reverse(slice(right_path,startpath[2],-1-endpath[1])),
-                startpath[0]
-        );
-
+            start = closed? [] : _parse_stroke_end(default(start,"flat"),"start"),
+            end = closed? [] : _parse_stroke_end(default(end,"flat"),"end"),
+            width = is_list(width)? reverse(sort(width)) : [1,-1]*width/2,
+            left_r = !rounded? undef : width[0],
+            left_delta = rounded? undef : width[0],
+            right_r = !rounded? undef : width[1],
+            right_delta = rounded? undef : width[1],
+            left_path = offset(
+                    path, delta=left_delta, r=left_r, closed=closed,
+                    check_valid=check_valid, quality=quality,
+                    chamfer=chamfer 
+            ),
+            right_path = offset(
+                    path, delta=right_delta, r=right_r, closed=closed,
+                    check_valid=check_valid, quality=quality,
+                    chamfer=chamfer 
+            )
+         )
+         closed? let(pts = [left_path, right_path])
+                 reorient(anchor=anchor, spin=spin, two_d=true, region=pts, extent=atype=="hull", cp=cp, p=pts)
+         :
+         let(
+             startpath = _stroke_end(width,left_path, right_path, start),
+             endpath = _stroke_end(reverse(width),reverse(right_path), reverse(left_path),end),
+             clipping_ok = startpath[1]+endpath[2]<=len(left_path) && startpath[2]+endpath[1]<=len(right_path)
+         )
+         assert(clipping_ok, "End treatment removed the whole stroke")
+         let(
+             pts = concat(
+                          slice(left_path,startpath[1],-1-endpath[2]),
+                          endpath[0],
+                          reverse(slice(right_path,startpath[2],-1-endpath[1])),
+                          startpath[0]
+                  )
+         )
+         reorient(anchor=anchor, spin=spin, two_d=true, path=pts, extent=atype=="hull", cp=cp, p=pts);
 
 function os_pointed(dist,loc=0) =
         assert(is_def(dist), "Must specify `dist`")
         [
                 "for", "offset_stroke",
                 "type", "shifted_point",
                 "loc",loc,
@@ -1181,21 +1203,22 @@
                                 vector_angle([newleft[1],newleft[0],newright[0]])/2 :
                                 90-vector_angle([newleft[1],newleft[0],newright[0]])/2,
                         rightangle = cutright>=0?
                                 vector_angle([newright[1],newright[0],newleft[0]])/2 :
                                 90-vector_angle([newright[1],newright[0],newleft[0]])/2,
                         jointleft = 8*cutleft/cos(leftangle)/(1+4*bez_k),
                         jointright = 8*cutright/cos(rightangle)/(1+4*bez_k),
-                        pathcutleft = _path_cut_points(newleft,abs(jointleft)),
-                        pathcutright = _path_cut_points(newright,abs(jointright)),
+                        pathcutleft = path_cut_points(newleft,abs(jointleft)),
+                        pathcutright = path_cut_points(newright,abs(jointright)),
                         leftdelete = intright? pathcutleft[1] : pathcutleft[1] + pathclip[1] -1,
                         rightdelete = intright? pathcutright[1] + pathclip[1] -1 : pathcutright[1],
                         leftcorner = line_intersection([pathcutleft[0], newleft[pathcutleft[1]]], [newright[0],newleft[0]]),
                         rightcorner = line_intersection([pathcutright[0], newright[pathcutright[1]]], [newright[0],newleft[0]]),
-                        roundover_fits = jointleft+jointright < norm(rightcorner-leftcorner)
+                        roundover_fits = is_def(rightcorner) && is_def(leftcorner) &&
+                                         jointleft+jointright < norm(rightcorner-leftcorner)
                 )
                 assert(roundover_fits,"Roundover too large to fit")
                 let(
                         angled_dir = unit(newleft[0]-newright[0]),
                         nPleft = [
                                 leftcorner - jointleft*angled_dir,
                                 leftcorner,
@@ -1218,39 +1241,38 @@
         let(intersect=line_intersection(line, select(path,ind,ind+1),LINE,SEGMENT))
         // If it intersects the segment excluding it's final point, then we're done
         // The final point is treated as part of the next segment
         is_def(intersect) && intersect != path[ind+1]?
                 [intersect, ind+1] :
                 _path_line_intersection(path, line, ind+1);
 
-module offset_stroke(path, width=1, rounded=true, start, end, check_valid=true, quality=1, chamfer=false, closed=false)
+module offset_stroke(path, width=1, rounded=true, start, end, check_valid=true, quality=1, chamfer=false, closed=false,
+                     atype="hull", anchor, spin, cp="centroid")
 {
-        no_children($children);
         result = offset_stroke(
                 path, width=width, rounded=rounded,
                 start=start, end=end,
                 check_valid=check_valid, quality=quality,
                 chamfer=chamfer,
                 closed=closed
         );
-        if (closed) {
-                region(result);
-        } else {
-                polygon(result);
-        }
+        region(result,atype=atype, anchor=anchor, spin=spin, cp=cp) children();
 }
 
 
 // Section: Three-Dimensional Rounding
 
 // Function&Module: offset_sweep()
+// Synopsis: Make a solid from a polygon with offset that changes along its length.
+// Topics: Rounding, Offsets
+// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
 // Usage: most common module arguments.  See Arguments list below for more.
 //    offset_sweep(path, [height|length|h|l|], [bottom], [top], [offset=], [convexity=],...) [ATTACHMENTS];
 // Usage: most common function arguments.  See Arguments list below for more.
-//    vnf = offset_sweep(path, [height|h|l|length], [bottom], [top], [offset=], ...);
+//   vnf = offset_sweep(path, [height|h|l|length], [bottom], [top], [offset=], ...);
 // Description:
 //   Takes a 2d path as input and extrudes it upwards and/or downward.  Each layer in the extrusion is produced using `offset()` to expand or shrink the previous layer.  When invoked as a function returns a VNF; when invoked as a module produces geometry.  
 //   Using the `top` and/or `bottom` arguments you can specify a sequence of offsets values, or you can use several built-in offset profiles that
 //   provide end treatments such as roundovers.
 //   The height of the resulting object can be specified using the `height` argument, in which case `height` must be larger than the combined height
 //   of the end treatments.  If you omit `height` then the object height will be the height of just the top and bottom end treatments.  
 //   .
@@ -1705,14 +1727,17 @@
   let(
       points = ([for(pt=list_rotate(mask,origin_index[0])) [xfactor*max(pt.x,0),-max(pt.y,0)]])
   )
   os_profile(deduplicate(move(-points[1],p=list_tail(points))), extra,check_valid,quality,offset);
 
 
 // Module: convex_offset_extrude()
+// Synopsis: Make a solid from geometry where offset changes along the object's length.
+// Topics: Rounding, Offsets
+// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
 // Usage: Basic usage.  See below for full options
 //   convex_offset_extrude(height, [bottom], [top], ...) 2D-CHILDREN;
 // Description:
 //   Extrudes 2d children with layers formed from the convex hull of the offset of each child according to a sequence of offset values.
 //   Like `offset_sweep` this module can use built-in offset profiles to provide treatments such as roundovers or chamfers but unlike `offset_sweep()` it
 //   operates on 2d children rather than a point list.  Each offset is computed using
 //   the native `offset()` module from the input geometry.
@@ -1838,23 +1863,22 @@
         offsets_top = _rounding_offsets(top, 1);
 
         // "Extra" height enlarges the result beyond the requested height, so subtract it
         bottom_height = len(offsets_bot)==0 ? 0 : abs(last(offsets_bot)[1]) - struct_val(bottom,"extra");
         top_height = len(offsets_top)==0 ? 0 : abs(last(offsets_top)[1]) - struct_val(top,"extra");
 
         height = one_defined([l,h,height,length], "l,h,height,length", dflt=u_add(bottom_height,top_height));
-        assert(height>=0, "Height must be nonnegative");
-
         middle = height-bottom_height-top_height;
-        assert(
-                middle>=0, str(
-                        "Specified end treatments (bottom height = ",bottom_height,
-                        " top_height = ",top_height,") are too large for extrusion height (",height,")"
-                )
-        );
+        check =
+          assert(height>=0, "Height must be nonnegative")
+          assert(middle>=0, str(
+                                "Specified end treatments (bottom height = ",bottom_height,
+                                " top_height = ",top_height,") are too large for extrusion height (",height,")"
+                            )
+          );
         // The entry r[i] is [radius,z] for a given layer
         r = move([0,bottom_height],p=concat(
                           reverse(offsets_bot), [[0,0], [0,middle]], move([0,middle], p=offsets_top)));
         delta = [for(val=deltas(column(r,0))) sign(val)];
         below=[-thickness,0];
         above=[0,thickness];
            // layers is a list of pairs of the relative positions for each layer, e.g. [0,thickness]
@@ -1937,14 +1961,17 @@
                       next_degenerate ? far_corner : next_corner]
             ) _smooth_bez_fill(
                       [for(row=[row0, row2, row4]) _smooth_bez_fill(row,ksides[i])],
                       ktop)];
 
 
 // Function&Module: rounded_prism()
+// Synopsis: Make a rounded 3d object by connecting two polygons with the same vertex count.
+// Topics: Rounding, Offsets
+// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
 // Usage: as a module
 //   rounded_prism(bottom, [top], [height=|h=|length=|l=], [joint_top=], [joint_bot=], [joint_sides=], [k=], [k_top=], [k_bot=], [k_sides=], [splinesteps=], [debug=], [convexity=],...) [ATTACHMENTS];
 // Usage: as a function
 //   vnf = rounded_prism(bottom, [top], [height=|h=|length=|l=], [joint_top=], [joint_bot=], [joint_sides=], [k=], [k_top=], [k_bot=], [k_sides=], [splinesteps=], [debug=]);
 // Description:
 //   Construct a generalized prism with continuous curvature rounding.  You supply the polygons for the top and bottom of the prism.  The only
 //   limitation is that joining the edges must produce a valid polyhedron with coplanar side faces.  You specify the rounding by giving
@@ -2250,14 +2277,17 @@
     [-r-eps,0],
     [-r-eps, r+3*eps],
     [r+eps, r+3*eps]
    ]);
 
 
 // Module: bent_cutout_mask()
+// Synopsis: Create a mask for making a round-edged cutout in a cylindrical shell.
+// Topics: Rounding, Offsets
+// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
 // Usage:
 //   bent_cutout_mask(r|radius, thickness, path);
 // Description:
 //   Creates a mask for cutting a round-edged hole out of a vertical cylindrical shell.  The specified radius
 //   is the center radius of the cylindrical shell.  The path needs to be sampled finely enough
 //   so that it can follow the curve of the cylinder.  The thickness may need to be slighly oversized to
 //   handle the faceting of the cylinder.  The path is wrapped around a cylinder, keeping the
@@ -2441,29 +2471,30 @@
 function bent_cutout_mask(r, thickness, path, radius, convexity=10) = no_function("bent_cutout_mask");
 module bent_cutout_mask(r, thickness, path, radius, convexity=10)
 {
   no_children($children);
   r = get_radius(r1=r, r2=radius);
   dummy1=assert(is_def(r) && r>0,"Radius of the cylinder to bend around must be positive");
   path2 = force_path(path);
-  dummy2=assert(is_path(path2,2),"Input path must be a 2D path");
-  assert(r-thickness>0, "Thickness too large for radius");
-  assert(thickness>0, "Thickness must be positive");
+  dummy2=assert(is_path(path2,2),"Input path must be a 2D path")
+         assert(r-thickness>0, "Thickness too large for radius")
+         assert(thickness>0, "Thickness must be positive");
   fixpath = clockwise_polygon(path2);
   curvepoints = arc(d=thickness, angle = [-180,0]);
   profiles = [for(pt=curvepoints) _cyl_hole(r+pt.x,apply(xscale((r+pt.x)/r), offset(fixpath,delta=thickness/2+pt.y,check_valid=false,closed=true)))];
   pathx = column(fixpath,0);
   minangle = (min(pathx)-thickness/2)*360/(2*PI*r);
   maxangle = (max(pathx)+thickness/2)*360/(2*PI*r);
   mindist = (r+thickness/2)/cos((maxangle-minangle)/2);
-  assert(maxangle-minangle<180,"Cutout angle span is too large.  Must be smaller than 180.");
+  dummy3 = assert(maxangle-minangle<180,"Cutout angle span is too large.  Must be smaller than 180.");
   zmean = mean(column(fixpath,1));
   innerzero = repeat([0,0,zmean], len(fixpath));
   outerpt = repeat( [1.5*mindist*cos((maxangle+minangle)/2),1.5*mindist*sin((maxangle+minangle)/2),zmean], len(fixpath));
-  vnf_polyhedron(vnf_vertex_array([innerzero, each profiles, outerpt],col_wrap=true),convexity=convexity);
+  default_tag("remove")
+    vnf_polyhedron(vnf_vertex_array([innerzero, each profiles, outerpt],col_wrap=true),convexity=convexity);
 }
 
 
 
 /*
 
 join_prism To Do List:
@@ -2474,14 +2505,17 @@
 Access to the derivative smoothing parameter?   
 
 */
 
 
 
 // Function&Module: join_prism()
+// Synopsis: Join an arbitrary prism to a plane, sphere, cylinder or another arbitrary prism with a fillet.
+// Topics: Rounding, Offsets
+// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
 // Usage: The two main forms with most common options
 //   join_prism(polygon, base, length=|height=|l=|h=, fillet=, [base_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];
 //   join_prism(polygon, base, aux=, fillet=, [base_T=], [aux_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];
 // Usage: As function
 //   vnf = join_prism( ... );
 // Description:
 //   This function creates a smooth fillet between one or both ends of an arbitrary prism and various other shapes: a plane, a sphere, a cylinder,
@@ -2912,37 +2946,37 @@
 //   tube(ir=30,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
 //   multmatrix(auxT)
 //     tube(ir=40,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
 // Example(3D,NoScales): Many of the preceeding examples feature a prism with a concave shape cross section.  Concave regions can limit the amount of rounding that is possible.  This occurs because the algorithm is not able to handle a fillet that intersects itself.  Fillets on a convex prism always grow larger as they move away from the prism, so they cannot self intersect.  This means that you can make the fillet as big as will fit on the base shape.  The fillet will fail to fit if the tangent plane to the base at the fillet distance from the prism fails to intersect the prism.  Here is an extreme example, almost the largest possible fillet to the convex elliptical convex prism.  
 //   ellipse = ellipse([17,10],$fn=164);  
 //   join_prism(ellipse,base="sphere",base_r=30, length=18,
 //              fillet=18, n=25, overlap=1);
-//   sphere(r=30,circum=true, $fn=96);
+//   spheroid(r=30,circum=true, $fn=96);
 // Example(3D,NoScales): This example shows a failed rounding attempt where the result is self-intersecting.  Using the `debug=true` option makes it possible to view the result to understand what went wrong.  Note that the concave corners have a crease where the fillet crosses itself.  The error message will advise you to decrease the size of the fillet.  You can also fix the problem by making your concave curves shallower.  
 //   flower = [for(theta=lerpn(0,360,180,endpoint=false))
 //             (15+2.5*sin(6*theta))*[cos(theta),sin(theta)]];
 //   join_prism(flower,base="cylinder",base_r=30, length=18,
 //              fillet=6, n=12, debug=true); 
 // Example(3D,NoScales): Your prism needs to be finely sampled enough to follow the contour of the base you are attaching it to.  If it is not, you get a result like this.  The fillet joints the prism smoothly, but makes a poor transition to the sphere. 
 //   sq = rect(15);
 //   join_prism(sq, base="sphere", base_r=25,
 //              length=18, fillet=4, n=12);
-//   sphere(r=25, circum=true, $fn=96);
+//   spheroid(r=25, circum=true, $fn=96);
 // Example(3D,NoScales): To fix the problem, you must subdivide the polygon that defines the prism.  But note that the join_prism method works poorly at sharp corners.
 //   sq = subdivide_path(rect(15),n=64);
 //   join_prism(sq, base="sphere", base_r=25,
 //              length=18, fillet=4, n=12);
-//   sphere(r=25, circum=true,$fn=96);
+//   spheroid(r=25, circum=true,$fn=96);
 // Example(3D,NoScales): In the previous example, a small rounding of the prism corners produces a nicer result.
 //   sq = subdivide_path(
 //          round_corners(rect(15),cut=.5,$fn=32),
 //          n=128);
 //   join_prism(sq, base="sphere", base_r=25,
 //              length=18, fillet=4, n=12);
-//   sphere(r=25, circum=true,$fn=96);
+//   spheroid(r=25, circum=true,$fn=96);
 // Example(3D,NoScales): The final option for specifying the base is to use an arbitrary prism, specified by a polygon.  Note that the base prism is oriented to the RIGHT, so the attached prism remains Z oriented.  
 //   ellipse = ellipse([17,10],$fn=164);  
 //   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,
 //              fillet=4, n=12);
 //   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);
 // Example(3D,NoScales): As usual, you can rotate around the attachment point using prism_end_T. 
 //   ellipse = ellipse([17,10],$fn=164);  
@@ -3020,32 +3054,32 @@
 // Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): It works the same way with the other shapes, but make sure you move the shapes far enough apart that there is room for a prism.  
 //   flower = [for(theta=lerpn(0,360,180,endpoint=false))
 //             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
 //   aux_T = up(85);
 //   base_T = xrot(5)*yrot(-12);
 //   join_prism(flower,base="cylinder",base_r=25, fillet=4, n=12,
 //              aux="sphere",aux_r=35,base_T=base_T, aux_T=aux_T);
-//   multmatrix(aux_T)sphere(35,circum=true);
+//   multmatrix(aux_T)spheroid(35,circum=true);
 //   multmatrix(base_T)xcyl(l=75,r=25,circum=true);
 // Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): Here we translate the sphere to the right and the prism goes with it
 //   flower = [for(theta=lerpn(0,360,180,endpoint=false))
 //             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
 //   aux_T = right(40)*up(85);
 //   join_prism(flower,base="cylinder",base_r=25, n=12,
 //              aux="sphere",aux_r=35, aux_T=aux_T, fillet=4);
-//   multmatrix(aux_T)sphere(35,circum=true);
+//   multmatrix(aux_T)spheroid(35,circum=true);
 //   xcyl(l=75,r=25,circum=true);
 // Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): This is the previous example with the prism_end_T transformation used to shift the far end of the prism away from the sphere center.  Note that prism_end_T can be any transformation, but it just acts on the location of the prism endpoint to shift the direction the prism points.  
 //   flower = [for(theta=lerpn(0,360,180,endpoint=false))
 //             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
 //   aux_T = right(40)*up(85);
 //   join_prism(flower,base="cylinder",base_r=25,
 //              prism_end_T=left(4), fillet=3, n=12, 
 //              aux="sphere",aux_r=35, aux_T=aux_T); 
-//   multmatrix(aux_T)sphere(35,circum=true);
+//   multmatrix(aux_T)spheroid(35,circum=true);
 //   xcyl(l=75,r=25,circum=true);
 // Example(3D,NoScales,VPR=[96.9,0,157.5],VPT=[-7.77616,-2.272,37.9424],VPD=366.527): Here the base is a cylinder but the auxilary object is a generic prism, and the joiner prism has a scale factor.  
 //   flower = [for(theta=lerpn(0,360,180,endpoint=false))
 //             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
 //   aux_T = up(85)*zrot(-75);
 //   ellipse = ellipse([17,10],$fn=164);  
 //   join_prism(flower,base="cylinder",base_r=25,
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/screw_drive.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/screw_drive.scad`

 * *Files 27% similar despite different names*

```diff
@@ -5,18 +5,24 @@
 //   include <BOSL2/std.scad>
 //   include <BOSL2/screw_drive.scad>
 // FileGroup: Threaded Parts
 // FileSummary: Masks for Phillips, Torx and square (Robertson) driver holes.
 //////////////////////////////////////////////////////////////////////
 
 
+include <structs.scad>
+
 // Section: Phillips Drive
 
 // Module: phillips_mask()
-// Usage: phillips_mask(size) [ATTACHMENTS];
+// Synopsis: Creates a mask for a Philips screw drive.
+// Topics: Screws, Masks
+// See Also: hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask(), robertson_mask()
+// Usage:
+//   phillips_mask(size) [ATTACHMENTS];
 // Description:
 //   Creates a mask for creating a Phillips drive recess given the Phillips size.  Each mask can
 //   be lowered to different depths to create different sizes of recess.  
 // Arguments:
 //   size = The size of the bit as an integer or string.  "#0", "#1", "#2", "#3", or "#4"
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
@@ -34,15 +40,15 @@
 //   https://www.fasteners.eu/tech-info/ISO/4757/
 
 function _phillips_shaft(x) = [3,4.5,6,8,10][x];
 function _ph_bot_angle() = 28.0;
 function _ph_side_angle() = 26.5;
 
 module phillips_mask(size="#2", $fn=36, anchor=BOTTOM, spin=0, orient=UP) {
-    assert(in_list(size,["#0","#1","#2","#3","#4",0,1,2,3,4]));
+    dummy = assert(in_list(size,["#0","#1","#2","#3","#4",0,1,2,3,4]));
     num = is_num(size) ? size : ord(size[1]) - ord("0");
     shaft = _phillips_shaft(num);
     b =     [0.61, 0.97, 1.47, 2.41, 3.48][num];
     e =     [0.31, 0.435, 0.815, 2.005, 2.415][num];
     g =     [0.81, 1.27, 2.29, 3.81, 5.08][num];
     alpha = [ 136,  138,  140,  146,  153][num];
     beta  = [7.00, 7.00, 5.75, 5.75, 7.00][num];
@@ -76,14 +82,17 @@
         children();
     }
 }
 
 
 
 // Function: phillips_depth()
+// Synopsis: Returns the depth a phillips recess needs to be for a given diameter.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask()
 // Usage:
 //   depth = phillips_depth(size, d);
 // Description:
 //   Returns the depth of the Phillips recess required to produce the specified diameter, or
 //   undef if not possible.
 // Arguments:
 //   size = size as a number or text string like "#2"
@@ -98,14 +107,17 @@
         h2 = adj_ang_to_opp((shaft-g)/2, 90-_ph_side_angle())   // height of larger cone
     )
     d>=shaft || d<g ? undef :
     (d-g) / 2 / tan(_ph_side_angle()) + h1;
 
 
 // Function: phillips_diam()
+// Synopsis: Returns the diameter of a phillips recess of a given depth.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask()
 // Usage:
 //   diam = phillips_diam(size, depth);
 // Description:
 //   Returns the diameter at the top of the Phillips recess when constructed at the specified depth,
 //   or undef if that depth is not valid.  
 // Arguments:
 //   size = size as number or text string like "#2"
@@ -119,60 +131,86 @@
         h1 = adj_ang_to_opp(g/2, _ph_bot_angle()),   // height of the small conical tip
         h2 = adj_ang_to_opp((shaft-g)/2, 90-_ph_side_angle())   // height of larger cone
     )
     depth<h1 || depth>= h1+h2 ? undef :
     2 * tan(_ph_side_angle())*(depth-h1) + g;
 
 
+// Section: Hex drive
 
-// Section: Torx Drive
+// Module: hex_drive_mask()
+// Synopsis: Creates a mask for a hex drive recess.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), robertson_mask()
+// Usage:
+//   hex_drive_mask(size, length, [anchor], [spin], [orient], [$slop]) [ATTACHMENTS];
+// Description:
+//   Creates a mask for hex drive.  Note that the hex recess specs requires
+//   a slightly oversized recess.  You can use $slop to increase the size by 
+//   `2 * $slop` if necessary.  
+// 
+module hex_drive_mask(size,length,l,h,height,anchor,spin,orient)
+{
+   length = one_defined([length,height,l,h],"length,height,l,h");
+   realsize = 1.0072*size + 0.0341 + 2 * get_slop();  // Formula emperically determined from ISO standard
+   linear_sweep(height=length,hexagon(id=realsize),anchor=anchor,spin=spin,orient=orient) children();
+}
+function hex_drive_mask(size,length,l,h,height,anchor,spin,orient) = no_function("hex_drive_mask");
 
 
+// Section: Torx Drive
 
 // Module: torx_mask()
+// Synopsis: Creates a mask for a torx drive recess.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), robertson_mask()
 // Usage:
 //   torx_mask(size, l, [center]) [ATTACHMENTS];
 // Description: Creates a torx bit tip.
 // Arguments:
 //   size = Torx size.
 //   l = Length of bit.
-//   center = If true, centers bit vertically.
+//   center = If true, centers mask vertically.
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Examples:
 //   torx_mask(size=30, l=10, $fa=1, $fs=1);
 module torx_mask(size, l=5, center, anchor, spin=0, orient=UP) {
-    anchor = get_anchor(anchor, center, BOT, BOT);
     od = torx_diam(size);
+    anchor = get_anchor(anchor, center, BOT, BOT);
     attachable(anchor,spin,orient, d=od, l=l) {
         linear_extrude(height=l, convexity=4, center=true) {
             torx_mask2d(size);
         }
         children();
     }
 }
 
 
 
 // Module: torx_mask2d()
+// Synopsis: Creates the 2D cross section for a torx drive recess.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info(), robertson_mask()
 // Usage:
 //   torx_mask2d(size);
 // Description: Creates a torx bit 2D profile.
 // Arguments:
 //   size = Torx size.
 // Example(2D):
 //   torx_mask2d(size=30, $fa=1, $fs=1);
 module torx_mask2d(size) {
     no_children($children);
-    od = torx_diam(size);
-    id = _torx_inner_diam(size);
-    tip = _torx_tip_radius(size);
-    rounding = _torx_rounding_radius(size);
+    info = torx_info(size);
+    od = info[0];
+    id = info[1];
+    tip = info[3];
+    rounding = info[4];
     base = od - 2*tip;
     $fn = quantup(segs(od/2),12);
     difference() {
         union() {
             circle(d=base);
             zrot_copies(n=2) {
                 hull() {
@@ -191,170 +229,118 @@
                 }
             }
         }
     }
 }
 
 
+// Function: torx_info()
+// Synopsis: Returns the dimensions of a torx drive.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()
+// Usage:
+//   info = torx_info(size);
+// Description:
+//   Get the typical dimensional info for a given Torx size.
+//   Returns a list containing, in order:
+//   - Outer Diameter
+//   - Inner Diameter
+//   - Drive Hole Depth
+//   - External Tip Rounding Radius
+//   - Inner Rounding Radius
+// Arguments:
+//   size = Torx size.
+function torx_info(size) =
+    let( 
+        info_arr = [      // Depth is from metric socket head screws, ISO 14583
+            //T#     OD     ID     H        Re     Ri
+            [  1, [  0.90,  0.65,  0.40,  0.059, 0.201]],  // depth interpolated
+            [  2, [  1.00,  0.73,  0.44,  0.069, 0.224]],  // depth interpolated
+            [  3, [  1.20,  0.87,  0.53,  0.081, 0.266]],  // depth interpolated
+            [  4, [  1.35,  0.98,  0.59,  0.090, 0.308]],  // depth interpolated
+            [  5, [  1.48,  1.08,  0.65,  0.109, 0.330]],  // depth interpolated
+            [  6, [  1.75,  1.27,  0.775, 0.132, 0.383]],
+            [  7, [  2.08,  1.50,  0.886, 0.161, 0.446]],  // depth interpolated
+            [  8, [  2.40,  1.75,  1.0,   0.190, 0.510]],
+            [  9, [  2.58,  1.87,  1.078, 0.207, 0.554]],  // depth interpolated
+            [ 10, [  2.80,  2.05,  1.142, 0.229, 0.598]],
+            [ 15, [  3.35,  2.40,  1.2,   0.267, 0.716]],  // depth interpolated
+            [ 20, [  3.95,  2.85,  1.4,   0.305, 0.859]],  // depth interpolated
+            [ 25, [  4.50,  3.25,  1.61,  0.375, 0.920]],  
+            [ 27, [  5.07,  3.65,  1.84,  0.390, 1.108]],
+            [ 30, [  5.60,  4.05,  2.22,  0.451, 1.194]],
+            [ 40, [  6.75,  4.85,  2.63,  0.546, 1.428]],
+            [ 45, [  7.93,  5.64,  3.115, 0.574, 1.796]],
+            [ 50, [  8.95,  6.45,  3.82,  0.775, 1.816]],
+            [ 55, [ 11.35,  8.05,  5.015, 0.867, 2.667]],
+            [ 60, [ 13.45,  9.60,  5.805, 1.067, 2.883]],
+            [ 70, [ 15.70, 11.20,  6.815, 1.194, 3.477]],
+            [ 80, [ 17.75, 12.80,  7.75,  1.526, 3.627]],
+            [ 90, [ 20.20, 14.40,  8.945, 1.530, 4.468]],
+            [100, [ 22.40, 16.00, 10.79,  1.720, 4.925]],
+        ],
+        found = struct_val(info_arr,size)
+    )
+    assert(found, str("Unsupported Torx size, ",size))
+    found;
+
+
 // Function: torx_diam()
+// Synopsis: Returns the diameter of a torx drive.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()
 // Usage:
 //   diam = torx_diam(size);
 // Description: Get the typical outer diameter of Torx profile.
 // Arguments:
 //   size = Torx size.
-function torx_diam(size) = lookup(size, [
-    [  6,  1.75],
-    [  8,  2.40],
-    [ 10,  2.80],
-    [ 15,  3.35],
-    [ 20,  3.95],
-    [ 25,  4.50],
-    [ 30,  5.60],
-    [ 40,  6.75],
-    [ 45,  7.93],
-    [ 50,  8.95],
-    [ 55, 11.35],
-    [ 60, 13.45],
-    [ 70, 15.70],
-    [ 80, 17.75],
-    [ 90, 20.20],
-    [100, 22.40]
-]);
- 
-
-/// Internal Function: torx_inner_diam()
-/// Usage:
-///   diam = torx_inner_diam(size);
-/// Description: Get typical inner diameter of Torx profile.
-/// Arguments:
-///   size = Torx size.
-function _torx_inner_diam(size) = lookup(size, [
-    [  6,  1.27],
-    [  8,  1.75],
-    [ 10,  2.05],
-    [ 15,  2.40],
-    [ 20,  2.85],
-    [ 25,  3.25],
-    [ 30,  4.05],
-    [ 40,  4.85],
-    [ 45,  5.64],
-    [ 50,  6.45],
-    [ 55,  8.05],
-    [ 60,  9.60],
-    [ 70, 11.20],
-    [ 80, 12.80],
-    [ 90, 14.40],
-    [100, 16.00]
-]);
- 
+function torx_diam(size) = torx_info(size)[0];
+
 
 // Function: torx_depth()
+// Synopsis: Returns the typical depth of a torx drive recess.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()
 // Usage:
 //   depth = torx_depth(size);
 // Description: Gets typical drive hole depth.
 // Arguments:
 //   size = Torx size.
-function torx_depth(size) = lookup(size, [
-    [  6,  1.82],
-    [  8,  3.05],
-    [ 10,  3.56],
-    [ 15,  3.81],
-    [ 20,  4.07],
-    [ 25,  4.45],
-    [ 30,  4.95],
-    [ 40,  5.59],
-    [ 45,  6.22],
-    [ 50,  6.48],
-    [ 55,  6.73],
-    [ 60,  8.17],
-    [ 70,  8.96],
-    [ 80,  9.90],
-    [ 90, 10.56],
-    [100, 11.35]
-]);
- 
-
-/// Internal Function: torx_tip_radius()
-/// Usage:
-///   rad = torx_tip_radius(size);
-/// Description: Gets minor rounding radius of Torx profile.
-/// Arguments:
-///   size = Torx size.
-function _torx_tip_radius(size) = lookup(size, [
-    [  6, 0.132],
-    [  8, 0.190],
-    [ 10, 0.229],
-    [ 15, 0.267],
-    [ 20, 0.305],
-    [ 25, 0.375],
-    [ 30, 0.451],
-    [ 40, 0.546],
-    [ 45, 0.574],
-    [ 50, 0.775],
-    [ 55, 0.867],
-    [ 60, 1.067],
-    [ 70, 1.194],
-    [ 80, 1.526],
-    [ 90, 1.530],
-    [100, 1.720]
-]);
-
-
-/// Internal Function: torx_rounding_radius()
-/// Usage:
-///   rad = torx_rounding_radius(size);
-/// Description: Gets major rounding radius of Torx profile.
-/// Arguments:
-///   size = Torx size.
-function _torx_rounding_radius(size) = lookup(size, [
-    [  6, 0.383],
-    [  8, 0.510],
-    [ 10, 0.598],
-    [ 15, 0.716],
-    [ 20, 0.859],
-    [ 25, 0.920],
-    [ 30, 1.194],
-    [ 40, 1.428],
-    [ 45, 1.796],
-    [ 50, 1.816],
-    [ 55, 2.667],
-    [ 60, 2.883],
-    [ 70, 3.477],
-    [ 80, 3.627],
-    [ 90, 4.468],
-    [100, 4.925]
-]);
-
+function torx_depth(size) = torx_info(size)[2];
 
 
 
 // Section: Robertson/Square Drives
 
 // Module: robertson_mask()
+// Synopsis: Creates a mask for a Robertson/Square drive recess.
+// Topics: Screws, Masks
+// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info(), robertson_mask()
 // Usage:
-//   robertson_mask(size, [extra]);
+//   robertson_mask(size, [extra], [ang], [$slop=]);
 // Description:
 //   Creates a mask for creating a Robertson/Square drive recess given the drive size as an integer.
 //   The width of the recess will be oversized by `2 * $slop`.  Note that this model is based
 //   on an incomplete spec.   https://www.aspenfasteners.com/content/pdf/square_drive_specification.pdf
 //   We determined the angle by doing print tests on a Prusa MK3S with $slop set to 0.05.
 // Arguments:
 //   size = The size of the square drive, as an integer from 0 to 4.
 //   extra = Extra length of drive mask to create.
 //   ang = taper angle of each face.  Default: 2.5
+//   ---
 //   $slop = enlarge recess by this twice amount.  Default: 0
 // Example:
 //   robertson_mask(size=2);
 // Example:
 //   difference() {
 //       cyl(d1=2, d2=8, h=4, anchor=TOP);
 //       robertson_mask(size=2);
 //   }
 module robertson_mask(size, extra=1, ang=2.5) {
-    assert(is_int(size) && size>=0 && size<=4);
+    dummy=assert(is_int(size) && size>=0 && size<=4);
     Mmin = [0.0696, 0.0900, 0.1110, 0.1315, 0.1895][size];
     Mmax = [0.0710, 0.0910, 0.1126, 0.1330, 0.1910][size];
     M = (Mmin + Mmax) / 2 * INCH;
     Tmin = [0.063, 0.105, 0.119, 0.155, 0.191][size];
     Tmax = [0.073, 0.113, 0.140, 0.165, 0.201][size];
     T = (Tmin + Tmax) / 2 * INCH;
     Fmin = [0.032, 0.057, 0.065, 0.085, 0.090][size];
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/shapes2d.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/shapes2d.scad`

 * *Files 9% similar despite different names*

```diff
@@ -17,22 +17,23 @@
 
 use <builtins.scad>
 
 
 // Section: 2D Primitives
 
 // Function&Module: square()
+// Synopsis: Creates a 2D square or rectangle.
 // Topics: Shapes (2D), Path Generators (2D)
+// See Also: rect()
 // Usage: As a Module
 //   square(size, [center], ...);
 // Usage: With Attachments
 //   square(size, [center], ...) [ATTACHMENTS];
 // Usage: As a Function
 //   path = square(size, [center], ...);
-// See Also: rect()
 // Description:
 //   When called as the builtin module, creates a 2D square or rectangle of the given size.
 //   When called as a function, returns a 2D path/list of points for a square/rectangle of the given size.
 // Arguments:
 //   size = The size of the square to create.  If given as a scalar, both X and Y will be the same size.
 //   center = If given and true, overrides `anchor` to be `CENTER`.  If given and false, overrides `anchor` to be `FRONT+LEFT`.
 //   ---
@@ -67,20 +68,21 @@
         children();
     }
 }
 
 
 
 // Function&Module: rect()
+// Synopsis: Creates a 2d rectangle with optional corner rounding.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: square()
 // Usage: As Module
 //   rect(size, [rounding], [chamfer], ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = rect(size, [rounding], [chamfer], ...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: square()
 // Description:
 //   When called as a module, creates a 2D rectangle of the given size, with optional rounding or chamfering.
 //   When called as a function, returns a 2D path/list of points for a square/rectangle of the given size.
 // Arguments:
 //   size = The size of the rectangle to create.  If given as a scalar, both X and Y will be the same size.
 //   ---
 //   rounding = The rounding radius for the corners.  If negative, produces external roundover spikes on the X axis. If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-]. Default: 0 (no rounding)
@@ -108,113 +110,121 @@
 // Example(2D): Default "box" Anchors
 //   color("red") rect([40,30]);
 //   rect([40,30], rounding=10)
 //       show_anchors();
 // Example(2D): "perim" Anchors
 //   rect([40,30], rounding=10, atype="perim")
 //       show_anchors();
+// Example(2D): "perim" Anchors
+//   rect([40,30], rounding=[-10,-8,-3,-7], atype="perim")
+//       show_anchors();
 // Example(2D): Mixed Chamferring and Rounding
 //   rect([40,30],rounding=[5,0,10,0],chamfer=[0,8,0,15],$fa=1,$fs=1);
 // Example(2D): Called as Function
 //   path = rect([40,30], chamfer=5, anchor=FRONT, spin=30);
 //   stroke(path, closed=true);
 //   move_copies(path) color("blue") circle(d=2,$fn=8);
 module rect(size=1, rounding=0, atype="box", chamfer=0, anchor=CENTER, spin=0) {
     errchk = assert(in_list(atype, ["box", "perim"]));
-    size = is_num(size)? [size,size] : point2d(size);
+    size = force_list(size,2);
     if (rounding==0 && chamfer==0) {
         attachable(anchor, spin, two_d=true, size=size) {
             square(size, center=true);
             children();
         }
     } else {
-        pts = rect(size=size, rounding=rounding, chamfer=chamfer);
-        if (atype == "perim") {
-            attachable(anchor, spin, two_d=true, path=pts) {
+        pts_over = rect(size=size, rounding=rounding, chamfer=chamfer, atype=atype, _return_override=true);
+        pts = pts_over[0];
+        override = pts_over[1];
+        attachable(anchor, spin, two_d=true, size=size,override=override) {
                 polygon(pts);
                 children();
-            }
-        } else {
-            attachable(anchor, spin, two_d=true, size=size) {
-                polygon(pts);
-                children();
-            }
         }
     }
 }
 
 
 
-function rect(size=1, rounding=0, chamfer=0, atype="box", anchor=CENTER, spin=0) =
-    assert(is_num(size)     || is_vector(size))
-    assert(is_num(chamfer)  || len(chamfer)==4)
-    assert(is_num(rounding) || len(rounding)==4)
+function rect(size=1, rounding=0, chamfer=0, atype="box", anchor=CENTER, spin=0, _return_override) =
+    assert(is_num(size)     || is_vector(size,2))
+    assert(is_num(chamfer)  || is_vector(chamfer,4))
+    assert(is_num(rounding) || is_vector(rounding,4))
     assert(in_list(atype, ["box", "perim"]))
     let(
-        anchor=point2d(anchor),
-        size = is_num(size)? [size,size] : point2d(size),
-        complex = rounding!=0 || chamfer!=0
-    )
-    (rounding==0 && chamfer==0)? let(
-        path = [
-            [ size.x/2, -size.y/2],
-            [-size.x/2, -size.y/2],
-            [-size.x/2,  size.y/2],
-            [ size.x/2,  size.y/2] 
-        ]
+        anchor=_force_anchor_2d(anchor),
+        size = force_list(size,2),
+        chamfer = force_list(chamfer,4), 
+        rounding = force_list(rounding,4)
     )
-    rot(spin, p=move(-v_mul(anchor,size/2), p=path)) :
+    all_zero(concat(chamfer,rounding),0) ?
+        let(
+             path = [
+                     [ size.x/2, -size.y/2],
+                     [-size.x/2, -size.y/2],
+                     [-size.x/2,  size.y/2],
+                     [ size.x/2,  size.y/2] 
+                    ]
+        )
+        rot(spin, p=move(-v_mul(anchor,size/2), p=path))
+    :
+    assert(all_zero(v_mul(chamfer,rounding),0), "Cannot specify chamfer and rounding at the same corner")
     let(
-        chamfer = is_list(chamfer)? chamfer : [for (i=[0:3]) chamfer],
-        rounding = is_list(rounding)? rounding : [for (i=[0:3]) rounding],
         quadorder = [3,2,1,0],
         quadpos = [[1,1],[-1,1],[-1,-1],[1,-1]],
         eps = 1e-9,
         insets = [for (i=[0:3]) abs(chamfer[i])>=eps? chamfer[i] : abs(rounding[i])>=eps? rounding[i] : 0],
         insets_x = max(insets[0]+insets[1],insets[2]+insets[3]),
         insets_y = max(insets[0]+insets[3],insets[1]+insets[2])
     )
     assert(insets_x <= size.x, "Requested roundings and/or chamfers exceed the rect width.")
     assert(insets_y <= size.y, "Requested roundings and/or chamfers exceed the rect height.")
     let(
-        path = [
+        corners = [
             for(i = [0:3])
             let(
                 quad = quadorder[i],
                 qinset = insets[quad],
                 qpos = quadpos[quad],
                 qchamf = chamfer[quad],
                 qround = rounding[quad],
                 cverts = quant(segs(abs(qinset)),4)/4,
                 step = 90/cverts,
                 cp = v_mul(size/2-[qinset,abs(qinset)], qpos),
                 qpts = abs(qchamf) >= eps? [[0,abs(qinset)], [qinset,0]] :
                     abs(qround) >= eps? [for (j=[0:1:cverts]) let(a=90-j*step) v_mul(polar_to_xy(abs(qinset),a),[sign(qinset),1])] :
                     [[0,0]],
                 qfpts = [for (p=qpts) v_mul(p,qpos)],
-                qrpts = qpos.x*qpos.y < 0? reverse(qfpts) : qfpts
-            )
-            each move(cp, p=qrpts)
-        ]
-    ) complex && atype=="perim"?
-        reorient(anchor,spin, two_d=true, path=path, p=path) :
-        reorient(anchor,spin, two_d=true, size=size, p=path);
+                qrpts = qpos.x*qpos.y < 0? reverse(qfpts) : qfpts,
+                cornerpt = atype=="box" || (qround==0 && qchamf==0) ? undef
+                         : qround<0 || qchamf<0 ? [[0,-qpos.y*min(qround,qchamf)]]
+                         : [for(seg=pair(qrpts)) let(isect=line_intersection(seg, [[0,0],qpos],SEGMENT,LINE)) if (is_def(isect) && isect!=seg[0]) isect]
+              )
+            assert(is_undef(cornerpt) || len(cornerpt)==1,"Cannot find corner point to anchor")
+            [move(cp, p=qrpts), is_undef(cornerpt)? undef : move(cp,p=cornerpt[0])]
+        ],
+        path = flatten(column(corners,0)),
+        override = [for(i=[0:3])
+                      let(quad=quadorder[i])
+                      if (is_def(corners[i][1])) [quadpos[quad], [corners[i][1], min(chamfer[quad],rounding[quad])<0 ? [quadpos[quad].x,0] : undef]]]
+      ) _return_override ? [reorient(anchor,spin, two_d=true, size=size, p=path, override=override), override]
+                       : reorient(anchor,spin, two_d=true, size=size, p=path, override=override);
 
 
 // Function&Module: circle()
+// Synopsis: Creates the approximation of a circle.
 // Topics: Shapes (2D), Path Generators (2D)
+// See Also: ellipse(), circle_2tangents(), circle_3points()
 // Usage: As a Module
 //   circle(r|d=, ...) [ATTACHMENTS];
 //   circle(points=) [ATTACHMENTS];
 //   circle(r|d=, corner=) [ATTACHMENTS];
 // Usage: As a Function
 //   path = circle(r|d=, ...);
 //   path = circle(points=);
 //   path = circle(r|d=, corner=);
-// See Also: ellipse(), circle_2tangents(), circle_3points()
 // Description:
 //   When called as the builtin module, creates a 2D polygon that approximates a circle of the given size.
 //   When called as a function, returns a 2D list of points (path) for a polygon that approximates a circle of the given size.
 //   If `corner=` is given three 2D points, centers the circle so that it will be tangent to both segments of the path, on the inside corner.
 //   If `points=` is given three 2D points, centers and sizes the circle so that it passes through all three points.
 // Arguments:
 //   r = The radius of the circle to create.
@@ -300,32 +310,36 @@
         }
     }
 }
 
 
 
 // Function&Module: ellipse()
-// Usage: As a Module
-//   ellipse(r|d=, [realign=], [circum=], ...) [ATTACHMENTS];
-// Usage: As a Function
-//   path = ellipse(r|d=, [realign=], [circum=], ...);
+// Synopsis: Creates the approximation of an ellipse or a circle.
 // Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
 // See Also: circle(), circle_2tangents(), circle_3points()
+// Usage: As a Module
+//   ellipse(r|d=, [realign=], [circum=], [uniform=], ...) [ATTACHMENTS];
+// Usage: As a Function
+//   path = ellipse(r|d=, [realign=], [circum=], [uniform=], ...);
 // Description:
 //   When called as a module, creates a 2D polygon that approximates a circle or ellipse of the given size.
 //   When called as a function, returns a 2D list of points (path) for a polygon that approximates a circle or ellipse of the given size.
 //   By default the point list or shape is the same as the one you would get by scaling the output of {{circle()}}, but with this module your
 //   attachments to the ellipse will retain their dimensions, whereas scaling a circle with attachments will also scale the attachments.
-//   If you set unifom to true then you will get a polygon with congruent sides whose vertices lie on the ellipse.  
+//   If you set `uniform` to true then you will get a polygon with congruent sides whose vertices lie on the ellipse.  The `circum` option
+//   requests a polygon that circumscribes the requested ellipse (so the specified ellipse will fit into the resulting polygon).  Note that
+//   you cannot gives `circum=true` and `uniform=true`.  
 // Arguments:
 //   r = Radius of the circle or pair of semiaxes of ellipse 
 //   ---
 //   d = Diameter of the circle or a pair giving the full X and Y axis lengths.  
 //   realign = If false starts the approximate ellipse with a point on the X+ axis.  If true the midpoint of a side is on the X+ axis and the first point of the polygon is below the X+ axis.  This can result in a very different polygon when $fn is small.  Default: false
-//   circum = If true, the polygon that approximates the circle will be upsized slightly to circumscribe the theoretical circle.  If false, it inscribes the theoretical circle.  Default: false
+//   uniform = If true, the polygon that approximates the circle will have segments of equal length.  Only works if `circum=false`.  Default: false
+//   circum = If true, the polygon that approximates the circle will be upsized slightly to circumscribe the theoretical circle.  If false, it inscribes the theoretical circle.  If this is true then `uniform` must be false.  Default: false
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 // Example(2D): By Radius
 //   ellipse(r=25);
 // Example(2D): By Diameter
 //   ellipse(d=50);
 // Example(2D): Anchoring
@@ -480,20 +494,21 @@
         pts = [for (i=[0:1:sides-1]) let(a=360-offset-i*360/sides) [rx*cos(a), ry*sin(a)]]
     ) reorient(anchor,spin, two_d=true, r=[rx,ry], p=pts);
 
 
 // Section: Polygons
 
 // Function&Module: regular_ngon()
+// Synopsis: Creates a regular N-sided polygon.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: debug_polygon(), circle(), pentagon(), hexagon(), octagon(), ellipse(), star()
 // Usage:
 //   regular_ngon(n, r|d=|or=|od=, [realign=]) [ATTACHMENTS];
 //   regular_ngon(n, ir=|id=, [realign=]) [ATTACHMENTS];
 //   regular_ngon(n, side=, [realign=]) [ATTACHMENTS];
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), pentagon(), hexagon(), octagon(), ellipse(), star()
 // Description:
 //   When called as a function, returns a 2D path for a regular N-sided polygon.
 //   When called as a module, creates a 2D regular N-sided polygon.
 // Arguments:
 //   n = The number of sides.
 //   r/or = Outside radius, at points.
 //   ---
@@ -529,25 +544,27 @@
 //       attach("side0", FWD) color("blue")
 //           stroke([[0,0],[0,7]], endcap2="arrow2");
 // Example(2D): Rounded
 //   regular_ngon(n=5, od=100, rounding=20, $fn=20);
 // Example(2D): Called as Function
 //   stroke(closed=true, regular_ngon(n=6, or=30));
 function regular_ngon(n=6, r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0, _mat, _anchs) =
+    assert(is_int(n) && n>=3)
     assert(is_undef(align_tip) || is_vector(align_tip))
     assert(is_undef(align_side) || is_vector(align_side))
     assert(is_undef(align_tip) || is_undef(align_side), "Can only specify one of align_tip and align-side")
     let(
         sc = 1/cos(180/n),
         ir = is_finite(ir)? ir*sc : undef,
         id = is_finite(id)? id*sc : undef,
         side = is_finite(side)? side/2/sin(180/n) : undef,
         r = get_radius(r1=ir, r2=or, r=r, d1=id, d2=od, d=d, dflt=side)
     )
     assert(!is_undef(r), "regular_ngon(): need to specify one of r, d, or, od, ir, id, side.")
+    assert(all_positive([r]), "polygon size must be a positive value")
     let(
         inset = opp_ang_to_hyp(rounding, (180-360/n)/2),
         mat = !is_undef(_mat) ? _mat :
             ( realign? zrot(-180/n) : ident(4)) * (
                 !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :
                 !is_undef(align_side)? rot(from=RIGHT, to=point2d(align_side)) * zrot(180/n) :
                 1
@@ -587,15 +604,16 @@
 
 module regular_ngon(n=6, r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0) {
     sc = 1/cos(180/n);
     ir = is_finite(ir)? ir*sc : undef;
     id = is_finite(id)? id*sc : undef;
     side = is_finite(side)? side/2/sin(180/n) : undef;
     r = get_radius(r1=ir, r2=or, r=r, d1=id, d2=od, d=d, dflt=side);
-    check = assert(!is_undef(r), "regular_ngon(): need to specify one of r, d, or, od, ir, id, side.");
+    check = assert(!is_undef(r), "regular_ngon(): need to specify one of r, d, or, od, ir, id, side.")
+            assert(all_positive([r]), "polygon size must be a positive value");
     mat = ( realign? zrot(-180/n) : ident(4) ) * (
             !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :
             !is_undef(align_side)? rot(from=RIGHT, to=point2d(align_side)) * zrot(180/n) :
             1
         );
     inset = opp_ang_to_hyp(rounding, (180-360/n)/2);
     anchors = [
@@ -616,22 +634,23 @@
         polygon(path);
         children();
     }
 }
 
 
 // Function&Module: pentagon()
+// Synopsis: Creates a regular pentagon.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), regular_ngon(), hexagon(), octagon(), ellipse(), star()
 // Usage:
 //   pentagon(or|od=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];
 //   pentagon(ir=|id=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];
 //   pentagon(side=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];
 // Usage: as function
 //   path = pentagon(...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), regular_ngon(), hexagon(), octagon(), ellipse(), star()
 // Description:
 //   When called as a function, returns a 2D path for a regular pentagon.
 //   When called as a module, creates a 2D regular pentagon.
 // Arguments:
 //   r/or = Outside radius, at points.
 //   ---
 //   d/od = Outside diameter, at points.
@@ -674,23 +693,24 @@
 
 
 module pentagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)
     regular_ngon(n=5, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();
 
 
 // Function&Module: hexagon()
+// Synopsis: Creates a regular hexagon.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), regular_ngon(), pentagon(), octagon(), ellipse(), star()
 // Usage: As Module
 //   hexagon(r/or, [realign=], <align_tip=|align_side=>, [rounding=], ...) [ATTACHMENTS];
 //   hexagon(d=/od=, ...) [ATTACHMENTS];
 //   hexagon(ir=/id=, ...) [ATTACHMENTS];
 //   hexagon(side=, ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = hexagon(...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), regular_ngon(), pentagon(), octagon(), ellipse(), star()
 // Description:
 //   When called as a function, returns a 2D path for a regular hexagon.
 //   When called as a module, creates a 2D regular hexagon.
 // Arguments:
 //   r/or = Outside radius, at points.
 //   ---
 //   d/od = Outside diameter, at points.
@@ -733,23 +753,24 @@
 
 
 module hexagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)
     regular_ngon(n=6, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();
 
 
 // Function&Module: octagon()
+// Synopsis: Creates a regular octagon.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), regular_ngon(), pentagon(), hexagon(), ellipse(), star()
 // Usage: As Module
 //   octagon(r/or, [realign=], [align_tip=|align_side=], [rounding=], ...) [ATTACHMENTS];
 //   octagon(d=/od=, ...) [ATTACHMENTS];
 //   octagon(ir=/id=, ...) [ATTACHMENTS];
 //   octagon(side=, ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = octagon(...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), regular_ngon(), pentagon(), hexagon(), ellipse(), star()
 // Description:
 //   When called as a function, returns a 2D path for a regular octagon.
 //   When called as a module, creates a 2D regular octagon.
 // Arguments:
 //   r/or = Outside radius, at points.
 //   d/od = Outside diameter, at points.
 //   ir = Inside radius, at center of sides.
@@ -791,125 +812,189 @@
 
 
 module octagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)
     regular_ngon(n=8, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();
 
 
 // Function&Module: right_triangle()
+// Synopsis: Creates a right triangle.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: square(), rect(), regular_ngon(), pentagon(), hexagon(), octagon(), star()
 // Usage: As Module
 //   right_triangle(size, [center], ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = right_triangle(size, [center], ...);
 // Description:
 //   Creates a right triangle with the Hypotenuse in the X+Y+ quadrant.
 // Arguments:
 //   size = The width and length of the right triangle, given as a scalar or an XY vector.
 //   center = If true, forces `anchor=CENTER`.  If false, forces `anchor=[-1,-1]`.  Default: undef (use `anchor=`)
 //   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+// Extra Anchors:
+//   hypot = Center of angled side, perpendicular to that side.
 // Example(2D):
 //   right_triangle([40,30]);
 // Example(2D): With `center=true`
 //   right_triangle([40,30], center=true);
-// Example(2D): Anchors
-//   right_triangle([40,30])
-//       show_anchors();
+// Example(2D): Standard Anchors
+//   right_triangle([80,30], center=true)
+//       show_anchors(custom=false);
+//   color([0.5,0.5,0.5,0.1])
+//       square([80,30], center=true);
+// Example(2D): Named Anchors
+//   right_triangle([80,30], center=true)
+//       show_anchors(std=false);
 function right_triangle(size=[1,1], center, anchor, spin=0) =
     let(
         size = is_num(size)? [size,size] : size,
         anchor = get_anchor(anchor, center, [-1,-1], [-1,-1])
     )
     assert(is_vector(size,2))
     assert(min(size)>0, "Must give positive size")
     let(
-        path = [ [size.x/2,-size.y/2], [-size.x/2,-size.y/2], [-size.x/2,size.y/2] ]
-    ) reorient(anchor,spin, two_d=true, size=[size.x,size.y], size2=0, shift=-size.x/2, p=path);
+        path = [ [size.x/2,-size.y/2], [-size.x/2,-size.y/2], [-size.x/2,size.y/2] ],
+        anchors = [
+            named_anchor("hypot", CTR, unit([size.y,size.x])),
+        ]
+    ) reorient(anchor,spin, two_d=true, size=[size.x,size.y], anchors=anchors, p=path);
 
 module right_triangle(size=[1,1], center, anchor, spin=0) {
     size = is_num(size)? [size,size] : size;
     anchor = get_anchor(anchor, center, [-1,-1], [-1,-1]);
     check = assert(is_vector(size,2));
-    path = right_triangle(size, center=true);
-    attachable(anchor,spin, two_d=true, size=[size.x,size.y], size2=0, shift=-size.x/2) {
+    path = right_triangle(size, anchor="origin");
+    anchors = [
+        named_anchor("hypot", CTR, unit([size.y,size.x])),
+    ];
+    attachable(anchor,spin, two_d=true, size=[size.x,size.y], anchors=anchors) {
         polygon(path);
         children();
     }
 }
 
 
 // Function&Module: trapezoid()
+// Synopsis: Creates a trapezoid with parallel top and bottom sides.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: rect(), square()
 // Usage: As Module
-//   trapezoid(h, w1, w2, [shift=], [rounding=], [chamfer=], ...) [ATTACHMENTS];
-//   trapezoid(h, w1, angle=, ...) [ATTACHMENTS];
-//   trapezoid(h, w2, angle=, ...) [ATTACHMENTS];
-//   trapezoid(w1, w2, angle=, ...) [ATTACHMENTS];
+//   trapezoid(h, w1, w2, [shift=], [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];
+//   trapezoid(h, w1, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];
+//   trapezoid(h, w2=, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];
+//   trapezoid(w1=, w2=, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = trapezoid(...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: rect(), square()
 // Description:
-//   When called as a function, returns a 2D path for a trapezoid with parallel front and back sides.
-//   When called as a module, creates a 2D trapezoid with parallel front and back sides.
+//   When called as a function, returns a 2D path for a trapezoid with parallel front and back (top and bottom) sides. 
+//   When called as a module, creates a 2D trapezoid.  You can specify the trapezoid by giving its height and the lengths
+//   of its two bases.  Alternatively, you can omit one of those parameters and specify the lower angle(s).
+//   The shift parameter, which cannot be combined with ang, shifts the back (top) of the trapezoid to the right.  
 // Arguments:
 //   h = The Y axis height of the trapezoid.
 //   w1 = The X axis width of the front end of the trapezoid.
 //   w2 = The X axis width of the back end of the trapezoid.
 //   ---
-//   angle = If given in place of `h`, `w1`, or `w2`, then the missing value is calculated such that the right side has that angle away from the Y axis.
-//   shift = Scalar value to shift the back of the trapezoid along the X axis by.  Default: 0
+//   ang = Specify the bottom angle(s) of the trapezoid.  Can give a scalar for an isosceles trapezoid or a list of two angles, the left angle and right angle.  You must omit one of `h`, `w1`, or `w2` to allow the freedom to control the angles. 
+//   shift = Scalar value to shift the back of the trapezoid along the X axis by.  Cannot be combined with ang.  Default: 0
 //   rounding = The rounding radius for the corners.  If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-]. Default: 0 (no rounding)
 //   chamfer = The Length of the chamfer faces at the corners.  If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].  Default: 0 (no chamfer)
 //   flip = If true, negative roundings and chamfers will point forward and back instead of left and right.  Default: `false`.
+//   atype = The type of anchoring to use with `anchor=`.  Valid opptions are "box" and "perim".  This lets you choose between putting anchors on the rounded or chamfered perimeter, or on the square bounding box of the shape. Default: "box"
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+// Anchor Types:
+//   box = Anchor is with respect to the rectangular bounding box of the shape.
+//   perim = Anchors are placed along the rounded or chamfered perimeter of the shape.
 // Examples(2D):
 //   trapezoid(h=30, w1=40, w2=20);
 //   trapezoid(h=25, w1=20, w2=35);
 //   trapezoid(h=20, w1=40, w2=0);
-//   trapezoid(h=20, w1=30, angle=30);
-//   trapezoid(h=20, w1=20, angle=-30);
-//   trapezoid(h=20, w2=10, angle=30);
-//   trapezoid(h=20, w2=30, angle=-30);
-//   trapezoid(w1=30, w2=10, angle=30);
+//   trapezoid(h=20, w1=30, ang=60);
+//   trapezoid(h=20, w1=20, ang=120);
+//   trapezoid(h=20, w2=10, ang=60);
+//   trapezoid(h=20, w1=50, ang=[40,60]);
+//   trapezoid(w1=30, w2=10, ang=[30,90]);
 // Example(2D): Chamfered Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, chamfer=5);
 // Example(2D): Negative Chamfered Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, chamfer=-5);
 // Example(2D): Flipped Negative Chamfered Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, chamfer=-5, flip=true);
 // Example(2D): Rounded Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, rounding=5);
 // Example(2D): Negative Rounded Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, rounding=-5);
 // Example(2D): Flipped Negative Rounded Trapezoid
 //   trapezoid(h=30, w1=60, w2=40, rounding=-5, flip=true);
 // Example(2D): Mixed Chamfering and Rounding
 //   trapezoid(h=30, w1=60, w2=40, rounding=[5,0,-10,0],chamfer=[0,8,0,-15],$fa=1,$fs=1);
+// Example(2D): default anchors for roundings
+//   trapezoid(h=30, w1=100, ang=[66,44],rounding=5) show_anchors();
+// Example(2D): default anchors for negative roundings are still at the trapezoid corners
+//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5) show_anchors();
+// Example(2D): "perim" anchors are at the tips of negative roundings
+//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5, atype="perim") show_anchors();
+// Example(2D): They point the other direction if you flip them
+//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5, atype="perim",flip=true) show_anchors();
 // Example(2D): Called as Function
 //   stroke(closed=true, trapezoid(h=30, w1=40, w2=20));
-function trapezoid(h, w1, w2, angle, shift=0, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0) =
+
+function _trapezoid_dims(h,w1,w2,shift,ang) = 
+    let(  
+        h = is_def(h)? h
+          : num_defined([w1,w2,each ang])==4 ? (w1-w2) * sin(ang[0]) * sin(ang[1]) / sin(ang[0]+ang[1])
+          : undef
+    )
+    is_undef(h) ? [h]
+  :
+    let(
+        x1 = is_undef(ang[0]) || ang[0]==90 ? 0 : h/tan(ang[0]),
+        x2 = is_undef(ang[1]) || ang[1]==90 ? 0 : h/tan(ang[1]),
+        w1 = is_def(w1)? w1
+           : is_def(w2) && is_def(ang[0]) ? w2 + x1 + x2
+           : undef,
+        w2 = is_def(w2)? w2
+           : is_def(w1) && is_def(ang[0]) ? w1 - x1 - x2
+           : undef,
+        shift = first_defined([shift,(x1-x2)/2])
+    )
+    [h,w1,w2,shift];
+
+
+
+function trapezoid(h, w1, w2, ang, shift, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0,atype="box", _return_override, angle) =
+    assert(is_undef(angle), "The angle parameter has been replaced by ang, which specifies trapezoid interior angle")
     assert(is_undef(h) || is_finite(h))
     assert(is_undef(w1) || is_finite(w1))
     assert(is_undef(w2) || is_finite(w2))
-    assert(is_undef(angle) || is_finite(angle))
-    assert(num_defined([h, w1, w2, angle]) == 3, "Must give exactly 3 of the arguments h, w1, w2, and angle.")
-    assert(is_finite(shift))
+    assert(is_undef(ang) || is_finite(ang) || is_vector(ang,2))
+    assert(num_defined([h, w1, w2, ang]) == 3, "Must give exactly 3 of the arguments h, w1, w2, and angle.")
+    assert(is_undef(shift) || is_finite(shift))
+    assert(num_defined([shift,ang])<2, "Cannot specify shift and ang together")
     assert(is_finite(chamfer)  || is_vector(chamfer,4))
     assert(is_finite(rounding) || is_vector(rounding,4))
     let(
-        simple = chamfer==0 && rounding==0,
-        h  = !is_undef(h)?  h  : opp_ang_to_adj(abs(w2-w1)/2, abs(angle)),
-        w1 = !is_undef(w1)? w1 : w2 + 2*(adj_ang_to_opp(h, angle) + shift),
-        w2 = !is_undef(w2)? w2 : w1 - 2*(adj_ang_to_opp(h, angle) + shift),
-        chamfs = is_num(chamfer)? [for (i=[0:3]) chamfer] :
-            assert(len(chamfer)==4) chamfer,
-        rounds = is_num(rounding)? [for (i=[0:3]) rounding] :
-            assert(len(rounding)==4) rounding,
-        srads = [for (i=[0:3]) rounds[i]? rounds[i] : chamfs[i]],
+        ang = force_list(ang,2),
+        angOK = len(ang)==2 && (ang==[undef,undef] || (all_positive(ang) && ang[0]<180 && ang[1]<180))
+    )
+    assert(angOK, "trapezoid angles must be scalar or 2-vector, strictly between 0 and 180")
+    let(
+        h_w1_w2_shift = _trapezoid_dims(h,w1,w2,shift,ang),
+        h = h_w1_w2_shift[0],
+        w1 = h_w1_w2_shift[1],
+        w2 = h_w1_w2_shift[2],
+        shift = h_w1_w2_shift[3],
+        chamfer = force_list(chamfer,4),
+        rounding = force_list(rounding,4)
+    )
+    assert(all_zero(v_mul(chamfer,rounding),0), "Cannot specify chamfer and rounding at the same corner")
+    let(
+        srads = chamfer+rounding, 
         rads = v_abs(srads)
     )
     assert(w1>=0 && w2>=0 && h>0, "Degenerate trapezoid geometry.")
     assert(w1+w2>0, "Degenerate trapezoid geometry.")
     let(
         base = [
             [ w2/2+shift, h/2],
@@ -925,83 +1010,93 @@
         offs = [
             for (i=[0:3]) let(
                 xoff = adj_ang_to_opp(rads[i],angs[i]),
                 a = [xoff, -rads[i]] * qdirs[i].y * (srads[i]<0 && flip? -1 : 1),
                 b = a + [hyps[i] * qdirs[i].x * (srads[i]<0 && !flip? 1 : -1), 0]
             ) b
         ],
-        cpath = [
-            each (
+        corners = [
+             (
                 let(i = 0)
-                rads[i] == 0? [base[i]] :
-                srads[i] > 0? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i], 90], r=rads[i]) :
-                flip? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i]) :
-                arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i])
+                rads[i] == 0? [base[i]]
+              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i], 90], r=rads[i])
+              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i])
+              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i])
             ),
-            each (
+             (
                 let(i = 1)
-                rads[i] == 0? [base[i]] :
-                srads[i] > 0? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[90,180+angs[i]], r=rads[i]) :
-                flip? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i]) :
-                arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i])
+                rads[i] == 0? [base[i]] 
+              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,180+angs[i]], r=rads[i]) 
+              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i]) 
+              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i])
             ),
-            each (
+             (
                 let(i = 2)
-                rads[i] == 0? [base[i]] :
-                srads[i] > 0? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],270], r=rads[i]) :
-                flip? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i]) :
-                arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i])
+                rads[i] == 0? [base[i]] 
+              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],270], r=rads[i]) 
+              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i]) 
+              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i])
             ),
-            each (
+             (
                 let(i = 3)
-                rads[i] == 0? [base[i]] :
-                srads[i] > 0? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[-90,angs[i]], r=rads[i]) :
-                flip? arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i]) :
-                arc(n=rounds[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i])
+                rads[i] == 0? [base[i]] 
+              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[-90,angs[i]], r=rads[i]) 
+              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i]) 
+              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i])
             ),
         ],
-        path = reverse(cpath)
-    ) simple
-      ? reorient(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, p=path)
-      : reorient(anchor,spin, two_d=true, path=path, p=path);
+        path = reverse(flatten(corners)),
+        override = [for(i=[0:3])
+                      if (atype!="box" && srads[i]!=0)
+                         srads[i]>0?
+                             let(dir = unit(base[i]-select(base,i-1)) + unit(base[i]-select(base,i+1)),
+                                pt=[for(seg=pair(corners[i])) let(isect=line_intersection(seg, [base[i],base[i]+dir],SEGMENT,LINE))
+                                                             if (is_def(isect) && isect!=seg[0]) isect]
+                             )
+                             [qdirs[i], [pt[0], undef]]
+                        : flip?
+                            let(  dir=unit(base[i] - select(base,i+(i%2==0?-1:1))))
+                            [qdirs[i], [select(corners[i],i%2==0?0:-1), dir]]
+                        : let( dir = [qdirs[i].x,0])
+                            [qdirs[i], [select(corners[i],i%2==0?-1:0), dir]]]
+    ) _return_override ? [reorient(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, p=path, override=override),override]
+                       : reorient(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, p=path, override=override);
 
 
 
-module trapezoid(h, w1, w2, angle, shift=0, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0) {
-    path = trapezoid(h=h, w1=w1, w2=w2, angle=angle, shift=shift, chamfer=chamfer, rounding=rounding, flip=flip);
-    union() {
-        simple = chamfer==0 && rounding==0;
-        h  = !is_undef(h)?  h  : opp_ang_to_adj(abs(w2-w1)/2, abs(angle));
-        w1 = !is_undef(w1)? w1 : w2 + 2*(adj_ang_to_opp(h, angle) + shift);
-        w2 = !is_undef(w2)? w2 : w1 - 2*(adj_ang_to_opp(h, angle) + shift);
-        if (simple) {
-            attachable(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift) {
-                polygon(path);
-                children();
-            }
-        } else {
-            attachable(anchor,spin, two_d=true, path=path) {
-                polygon(path);
-                children();
-            }
-        }
+
+module trapezoid(h, w1, w2, ang, shift, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0, atype="box", angle) {
+    path_over = trapezoid(h=h, w1=w1, w2=w2, ang=ang, shift=shift, chamfer=chamfer, rounding=rounding,
+                          flip=flip, angle=angle,atype=atype,anchor="origin",_return_override=true);
+    path=path_over[0];
+    override = path_over[1];
+    ang = force_list(ang,2);
+    h_w1_w2_shift = _trapezoid_dims(h,w1,w2,shift,ang);
+    h = h_w1_w2_shift[0];
+    w1 = h_w1_w2_shift[1];
+    w2 = h_w1_w2_shift[2];
+    shift = h_w1_w2_shift[3];
+    attachable(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, override=override) {
+        polygon(path);
+        children();
     }
 }
 
 
 
 // Function&Module: star()
+// Synopsis: Creates a star-shaped polygon or returns a star-shaped region.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), ellipse(), regular_ngon()
 // Usage: As Module
 //   star(n, r/or, ir, [realign=], [align_tip=], [align_pit=], ...) [ATTACHMENTS];
 //   star(n, r/or, step=, ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = star(n, r/or, ir, [realign=], [align_tip=], [align_pit=], ...);
 //   path = star(n, r/or, step=, ...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), ellipse()
 // Description:
 //   When called as a function, returns the path needed to create a star polygon with N points.
 //   When called as a module, creates a star polygon with N points.
 // Arguments:
 //   n = The number of stellate tips on the star.
 //   r/or = The radius to the tips of the star.
 //   ir = The radius to the inner corners of the star.
@@ -1153,14 +1248,15 @@
         ) path[i] + n * (is_collinear(select(path,i-1,i+1))? (dist * ((i%2)*2-1)) : 0),
         if (!closed) last(path)
     ];
 
 
 
 // Module: jittered_poly()
+// Synopsis: Creates a polygon with extra points for smoother twisted extrusions.
 // Topics: Extrusions
 // See Also: subdivide_path()
 // Usage:
 //   jittered_poly(path, [dist]);
 // Description:
 //   Creates a 2D polygon shape from the given path in such a way that any extra
 //   collinear points are not stripped out in the way that `polygon()` normally does.
@@ -1180,76 +1276,119 @@
 }
 
 
 // Section: Curved 2D Shapes
 
 
 // Function&Module: teardrop2d()
-//
+// Synopsis: Creates a 2D teardrop shape.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: teardrop(), onion()
 // Description:
-//   Makes a 2D teardrop shape. Useful for extruding into 3D printable holes.  Uses "intersect" style anchoring.  
+//   Makes a 2D teardrop shape. Useful for extruding into 3D printable holes as it limits overhang to 45 degrees.  Uses "intersect" style anchoring.  
+//   The cap_h parameter truncates the top of the teardrop.  If cap_h is taller than the untruncated form then
+//   the result will be the full, untruncated shape.  The segments of the bottom section of the teardrop are
+//   calculated to be the same as a circle or cylinder when rotated 90 degrees.  (Note that this agreement is poor when `$fn=6` or `$fn=7`.  
+//   If `$fn` is a multiple of four then the teardrop will reach its extremes on all four axes.  The circum option
+//   produces a teardrop that circumscribes the circle; in this case set `realign=true` to get a teardrop that meets its internal extremes
+//   on the axes.  
 //
 // Usage: As Module
 //   teardrop2d(r/d=, [ang], [cap_h]) [ATTACHMENTS];
 // Usage: As Function
-//   path = teardrop2d(r/d=, [ang], [cap_h]);
-//
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-//
-// See Also: teardrop(), onion()
+//   path = teardrop2d(r|d=, [ang], [cap_h]);
 //
 // Arguments:
 //   r = radius of circular part of teardrop.  (Default: 1)
-//   ang = angle of hat walls from the Y axis.  (Default: 45 degrees)
+//   ang = angle of hat walls from the Y axis (half the angle of the peak).  (Default: 45 degrees)
 //   cap_h = if given, height above center where the shape will be truncated.
 //   ---
-//   d = diameter of spherical portion of bottom. (Use instead of r)
+//   d = diameter of circular portion of bottom. (Use instead of r)
+//   circum = if true, create a circumscribing teardrop.  Default: false
+//   realign = if true, change whether bottom of teardrop is a point or a flat.  Default: false
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //
 // Example(2D): Typical Shape
 //   teardrop2d(r=30, ang=30);
 // Example(2D): Crop Cap
 //   teardrop2d(r=30, ang=30, cap_h=40);
 // Example(2D): Close Crop
 //   teardrop2d(r=30, ang=30, cap_h=20);
-module teardrop2d(r, ang=45, cap_h, d, anchor=CENTER, spin=0)
+module teardrop2d(r, ang=45, cap_h, d, circum=false, realign=false, anchor=CENTER, spin=0)
 {
-    path = teardrop2d(r=r, d=d, ang=ang, cap_h=cap_h);
+    path = teardrop2d(r=r, d=d, ang=ang, circum=circum, realign=realign, cap_h=cap_h);
     attachable(anchor,spin, two_d=true, path=path, extent=false) {
         polygon(path);
         children();
     }
 }
 
+// _extrapt = true causes the point to be duplicated so a teardrop with no cap
+// has the same point count as one with a cap.  
 
-function teardrop2d(r, ang=45, cap_h, d, anchor=CENTER, spin=0) =
+function teardrop2d(r, ang=45, cap_h, d, circum=false, realign=false, anchor=CENTER, spin=0, _extrapt=false) =
     let(
         r = get_radius(r=r, d=d, dflt=1),
-        ang2 = 90-ang,
-        prepath = zrot(90, p=circle(r=r)),
-        eps=1e-9,
-        prepath2 = [for (p=prepath) let(a=atan2(p.y,p.x)) if(a<=90-ang2+eps || a>=90+ang2-eps) p],
-        hyp = is_undef(cap_h)
-          ? opp_ang_to_hyp(abs(prepath2[0].x), ang)
-          : adj_ang_to_hyp(cap_h-prepath2[0].y, ang),
-        p1 = prepath2[0] + polar_to_xy(hyp, 90+ang),
-        p2 = last(prepath2) + polar_to_xy(hyp, 90-ang),
-        path = deduplicate([p1, each prepath2, p2], closed=true)
-    ) reorient(anchor,spin, two_d=true, path=path, p=path, extent=false);
+        minheight = r*sin(ang),
+        maxheight = r/sin(ang), //cos(90-ang),
+        pointycap = is_undef(cap_h) || cap_h>=maxheight
+    )
+    assert(is_undef(cap_h) || cap_h>=minheight, str("cap_h cannot be less than ",minheight," but it is ",cap_h))
+    let(
+        cap = [
+                pointycap? [0,maxheight] : [(maxheight-cap_h)*tan(ang), cap_h],
+                r*[cos(ang),sin(ang)]
+              ],
+        fullcircle = ellipse(r=r, realign=realign, circum=circum,spin=90),        
+        
+        // Chose the point on the circle that is lower than the cap but also creates a segment bigger than
+        // seglen/skipfactor so we don't have a teeny tiny segment at the end of the cap, except for the hexagoin
+        // case which is treated specially
+        skipfactor = len(fullcircle)==6 ? 15 : 3,
+        path = !circum ?
+                  let(seglen = norm(fullcircle[0]-fullcircle[1]))
+                  [
+                   each cap,
+                   for (p=fullcircle)
+                          if (
+                               p.y<last(cap).y-EPSILON
+                                 && norm([abs(p.x)-last(cap).x,p.y-last(cap.y)])>seglen/skipfactor
+                             ) p,
+                   xflip(cap[1]),
+                   if (_extrapt || !pointycap) xflip(cap[0])
+                  ]
+             : let(
+                   isect = [for(i=[0:1:len(fullcircle)/4])
+                               let(p = line_intersection(cap, select(fullcircle,[i,i+1]), bounded1=RAY, bounded2=SEGMENT))
+                               if (p) [i,p]
+                           ],
+                   i = last(isect)[0],
+                   p = last(isect)[1]
+               )
+               [
+                 cap[0],
+                 p,
+                 each select(fullcircle,i+1,-i-1-(realign?1:0)),
+                 xflip(p),
+                 if(_extrapt || !pointycap) xflip(cap[0])
+               ]
+    )
+    reorient(anchor,spin, two_d=true, path=path, p=path, extent=false);
 
 
 
 // Function&Module: egg()
+// Synopsis: Creates an egg-shaped 2d object.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), ellipse(), glued_circles()
 // Usage: As Module
 //   egg(length, r1|d1=, r2|d2=, R|D=) [ATTACHMENTS];
 // Usage: As Function
 //   path = egg(length, r1|d1=, r2|d2=, R|D=);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), ellipse(), glued_circles()
 // Description:
 //   Constructs an egg-shaped object by connecting two circles with convex arcs that are tangent to the circles.
 //   You specify the length of the egg, the radii of the two circles, and the desired arc radius.
 //   Note that because the side radius, R, is often much larger than the end radii, you may get better
 //   results using `$fs` and `$fa` to control the number of semgments rather than using `$fn`.
 //   This shape may be useful for creating a cam.  
 // Arguments:
@@ -1323,20 +1462,21 @@
     children();
   }
 }
 
 
 
 // Function&Module: glued_circles()
+// Synopsis: Creates a shape of two circles joined by a curved waist.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: circle(), ellipse(), egg()
 // Usage: As Module
 //   glued_circles(r/d=, [spread], [tangent], ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = glued_circles(r/d=, [spread], [tangent], ...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: circle(), ellipse(), egg()
 // Description:
 //   When called as a function, returns a 2D path forming a shape of two circles joined by curved waist.
 //   When called as a module, creates a 2D shape of two circles joined by curved waist.  Uses "hull" style anchoring.  
 // Arguments:
 //   r = The radius of the end circles.
 //   spread = The distance between the centers of the end circles.  Default: 10
 //   tangent = The angle in degrees of the tangent point for the joining arcs, measured away from the Y axis.  Default: 30
@@ -1391,36 +1531,40 @@
 
 
 
 function _superformula(theta,m1,m2,n1,n2=1,n3=1,a=1,b=1) =
     pow(pow(abs(cos(m1*theta/4)/a),n2)+pow(abs(sin(m2*theta/4)/b),n3),-1/n1);
 
 // Function&Module: supershape()
-// Usage: As Module
-//   supershape(step, [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]) [ATTACHMENTS];
-// Usage: As Function
-//   path = supershape(step, [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]);
+// Synopsis: Creates a 2D [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.
 // Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
 // See Also: circle(), ellipse()
+// Usage: As Module
+//   supershape([step],[n=], [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]) [ATTACHMENTS];
+// Usage: As Function
+//   path = supershape([step], [n=], [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]);
 // Description:
 //   When called as a function, returns a 2D path for the outline of the [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.
 //   When called as a module, creates a 2D [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.
 //   Note that the "hull" type anchoring (the default) is more intuitive for concave star-like shapes, but the anchor points do not
-//   necesarily lie on the line of the anchor vector, which can be confusing, especially for simpler, ellipse-like shapes.  
+//   necesarily lie on the line of the anchor vector, which can be confusing, especially for simpler, ellipse-like shapes.
+//   Note that the default step angle of 0.5 is very fine and can be slow, but due to the complex curves of the supershape,
+//   many points are often required to give a good result.  
 // Arguments:
-//   step = The angle step size for sampling the superformula shape.  Smaller steps are slower but more accurate.
+//   step = The angle step size for sampling the superformula shape.  Smaller steps are slower but more accurate.  Default: 0.5
+//   ---
+//   n = Produce n points as output.  Alternative to step.  Not to be confused with shape parameters n1 and n2.  
 //   m1 = The m1 argument for the superformula. Default: 4.
 //   m2 = The m2 argument for the superformula. Default: m1.
 //   n1 = The n1 argument for the superformula. Default: 1.
 //   n2 = The n2 argument for the superformula. Default: n1.
 //   n3 = The n3 argument for the superformula. Default: n2.
 //   a = The a argument for the superformula.  Default: 1.
 //   b = The b argument for the superformula.  Default: a.
 //   r = Radius of the shape.  Scale shape to fit in a circle of radius r.
-//   ---
 //   d = Diameter of the shape.  Scale shape to fit in a circle of diameter d.
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   atype = Select "hull" or "intersect" style anchoring.  Default: "hull". 
 // Example(2D):
 //   supershape(step=0.5,m1=16,m2=16,n1=0.5,n2=0.5,n3=16,r=50);
 // Example(2D): Called as Function
@@ -1442,48 +1586,48 @@
 //   m=[4,6,10]; for(i=[0:2]) right(i*5) supershape(m1=m[i], n1=12, n2=8, n3=5, a=2.7);
 //   for(i=[-1.5:3:1.5]) right(i*1.5) supershape(m1=2,m2=10,n1=i,n2=1);
 //   for(i=[1:3],j=[-1,1]) translate([3.5*i,1.5*j])supershape(m1=4,m2=6,n1=i*j,n2=1);
 //   for(i=[1:3]) right(2.5*i)supershape(step=.5,m1=88, m2=64, n1=-i*i,n2=1,r=1);
 // Examples:
 //   linear_extrude(height=0.3, scale=0) supershape(step=1, m1=6, n1=0.4, n2=0, n3=6);
 //   linear_extrude(height=5, scale=0) supershape(step=1, b=3, m1=6, n1=3.8, n2=16, n3=10);
-function supershape(step=0.5, m1=4, m2, n1=1, n2, n3, a=1, b, r, d,anchor=CENTER, spin=0, atype="hull") =
+function supershape(step=0.5, n, m1=4, m2, n1=1, n2, n3, a=1, b, r, d,anchor=CENTER, spin=0, atype="hull") =
     assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
     let(
-
+        n = first_defined([n, ceil(360/step)]),
+        angs = lerpn(360,0,n,endpoint=false),  
         r = get_radius(r=r, d=d, dflt=undef),
         m2 = is_def(m2) ? m2 : m1,
         n2 = is_def(n2) ? n2 : n1,
         n3 = is_def(n3) ? n3 : n2,
         b = is_def(b) ? b : a,
-        steps = ceil(360/step),
-        step = 360/steps,
-        angs = [for (i = [0:steps]) step*i],
-        rads = [for (theta = angs) _superformula(theta=theta,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b)],
-        scale = is_def(r) ? r/max(rads) : 1,
-        path = [for (i = [steps:-1:1]) let(a=angs[i]) scale*rads[i]*[cos(a), sin(a)]]
+        // superformula returns r(theta), the point in polar coordinates
+        rvals = [for (theta = angs) _superformula(theta=theta,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b)],
+        scale = is_def(r) ? r/max(rvals) : 1,
+        path = [for (i=idx(angs)) scale*rvals[i]*[cos(angs[i]), sin(angs[i])]]
     ) reorient(anchor,spin, two_d=true, path=path, p=path, extent=atype=="hull");
 
-module supershape(step=0.5,m1=4,m2=undef,n1,n2=undef,n3=undef,a=1,b=undef, r=undef, d=undef, anchor=CENTER, spin=0, atype="hull") {
+module supershape(step=0.5,n,m1=4,m2=undef,n1,n2=undef,n3=undef,a=1,b=undef, r=undef, d=undef, anchor=CENTER, spin=0, atype="hull") {
     check = assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"");
-    path = supershape(step=step,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b,r=r,d=d);
+    path = supershape(step=step,n=n,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b,r=r,d=d);
     attachable(anchor,spin,extent=atype=="hull", two_d=true, path=path) {
         polygon(path);
         children();
     }
 }
 
 
 // Function&Module: reuleaux_polygon()
+// Synopsis: Creates a constant-width shape that is not circular.
+// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
+// See Also: regular_ngon(), pentagon(), hexagon(), octagon()
 // Usage: As Module
 //   reuleaux_polygon(n, r|d=, ...) [ATTACHMENTS];
 // Usage: As Function
 //   path = reuleaux_polygon(n, r|d=, ...);
-// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
-// See Also: regular_ngon(), pentagon(), hexagon(), octagon()
 // Description:
 //   Creates a 2D Reuleaux Polygon; a constant width shape that is not circular.  Uses "intersect" type anchoring.  
 // Arguments:
 //   n = Number of "sides" to the Reuleaux Polygon.  Must be an odd positive number.  Default: 3
 //   r = Radius of the shape.  Scale shape to fit in a circle of radius r.
 //   ---
 //   d = Diameter of the shape.  Scale shape to fit in a circle of diameter d.
@@ -1538,49 +1682,70 @@
     ) reorient(anchor,spin, two_d=true, path=path, extent=false, anchors=anchors, p=path);
 
 
 
 // Section: Text
 
 // Module: text()
+// Synopsis: Creates an attachable block of text.
 // Topics: Attachments, Text
+// See Also: text3d(), attachable()
 // Usage:
 //   text(text, [size], [font], ...);
 // Description:
 //   Creates a 3D text block that can be attached to other attachable objects.
-//   NOTE: You cannot attach children to this.
+//   You cannot attach children to text.
+//   .
+//   Historically fonts were specified by their "body size", the height of the metal body
+//   on which the glyphs were cast.  This means the size was an upper bound on the size
+//   of the font glyphs, not a direct measurement of their size.  In digital typesetting,
+//   the metal body is replaced by an invisible box, the em square, whose side length is
+//   defined to be the font's size.  The glyphs can be contained in that square, or they
+//   can extend beyond it, depending on the choices made by the font designer.  As a
+//   result, the meaning of font size varies between fonts: two fonts at the "same" size
+//   can differ significantly in the actual size of their characters.  Typographers
+//   customarily specify the size in the units of "points".  A point is 1/72 inch.  In
+//   OpenSCAD, you specify the size in OpenSCAD units (often treated as millimeters for 3d
+//   printing), so if you want points you will need to perform a suitable unit conversion.
+//   In addition, the OpenSCAD font system has a bug: if you specify size=s you will
+//   instead get a font whose size is s/0.72.  For many fonts this means the size of
+//   capital letters will be approximately equal to s, because it is common for fonts to
+//   use about 70% of their height for the ascenders in the font.  To get the customary
+//   font size, you should multiply your desired size by 0.72.
+//   .
+//   To find the fonts that you have available in your OpenSCAD installation,
+//   go to the Help menu and select "Font List".  
 // Arguments:
-//   text = The text string to instantiate as an object.
-//   size = The font size used to create the text block.  Default: 10
-//   font = The name of the font used to create the text block.  Default: "Helvetica"
+//   text = Text to create.
+//   size = The font will be created at this size divided by 0.72.   Default: 10
+//   font = Font to use.  Default: "Liberation Sans"
 //   ---
 //   halign = If given, specifies the horizontal alignment of the text.  `"left"`, `"center"`, or `"right"`.  Overrides `anchor=`.
 //   valign = If given, specifies the vertical alignment of the text.  `"top"`, `"center"`, `"baseline"` or `"bottom"`.  Overrides `anchor=`.
 //   spacing = The relative spacing multiplier between characters.  Default: `1.0`
 //   direction = The text direction.  `"ltr"` for left to right.  `"rtl"` for right to left. `"ttb"` for top to bottom. `"btt"` for bottom to top.  Default: `"ltr"`
 //   language = The language the text is in.  Default: `"en"`
 //   script = The script the text is in.  Default: `"latin"`
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `"baseline"`
 //   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-// See Also: attachable()
 // Extra Anchors:
 //   "baseline" = Anchors at the baseline of the text, at the start of the string.
 //   str("baseline",VECTOR) = Anchors at the baseline of the text, modified by the X and Z components of the appended vector.
 // Examples(2D):
 //   text("Foobar", size=10);
 //   text("Foobar", size=12, font="Helvetica");
 //   text("Foobar", anchor=CENTER);
 //   text("Foobar", anchor=str("baseline",CENTER));
-// Example: Using line_of() distributor
+// Example: Using line_copies() distributor
 //   txt = "This is the string.";
-//   line_of(spacing=[10,-5],n=len(txt))
+//   line_copies(spacing=[10,-5],n=len(txt))
 //       text(txt[$idx], size=10, anchor=CENTER);
-// Example: Using arc_of() distributor
+// Example: Using arc_copies() distributor
 //   txt = "This is the string";
-//   arc_of(r=50, n=len(txt), sa=0, ea=180)
+//   arc_copies(r=50, n=len(txt), sa=0, ea=180)
 //       text(select(txt,-1-$idx), size=10, anchor=str("baseline",CENTER), spin=-90);
 module text(text, size=10, font="Helvetica", halign, valign, spacing=1.0, direction="ltr", language="en", script="latin", anchor="baseline", spin=0) {
     no_children($children);
     dummy1 =
         assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str("Got: ",anchor))
         assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str("Got: ",spin));
     anchor = default(anchor, CENTER);
@@ -1629,14 +1794,17 @@
     }
 }
 
 
 // Section: Rounding 2D shapes
 
 // Module: round2d()
+// Synopsis: Rounds the corners of 2d objects.
+// Topics: Rounding
+// See Also: shell2d(), round3d(), minkowski_difference()
 // Usage:
 //   round2d(r) [ATTACHMENTS];
 //   round2d(or=) [ATTACHMENTS];
 //   round2d(ir=) [ATTACHMENTS];
 //   round2d(or=, ir=) [ATTACHMENTS];
 // Description:
 //   Rounds arbitrary 2D objects.  Giving `r` rounds all concave and convex corners.  Giving just `ir`
@@ -1658,14 +1826,17 @@
     or = get_radius(r1=or, r=r, dflt=0);
     ir = get_radius(r1=ir, r=r, dflt=0);
     offset(or) offset(-ir-or) offset(delta=ir,chamfer=true) children();
 }
 
 
 // Module: shell2d()
+// Synopsis: Creates a shell from 2D children.
+// Topics: Shell
+// See Also: round2d(), round3d(), minkowski_difference()
 // Usage:
 //   shell2d(thickness, [or], [ir])
 // Description:
 //   Creates a hollow shell from 2D children, with optional rounding.
 // Arguments:
 //   thickness = Thickness of the shell.  Positive to expand outward, negative to shrink inward, or a two-element list to do both.
 //   or = Radius to round corners on the outside of the shell.  If given a list of 2 radii, [CONVEX,CONCAVE], specifies the radii for convex and concave corners separately.  Default: 0 (no outside rounding)
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/shapes3d.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/shapes3d.scad`

 * *Files 20% similar despite different names*

```diff
@@ -29,9245 +29,11311 @@
 000001c0: 7465 7874 206d 6f64 756c 6573 206c 6574  text modules let
 000001d0: 2079 6f75 2077 7269 7465 2074 6578 7420   you write text 
 000001e0: 6f6e 2061 2070 6174 680a 2f2f 2020 2073  on a path.//   s
 000001f0: 6f20 796f 7520 6361 6e20 706c 6163 6520  o you can place 
 00000200: 6974 206f 6e20 6120 6375 7276 6564 206f  it on a curved o
 00000210: 626a 6563 742e 2020 4120 7275 6c65 7220  bject.  A ruler 
 00000220: 6c65 7473 2079 6f75 206d 6561 7375 7265  lets you measure
-00000230: 206f 626a 6563 7473 2e20 200a 2f2f 2049   objects.  .// I
-00000240: 6e63 6c75 6465 733a 0a2f 2f20 2020 696e  ncludes:.//   in
-00000250: 636c 7564 6520 3c42 4f53 4c32 2f73 7464  clude <BOSL2/std
-00000260: 2e73 6361 643e 0a2f 2f20 4669 6c65 4772  .scad>.// FileGr
-00000270: 6f75 703a 2042 6173 6963 204d 6f64 656c  oup: Basic Model
-00000280: 696e 670a 2f2f 2046 696c 6553 756d 6d61  ing.// FileSumma
-00000290: 7279 3a20 4174 7461 6368 6162 6c65 2063  ry: Attachable c
-000002a0: 7562 6573 2c20 6379 6c69 6e64 6572 732c  ubes, cylinders,
-000002b0: 2073 7068 6572 6573 2c20 7275 6c65 722c   spheres, ruler,
-000002c0: 2061 6e64 2074 6578 742e 2020 4d61 6e79   and text.  Many
-000002d0: 2063 616e 2070 726f 6475 6365 2061 2056   can produce a V
-000002e0: 4e46 2e0a 2f2f 2046 696c 6546 6f6f 746e  NF..// FileFootn
-000002f0: 6f74 6573 3a20 5354 443d 496e 636c 7564  otes: STD=Includ
-00000300: 6564 2069 6e20 7374 642e 7363 6164 0a2f  ed in std.scad./
+00000230: 206f 626a 6563 7473 2e0a 2f2f 2049 6e63   objects..// Inc
+00000240: 6c75 6465 733a 0a2f 2f20 2020 696e 636c  ludes:.//   incl
+00000250: 7564 6520 3c42 4f53 4c32 2f73 7464 2e73  ude <BOSL2/std.s
+00000260: 6361 643e 0a2f 2f20 4669 6c65 4772 6f75  cad>.// FileGrou
+00000270: 703a 2042 6173 6963 204d 6f64 656c 696e  p: Basic Modelin
+00000280: 670a 2f2f 2046 696c 6553 756d 6d61 7279  g.// FileSummary
+00000290: 3a20 4174 7461 6368 6162 6c65 2063 7562  : Attachable cub
+000002a0: 6573 2c20 6379 6c69 6e64 6572 732c 2073  es, cylinders, s
+000002b0: 7068 6572 6573 2c20 7275 6c65 722c 2061  pheres, ruler, a
+000002c0: 6e64 2074 6578 742e 2020 4d61 6e79 2063  nd text.  Many c
+000002d0: 616e 2070 726f 6475 6365 2061 2056 4e46  an produce a VNF
+000002e0: 2e0a 2f2f 2046 696c 6546 6f6f 746e 6f74  ..// FileFootnot
+000002f0: 6573 3a20 5354 443d 496e 636c 7564 6564  es: STD=Included
+00000300: 2069 6e20 7374 642e 7363 6164 0a2f 2f2f   in std.scad.///
 00000310: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
 00000320: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
 00000330: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
 00000340: 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f 2f2f  ////////////////
-00000350: 2f2f 2f2f 2f0a 0a75 7365 203c 6275 696c  /////..use <buil
-00000360: 7469 6e73 2e73 6361 643e 0a0a 0a2f 2f20  tins.scad>...// 
-00000370: 5365 6374 696f 6e3a 2043 7562 6f69 6473  Section: Cuboids
-00000380: 2c20 5072 6973 6d6f 6964 7320 616e 6420  , Prismoids and 
-00000390: 5079 7261 6d69 6473 0a0a 2f2f 2046 756e  Pyramids..// Fun
-000003a0: 6374 696f 6e26 4d6f 6475 6c65 3a20 6375  ction&Module: cu
-000003b0: 6265 2829 0a2f 2f20 546f 7069 6373 3a20  be().// Topics: 
-000003c0: 5368 6170 6573 2028 3344 292c 2041 7474  Shapes (3D), Att
-000003d0: 6163 6861 626c 652c 2056 4e46 2047 656e  achable, VNF Gen
-000003e0: 6572 6174 6f72 730a 2f2f 2055 7361 6765  erators.// Usage
-000003f0: 3a20 4173 204d 6f64 756c 650a 2f2f 2020  : As Module.//  
-00000400: 2063 7562 6528 7369 7a65 2c20 5b63 656e   cube(size, [cen
-00000410: 7465 725d 2c20 2e2e 2e29 3b0a 2f2f 2055  ter], ...);.// U
-00000420: 7361 6765 3a20 5769 7468 2041 7474 6163  sage: With Attac
-00000430: 686d 656e 7473 0a2f 2f20 2020 6375 6265  hments.//   cube
-00000440: 2873 697a 652c 205b 6365 6e74 6572 5d2c  (size, [center],
-00000450: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
-00000460: 5453 5d3b 0a2f 2f20 5573 6167 653a 2041  TS];.// Usage: A
-00000470: 7320 4675 6e63 7469 6f6e 0a2f 2f20 2020  s Function.//   
-00000480: 766e 6620 3d20 6375 6265 2873 697a 652c  vnf = cube(size,
-00000490: 205b 6365 6e74 6572 5d2c 202e 2e2e 293b   [center], ...);
-000004a0: 0a2f 2f20 5365 6520 416c 736f 3a20 6375  .// See Also: cu
-000004b0: 626f 6964 2829 2c20 7072 6973 6d6f 6964  boid(), prismoid
-000004c0: 2829 0a2f 2f20 4465 7363 7269 7074 696f  ().// Descriptio
-000004d0: 6e3a 0a2f 2f20 2020 4372 6561 7465 7320  n:.//   Creates 
-000004e0: 6120 3344 2063 7562 6963 206f 626a 6563  a 3D cubic objec
-000004f0: 7420 7769 7468 2073 7570 706f 7274 2066  t with support f
-00000500: 6f72 2061 6e63 686f 7269 6e67 2061 6e64  or anchoring and
-00000510: 2061 7474 6163 686d 656e 7473 2e0a 2f2f   attachments..//
-00000520: 2020 2054 6869 7320 6361 6e20 6265 2075     This can be u
-00000530: 7365 6420 6173 2061 2064 726f 702d 696e  sed as a drop-in
-00000540: 2072 6570 6c61 6365 6d65 6e74 2066 6f72   replacement for
-00000550: 2074 6865 2062 7569 6c74 2d69 6e20 6063   the built-in `c
-00000560: 7562 6528 2960 206d 6f64 756c 652e 0a2f  ube()` module../
-00000570: 2f20 2020 5768 656e 2063 616c 6c65 6420  /   When called 
-00000580: 6173 2061 2066 756e 6374 696f 6e2c 2072  as a function, r
-00000590: 6574 7572 6e73 2061 205b 564e 465d 2876  eturns a [VNF](v
-000005a0: 6e66 2e73 6361 6429 2066 6f72 2061 2063  nf.scad) for a c
-000005b0: 7562 652e 0a2f 2f20 4172 6775 6d65 6e74  ube..// Argument
-000005c0: 733a 0a2f 2f20 2020 7369 7a65 203d 2054  s:.//   size = T
-000005d0: 6865 2073 697a 6520 6f66 2074 6865 2063  he size of the c
-000005e0: 7562 652e 0a2f 2f20 2020 6365 6e74 6572  ube..//   center
-000005f0: 203d 2049 6620 6769 7665 6e2c 206f 7665   = If given, ove
-00000600: 7272 6964 6573 2060 616e 6368 6f72 602e  rrides `anchor`.
-00000610: 2020 4120 7472 7565 2076 616c 7565 2073    A true value s
-00000620: 6574 7320 6061 6e63 686f 723d 4345 4e54  ets `anchor=CENT
-00000630: 4552 602c 2066 616c 7365 2073 6574 7320  ER`, false sets 
-00000640: 6061 6e63 686f 723d 4652 4f4e 542b 4c45  `anchor=FRONT+LE
-00000650: 4654 2b42 4f54 544f 4d60 2e0a 2f2f 2020  FT+BOTTOM`..//  
-00000660: 202d 2d2d 0a2f 2f20 2020 616e 6368 6f72   ---.//   anchor
-00000670: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
-00000680: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
-00000690: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
-000006a0: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
-000006b0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-000006c0: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
-000006d0: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
-000006e0: 6043 454e 5445 5260 0a2f 2f20 2020 7370  `CENTER`.//   sp
-000006f0: 696e 203d 2052 6f74 6174 6520 7468 6973  in = Rotate this
-00000700: 206d 616e 7920 6465 6772 6565 7320 6172   many degrees ar
-00000710: 6f75 6e64 2074 6865 205a 2061 7869 7320  ound the Z axis 
-00000720: 6166 7465 7220 616e 6368 6f72 2e20 2053  after anchor.  S
-00000730: 6565 205b 7370 696e 5d28 6174 7461 6368  ee [spin](attach
-00000740: 6d65 6e74 732e 7363 6164 2373 7562 7365  ments.scad#subse
-00000750: 6374 696f 6e2d 7370 696e 292e 2020 4465  ction-spin).  De
-00000760: 6661 756c 743a 2060 3060 0a2f 2f20 2020  fault: `0`.//   
-00000770: 6f72 6965 6e74 203d 2056 6563 746f 7220  orient = Vector 
-00000780: 746f 2072 6f74 6174 6520 746f 7020 746f  to rotate top to
-00000790: 7761 7264 732c 2061 6674 6572 2073 7069  wards, after spi
-000007a0: 6e2e 2020 5365 6520 5b6f 7269 656e 745d  n.  See [orient]
-000007b0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-000007c0: 6423 7375 6273 6563 7469 6f6e 2d6f 7269  d#subsection-ori
-000007d0: 656e 7429 2e20 2044 6566 6175 6c74 3a20  ent).  Default: 
-000007e0: 6055 5060 0a2f 2f20 4578 616d 706c 653a  `UP`.// Example:
-000007f0: 2053 696d 706c 6520 6375 6265 2e0a 2f2f   Simple cube..//
-00000800: 2020 2063 7562 6528 3430 293b 0a2f 2f20     cube(40);.// 
-00000810: 4578 616d 706c 653a 2052 6563 7461 6e67  Example: Rectang
-00000820: 756c 6172 2063 7562 652e 0a2f 2f20 2020  ular cube..//   
-00000830: 6375 6265 285b 3230 2c34 302c 3530 5d29  cube([20,40,50])
-00000840: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 416e  ;.// Example: An
-00000850: 6368 6f72 696e 672e 0a2f 2f20 2020 6375  choring..//   cu
-00000860: 6265 285b 3230 2c34 302c 3530 5d2c 2061  be([20,40,50], a
-00000870: 6e63 686f 723d 424f 5454 4f4d 2b46 524f  nchor=BOTTOM+FRO
-00000880: 4e54 293b 0a2f 2f20 4578 616d 706c 653a  NT);.// Example:
-00000890: 2053 7069 6e2e 0a2f 2f20 2020 6375 6265   Spin..//   cube
-000008a0: 285b 3230 2c34 302c 3530 5d2c 2061 6e63  ([20,40,50], anc
-000008b0: 686f 723d 424f 5454 4f4d 2b46 524f 4e54  hor=BOTTOM+FRONT
-000008c0: 2c20 7370 696e 3d33 3029 3b0a 2f2f 2045  , spin=30);.// E
-000008d0: 7861 6d70 6c65 3a20 4f72 6965 6e74 6174  xample: Orientat
-000008e0: 696f 6e2e 0a2f 2f20 2020 6375 6265 285b  ion..//   cube([
-000008f0: 3230 2c34 302c 3530 5d2c 2061 6e63 686f  20,40,50], ancho
-00000900: 723d 424f 5454 4f4d 2b46 524f 4e54 2c20  r=BOTTOM+FRONT, 
-00000910: 7370 696e 3d33 302c 206f 7269 656e 743d  spin=30, orient=
-00000920: 4657 4429 3b0a 2f2f 2045 7861 6d70 6c65  FWD);.// Example
-00000930: 3a20 5374 616e 6461 7264 2043 6f6e 6e65  : Standard Conne
-00000940: 6374 6f72 732e 0a2f 2f20 2020 6375 6265  ctors..//   cube
-00000950: 2834 302c 2063 656e 7465 723d 7472 7565  (40, center=true
-00000960: 2920 7368 6f77 5f61 6e63 686f 7273 2829  ) show_anchors()
-00000970: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4361  ;.// Example: Ca
-00000980: 6c6c 6564 2061 7320 4675 6e63 7469 6f6e  lled as Function
-00000990: 0a2f 2f20 2020 766e 6620 3d20 6375 6265  .//   vnf = cube
-000009a0: 285b 3230 2c34 302c 3530 5d29 3b0a 2f2f  ([20,40,50]);.//
-000009b0: 2020 2076 6e66 5f70 6f6c 7968 6564 726f     vnf_polyhedro
-000009c0: 6e28 766e 6629 3b0a 6d6f 6475 6c65 2063  n(vnf);.module c
-000009d0: 7562 6528 7369 7a65 3d31 2c20 6365 6e74  ube(size=1, cent
-000009e0: 6572 2c20 616e 6368 6f72 2c20 7370 696e  er, anchor, spin
-000009f0: 3d30 2c20 6f72 6965 6e74 3d55 5029 0a7b  =0, orient=UP).{
-00000a00: 0a20 2020 2061 6e63 686f 7220 3d20 6765  .    anchor = ge
-00000a10: 745f 616e 6368 6f72 2861 6e63 686f 722c  t_anchor(anchor,
-00000a20: 2063 656e 7465 722c 202d 5b31 2c31 2c31   center, -[1,1,1
-00000a30: 5d2c 202d 5b31 2c31 2c31 5d29 3b0a 2020  ], -[1,1,1]);.  
-00000a40: 2020 7369 7a65 203d 2073 6361 6c61 725f    size = scalar_
-00000a50: 7665 6333 2873 697a 6529 3b0a 2020 2020  vec3(size);.    
-00000a60: 6174 7461 6368 6162 6c65 2861 6e63 686f  attachable(ancho
-00000a70: 722c 7370 696e 2c6f 7269 656e 742c 2073  r,spin,orient, s
-00000a80: 697a 653d 7369 7a65 2920 7b0a 2020 2020  ize=size) {.    
-00000a90: 2020 2020 5f63 7562 6528 7369 7a65 2c20      _cube(size, 
-00000aa0: 6365 6e74 6572 3d74 7275 6529 3b0a 2020  center=true);.  
-00000ab0: 2020 2020 2020 6368 696c 6472 656e 2829        children()
-00000ac0: 3b0a 2020 2020 7d0a 7d0a 0a66 756e 6374  ;.    }.}..funct
-00000ad0: 696f 6e20 6375 6265 2873 697a 653d 312c  ion cube(size=1,
-00000ae0: 2063 656e 7465 722c 2061 6e63 686f 722c   center, anchor,
-00000af0: 2073 7069 6e3d 302c 206f 7269 656e 743d   spin=0, orient=
-00000b00: 5550 2920 3d0a 2020 2020 6c65 7428 0a20  UP) =.    let(. 
-00000b10: 2020 2020 2020 2073 697a 203d 2073 6361         siz = sca
-00000b20: 6c61 725f 7665 6333 2873 697a 6529 2c0a  lar_vec3(size),.
-00000b30: 2020 2020 2020 2020 616e 6368 6f72 203d          anchor =
-00000b40: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
-00000b50: 6f72 2c20 6365 6e74 6572 2c20 2d5b 312c  or, center, -[1,
-00000b60: 312c 315d 2c20 2d5b 312c 312c 315d 292c  1,1], -[1,1,1]),
-00000b70: 0a20 2020 2020 2020 2075 6e73 6361 6c65  .        unscale
-00000b80: 6420 3d20 5b0a 2020 2020 2020 2020 2020  d = [.          
-00000b90: 2020 5b2d 312c 2d31 2c2d 315d 2c5b 312c    [-1,-1,-1],[1,
-00000ba0: 2d31 2c2d 315d 2c5b 312c 312c 2d31 5d2c  -1,-1],[1,1,-1],
-00000bb0: 5b2d 312c 312c 2d31 5d2c 0a20 2020 2020  [-1,1,-1],.     
-00000bc0: 2020 2020 2020 205b 2d31 2c2d 312c 2031         [-1,-1, 1
-00000bd0: 5d2c 5b31 2c2d 312c 2031 5d2c 5b31 2c31  ],[1,-1, 1],[1,1
-00000be0: 2c20 315d 2c5b 2d31 2c31 2c20 315d 2c0a  , 1],[-1,1, 1],.
-00000bf0: 2020 2020 2020 2020 5d2f 322c 0a20 2020          ]/2,.   
-00000c00: 2020 2020 2076 6572 7473 203d 2069 735f       verts = is_
-00000c10: 6e75 6d28 7369 7a65 293f 2075 6e73 6361  num(size)? unsca
-00000c20: 6c65 6420 2a20 7369 7a65 203a 0a20 2020  led * size :.   
-00000c30: 2020 2020 2020 2020 2069 735f 7665 6374           is_vect
-00000c40: 6f72 2873 697a 652c 3329 3f20 5b66 6f72  or(size,3)? [for
-00000c50: 2028 703d 756e 7363 616c 6564 2920 765f   (p=unscaled) v_
-00000c60: 6d75 6c28 702c 7369 7a65 295d 203a 0a20  mul(p,size)] :. 
-00000c70: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00000c80: 7428 6973 5f6e 756d 2873 697a 6529 207c  t(is_num(size) |
-00000c90: 7c20 6973 5f76 6563 746f 7228 7369 7a65  | is_vector(size
-00000ca0: 2c33 2929 2c0a 2020 2020 2020 2020 6661  ,3)),.        fa
-00000cb0: 6365 7320 3d20 5b0a 2020 2020 2020 2020  ces = [.        
-00000cc0: 2020 2020 5b30 2c31 2c32 5d2c 205b 302c      [0,1,2], [0,
-00000cd0: 322c 335d 2c20 202f 2f42 4f54 544f 4d0a  2,3],  //BOTTOM.
-00000ce0: 2020 2020 2020 2020 2020 2020 5b30 2c34              [0,4
-00000cf0: 2c35 5d2c 205b 302c 352c 315d 2c20 202f  ,5], [0,5,1],  /
-00000d00: 2f46 524f 4e54 0a20 2020 2020 2020 2020  /FRONT.         
-00000d10: 2020 205b 312c 352c 365d 2c20 5b31 2c36     [1,5,6], [1,6
-00000d20: 2c32 5d2c 2020 2f2f 5249 4748 540a 2020  ,2],  //RIGHT.  
-00000d30: 2020 2020 2020 2020 2020 5b32 2c36 2c37            [2,6,7
-00000d40: 5d2c 205b 322c 372c 335d 2c20 202f 2f42  ], [2,7,3],  //B
-00000d50: 4143 4b0a 2020 2020 2020 2020 2020 2020  ACK.            
-00000d60: 5b33 2c37 2c34 5d2c 205b 332c 342c 305d  [3,7,4], [3,4,0]
-00000d70: 2c20 202f 2f4c 4546 540a 2020 2020 2020  ,  //LEFT.      
-00000d80: 2020 2020 2020 5b36 2c34 2c37 5d2c 205b        [6,4,7], [
-00000d90: 362c 352c 345d 2020 202f 2f54 4f50 0a20  6,5,4]   //TOP. 
-00000da0: 2020 2020 2020 205d 0a20 2020 2029 205b         ].    ) [
-00000db0: 7265 6f72 6965 6e74 2861 6e63 686f 722c  reorient(anchor,
-00000dc0: 7370 696e 2c6f 7269 656e 742c 2073 697a  spin,orient, siz
-00000dd0: 653d 7369 7a2c 2070 3d76 6572 7473 292c  e=siz, p=verts),
-00000de0: 2066 6163 6573 5d3b 0a0a 0a0a 2f2f 204d   faces];....// M
-00000df0: 6f64 756c 653a 2063 7562 6f69 6428 290a  odule: cuboid().
-00000e00: 2f2f 0a2f 2f20 5573 6167 653a 2053 7461  //.// Usage: Sta
-00000e10: 6e64 6172 6420 4375 6265 730a 2f2f 2020  ndard Cubes.//  
-00000e20: 2063 7562 6f69 6428 7369 7a65 2c20 5b61   cuboid(size, [a
-00000e30: 6e63 686f 723d 5d2c 205b 7370 696e 3d5d  nchor=], [spin=]
-00000e40: 2c20 5b6f 7269 656e 743d 5d29 3b0a 2f2f  , [orient=]);.//
-00000e50: 2020 2063 7562 6f69 6428 7369 7a65 2c20     cuboid(size, 
-00000e60: 7031 3d2c 202e 2e2e 293b 0a2f 2f20 2020  p1=, ...);.//   
-00000e70: 6375 626f 6964 2870 313d 2c20 7032 3d2c  cuboid(p1=, p2=,
-00000e80: 202e 2e2e 293b 0a2f 2f20 5573 6167 653a   ...);.// Usage:
-00000e90: 2043 6861 6d66 6572 6564 2043 7562 6573   Chamfered Cubes
-00000ea0: 0a2f 2f20 2020 6375 626f 6964 2873 697a  .//   cuboid(siz
-00000eb0: 652c 205b 6368 616d 6665 723d 5d2c 205b  e, [chamfer=], [
-00000ec0: 6564 6765 733d 5d2c 205b 6578 6365 7074  edges=], [except
-00000ed0: 3d5d 2c20 5b74 7269 6d63 6f72 6e65 7273  =], [trimcorners
-00000ee0: 3d5d 2c20 2e2e 2e29 3b0a 2f2f 2055 7361  =], ...);.// Usa
-00000ef0: 6765 3a20 526f 756e 6465 6420 4375 6265  ge: Rounded Cube
-00000f00: 730a 2f2f 2020 2063 7562 6f69 6428 7369  s.//   cuboid(si
-00000f10: 7a65 2c20 5b72 6f75 6e64 696e 673d 5d2c  ze, [rounding=],
-00000f20: 205b 7465 6172 6472 6f70 3d5d 2c20 5b65   [teardrop=], [e
-00000f30: 6467 6573 3d5d 2c20 5b65 7863 6570 743d  dges=], [except=
-00000f40: 5d2c 205b 7472 696d 636f 726e 6572 733d  ], [trimcorners=
-00000f50: 5d2c 202e 2e2e 293b 0a2f 2f20 5573 6167  ], ...);.// Usag
-00000f60: 653a 2041 7474 6163 6869 6e67 2063 6869  e: Attaching chi
-00000f70: 6c64 7265 6e0a 2f2f 2020 2063 7562 6f69  ldren.//   cuboi
-00000f80: 6428 2e2e 2e29 2041 5454 4143 484d 454e  d(...) ATTACHMEN
-00000f90: 5453 3b0a 2f2f 0a2f 2f20 4465 7363 7269  TS;.//.// Descri
-00000fa0: 7074 696f 6e3a 0a2f 2f20 2020 4372 6561  ption:.//   Crea
-00000fb0: 7465 7320 6120 6375 6265 206f 7220 6375  tes a cube or cu
-00000fc0: 626f 6964 206f 626a 6563 742c 2077 6974  boid object, wit
-00000fd0: 6820 6f70 7469 6f6e 616c 2063 6861 6d66  h optional chamf
-00000fe0: 6572 696e 6720 6f72 2072 6f75 6e64 696e  ering or roundin
-00000ff0: 6720 6f66 2065 6467 6573 2061 6e64 2063  g of edges and c
-00001000: 6f72 6e65 7273 2e0a 2f2f 2020 2059 6f75  orners..//   You
-00001010: 2063 616e 6e6f 7420 6d69 7820 6368 616d   cannot mix cham
-00001020: 6665 7269 6e67 2061 6e64 2072 6f75 6e64  fering and round
-00001030: 696e 673a 206a 7573 7420 6f6e 6520 6564  ing: just one ed
-00001040: 6765 2074 7265 6174 6d65 6e74 2077 6974  ge treatment wit
-00001050: 6820 7468 6520 7361 6d65 2073 697a 6520  h the same size 
-00001060: 6170 706c 6965 7320 746f 2061 6c6c 2073  applies to all s
-00001070: 656c 6563 7465 6420 6564 6765 732e 0a2f  elected edges../
-00001080: 2f20 2020 4e65 6761 7469 7665 2063 6861  /   Negative cha
-00001090: 6d66 6572 7320 616e 6420 726f 756e 6469  mfers and roundi
-000010a0: 6e67 7320 6361 6e20 6265 2061 7070 6c69  ngs can be appli
-000010b0: 6564 2074 6f20 6372 6561 7465 2065 7874  ed to create ext
-000010c0: 6572 6e61 6c20 6669 6c6c 6574 732c 2062  ernal fillets, b
-000010d0: 7574 2074 6865 790a 2f2f 2020 206f 6e6c  ut they.//   onl
-000010e0: 7920 6170 706c 7920 746f 2065 6467 6573  y apply to edges
-000010f0: 2061 726f 756e 6420 7468 6520 746f 7020   around the top 
-00001100: 6f72 2062 6f74 746f 6d20 6661 6365 732e  or bottom faces.
-00001110: 2020 4966 2079 6f75 2073 7065 6369 6679    If you specify
-00001120: 2061 6e20 6564 6765 2073 6574 206f 7468   an edge set oth
-00001130: 6572 2074 6861 6e20 2241 4c4c 220a 2f2f  er than "ALL".//
-00001140: 2020 2077 6974 6820 6e65 6761 7469 7665     with negative
-00001150: 2072 6f75 6e64 696e 6773 206f 7220 6368   roundings or ch
-00001160: 616d 6665 7273 2074 6865 6e20 796f 7520  amfers then you 
-00001170: 7769 6c6c 2067 6574 2061 6e20 6572 726f  will get an erro
-00001180: 722e 2020 5365 6520 5b53 7065 6369 6679  r.  See [Specify
-00001190: 696e 6720 4564 6765 735d 2861 7474 6163  ing Edges](attac
-000011a0: 686d 656e 7473 2e73 6361 6423 7365 6374  hments.scad#sect
-000011b0: 696f 6e2d 7370 6563 6966 7969 6e67 2d65  ion-specifying-e
-000011c0: 6467 6573 290a 2f2f 2020 2066 6f72 2069  dges).//   for i
-000011d0: 6e66 6f72 6d61 7469 6f6e 206f 6e20 686f  nformation on ho
-000011e0: 7720 746f 2073 7065 6369 6679 2065 6467  w to specify edg
-000011f0: 6520 7365 7473 2e0a 2f2f 2041 7267 756d  e sets..// Argum
-00001200: 656e 7473 3a0a 2f2f 2020 2073 697a 6520  ents:.//   size 
-00001210: 3d20 5468 6520 7369 7a65 206f 6620 7468  = The size of th
-00001220: 6520 6375 6265 2c20 6120 6e75 6d62 6572  e cube, a number
-00001230: 206f 7220 6c65 6e67 7468 2033 2076 6563   or length 3 vec
-00001240: 746f 722e 0a2f 2f20 2020 2d2d 2d0a 2f2f  tor..//   ---.//
-00001250: 2020 2063 6861 6d66 6572 203d 2053 697a     chamfer = Siz
-00001260: 6520 6f66 2063 6861 6d66 6572 2c20 696e  e of chamfer, in
-00001270: 7365 7420 6672 6f6d 2073 6964 6573 2e20  set from sides. 
-00001280: 2044 6566 6175 6c74 3a20 4e6f 2063 6861   Default: No cha
-00001290: 6d66 6572 696e 672e 0a2f 2f20 2020 726f  mfering..//   ro
-000012a0: 756e 6469 6e67 203d 2052 6164 6975 7320  unding = Radius 
-000012b0: 6f66 2074 6865 2065 6467 6520 726f 756e  of the edge roun
-000012c0: 6469 6e67 2e20 2044 6566 6175 6c74 3a20  ding.  Default: 
-000012d0: 4e6f 2072 6f75 6e64 696e 672e 0a2f 2f20  No rounding..// 
-000012e0: 2020 6564 6765 7320 3d20 4564 6765 7320    edges = Edges 
-000012f0: 746f 206d 6173 6b2e 2020 5365 6520 5b53  to mask.  See [S
-00001300: 7065 6369 6679 696e 6720 4564 6765 735d  pecifying Edges]
-00001310: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-00001320: 6423 7365 6374 696f 6e2d 7370 6563 6966  d#section-specif
-00001330: 7969 6e67 2d65 6467 6573 292e 2020 4465  ying-edges).  De
-00001340: 6661 756c 743a 2061 6c6c 2065 6467 6573  fault: all edges
-00001350: 2e0a 2f2f 2020 2065 7863 6570 7420 3d20  ..//   except = 
-00001360: 4564 6765 7320 746f 2065 7870 6c69 6369  Edges to explici
-00001370: 746c 7920 4e4f 5420 6d61 736b 2e20 2053  tly NOT mask.  S
-00001380: 6565 205b 5370 6563 6966 7969 6e67 2045  ee [Specifying E
-00001390: 6467 6573 5d28 6174 7461 6368 6d65 6e74  dges](attachment
-000013a0: 732e 7363 6164 2373 6563 7469 6f6e 2d73  s.scad#section-s
-000013b0: 7065 6369 6679 696e 672d 6564 6765 7329  pecifying-edges)
-000013c0: 2e20 2044 6566 6175 6c74 3a20 4e6f 2065  .  Default: No e
-000013d0: 6467 6573 2e0a 2f2f 2020 2074 7269 6d63  dges..//   trimc
-000013e0: 6f72 6e65 7273 203d 2049 6620 7472 7565  orners = If true
-000013f0: 2c20 726f 756e 6473 206f 7220 6368 616d  , rounds or cham
-00001400: 6665 7273 2063 6f72 6e65 7273 2077 6865  fers corners whe
-00001410: 7265 2074 6872 6565 2063 6861 6d66 6572  re three chamfer
-00001420: 6564 2f72 6f75 6e64 6564 2065 6467 6573  ed/rounded edges
-00001430: 206d 6565 742e 2020 4465 6661 756c 743a   meet.  Default:
-00001440: 2060 7472 7565 600a 2f2f 2020 2074 6561   `true`.//   tea
-00001450: 7264 726f 7020 3d20 4966 2067 6976 656e  rdrop = If given
-00001460: 2061 7320 6120 6e75 6d62 6572 2c20 726f   as a number, ro
-00001470: 756e 6469 6e67 2061 726f 756e 6420 7468  unding around th
-00001480: 6520 626f 7474 6f6d 2065 6467 6520 6f66  e bottom edge of
-00001490: 2074 6865 2063 7562 6f69 6420 776f 6e27   the cuboid won'
-000014a0: 7420 6578 6365 6564 2074 6869 7320 6d61  t exceed this ma
-000014b0: 6e79 2064 6567 7265 6573 2066 726f 6d20  ny degrees from 
-000014c0: 7665 7274 6963 616c 2e20 2049 6620 7472  vertical.  If tr
-000014d0: 7565 2c20 7468 6520 6c69 6d69 7420 616e  ue, the limit an
-000014e0: 676c 6520 6973 2034 3520 6465 6772 6565  gle is 45 degree
-000014f0: 732e 2020 4465 6661 756c 743a 2060 6661  s.  Default: `fa
-00001500: 6c73 6560 0a2f 2f20 2020 7031 203d 2041  lse`.//   p1 = A
-00001510: 6c69 676e 2074 6865 2063 7562 6f69 6427  lign the cuboid'
-00001520: 7320 636f 726e 6572 2061 7420 6070 3160  s corner at `p1`
-00001530: 2c20 6966 2067 6976 656e 2e20 2046 6f72  , if given.  For
-00001540: 6365 7320 6061 6e63 686f 723d 4652 4f4e  ces `anchor=FRON
-00001550: 542b 4c45 4654 2b42 4f54 544f 4d60 2e0a  T+LEFT+BOTTOM`..
-00001560: 2f2f 2020 2070 3220 3d20 4966 2067 6976  //   p2 = If giv
-00001570: 656e 2077 6974 6820 6070 3160 2c20 6465  en with `p1`, de
-00001580: 6669 6e65 7320 7468 6520 636f 726e 6572  fines the corner
-00001590: 706f 696e 7473 206f 6620 7468 6520 6375  points of the cu
-000015a0: 626f 6964 2e0a 2f2f 2020 2061 6e63 686f  boid..//   ancho
-000015b0: 7220 3d20 5472 616e 736c 6174 6520 736f  r = Translate so
-000015c0: 2061 6e63 686f 7220 706f 696e 7420 6973   anchor point is
-000015d0: 2061 7420 6f72 6967 696e 2028 302c 302c   at origin (0,0,
-000015e0: 3029 2e20 2053 6565 205b 616e 6368 6f72  0).  See [anchor
-000015f0: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
-00001600: 6164 2373 7562 7365 6374 696f 6e2d 616e  ad#subsection-an
-00001610: 6368 6f72 292e 2020 4465 6661 756c 743a  chor).  Default:
-00001620: 2060 4345 4e54 4552 600a 2f2f 2020 2073   `CENTER`.//   s
-00001630: 7069 6e20 3d20 526f 7461 7465 2074 6869  pin = Rotate thi
-00001640: 7320 6d61 6e79 2064 6567 7265 6573 2061  s many degrees a
-00001650: 726f 756e 6420 7468 6520 5a20 6178 6973  round the Z axis
-00001660: 2e20 2053 6565 205b 7370 696e 5d28 6174  .  See [spin](at
-00001670: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-00001680: 7562 7365 6374 696f 6e2d 7370 696e 292e  ubsection-spin).
-00001690: 2020 4465 6661 756c 743a 2060 3060 0a2f    Default: `0`./
-000016a0: 2f20 2020 6f72 6965 6e74 203d 2056 6563  /   orient = Vec
-000016b0: 746f 7220 746f 2072 6f74 6174 6520 746f  tor to rotate to
-000016c0: 7020 746f 7761 7264 732e 2020 5365 6520  p towards.  See 
-000016d0: 5b6f 7269 656e 745d 2861 7474 6163 686d  [orient](attachm
-000016e0: 656e 7473 2e73 6361 6423 7375 6273 6563  ents.scad#subsec
-000016f0: 7469 6f6e 2d6f 7269 656e 7429 2e20 2044  tion-orient).  D
-00001700: 6566 6175 6c74 3a20 6055 5060 0a2f 2f20  efault: `UP`.// 
-00001710: 4578 616d 706c 653a 2053 696d 706c 6520  Example: Simple 
-00001720: 7265 6775 6c61 7220 6375 6265 2e0a 2f2f  regular cube..//
-00001730: 2020 2063 7562 6f69 6428 3430 293b 0a2f     cuboid(40);./
-00001740: 2f20 4578 616d 706c 653a 2043 7562 6520  / Example: Cube 
-00001750: 7769 7468 206d 696e 696d 756d 2063 6f72  with minimum cor
-00001760: 6e65 7270 6f69 6e74 2067 6976 656e 2e0a  nerpoint given..
-00001770: 2f2f 2020 2063 7562 6f69 6428 3230 2c20  //   cuboid(20, 
-00001780: 7031 3d5b 3130 2c30 2c30 5d29 3b0a 2f2f  p1=[10,0,0]);.//
-00001790: 2045 7861 6d70 6c65 3a20 5265 6374 616e   Example: Rectan
-000017a0: 6775 6c61 7220 6375 6265 2c20 7769 7468  gular cube, with
-000017b0: 2067 6976 656e 2058 2c20 592c 2061 6e64   given X, Y, and
-000017c0: 205a 2073 697a 6573 2e0a 2f2f 2020 2063   Z sizes..//   c
-000017d0: 7562 6f69 6428 5b32 302c 3430 2c35 305d  uboid([20,40,50]
-000017e0: 293b 0a2f 2f20 4578 616d 706c 653a 2043  );.// Example: C
-000017f0: 7562 6520 6279 204f 7070 6f73 696e 6720  ube by Opposing 
-00001800: 436f 726e 6572 732e 0a2f 2f20 2020 6375  Corners..//   cu
-00001810: 626f 6964 2870 313d 5b30 2c31 302c 305d  boid(p1=[0,10,0]
-00001820: 2c20 7032 3d5b 3230 2c33 302c 3330 5d29  , p2=[20,30,30])
-00001830: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4368  ;.// Example: Ch
-00001840: 616d 6665 7272 6564 2045 6467 6573 2061  amferred Edges a
-00001850: 6e64 2043 6f72 6e65 7273 2e0a 2f2f 2020  nd Corners..//  
-00001860: 2063 7562 6f69 6428 5b33 302c 3430 2c35   cuboid([30,40,5
-00001870: 305d 2c20 6368 616d 6665 723d 3529 3b0a  0], chamfer=5);.
-00001880: 2f2f 2045 7861 6d70 6c65 3a20 4368 616d  // Example: Cham
-00001890: 6665 7272 6564 2045 6467 6573 2c20 556e  ferred Edges, Un
-000018a0: 7472 696d 6d65 6420 436f 726e 6572 732e  trimmed Corners.
-000018b0: 0a2f 2f20 2020 6375 626f 6964 285b 3330  .//   cuboid([30
-000018c0: 2c34 302c 3530 5d2c 2063 6861 6d66 6572  ,40,50], chamfer
-000018d0: 3d35 2c20 7472 696d 636f 726e 6572 733d  =5, trimcorners=
-000018e0: 6661 6c73 6529 3b0a 2f2f 2045 7861 6d70  false);.// Examp
-000018f0: 6c65 3a20 526f 756e 6465 6420 4564 6765  le: Rounded Edge
-00001900: 7320 616e 6420 436f 726e 6572 730a 2f2f  s and Corners.//
-00001910: 2020 2063 7562 6f69 6428 5b33 302c 3430     cuboid([30,40
-00001920: 2c35 305d 2c20 726f 756e 6469 6e67 3d31  ,50], rounding=1
-00001930: 3029 3b0a 2f2f 2045 7861 6d70 6c65 2856  0);.// Example(V
-00001940: 5052 3d5b 3130 302c 302c 3235 5d2c 5650  PR=[100,0,25],VP
-00001950: 443d 3138 3029 3a20 526f 756e 6465 6420  D=180): Rounded 
-00001960: 4564 6765 7320 616e 6420 436f 726e 6572  Edges and Corner
-00001970: 7320 7769 7468 2054 6561 7264 726f 7020  s with Teardrop 
-00001980: 426f 7474 6f6d 730a 2f2f 2020 2063 7562  Bottoms.//   cub
-00001990: 6f69 6428 5b33 302c 3430 2c35 305d 2c20  oid([30,40,50], 
-000019a0: 726f 756e 6469 6e67 3d31 302c 2074 6561  rounding=10, tea
-000019b0: 7264 726f 703d 7472 7565 293b 0a2f 2f20  rdrop=true);.// 
-000019c0: 4578 616d 706c 653a 2052 6f75 6e64 6564  Example: Rounded
-000019d0: 2045 6467 6573 2c20 556e 7472 696d 6d65   Edges, Untrimme
-000019e0: 6420 436f 726e 6572 730a 2f2f 2020 2063  d Corners.//   c
-000019f0: 7562 6f69 6428 5b33 302c 3430 2c35 305d  uboid([30,40,50]
-00001a00: 2c20 726f 756e 6469 6e67 3d31 302c 2074  , rounding=10, t
-00001a10: 7269 6d63 6f72 6e65 7273 3d66 616c 7365  rimcorners=false
-00001a20: 293b 0a2f 2f20 4578 616d 706c 653a 2043  );.// Example: C
-00001a30: 6861 6d66 6572 7269 6e67 2053 656c 6563  hamferring Selec
-00001a40: 7465 6420 4564 6765 730a 2f2f 2020 2063  ted Edges.//   c
-00001a50: 7562 6f69 6428 0a2f 2f20 2020 2020 2020  uboid(.//       
-00001a60: 5b33 302c 3430 2c35 305d 2c20 6368 616d  [30,40,50], cham
-00001a70: 6665 723d 352c 0a2f 2f20 2020 2020 2020  fer=5,.//       
-00001a80: 6564 6765 733d 5b54 4f50 2b46 524f 4e54  edges=[TOP+FRONT
-00001a90: 2c54 4f50 2b52 4947 4854 2c46 524f 4e54  ,TOP+RIGHT,FRONT
-00001aa0: 2b52 4947 4854 5d2c 0a2f 2f20 2020 2020  +RIGHT],.//     
-00001ab0: 2020 2466 6e3d 3234 0a2f 2f20 2020 293b    $fn=24.//   );
-00001ac0: 0a2f 2f20 4578 616d 706c 653a 2052 6f75  .// Example: Rou
-00001ad0: 6e64 696e 6720 5365 6c65 6374 6564 2045  nding Selected E
-00001ae0: 6467 6573 0a2f 2f20 2020 6375 626f 6964  dges.//   cuboid
-00001af0: 280a 2f2f 2020 2020 2020 205b 3330 2c34  (.//       [30,4
-00001b00: 302c 3530 5d2c 2072 6f75 6e64 696e 673d  0,50], rounding=
-00001b10: 352c 0a2f 2f20 2020 2020 2020 6564 6765  5,.//       edge
-00001b20: 733d 5b54 4f50 2b46 524f 4e54 2c54 4f50  s=[TOP+FRONT,TOP
-00001b30: 2b52 4947 4854 2c46 524f 4e54 2b52 4947  +RIGHT,FRONT+RIG
-00001b40: 4854 5d2c 0a2f 2f20 2020 2020 2020 2466  HT],.//       $f
-00001b50: 6e3d 3234 0a2f 2f20 2020 293b 0a2f 2f20  n=24.//   );.// 
-00001b60: 4578 616d 706c 653a 204e 6567 6174 6976  Example: Negativ
-00001b70: 6520 4368 616d 6665 7272 696e 670a 2f2f  e Chamferring.//
-00001b80: 2020 2063 7562 6f69 6428 0a2f 2f20 2020     cuboid(.//   
-00001b90: 2020 2020 5b33 302c 3430 2c35 305d 2c20      [30,40,50], 
-00001ba0: 6368 616d 6665 723d 2d35 2c0a 2f2f 2020  chamfer=-5,.//  
-00001bb0: 2020 2020 2065 6467 6573 3d5b 544f 502c       edges=[TOP,
-00001bc0: 424f 545d 2c20 6578 6365 7074 3d52 4947  BOT], except=RIG
-00001bd0: 4854 2c0a 2f2f 2020 2020 2020 2024 666e  HT,.//       $fn
-00001be0: 3d32 340a 2f2f 2020 2029 3b0a 2f2f 2045  =24.//   );.// E
-00001bf0: 7861 6d70 6c65 3a20 4e65 6761 7469 7665  xample: Negative
-00001c00: 2043 6861 6d66 6572 7269 6e67 2c20 556e   Chamferring, Un
-00001c10: 7472 696d 6d65 6420 436f 726e 6572 730a  trimmed Corners.
-00001c20: 2f2f 2020 2063 7562 6f69 6428 0a2f 2f20  //   cuboid(.// 
-00001c30: 2020 2020 2020 5b33 302c 3430 2c35 305d        [30,40,50]
-00001c40: 2c20 6368 616d 6665 723d 2d35 2c0a 2f2f  , chamfer=-5,.//
-00001c50: 2020 2020 2020 2065 6467 6573 3d5b 544f         edges=[TO
-00001c60: 502c 424f 545d 2c20 6578 6365 7074 3d52  P,BOT], except=R
-00001c70: 4947 4854 2c0a 2f2f 2020 2020 2020 2074  IGHT,.//       t
-00001c80: 7269 6d63 6f72 6e65 7273 3d66 616c 7365  rimcorners=false
-00001c90: 2c20 2466 6e3d 3234 0a2f 2f20 2020 293b  , $fn=24.//   );
-00001ca0: 0a2f 2f20 4578 616d 706c 653a 204e 6567  .// Example: Neg
-00001cb0: 6174 6976 6520 526f 756e 6469 6e67 0a2f  ative Rounding./
-00001cc0: 2f20 2020 6375 626f 6964 280a 2f2f 2020  /   cuboid(.//  
-00001cd0: 2020 2020 205b 3330 2c34 302c 3530 5d2c       [30,40,50],
-00001ce0: 2072 6f75 6e64 696e 673d 2d35 2c0a 2f2f   rounding=-5,.//
-00001cf0: 2020 2020 2020 2065 6467 6573 3d5b 544f         edges=[TO
-00001d00: 502c 424f 545d 2c20 6578 6365 7074 3d52  P,BOT], except=R
-00001d10: 4947 4854 2c0a 2f2f 2020 2020 2020 2024  IGHT,.//       $
-00001d20: 666e 3d32 340a 2f2f 2020 2029 3b0a 2f2f  fn=24.//   );.//
-00001d30: 2045 7861 6d70 6c65 3a20 4e65 6761 7469   Example: Negati
-00001d40: 7665 2052 6f75 6e64 696e 672c 2055 6e74  ve Rounding, Unt
-00001d50: 7269 6d6d 6564 2043 6f72 6e65 7273 0a2f  rimmed Corners./
-00001d60: 2f20 2020 6375 626f 6964 280a 2f2f 2020  /   cuboid(.//  
-00001d70: 2020 2020 205b 3330 2c34 302c 3530 5d2c       [30,40,50],
-00001d80: 2072 6f75 6e64 696e 673d 2d35 2c0a 2f2f   rounding=-5,.//
-00001d90: 2020 2020 2020 2065 6467 6573 3d5b 544f         edges=[TO
-00001da0: 502c 424f 545d 2c20 6578 6365 7074 3d52  P,BOT], except=R
-00001db0: 4947 4854 2c0a 2f2f 2020 2020 2020 2074  IGHT,.//       t
-00001dc0: 7269 6d63 6f72 6e65 7273 3d66 616c 7365  rimcorners=false
-00001dd0: 2c20 2466 6e3d 3234 0a2f 2f20 2020 293b  , $fn=24.//   );
-00001de0: 0a2f 2f20 4578 616d 706c 653a 2052 6f75  .// Example: Rou
-00001df0: 6e64 696e 6773 2061 6e64 2043 6861 6d66  ndings and Chamf
-00001e00: 6572 7320 6361 6e20 6265 2061 7320 6c61  ers can be as la
-00001e10: 7267 6520 6173 2074 6865 2066 756c 6c20  rge as the full 
-00001e20: 7369 7a65 206f 6620 7468 6520 6375 626f  size of the cubo
-00001e30: 6964 2c20 736f 206c 6f6e 6720 6173 2074  id, so long as t
-00001e40: 6865 2065 6467 6573 2077 6f75 6c64 206e  he edges would n
-00001e50: 6f74 2069 6e74 6572 6665 7265 2e0a 2f2f  ot interfere..//
-00001e60: 2020 2063 7562 6f69 6428 5b34 2c32 2c31     cuboid([4,2,1
-00001e70: 5d2c 2072 6f75 6e64 696e 673d 322c 2065  ], rounding=2, e
-00001e80: 6467 6573 3d5b 4657 442b 5249 4748 542c  dges=[FWD+RIGHT,
-00001e90: 4241 434b 2b4c 4546 545d 293b 0a2f 2f20  BACK+LEFT]);.// 
-00001ea0: 4578 616d 706c 653a 2053 7461 6e64 6172  Example: Standar
-00001eb0: 6420 436f 6e6e 6563 746f 7273 0a2f 2f20  d Connectors.// 
-00001ec0: 2020 6375 626f 6964 2834 3029 2073 686f    cuboid(40) sho
-00001ed0: 775f 616e 6368 6f72 7328 293b 0a6d 6f64  w_anchors();.mod
-00001ee0: 756c 6520 6375 626f 6964 280a 2020 2020  ule cuboid(.    
-00001ef0: 7369 7a65 3d5b 312c 312c 315d 2c0a 2020  size=[1,1,1],.  
-00001f00: 2020 7031 2c20 7032 2c0a 2020 2020 6368    p1, p2,.    ch
-00001f10: 616d 6665 722c 0a20 2020 2072 6f75 6e64  amfer,.    round
-00001f20: 696e 672c 0a20 2020 2065 6467 6573 3d45  ing,.    edges=E
-00001f30: 4447 4553 5f41 4c4c 2c0a 2020 2020 6578  DGES_ALL,.    ex
-00001f40: 6365 7074 3d5b 5d2c 0a20 2020 2065 7863  cept=[],.    exc
-00001f50: 6570 745f 6564 6765 732c 0a20 2020 2074  ept_edges,.    t
-00001f60: 7269 6d63 6f72 6e65 7273 3d74 7275 652c  rimcorners=true,
-00001f70: 0a20 2020 2074 6561 7264 726f 703d 6661  .    teardrop=fa
-00001f80: 6c73 652c 0a20 2020 2061 6e63 686f 723d  lse,.    anchor=
-00001f90: 4345 4e54 4552 2c0a 2020 2020 7370 696e  CENTER,.    spin
-00001fa0: 3d30 2c0a 2020 2020 6f72 6965 6e74 3d55  =0,.    orient=U
-00001fb0: 500a 2920 7b0a 2020 2020 6d6f 6475 6c65  P.) {.    module
-00001fc0: 2074 7275 6e63 5f63 7562 6528 732c 636f   trunc_cube(s,co
-00001fd0: 726e 6572 2920 7b0a 2020 2020 2020 2020  rner) {.        
-00001fe0: 6d75 6c74 6d61 7472 6978 280a 2020 2020  multmatrix(.    
-00001ff0: 2020 2020 2020 2020 2863 6f72 6e65 722e          (corner.
-00002000: 783c 303f 2078 666c 6970 2829 203a 2069  x<0? xflip() : i
-00002010: 6465 6e74 2834 2929 202a 0a20 2020 2020  dent(4)) *.     
-00002020: 2020 2020 2020 2028 636f 726e 6572 2e79         (corner.y
-00002030: 3c30 3f20 7966 6c69 7028 2920 3a20 6964  <0? yflip() : id
-00002040: 656e 7428 3429 2920 2a0a 2020 2020 2020  ent(4)) *.      
-00002050: 2020 2020 2020 2863 6f72 6e65 722e 7a3c        (corner.z<
-00002060: 303f 207a 666c 6970 2829 203a 2069 6465  0? zflip() : ide
-00002070: 6e74 2834 2929 202a 0a20 2020 2020 2020  nt(4)) *.       
-00002080: 2020 2020 2073 6361 6c65 2873 2b5b 312c       scale(s+[1,
-00002090: 312c 315d 2a30 2e30 3129 202a 0a20 2020  1,1]*0.01) *.   
-000020a0: 2020 2020 2020 2020 206d 6f76 6528 2d5b           move(-[
-000020b0: 312c 312c 315d 2f32 290a 2020 2020 2020  1,1,1]/2).      
-000020c0: 2020 2920 706f 6c79 6865 6472 6f6e 280a    ) polyhedron(.
-000020d0: 2020 2020 2020 2020 2020 2020 5b5b 312c              [[1,
-000020e0: 312c 315d 2c5b 312c 312c 305d 2c5b 312c  1,1],[1,1,0],[1,
-000020f0: 302c 305d 2c5b 302c 312c 315d 2c5b 302c  0,0],[0,1,1],[0,
-00002100: 312c 305d 2c5b 312c 302c 315d 2c5b 302c  1,0],[1,0,1],[0,
-00002110: 302c 315d 5d2c 0a20 2020 2020 2020 2020  0,1]],.         
-00002120: 2020 205b 5b30 2c31 2c32 5d2c 5b32 2c35     [[0,1,2],[2,5
-00002130: 2c30 5d2c 5b30 2c35 2c36 5d2c 5b30 2c36  ,0],[0,5,6],[0,6
-00002140: 2c33 5d2c 5b30 2c33 2c34 5d2c 5b30 2c34  ,3],[0,3,4],[0,4
-00002150: 2c31 5d2c 5b31 2c34 2c32 5d2c 5b33 2c36  ,1],[1,4,2],[3,6
-00002160: 2c34 5d2c 5b35 2c32 2c36 5d2c 5b32 2c34  ,4],[5,2,6],[2,4
-00002170: 2c36 5d5d 0a20 2020 2020 2020 2029 3b0a  ,6]].        );.
-00002180: 2020 2020 7d0a 2020 2020 6d6f 6475 6c65      }.    module
-00002190: 2078 7463 796c 286c 2c72 2920 7b0a 2020   xtcyl(l,r) {.  
-000021a0: 2020 2020 2020 6966 2028 7465 6172 6472        if (teardr
-000021b0: 6f70 2920 7b0a 2020 2020 2020 2020 2020  op) {.          
-000021c0: 2020 7465 6172 6472 6f70 2872 3d72 2c20    teardrop(r=r, 
-000021d0: 6c3d 6c2c 2063 6170 5f68 3d72 2c20 616e  l=l, cap_h=r, an
-000021e0: 673d 7465 6172 6472 6f70 2c20 7370 696e  g=teardrop, spin
-000021f0: 3d39 302c 206f 7269 656e 743d 444f 574e  =90, orient=DOWN
-00002200: 293b 0a20 2020 2020 2020 207d 2065 6c73  );.        } els
-00002210: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
-00002220: 7972 6f74 2839 3029 2063 796c 286c 3d6c  yrot(90) cyl(l=l
-00002230: 2c20 723d 7229 3b0a 2020 2020 2020 2020  , r=r);.        
-00002240: 7d0a 2020 2020 7d0a 2020 2020 6d6f 6475  }.    }.    modu
-00002250: 6c65 2079 7463 796c 286c 2c72 2920 7b0a  le ytcyl(l,r) {.
-00002260: 2020 2020 2020 2020 6966 2028 7465 6172          if (tear
-00002270: 6472 6f70 2920 7b0a 2020 2020 2020 2020  drop) {.        
-00002280: 2020 2020 7465 6172 6472 6f70 2872 3d72      teardrop(r=r
-00002290: 2c20 6c3d 6c2c 2063 6170 5f68 3d72 2c20  , l=l, cap_h=r, 
-000022a0: 616e 673d 7465 6172 6472 6f70 2c20 7370  ang=teardrop, sp
-000022b0: 696e 3d30 2c20 6f72 6965 6e74 3d44 4f57  in=0, orient=DOW
-000022c0: 4e29 3b0a 2020 2020 2020 2020 7d20 656c  N);.        } el
-000022d0: 7365 207b 0a20 2020 2020 2020 2020 2020  se {.           
-000022e0: 207a 726f 7428 3930 2920 7972 6f74 2839   zrot(90) yrot(9
-000022f0: 3029 2063 796c 286c 3d6c 2c20 723d 7229  0) cyl(l=l, r=r)
-00002300: 3b0a 2020 2020 2020 2020 7d0a 2020 2020  ;.        }.    
-00002310: 7d0a 2020 2020 6d6f 6475 6c65 2074 7370  }.    module tsp
-00002320: 6865 7265 2872 2920 7b0a 2020 2020 2020  here(r) {.      
-00002330: 2020 6966 2028 7465 6172 6472 6f70 2920    if (teardrop) 
-00002340: 7b0a 2020 2020 2020 2020 2020 2020 6f6e  {.            on
-00002350: 696f 6e28 723d 722c 2063 6170 5f68 3d72  ion(r=r, cap_h=r
-00002360: 2c20 616e 673d 7465 6172 6472 6f70 2c20  , ang=teardrop, 
-00002370: 6f72 6965 6e74 3d44 4f57 4e29 3b0a 2020  orient=DOWN);.  
-00002380: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
-00002390: 2020 2020 2020 2020 2020 2073 7068 6572             spher
-000023a0: 6f69 6428 723d 722c 2073 7479 6c65 3d22  oid(r=r, style="
-000023b0: 6f63 7461 222c 206f 7269 656e 743d 444f  octa", orient=DO
-000023c0: 574e 293b 0a20 2020 2020 2020 207d 0a20  WN);.        }. 
-000023d0: 2020 207d 0a20 2020 206d 6f64 756c 6520     }.    module 
-000023e0: 636f 726e 6572 5f73 6861 7065 2863 6f72  corner_shape(cor
-000023f0: 6e65 7229 207b 0a20 2020 2020 2020 2065  ner) {.        e
-00002400: 203d 205f 636f 726e 6572 5f65 6467 6573   = _corner_edges
-00002410: 2865 6467 6573 2c20 636f 726e 6572 293b  (edges, corner);
-00002420: 0a20 2020 2020 2020 2063 6e74 203d 2073  .        cnt = s
-00002430: 756d 2865 293b 0a20 2020 2020 2020 2072  um(e);.        r
-00002440: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-00002450: 285b 6368 616d 6665 722c 2072 6f75 6e64  ([chamfer, round
-00002460: 696e 675d 293b 0a20 2020 2020 2020 2064  ing]);.        d
-00002470: 756d 6d79 203d 2061 7373 6572 7428 6973  ummy = assert(is
-00002480: 5f66 696e 6974 6528 7229 2026 2620 2161  _finite(r) && !a
-00002490: 7070 726f 7828 722c 3029 293b 0a20 2020  pprox(r,0));.   
-000024a0: 2020 2020 2063 203d 205b 722c 722c 725d       c = [r,r,r]
-000024b0: 3b0a 2020 2020 2020 2020 6d20 3d20 302e  ;.        m = 0.
-000024c0: 3031 3b0a 2020 2020 2020 2020 6332 203d  01;.        c2 =
-000024d0: 2076 5f6d 756c 2863 6f72 6e65 722c 632f   v_mul(corner,c/
-000024e0: 3229 3b0a 2020 2020 2020 2020 6333 203d  2);.        c3 =
-000024f0: 2076 5f6d 756c 2863 6f72 6e65 722c 632d   v_mul(corner,c-
-00002500: 5b31 2c31 2c31 5d2a 6d2f 3229 3b0a 2020  [1,1,1]*m/2);.  
-00002510: 2020 2020 2020 2466 6e20 3d20 6973 5f66        $fn = is_f
-00002520: 696e 6974 6528 6368 616d 6665 7229 3f20  inite(chamfer)? 
-00002530: 3420 3a20 7175 616e 7475 7028 7365 6773  4 : quantup(segs
-00002540: 2872 292c 3429 3b0a 2020 2020 2020 2020  (r),4);.        
-00002550: 7472 616e 736c 6174 6528 765f 6d75 6c28  translate(v_mul(
-00002560: 636f 726e 6572 2c20 7369 7a65 2f32 2d63  corner, size/2-c
-00002570: 2929 207b 0a20 2020 2020 2020 2020 2020  )) {.           
-00002580: 2069 6620 2863 6e74 203d 3d20 3020 7c7c   if (cnt == 0 ||
-00002590: 2061 7070 726f 7828 722c 3029 2920 7b0a   approx(r,0)) {.
-000025a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025b0: 7472 616e 736c 6174 6528 6333 2920 6375  translate(c3) cu
-000025c0: 6265 286d 2c20 6365 6e74 6572 3d74 7275  be(m, center=tru
-000025d0: 6529 3b0a 2020 2020 2020 2020 2020 2020  e);.            
-000025e0: 7d20 656c 7365 2069 6620 2863 6e74 203d  } else if (cnt =
-000025f0: 3d20 3129 207b 0a20 2020 2020 2020 2020  = 1) {.         
-00002600: 2020 2020 2020 2069 6620 2865 2e78 2920         if (e.x) 
-00002610: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00002620: 2020 2020 2020 6d61 7420 3d20 2863 6f72        mat = (cor
-00002630: 6e65 722e 793c 303f 2079 666c 6970 2829  ner.y<0? yflip()
-00002640: 203a 2069 6465 6e74 2834 2929 202a 0a20   : ident(4)) *. 
-00002650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002660: 2020 2020 2020 2028 636f 726e 6572 2e7a         (corner.z
-00002670: 3c30 3f20 7a66 6c69 7028 2920 3a20 6964  <0? zflip() : id
-00002680: 656e 7428 3429 2920 2a0a 2020 2020 2020  ent(4)) *.      
-00002690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000026a0: 2020 7972 6f74 282d 3930 2920 2a20 6d6f    yrot(-90) * mo
-000026b0: 7665 282d 5b31 2c31 5d2a 302e 3031 293b  ve(-[1,1]*0.01);
-000026c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000026d0: 2020 2020 2072 6967 6874 2863 332e 7829       right(c3.x)
-000026e0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000026f0: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
-00002700: 7365 6374 696f 6e28 2920 7b0a 2020 2020  section() {.    
-00002710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002720: 2020 2020 2020 2020 7874 6379 6c28 6c3d          xtcyl(l=
-00002730: 6d2c 2072 3d72 293b 0a20 2020 2020 2020  m, r=r);.       
-00002740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002750: 2020 2020 206d 756c 746d 6174 7269 7828       multmatrix(
-00002760: 6d61 7429 0a20 2020 2020 2020 2020 2020  mat).           
+00000350: 2f2f 2f0a 0a75 7365 203c 6275 696c 7469  ///..use <builti
+00000360: 6e73 2e73 6361 643e 0a0a 0a2f 2f20 5365  ns.scad>...// Se
+00000370: 6374 696f 6e3a 2043 7562 6f69 6473 2c20  ction: Cuboids, 
+00000380: 5072 6973 6d6f 6964 7320 616e 6420 5079  Prismoids and Py
+00000390: 7261 6d69 6473 0a0a 2f2f 2046 756e 6374  ramids..// Funct
+000003a0: 696f 6e26 4d6f 6475 6c65 3a20 6375 6265  ion&Module: cube
+000003b0: 2829 0a2f 2f20 5379 6e6f 7073 6973 3a20  ().// Synopsis: 
+000003c0: 4372 6561 7465 7320 6120 6375 6265 2077  Creates a cube w
+000003d0: 6974 6820 616e 6368 6f72 7320 666f 7220  ith anchors for 
+000003e0: 6174 7461 6368 696e 6720 6368 696c 6472  attaching childr
+000003f0: 656e 2c20 6f72 2072 6574 7572 6e73 2061  en, or returns a
+00000400: 2076 6e66 2e0a 2f2f 2054 6f70 6963 733a   vnf..// Topics:
+00000410: 2053 6861 7065 7320 2833 4429 2c20 4174   Shapes (3D), At
+00000420: 7461 6368 6162 6c65 2c20 564e 4620 4765  tachable, VNF Ge
+00000430: 6e65 7261 746f 7273 0a2f 2f20 5365 6520  nerators.// See 
+00000440: 416c 736f 3a20 6375 626f 6964 2829 2c20  Also: cuboid(), 
+00000450: 7072 6973 6d6f 6964 2829 0a2f 2f20 5573  prismoid().// Us
+00000460: 6167 653a 2041 7320 4d6f 6475 6c65 2028  age: As Module (
+00000470: 6173 2069 6e20 6e61 7469 7665 204f 7065  as in native Ope
+00000480: 6e53 4341 4429 0a2f 2f20 2020 6375 6265  nSCAD).//   cube
+00000490: 2873 697a 652c 205b 6365 6e74 6572 5d29  (size, [center])
+000004a0: 3b0a 2f2f 2055 7361 6765 3a20 5769 7468  ;.// Usage: With
+000004b0: 2042 4f53 4c32 2041 7474 6163 686d 656e   BOSL2 Attachmen
+000004c0: 7420 6578 7465 6e73 696f 6e73 0a2f 2f20  t extensions.// 
+000004d0: 2020 6375 6265 2873 697a 652c 205b 6365    cube(size, [ce
+000004e0: 6e74 6572 5d2c 205b 616e 6368 6f72 3d5d  nter], [anchor=]
+000004f0: 2c20 5b73 7069 6e3d 5d2c 205b 6f72 6965  , [spin=], [orie
+00000500: 6e74 3d5d 2920 5b41 5454 4143 484d 454e  nt=]) [ATTACHMEN
+00000510: 5453 5d3b 0a2f 2f20 5573 6167 653a 2041  TS];.// Usage: A
+00000520: 7320 4675 6e63 7469 6f6e 2028 424f 534c  s Function (BOSL
+00000530: 3220 6578 7465 6e73 696f 6e29 0a2f 2f20  2 extension).// 
+00000540: 2020 766e 6620 3d20 6375 6265 2873 697a    vnf = cube(siz
+00000550: 652c 202e 2e2e 293b 0a2f 2f20 4465 7363  e, ...);.// Desc
+00000560: 7269 7074 696f 6e3a 0a2f 2f20 2020 4372  ription:.//   Cr
+00000570: 6561 7465 7320 6120 3344 2063 7562 6963  eates a 3D cubic
+00000580: 206f 626a 6563 742e 0a2f 2f20 2020 5468   object..//   Th
+00000590: 6973 206d 6f64 756c 6520 6578 7465 6e64  is module extend
+000005a0: 7320 7468 6520 6275 696c 742d 696e 2063  s the built-in c
+000005b0: 7562 6528 2960 206d 6f64 756c 6520 6279  ube()` module by
+000005c0: 2070 726f 7669 6469 6e67 2073 7570 706f   providing suppo
+000005d0: 7274 2066 6f72 2061 7474 6163 686d 656e  rt for attachmen
+000005e0: 7473 2061 6e64 2061 2066 756e 6374 696f  ts and a functio
+000005f0: 6e20 666f 726d 2e20 200a 2f2f 2020 2057  n form.  .//   W
+00000600: 6865 6e20 6361 6c6c 6564 2061 7320 6120  hen called as a 
+00000610: 6675 6e63 7469 6f6e 2c20 7265 7475 726e  function, return
+00000620: 7320 6120 5b56 4e46 5d28 766e 662e 7363  s a [VNF](vnf.sc
+00000630: 6164 2920 666f 7220 6120 6375 6265 2e0a  ad) for a cube..
+00000640: 2f2f 2041 7267 756d 656e 7473 3a0a 2f2f  // Arguments:.//
+00000650: 2020 2073 697a 6520 3d20 5468 6520 7369     size = The si
+00000660: 7a65 206f 6620 7468 6520 6375 6265 2e0a  ze of the cube..
+00000670: 2f2f 2020 2063 656e 7465 7220 3d20 4966  //   center = If
+00000680: 2067 6976 656e 2c20 6f76 6572 7269 6465   given, override
+00000690: 7320 6061 6e63 686f 7260 2e20 2041 2074  s `anchor`.  A t
+000006a0: 7275 6520 7661 6c75 6520 7365 7473 2060  rue value sets `
+000006b0: 616e 6368 6f72 3d43 454e 5445 5260 2c20  anchor=CENTER`, 
+000006c0: 6661 6c73 6520 7365 7473 2060 616e 6368  false sets `anch
+000006d0: 6f72 3d46 524f 4e54 2b4c 4546 542b 424f  or=FRONT+LEFT+BO
+000006e0: 5454 4f4d 602e 0a2f 2f20 2020 2d2d 2d0a  TTOM`..//   ---.
+000006f0: 2f2f 2020 2061 6e63 686f 7220 3d20 5472  //   anchor = Tr
+00000700: 616e 736c 6174 6520 736f 2061 6e63 686f  anslate so ancho
+00000710: 7220 706f 696e 7420 6973 2061 7420 6f72  r point is at or
+00000720: 6967 696e 2028 302c 302c 3029 2e20 2053  igin (0,0,0).  S
+00000730: 6565 205b 616e 6368 6f72 5d28 6174 7461  ee [anchor](atta
+00000740: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00000750: 7365 6374 696f 6e2d 616e 6368 6f72 292e  section-anchor).
+00000760: 2020 4465 6661 756c 743a 2060 4345 4e54    Default: `CENT
+00000770: 4552 600a 2f2f 2020 2073 7069 6e20 3d20  ER`.//   spin = 
+00000780: 526f 7461 7465 2074 6869 7320 6d61 6e79  Rotate this many
+00000790: 2064 6567 7265 6573 2061 726f 756e 6420   degrees around 
+000007a0: 7468 6520 5a20 6178 6973 2061 6674 6572  the Z axis after
+000007b0: 2061 6e63 686f 722e 2020 5365 6520 5b73   anchor.  See [s
+000007c0: 7069 6e5d 2861 7474 6163 686d 656e 7473  pin](attachments
+000007d0: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
+000007e0: 2d73 7069 6e29 2e20 2044 6566 6175 6c74  -spin).  Default
+000007f0: 3a20 6030 600a 2f2f 2020 206f 7269 656e  : `0`.//   orien
+00000800: 7420 3d20 5665 6374 6f72 2074 6f20 726f  t = Vector to ro
+00000810: 7461 7465 2074 6f70 2074 6f77 6172 6473  tate top towards
+00000820: 2c20 6166 7465 7220 7370 696e 2e20 2053  , after spin.  S
+00000830: 6565 205b 6f72 6965 6e74 5d28 6174 7461  ee [orient](atta
+00000840: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00000850: 7365 6374 696f 6e2d 6f72 6965 6e74 292e  section-orient).
+00000860: 2020 4465 6661 756c 743a 2060 5550 600a    Default: `UP`.
+00000870: 2f2f 2045 7861 6d70 6c65 3a20 5369 6d70  // Example: Simp
+00000880: 6c65 2063 7562 652e 0a2f 2f20 2020 6375  le cube..//   cu
+00000890: 6265 2834 3029 3b0a 2f2f 2045 7861 6d70  be(40);.// Examp
+000008a0: 6c65 3a20 5265 6374 616e 6775 6c61 7220  le: Rectangular 
+000008b0: 6375 6265 2e0a 2f2f 2020 2063 7562 6528  cube..//   cube(
+000008c0: 5b32 302c 3430 2c35 305d 293b 0a2f 2f20  [20,40,50]);.// 
+000008d0: 4578 616d 706c 653a 2041 6e63 686f 7269  Example: Anchori
+000008e0: 6e67 2e0a 2f2f 2020 2063 7562 6528 5b32  ng..//   cube([2
+000008f0: 302c 3430 2c35 305d 2c20 616e 6368 6f72  0,40,50], anchor
+00000900: 3d42 4f54 544f 4d2b 4652 4f4e 5429 3b0a  =BOTTOM+FRONT);.
+00000910: 2f2f 2045 7861 6d70 6c65 3a20 5370 696e  // Example: Spin
+00000920: 2e0a 2f2f 2020 2063 7562 6528 5b32 302c  ..//   cube([20,
+00000930: 3430 2c35 305d 2c20 616e 6368 6f72 3d42  40,50], anchor=B
+00000940: 4f54 544f 4d2b 4652 4f4e 542c 2073 7069  OTTOM+FRONT, spi
+00000950: 6e3d 3330 293b 0a2f 2f20 4578 616d 706c  n=30);.// Exampl
+00000960: 653a 204f 7269 656e 7461 7469 6f6e 2e0a  e: Orientation..
+00000970: 2f2f 2020 2063 7562 6528 5b32 302c 3430  //   cube([20,40
+00000980: 2c35 305d 2c20 616e 6368 6f72 3d42 4f54  ,50], anchor=BOT
+00000990: 544f 4d2b 4652 4f4e 542c 2073 7069 6e3d  TOM+FRONT, spin=
+000009a0: 3330 2c20 6f72 6965 6e74 3d46 5744 293b  30, orient=FWD);
+000009b0: 0a2f 2f20 4578 616d 706c 653a 2053 7461  .// Example: Sta
+000009c0: 6e64 6172 6420 436f 6e6e 6563 746f 7273  ndard Connectors
+000009d0: 2e0a 2f2f 2020 2063 7562 6528 3430 2c20  ..//   cube(40, 
+000009e0: 6365 6e74 6572 3d74 7275 6529 2073 686f  center=true) sho
+000009f0: 775f 616e 6368 6f72 7328 293b 0a2f 2f20  w_anchors();.// 
+00000a00: 4578 616d 706c 653a 2043 616c 6c65 6420  Example: Called 
+00000a10: 6173 2046 756e 6374 696f 6e0a 2f2f 2020  as Function.//  
+00000a20: 2076 6e66 203d 2063 7562 6528 5b32 302c   vnf = cube([20,
+00000a30: 3430 2c35 305d 293b 0a2f 2f20 2020 766e  40,50]);.//   vn
+00000a40: 665f 706f 6c79 6865 6472 6f6e 2876 6e66  f_polyhedron(vnf
+00000a50: 293b 0a0a 6d6f 6475 6c65 2063 7562 6528  );..module cube(
+00000a60: 7369 7a65 3d31 2c20 6365 6e74 6572 2c20  size=1, center, 
+00000a70: 616e 6368 6f72 2c20 7370 696e 3d30 2c20  anchor, spin=0, 
+00000a80: 6f72 6965 6e74 3d55 5029 0a7b 0a20 2020  orient=UP).{.   
+00000a90: 2061 6e63 686f 7220 3d20 6765 745f 616e   anchor = get_an
+00000aa0: 6368 6f72 2861 6e63 686f 722c 2063 656e  chor(anchor, cen
+00000ab0: 7465 722c 202d 5b31 2c31 2c31 5d2c 202d  ter, -[1,1,1], -
+00000ac0: 5b31 2c31 2c31 5d29 3b0a 2020 2020 7369  [1,1,1]);.    si
+00000ad0: 7a65 203d 2073 6361 6c61 725f 7665 6333  ze = scalar_vec3
+00000ae0: 2873 697a 6529 3b0a 2020 2020 6174 7461  (size);.    atta
+00000af0: 6368 6162 6c65 2861 6e63 686f 722c 7370  chable(anchor,sp
+00000b00: 696e 2c6f 7269 656e 742c 2073 697a 653d  in,orient, size=
+00000b10: 7369 7a65 2920 7b0a 2020 2020 2020 2020  size) {.        
+00000b20: 5f63 7562 6528 7369 7a65 2c20 6365 6e74  _cube(size, cent
+00000b30: 6572 3d74 7275 6529 3b0a 2020 2020 2020  er=true);.      
+00000b40: 2020 6368 696c 6472 656e 2829 3b0a 2020    children();.  
+00000b50: 2020 7d0a 7d0a 0a66 756e 6374 696f 6e20    }.}..function 
+00000b60: 6375 6265 2873 697a 653d 312c 2063 656e  cube(size=1, cen
+00000b70: 7465 722c 2061 6e63 686f 722c 2073 7069  ter, anchor, spi
+00000b80: 6e3d 302c 206f 7269 656e 743d 5550 2920  n=0, orient=UP) 
+00000b90: 3d0a 2020 2020 6c65 7428 0a20 2020 2020  =.    let(.     
+00000ba0: 2020 2073 697a 203d 2073 6361 6c61 725f     siz = scalar_
+00000bb0: 7665 6333 2873 697a 6529 2c0a 2020 2020  vec3(size),.    
+00000bc0: 2020 2020 616e 6368 6f72 203d 2067 6574      anchor = get
+00000bd0: 5f61 6e63 686f 7228 616e 6368 6f72 2c20  _anchor(anchor, 
+00000be0: 6365 6e74 6572 2c20 2d5b 312c 312c 315d  center, -[1,1,1]
+00000bf0: 2c20 2d5b 312c 312c 315d 292c 0a20 2020  , -[1,1,1]),.   
+00000c00: 2020 2020 2075 6e73 6361 6c65 6420 3d20       unscaled = 
+00000c10: 5b0a 2020 2020 2020 2020 2020 2020 5b2d  [.            [-
+00000c20: 312c 2d31 2c2d 315d 2c5b 312c 2d31 2c2d  1,-1,-1],[1,-1,-
+00000c30: 315d 2c5b 312c 312c 2d31 5d2c 5b2d 312c  1],[1,1,-1],[-1,
+00000c40: 312c 2d31 5d2c 0a20 2020 2020 2020 2020  1,-1],.         
+00000c50: 2020 205b 2d31 2c2d 312c 2031 5d2c 5b31     [-1,-1, 1],[1
+00000c60: 2c2d 312c 2031 5d2c 5b31 2c31 2c20 315d  ,-1, 1],[1,1, 1]
+00000c70: 2c5b 2d31 2c31 2c20 315d 2c0a 2020 2020  ,[-1,1, 1],.    
+00000c80: 2020 2020 5d2f 322c 0a20 2020 2020 2020      ]/2,.       
+00000c90: 2076 6572 7473 203d 2069 735f 6e75 6d28   verts = is_num(
+00000ca0: 7369 7a65 293f 2075 6e73 6361 6c65 6420  size)? unscaled 
+00000cb0: 2a20 7369 7a65 203a 0a20 2020 2020 2020  * size :.       
+00000cc0: 2020 2020 2069 735f 7665 6374 6f72 2873       is_vector(s
+00000cd0: 697a 652c 3329 3f20 5b66 6f72 2028 703d  ize,3)? [for (p=
+00000ce0: 756e 7363 616c 6564 2920 765f 6d75 6c28  unscaled) v_mul(
+00000cf0: 702c 7369 7a65 295d 203a 0a20 2020 2020  p,size)] :.     
+00000d00: 2020 2020 2020 2061 7373 6572 7428 6973         assert(is
+00000d10: 5f6e 756d 2873 697a 6529 207c 7c20 6973  _num(size) || is
+00000d20: 5f76 6563 746f 7228 7369 7a65 2c33 2929  _vector(size,3))
+00000d30: 2c0a 2020 2020 2020 2020 6661 6365 7320  ,.        faces 
+00000d40: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+00000d50: 5b30 2c31 2c32 5d2c 205b 302c 322c 335d  [0,1,2], [0,2,3]
+00000d60: 2c20 202f 2f42 4f54 544f 4d0a 2020 2020  ,  //BOTTOM.    
+00000d70: 2020 2020 2020 2020 5b30 2c34 2c35 5d2c          [0,4,5],
+00000d80: 205b 302c 352c 315d 2c20 202f 2f46 524f   [0,5,1],  //FRO
+00000d90: 4e54 0a20 2020 2020 2020 2020 2020 205b  NT.            [
+00000da0: 312c 352c 365d 2c20 5b31 2c36 2c32 5d2c  1,5,6], [1,6,2],
+00000db0: 2020 2f2f 5249 4748 540a 2020 2020 2020    //RIGHT.      
+00000dc0: 2020 2020 2020 5b32 2c36 2c37 5d2c 205b        [2,6,7], [
+00000dd0: 322c 372c 335d 2c20 202f 2f42 4143 4b0a  2,7,3],  //BACK.
+00000de0: 2020 2020 2020 2020 2020 2020 5b33 2c37              [3,7
+00000df0: 2c34 5d2c 205b 332c 342c 305d 2c20 202f  ,4], [3,4,0],  /
+00000e00: 2f4c 4546 540a 2020 2020 2020 2020 2020  /LEFT.          
+00000e10: 2020 5b36 2c34 2c37 5d2c 205b 362c 352c    [6,4,7], [6,5,
+00000e20: 345d 2020 202f 2f54 4f50 0a20 2020 2020  4]   //TOP.     
+00000e30: 2020 205d 0a20 2020 2029 205b 7265 6f72     ].    ) [reor
+00000e40: 6965 6e74 2861 6e63 686f 722c 7370 696e  ient(anchor,spin
+00000e50: 2c6f 7269 656e 742c 2073 697a 653d 7369  ,orient, size=si
+00000e60: 7a2c 2070 3d76 6572 7473 292c 2066 6163  z, p=verts), fac
+00000e70: 6573 5d3b 0a0a 0a0a 2f2f 204d 6f64 756c  es];....// Modul
+00000e80: 653a 2063 7562 6f69 6428 290a 2f2f 2053  e: cuboid().// S
+00000e90: 796e 6f70 7369 733a 2043 7265 6174 6573  ynopsis: Creates
+00000ea0: 2061 2063 7562 6520 7769 7468 2063 6861   a cube with cha
+00000eb0: 6d66 6572 696e 6720 616e 6420 726f 756e  mfering and roun
+00000ec0: 646f 7665 7273 2c20 6f72 2072 6574 7572  dovers, or retur
+00000ed0: 6e73 2061 2076 6e66 2e0a 2f2f 2054 6f70  ns a vnf..// Top
+00000ee0: 6963 733a 2053 6861 7065 7320 2833 4429  ics: Shapes (3D)
+00000ef0: 2c20 4174 7461 6368 6162 6c65 2c20 564e  , Attachable, VN
+00000f00: 4620 4765 6e65 7261 746f 7273 0a2f 2f20  F Generators.// 
+00000f10: 5365 6520 416c 736f 3a20 7072 6973 6d6f  See Also: prismo
+00000f20: 6964 2829 2c20 726f 756e 6465 645f 7072  id(), rounded_pr
+00000f30: 6973 6d28 290a 2f2f 2055 7361 6765 3a20  ism().// Usage: 
+00000f40: 5374 616e 6461 7264 2043 7562 6573 0a2f  Standard Cubes./
+00000f50: 2f20 2020 6375 626f 6964 2873 697a 652c  /   cuboid(size,
+00000f60: 205b 616e 6368 6f72 3d5d 2c20 5b73 7069   [anchor=], [spi
+00000f70: 6e3d 5d2c 205b 6f72 6965 6e74 3d5d 293b  n=], [orient=]);
+00000f80: 0a2f 2f20 2020 6375 626f 6964 2873 697a  .//   cuboid(siz
+00000f90: 652c 2070 313d 2c20 2e2e 2e29 3b0a 2f2f  e, p1=, ...);.//
+00000fa0: 2020 2063 7562 6f69 6428 7031 3d2c 2070     cuboid(p1=, p
+00000fb0: 323d 2c20 2e2e 2e29 3b0a 2f2f 2055 7361  2=, ...);.// Usa
+00000fc0: 6765 3a20 4368 616d 6665 7265 6420 4375  ge: Chamfered Cu
+00000fd0: 6265 730a 2f2f 2020 2063 7562 6f69 6428  bes.//   cuboid(
+00000fe0: 7369 7a65 2c20 5b63 6861 6d66 6572 3d5d  size, [chamfer=]
+00000ff0: 2c20 5b65 6467 6573 3d5d 2c20 5b65 7863  , [edges=], [exc
+00001000: 6570 743d 5d2c 205b 7472 696d 636f 726e  ept=], [trimcorn
+00001010: 6572 733d 5d2c 202e 2e2e 293b 0a2f 2f20  ers=], ...);.// 
+00001020: 5573 6167 653a 2052 6f75 6e64 6564 2043  Usage: Rounded C
+00001030: 7562 6573 0a2f 2f20 2020 6375 626f 6964  ubes.//   cuboid
+00001040: 2873 697a 652c 205b 726f 756e 6469 6e67  (size, [rounding
+00001050: 3d5d 2c20 5b74 6561 7264 726f 703d 5d2c  =], [teardrop=],
+00001060: 205b 6564 6765 733d 5d2c 205b 6578 6365   [edges=], [exce
+00001070: 7074 3d5d 2c20 5b74 7269 6d63 6f72 6e65  pt=], [trimcorne
+00001080: 7273 3d5d 2c20 2e2e 2e29 3b0a 2f2f 2055  rs=], ...);.// U
+00001090: 7361 6765 3a20 4174 7461 6368 696e 6720  sage: Attaching 
+000010a0: 6368 696c 6472 656e 0a2f 2f20 2020 6375  children.//   cu
+000010b0: 626f 6964 282e 2e2e 2920 4154 5441 4348  boid(...) ATTACH
+000010c0: 4d45 4e54 533b 0a2f 2f0a 2f2f 2044 6573  MENTS;.//.// Des
+000010d0: 6372 6970 7469 6f6e 3a0a 2f2f 2020 2043  cription:.//   C
+000010e0: 7265 6174 6573 2061 2063 7562 6520 6f72  reates a cube or
+000010f0: 2063 7562 6f69 6420 6f62 6a65 6374 2c20   cuboid object, 
+00001100: 7769 7468 206f 7074 696f 6e61 6c20 6368  with optional ch
+00001110: 616d 6665 7269 6e67 206f 7220 726f 756e  amfering or roun
+00001120: 6469 6e67 206f 6620 6564 6765 7320 616e  ding of edges an
+00001130: 6420 636f 726e 6572 732e 0a2f 2f20 2020  d corners..//   
+00001140: 596f 7520 6361 6e6e 6f74 206d 6978 2063  You cannot mix c
+00001150: 6861 6d66 6572 696e 6720 616e 6420 726f  hamfering and ro
+00001160: 756e 6469 6e67 3a20 6a75 7374 206f 6e65  unding: just one
+00001170: 2065 6467 6520 7472 6561 746d 656e 7420   edge treatment 
+00001180: 7769 7468 2074 6865 2073 616d 6520 7369  with the same si
+00001190: 7a65 2061 7070 6c69 6573 2074 6f20 616c  ze applies to al
+000011a0: 6c20 7365 6c65 6374 6564 2065 6467 6573  l selected edges
+000011b0: 2e0a 2f2f 2020 204e 6567 6174 6976 6520  ..//   Negative 
+000011c0: 6368 616d 6665 7273 2061 6e64 2072 6f75  chamfers and rou
+000011d0: 6e64 696e 6773 2063 616e 2062 6520 6170  ndings can be ap
+000011e0: 706c 6965 6420 746f 2063 7265 6174 6520  plied to create 
+000011f0: 6578 7465 726e 616c 2066 696c 6c65 7473  external fillets
+00001200: 2c20 6275 7420 7468 6579 0a2f 2f20 2020  , but they.//   
+00001210: 6f6e 6c79 2061 7070 6c79 2074 6f20 6564  only apply to ed
+00001220: 6765 7320 6172 6f75 6e64 2074 6865 2074  ges around the t
+00001230: 6f70 206f 7220 626f 7474 6f6d 2066 6163  op or bottom fac
+00001240: 6573 2e20 2049 6620 796f 7520 7370 6563  es.  If you spec
+00001250: 6966 7920 616e 2065 6467 6520 7365 7420  ify an edge set 
+00001260: 6f74 6865 7220 7468 616e 2022 414c 4c22  other than "ALL"
+00001270: 0a2f 2f20 2020 7769 7468 206e 6567 6174  .//   with negat
+00001280: 6976 6520 726f 756e 6469 6e67 7320 6f72  ive roundings or
+00001290: 2063 6861 6d66 6572 7320 7468 656e 2079   chamfers then y
+000012a0: 6f75 2077 696c 6c20 6765 7420 616e 2065  ou will get an e
+000012b0: 7272 6f72 2e20 2053 6565 205b 5370 6563  rror.  See [Spec
+000012c0: 6966 7969 6e67 2045 6467 6573 5d28 6174  ifying Edges](at
+000012d0: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
+000012e0: 6563 7469 6f6e 2d73 7065 6369 6679 696e  ection-specifyin
+000012f0: 672d 6564 6765 7329 0a2f 2f20 2020 666f  g-edges).//   fo
+00001300: 7220 696e 666f 726d 6174 696f 6e20 6f6e  r information on
+00001310: 2068 6f77 2074 6f20 7370 6563 6966 7920   how to specify 
+00001320: 6564 6765 2073 6574 732e 0a2f 2f20 4172  edge sets..// Ar
+00001330: 6775 6d65 6e74 733a 0a2f 2f20 2020 7369  guments:.//   si
+00001340: 7a65 203d 2054 6865 2073 697a 6520 6f66  ze = The size of
+00001350: 2074 6865 2063 7562 652c 2061 206e 756d   the cube, a num
+00001360: 6265 7220 6f72 206c 656e 6774 6820 3320  ber or length 3 
+00001370: 7665 6374 6f72 2e0a 2f2f 2020 202d 2d2d  vector..//   ---
+00001380: 0a2f 2f20 2020 6368 616d 6665 7220 3d20  .//   chamfer = 
+00001390: 5369 7a65 206f 6620 6368 616d 6665 722c  Size of chamfer,
+000013a0: 2069 6e73 6574 2066 726f 6d20 7369 6465   inset from side
+000013b0: 732e 2020 4465 6661 756c 743a 204e 6f20  s.  Default: No 
+000013c0: 6368 616d 6665 7269 6e67 2e0a 2f2f 2020  chamfering..//  
+000013d0: 2072 6f75 6e64 696e 6720 3d20 5261 6469   rounding = Radi
+000013e0: 7573 206f 6620 7468 6520 6564 6765 2072  us of the edge r
+000013f0: 6f75 6e64 696e 672e 2020 4465 6661 756c  ounding.  Defaul
+00001400: 743a 204e 6f20 726f 756e 6469 6e67 2e0a  t: No rounding..
+00001410: 2f2f 2020 2065 6467 6573 203d 2045 6467  //   edges = Edg
+00001420: 6573 2074 6f20 6d61 736b 2e20 2053 6565  es to mask.  See
+00001430: 205b 5370 6563 6966 7969 6e67 2045 6467   [Specifying Edg
+00001440: 6573 5d28 6174 7461 6368 6d65 6e74 732e  es](attachments.
+00001450: 7363 6164 2373 6563 7469 6f6e 2d73 7065  scad#section-spe
+00001460: 6369 6679 696e 672d 6564 6765 7329 2e20  cifying-edges). 
+00001470: 2044 6566 6175 6c74 3a20 616c 6c20 6564   Default: all ed
+00001480: 6765 732e 0a2f 2f20 2020 6578 6365 7074  ges..//   except
+00001490: 203d 2045 6467 6573 2074 6f20 6578 706c   = Edges to expl
+000014a0: 6963 6974 6c79 204e 4f54 206d 6173 6b2e  icitly NOT mask.
+000014b0: 2020 5365 6520 5b53 7065 6369 6679 696e    See [Specifyin
+000014c0: 6720 4564 6765 735d 2861 7474 6163 686d  g Edges](attachm
+000014d0: 656e 7473 2e73 6361 6423 7365 6374 696f  ents.scad#sectio
+000014e0: 6e2d 7370 6563 6966 7969 6e67 2d65 6467  n-specifying-edg
+000014f0: 6573 292e 2020 4465 6661 756c 743a 204e  es).  Default: N
+00001500: 6f20 6564 6765 732e 0a2f 2f20 2020 7472  o edges..//   tr
+00001510: 696d 636f 726e 6572 7320 3d20 4966 2074  imcorners = If t
+00001520: 7275 652c 2072 6f75 6e64 7320 6f72 2063  rue, rounds or c
+00001530: 6861 6d66 6572 7320 636f 726e 6572 7320  hamfers corners 
+00001540: 7768 6572 6520 7468 7265 6520 6368 616d  where three cham
+00001550: 6665 7265 642f 726f 756e 6465 6420 6564  fered/rounded ed
+00001560: 6765 7320 6d65 6574 2e20 2044 6566 6175  ges meet.  Defau
+00001570: 6c74 3a20 6074 7275 6560 0a2f 2f20 2020  lt: `true`.//   
+00001580: 7465 6172 6472 6f70 203d 2049 6620 6769  teardrop = If gi
+00001590: 7665 6e20 6173 2061 206e 756d 6265 722c  ven as a number,
+000015a0: 2072 6f75 6e64 696e 6720 6172 6f75 6e64   rounding around
+000015b0: 2074 6865 2062 6f74 746f 6d20 6564 6765   the bottom edge
+000015c0: 206f 6620 7468 6520 6375 626f 6964 2077   of the cuboid w
+000015d0: 6f6e 2774 2065 7863 6565 6420 7468 6973  on't exceed this
+000015e0: 206d 616e 7920 6465 6772 6565 7320 6672   many degrees fr
+000015f0: 6f6d 2076 6572 7469 6361 6c2e 2020 4966  om vertical.  If
+00001600: 2074 7275 652c 2074 6865 206c 696d 6974   true, the limit
+00001610: 2061 6e67 6c65 2069 7320 3435 2064 6567   angle is 45 deg
+00001620: 7265 6573 2e20 2044 6566 6175 6c74 3a20  rees.  Default: 
+00001630: 6066 616c 7365 600a 2f2f 2020 2070 3120  `false`.//   p1 
+00001640: 3d20 416c 6967 6e20 7468 6520 6375 626f  = Align the cubo
+00001650: 6964 2773 2063 6f72 6e65 7220 6174 2060  id's corner at `
+00001660: 7031 602c 2069 6620 6769 7665 6e2e 2020  p1`, if given.  
+00001670: 466f 7263 6573 2060 616e 6368 6f72 3d46  Forces `anchor=F
+00001680: 524f 4e54 2b4c 4546 542b 424f 5454 4f4d  RONT+LEFT+BOTTOM
+00001690: 602e 0a2f 2f20 2020 7032 203d 2049 6620  `..//   p2 = If 
+000016a0: 6769 7665 6e20 7769 7468 2060 7031 602c  given with `p1`,
+000016b0: 2064 6566 696e 6573 2074 6865 2063 6f72   defines the cor
+000016c0: 6e65 7270 6f69 6e74 7320 6f66 2074 6865  nerpoints of the
+000016d0: 2063 7562 6f69 642e 0a2f 2f20 2020 616e   cuboid..//   an
+000016e0: 6368 6f72 203d 2054 7261 6e73 6c61 7465  chor = Translate
+000016f0: 2073 6f20 616e 6368 6f72 2070 6f69 6e74   so anchor point
+00001700: 2069 7320 6174 206f 7269 6769 6e20 2830   is at origin (0
+00001710: 2c30 2c30 292e 2020 5365 6520 5b61 6e63  ,0,0).  See [anc
+00001720: 686f 725d 2861 7474 6163 686d 656e 7473  hor](attachments
+00001730: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
+00001740: 2d61 6e63 686f 7229 2e20 2044 6566 6175  -anchor).  Defau
+00001750: 6c74 3a20 6043 454e 5445 5260 0a2f 2f20  lt: `CENTER`.// 
+00001760: 2020 7370 696e 203d 2052 6f74 6174 6520    spin = Rotate 
+00001770: 7468 6973 206d 616e 7920 6465 6772 6565  this many degree
+00001780: 7320 6172 6f75 6e64 2074 6865 205a 2061  s around the Z a
+00001790: 7869 732e 2020 5365 6520 5b73 7069 6e5d  xis.  See [spin]
+000017a0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+000017b0: 6423 7375 6273 6563 7469 6f6e 2d73 7069  d#subsection-spi
+000017c0: 6e29 2e20 2044 6566 6175 6c74 3a20 6030  n).  Default: `0
+000017d0: 600a 2f2f 2020 206f 7269 656e 7420 3d20  `.//   orient = 
+000017e0: 5665 6374 6f72 2074 6f20 726f 7461 7465  Vector to rotate
+000017f0: 2074 6f70 2074 6f77 6172 6473 2e20 2053   top towards.  S
+00001800: 6565 205b 6f72 6965 6e74 5d28 6174 7461  ee [orient](atta
+00001810: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00001820: 7365 6374 696f 6e2d 6f72 6965 6e74 292e  section-orient).
+00001830: 2020 4465 6661 756c 743a 2060 5550 600a    Default: `UP`.
+00001840: 2f2f 2045 7861 6d70 6c65 3a20 5369 6d70  // Example: Simp
+00001850: 6c65 2072 6567 756c 6172 2063 7562 652e  le regular cube.
+00001860: 0a2f 2f20 2020 6375 626f 6964 2834 3029  .//   cuboid(40)
+00001870: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4375  ;.// Example: Cu
+00001880: 6265 2077 6974 6820 6d69 6e69 6d75 6d20  be with minimum 
+00001890: 636f 726e 6572 706f 696e 7420 6769 7665  cornerpoint give
+000018a0: 6e2e 0a2f 2f20 2020 6375 626f 6964 2832  n..//   cuboid(2
+000018b0: 302c 2070 313d 5b31 302c 302c 305d 293b  0, p1=[10,0,0]);
+000018c0: 0a2f 2f20 4578 616d 706c 653a 2052 6563  .// Example: Rec
+000018d0: 7461 6e67 756c 6172 2063 7562 652c 2077  tangular cube, w
+000018e0: 6974 6820 6769 7665 6e20 582c 2059 2c20  ith given X, Y, 
+000018f0: 616e 6420 5a20 7369 7a65 732e 0a2f 2f20  and Z sizes..// 
+00001900: 2020 6375 626f 6964 285b 3230 2c34 302c    cuboid([20,40,
+00001910: 3530 5d29 3b0a 2f2f 2045 7861 6d70 6c65  50]);.// Example
+00001920: 3a20 4375 6265 2062 7920 4f70 706f 7369  : Cube by Opposi
+00001930: 6e67 2043 6f72 6e65 7273 2e0a 2f2f 2020  ng Corners..//  
+00001940: 2063 7562 6f69 6428 7031 3d5b 302c 3130   cuboid(p1=[0,10
+00001950: 2c30 5d2c 2070 323d 5b32 302c 3330 2c33  ,0], p2=[20,30,3
+00001960: 305d 293b 0a2f 2f20 4578 616d 706c 653a  0]);.// Example:
+00001970: 2043 6861 6d66 6572 7265 6420 4564 6765   Chamferred Edge
+00001980: 7320 616e 6420 436f 726e 6572 732e 0a2f  s and Corners../
+00001990: 2f20 2020 6375 626f 6964 285b 3330 2c34  /   cuboid([30,4
+000019a0: 302c 3530 5d2c 2063 6861 6d66 6572 3d35  0,50], chamfer=5
+000019b0: 293b 0a2f 2f20 4578 616d 706c 653a 2043  );.// Example: C
+000019c0: 6861 6d66 6572 7265 6420 4564 6765 732c  hamferred Edges,
+000019d0: 2055 6e74 7269 6d6d 6564 2043 6f72 6e65   Untrimmed Corne
+000019e0: 7273 2e0a 2f2f 2020 2063 7562 6f69 6428  rs..//   cuboid(
+000019f0: 5b33 302c 3430 2c35 305d 2c20 6368 616d  [30,40,50], cham
+00001a00: 6665 723d 352c 2074 7269 6d63 6f72 6e65  fer=5, trimcorne
+00001a10: 7273 3d66 616c 7365 293b 0a2f 2f20 4578  rs=false);.// Ex
+00001a20: 616d 706c 653a 2052 6f75 6e64 6564 2045  ample: Rounded E
+00001a30: 6467 6573 2061 6e64 2043 6f72 6e65 7273  dges and Corners
+00001a40: 0a2f 2f20 2020 6375 626f 6964 285b 3330  .//   cuboid([30
+00001a50: 2c34 302c 3530 5d2c 2072 6f75 6e64 696e  ,40,50], roundin
+00001a60: 673d 3130 293b 0a2f 2f20 4578 616d 706c  g=10);.// Exampl
+00001a70: 6528 5650 523d 5b31 3030 2c30 2c32 355d  e(VPR=[100,0,25]
+00001a80: 2c56 5044 3d31 3830 293a 2052 6f75 6e64  ,VPD=180): Round
+00001a90: 6564 2045 6467 6573 2061 6e64 2043 6f72  ed Edges and Cor
+00001aa0: 6e65 7273 2077 6974 6820 5465 6172 6472  ners with Teardr
+00001ab0: 6f70 2042 6f74 746f 6d73 0a2f 2f20 2020  op Bottoms.//   
+00001ac0: 6375 626f 6964 285b 3330 2c34 302c 3530  cuboid([30,40,50
+00001ad0: 5d2c 2072 6f75 6e64 696e 673d 3130 2c20  ], rounding=10, 
+00001ae0: 7465 6172 6472 6f70 3d74 7275 6529 3b0a  teardrop=true);.
+00001af0: 2f2f 2045 7861 6d70 6c65 3a20 526f 756e  // Example: Roun
+00001b00: 6465 6420 4564 6765 732c 2055 6e74 7269  ded Edges, Untri
+00001b10: 6d6d 6564 2043 6f72 6e65 7273 0a2f 2f20  mmed Corners.// 
+00001b20: 2020 6375 626f 6964 285b 3330 2c34 302c    cuboid([30,40,
+00001b30: 3530 5d2c 2072 6f75 6e64 696e 673d 3130  50], rounding=10
+00001b40: 2c20 7472 696d 636f 726e 6572 733d 6661  , trimcorners=fa
+00001b50: 6c73 6529 3b0a 2f2f 2045 7861 6d70 6c65  lse);.// Example
+00001b60: 3a20 4368 616d 6665 7272 696e 6720 5365  : Chamferring Se
+00001b70: 6c65 6374 6564 2045 6467 6573 0a2f 2f20  lected Edges.// 
+00001b80: 2020 6375 626f 6964 280a 2f2f 2020 2020    cuboid(.//    
+00001b90: 2020 205b 3330 2c34 302c 3530 5d2c 2063     [30,40,50], c
+00001ba0: 6861 6d66 6572 3d35 2c0a 2f2f 2020 2020  hamfer=5,.//    
+00001bb0: 2020 2065 6467 6573 3d5b 544f 502b 4652     edges=[TOP+FR
+00001bc0: 4f4e 542c 544f 502b 5249 4748 542c 4652  ONT,TOP+RIGHT,FR
+00001bd0: 4f4e 542b 5249 4748 545d 2c0a 2f2f 2020  ONT+RIGHT],.//  
+00001be0: 2020 2020 2024 666e 3d32 340a 2f2f 2020       $fn=24.//  
+00001bf0: 2029 3b0a 2f2f 2045 7861 6d70 6c65 3a20   );.// Example: 
+00001c00: 526f 756e 6469 6e67 2053 656c 6563 7465  Rounding Selecte
+00001c10: 6420 4564 6765 730a 2f2f 2020 2063 7562  d Edges.//   cub
+00001c20: 6f69 6428 0a2f 2f20 2020 2020 2020 5b33  oid(.//       [3
+00001c30: 302c 3430 2c35 305d 2c20 726f 756e 6469  0,40,50], roundi
+00001c40: 6e67 3d35 2c0a 2f2f 2020 2020 2020 2065  ng=5,.//       e
+00001c50: 6467 6573 3d5b 544f 502b 4652 4f4e 542c  dges=[TOP+FRONT,
+00001c60: 544f 502b 5249 4748 542c 4652 4f4e 542b  TOP+RIGHT,FRONT+
+00001c70: 5249 4748 545d 2c0a 2f2f 2020 2020 2020  RIGHT],.//      
+00001c80: 2024 666e 3d32 340a 2f2f 2020 2029 3b0a   $fn=24.//   );.
+00001c90: 2f2f 2045 7861 6d70 6c65 3a20 4e65 6761  // Example: Nega
+00001ca0: 7469 7665 2043 6861 6d66 6572 7269 6e67  tive Chamferring
+00001cb0: 0a2f 2f20 2020 6375 626f 6964 280a 2f2f  .//   cuboid(.//
+00001cc0: 2020 2020 2020 205b 3330 2c34 302c 3530         [30,40,50
+00001cd0: 5d2c 2063 6861 6d66 6572 3d2d 352c 0a2f  ], chamfer=-5,./
+00001ce0: 2f20 2020 2020 2020 6564 6765 733d 5b54  /       edges=[T
+00001cf0: 4f50 2c42 4f54 5d2c 2065 7863 6570 743d  OP,BOT], except=
+00001d00: 5249 4748 542c 0a2f 2f20 2020 2020 2020  RIGHT,.//       
+00001d10: 2466 6e3d 3234 0a2f 2f20 2020 293b 0a2f  $fn=24.//   );./
+00001d20: 2f20 4578 616d 706c 653a 204e 6567 6174  / Example: Negat
+00001d30: 6976 6520 4368 616d 6665 7272 696e 672c  ive Chamferring,
+00001d40: 2055 6e74 7269 6d6d 6564 2043 6f72 6e65   Untrimmed Corne
+00001d50: 7273 0a2f 2f20 2020 6375 626f 6964 280a  rs.//   cuboid(.
+00001d60: 2f2f 2020 2020 2020 205b 3330 2c34 302c  //       [30,40,
+00001d70: 3530 5d2c 2063 6861 6d66 6572 3d2d 352c  50], chamfer=-5,
+00001d80: 0a2f 2f20 2020 2020 2020 6564 6765 733d  .//       edges=
+00001d90: 5b54 4f50 2c42 4f54 5d2c 2065 7863 6570  [TOP,BOT], excep
+00001da0: 743d 5249 4748 542c 0a2f 2f20 2020 2020  t=RIGHT,.//     
+00001db0: 2020 7472 696d 636f 726e 6572 733d 6661    trimcorners=fa
+00001dc0: 6c73 652c 2024 666e 3d32 340a 2f2f 2020  lse, $fn=24.//  
+00001dd0: 2029 3b0a 2f2f 2045 7861 6d70 6c65 3a20   );.// Example: 
+00001de0: 4e65 6761 7469 7665 2052 6f75 6e64 696e  Negative Roundin
+00001df0: 670a 2f2f 2020 2063 7562 6f69 6428 0a2f  g.//   cuboid(./
+00001e00: 2f20 2020 2020 2020 5b33 302c 3430 2c35  /       [30,40,5
+00001e10: 305d 2c20 726f 756e 6469 6e67 3d2d 352c  0], rounding=-5,
+00001e20: 0a2f 2f20 2020 2020 2020 6564 6765 733d  .//       edges=
+00001e30: 5b54 4f50 2c42 4f54 5d2c 2065 7863 6570  [TOP,BOT], excep
+00001e40: 743d 5249 4748 542c 0a2f 2f20 2020 2020  t=RIGHT,.//     
+00001e50: 2020 2466 6e3d 3234 0a2f 2f20 2020 293b    $fn=24.//   );
+00001e60: 0a2f 2f20 4578 616d 706c 653a 204e 6567  .// Example: Neg
+00001e70: 6174 6976 6520 526f 756e 6469 6e67 2c20  ative Rounding, 
+00001e80: 556e 7472 696d 6d65 6420 436f 726e 6572  Untrimmed Corner
+00001e90: 730a 2f2f 2020 2063 7562 6f69 6428 0a2f  s.//   cuboid(./
+00001ea0: 2f20 2020 2020 2020 5b33 302c 3430 2c35  /       [30,40,5
+00001eb0: 305d 2c20 726f 756e 6469 6e67 3d2d 352c  0], rounding=-5,
+00001ec0: 0a2f 2f20 2020 2020 2020 6564 6765 733d  .//       edges=
+00001ed0: 5b54 4f50 2c42 4f54 5d2c 2065 7863 6570  [TOP,BOT], excep
+00001ee0: 743d 5249 4748 542c 0a2f 2f20 2020 2020  t=RIGHT,.//     
+00001ef0: 2020 7472 696d 636f 726e 6572 733d 6661    trimcorners=fa
+00001f00: 6c73 652c 2024 666e 3d32 340a 2f2f 2020  lse, $fn=24.//  
+00001f10: 2029 3b0a 2f2f 2045 7861 6d70 6c65 3a20   );.// Example: 
+00001f20: 526f 756e 6469 6e67 7320 616e 6420 4368  Roundings and Ch
+00001f30: 616d 6665 7273 2063 616e 2062 6520 6173  amfers can be as
+00001f40: 206c 6172 6765 2061 7320 7468 6520 6675   large as the fu
+00001f50: 6c6c 2073 697a 6520 6f66 2074 6865 2063  ll size of the c
+00001f60: 7562 6f69 642c 2073 6f20 6c6f 6e67 2061  uboid, so long a
+00001f70: 7320 7468 6520 6564 6765 7320 776f 756c  s the edges woul
+00001f80: 6420 6e6f 7420 696e 7465 7266 6572 652e  d not interfere.
+00001f90: 0a2f 2f20 2020 6375 626f 6964 285b 3430  .//   cuboid([40
+00001fa0: 2c32 302c 3130 5d2c 2072 6f75 6e64 696e  ,20,10], roundin
+00001fb0: 673d 3230 2c20 6564 6765 733d 5b46 5744  g=20, edges=[FWD
+00001fc0: 2b52 4947 4854 2c42 4143 4b2b 4c45 4654  +RIGHT,BACK+LEFT
+00001fd0: 5d29 3b0a 2f2f 2045 7861 6d70 6c65 3a20  ]);.// Example: 
+00001fe0: 5374 616e 6461 7264 2043 6f6e 6e65 6374  Standard Connect
+00001ff0: 6f72 730a 2f2f 2020 2063 7562 6f69 6428  ors.//   cuboid(
+00002000: 3430 2920 7368 6f77 5f61 6e63 686f 7273  40) show_anchors
+00002010: 2829 3b0a 0a6d 6f64 756c 6520 6375 626f  ();..module cubo
+00002020: 6964 280a 2020 2020 7369 7a65 3d5b 312c  id(.    size=[1,
+00002030: 312c 315d 2c0a 2020 2020 7031 2c20 7032  1,1],.    p1, p2
+00002040: 2c0a 2020 2020 6368 616d 6665 722c 0a20  ,.    chamfer,. 
+00002050: 2020 2072 6f75 6e64 696e 672c 0a20 2020     rounding,.   
+00002060: 2065 6467 6573 3d45 4447 4553 5f41 4c4c   edges=EDGES_ALL
+00002070: 2c0a 2020 2020 6578 6365 7074 3d5b 5d2c  ,.    except=[],
+00002080: 0a20 2020 2065 7863 6570 745f 6564 6765  .    except_edge
+00002090: 732c 0a20 2020 2074 7269 6d63 6f72 6e65  s,.    trimcorne
+000020a0: 7273 3d74 7275 652c 0a20 2020 2074 6561  rs=true,.    tea
+000020b0: 7264 726f 703d 6661 6c73 652c 0a20 2020  rdrop=false,.   
+000020c0: 2061 6e63 686f 723d 4345 4e54 4552 2c0a   anchor=CENTER,.
+000020d0: 2020 2020 7370 696e 3d30 2c0a 2020 2020      spin=0,.    
+000020e0: 6f72 6965 6e74 3d55 500a 2920 7b0a 2020  orient=UP.) {.  
+000020f0: 2020 6d6f 6475 6c65 2074 7275 6e63 5f63    module trunc_c
+00002100: 7562 6528 732c 636f 726e 6572 2920 7b0a  ube(s,corner) {.
+00002110: 2020 2020 2020 2020 6d75 6c74 6d61 7472          multmatr
+00002120: 6978 280a 2020 2020 2020 2020 2020 2020  ix(.            
+00002130: 2863 6f72 6e65 722e 783c 303f 2078 666c  (corner.x<0? xfl
+00002140: 6970 2829 203a 2069 6465 6e74 2834 2929  ip() : ident(4))
+00002150: 202a 0a20 2020 2020 2020 2020 2020 2028   *.            (
+00002160: 636f 726e 6572 2e79 3c30 3f20 7966 6c69  corner.y<0? yfli
+00002170: 7028 2920 3a20 6964 656e 7428 3429 2920  p() : ident(4)) 
+00002180: 2a0a 2020 2020 2020 2020 2020 2020 2863  *.            (c
+00002190: 6f72 6e65 722e 7a3c 303f 207a 666c 6970  orner.z<0? zflip
+000021a0: 2829 203a 2069 6465 6e74 2834 2929 202a  () : ident(4)) *
+000021b0: 0a20 2020 2020 2020 2020 2020 2073 6361  .            sca
+000021c0: 6c65 2873 2b5b 312c 312c 315d 2a30 2e30  le(s+[1,1,1]*0.0
+000021d0: 3031 2920 2a0a 2020 2020 2020 2020 2020  01) *.          
+000021e0: 2020 6d6f 7665 282d 5b31 2c31 2c31 5d2f    move(-[1,1,1]/
+000021f0: 3229 0a20 2020 2020 2020 2029 2070 6f6c  2).        ) pol
+00002200: 7968 6564 726f 6e28 0a20 2020 2020 2020  yhedron(.       
+00002210: 2020 2020 205b 5b31 2c31 2c31 5d2c 5b31       [[1,1,1],[1
+00002220: 2c31 2c30 5d2c 5b31 2c30 2c30 5d2c 5b30  ,1,0],[1,0,0],[0
+00002230: 2c31 2c31 5d2c 5b30 2c31 2c30 5d2c 5b31  ,1,1],[0,1,0],[1
+00002240: 2c30 2c31 5d2c 5b30 2c30 2c31 5d5d 2c0a  ,0,1],[0,0,1]],.
+00002250: 2020 2020 2020 2020 2020 2020 5b5b 302c              [[0,
+00002260: 312c 325d 2c5b 322c 352c 305d 2c5b 302c  1,2],[2,5,0],[0,
+00002270: 352c 365d 2c5b 302c 362c 335d 2c5b 302c  5,6],[0,6,3],[0,
+00002280: 332c 345d 2c5b 302c 342c 315d 2c5b 312c  3,4],[0,4,1],[1,
+00002290: 342c 325d 2c5b 332c 362c 345d 2c5b 352c  4,2],[3,6,4],[5,
+000022a0: 322c 365d 2c5b 322c 342c 365d 5d0a 2020  2,6],[2,4,6]].  
+000022b0: 2020 2020 2020 293b 0a20 2020 207d 0a20        );.    }. 
+000022c0: 2020 206d 6f64 756c 6520 7874 6379 6c28     module xtcyl(
+000022d0: 6c2c 7229 207b 0a20 2020 2020 2020 2069  l,r) {.        i
+000022e0: 6620 2874 6561 7264 726f 7029 207b 0a20  f (teardrop) {. 
+000022f0: 2020 2020 2020 2020 2020 2074 6561 7264             teard
+00002300: 726f 7028 723d 722c 206c 3d6c 2c20 6361  rop(r=r, l=l, ca
+00002310: 705f 683d 722c 2061 6e67 3d74 6561 7264  p_h=r, ang=teard
+00002320: 726f 702c 2073 7069 6e3d 3930 2c20 6f72  rop, spin=90, or
+00002330: 6965 6e74 3d44 4f57 4e29 3b0a 2020 2020  ient=DOWN);.    
+00002340: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
+00002350: 2020 2020 2020 2020 2079 726f 7428 3930           yrot(90
+00002360: 2920 6379 6c28 6c3d 6c2c 2072 3d72 293b  ) cyl(l=l, r=r);
+00002370: 0a20 2020 2020 2020 207d 0a20 2020 207d  .        }.    }
+00002380: 0a20 2020 206d 6f64 756c 6520 7974 6379  .    module ytcy
+00002390: 6c28 6c2c 7229 207b 0a20 2020 2020 2020  l(l,r) {.       
+000023a0: 2069 6620 2874 6561 7264 726f 7029 207b   if (teardrop) {
+000023b0: 0a20 2020 2020 2020 2020 2020 2074 6561  .            tea
+000023c0: 7264 726f 7028 723d 722c 206c 3d6c 2c20  rdrop(r=r, l=l, 
+000023d0: 6361 705f 683d 722c 2061 6e67 3d74 6561  cap_h=r, ang=tea
+000023e0: 7264 726f 702c 2073 7069 6e3d 302c 206f  rdrop, spin=0, o
+000023f0: 7269 656e 743d 444f 574e 293b 0a20 2020  rient=DOWN);.   
+00002400: 2020 2020 207d 2065 6c73 6520 7b0a 2020       } else {.  
+00002410: 2020 2020 2020 2020 2020 7a72 6f74 2839            zrot(9
+00002420: 3029 2079 726f 7428 3930 2920 6379 6c28  0) yrot(90) cyl(
+00002430: 6c3d 6c2c 2072 3d72 293b 0a20 2020 2020  l=l, r=r);.     
+00002440: 2020 207d 0a20 2020 207d 0a20 2020 206d     }.    }.    m
+00002450: 6f64 756c 6520 7473 7068 6572 6528 7229  odule tsphere(r)
+00002460: 207b 0a20 2020 2020 2020 2069 6620 2874   {.        if (t
+00002470: 6561 7264 726f 7029 207b 0a20 2020 2020  eardrop) {.     
+00002480: 2020 2020 2020 206f 6e69 6f6e 2872 3d72         onion(r=r
+00002490: 2c20 6361 705f 683d 722c 2061 6e67 3d74  , cap_h=r, ang=t
+000024a0: 6561 7264 726f 702c 206f 7269 656e 743d  eardrop, orient=
+000024b0: 444f 574e 293b 0a20 2020 2020 2020 207d  DOWN);.        }
+000024c0: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
+000024d0: 2020 2020 7370 6865 726f 6964 2872 3d72      spheroid(r=r
+000024e0: 2c20 7374 796c 653d 226f 6374 6122 2c20  , style="octa", 
+000024f0: 6f72 6965 6e74 3d44 4f57 4e29 3b0a 2020  orient=DOWN);.  
+00002500: 2020 2020 2020 7d0a 2020 2020 7d0a 2020        }.    }.  
+00002510: 2020 6d6f 6475 6c65 2063 6f72 6e65 725f    module corner_
+00002520: 7368 6170 6528 636f 726e 6572 2920 7b0a  shape(corner) {.
+00002530: 2020 2020 2020 2020 6520 3d20 5f63 6f72          e = _cor
+00002540: 6e65 725f 6564 6765 7328 6564 6765 732c  ner_edges(edges,
+00002550: 2063 6f72 6e65 7229 3b0a 2020 2020 2020   corner);.      
+00002560: 2020 636e 7420 3d20 7375 6d28 6529 3b0a    cnt = sum(e);.
+00002570: 2020 2020 2020 2020 7220 3d20 6669 7273          r = firs
+00002580: 745f 6465 6669 6e65 6428 5b63 6861 6d66  t_defined([chamf
+00002590: 6572 2c20 726f 756e 6469 6e67 5d29 3b0a  er, rounding]);.
+000025a0: 2020 2020 2020 2020 6475 6d6d 7920 3d20          dummy = 
+000025b0: 6173 7365 7274 2869 735f 6669 6e69 7465  assert(is_finite
+000025c0: 2872 2920 2626 2021 6170 7072 6f78 2872  (r) && !approx(r
+000025d0: 2c30 2929 3b0a 2020 2020 2020 2020 6320  ,0));.        c 
+000025e0: 3d20 5b72 2c72 2c72 5d3b 0a20 2020 2020  = [r,r,r];.     
+000025f0: 2020 206d 203d 2030 2e30 313b 0a20 2020     m = 0.01;.   
+00002600: 2020 2020 2063 3220 3d20 765f 6d75 6c28       c2 = v_mul(
+00002610: 636f 726e 6572 2c63 2f32 293b 0a20 2020  corner,c/2);.   
+00002620: 2020 2020 2063 3320 3d20 765f 6d75 6c28       c3 = v_mul(
+00002630: 636f 726e 6572 2c63 2d5b 312c 312c 315d  corner,c-[1,1,1]
+00002640: 2a6d 2f32 293b 0a20 2020 2020 2020 2024  *m/2);.        $
+00002650: 666e 203d 2069 735f 6669 6e69 7465 2863  fn = is_finite(c
+00002660: 6861 6d66 6572 293f 2034 203a 2071 7561  hamfer)? 4 : qua
+00002670: 6e74 7570 2873 6567 7328 7229 2c34 293b  ntup(segs(r),4);
+00002680: 0a20 2020 2020 2020 2074 7261 6e73 6c61  .        transla
+00002690: 7465 2876 5f6d 756c 2863 6f72 6e65 722c  te(v_mul(corner,
+000026a0: 2073 697a 652f 322d 6329 2920 7b0a 2020   size/2-c)) {.  
+000026b0: 2020 2020 2020 2020 2020 6966 2028 636e            if (cn
+000026c0: 7420 3d3d 2030 207c 7c20 6170 7072 6f78  t == 0 || approx
+000026d0: 2872 2c30 2929 207b 0a20 2020 2020 2020  (r,0)) {.       
+000026e0: 2020 2020 2020 2020 2074 7261 6e73 6c61           transla
+000026f0: 7465 2863 3329 2063 7562 6528 6d2c 2063  te(c3) cube(m, c
+00002700: 656e 7465 723d 7472 7565 293b 0a20 2020  enter=true);.   
+00002710: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
+00002720: 6966 2028 636e 7420 3d3d 2031 2920 7b0a  if (cnt == 1) {.
+00002730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002740: 6966 2028 652e 7829 207b 0a20 2020 2020  if (e.x) {.     
+00002750: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00002760: 6967 6874 2863 332e 7829 207b 0a20 2020  ight(c3.x) {.   
 00002770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002780: 2020 2020 206c 696e 6561 725f 6578 7472       linear_extr
-00002790: 7564 6528 6865 6967 6874 3d6d 2b30 2e31  ude(height=m+0.1
-000027a0: 2c20 6365 6e74 6572 3d74 7275 6529 0a20  , center=true). 
-000027b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027d0: 2020 2073 6361 6c65 2872 2b30 2e30 3229     scale(r+0.02)
-000027e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002780: 2020 2020 2069 6e74 6572 7365 6374 696f       intersectio
+00002790: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
+000027a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000027b0: 2020 7874 6379 6c28 6c3d 6d2c 2072 3d72    xtcyl(l=m, r=r
+000027c0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+000027d0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000027e0: 756c 746d 6174 7269 7828 0a20 2020 2020  ultmatrix(.     
 000027f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002800: 2020 2020 2020 2020 2070 6f6c 7967 6f6e           polygon
-00002810: 285b 5b31 2c30 5d2c 5b30 2c31 5d2c 5b31  ([[1,0],[0,1],[1
-00002820: 2c31 5d5d 293b 0a20 2020 2020 2020 2020  ,1]]);.         
-00002830: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00002840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002850: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00002860: 2020 2020 2020 207d 2065 6c73 6520 6966         } else if
-00002870: 2028 652e 7929 207b 0a20 2020 2020 2020   (e.y) {.       
-00002880: 2020 2020 2020 2020 2020 2020 206d 6174               mat
-00002890: 203d 2028 636f 726e 6572 2e78 3c30 3f20   = (corner.x<0? 
-000028a0: 7866 6c69 7028 2920 3a20 6964 656e 7428  xflip() : ident(
-000028b0: 3429 2920 2a0a 2020 2020 2020 2020 2020  4)) *.          
-000028c0: 2020 2020 2020 2020 2020 2020 2020 2863                (c
-000028d0: 6f72 6e65 722e 7a3c 303f 207a 666c 6970  orner.z<0? zflip
-000028e0: 2829 203a 2069 6465 6e74 2834 2929 202a  () : ident(4)) *
-000028f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002900: 2020 2020 2020 2020 2078 726f 7428 3930           xrot(90
-00002910: 2920 2a20 6d6f 7665 282d 5b31 2c31 5d2a  ) * move(-[1,1]*
-00002920: 302e 3031 293b 0a20 2020 2020 2020 2020  0.01);.         
-00002930: 2020 2020 2020 2020 2020 2062 6163 6b28             back(
-00002940: 6333 2e79 2920 7b0a 2020 2020 2020 2020  c3.y) {.        
-00002950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002960: 696e 7465 7273 6563 7469 6f6e 2829 207b  intersection() {
-00002970: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002980: 2020 2020 2020 2020 2020 2020 2079 7463               ytc
-00002990: 796c 286c 3d6d 2c20 723d 7229 3b0a 2020  yl(l=m, r=r);.  
-000029a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029b0: 2020 2020 2020 2020 2020 6d75 6c74 6d61            multma
-000029c0: 7472 6978 286d 6174 290a 2020 2020 2020  trix(mat).      
-000029d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029e0: 2020 2020 2020 2020 2020 6c69 6e65 6172            linear
-000029f0: 5f65 7874 7275 6465 2868 6569 6768 743d  _extrude(height=
-00002a00: 6d2b 302e 312c 2063 656e 7465 723d 7472  m+0.1, center=tr
-00002a10: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
+00002800: 2020 2020 2020 2020 2020 2028 636f 726e             (corn
+00002810: 6572 2e79 3c30 3f20 7966 6c69 7028 2920  er.y<0? yflip() 
+00002820: 3a20 6964 656e 7428 3429 2920 2a0a 2020  : ident(4)) *.  
+00002830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002840: 2020 2020 2020 2020 2020 2020 2020 2863                (c
+00002850: 6f72 6e65 722e 7a3c 303f 207a 666c 6970  orner.z<0? zflip
+00002860: 2829 203a 2069 6465 6e74 2834 2929 0a20  () : ident(4)). 
+00002870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002880: 2020 2020 2020 2020 2020 2029 207b 0a20             ) {. 
+00002890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000028a0: 2020 2020 2020 2020 2020 2020 2020 2079                 y
+000028b0: 726f 7428 2d39 3029 206c 696e 6561 725f  rot(-90) linear_
+000028c0: 6578 7472 7564 6528 6865 6967 6874 3d6d  extrude(height=m
+000028d0: 2b30 2e31 2c20 6365 6e74 6572 3d74 7275  +0.1, center=tru
+000028e0: 6529 207b 0a20 2020 2020 2020 2020 2020  e) {.           
+000028f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002900: 2020 2020 2020 2020 2070 6f6c 7967 6f6e           polygon
+00002910: 285b 5b72 2c30 5d2c 5b30 2e39 3939 2a72  ([[r,0],[0.999*r
+00002920: 2c30 5d2c 5b30 2c30 2e39 3939 2a72 5d2c  ,0],[0,0.999*r],
+00002930: 5b30 2c72 5d2c 5b72 2c72 5d5d 293b 0a20  [0,r],[r,r]]);. 
+00002940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002950: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00002960: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002970: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00002980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002990: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000029a0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+000029b0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+000029c0: 2065 6c73 6520 6966 2028 652e 7929 207b   else if (e.y) {
+000029d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000029e0: 2020 2020 2062 6163 6b28 6333 2e79 2920       back(c3.y) 
+000029f0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00002a00: 2020 2020 2020 2020 2020 696e 7465 7273            inters
+00002a10: 6563 7469 6f6e 2829 207b 0a20 2020 2020  ection() {.     
 00002a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a30: 2020 2020 2020 2020 7363 616c 6528 722b          scale(r+
-00002a40: 302e 3032 290a 2020 2020 2020 2020 2020  0.02).          
+00002a30: 2020 2020 2020 2079 7463 796c 286c 3d6d         ytcyl(l=m
+00002a40: 2c20 723d 7229 3b0a 2020 2020 2020 2020  , r=r);.        
 00002a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002a60: 2020 2020 2020 2020 2020 2020 2020 706f                po
-00002a70: 6c79 676f 6e28 5b5b 312c 305d 2c5b 302c  lygon([[1,0],[0,
-00002a80: 315d 2c5b 312c 315d 5d29 3b0a 2020 2020  1],[1,1]]);.    
-00002a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002aa0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00002ab0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00002ac0: 2020 2020 2020 2020 2020 2020 7d20 656c              } el
-00002ad0: 7365 2069 6620 2865 2e7a 2920 7b0a 2020  se if (e.z) {.  
-00002ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002af0: 2020 6d61 7420 3d20 2863 6f72 6e65 722e    mat = (corner.
-00002b00: 783c 303f 2078 666c 6970 2829 203a 2069  x<0? xflip() : i
-00002b10: 6465 6e74 2834 2929 202a 0a20 2020 2020  dent(4)) *.     
+00002a60: 2020 2020 6d75 6c74 6d61 7472 6978 280a      multmatrix(.
+00002a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a90: 2863 6f72 6e65 722e 783c 303f 2078 666c  (corner.x<0? xfl
+00002aa0: 6970 2829 203a 2069 6465 6e74 2834 2929  ip() : ident(4))
+00002ab0: 202a 0a20 2020 2020 2020 2020 2020 2020   *.             
+00002ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ad0: 2020 2028 636f 726e 6572 2e7a 3c30 3f20     (corner.z<0? 
+00002ae0: 7a66 6c69 7028 2920 3a20 6964 656e 7428  zflip() : ident(
+00002af0: 3429 290a 2020 2020 2020 2020 2020 2020  4)).            
+00002b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002b10: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
 00002b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b30: 2020 2028 636f 726e 6572 2e79 3c30 3f20     (corner.y<0? 
-00002b40: 7966 6c69 7028 2920 3a20 6964 656e 7428  yflip() : ident(
-00002b50: 3429 2920 2a0a 2020 2020 2020 2020 2020  4)) *.          
-00002b60: 2020 2020 2020 2020 2020 2020 2020 6d6f                mo
-00002b70: 7665 282d 5b31 2c31 5d2a 302e 3031 293b  ve(-[1,1]*0.01);
-00002b80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002b90: 2020 2020 2075 7028 6333 2e7a 2920 7b0a       up(c3.z) {.
-00002ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bb0: 2020 2020 2020 2020 696e 7465 7273 6563          intersec
-00002bc0: 7469 6f6e 2829 207b 0a20 2020 2020 2020  tion() {.       
+00002b30: 2020 2020 7872 6f74 2839 3029 206c 696e      xrot(90) lin
+00002b40: 6561 725f 6578 7472 7564 6528 6865 6967  ear_extrude(heig
+00002b50: 6874 3d6d 2b30 2e31 2c20 6365 6e74 6572  ht=m+0.1, center
+00002b60: 3d74 7275 6529 207b 0a20 2020 2020 2020  =true) {.       
+00002b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002b80: 2020 2020 2020 2020 2020 2020 2070 6f6c               pol
+00002b90: 7967 6f6e 285b 5b72 2c30 5d2c 5b30 2e39  ygon([[r,0],[0.9
+00002ba0: 3939 2a72 2c30 5d2c 5b30 2c30 2e39 3939  99*r,0],[0,0.999
+00002bb0: 2a72 5d2c 5b30 2c72 5d2c 5b72 2c72 5d5d  *r],[0,r],[r,r]]
+00002bc0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
 00002bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002be0: 2020 2020 207a 6379 6c28 6c3d 6d2c 2072       zcyl(l=m, r
-00002bf0: 3d72 293b 0a20 2020 2020 2020 2020 2020  =r);.           
-00002c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c10: 206d 756c 746d 6174 7269 7828 6d61 7429   multmatrix(mat)
-00002c20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c40: 206c 696e 6561 725f 6578 7472 7564 6528   linear_extrude(
-00002c50: 6865 6967 6874 3d6d 2b30 2e31 2c20 6365  height=m+0.1, ce
-00002c60: 6e74 6572 3d74 7275 6529 0a20 2020 2020  nter=true).     
-00002c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002c80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00002c90: 6361 6c65 2872 2b30 2e30 3229 0a20 2020  cale(r+0.02).   
+00002be0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00002bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c00: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00002c10: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00002c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c30: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00002c40: 2020 207d 2065 6c73 6520 6966 2028 652e     } else if (e.
+00002c50: 7a29 207b 0a20 2020 2020 2020 2020 2020  z) {.           
+00002c60: 2020 2020 2020 2020 2075 7028 6333 2e7a           up(c3.z
+00002c70: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00002c80: 2020 2020 2020 2020 2020 2020 696e 7465              inte
+00002c90: 7273 6563 7469 6f6e 2829 207b 0a20 2020  rsection() {.   
 00002ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002cc0: 2020 2020 2070 6f6c 7967 6f6e 285b 5b31       polygon([[1
-00002cd0: 2c30 5d2c 5b30 2c31 5d2c 5b31 2c31 5d5d  ,0],[0,1],[1,1]]
-00002ce0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00002cf0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00002cb0: 2020 2020 2020 2020 207a 6379 6c28 6c3d           zcyl(l=
+00002cc0: 6d2c 2072 3d72 293b 0a20 2020 2020 2020  m, r=r);.       
+00002cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ce0: 2020 2020 206d 756c 746d 6174 7269 7828       multmatrix(
+00002cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00002d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d10: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-00002d20: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00002d30: 207d 2065 6c73 6520 6966 2028 636e 7420   } else if (cnt 
-00002d40: 3d3d 2032 2920 7b0a 2020 2020 2020 2020  == 2) {.        
-00002d50: 2020 2020 2020 2020 696e 7465 7273 6563          intersec
-00002d60: 7469 6f6e 2829 207b 0a20 2020 2020 2020  tion() {.       
-00002d70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00002d80: 2821 652e 7829 207b 0a20 2020 2020 2020  (!e.x) {.       
-00002d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002da0: 2069 6e74 6572 7365 6374 696f 6e28 2920   intersection() 
-00002db0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00002dc0: 2020 2020 2020 2020 2020 2020 2020 7974                yt
-00002dd0: 6379 6c28 6c3d 632e 792a 322c 2072 3d72  cyl(l=c.y*2, r=r
-00002de0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00002df0: 2020 2020 2020 2020 2020 2020 2020 207a                 z
-00002e00: 6379 6c28 6c3d 632e 7a2a 322c 2072 3d72  cyl(l=c.z*2, r=r
-00002e10: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00002e20: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-00002e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e40: 207d 2065 6c73 6520 6966 2028 2165 2e79   } else if (!e.y
-00002e50: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00002e60: 2020 2020 2020 2020 2020 2020 696e 7465              inte
-00002e70: 7273 6563 7469 6f6e 2829 207b 0a20 2020  rsection() {.   
+00002d10: 2028 636f 726e 6572 2e78 3c30 3f20 7866   (corner.x<0? xf
+00002d20: 6c69 7028 2920 3a20 6964 656e 7428 3429  lip() : ident(4)
+00002d30: 2920 2a0a 2020 2020 2020 2020 2020 2020  ) *.            
+00002d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d50: 2020 2020 2863 6f72 6e65 722e 793c 303f      (corner.y<0?
+00002d60: 2079 666c 6970 2829 203a 2069 6465 6e74   yflip() : ident
+00002d70: 2834 2929 0a20 2020 2020 2020 2020 2020  (4)).           
+00002d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002d90: 2029 207b 0a20 2020 2020 2020 2020 2020   ) {.           
+00002da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002db0: 2020 2020 206c 696e 6561 725f 6578 7472       linear_extr
+00002dc0: 7564 6528 6865 6967 6874 3d6d 2b30 2e31  ude(height=m+0.1
+00002dd0: 2c20 6365 6e74 6572 3d74 7275 6529 207b  , center=true) {
+00002de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e00: 2020 2020 2070 6f6c 7967 6f6e 285b 5b72       polygon([[r
+00002e10: 2c30 5d2c 5b30 2e39 3939 2a72 2c30 5d2c  ,0],[0.999*r,0],
+00002e20: 5b30 2c30 2e39 3939 2a72 5d2c 5b30 2c72  [0,0.999*r],[0,r
+00002e30: 5d2c 5b72 2c72 5d5d 293b 0a20 2020 2020  ],[r,r]]);.     
+00002e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e50: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00002e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e70: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
 00002e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e90: 2020 2020 2020 2020 2078 7463 796c 286c           xtcyl(l
-00002ea0: 3d63 2e78 2a32 2c20 723d 7229 3b0a 2020  =c.x*2, r=r);.  
-00002eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ec0: 2020 2020 2020 2020 2020 7a63 796c 286c            zcyl(l
-00002ed0: 3d63 2e7a 2a32 2c20 723d 7229 3b0a 2020  =c.z*2, r=r);.  
+00002e90: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00002ea0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00002eb0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00002ec0: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
+00002ed0: 6966 2028 636e 7420 3d3d 2032 2920 7b0a  if (cnt == 2) {.
 00002ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002ef0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-00002f00: 2020 2020 2020 2020 2020 2020 7d20 656c              } el
-00002f10: 7365 207b 0a20 2020 2020 2020 2020 2020  se {.           
-00002f20: 2020 2020 2020 2020 2020 2020 2069 6e74               int
-00002f30: 6572 7365 6374 696f 6e28 2920 7b0a 2020  ersection() {.  
-00002f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002f50: 2020 2020 2020 2020 2020 7874 6379 6c28            xtcyl(
-00002f60: 6c3d 632e 782a 322c 2072 3d72 293b 0a20  l=c.x*2, r=r);. 
-00002f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002f80: 2020 2020 2020 2020 2020 2079 7463 796c             ytcyl
-00002f90: 286c 3d63 2e79 2a32 2c20 723d 7229 3b0a  (l=c.y*2, r=r);.
-00002fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002fb0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00002fc0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00002fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002fe0: 2020 2020 7472 616e 736c 6174 6528 6332      translate(c2
-00002ff0: 2920 7472 756e 635f 6375 6265 2863 2c63  ) trunc_cube(c,c
-00003000: 6f72 6e65 7229 3b20 2f2f 2054 7269 6d20  orner); // Trim 
-00003010: 746f 206a 7573 7420 7468 6520 6f63 7461  to just the octa
-00003020: 6e74 2e0a 2020 2020 2020 2020 2020 2020  nt..            
-00003030: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00003040: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
-00003050: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
-00003060: 7365 6374 696f 6e28 2920 7b0a 2020 2020  section() {.    
-00003070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003080: 6966 2028 7472 696d 636f 726e 6572 7329  if (trimcorners)
-00003090: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-000030a0: 2020 2020 2020 2020 2020 2074 7370 6865             tsphe
-000030b0: 7265 2872 3d72 293b 0a20 2020 2020 2020  re(r=r);.       
-000030c0: 2020 2020 2020 2020 2020 2020 207d 2065               } e
-000030d0: 6c73 6520 7b0a 2020 2020 2020 2020 2020  lse {.          
-000030e0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-000030f0: 7465 7273 6563 7469 6f6e 2829 207b 0a20  tersection() {. 
-00003100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003110: 2020 2020 2020 2020 2020 2078 7463 796c             xtcyl
-00003120: 286c 3d63 2e78 2a32 2c20 723d 7229 3b0a  (l=c.x*2, r=r);.
-00003130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003140: 2020 2020 2020 2020 2020 2020 7974 6379              ytcy
-00003150: 6c28 6c3d 632e 792a 322c 2072 3d72 293b  l(l=c.y*2, r=r);
-00003160: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003170: 2020 2020 2020 2020 2020 2020 207a 6379               zcy
-00003180: 6c28 6c3d 632e 7a2a 322c 2072 3d72 293b  l(l=c.z*2, r=r);
-00003190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000031a0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-000031b0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-000031c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000031d0: 2020 2020 2074 7261 6e73 6c61 7465 2863       translate(c
-000031e0: 3229 2074 7275 6e63 5f63 7562 6528 632c  2) trunc_cube(c,
-000031f0: 636f 726e 6572 293b 202f 2f20 5472 696d  corner); // Trim
-00003200: 2074 6f20 6a75 7374 2074 6865 206f 6374   to just the oct
-00003210: 616e 742e 0a20 2020 2020 2020 2020 2020  ant..           
-00003220: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00003230: 2020 207d 0a20 2020 2020 2020 207d 0a20     }.        }. 
-00003240: 2020 207d 0a0a 2020 2020 7369 7a65 203d     }..    size =
-00003250: 2073 6361 6c61 725f 7665 6333 2873 697a   scalar_vec3(siz
-00003260: 6529 3b0a 2020 2020 6564 6765 7320 3d20  e);.    edges = 
-00003270: 5f65 6467 6573 2865 6467 6573 2c20 6578  _edges(edges, ex
-00003280: 6365 7074 3d66 6972 7374 5f64 6566 696e  cept=first_defin
-00003290: 6564 285b 6578 6365 7074 5f65 6467 6573  ed([except_edges
-000032a0: 2c65 7863 6570 745d 2929 3b0a 2020 2020  ,except]));.    
-000032b0: 7465 6172 6472 6f70 203d 2069 735f 626f  teardrop = is_bo
-000032c0: 6f6c 2874 6561 7264 726f 7029 2626 7465  ol(teardrop)&&te
-000032d0: 6172 6472 6f70 3f20 3435 203a 2074 6561  ardrop? 45 : tea
-000032e0: 7264 726f 703b 0a20 2020 2063 6861 6d66  rdrop;.    chamf
-000032f0: 6572 203d 2061 7070 726f 7828 6368 616d  er = approx(cham
-00003300: 6665 722c 3029 203f 2075 6e64 6566 203a  fer,0) ? undef :
-00003310: 2063 6861 6d66 6572 3b0a 2020 2020 726f   chamfer;.    ro
-00003320: 756e 6469 6e67 203d 2061 7070 726f 7828  unding = approx(
-00003330: 726f 756e 6469 6e67 2c30 2920 3f20 756e  rounding,0) ? un
-00003340: 6465 6620 3a20 726f 756e 6469 6e67 3b0a  def : rounding;.
-00003350: 2020 2020 6368 6563 6b73 203d 200a 2020      checks = .  
-00003360: 2020 2020 2020 6173 7365 7274 2869 735f        assert(is_
-00003370: 7665 6374 6f72 2873 697a 652c 3329 290a  vector(size,3)).
-00003380: 2020 2020 2020 2020 6173 7365 7274 2861          assert(a
-00003390: 6c6c 5f70 6f73 6974 6976 6528 7369 7a65  ll_positive(size
-000033a0: 2929 0a20 2020 2020 2020 2061 7373 6572  )).        asser
-000033b0: 7428 6973 5f75 6e64 6566 2863 6861 6d66  t(is_undef(chamf
-000033c0: 6572 2920 7c7c 2069 735f 6669 6e69 7465  er) || is_finite
-000033d0: 2863 6861 6d66 6572 292c 2263 6861 6d66  (chamfer),"chamf
-000033e0: 6572 206d 7573 7420 6265 2061 2066 696e  er must be a fin
-000033f0: 6974 6520 7661 6c75 6522 290a 2020 2020  ite value").    
-00003400: 2020 2020 6173 7365 7274 2869 735f 756e      assert(is_un
-00003410: 6465 6628 726f 756e 6469 6e67 2920 7c7c  def(rounding) ||
-00003420: 2069 735f 6669 6e69 7465 2872 6f75 6e64   is_finite(round
-00003430: 696e 6729 2c22 726f 756e 6469 6e67 206d  ing),"rounding m
-00003440: 7573 7420 6265 2061 2066 696e 6974 6520  ust be a finite 
-00003450: 7661 6c75 6522 290a 2020 2020 2020 2020  value").        
-00003460: 6173 7365 7274 2869 735f 756e 6465 6628  assert(is_undef(
-00003470: 726f 756e 6469 6e67 2920 7c7c 2069 735f  rounding) || is_
-00003480: 756e 6465 6628 6368 616d 6665 7229 2c20  undef(chamfer), 
-00003490: 2243 616e 6e6f 7420 7370 6563 6966 7920  "Cannot specify 
-000034a0: 6e6f 6e7a 6572 6f20 7661 6c75 6520 666f  nonzero value fo
-000034b0: 7220 626f 7468 2063 6861 6d66 6572 2061  r both chamfer a
-000034c0: 6e64 2072 6f75 6e64 696e 6722 290a 2020  nd rounding").  
-000034d0: 2020 2020 2020 6173 7365 7274 2874 6561        assert(tea
-000034e0: 7264 726f 703d 3d66 616c 7365 207c 7c20  rdrop==false || 
-000034f0: 2869 735f 6669 6e69 7465 2874 6561 7264  (is_finite(teard
-00003500: 726f 7029 2026 2620 7465 6172 6472 6f70  rop) && teardrop
-00003510: 3e30 2026 2620 7465 6172 6472 6f70 3c39  >0 && teardrop<9
-00003520: 3029 2c20 2274 6561 7264 726f 7020 6d75  0), "teardrop mu
-00003530: 7374 2062 6520 6569 7468 6572 2066 616c  st be either fal
-00003540: 7365 206f 7220 616e 2061 6e67 6c65 206e  se or an angle n
-00003550: 756d 6265 7220 6265 7477 6565 6e20 3020  umber between 0 
-00003560: 616e 6420 3930 2229 0a20 2020 2020 2020  and 90").       
-00003570: 2061 7373 6572 7428 6973 5f75 6e64 6566   assert(is_undef
-00003580: 2870 3129 207c 7c20 6973 5f76 6563 746f  (p1) || is_vecto
-00003590: 7228 7031 2929 0a20 2020 2020 2020 2061  r(p1)).        a
-000035a0: 7373 6572 7428 6973 5f75 6e64 6566 2870  ssert(is_undef(p
-000035b0: 3229 207c 7c20 6973 5f76 6563 746f 7228  2) || is_vector(
-000035c0: 7032 2929 0a20 2020 2020 2020 2061 7373  p2)).        ass
-000035d0: 6572 7428 6973 5f62 6f6f 6c28 7472 696d  ert(is_bool(trim
-000035e0: 636f 726e 6572 7329 293b 0a20 2020 2069  corners));.    i
-000035f0: 6620 2821 6973 5f75 6e64 6566 2870 3129  f (!is_undef(p1)
-00003600: 2920 7b0a 2020 2020 2020 2020 6966 2028  ) {.        if (
-00003610: 2169 735f 756e 6465 6628 7032 2929 207b  !is_undef(p2)) {
-00003620: 0a20 2020 2020 2020 2020 2020 2074 7261  .            tra
-00003630: 6e73 6c61 7465 2870 6f69 6e74 6c69 7374  nslate(pointlist
-00003640: 5f62 6f75 6e64 7328 5b70 312c 7032 5d29  _bounds([p1,p2])
-00003650: 5b30 5d29 207b 0a20 2020 2020 2020 2020  [0]) {.         
-00003660: 2020 2020 2020 2063 7562 6f69 6428 7369         cuboid(si
-00003670: 7a65 3d76 5f61 6273 2870 322d 7031 292c  ze=v_abs(p2-p1),
-00003680: 2063 6861 6d66 6572 3d63 6861 6d66 6572   chamfer=chamfer
-00003690: 2c20 726f 756e 6469 6e67 3d72 6f75 6e64  , rounding=round
-000036a0: 696e 672c 2065 6467 6573 3d65 6467 6573  ing, edges=edges
-000036b0: 2c20 7472 696d 636f 726e 6572 733d 7472  , trimcorners=tr
-000036c0: 696d 636f 726e 6572 732c 2061 6e63 686f  imcorners, ancho
-000036d0: 723d 2d5b 312c 312c 315d 2920 6368 696c  r=-[1,1,1]) chil
-000036e0: 6472 656e 2829 3b0a 2020 2020 2020 2020  dren();.        
-000036f0: 2020 2020 7d0a 2020 2020 2020 2020 7d20      }.        } 
-00003700: 656c 7365 207b 0a20 2020 2020 2020 2020  else {.         
-00003710: 2020 2074 7261 6e73 6c61 7465 2870 3129     translate(p1)
-00003720: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00003730: 2020 2063 7562 6f69 6428 7369 7a65 3d73     cuboid(size=s
-00003740: 697a 652c 2063 6861 6d66 6572 3d63 6861  ize, chamfer=cha
-00003750: 6d66 6572 2c20 726f 756e 6469 6e67 3d72  mfer, rounding=r
-00003760: 6f75 6e64 696e 672c 2065 6467 6573 3d65  ounding, edges=e
-00003770: 6467 6573 2c20 7472 696d 636f 726e 6572  dges, trimcorner
-00003780: 733d 7472 696d 636f 726e 6572 732c 2061  s=trimcorners, a
-00003790: 6e63 686f 723d 2d5b 312c 312c 315d 2920  nchor=-[1,1,1]) 
-000037a0: 6368 696c 6472 656e 2829 3b0a 2020 2020  children();.    
-000037b0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-000037c0: 2020 7d0a 2020 2020 7d20 656c 7365 207b    }.    } else {
-000037d0: 0a20 2020 2020 2020 2072 7220 3d20 6d61  .        rr = ma
-000037e0: 7828 6465 6661 756c 7428 6368 616d 6665  x(default(chamfe
-000037f0: 722c 3029 2c20 6465 6661 756c 7428 726f  r,0), default(ro
-00003800: 756e 6469 6e67 2c30 2929 3b0a 2020 2020  unding,0));.    
-00003810: 2020 2020 6966 2028 7272 3e30 2920 7b0a      if (rr>0) {.
-00003820: 2020 2020 2020 2020 2020 2020 6d69 6e78              minx
-00003830: 203d 206d 6178 280a 2020 2020 2020 2020   = max(.        
-00003840: 2020 2020 2020 2020 6564 6765 732e 795b          edges.y[
-00003850: 305d 202b 2065 6467 6573 2e79 5b31 5d2c  0] + edges.y[1],
-00003860: 2065 6467 6573 2e79 5b32 5d20 2b20 6564   edges.y[2] + ed
-00003870: 6765 732e 795b 335d 2c0a 2020 2020 2020  ges.y[3],.      
-00003880: 2020 2020 2020 2020 2020 6564 6765 732e            edges.
-00003890: 7a5b 305d 202b 2065 6467 6573 2e7a 5b31  z[0] + edges.z[1
-000038a0: 5d2c 2065 6467 6573 2e7a 5b32 5d20 2b20  ], edges.z[2] + 
-000038b0: 6564 6765 732e 7a5b 335d 2c0a 2020 2020  edges.z[3],.    
-000038c0: 2020 2020 2020 2020 2020 2020 6564 6765              edge
-000038d0: 732e 795b 305d 202b 2065 6467 6573 2e7a  s.y[0] + edges.z
-000038e0: 5b31 5d2c 2065 6467 6573 2e79 5b30 5d20  [1], edges.y[0] 
-000038f0: 2b20 6564 6765 732e 7a5b 335d 2c0a 2020  + edges.z[3],.  
-00003900: 2020 2020 2020 2020 2020 2020 2020 6564                ed
-00003910: 6765 732e 795b 315d 202b 2065 6467 6573  ges.y[1] + edges
-00003920: 2e7a 5b30 5d2c 2065 6467 6573 2e79 5b31  .z[0], edges.y[1
-00003930: 5d20 2b20 6564 6765 732e 7a5b 325d 2c0a  ] + edges.z[2],.
-00003940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003950: 6564 6765 732e 795b 325d 202b 2065 6467  edges.y[2] + edg
-00003960: 6573 2e7a 5b31 5d2c 2065 6467 6573 2e79  es.z[1], edges.y
-00003970: 5b32 5d20 2b20 6564 6765 732e 7a5b 335d  [2] + edges.z[3]
-00003980: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00003990: 2020 6564 6765 732e 795b 335d 202b 2065    edges.y[3] + e
-000039a0: 6467 6573 2e7a 5b30 5d2c 2065 6467 6573  dges.z[0], edges
-000039b0: 2e79 5b33 5d20 2b20 6564 6765 732e 7a5b  .y[3] + edges.z[
-000039c0: 325d 0a20 2020 2020 2020 2020 2020 2029  2].            )
-000039d0: 202a 2072 723b 0a20 2020 2020 2020 2020   * rr;.         
-000039e0: 2020 206d 696e 7920 3d20 6d61 7828 0a20     miny = max(. 
-000039f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00003a00: 6467 6573 2e78 5b30 5d20 2b20 6564 6765  dges.x[0] + edge
-00003a10: 732e 785b 315d 2c20 6564 6765 732e 785b  s.x[1], edges.x[
-00003a20: 325d 202b 2065 6467 6573 2e78 5b33 5d2c  2] + edges.x[3],
-00003a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003a40: 2065 6467 6573 2e7a 5b30 5d20 2b20 6564   edges.z[0] + ed
-00003a50: 6765 732e 7a5b 325d 2c20 6564 6765 732e  ges.z[2], edges.
-00003a60: 7a5b 315d 202b 2065 6467 6573 2e7a 5b33  z[1] + edges.z[3
-00003a70: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-00003a80: 2020 2065 6467 6573 2e78 5b30 5d20 2b20     edges.x[0] + 
-00003a90: 6564 6765 732e 7a5b 325d 2c20 6564 6765  edges.z[2], edge
-00003aa0: 732e 785b 305d 202b 2065 6467 6573 2e7a  s.x[0] + edges.z
-00003ab0: 5b33 5d2c 0a20 2020 2020 2020 2020 2020  [3],.           
-00003ac0: 2020 2020 2065 6467 6573 2e78 5b31 5d20       edges.x[1] 
-00003ad0: 2b20 6564 6765 732e 7a5b 305d 2c20 6564  + edges.z[0], ed
-00003ae0: 6765 732e 785b 315d 202b 2065 6467 6573  ges.x[1] + edges
-00003af0: 2e7a 5b31 5d2c 0a20 2020 2020 2020 2020  .z[1],.         
-00003b00: 2020 2020 2020 2065 6467 6573 2e78 5b32         edges.x[2
-00003b10: 5d20 2b20 6564 6765 732e 7a5b 325d 2c20  ] + edges.z[2], 
-00003b20: 6564 6765 732e 785b 325d 202b 2065 6467  edges.x[2] + edg
-00003b30: 6573 2e7a 5b33 5d2c 0a20 2020 2020 2020  es.z[3],.       
-00003b40: 2020 2020 2020 2020 2065 6467 6573 2e78           edges.x
-00003b50: 5b33 5d20 2b20 6564 6765 732e 7a5b 305d  [3] + edges.z[0]
-00003b60: 2c20 6564 6765 732e 785b 335d 202b 2065  , edges.x[3] + e
-00003b70: 6467 6573 2e7a 5b31 5d0a 2020 2020 2020  dges.z[1].      
-00003b80: 2020 2020 2020 2920 2a20 7272 3b0a 2020        ) * rr;.  
-00003b90: 2020 2020 2020 2020 2020 6d69 6e7a 203d            minz =
-00003ba0: 206d 6178 280a 2020 2020 2020 2020 2020   max(.          
-00003bb0: 2020 2020 2020 6564 6765 732e 785b 305d        edges.x[0]
-00003bc0: 202b 2065 6467 6573 2e78 5b32 5d2c 2065   + edges.x[2], e
-00003bd0: 6467 6573 2e78 5b31 5d20 2b20 6564 6765  dges.x[1] + edge
-00003be0: 732e 785b 335d 2c0a 2020 2020 2020 2020  s.x[3],.        
-00003bf0: 2020 2020 2020 2020 6564 6765 732e 795b          edges.y[
-00003c00: 305d 202b 2065 6467 6573 2e79 5b32 5d2c  0] + edges.y[2],
-00003c10: 2065 6467 6573 2e79 5b31 5d20 2b20 6564   edges.y[1] + ed
-00003c20: 6765 732e 795b 335d 2c0a 2020 2020 2020  ges.y[3],.      
-00003c30: 2020 2020 2020 2020 2020 6564 6765 732e            edges.
-00003c40: 785b 305d 202b 2065 6467 6573 2e79 5b32  x[0] + edges.y[2
-00003c50: 5d2c 2065 6467 6573 2e78 5b30 5d20 2b20  ], edges.x[0] + 
-00003c60: 6564 6765 732e 795b 335d 2c0a 2020 2020  edges.y[3],.    
-00003c70: 2020 2020 2020 2020 2020 2020 6564 6765              edge
-00003c80: 732e 785b 315d 202b 2065 6467 6573 2e79  s.x[1] + edges.y
-00003c90: 5b32 5d2c 2065 6467 6573 2e78 5b31 5d20  [2], edges.x[1] 
-00003ca0: 2b20 6564 6765 732e 795b 335d 2c0a 2020  + edges.y[3],.  
-00003cb0: 2020 2020 2020 2020 2020 2020 2020 6564                ed
-00003cc0: 6765 732e 785b 325d 202b 2065 6467 6573  ges.x[2] + edges
-00003cd0: 2e79 5b30 5d2c 2065 6467 6573 2e78 5b32  .y[0], edges.x[2
-00003ce0: 5d20 2b20 6564 6765 732e 795b 315d 2c0a  ] + edges.y[1],.
-00003cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003d00: 6564 6765 732e 785b 335d 202b 2065 6467  edges.x[3] + edg
-00003d10: 6573 2e79 5b30 5d2c 2065 6467 6573 2e78  es.y[0], edges.x
-00003d20: 5b33 5d20 2b20 6564 6765 732e 795b 315d  [3] + edges.y[1]
-00003d30: 0a20 2020 2020 2020 2020 2020 2029 202a  .            ) *
-00003d40: 2072 723b 0a20 2020 2020 2020 2020 2020   rr;.           
-00003d50: 2063 6865 636b 203d 0a20 2020 2020 2020   check =.       
-00003d60: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
-00003d70: 6d69 6e78 203c 3d20 7369 7a65 2e78 2c20  minx <= size.x, 
-00003d80: 2252 6f75 6e64 696e 6720 6f72 2063 6861  "Rounding or cha
-00003d90: 6d66 6572 696e 6720 746f 6f20 6c61 7267  mfering too larg
-00003da0: 6520 666f 7220 6375 626f 6964 2073 697a  e for cuboid siz
-00003db0: 6520 696e 2074 6865 2058 2061 7869 732e  e in the X axis.
-00003dc0: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
-00003dd0: 2020 2061 7373 6572 7428 6d69 6e79 203c     assert(miny <
-00003de0: 3d20 7369 7a65 2e79 2c20 2252 6f75 6e64  = size.y, "Round
-00003df0: 696e 6720 6f72 2063 6861 6d66 6572 696e  ing or chamferin
-00003e00: 6720 746f 6f20 6c61 7267 6520 666f 7220  g too large for 
-00003e10: 6375 626f 6964 2073 697a 6520 696e 2074  cuboid size in t
-00003e20: 6865 2059 2061 7869 732e 2229 0a20 2020  he Y axis.").   
-00003e30: 2020 2020 2020 2020 2020 2020 2061 7373               ass
-00003e40: 6572 7428 6d69 6e7a 203c 3d20 7369 7a65  ert(minz <= size
-00003e50: 2e7a 2c20 2252 6f75 6e64 696e 6720 6f72  .z, "Rounding or
-00003e60: 2063 6861 6d66 6572 696e 6720 746f 6f20   chamfering too 
-00003e70: 6c61 7267 6520 666f 7220 6375 626f 6964  large for cuboid
-00003e80: 2073 697a 6520 696e 2074 6865 205a 2061   size in the Z a
-00003e90: 7869 732e 2229 0a20 2020 2020 2020 2020  xis.").         
-00003ea0: 2020 203b 0a20 2020 2020 2020 207d 0a20     ;.        }. 
-00003eb0: 2020 2020 2020 206d 616a 726f 7473 203d         majrots =
-00003ec0: 205b 5b30 2c39 302c 305d 2c20 5b39 302c   [[0,90,0], [90,
-00003ed0: 302c 305d 2c20 5b30 2c30 2c30 5d5d 3b0a  0,0], [0,0,0]];.
-00003ee0: 2020 2020 2020 2020 6174 7461 6368 6162          attachab
-00003ef0: 6c65 2861 6e63 686f 722c 7370 696e 2c6f  le(anchor,spin,o
-00003f00: 7269 656e 742c 2073 697a 653d 7369 7a65  rient, size=size
-00003f10: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00003f20: 6966 2028 6973 5f66 696e 6974 6528 6368  if (is_finite(ch
-00003f30: 616d 6665 7229 2026 2620 2161 7070 726f  amfer) && !appro
-00003f40: 7828 6368 616d 6665 722c 3029 2920 7b0a  x(chamfer,0)) {.
-00003f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003f60: 6966 2028 6564 6765 7320 3d3d 2045 4447  if (edges == EDG
-00003f70: 4553 5f41 4c4c 2026 2620 7472 696d 636f  ES_ALL && trimco
-00003f80: 726e 6572 7329 207b 0a20 2020 2020 2020  rners) {.       
-00003f90: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00003fa0: 2863 6861 6d66 6572 3c30 2920 7b0a 2020  (chamfer<0) {.  
-00003fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003fc0: 2020 2020 2020 6375 6265 2873 697a 652c        cube(size,
-00003fd0: 2063 656e 7465 723d 7472 7565 2920 7b0a   center=true) {.
-00003fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003ff0: 2020 2020 2020 2020 2020 2020 6174 7461              atta
-00004000: 6368 2854 4f50 2c6f 7665 726c 6170 3d30  ch(TOP,overlap=0
-00004010: 2920 7072 6973 6d6f 6964 285b 7369 7a65  ) prismoid([size
-00004020: 2e78 2c73 697a 652e 795d 2c20 5b73 697a  .x,size.y], [siz
-00004030: 652e 782d 322a 6368 616d 6665 722c 7369  e.x-2*chamfer,si
-00004040: 7a65 2e79 2d32 2a63 6861 6d66 6572 5d2c  ze.y-2*chamfer],
-00004050: 2068 3d2d 6368 616d 6665 722c 2061 6e63   h=-chamfer, anc
-00004060: 686f 723d 544f 5029 3b0a 2020 2020 2020  hor=TOP);.      
-00004070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004080: 2020 2020 2020 6174 7461 6368 2842 4f54        attach(BOT
-00004090: 2c6f 7665 726c 6170 3d30 2920 7072 6973  ,overlap=0) pris
-000040a0: 6d6f 6964 285b 7369 7a65 2e78 2c73 697a  moid([size.x,siz
-000040b0: 652e 795d 2c20 5b73 697a 652e 782d 322a  e.y], [size.x-2*
-000040c0: 6368 616d 6665 722c 7369 7a65 2e79 2d32  chamfer,size.y-2
-000040d0: 2a63 6861 6d66 6572 5d2c 2068 3d2d 6368  *chamfer], h=-ch
-000040e0: 616d 6665 722c 2061 6e63 686f 723d 544f  amfer, anchor=TO
-000040f0: 5029 3b0a 2020 2020 2020 2020 2020 2020  P);.            
-00004100: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00004110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004120: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
-00004130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004140: 2020 2069 7369 7a65 203d 205b 666f 7220     isize = [for 
-00004150: 2876 203d 2073 697a 6529 206d 6178 2830  (v = size) max(0
-00004160: 2e30 3031 2c20 762d 322a 6368 616d 6665  .001, v-2*chamfe
-00004170: 7229 5d3b 0a20 2020 2020 2020 2020 2020  r)];.           
-00004180: 2020 2020 2020 2020 2020 2020 2068 756c               hul
-00004190: 6c28 2920 7b0a 2020 2020 2020 2020 2020  l() {.          
-000041a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000041b0: 2020 6375 6265 285b 2073 697a 652e 782c    cube([ size.x,
-000041c0: 2069 7369 7a65 2e79 2c20 6973 697a 652e   isize.y, isize.
-000041d0: 7a5d 2c20 6365 6e74 6572 3d74 7275 6529  z], center=true)
-000041e0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-000041f0: 2020 2020 2020 2020 2020 2020 2020 6375                cu
-00004200: 6265 285b 6973 697a 652e 782c 2020 7369  be([isize.x,  si
-00004210: 7a65 2e79 2c20 6973 697a 652e 7a5d 2c20  ze.y, isize.z], 
-00004220: 6365 6e74 6572 3d74 7275 6529 3b0a 2020  center=true);.  
-00004230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004240: 2020 2020 2020 2020 2020 6375 6265 285b            cube([
-00004250: 6973 697a 652e 782c 2069 7369 7a65 2e79  isize.x, isize.y
-00004260: 2c20 2073 697a 652e 7a5d 2c20 6365 6e74  ,  size.z], cent
-00004270: 6572 3d74 7275 6529 3b0a 2020 2020 2020  er=true);.      
-00004280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004290: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-000042a0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00002ef0: 696e 7465 7273 6563 7469 6f6e 2829 207b  intersection() {
+00002f00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002f10: 2020 2020 2069 6620 2821 652e 7829 207b       if (!e.x) {
+00002f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002f30: 2020 2020 2020 2020 2069 6e74 6572 7365           interse
+00002f40: 6374 696f 6e28 2920 7b0a 2020 2020 2020  ction() {.      
+00002f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f60: 2020 2020 2020 7974 6379 6c28 6c3d 632e        ytcyl(l=c.
+00002f70: 792a 322c 2072 3d72 293b 0a20 2020 2020  y*2, r=r);.     
+00002f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002f90: 2020 2020 2020 207a 6379 6c28 6c3d 632e         zcyl(l=c.
+00002fa0: 7a2a 322c 2072 3d72 293b 0a20 2020 2020  z*2, r=r);.     
+00002fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002fc0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00002fd0: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
+00002fe0: 6966 2028 2165 2e79 2920 7b0a 2020 2020  if (!e.y) {.    
+00002ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003000: 2020 2020 696e 7465 7273 6563 7469 6f6e      intersection
+00003010: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
+00003020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003030: 2078 7463 796c 286c 3d63 2e78 2a32 2c20   xtcyl(l=c.x*2, 
+00003040: 723d 7229 3b0a 2020 2020 2020 2020 2020  r=r);.          
+00003050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003060: 2020 7a63 796c 286c 3d63 2e7a 2a32 2c20    zcyl(l=c.z*2, 
+00003070: 723d 7229 3b0a 2020 2020 2020 2020 2020  r=r);.          
+00003080: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+00003090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030a0: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
+000030b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030c0: 2020 2020 2069 6e74 6572 7365 6374 696f       intersectio
+000030d0: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
+000030e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030f0: 2020 7874 6379 6c28 6c3d 632e 782a 322c    xtcyl(l=c.x*2,
+00003100: 2072 3d72 293b 0a20 2020 2020 2020 2020   r=r);.         
+00003110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003120: 2020 2079 7463 796c 286c 3d63 2e79 2a32     ytcyl(l=c.y*2
+00003130: 2c20 723d 7229 3b0a 2020 2020 2020 2020  , r=r);.        
+00003140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003150: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+00003160: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00003170: 2020 2020 2020 2020 2020 2020 7472 616e              tran
+00003180: 736c 6174 6528 6332 2920 7472 756e 635f  slate(c2) trunc_
+00003190: 6375 6265 2863 2c63 6f72 6e65 7229 3b20  cube(c,corner); 
+000031a0: 2f2f 2054 7269 6d20 746f 206a 7573 7420  // Trim to just 
+000031b0: 7468 6520 6f63 7461 6e74 2e0a 2020 2020  the octant..    
+000031c0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+000031d0: 2020 2020 2020 2020 2020 7d20 656c 7365            } else
+000031e0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+000031f0: 2020 2069 6e74 6572 7365 6374 696f 6e28     intersection(
+00003200: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00003210: 2020 2020 2020 2020 6966 2028 7472 696d          if (trim
+00003220: 636f 726e 6572 7329 207b 0a20 2020 2020  corners) {.     
+00003230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003240: 2020 2074 7370 6865 7265 2872 3d72 293b     tsphere(r=r);
+00003250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003260: 2020 2020 207d 2065 6c73 6520 7b0a 2020       } else {.  
+00003270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003280: 2020 2020 2020 696e 7465 7273 6563 7469        intersecti
+00003290: 6f6e 2829 207b 0a20 2020 2020 2020 2020  on() {.         
+000032a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000032b0: 2020 2078 7463 796c 286c 3d63 2e78 2a32     xtcyl(l=c.x*2
+000032c0: 2c20 723d 7229 3b0a 2020 2020 2020 2020  , r=r);.        
+000032d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000032e0: 2020 2020 7974 6379 6c28 6c3d 632e 792a      ytcyl(l=c.y*
+000032f0: 322c 2072 3d72 293b 0a20 2020 2020 2020  2, r=r);.       
+00003300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003310: 2020 2020 207a 6379 6c28 6c3d 632e 7a2a       zcyl(l=c.z*
+00003320: 322c 2072 3d72 293b 0a20 2020 2020 2020  2, r=r);.       
+00003330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003340: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00003350: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00003360: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+00003370: 6e73 6c61 7465 2863 3229 2074 7275 6e63  nslate(c2) trunc
+00003380: 5f63 7562 6528 632c 636f 726e 6572 293b  _cube(c,corner);
+00003390: 202f 2f20 5472 696d 2074 6f20 6a75 7374   // Trim to just
+000033a0: 2074 6865 206f 6374 616e 742e 0a20 2020   the octant..   
+000033b0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+000033c0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+000033d0: 2020 2020 207d 0a20 2020 207d 0a0a 2020       }.    }..  
+000033e0: 2020 7369 7a65 203d 2073 6361 6c61 725f    size = scalar_
+000033f0: 7665 6333 2873 697a 6529 3b0a 2020 2020  vec3(size);.    
+00003400: 6564 6765 7320 3d20 5f65 6467 6573 2865  edges = _edges(e
+00003410: 6467 6573 2c20 6578 6365 7074 3d66 6972  dges, except=fir
+00003420: 7374 5f64 6566 696e 6564 285b 6578 6365  st_defined([exce
+00003430: 7074 5f65 6467 6573 2c65 7863 6570 745d  pt_edges,except]
+00003440: 2929 3b0a 2020 2020 7465 6172 6472 6f70  ));.    teardrop
+00003450: 203d 2069 735f 626f 6f6c 2874 6561 7264   = is_bool(teard
+00003460: 726f 7029 2626 7465 6172 6472 6f70 3f20  rop)&&teardrop? 
+00003470: 3435 203a 2074 6561 7264 726f 703b 0a20  45 : teardrop;. 
+00003480: 2020 2063 6861 6d66 6572 203d 2061 7070     chamfer = app
+00003490: 726f 7828 6368 616d 6665 722c 3029 203f  rox(chamfer,0) ?
+000034a0: 2075 6e64 6566 203a 2063 6861 6d66 6572   undef : chamfer
+000034b0: 3b0a 2020 2020 726f 756e 6469 6e67 203d  ;.    rounding =
+000034c0: 2061 7070 726f 7828 726f 756e 6469 6e67   approx(rounding
+000034d0: 2c30 2920 3f20 756e 6465 6620 3a20 726f  ,0) ? undef : ro
+000034e0: 756e 6469 6e67 3b0a 2020 2020 6368 6563  unding;.    chec
+000034f0: 6b73 203d 0a20 2020 2020 2020 2061 7373  ks =.        ass
+00003500: 6572 7428 6973 5f76 6563 746f 7228 7369  ert(is_vector(si
+00003510: 7a65 2c33 2929 0a20 2020 2020 2020 2061  ze,3)).        a
+00003520: 7373 6572 7428 616c 6c5f 706f 7369 7469  ssert(all_positi
+00003530: 7665 2873 697a 6529 290a 2020 2020 2020  ve(size)).      
+00003540: 2020 6173 7365 7274 2869 735f 756e 6465    assert(is_unde
+00003550: 6628 6368 616d 6665 7229 207c 7c20 6973  f(chamfer) || is
+00003560: 5f66 696e 6974 6528 6368 616d 6665 7229  _finite(chamfer)
+00003570: 2c22 6368 616d 6665 7220 6d75 7374 2062  ,"chamfer must b
+00003580: 6520 6120 6669 6e69 7465 2076 616c 7565  e a finite value
+00003590: 2229 0a20 2020 2020 2020 2061 7373 6572  ").        asser
+000035a0: 7428 6973 5f75 6e64 6566 2872 6f75 6e64  t(is_undef(round
+000035b0: 696e 6729 207c 7c20 6973 5f66 696e 6974  ing) || is_finit
+000035c0: 6528 726f 756e 6469 6e67 292c 2272 6f75  e(rounding),"rou
+000035d0: 6e64 696e 6720 6d75 7374 2062 6520 6120  nding must be a 
+000035e0: 6669 6e69 7465 2076 616c 7565 2229 0a20  finite value"). 
+000035f0: 2020 2020 2020 2061 7373 6572 7428 6973         assert(is
+00003600: 5f75 6e64 6566 2872 6f75 6e64 696e 6729  _undef(rounding)
+00003610: 207c 7c20 6973 5f75 6e64 6566 2863 6861   || is_undef(cha
+00003620: 6d66 6572 292c 2022 4361 6e6e 6f74 2073  mfer), "Cannot s
+00003630: 7065 6369 6679 206e 6f6e 7a65 726f 2076  pecify nonzero v
+00003640: 616c 7565 2066 6f72 2062 6f74 6820 6368  alue for both ch
+00003650: 616d 6665 7220 616e 6420 726f 756e 6469  amfer and roundi
+00003660: 6e67 2229 0a20 2020 2020 2020 2061 7373  ng").        ass
+00003670: 6572 7428 7465 6172 6472 6f70 3d3d 6661  ert(teardrop==fa
+00003680: 6c73 6520 7c7c 2028 6973 5f66 696e 6974  lse || (is_finit
+00003690: 6528 7465 6172 6472 6f70 2920 2626 2074  e(teardrop) && t
+000036a0: 6561 7264 726f 703e 3020 2626 2074 6561  eardrop>0 && tea
+000036b0: 7264 726f 703c 3d39 3029 2c20 2274 6561  rdrop<=90), "tea
+000036c0: 7264 726f 7020 6d75 7374 2062 6520 6569  rdrop must be ei
+000036d0: 7468 6572 2066 616c 7365 206f 7220 616e  ther false or an
+000036e0: 2061 6e67 6c65 206e 756d 6265 7220 6265   angle number be
+000036f0: 7477 6565 6e20 3020 616e 6420 3930 2229  tween 0 and 90")
+00003700: 0a20 2020 2020 2020 2061 7373 6572 7428  .        assert(
+00003710: 6973 5f75 6e64 6566 2870 3129 207c 7c20  is_undef(p1) || 
+00003720: 6973 5f76 6563 746f 7228 7031 2929 0a20  is_vector(p1)). 
+00003730: 2020 2020 2020 2061 7373 6572 7428 6973         assert(is
+00003740: 5f75 6e64 6566 2870 3229 207c 7c20 6973  _undef(p2) || is
+00003750: 5f76 6563 746f 7228 7032 2929 0a20 2020  _vector(p2)).   
+00003760: 2020 2020 2061 7373 6572 7428 6973 5f62       assert(is_b
+00003770: 6f6f 6c28 7472 696d 636f 726e 6572 7329  ool(trimcorners)
+00003780: 293b 0a20 2020 2069 6620 2821 6973 5f75  );.    if (!is_u
+00003790: 6e64 6566 2870 3129 2920 7b0a 2020 2020  ndef(p1)) {.    
+000037a0: 2020 2020 6966 2028 2169 735f 756e 6465      if (!is_unde
+000037b0: 6628 7032 2929 207b 0a20 2020 2020 2020  f(p2)) {.       
+000037c0: 2020 2020 2074 7261 6e73 6c61 7465 2870       translate(p
+000037d0: 6f69 6e74 6c69 7374 5f62 6f75 6e64 7328  ointlist_bounds(
+000037e0: 5b70 312c 7032 5d29 5b30 5d29 207b 0a20  [p1,p2])[0]) {. 
+000037f0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00003800: 7562 6f69 6428 7369 7a65 3d76 5f61 6273  uboid(size=v_abs
+00003810: 2870 322d 7031 292c 2063 6861 6d66 6572  (p2-p1), chamfer
+00003820: 3d63 6861 6d66 6572 2c20 726f 756e 6469  =chamfer, roundi
+00003830: 6e67 3d72 6f75 6e64 696e 672c 2065 6467  ng=rounding, edg
+00003840: 6573 3d65 6467 6573 2c20 7472 696d 636f  es=edges, trimco
+00003850: 726e 6572 733d 7472 696d 636f 726e 6572  rners=trimcorner
+00003860: 732c 2061 6e63 686f 723d 2d5b 312c 312c  s, anchor=-[1,1,
+00003870: 315d 2920 6368 696c 6472 656e 2829 3b0a  1]) children();.
+00003880: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00003890: 2020 2020 2020 7d20 656c 7365 207b 0a20        } else {. 
+000038a0: 2020 2020 2020 2020 2020 2074 7261 6e73             trans
+000038b0: 6c61 7465 2870 3129 207b 0a20 2020 2020  late(p1) {.     
+000038c0: 2020 2020 2020 2020 2020 2063 7562 6f69             cuboi
+000038d0: 6428 7369 7a65 3d73 697a 652c 2063 6861  d(size=size, cha
+000038e0: 6d66 6572 3d63 6861 6d66 6572 2c20 726f  mfer=chamfer, ro
+000038f0: 756e 6469 6e67 3d72 6f75 6e64 696e 672c  unding=rounding,
+00003900: 2065 6467 6573 3d65 6467 6573 2c20 7472   edges=edges, tr
+00003910: 696d 636f 726e 6572 733d 7472 696d 636f  imcorners=trimco
+00003920: 726e 6572 732c 2061 6e63 686f 723d 2d5b  rners, anchor=-[
+00003930: 312c 312c 315d 2920 6368 696c 6472 656e  1,1,1]) children
+00003940: 2829 3b0a 2020 2020 2020 2020 2020 2020  ();.            
+00003950: 7d0a 2020 2020 2020 2020 7d0a 2020 2020  }.        }.    
+00003960: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00003970: 2072 7220 3d20 6d61 7828 6465 6661 756c   rr = max(defaul
+00003980: 7428 6368 616d 6665 722c 3029 2c20 6465  t(chamfer,0), de
+00003990: 6661 756c 7428 726f 756e 6469 6e67 2c30  fault(rounding,0
+000039a0: 2929 3b0a 2020 2020 2020 2020 6966 2028  ));.        if (
+000039b0: 7272 3e30 2920 7b0a 2020 2020 2020 2020  rr>0) {.        
+000039c0: 2020 2020 6d69 6e78 203d 206d 6178 280a      minx = max(.
+000039d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000039e0: 6564 6765 732e 795b 305d 202b 2065 6467  edges.y[0] + edg
+000039f0: 6573 2e79 5b31 5d2c 2065 6467 6573 2e79  es.y[1], edges.y
+00003a00: 5b32 5d20 2b20 6564 6765 732e 795b 335d  [2] + edges.y[3]
+00003a10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00003a20: 2020 6564 6765 732e 7a5b 305d 202b 2065    edges.z[0] + e
+00003a30: 6467 6573 2e7a 5b31 5d2c 2065 6467 6573  dges.z[1], edges
+00003a40: 2e7a 5b32 5d20 2b20 6564 6765 732e 7a5b  .z[2] + edges.z[
+00003a50: 335d 2c0a 2020 2020 2020 2020 2020 2020  3],.            
+00003a60: 2020 2020 6564 6765 732e 795b 305d 202b      edges.y[0] +
+00003a70: 2065 6467 6573 2e7a 5b31 5d2c 2065 6467   edges.z[1], edg
+00003a80: 6573 2e79 5b30 5d20 2b20 6564 6765 732e  es.y[0] + edges.
+00003a90: 7a5b 335d 2c0a 2020 2020 2020 2020 2020  z[3],.          
+00003aa0: 2020 2020 2020 6564 6765 732e 795b 315d        edges.y[1]
+00003ab0: 202b 2065 6467 6573 2e7a 5b30 5d2c 2065   + edges.z[0], e
+00003ac0: 6467 6573 2e79 5b31 5d20 2b20 6564 6765  dges.y[1] + edge
+00003ad0: 732e 7a5b 325d 2c0a 2020 2020 2020 2020  s.z[2],.        
+00003ae0: 2020 2020 2020 2020 6564 6765 732e 795b          edges.y[
+00003af0: 325d 202b 2065 6467 6573 2e7a 5b31 5d2c  2] + edges.z[1],
+00003b00: 2065 6467 6573 2e79 5b32 5d20 2b20 6564   edges.y[2] + ed
+00003b10: 6765 732e 7a5b 335d 2c0a 2020 2020 2020  ges.z[3],.      
+00003b20: 2020 2020 2020 2020 2020 6564 6765 732e            edges.
+00003b30: 795b 335d 202b 2065 6467 6573 2e7a 5b30  y[3] + edges.z[0
+00003b40: 5d2c 2065 6467 6573 2e79 5b33 5d20 2b20  ], edges.y[3] + 
+00003b50: 6564 6765 732e 7a5b 325d 0a20 2020 2020  edges.z[2].     
+00003b60: 2020 2020 2020 2029 202a 2072 723b 0a20         ) * rr;. 
+00003b70: 2020 2020 2020 2020 2020 206d 696e 7920             miny 
+00003b80: 3d20 6d61 7828 0a20 2020 2020 2020 2020  = max(.         
+00003b90: 2020 2020 2020 2065 6467 6573 2e78 5b30         edges.x[0
+00003ba0: 5d20 2b20 6564 6765 732e 785b 315d 2c20  ] + edges.x[1], 
+00003bb0: 6564 6765 732e 785b 325d 202b 2065 6467  edges.x[2] + edg
+00003bc0: 6573 2e78 5b33 5d2c 0a20 2020 2020 2020  es.x[3],.       
+00003bd0: 2020 2020 2020 2020 2065 6467 6573 2e7a           edges.z
+00003be0: 5b30 5d20 2b20 6564 6765 732e 7a5b 325d  [0] + edges.z[2]
+00003bf0: 2c20 6564 6765 732e 7a5b 315d 202b 2065  , edges.z[1] + e
+00003c00: 6467 6573 2e7a 5b33 5d2c 0a20 2020 2020  dges.z[3],.     
+00003c10: 2020 2020 2020 2020 2020 2065 6467 6573             edges
+00003c20: 2e78 5b30 5d20 2b20 6564 6765 732e 7a5b  .x[0] + edges.z[
+00003c30: 325d 2c20 6564 6765 732e 785b 305d 202b  2], edges.x[0] +
+00003c40: 2065 6467 6573 2e7a 5b33 5d2c 0a20 2020   edges.z[3],.   
+00003c50: 2020 2020 2020 2020 2020 2020 2065 6467               edg
+00003c60: 6573 2e78 5b31 5d20 2b20 6564 6765 732e  es.x[1] + edges.
+00003c70: 7a5b 305d 2c20 6564 6765 732e 785b 315d  z[0], edges.x[1]
+00003c80: 202b 2065 6467 6573 2e7a 5b31 5d2c 0a20   + edges.z[1],. 
+00003c90: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00003ca0: 6467 6573 2e78 5b32 5d20 2b20 6564 6765  dges.x[2] + edge
+00003cb0: 732e 7a5b 325d 2c20 6564 6765 732e 785b  s.z[2], edges.x[
+00003cc0: 325d 202b 2065 6467 6573 2e7a 5b33 5d2c  2] + edges.z[3],
+00003cd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003ce0: 2065 6467 6573 2e78 5b33 5d20 2b20 6564   edges.x[3] + ed
+00003cf0: 6765 732e 7a5b 305d 2c20 6564 6765 732e  ges.z[0], edges.
+00003d00: 785b 335d 202b 2065 6467 6573 2e7a 5b31  x[3] + edges.z[1
+00003d10: 5d0a 2020 2020 2020 2020 2020 2020 2920  ].            ) 
+00003d20: 2a20 7272 3b0a 2020 2020 2020 2020 2020  * rr;.          
+00003d30: 2020 6d69 6e7a 203d 206d 6178 280a 2020    minz = max(.  
+00003d40: 2020 2020 2020 2020 2020 2020 2020 6564                ed
+00003d50: 6765 732e 785b 305d 202b 2065 6467 6573  ges.x[0] + edges
+00003d60: 2e78 5b32 5d2c 2065 6467 6573 2e78 5b31  .x[2], edges.x[1
+00003d70: 5d20 2b20 6564 6765 732e 785b 335d 2c0a  ] + edges.x[3],.
+00003d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003d90: 6564 6765 732e 795b 305d 202b 2065 6467  edges.y[0] + edg
+00003da0: 6573 2e79 5b32 5d2c 2065 6467 6573 2e79  es.y[2], edges.y
+00003db0: 5b31 5d20 2b20 6564 6765 732e 795b 335d  [1] + edges.y[3]
+00003dc0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00003dd0: 2020 6564 6765 732e 785b 305d 202b 2065    edges.x[0] + e
+00003de0: 6467 6573 2e79 5b32 5d2c 2065 6467 6573  dges.y[2], edges
+00003df0: 2e78 5b30 5d20 2b20 6564 6765 732e 795b  .x[0] + edges.y[
+00003e00: 335d 2c0a 2020 2020 2020 2020 2020 2020  3],.            
+00003e10: 2020 2020 6564 6765 732e 785b 315d 202b      edges.x[1] +
+00003e20: 2065 6467 6573 2e79 5b32 5d2c 2065 6467   edges.y[2], edg
+00003e30: 6573 2e78 5b31 5d20 2b20 6564 6765 732e  es.x[1] + edges.
+00003e40: 795b 335d 2c0a 2020 2020 2020 2020 2020  y[3],.          
+00003e50: 2020 2020 2020 6564 6765 732e 785b 325d        edges.x[2]
+00003e60: 202b 2065 6467 6573 2e79 5b30 5d2c 2065   + edges.y[0], e
+00003e70: 6467 6573 2e78 5b32 5d20 2b20 6564 6765  dges.x[2] + edge
+00003e80: 732e 795b 315d 2c0a 2020 2020 2020 2020  s.y[1],.        
+00003e90: 2020 2020 2020 2020 6564 6765 732e 785b          edges.x[
+00003ea0: 335d 202b 2065 6467 6573 2e79 5b30 5d2c  3] + edges.y[0],
+00003eb0: 2065 6467 6573 2e78 5b33 5d20 2b20 6564   edges.x[3] + ed
+00003ec0: 6765 732e 795b 315d 0a20 2020 2020 2020  ges.y[1].       
+00003ed0: 2020 2020 2029 202a 2072 723b 0a20 2020       ) * rr;.   
+00003ee0: 2020 2020 2020 2020 2063 6865 636b 203d           check =
+00003ef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003f00: 2061 7373 6572 7428 6d69 6e78 203c 3d20   assert(minx <= 
+00003f10: 7369 7a65 2e78 2c20 2252 6f75 6e64 696e  size.x, "Roundin
+00003f20: 6720 6f72 2063 6861 6d66 6572 696e 6720  g or chamfering 
+00003f30: 746f 6f20 6c61 7267 6520 666f 7220 6375  too large for cu
+00003f40: 626f 6964 2073 697a 6520 696e 2074 6865  boid size in the
+00003f50: 2058 2061 7869 732e 2229 0a20 2020 2020   X axis.").     
+00003f60: 2020 2020 2020 2020 2020 2061 7373 6572             asser
+00003f70: 7428 6d69 6e79 203c 3d20 7369 7a65 2e79  t(miny <= size.y
+00003f80: 2c20 2252 6f75 6e64 696e 6720 6f72 2063  , "Rounding or c
+00003f90: 6861 6d66 6572 696e 6720 746f 6f20 6c61  hamfering too la
+00003fa0: 7267 6520 666f 7220 6375 626f 6964 2073  rge for cuboid s
+00003fb0: 697a 6520 696e 2074 6865 2059 2061 7869  ize in the Y axi
+00003fc0: 732e 2229 0a20 2020 2020 2020 2020 2020  s.").           
+00003fd0: 2020 2020 2061 7373 6572 7428 6d69 6e7a       assert(minz
+00003fe0: 203c 3d20 7369 7a65 2e7a 2c20 2252 6f75   <= size.z, "Rou
+00003ff0: 6e64 696e 6720 6f72 2063 6861 6d66 6572  nding or chamfer
+00004000: 696e 6720 746f 6f20 6c61 7267 6520 666f  ing too large fo
+00004010: 7220 6375 626f 6964 2073 697a 6520 696e  r cuboid size in
+00004020: 2074 6865 205a 2061 7869 732e 2229 0a20   the Z axis."). 
+00004030: 2020 2020 2020 2020 2020 203b 0a20 2020             ;.   
+00004040: 2020 2020 207d 0a20 2020 2020 2020 206d       }.        m
+00004050: 616a 726f 7473 203d 205b 5b30 2c39 302c  ajrots = [[0,90,
+00004060: 305d 2c20 5b39 302c 302c 305d 2c20 5b30  0], [90,0,0], [0
+00004070: 2c30 2c30 5d5d 3b0a 2020 2020 2020 2020  ,0,0]];.        
+00004080: 6174 7461 6368 6162 6c65 2861 6e63 686f  attachable(ancho
+00004090: 722c 7370 696e 2c6f 7269 656e 742c 2073  r,spin,orient, s
+000040a0: 697a 653d 7369 7a65 2920 7b0a 2020 2020  ize=size) {.    
+000040b0: 2020 2020 2020 2020 6966 2028 6973 5f66          if (is_f
+000040c0: 696e 6974 6528 6368 616d 6665 7229 2026  inite(chamfer) &
+000040d0: 2620 2161 7070 726f 7828 6368 616d 6665  & !approx(chamfe
+000040e0: 722c 3029 2920 7b0a 2020 2020 2020 2020  r,0)) {.        
+000040f0: 2020 2020 2020 2020 6966 2028 6564 6765          if (edge
+00004100: 7320 3d3d 2045 4447 4553 5f41 4c4c 2026  s == EDGES_ALL &
+00004110: 2620 7472 696d 636f 726e 6572 7329 207b  & trimcorners) {
+00004120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004130: 2020 2020 2069 6620 2863 6861 6d66 6572       if (chamfer
+00004140: 3c30 2920 7b0a 2020 2020 2020 2020 2020  <0) {.          
+00004150: 2020 2020 2020 2020 2020 2020 2020 6375                cu
+00004160: 6265 2873 697a 652c 2063 656e 7465 723d  be(size, center=
+00004170: 7472 7565 2920 7b0a 2020 2020 2020 2020  true) {.        
+00004180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004190: 2020 2020 6174 7461 6368 2854 4f50 2c6f      attach(TOP,o
+000041a0: 7665 726c 6170 3d30 2920 7072 6973 6d6f  verlap=0) prismo
+000041b0: 6964 285b 7369 7a65 2e78 2c73 697a 652e  id([size.x,size.
+000041c0: 795d 2c20 5b73 697a 652e 782d 322a 6368  y], [size.x-2*ch
+000041d0: 616d 6665 722c 7369 7a65 2e79 2d32 2a63  amfer,size.y-2*c
+000041e0: 6861 6d66 6572 5d2c 2068 3d2d 6368 616d  hamfer], h=-cham
+000041f0: 6665 722c 2061 6e63 686f 723d 544f 5029  fer, anchor=TOP)
+00004200: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00004210: 2020 2020 2020 2020 2020 2020 2020 6174                at
+00004220: 7461 6368 2842 4f54 2c6f 7665 726c 6170  tach(BOT,overlap
+00004230: 3d30 2920 7072 6973 6d6f 6964 285b 7369  =0) prismoid([si
+00004240: 7a65 2e78 2c73 697a 652e 795d 2c20 5b73  ze.x,size.y], [s
+00004250: 697a 652e 782d 322a 6368 616d 6665 722c  ize.x-2*chamfer,
+00004260: 7369 7a65 2e79 2d32 2a63 6861 6d66 6572  size.y-2*chamfer
+00004270: 5d2c 2068 3d2d 6368 616d 6665 722c 2061  ], h=-chamfer, a
+00004280: 6e63 686f 723d 544f 5029 3b0a 2020 2020  nchor=TOP);.    
+00004290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000042a0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
 000042b0: 2020 2020 2020 2020 2020 7d20 656c 7365            } else
-000042c0: 2069 6620 2863 6861 6d66 6572 3c30 2920   if (chamfer<0) 
-000042d0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-000042e0: 2020 2020 2020 6368 6563 6b73 203d 2061        checks = a
-000042f0: 7373 6572 7428 6564 6765 7320 3d3d 2045  ssert(edges == E
-00004300: 4447 4553 5f41 4c4c 207c 7c20 6564 6765  DGES_ALL || edge
-00004310: 735b 325d 203d 3d20 5b30 2c30 2c30 2c30  s[2] == [0,0,0,0
-00004320: 5d2c 2022 4361 6e6e 6f74 2075 7365 206e  ], "Cannot use n
-00004330: 6567 6174 6976 6520 6368 616d 6665 7220  egative chamfer 
-00004340: 7769 7468 205a 2061 6c69 676e 6564 2065  with Z aligned e
-00004350: 6467 6573 2e22 293b 0a20 2020 2020 2020  dges.");.       
-00004360: 2020 2020 2020 2020 2020 2020 2061 6368               ach
-00004370: 203d 2061 6273 2863 6861 6d66 6572 293b   = abs(chamfer);
-00004380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004390: 2020 2020 2063 7562 6528 7369 7a65 2c20       cube(size, 
-000043a0: 6365 6e74 6572 3d74 7275 6529 3b0a 0a20  center=true);.. 
-000043b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000043c0: 2020 202f 2f20 4578 7465 726e 616c 2d43     // External-C
-000043d0: 6861 6d66 6572 206d 6173 6b20 6564 6765  hamfer mask edge
-000043e0: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-000043f0: 2020 2020 2020 6469 6666 6572 656e 6365        difference
-00004400: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00004410: 2020 2020 2020 2020 2020 2020 2075 6e69               uni
-00004420: 6f6e 2829 207b 0a20 2020 2020 2020 2020  on() {.         
+000042c0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+000042d0: 2020 2020 2020 2020 2020 2069 7369 7a65             isize
+000042e0: 203d 205b 666f 7220 2876 203d 2073 697a   = [for (v = siz
+000042f0: 6529 206d 6178 2830 2e30 3031 2c20 762d  e) max(0.001, v-
+00004300: 322a 6368 616d 6665 7229 5d3b 0a20 2020  2*chamfer)];.   
+00004310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004320: 2020 2020 2068 756c 6c28 2920 7b0a 2020       hull() {.  
+00004330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004340: 2020 2020 2020 2020 2020 6375 6265 285b            cube([
+00004350: 2073 697a 652e 782c 2069 7369 7a65 2e79   size.x, isize.y
+00004360: 2c20 6973 697a 652e 7a5d 2c20 6365 6e74  , isize.z], cent
+00004370: 6572 3d74 7275 6529 3b0a 2020 2020 2020  er=true);.      
+00004380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004390: 2020 2020 2020 6375 6265 285b 6973 697a        cube([isiz
+000043a0: 652e 782c 2020 7369 7a65 2e79 2c20 6973  e.x,  size.y, is
+000043b0: 697a 652e 7a5d 2c20 6365 6e74 6572 3d74  ize.z], center=t
+000043c0: 7275 6529 3b0a 2020 2020 2020 2020 2020  rue);.          
+000043d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000043e0: 2020 6375 6265 285b 6973 697a 652e 782c    cube([isize.x,
+000043f0: 2069 7369 7a65 2e79 2c20 2073 697a 652e   isize.y,  size.
+00004400: 7a5d 2c20 6365 6e74 6572 3d74 7275 6529  z], center=true)
+00004410: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00004420: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
 00004430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004440: 2020 2066 6f72 2028 6920 3d20 5b30 3a33     for (i = [0:3
-00004450: 5d2c 2061 7869 733d 5b30 3a31 5d29 207b  ], axis=[0:1]) {
-00004460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004480: 2069 6620 2865 6467 6573 5b61 7869 735d   if (edges[axis]
-00004490: 5b69 5d3e 3029 207b 0a20 2020 2020 2020  [i]>0) {.       
-000044a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000044b0: 2020 2020 2020 2020 2020 2020 2076 6563               vec
-000044c0: 203d 2045 4447 455f 4f46 4653 4554 535b   = EDGE_OFFSETS[
-000044d0: 6178 6973 5d5b 695d 3b0a 2020 2020 2020  axis][i];.      
-000044e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000044f0: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00004500: 616e 736c 6174 6528 765f 6d75 6c28 7665  anslate(v_mul(ve
-00004510: 632f 322c 2073 697a 652b 5b61 6368 2c61  c/2, size+[ach,a
-00004520: 6368 2c2d 6163 685d 2929 207b 0a20 2020  ch,-ach])) {.   
-00004530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004550: 2020 2020 2072 6f74 6174 6528 6d61 6a72       rotate(majr
-00004560: 6f74 735b 6178 6973 5d29 207b 0a20 2020  ots[axis]) {.   
-00004570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004590: 2020 2020 2020 2020 2063 7562 6528 5b61           cube([a
-000045a0: 6368 2c20 6163 682c 2073 697a 655b 6178  ch, ach, size[ax
-000045b0: 6973 5d5d 2c20 6365 6e74 6572 3d74 7275  is]], center=tru
-000045c0: 6529 3b0a 2020 2020 2020 2020 2020 2020  e);.            
-000045d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045e0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-000045f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004440: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+00004450: 2020 7d20 656c 7365 2069 6620 2863 6861    } else if (cha
+00004460: 6d66 6572 3c30 2920 7b0a 2020 2020 2020  mfer<0) {.      
+00004470: 2020 2020 2020 2020 2020 2020 2020 6368                ch
+00004480: 6563 6b73 203d 2061 7373 6572 7428 6564  ecks = assert(ed
+00004490: 6765 7320 3d3d 2045 4447 4553 5f41 4c4c  ges == EDGES_ALL
+000044a0: 207c 7c20 6564 6765 735b 325d 203d 3d20   || edges[2] == 
+000044b0: 5b30 2c30 2c30 2c30 5d2c 2022 4361 6e6e  [0,0,0,0], "Cann
+000044c0: 6f74 2075 7365 206e 6567 6174 6976 6520  ot use negative 
+000044d0: 6368 616d 6665 7220 7769 7468 205a 2061  chamfer with Z a
+000044e0: 6c69 676e 6564 2065 6467 6573 2e22 293b  ligned edges.");
+000044f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004500: 2020 2020 2061 6368 203d 2061 6273 2863       ach = abs(c
+00004510: 6861 6d66 6572 293b 0a20 2020 2020 2020  hamfer);.       
+00004520: 2020 2020 2020 2020 2020 2020 2063 7562               cub
+00004530: 6528 7369 7a65 2c20 6365 6e74 6572 3d74  e(size, center=t
+00004540: 7275 6529 3b0a 0a20 2020 2020 2020 2020  rue);..         
+00004550: 2020 2020 2020 2020 2020 202f 2f20 4578             // Ex
+00004560: 7465 726e 616c 2d43 6861 6d66 6572 206d  ternal-Chamfer m
+00004570: 6173 6b20 6564 6765 730a 2020 2020 2020  ask edges.      
+00004580: 2020 2020 2020 2020 2020 2020 2020 6469                di
+00004590: 6666 6572 656e 6365 2829 207b 0a20 2020  fference() {.   
+000045a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000045b0: 2020 2020 2075 6e69 6f6e 2829 207b 0a20       union() {. 
+000045c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000045d0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
+000045e0: 6920 3d20 5b30 3a33 5d2c 2061 7869 733d  i = [0:3], axis=
+000045f0: 5b30 3a31 5d29 207b 0a20 2020 2020 2020  [0:1]) {.       
 00004600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004610: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00004620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004630: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+00004610: 2020 2020 2020 2020 2069 6620 2865 6467           if (edg
+00004620: 6573 5b61 7869 735d 5b69 5d3e 3029 207b  es[axis][i]>0) {
+00004630: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00004640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004650: 2020 7d0a 0a20 2020 2020 2020 2020 2020    }..           
-00004660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004670: 202f 2f20 4164 6420 6d75 6c74 692d 6564   // Add multi-ed
-00004680: 6765 2063 6f72 6e65 7273 2e0a 2020 2020  ge corners..    
-00004690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000046a0: 2020 2020 2020 2020 6966 2028 7472 696d          if (trim
-000046b0: 636f 726e 6572 7329 207b 0a20 2020 2020  corners) {.     
-000046c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000046d0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-000046e0: 7a61 3d5b 2d31 2c31 5d2c 2079 613d 5b2d  za=[-1,1], ya=[-
-000046f0: 312c 315d 2c20 7861 3d5b 2d31 2c31 5d29  1,1], xa=[-1,1])
-00004700: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00004650: 2020 2020 2076 6563 203d 2045 4447 455f       vec = EDGE_
+00004660: 4f46 4653 4554 535b 6178 6973 5d5b 695d  OFFSETS[axis][i]
+00004670: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00004680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004690: 2020 2020 2020 7472 616e 736c 6174 6528        translate(
+000046a0: 765f 6d75 6c28 7665 632f 322c 2073 697a  v_mul(vec/2, siz
+000046b0: 652b 5b61 6368 2c61 6368 2c2d 6163 685d  e+[ach,ach,-ach]
+000046c0: 2929 207b 0a20 2020 2020 2020 2020 2020  )) {.           
+000046d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000046e0: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
+000046f0: 6174 6528 6d61 6a72 6f74 735b 6178 6973  ate(majrots[axis
+00004700: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
 00004710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004720: 2020 2020 2020 2063 6520 3d20 5f63 6f72         ce = _cor
-00004730: 6e65 725f 6564 6765 7328 6564 6765 732c  ner_edges(edges,
-00004740: 205b 7861 2c79 612c 7a61 5d29 3b0a 2020   [xa,ya,za]);.  
-00004750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004730: 2063 7562 6528 5b61 6368 2c20 6163 682c   cube([ach, ach,
+00004740: 2073 697a 655b 6178 6973 5d5d 2c20 6365   size[axis]], ce
+00004750: 6e74 6572 3d74 7275 6529 3b0a 2020 2020  nter=true);.    
 00004760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004770: 2020 6966 2028 6365 2e78 202b 2063 652e    if (ce.x + ce.
-00004780: 7920 3e20 3129 207b 0a20 2020 2020 2020  y > 1) {.       
+00004770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004780: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
 00004790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000047a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000047b0: 2074 7261 6e73 6c61 7465 2876 5f6d 756c   translate(v_mul
-000047c0: 285b 7861 2c79 612c 7a61 5d2f 322c 2073  ([xa,ya,za]/2, s
-000047d0: 697a 652b 5b61 6368 2d30 2e30 312c 6163  ize+[ach-0.01,ac
-000047e0: 682d 302e 3031 2c2d 6163 685d 2929 207b  h-0.01,-ach])) {
-000047f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004810: 2020 2020 2020 2020 2020 2020 2063 7562               cub
-00004820: 6528 5b61 6368 2b30 2e30 312c 6163 682b  e([ach+0.01,ach+
-00004830: 302e 3031 2c61 6368 5d2c 2063 656e 7465  0.01,ach], cente
-00004840: 723d 7472 7565 293b 0a20 2020 2020 2020  r=true);.       
-00004850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000047a0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+000047b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000047c0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+000047d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000047e0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+000047f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004800: 2020 2020 2020 2020 202f 2f20 4164 6420           // Add 
+00004810: 6d75 6c74 692d 6564 6765 2063 6f72 6e65  multi-edge corne
+00004820: 7273 2e0a 2020 2020 2020 2020 2020 2020  rs..            
+00004830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004840: 6966 2028 7472 696d 636f 726e 6572 7329  if (trimcorners)
+00004850: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
 00004860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004870: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-00004880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004890: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00004870: 2020 2066 6f72 2028 7a61 3d5b 2d31 2c31     for (za=[-1,1
+00004880: 5d2c 2079 613d 5b2d 312c 315d 2c20 7861  ], ya=[-1,1], xa
+00004890: 3d5b 2d31 2c31 5d29 207b 0a20 2020 2020  =[-1,1]) {.     
 000048a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048b0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-000048c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048d0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-000048e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048f0: 207d 0a0a 2020 2020 2020 2020 2020 2020   }..            
-00004900: 2020 2020 2020 2020 2020 2020 2f2f 2052              // R
-00004910: 656d 6f76 6520 6265 7665 6c73 2066 726f  emove bevels fro
-00004920: 6d20 6f76 6572 6861 6e67 732e 0a20 2020  m overhangs..   
+000048b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000048c0: 6520 3d20 5f63 6f72 6e65 725f 6564 6765  e = _corner_edge
+000048d0: 7328 6564 6765 732c 205b 7861 2c79 612c  s(edges, [xa,ya,
+000048e0: 7a61 5d29 3b0a 2020 2020 2020 2020 2020  za]);.          
+000048f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004900: 2020 2020 2020 2020 2020 6966 2028 6365            if (ce
+00004910: 2e78 202b 2063 652e 7920 3e20 3129 207b  .x + ce.y > 1) {
+00004920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00004930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004940: 2020 2020 2066 6f72 2028 6920 3d20 5b30       for (i = [0
-00004950: 3a33 5d2c 2061 7869 733d 5b30 3a31 5d29  :3], axis=[0:1])
-00004960: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00004970: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00004980: 6620 2865 6467 6573 5b61 7869 735d 5b69  f (edges[axis][i
-00004990: 5d3e 3029 207b 0a20 2020 2020 2020 2020  ]>0) {.         
+00004940: 2020 2020 2020 2020 2074 7261 6e73 6c61           transla
+00004950: 7465 2876 5f6d 756c 285b 7861 2c79 612c  te(v_mul([xa,ya,
+00004960: 7a61 5d2f 322c 2073 697a 652b 5b61 6368  za]/2, size+[ach
+00004970: 2d30 2e30 312c 6163 682d 302e 3031 2c2d  -0.01,ach-0.01,-
+00004980: 6163 685d 2929 207b 0a20 2020 2020 2020  ach])) {.       
+00004990: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000049a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000049b0: 2020 2020 2020 2076 6563 203d 2045 4447         vec = EDG
-000049c0: 455f 4f46 4653 4554 535b 6178 6973 5d5b  E_OFFSETS[axis][
-000049d0: 695d 3b0a 2020 2020 2020 2020 2020 2020  i];.            
-000049e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000049f0: 2020 2020 7472 616e 736c 6174 6528 765f      translate(v_
-00004a00: 6d75 6c28 7665 632f 322c 2073 697a 652b  mul(vec/2, size+
-00004a10: 5b32 2a61 6368 2c32 2a61 6368 2c2d 322a  [2*ach,2*ach,-2*
-00004a20: 6163 685d 2929 207b 0a20 2020 2020 2020  ach])) {.       
-00004a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a40: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
-00004a50: 6174 6528 6d61 6a72 6f74 735b 6178 6973  ate(majrots[axis
-00004a60: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
-00004a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a80: 2020 2020 2020 2020 2020 2020 207a 726f               zro
-00004a90: 7428 3435 2920 6375 6265 285b 6163 682a  t(45) cube([ach*
-00004aa0: 7371 7274 2832 292c 2061 6368 2a73 7172  sqrt(2), ach*sqr
-00004ab0: 7428 3229 2c20 7369 7a65 5b61 7869 735d  t(2), size[axis]
-00004ac0: 2b32 2e31 2a61 6368 5d2c 2063 656e 7465  +2.1*ach], cente
-00004ad0: 723d 7472 7565 293b 0a20 2020 2020 2020  r=true);.       
-00004ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004af0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+000049b0: 2020 2020 2063 7562 6528 5b61 6368 2b30       cube([ach+0
+000049c0: 2e30 312c 6163 682b 302e 3031 2c61 6368  .01,ach+0.01,ach
+000049d0: 5d2c 2063 656e 7465 723d 7472 7565 293b  ], center=true);
+000049e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000049f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a00: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00004a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a20: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00004a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a50: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00004a60: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00004a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004a80: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
+00004a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004aa0: 2020 2020 2f2f 2052 656d 6f76 6520 6265      // Remove be
+00004ab0: 7665 6c73 2066 726f 6d20 6f76 6572 6861  vels from overha
+00004ac0: 6e67 732e 0a20 2020 2020 2020 2020 2020  ngs..           
+00004ad0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00004ae0: 2028 6920 3d20 5b30 3a33 5d2c 2061 7869   (i = [0:3], axi
+00004af0: 733d 5b30 3a31 5d29 207b 0a20 2020 2020  s=[0:1]) {.     
 00004b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b10: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00004b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004b30: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
-00004b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b50: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-00004b60: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
-00004b70: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00004b80: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
-00004b90: 2020 2020 2020 2020 2020 2020 6875 6c6c              hull
-00004ba0: 2829 207b 0a20 2020 2020 2020 2020 2020  () {.           
-00004bb0: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
-00004bc0: 6e65 725f 7368 6170 6528 5b2d 312c 2d31  ner_shape([-1,-1
-00004bd0: 2c2d 315d 293b 0a20 2020 2020 2020 2020  ,-1]);.         
-00004be0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00004bf0: 6f72 6e65 725f 7368 6170 6528 5b20 312c  orner_shape([ 1,
-00004c00: 2d31 2c2d 315d 293b 0a20 2020 2020 2020  -1,-1]);.       
+00004b10: 2020 2020 2020 2069 6620 2865 6467 6573         if (edges
+00004b20: 5b61 7869 735d 5b69 5d3e 3029 207b 0a20  [axis][i]>0) {. 
+00004b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b40: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00004b50: 6563 203d 2045 4447 455f 4f46 4653 4554  ec = EDGE_OFFSET
+00004b60: 535b 6178 6973 5d5b 695d 3b0a 2020 2020  S[axis][i];.    
+00004b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b80: 2020 2020 2020 2020 2020 2020 7472 616e              tran
+00004b90: 736c 6174 6528 765f 6d75 6c28 7665 632f  slate(v_mul(vec/
+00004ba0: 322c 2073 697a 652b 5b32 2a61 6368 2c32  2, size+[2*ach,2
+00004bb0: 2a61 6368 2c2d 322a 6163 685d 2929 207b  *ach,-2*ach])) {
+00004bc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004be0: 2020 2020 2072 6f74 6174 6528 6d61 6a72       rotate(majr
+00004bf0: 6f74 735b 6178 6973 5d29 207b 0a20 2020  ots[axis]) {.   
+00004c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00004c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c20: 2063 6f72 6e65 725f 7368 6170 6528 5b2d   corner_shape([-
-00004c30: 312c 2031 2c2d 315d 293b 0a20 2020 2020  1, 1,-1]);.     
-00004c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c50: 2020 2063 6f72 6e65 725f 7368 6170 6528     corner_shape(
-00004c60: 5b20 312c 2031 2c2d 315d 293b 0a20 2020  [ 1, 1,-1]);.   
-00004c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004c80: 2020 2020 2063 6f72 6e65 725f 7368 6170       corner_shap
-00004c90: 6528 5b2d 312c 2d31 2c20 315d 293b 0a20  e([-1,-1, 1]);. 
+00004c20: 2020 2020 207a 726f 7428 3435 2920 6375       zrot(45) cu
+00004c30: 6265 285b 6163 682a 7371 7274 2832 292c  be([ach*sqrt(2),
+00004c40: 2061 6368 2a73 7172 7428 3229 2c20 7369   ach*sqrt(2), si
+00004c50: 7a65 5b61 7869 735d 2b32 2e31 2a61 6368  ze[axis]+2.1*ach
+00004c60: 5d2c 2063 656e 7465 723d 7472 7565 293b  ], center=true);
+00004c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c90: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
 00004ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004cb0: 2020 2020 2020 2063 6f72 6e65 725f 7368         corner_sh
-00004cc0: 6170 6528 5b20 312c 2d31 2c20 315d 293b  ape([ 1,-1, 1]);
-00004cd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004ce0: 2020 2020 2020 2020 2063 6f72 6e65 725f           corner_
-00004cf0: 7368 6170 6528 5b2d 312c 2031 2c20 315d  shape([-1, 1, 1]
-00004d00: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00004d10: 2020 2020 2020 2020 2020 2063 6f72 6e65             corne
-00004d20: 725f 7368 6170 6528 5b20 312c 2031 2c20  r_shape([ 1, 1, 
-00004d30: 315d 293b 0a20 2020 2020 2020 2020 2020  1]);.           
-00004d40: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-00004d50: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-00004d60: 2020 2020 2020 2020 207d 2065 6c73 6520           } else 
-00004d70: 6966 2028 6973 5f66 696e 6974 6528 726f  if (is_finite(ro
-00004d80: 756e 6469 6e67 2920 2626 2021 6170 7072  unding) && !appr
-00004d90: 6f78 2872 6f75 6e64 696e 672c 3029 2920  ox(rounding,0)) 
-00004da0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00004db0: 2020 7369 6465 7320 3d20 7175 616e 7475    sides = quantu
-00004dc0: 7028 7365 6773 2872 6f75 6e64 696e 6729  p(segs(rounding)
-00004dd0: 2c34 293b 0a20 2020 2020 2020 2020 2020  ,4);.           
-00004de0: 2020 2020 2069 6620 2865 6467 6573 203d       if (edges =
-00004df0: 3d20 4544 4745 535f 414c 4c29 207b 0a20  = EDGES_ALL) {. 
-00004e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e10: 2020 2069 6628 726f 756e 6469 6e67 3c30     if(rounding<0
-00004e20: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00004e30: 2020 2020 2020 2020 2020 2020 6375 6265              cube
-00004e40: 2873 697a 652c 2063 656e 7465 723d 7472  (size, center=tr
-00004e50: 7565 293b 0a20 2020 2020 2020 2020 2020  ue);.           
-00004e60: 2020 2020 2020 2020 2020 2020 207a 666c               zfl
-00004e70: 6970 5f63 6f70 7928 2920 7b0a 2020 2020  ip_copy() {.    
-00004e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e90: 2020 2020 2020 2020 7570 2873 697a 652e          up(size.
-00004ea0: 7a2f 3229 207b 0a20 2020 2020 2020 2020  z/2) {.         
-00004eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ec0: 2020 2020 2020 2064 6966 6665 7265 6e63         differenc
-00004ed0: 6528 2920 7b0a 2020 2020 2020 2020 2020  e() {.          
-00004ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ef0: 2020 2020 2020 2020 2020 646f 776e 282d            down(-
-00004f00: 726f 756e 6469 6e67 2f32 2920 6375 6265  rounding/2) cube
-00004f10: 285b 7369 7a65 2e78 2d32 2a72 6f75 6e64  ([size.x-2*round
-00004f20: 696e 672c 2073 697a 652e 792d 322a 726f  ing, size.y-2*ro
-00004f30: 756e 6469 6e67 2c20 2d72 6f75 6e64 696e  unding, -roundin
-00004f40: 675d 2c20 6365 6e74 6572 3d74 7275 6529  g], center=true)
-00004f50: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00004f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004f70: 2020 2020 2020 646f 776e 282d 726f 756e        down(-roun
-00004f80: 6469 6e67 2920 7b0a 2020 2020 2020 2020  ding) {.        
-00004f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004fb0: 7963 6f70 6965 7328 7369 7a65 2e79 2d32  ycopies(size.y-2
-00004fc0: 2a72 6f75 6e64 696e 6729 2078 6379 6c28  *rounding) xcyl(
-00004fd0: 6c3d 7369 7a65 2e78 2d33 2a72 6f75 6e64  l=size.x-3*round
-00004fe0: 696e 672c 2072 3d2d 726f 756e 6469 6e67  ing, r=-rounding
-00004ff0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00005000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005010: 2020 2020 2020 2020 2020 2078 636f 7069             xcopi
-00005020: 6573 2873 697a 652e 782d 322a 726f 756e  es(size.x-2*roun
-00005030: 6469 6e67 2920 7963 796c 286c 3d73 697a  ding) ycyl(l=siz
-00005040: 652e 792d 332a 726f 756e 6469 6e67 2c20  e.y-3*rounding, 
-00005050: 723d 2d72 6f75 6e64 696e 6729 3b0a 2020  r=-rounding);.  
-00005060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004cb0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00004cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004cd0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00004ce0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
+00004cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004d00: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00004d10: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
+00004d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d30: 2020 2020 6875 6c6c 2829 207b 0a20 2020      hull() {.   
+00004d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d50: 2020 2020 2063 6f72 6e65 725f 7368 6170       corner_shap
+00004d60: 6528 5b2d 312c 2d31 2c2d 315d 293b 0a20  e([-1,-1,-1]);. 
+00004d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d80: 2020 2020 2020 2063 6f72 6e65 725f 7368         corner_sh
+00004d90: 6170 6528 5b20 312c 2d31 2c2d 315d 293b  ape([ 1,-1,-1]);
+00004da0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004db0: 2020 2020 2020 2020 2063 6f72 6e65 725f           corner_
+00004dc0: 7368 6170 6528 5b2d 312c 2031 2c2d 315d  shape([-1, 1,-1]
+00004dd0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00004de0: 2020 2020 2020 2020 2020 2063 6f72 6e65             corne
+00004df0: 725f 7368 6170 6528 5b20 312c 2031 2c2d  r_shape([ 1, 1,-
+00004e00: 315d 293b 0a20 2020 2020 2020 2020 2020  1]);.           
+00004e10: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
+00004e20: 6e65 725f 7368 6170 6528 5b2d 312c 2d31  ner_shape([-1,-1
+00004e30: 2c20 315d 293b 0a20 2020 2020 2020 2020  , 1]);.         
+00004e40: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00004e50: 6f72 6e65 725f 7368 6170 6528 5b20 312c  orner_shape([ 1,
+00004e60: 2d31 2c20 315d 293b 0a20 2020 2020 2020  -1, 1]);.       
+00004e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e80: 2063 6f72 6e65 725f 7368 6170 6528 5b2d   corner_shape([-
+00004e90: 312c 2031 2c20 315d 293b 0a20 2020 2020  1, 1, 1]);.     
+00004ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004eb0: 2020 2063 6f72 6e65 725f 7368 6170 6528     corner_shape(
+00004ec0: 5b20 312c 2031 2c20 315d 293b 0a20 2020  [ 1, 1, 1]);.   
+00004ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ee0: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
+00004ef0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+00004f00: 207d 2065 6c73 6520 6966 2028 6973 5f66   } else if (is_f
+00004f10: 696e 6974 6528 726f 756e 6469 6e67 2920  inite(rounding) 
+00004f20: 2626 2021 6170 7072 6f78 2872 6f75 6e64  && !approx(round
+00004f30: 696e 672c 3029 2920 7b0a 2020 2020 2020  ing,0)) {.      
+00004f40: 2020 2020 2020 2020 2020 7369 6465 7320            sides 
+00004f50: 3d20 7175 616e 7475 7028 7365 6773 2872  = quantup(segs(r
+00004f60: 6f75 6e64 696e 6729 2c34 293b 0a20 2020  ounding),4);.   
+00004f70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00004f80: 2865 6467 6573 203d 3d20 4544 4745 535f  (edges == EDGES_
+00004f90: 414c 4c29 207b 0a20 2020 2020 2020 2020  ALL) {.         
+00004fa0: 2020 2020 2020 2020 2020 2069 6628 726f             if(ro
+00004fb0: 756e 6469 6e67 3c30 2920 7b0a 2020 2020  unding<0) {.    
+00004fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004fd0: 2020 2020 6375 6265 2873 697a 652c 2063      cube(size, c
+00004fe0: 656e 7465 723d 7472 7565 293b 0a20 2020  enter=true);.   
+00004ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005000: 2020 2020 207a 666c 6970 5f63 6f70 7928       zflip_copy(
+00005010: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00005020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005030: 7570 2873 697a 652e 7a2f 3229 207b 0a20  up(size.z/2) {. 
+00005040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005050: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00005060: 6966 6665 7265 6e63 6528 2920 7b0a 2020  ifference() {.  
 00005070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005080: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00005090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050a0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-000050b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050c0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-000050d0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-000050e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000050f0: 2020 7d20 656c 7365 207b 0a20 2020 2020    } else {.     
-00005100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005110: 2020 2069 7369 7a65 203d 205b 666f 7220     isize = [for 
-00005120: 2876 203d 2073 697a 6529 206d 6178 2830  (v = size) max(0
-00005130: 2e30 3031 2c20 762d 322a 726f 756e 6469  .001, v-2*roundi
-00005140: 6e67 295d 3b0a 2020 2020 2020 2020 2020  ng)];.          
-00005150: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
-00005160: 6e6b 6f77 736b 6928 2920 7b0a 2020 2020  nkowski() {.    
-00005170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005180: 2020 2020 2020 2020 6375 6265 2869 7369          cube(isi
-00005190: 7a65 2c20 6365 6e74 6572 3d74 7275 6529  ze, center=true)
-000051a0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-000051b0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-000051c0: 2028 7472 696d 636f 726e 6572 7329 207b   (trimcorners) {
-000051d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000051e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000051f0: 2074 7370 6865 7265 2872 3d72 6f75 6e64   tsphere(r=round
-00005200: 696e 672c 2024 666e 3d73 6964 6573 293b  ing, $fn=sides);
-00005210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005220: 2020 2020 2020 2020 2020 2020 207d 2065               } e
-00005230: 6c73 6520 7b0a 2020 2020 2020 2020 2020  lse {.          
+00005080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005090: 2020 646f 776e 282d 726f 756e 6469 6e67    down(-rounding
+000050a0: 2f32 2920 6375 6265 285b 7369 7a65 2e78  /2) cube([size.x
+000050b0: 2d32 2a72 6f75 6e64 696e 672c 2073 697a  -2*rounding, siz
+000050c0: 652e 792d 322a 726f 756e 6469 6e67 2c20  e.y-2*rounding, 
+000050d0: 2d72 6f75 6e64 696e 675d 2c20 6365 6e74  -rounding], cent
+000050e0: 6572 3d74 7275 6529 3b0a 2020 2020 2020  er=true);.      
+000050f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005100: 2020 2020 2020 2020 2020 2020 2020 646f                do
+00005110: 776e 282d 726f 756e 6469 6e67 2920 7b0a  wn(-rounding) {.
+00005120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005140: 2020 2020 2020 2020 7963 6f70 6965 7328          ycopies(
+00005150: 7369 7a65 2e79 2d32 2a72 6f75 6e64 696e  size.y-2*roundin
+00005160: 6729 2078 6379 6c28 6c3d 7369 7a65 2e78  g) xcyl(l=size.x
+00005170: 2d33 2a72 6f75 6e64 696e 672c 2072 3d2d  -3*rounding, r=-
+00005180: 726f 756e 6469 6e67 293b 0a20 2020 2020  rounding);.     
+00005190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000051a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000051b0: 2020 2078 636f 7069 6573 2873 697a 652e     xcopies(size.
+000051c0: 782d 322a 726f 756e 6469 6e67 2920 7963  x-2*rounding) yc
+000051d0: 796c 286c 3d73 697a 652e 792d 332a 726f  yl(l=size.y-3*ro
+000051e0: 756e 6469 6e67 2c20 723d 2d72 6f75 6e64  unding, r=-round
+000051f0: 696e 6729 3b0a 2020 2020 2020 2020 2020  ing);.          
+00005200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005210: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00005220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005230: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
 00005240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005250: 2020 2020 2020 696e 7465 7273 6563 7469        intersecti
-00005260: 6f6e 2829 207b 0a20 2020 2020 2020 2020  on() {.         
-00005270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005280: 2020 2020 2020 2020 2020 2078 7463 796c             xtcyl
-00005290: 2872 3d72 6f75 6e64 696e 672c 206c 3d72  (r=rounding, l=r
-000052a0: 6f75 6e64 696e 672a 322c 2024 666e 3d73  ounding*2, $fn=s
-000052b0: 6964 6573 293b 0a20 2020 2020 2020 2020  ides);.         
-000052c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000052d0: 2020 2020 2020 2020 2020 2079 7463 796c             ytcyl
-000052e0: 2872 3d72 6f75 6e64 696e 672c 206c 3d72  (r=rounding, l=r
-000052f0: 6f75 6e64 696e 672a 322c 2024 666e 3d73  ounding*2, $fn=s
-00005300: 6964 6573 293b 0a20 2020 2020 2020 2020  ides);.         
+00005250: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00005260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005270: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+00005280: 2020 2020 2020 2020 2020 7d20 656c 7365            } else
+00005290: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+000052a0: 2020 2020 2020 2020 2020 2069 7369 7a65             isize
+000052b0: 203d 205b 666f 7220 2876 203d 2073 697a   = [for (v = siz
+000052c0: 6529 206d 6178 2830 2e30 3031 2c20 762d  e) max(0.001, v-
+000052d0: 322a 726f 756e 6469 6e67 295d 3b0a 2020  2*rounding)];.  
+000052e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000052f0: 2020 2020 2020 6d69 6e6b 6f77 736b 6928        minkowski(
+00005300: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
 00005310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005320: 2020 2020 2020 2020 2020 2063 796c 2872             cyl(r
-00005330: 3d72 6f75 6e64 696e 672c 2068 3d72 6f75  =rounding, h=rou
-00005340: 6e64 696e 672a 322c 2024 666e 3d73 6964  nding*2, $fn=sid
-00005350: 6573 293b 0a20 2020 2020 2020 2020 2020  es);.           
-00005360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005370: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00005380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005390: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000053a0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00005320: 6375 6265 2869 7369 7a65 2c20 6365 6e74  cube(isize, cent
+00005330: 6572 3d74 7275 6529 3b0a 2020 2020 2020  er=true);.      
+00005340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005350: 2020 2020 2020 6966 2028 7472 696d 636f        if (trimco
+00005360: 726e 6572 7329 207b 0a20 2020 2020 2020  rners) {.       
+00005370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005380: 2020 2020 2020 2020 2074 7370 6865 7265           tsphere
+00005390: 2872 3d72 6f75 6e64 696e 672c 2024 666e  (r=rounding, $fn
+000053a0: 3d73 6964 6573 293b 0a20 2020 2020 2020  =sides);.       
 000053b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000053c0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000053d0: 2020 2020 207d 2065 6c73 6520 6966 2028       } else if (
-000053e0: 726f 756e 6469 6e67 3c30 2920 7b0a 2020  rounding<0) {.  
-000053f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005400: 2020 6368 6563 6b73 203d 2061 7373 6572    checks = asser
-00005410: 7428 6564 6765 7320 3d3d 2045 4447 4553  t(edges == EDGES
-00005420: 5f41 4c4c 207c 7c20 6564 6765 735b 325d  _ALL || edges[2]
-00005430: 203d 3d20 5b30 2c30 2c30 2c30 5d2c 2022   == [0,0,0,0], "
-00005440: 4361 6e6e 6f74 2075 7365 206e 6567 6174  Cannot use negat
-00005450: 6976 6520 726f 756e 6469 6e67 2077 6974  ive rounding wit
-00005460: 6820 5a20 616c 6967 6e65 6420 6564 6765  h Z aligned edge
-00005470: 732e 2229 3b0a 2020 2020 2020 2020 2020  s.");.          
-00005480: 2020 2020 2020 2020 2020 6172 6420 3d20            ard = 
-00005490: 6162 7328 726f 756e 6469 6e67 293b 0a20  abs(rounding);. 
+000053c0: 2020 2020 207d 2065 6c73 6520 7b0a 2020       } else {.  
+000053d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000053e0: 2020 2020 2020 2020 2020 2020 2020 696e                in
+000053f0: 7465 7273 6563 7469 6f6e 2829 207b 0a20  tersection() {. 
+00005400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005420: 2020 2078 7463 796c 2872 3d72 6f75 6e64     xtcyl(r=round
+00005430: 696e 672c 206c 3d72 6f75 6e64 696e 672a  ing, l=rounding*
+00005440: 322c 2024 666e 3d73 6964 6573 293b 0a20  2, $fn=sides);. 
+00005450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005470: 2020 2079 7463 796c 2872 3d72 6f75 6e64     ytcyl(r=round
+00005480: 696e 672c 206c 3d72 6f75 6e64 696e 672a  ing, l=rounding*
+00005490: 322c 2024 666e 3d73 6964 6573 293b 0a20  2, $fn=sides);. 
 000054a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000054b0: 2020 2063 7562 6528 7369 7a65 2c20 6365     cube(size, ce
-000054c0: 6e74 6572 3d74 7275 6529 3b0a 0a20 2020  nter=true);..   
-000054d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000054e0: 202f 2f20 4578 7465 726e 616c 2d52 6f75   // External-Rou
-000054f0: 6e64 696e 6720 6d61 736b 2065 6467 6573  nding mask edges
-00005500: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005510: 2020 2020 2064 6966 6665 7265 6e63 6528       difference(
-00005520: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-00005530: 2020 2020 2020 2020 2020 2020 756e 696f              unio
-00005540: 6e28 2920 7b0a 2020 2020 2020 2020 2020  n() {.          
-00005550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005560: 2020 666f 7220 2869 203d 205b 303a 335d    for (i = [0:3]
-00005570: 2c20 6178 6973 3d5b 303a 315d 2920 7b0a  , axis=[0:1]) {.
-00005580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000055a0: 6966 2028 6564 6765 735b 6178 6973 5d5b  if (edges[axis][
-000055b0: 695d 3e30 2920 7b0a 2020 2020 2020 2020  i]>0) {.        
-000055c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000055d0: 2020 2020 2020 2020 2020 2020 7665 6320              vec 
-000055e0: 3d20 4544 4745 5f4f 4646 5345 5453 5b61  = EDGE_OFFSETS[a
-000055f0: 7869 735d 5b69 5d3b 0a20 2020 2020 2020  xis][i];.       
-00005600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005610: 2020 2020 2020 2020 2020 2020 2074 7261               tra
-00005620: 6e73 6c61 7465 2876 5f6d 756c 2876 6563  nslate(v_mul(vec
-00005630: 2f32 2c20 7369 7a65 2b5b 6172 642c 6172  /2, size+[ard,ar
-00005640: 642c 2d61 7264 5d2d 5b30 2e30 312c 302e  d,-ard]-[0.01,0.
-00005650: 3031 2c30 5d29 2920 7b0a 2020 2020 2020  01,0])) {.      
-00005660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005680: 2020 726f 7461 7465 286d 616a 726f 7473    rotate(majrots
-00005690: 5b61 7869 735d 2920 7b0a 2020 2020 2020  [axis]) {.      
-000056a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000056b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000056c0: 2020 2020 2020 6375 6265 285b 6172 642c        cube([ard,
-000056d0: 2061 7264 2c20 7369 7a65 5b61 7869 735d   ard, size[axis]
-000056e0: 5d2c 2063 656e 7465 723d 7472 7565 293b  ], center=true);
-000056f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005710: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+000054b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000054c0: 2020 2063 796c 2872 3d72 6f75 6e64 696e     cyl(r=roundin
+000054d0: 672c 2068 3d72 6f75 6e64 696e 672a 322c  g, h=rounding*2,
+000054e0: 2024 666e 3d73 6964 6573 293b 0a20 2020   $fn=sides);.   
+000054f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005500: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00005510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005520: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00005530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005540: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00005550: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00005560: 2020 2020 2020 2020 2020 2020 207d 2065               } e
+00005570: 6c73 6520 6966 2028 726f 756e 6469 6e67  lse if (rounding
+00005580: 3c30 2920 7b0a 2020 2020 2020 2020 2020  <0) {.          
+00005590: 2020 2020 2020 2020 2020 6368 6563 6b73            checks
+000055a0: 203d 2061 7373 6572 7428 6564 6765 7320   = assert(edges 
+000055b0: 3d3d 2045 4447 4553 5f41 4c4c 207c 7c20  == EDGES_ALL || 
+000055c0: 6564 6765 735b 325d 203d 3d20 5b30 2c30  edges[2] == [0,0
+000055d0: 2c30 2c30 5d2c 2022 4361 6e6e 6f74 2075  ,0,0], "Cannot u
+000055e0: 7365 206e 6567 6174 6976 6520 726f 756e  se negative roun
+000055f0: 6469 6e67 2077 6974 6820 5a20 616c 6967  ding with Z alig
+00005600: 6e65 6420 6564 6765 732e 2229 3b0a 2020  ned edges.");.  
+00005610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005620: 2020 6172 6420 3d20 6162 7328 726f 756e    ard = abs(roun
+00005630: 6469 6e67 293b 0a20 2020 2020 2020 2020  ding);.         
+00005640: 2020 2020 2020 2020 2020 2063 7562 6528             cube(
+00005650: 7369 7a65 2c20 6365 6e74 6572 3d74 7275  size, center=tru
+00005660: 6529 3b0a 0a20 2020 2020 2020 2020 2020  e);..           
+00005670: 2020 2020 2020 2020 202f 2f20 4578 7465           // Exte
+00005680: 726e 616c 2d52 6f75 6e64 696e 6720 6d61  rnal-Rounding ma
+00005690: 736b 2065 6467 6573 0a20 2020 2020 2020  sk edges.       
+000056a0: 2020 2020 2020 2020 2020 2020 2064 6966               dif
+000056b0: 6665 7265 6e63 6528 2920 7b0a 2020 2020  ference() {.    
+000056c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000056d0: 2020 2020 756e 696f 6e28 2920 7b0a 2020      union() {.  
+000056e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000056f0: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
+00005700: 203d 205b 303a 335d 2c20 6178 6973 3d5b   = [0:3], axis=[
+00005710: 303a 315d 2920 7b0a 2020 2020 2020 2020  0:1]) {.        
 00005720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005730: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00005740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005730: 2020 2020 2020 2020 6966 2028 6564 6765          if (edge
+00005740: 735b 6178 6973 5d5b 695d 3e30 2920 7b0a  s[axis][i]>0) {.
 00005750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005760: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
-00005770: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00005780: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-00005790: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
-000057a0: 2041 6464 206d 756c 7469 2d65 6467 6520   Add multi-edge 
-000057b0: 636f 726e 6572 732e 0a20 2020 2020 2020  corners..       
-000057c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000057d0: 2020 2020 2069 6620 2874 7269 6d63 6f72       if (trimcor
-000057e0: 6e65 7273 2920 7b0a 2020 2020 2020 2020  ners) {.        
-000057f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005800: 2020 2020 2020 2020 666f 7220 287a 613d          for (za=
-00005810: 5b2d 312c 315d 2c20 7961 3d5b 2d31 2c31  [-1,1], ya=[-1,1
-00005820: 5d2c 2078 613d 5b2d 312c 315d 2920 7b0a  ], xa=[-1,1]) {.
-00005830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005770: 2020 2020 7665 6320 3d20 4544 4745 5f4f      vec = EDGE_O
+00005780: 4646 5345 5453 5b61 7869 735d 5b69 5d3b  FFSETS[axis][i];
+00005790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000057a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000057b0: 2020 2020 2074 7261 6e73 6c61 7465 2876       translate(v
+000057c0: 5f6d 756c 2876 6563 2f32 2c20 7369 7a65  _mul(vec/2, size
+000057d0: 2b5b 6172 642c 6172 642c 2d61 7264 5d2d  +[ard,ard,-ard]-
+000057e0: 5b30 2e30 312c 302e 3031 2c30 5d29 2920  [0.01,0.01,0])) 
+000057f0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00005800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005810: 2020 2020 2020 2020 2020 726f 7461 7465            rotate
+00005820: 286d 616a 726f 7473 5b61 7869 735d 2920  (majrots[axis]) 
+00005830: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
 00005840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005850: 2020 2020 6365 203d 205f 636f 726e 6572      ce = _corner
-00005860: 5f65 6467 6573 2865 6467 6573 2c20 5b78  _edges(edges, [x
-00005870: 612c 7961 2c7a 615d 293b 0a20 2020 2020  a,ya,za]);.     
-00005880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005890: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000058a0: 6620 2863 652e 7820 2b20 6365 2e79 203e  f (ce.x + ce.y >
-000058b0: 2031 2920 7b0a 2020 2020 2020 2020 2020   1) {.          
+00005850: 2020 2020 2020 2020 2020 2020 2020 6375                cu
+00005860: 6265 285b 6172 642c 2061 7264 2c20 7369  be([ard, ard, si
+00005870: 7a65 5b61 7869 735d 5d2c 2063 656e 7465  ze[axis]], cente
+00005880: 723d 7472 7565 293b 0a20 2020 2020 2020  r=true);.       
+00005890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000058a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000058b0: 207d 0a20 2020 2020 2020 2020 2020 2020   }.             
 000058c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000058d0: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-000058e0: 616e 736c 6174 6528 765f 6d75 6c28 5b78  anslate(v_mul([x
-000058f0: 612c 7961 2c7a 615d 2f32 2c20 7369 7a65  a,ya,za]/2, size
-00005900: 2b5b 6172 642d 302e 3031 2c61 7264 2d30  +[ard-0.01,ard-0
-00005910: 2e30 312c 2d61 7264 5d29 2920 7b0a 2020  .01,-ard])) {.  
+000058d0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000058e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000058f0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00005900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005910: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
 00005920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005940: 2020 2020 2020 2020 2020 6375 6265 285b            cube([
-00005950: 6172 642b 302e 3031 2c61 7264 2b30 2e30  ard+0.01,ard+0.0
-00005960: 312c 6172 645d 2c20 6365 6e74 6572 3d74  1,ard], center=t
-00005970: 7275 6529 3b0a 2020 2020 2020 2020 2020  rue);.          
+00005930: 2020 2020 2020 2f2f 2041 6464 206d 756c        // Add mul
+00005940: 7469 2d65 6467 6520 636f 726e 6572 732e  ti-edge corners.
+00005950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005960: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00005970: 2874 7269 6d63 6f72 6e65 7273 2920 7b0a  (trimcorners) {.
 00005980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005990: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-000059a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000059b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000059c0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+00005990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000059a0: 666f 7220 287a 613d 5b2d 312c 315d 2c20  for (za=[-1,1], 
+000059b0: 7961 3d5b 2d31 2c31 5d2c 2078 613d 5b2d  ya=[-1,1], xa=[-
+000059c0: 312c 315d 2920 7b0a 2020 2020 2020 2020  1,1]) {.        
 000059d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000059e0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-000059f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005a00: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00005a10: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-00005a20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005a30: 2020 2020 2020 2020 202f 2f20 5265 6d6f           // Remo
-00005a40: 7665 2072 6f75 6e64 696e 6773 2066 726f  ve roundings fro
-00005a50: 6d20 6f76 6572 6861 6e67 732e 0a20 2020  m overhangs..   
+000059e0: 2020 2020 2020 2020 2020 2020 6365 203d              ce =
+000059f0: 205f 636f 726e 6572 5f65 6467 6573 2865   _corner_edges(e
+00005a00: 6467 6573 2c20 5b78 612c 7961 2c7a 615d  dges, [xa,ya,za]
+00005a10: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00005a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005a30: 2020 2020 2020 2069 6620 2863 652e 7820         if (ce.x 
+00005a40: 2b20 6365 2e79 203e 2031 2920 7b0a 2020  + ce.y > 1) {.  
+00005a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00005a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005a70: 2020 2020 2066 6f72 2028 6920 3d20 5b30       for (i = [0
-00005a80: 3a33 5d2c 2061 7869 733d 5b30 3a31 5d29  :3], axis=[0:1])
-00005a90: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00005aa0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00005ab0: 6620 2865 6467 6573 5b61 7869 735d 5b69  f (edges[axis][i
-00005ac0: 5d3e 3029 207b 0a20 2020 2020 2020 2020  ]>0) {.         
+00005a70: 2020 2020 2020 7472 616e 736c 6174 6528        translate(
+00005a80: 765f 6d75 6c28 5b78 612c 7961 2c7a 615d  v_mul([xa,ya,za]
+00005a90: 2f32 2c20 7369 7a65 2b5b 6172 642d 302e  /2, size+[ard-0.
+00005aa0: 3031 2c61 7264 2d30 2e30 312c 2d61 7264  01,ard-0.01,-ard
+00005ab0: 5d29 2920 7b0a 2020 2020 2020 2020 2020  ])) {.          
+00005ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00005ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ae0: 2020 2020 2020 2076 6563 203d 2045 4447         vec = EDG
-00005af0: 455f 4f46 4653 4554 535b 6178 6973 5d5b  E_OFFSETS[axis][
-00005b00: 695d 3b0a 2020 2020 2020 2020 2020 2020  i];.            
+00005ae0: 2020 6375 6265 285b 6172 642b 302e 3031    cube([ard+0.01
+00005af0: 2c61 7264 2b30 2e30 312c 6172 645d 2c20  ,ard+0.01,ard], 
+00005b00: 6365 6e74 6572 3d74 7275 6529 3b0a 2020  center=true);.  
 00005b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b20: 2020 2020 7472 616e 736c 6174 6528 765f      translate(v_
-00005b30: 6d75 6c28 7665 632f 322c 2073 697a 652b  mul(vec/2, size+
-00005b40: 5b32 2a61 7264 2c32 2a61 7264 2c2d 322a  [2*ard,2*ard,-2*
-00005b50: 6172 645d 2929 207b 0a20 2020 2020 2020  ard])) {.       
+00005b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b30: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00005b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b50: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
 00005b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b70: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
-00005b80: 6174 6528 6d61 6a72 6f74 735b 6178 6973  ate(majrots[axis
-00005b90: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
+00005b70: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+00005b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b90: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
 00005ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005bb0: 2020 2020 2020 2020 2020 2020 2063 796c               cyl
-00005bc0: 286c 3d73 697a 655b 6178 6973 5d2b 322e  (l=size[axis]+2.
-00005bd0: 312a 6172 642c 2072 3d61 7264 293b 0a20  1*ard, r=ard);. 
-00005be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005c00: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00005c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005c20: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00005bb0: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
+00005bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bd0: 202f 2f20 5265 6d6f 7665 2072 6f75 6e64   // Remove round
+00005be0: 696e 6773 2066 726f 6d20 6f76 6572 6861  ings from overha
+00005bf0: 6e67 732e 0a20 2020 2020 2020 2020 2020  ngs..           
+00005c00: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00005c10: 2028 6920 3d20 5b30 3a33 5d2c 2061 7869   (i = [0:3], axi
+00005c20: 733d 5b30 3a31 5d29 207b 0a20 2020 2020  s=[0:1]) {.     
 00005c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005c40: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00005c50: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00005c40: 2020 2020 2020 2069 6620 2865 6467 6573         if (edges
+00005c50: 5b61 7869 735d 5b69 5d3e 3029 207b 0a20  [axis][i]>0) {. 
 00005c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005c70: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-00005c80: 2020 2020 207d 2065 6c73 6520 7b0a 2020       } else {.  
-00005c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ca0: 2020 6875 6c6c 2829 207b 0a20 2020 2020    hull() {.     
-00005cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005cc0: 2020 2063 6f72 6e65 725f 7368 6170 6528     corner_shape(
-00005cd0: 5b2d 312c 2d31 2c2d 315d 293b 0a20 2020  [-1,-1,-1]);.   
-00005ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005cf0: 2020 2020 2063 6f72 6e65 725f 7368 6170       corner_shap
-00005d00: 6528 5b20 312c 2d31 2c2d 315d 293b 0a20  e([ 1,-1,-1]);. 
-00005d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005d20: 2020 2020 2020 2063 6f72 6e65 725f 7368         corner_sh
-00005d30: 6170 6528 5b2d 312c 2031 2c2d 315d 293b  ape([-1, 1,-1]);
-00005d40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005d50: 2020 2020 2020 2020 2063 6f72 6e65 725f           corner_
-00005d60: 7368 6170 6528 5b20 312c 2031 2c2d 315d  shape([ 1, 1,-1]
-00005d70: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-00005d80: 2020 2020 2020 2020 2020 2063 6f72 6e65             corne
-00005d90: 725f 7368 6170 6528 5b2d 312c 2d31 2c20  r_shape([-1,-1, 
-00005da0: 315d 293b 0a20 2020 2020 2020 2020 2020  1]);.           
-00005db0: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
-00005dc0: 6e65 725f 7368 6170 6528 5b20 312c 2d31  ner_shape([ 1,-1
-00005dd0: 2c20 315d 293b 0a20 2020 2020 2020 2020  , 1]);.         
-00005de0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00005df0: 6f72 6e65 725f 7368 6170 6528 5b2d 312c  orner_shape([-1,
-00005e00: 2031 2c20 315d 293b 0a20 2020 2020 2020   1, 1]);.       
-00005e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e20: 2063 6f72 6e65 725f 7368 6170 6528 5b20   corner_shape([ 
-00005e30: 312c 2031 2c20 315d 293b 0a20 2020 2020  1, 1, 1]);.     
-00005e40: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-00005e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005e60: 207d 0a20 2020 2020 2020 2020 2020 207d   }.            }
-00005e70: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
-00005e80: 2020 2020 2020 2020 6375 6265 2873 697a          cube(siz
-00005e90: 653d 7369 7a65 2c20 6365 6e74 6572 3d74  e=size, center=t
-00005ea0: 7275 6529 3b0a 2020 2020 2020 2020 2020  rue);.          
-00005eb0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00005ec0: 6368 696c 6472 656e 2829 3b0a 2020 2020  children();.    
-00005ed0: 2020 2020 7d0a 2020 2020 7d0a 7d0a 0a0a      }.    }.}...
-00005ee0: 6675 6e63 7469 6f6e 2063 7562 6f69 6428  function cuboid(
-00005ef0: 0a20 2020 2073 697a 653d 5b31 2c31 2c31  .    size=[1,1,1
-00005f00: 5d2c 0a20 2020 2070 312c 2070 322c 0a20  ],.    p1, p2,. 
-00005f10: 2020 2063 6861 6d66 6572 2c0a 2020 2020     chamfer,.    
-00005f20: 726f 756e 6469 6e67 2c0a 2020 2020 6564  rounding,.    ed
-00005f30: 6765 733d 4544 4745 535f 414c 4c2c 0a20  ges=EDGES_ALL,. 
-00005f40: 2020 2065 7863 6570 745f 6564 6765 733d     except_edges=
-00005f50: 5b5d 2c0a 2020 2020 7472 696d 636f 726e  [],.    trimcorn
-00005f60: 6572 733d 7472 7565 2c0a 2020 2020 616e  ers=true,.    an
-00005f70: 6368 6f72 3d43 454e 5445 522c 0a20 2020  chor=CENTER,.   
-00005f80: 2073 7069 6e3d 302c 0a20 2020 206f 7269   spin=0,.    ori
-00005f90: 656e 743d 5550 0a29 203d 206e 6f5f 6675  ent=UP.) = no_fu
-00005fa0: 6e63 7469 6f6e 2822 6375 626f 6964 2229  nction("cuboid")
-00005fb0: 3b0a 0a0a 0a2f 2f20 4675 6e63 7469 6f6e  ;....// Function
-00005fc0: 264d 6f64 756c 653a 2070 7269 736d 6f69  &Module: prismoi
-00005fd0: 6428 290a 2f2f 0a2f 2f20 5573 6167 653a  d().//.// Usage:
-00005fe0: 2054 7970 6963 616c 2050 7269 736d 6f69   Typical Prismoi
-00005ff0: 6473 0a2f 2f20 2020 7072 6973 6d6f 6964  ds.//   prismoid
-00006000: 2873 697a 6531 2c20 7369 7a65 322c 2068  (size1, size2, h
-00006010: 7c6c 2c20 5b73 6869 6674 5d2c 202e 2e2e  |l, [shift], ...
-00006020: 2920 5b41 5454 4143 484d 454e 5453 5d3b  ) [ATTACHMENTS];
-00006030: 0a2f 2f20 5573 6167 653a 2043 6861 6d66  .// Usage: Chamf
-00006040: 6572 6564 2050 7269 736d 6f69 6473 0a2f  ered Prismoids./
-00006050: 2f20 2020 7072 6973 6d6f 6964 2873 697a  /   prismoid(siz
-00006060: 6531 2c20 7369 7a65 322c 2068 7c6c 2c20  e1, size2, h|l, 
-00006070: 5b63 6861 6d66 6572 3d5d 2c20 2e2e 2e29  [chamfer=], ...)
-00006080: 205b 4154 5441 4348 4d45 4e54 535d 3b0a   [ATTACHMENTS];.
-00006090: 2f2f 2020 2070 7269 736d 6f69 6428 7369  //   prismoid(si
-000060a0: 7a65 312c 2073 697a 6532 2c20 687c 6c2c  ze1, size2, h|l,
-000060b0: 205b 6368 616d 6665 7231 3d5d 2c20 5b63   [chamfer1=], [c
-000060c0: 6861 6d66 6572 323d 5d2c 202e 2e2e 2920  hamfer2=], ...) 
-000060d0: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
-000060e0: 2f20 5573 6167 653a 2052 6f75 6e64 6564  / Usage: Rounded
-000060f0: 2050 7269 736d 6f69 6473 0a2f 2f20 2020   Prismoids.//   
-00006100: 7072 6973 6d6f 6964 2873 697a 6531 2c20  prismoid(size1, 
-00006110: 7369 7a65 322c 2068 7c6c 2c20 5b72 6f75  size2, h|l, [rou
-00006120: 6e64 696e 673d 5d2c 202e 2e2e 2920 5b41  nding=], ...) [A
-00006130: 5454 4143 484d 454e 5453 5d3b 0a2f 2f20  TTACHMENTS];.// 
-00006140: 2020 7072 6973 6d6f 6964 2873 697a 6531    prismoid(size1
-00006150: 2c20 7369 7a65 322c 2068 7c6c 2c20 5b72  , size2, h|l, [r
-00006160: 6f75 6e64 696e 6731 3d5d 2c20 5b72 6f75  ounding1=], [rou
-00006170: 6e64 696e 6732 3d5d 2c20 2e2e 2e29 205b  nding2=], ...) [
-00006180: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-00006190: 2055 7361 6765 3a20 4173 2046 756e 6374   Usage: As Funct
-000061a0: 696f 6e0a 2f2f 2020 2076 6e66 203d 2070  ion.//   vnf = p
-000061b0: 7269 736d 6f69 6428 7369 7a65 312c 2073  rismoid(size1, s
-000061c0: 697a 6532 2c20 687c 6c2c 205b 7368 6966  ize2, h|l, [shif
-000061d0: 745d 2c20 5b72 6f75 6e64 696e 675d 2c20  t], [rounding], 
-000061e0: 5b63 6861 6d66 6572 5d29 3b0a 2f2f 2020  [chamfer]);.//  
-000061f0: 2076 6e66 203d 2070 7269 736d 6f69 6428   vnf = prismoid(
-00006200: 7369 7a65 312c 2073 697a 6532 2c20 687c  size1, size2, h|
-00006210: 6c2c 205b 7368 6966 745d 2c20 5b72 6f75  l, [shift], [rou
-00006220: 6e64 696e 6731 5d2c 205b 726f 756e 6469  nding1], [roundi
-00006230: 6e67 325d 2c20 5b63 6861 6d66 6572 315d  ng2], [chamfer1]
-00006240: 2c20 5b63 6861 6d66 6572 325d 293b 0a2f  , [chamfer2]);./
-00006250: 2f0a 2f2f 2044 6573 6372 6970 7469 6f6e  /.// Description
-00006260: 3a0a 2f2f 2020 2043 7265 6174 6573 2061  :.//   Creates a
-00006270: 2072 6563 7461 6e67 756c 6172 2070 7269   rectangular pri
-00006280: 736d 6f69 6420 7368 6170 6520 7769 7468  smoid shape with
-00006290: 206f 7074 696f 6e61 6c20 726f 756e 646f   optional roundo
-000062a0: 7665 7273 2061 6e64 2063 6861 6d66 6572  vers and chamfer
-000062b0: 696e 672e 0a2f 2f20 2020 596f 7520 6361  ing..//   You ca
-000062c0: 6e20 6f6e 6c79 2072 6f75 6e64 206f 7220  n only round or 
-000062d0: 6368 616d 6665 7220 7468 6520 7665 7274  chamfer the vert
-000062e0: 6963 616c 2869 7368 2920 6564 6765 732e  ical(ish) edges.
-000062f0: 2020 466f 7220 7468 6f73 6520 6564 6765    For those edge
-00006300: 732c 2079 6f75 2063 616e 0a2f 2f20 2020  s, you can.//   
-00006310: 7370 6563 6966 7920 726f 756e 6469 6e67  specify rounding
-00006320: 2061 6e64 2f6f 7220 6368 616d 6665 7272   and/or chamferr
-00006330: 696e 6720 7065 722d 6564 6765 2c20 616e  ing per-edge, an
-00006340: 6420 666f 7220 746f 7020 616e 6420 626f  d for top and bo
-00006350: 7474 6f6d 2073 6570 6172 6174 656c 792e  ttom separately.
-00006360: 0a2f 2f20 2020 4966 2079 6f75 2077 616e  .//   If you wan
-00006370: 7420 746f 2072 6f75 6e64 2074 6865 2062  t to round the b
-00006380: 6f74 746f 6d20 6f72 2074 6f70 2065 6467  ottom or top edg
-00006390: 6573 2073 6565 207b 7b72 6f75 6e64 6564  es see {{rounded
-000063a0: 5f70 7269 736d 2829 7d7d 2e20 200a 2f2f  _prism()}}.  .//
-000063b0: 0a2f 2f20 4172 6775 6d65 6e74 733a 0a2f  .// Arguments:./
-000063c0: 2f20 2020 7369 7a65 3120 3d20 5b77 6964  /   size1 = [wid
-000063d0: 7468 2c20 6c65 6e67 7468 5d20 6f66 2074  th, length] of t
-000063e0: 6865 2062 6f74 746f 6d20 656e 6420 6f66  he bottom end of
-000063f0: 2074 6865 2070 7269 736d 2e0a 2f2f 2020   the prism..//  
-00006400: 2073 697a 6532 203d 205b 7769 6474 682c   size2 = [width,
-00006410: 206c 656e 6774 685d 206f 6620 7468 6520   length] of the 
-00006420: 746f 7020 656e 6420 6f66 2074 6865 2070  top end of the p
-00006430: 7269 736d 2e0a 2f2f 2020 2068 2f6c 203d  rism..//   h/l =
-00006440: 2048 6569 6768 7420 6f66 2074 6865 2070   Height of the p
-00006450: 7269 736d 2e0a 2f2f 2020 2073 6869 6674  rism..//   shift
-00006460: 203d 205b 582c 595d 2061 6d6f 756e 7420   = [X,Y] amount 
-00006470: 746f 2073 6869 6674 2074 6865 2063 656e  to shift the cen
-00006480: 7465 7220 6f66 2074 6865 2074 6f70 2065  ter of the top e
-00006490: 6e64 2077 6974 6820 7265 7370 6563 7420  nd with respect 
-000064a0: 746f 2074 6865 2063 656e 7465 7220 6f66  to the center of
-000064b0: 2074 6865 2062 6f74 746f 6d20 656e 642e   the bottom end.
-000064c0: 0a2f 2f20 2020 2d2d 2d0a 2f2f 2020 2072  .//   ---.//   r
-000064d0: 6f75 6e64 696e 6720 3d20 5468 6520 726f  ounding = The ro
-000064e0: 756e 646f 7665 7220 7261 6469 7573 2066  undover radius f
-000064f0: 6f72 2074 6865 2076 6572 7469 6361 6c2d  or the vertical-
-00006500: 6973 6820 6564 6765 7320 6f66 2074 6865  ish edges of the
-00006510: 2070 7269 736d 6f69 642e 2020 4966 2067   prismoid.  If g
-00006520: 6976 656e 2061 7320 6120 6c69 7374 206f  iven as a list o
-00006530: 6620 666f 7572 206e 756d 6265 7273 2c20  f four numbers, 
-00006540: 6769 7665 7320 696e 6469 7669 6475 616c  gives individual
-00006550: 2072 6164 6969 2066 6f72 2065 6163 6820   radii for each 
-00006560: 636f 726e 6572 2c20 696e 2074 6865 206f  corner, in the o
-00006570: 7264 6572 205b 582b 592b 2c58 2d59 2b2c  rder [X+Y+,X-Y+,
-00006580: 582d 592d 2c58 2b59 2d5d 2e20 4465 6661  X-Y-,X+Y-]. Defa
-00006590: 756c 743a 2030 2028 6e6f 2072 6f75 6e64  ult: 0 (no round
-000065a0: 696e 6729 0a2f 2f20 2020 726f 756e 6469  ing).//   roundi
-000065b0: 6e67 3120 3d20 5468 6520 726f 756e 646f  ng1 = The roundo
-000065c0: 7665 7220 7261 6469 7573 2066 6f72 2074  ver radius for t
-000065d0: 6865 2062 6f74 746f 6d20 6f66 2074 6865  he bottom of the
-000065e0: 2076 6572 7469 6361 6c2d 6973 6820 6564   vertical-ish ed
-000065f0: 6765 7320 6f66 2074 6865 2070 7269 736d  ges of the prism
-00006600: 6f69 642e 2020 4966 2067 6976 656e 2061  oid.  If given a
-00006610: 7320 6120 6c69 7374 206f 6620 666f 7572  s a list of four
-00006620: 206e 756d 6265 7273 2c20 6769 7665 7320   numbers, gives 
-00006630: 696e 6469 7669 6475 616c 2072 6164 6969  individual radii
-00006640: 2066 6f72 2065 6163 6820 636f 726e 6572   for each corner
-00006650: 2c20 696e 2074 6865 206f 7264 6572 205b  , in the order [
-00006660: 582b 592b 2c58 2d59 2b2c 582d 592d 2c58  X+Y+,X-Y+,X-Y-,X
-00006670: 2b59 2d5d 2e0a 2f2f 2020 2072 6f75 6e64  +Y-]..//   round
-00006680: 696e 6732 203d 2054 6865 2072 6f75 6e64  ing2 = The round
-00006690: 6f76 6572 2072 6164 6975 7320 666f 7220  over radius for 
-000066a0: 7468 6520 746f 7020 6f66 2074 6865 2076  the top of the v
-000066b0: 6572 7469 6361 6c2d 6973 6820 6564 6765  ertical-ish edge
-000066c0: 7320 6f66 2074 6865 2070 7269 736d 6f69  s of the prismoi
-000066d0: 642e 2020 4966 2067 6976 656e 2061 7320  d.  If given as 
-000066e0: 6120 6c69 7374 206f 6620 666f 7572 206e  a list of four n
-000066f0: 756d 6265 7273 2c20 6769 7665 7320 696e  umbers, gives in
-00006700: 6469 7669 6475 616c 2072 6164 6969 2066  dividual radii f
-00006710: 6f72 2065 6163 6820 636f 726e 6572 2c20  or each corner, 
-00006720: 696e 2074 6865 206f 7264 6572 205b 582b  in the order [X+
-00006730: 592b 2c58 2d59 2b2c 582d 592d 2c58 2b59  Y+,X-Y+,X-Y-,X+Y
-00006740: 2d5d 2e0a 2f2f 2020 2063 6861 6d66 6572  -]..//   chamfer
-00006750: 203d 2054 6865 2063 6861 6d66 6572 2073   = The chamfer s
-00006760: 697a 6520 666f 7220 7468 6520 7665 7274  ize for the vert
-00006770: 6963 616c 2d69 7368 2065 6467 6573 206f  ical-ish edges o
-00006780: 6620 7468 6520 7072 6973 6d6f 6964 2e20  f the prismoid. 
-00006790: 2049 6620 6769 7665 6e20 6173 2061 206c   If given as a l
-000067a0: 6973 7420 6f66 2066 6f75 7220 6e75 6d62  ist of four numb
-000067b0: 6572 732c 2067 6976 6573 2069 6e64 6976  ers, gives indiv
-000067c0: 6964 7561 6c20 6368 616d 6665 7273 2066  idual chamfers f
-000067d0: 6f72 2065 6163 6820 636f 726e 6572 2c20  or each corner, 
-000067e0: 696e 2074 6865 206f 7264 6572 205b 582b  in the order [X+
-000067f0: 592b 2c58 2d59 2b2c 582d 592d 2c58 2b59  Y+,X-Y+,X-Y-,X+Y
-00006800: 2d5d 2e20 2044 6566 6175 6c74 3a20 3020  -].  Default: 0 
-00006810: 286e 6f20 6368 616d 6665 7229 0a2f 2f20  (no chamfer).// 
-00006820: 2020 6368 616d 6665 7231 203d 2054 6865    chamfer1 = The
-00006830: 2063 6861 6d66 6572 2073 697a 6520 666f   chamfer size fo
-00006840: 7220 7468 6520 626f 7474 6f6d 206f 6620  r the bottom of 
-00006850: 7468 6520 7665 7274 6963 616c 2d69 7368  the vertical-ish
-00006860: 2065 6467 6573 206f 6620 7468 6520 7072   edges of the pr
-00006870: 6973 6d6f 6964 2e20 2049 6620 6769 7665  ismoid.  If give
-00006880: 6e20 6173 2061 206c 6973 7420 6f66 2066  n as a list of f
-00006890: 6f75 7220 6e75 6d62 6572 732c 2067 6976  our numbers, giv
-000068a0: 6573 2069 6e64 6976 6964 7561 6c20 6368  es individual ch
-000068b0: 616d 6665 7273 2066 6f72 2065 6163 6820  amfers for each 
-000068c0: 636f 726e 6572 2c20 696e 2074 6865 206f  corner, in the o
-000068d0: 7264 6572 205b 582b 592b 2c58 2d59 2b2c  rder [X+Y+,X-Y+,
-000068e0: 582d 592d 2c58 2b59 2d5d 2e0a 2f2f 2020  X-Y-,X+Y-]..//  
-000068f0: 2063 6861 6d66 6572 3220 3d20 5468 6520   chamfer2 = The 
-00006900: 6368 616d 6665 7220 7369 7a65 2066 6f72  chamfer size for
-00006910: 2074 6865 2074 6f70 206f 6620 7468 6520   the top of the 
-00006920: 7665 7274 6963 616c 2d69 7368 2065 6467  vertical-ish edg
-00006930: 6573 206f 6620 7468 6520 7072 6973 6d6f  es of the prismo
-00006940: 6964 2e20 2049 6620 6769 7665 6e20 6173  id.  If given as
-00006950: 2061 206c 6973 7420 6f66 2066 6f75 7220   a list of four 
-00006960: 6e75 6d62 6572 732c 2067 6976 6573 2069  numbers, gives i
-00006970: 6e64 6976 6964 7561 6c20 6368 616d 6665  ndividual chamfe
-00006980: 7273 2066 6f72 2065 6163 6820 636f 726e  rs for each corn
-00006990: 6572 2c20 696e 2074 6865 206f 7264 6572  er, in the order
-000069a0: 205b 582b 592b 2c58 2d59 2b2c 582d 592d   [X+Y+,X-Y+,X-Y-
-000069b0: 2c58 2b59 2d5d 2e0a 2f2f 2020 2061 6e63  ,X+Y-]..//   anc
-000069c0: 686f 7220 3d20 5472 616e 736c 6174 6520  hor = Translate 
-000069d0: 736f 2061 6e63 686f 7220 706f 696e 7420  so anchor point 
-000069e0: 6973 2061 7420 6f72 6967 696e 2028 302c  is at origin (0,
-000069f0: 302c 3029 2e20 2053 6565 205b 616e 6368  0,0).  See [anch
-00006a00: 6f72 5d28 6174 7461 6368 6d65 6e74 732e  or](attachments.
-00006a10: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-00006a20: 616e 6368 6f72 292e 2020 4465 6661 756c  anchor).  Defaul
-00006a30: 743a 2060 4345 4e54 4552 600a 2f2f 2020  t: `CENTER`.//  
-00006a40: 2073 7069 6e20 3d20 526f 7461 7465 2074   spin = Rotate t
-00006a50: 6869 7320 6d61 6e79 2064 6567 7265 6573  his many degrees
-00006a60: 2061 726f 756e 6420 7468 6520 5a20 6178   around the Z ax
-00006a70: 6973 2061 6674 6572 2061 6e63 686f 722e  is after anchor.
-00006a80: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
-00006a90: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
-00006aa0: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
-00006ab0: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
-00006ac0: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
-00006ad0: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
-00006ae0: 2074 6f77 6172 6473 2c20 6166 7465 7220   towards, after 
-00006af0: 7370 696e 2e20 2053 6565 205b 6f72 6965  spin.  See [orie
-00006b00: 6e74 5d28 6174 7461 6368 6d65 6e74 732e  nt](attachments.
-00006b10: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-00006b20: 6f72 6965 6e74 292e 2020 4465 6661 756c  orient).  Defaul
-00006b30: 743a 2060 5550 600a 2f2f 0a2f 2f20 5365  t: `UP`.//.// Se
-00006b40: 6520 416c 736f 3a20 726f 756e 6465 645f  e Also: rounded_
-00006b50: 7072 6973 6d28 290a 2f2f 0a2f 2f20 4578  prism().//.// Ex
-00006b60: 616d 706c 653a 2052 6563 7461 6e67 756c  ample: Rectangul
-00006b70: 6172 2050 7972 616d 6964 0a2f 2f20 2020  ar Pyramid.//   
-00006b80: 7072 6973 6d6f 6964 285b 3430 2c34 305d  prismoid([40,40]
-00006b90: 2c20 5b30 2c30 5d2c 2068 3d32 3029 3b0a  , [0,0], h=20);.
-00006ba0: 2f2f 2045 7861 6d70 6c65 3a20 5072 6973  // Example: Pris
-00006bb0: 6d0a 2f2f 2020 2070 7269 736d 6f69 6428  m.//   prismoid(
-00006bc0: 7369 7a65 313d 5b34 302c 3430 5d2c 2073  size1=[40,40], s
-00006bd0: 697a 6532 3d5b 302c 3430 5d2c 2068 3d32  ize2=[0,40], h=2
-00006be0: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
-00006bf0: 5472 756e 6361 7465 6420 5079 7261 6d69  Truncated Pyrami
-00006c00: 640a 2f2f 2020 2070 7269 736d 6f69 6428  d.//   prismoid(
-00006c10: 7369 7a65 313d 5b33 352c 3530 5d2c 2073  size1=[35,50], s
-00006c20: 697a 6532 3d5b 3230 2c33 305d 2c20 683d  ize2=[20,30], h=
-00006c30: 3230 293b 0a2f 2f20 4578 616d 706c 653a  20);.// Example:
-00006c40: 2057 6564 6765 0a2f 2f20 2020 7072 6973   Wedge.//   pris
-00006c50: 6d6f 6964 2873 697a 6531 3d5b 3630 2c33  moid(size1=[60,3
-00006c60: 355d 2c20 7369 7a65 323d 5b33 302c 305d  5], size2=[30,0]
-00006c70: 2c20 683d 3330 293b 0a2f 2f20 4578 616d  , h=30);.// Exam
-00006c80: 706c 653a 2054 7275 6e63 6174 6564 2054  ple: Truncated T
-00006c90: 6574 7261 6865 6472 6f6e 0a2f 2f20 2020  etrahedron.//   
-00006ca0: 7072 6973 6d6f 6964 2873 697a 6531 3d5b  prismoid(size1=[
-00006cb0: 3130 2c34 305d 2c20 7369 7a65 323d 5b34  10,40], size2=[4
-00006cc0: 302c 3130 5d2c 2068 3d34 3029 3b0a 2f2f  0,10], h=40);.//
-00006cd0: 2045 7861 6d70 6c65 3a20 496e 7665 7274   Example: Invert
-00006ce0: 6564 2054 7275 6e63 6174 6564 2050 7972  ed Truncated Pyr
-00006cf0: 616d 6964 0a2f 2f20 2020 7072 6973 6d6f  amid.//   prismo
-00006d00: 6964 2873 697a 6531 3d5b 3135 2c35 5d2c  id(size1=[15,5],
-00006d10: 2073 697a 6532 3d5b 3330 2c32 305d 2c20   size2=[30,20], 
-00006d20: 683d 3230 293b 0a2f 2f20 4578 616d 706c  h=20);.// Exampl
-00006d30: 653a 2052 6967 6874 2050 7269 736d 0a2f  e: Right Prism./
-00006d40: 2f20 2020 7072 6973 6d6f 6964 2873 697a  /   prismoid(siz
-00006d50: 6531 3d5b 3330 2c36 305d 2c20 7369 7a65  e1=[30,60], size
-00006d60: 323d 5b30 2c36 305d 2c20 7368 6966 743d  2=[0,60], shift=
-00006d70: 5b2d 3135 2c30 5d2c 2068 3d33 3029 3b0a  [-15,0], h=30);.
-00006d80: 2f2f 2045 7861 6d70 6c65 2846 6c61 7453  // Example(FlatS
-00006d90: 7069 6e2c 5650 443d 3136 302c 5650 543d  pin,VPD=160,VPT=
-00006da0: 5b30 2c30 2c31 305d 293a 2053 6869 6674  [0,0,10]): Shift
-00006db0: 696e 672f 536b 6577 696e 670a 2f2f 2020  ing/Skewing.//  
-00006dc0: 2070 7269 736d 6f69 6428 7369 7a65 313d   prismoid(size1=
-00006dd0: 5b35 302c 3330 5d2c 2073 697a 6532 3d5b  [50,30], size2=[
-00006de0: 3230 2c32 305d 2c20 683d 3230 2c20 7368  20,20], h=20, sh
-00006df0: 6966 743d 5b31 352c 355d 293b 0a2f 2f20  ift=[15,5]);.// 
-00006e00: 4578 616d 706c 653a 2052 6f75 6e64 696e  Example: Roundin
-00006e10: 670a 2f2f 2020 2070 7269 736d 6f69 6428  g.//   prismoid(
-00006e20: 3130 302c 2038 302c 2072 6f75 6e64 696e  100, 80, roundin
-00006e30: 673d 3130 2c20 683d 3330 293b 0a2f 2f20  g=10, h=30);.// 
-00006e40: 4578 616d 706c 653a 204f 7574 6572 2043  Example: Outer C
-00006e50: 6861 6d66 6572 204f 6e6c 790a 2f2f 2020  hamfer Only.//  
-00006e60: 2070 7269 736d 6f69 6428 3130 302c 2038   prismoid(100, 8
-00006e70: 302c 2063 6861 6d66 6572 3d35 2c20 683d  0, chamfer=5, h=
-00006e80: 3330 293b 0a2f 2f20 4578 616d 706c 653a  30);.// Example:
-00006e90: 2047 7261 6469 616e 7420 526f 756e 6469   Gradiant Roundi
-00006ea0: 6e67 0a2f 2f20 2020 7072 6973 6d6f 6964  ng.//   prismoid
-00006eb0: 2831 3030 2c20 3830 2c20 726f 756e 6469  (100, 80, roundi
-00006ec0: 6e67 313d 3130 2c20 726f 756e 6469 6e67  ng1=10, rounding
-00006ed0: 323d 302c 2068 3d33 3029 3b0a 2f2f 2045  2=0, h=30);.// E
-00006ee0: 7861 6d70 6c65 3a20 5065 7220 436f 726e  xample: Per Corn
-00006ef0: 6572 2052 6f75 6e64 696e 670a 2f2f 2020  er Rounding.//  
-00006f00: 2070 7269 736d 6f69 6428 3130 302c 2038   prismoid(100, 8
-00006f10: 302c 2072 6f75 6e64 696e 673d 5b30 2c35  0, rounding=[0,5
-00006f20: 2c31 302c 3135 5d2c 2068 3d33 3029 3b0a  ,10,15], h=30);.
-00006f30: 2f2f 2045 7861 6d70 6c65 3a20 5065 7220  // Example: Per 
-00006f40: 436f 726e 6572 2043 6861 6d66 6572 0a2f  Corner Chamfer./
-00006f50: 2f20 2020 7072 6973 6d6f 6964 2831 3030  /   prismoid(100
-00006f60: 2c20 3830 2c20 6368 616d 6665 723d 5b30  , 80, chamfer=[0
-00006f70: 2c35 2c31 302c 3135 5d2c 2068 3d33 3029  ,5,10,15], h=30)
-00006f80: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4d69  ;.// Example: Mi
-00006f90: 7869 6e67 2043 6861 6d66 6572 2061 6e64  xing Chamfer and
-00006fa0: 2052 6f75 6e64 696e 670a 2f2f 2020 2070   Rounding.//   p
-00006fb0: 7269 736d 6f69 6428 0a2f 2f20 2020 2020  rismoid(.//     
-00006fc0: 2020 3130 302c 2038 302c 2068 3d33 302c    100, 80, h=30,
-00006fd0: 0a2f 2f20 2020 2020 2020 6368 616d 6665  .//       chamfe
-00006fe0: 723d 5b30 2c35 2c30 2c31 305d 2c0a 2f2f  r=[0,5,0,10],.//
-00006ff0: 2020 2020 2020 2072 6f75 6e64 696e 673d         rounding=
-00007000: 5b35 2c30 2c31 302c 305d 0a2f 2f20 2020  [5,0,10,0].//   
-00007010: 293b 0a2f 2f20 4578 616d 706c 653a 2052  );.// Example: R
-00007020: 6561 6c6c 7920 4d69 7869 6e67 2049 7420  eally Mixing It 
-00007030: 5570 0a2f 2f20 2020 7072 6973 6d6f 6964  Up.//   prismoid
-00007040: 280a 2f2f 2020 2020 2020 2073 697a 6531  (.//       size1
-00007050: 3d5b 3130 302c 3830 5d2c 2073 697a 6532  =[100,80], size2
-00007060: 3d5b 3830 2c36 305d 2c20 683d 3230 2c0a  =[80,60], h=20,.
-00007070: 2f2f 2020 2020 2020 2063 6861 6d66 6572  //       chamfer
-00007080: 313d 5b30 2c35 2c30 2c31 305d 2c20 6368  1=[0,5,0,10], ch
-00007090: 616d 6665 7232 3d5b 352c 302c 3130 2c30  amfer2=[5,0,10,0
-000070a0: 5d2c 0a2f 2f20 2020 2020 2020 726f 756e  ],.//       roun
-000070b0: 6469 6e67 313d 5b35 2c30 2c31 302c 305d  ding1=[5,0,10,0]
-000070c0: 2c20 726f 756e 6469 6e67 323d 5b30 2c35  , rounding2=[0,5
-000070d0: 2c30 2c31 305d 0a2f 2f20 2020 293b 0a2f  ,0,10].//   );./
-000070e0: 2f20 4578 616d 706c 6528 5370 696e 2c56  / Example(Spin,V
-000070f0: 5044 3d31 3630 2c56 5054 3d5b 302c 302c  PD=160,VPT=[0,0,
-00007100: 3130 5d29 3a20 5374 616e 6461 7264 2043  10]): Standard C
-00007110: 6f6e 6e65 6374 6f72 730a 2f2f 2020 2070  onnectors.//   p
-00007120: 7269 736d 6f69 6428 7369 7a65 313d 5b35  rismoid(size1=[5
-00007130: 302c 3330 5d2c 2073 697a 6532 3d5b 3230  0,30], size2=[20
-00007140: 2c32 305d 2c20 683d 3230 2c20 7368 6966  ,20], h=20, shif
-00007150: 743d 5b31 352c 355d 290a 2f2f 2020 2020  t=[15,5]).//    
-00007160: 2020 2073 686f 775f 616e 6368 6f72 7328     show_anchors(
-00007170: 293b 0a6d 6f64 756c 6520 7072 6973 6d6f  );.module prismo
-00007180: 6964 280a 2020 2020 7369 7a65 312c 2073  id(.    size1, s
-00007190: 697a 6532 2c20 682c 2073 6869 6674 3d5b  ize2, h, shift=[
-000071a0: 302c 305d 2c0a 2020 2020 726f 756e 6469  0,0],.    roundi
-000071b0: 6e67 3d30 2c20 726f 756e 6469 6e67 312c  ng=0, rounding1,
-000071c0: 2072 6f75 6e64 696e 6732 2c0a 2020 2020   rounding2,.    
-000071d0: 6368 616d 6665 723d 302c 2063 6861 6d66  chamfer=0, chamf
-000071e0: 6572 312c 2063 6861 6d66 6572 322c 0a20  er1, chamfer2,. 
-000071f0: 2020 206c 2c20 6365 6e74 6572 2c0a 2020     l, center,.  
-00007200: 2020 616e 6368 6f72 2c20 7370 696e 3d30    anchor, spin=0
-00007210: 2c20 6f72 6965 6e74 3d55 500a 2920 7b0a  , orient=UP.) {.
-00007220: 2020 2020 6368 6563 6b73 203d 0a20 2020      checks =.   
-00007230: 2020 2020 2061 7373 6572 7428 6973 5f6e       assert(is_n
-00007240: 756d 2873 697a 6531 2920 7c7c 2069 735f  um(size1) || is_
-00007250: 7665 6374 6f72 2873 697a 6531 2c32 2929  vector(size1,2))
-00007260: 0a20 2020 2020 2020 2061 7373 6572 7428  .        assert(
-00007270: 6973 5f6e 756d 2873 697a 6532 2920 7c7c  is_num(size2) ||
-00007280: 2069 735f 7665 6374 6f72 2873 697a 6532   is_vector(size2
-00007290: 2c32 2929 0a20 2020 2020 2020 2061 7373  ,2)).        ass
-000072a0: 6572 7428 6973 5f6e 756d 2868 2920 7c7c  ert(is_num(h) ||
-000072b0: 2069 735f 6e75 6d28 6c29 290a 2020 2020   is_num(l)).    
-000072c0: 2020 2020 6173 7365 7274 2869 735f 7665      assert(is_ve
-000072d0: 6374 6f72 2873 6869 6674 2c32 2929 0a20  ctor(shift,2)). 
-000072e0: 2020 2020 2020 2061 7373 6572 7428 6973         assert(is
-000072f0: 5f6e 756d 2872 6f75 6e64 696e 6729 207c  _num(rounding) |
-00007300: 7c20 6973 5f76 6563 746f 7228 726f 756e  | is_vector(roun
-00007310: 6469 6e67 2c34 292c 2022 4261 6420 726f  ding,4), "Bad ro
-00007320: 756e 6469 6e67 2061 7267 756d 656e 742e  unding argument.
-00007330: 2229 0a20 2020 2020 2020 2061 7373 6572  ").        asser
-00007340: 7428 6973 5f75 6e64 6566 2872 6f75 6e64  t(is_undef(round
-00007350: 696e 6731 2920 7c7c 2069 735f 6e75 6d28  ing1) || is_num(
-00007360: 726f 756e 6469 6e67 3129 207c 7c20 6973  rounding1) || is
-00007370: 5f76 6563 746f 7228 726f 756e 6469 6e67  _vector(rounding
-00007380: 312c 3429 2c20 2242 6164 2072 6f75 6e64  1,4), "Bad round
-00007390: 696e 6731 2061 7267 756d 656e 742e 2229  ing1 argument.")
-000073a0: 0a20 2020 2020 2020 2061 7373 6572 7428  .        assert(
-000073b0: 6973 5f75 6e64 6566 2872 6f75 6e64 696e  is_undef(roundin
-000073c0: 6732 2920 7c7c 2069 735f 6e75 6d28 726f  g2) || is_num(ro
-000073d0: 756e 6469 6e67 3229 207c 7c20 6973 5f76  unding2) || is_v
-000073e0: 6563 746f 7228 726f 756e 6469 6e67 322c  ector(rounding2,
-000073f0: 3429 2c20 2242 6164 2072 6f75 6e64 696e  4), "Bad roundin
-00007400: 6732 2061 7267 756d 656e 742e 2229 0a20  g2 argument."). 
-00007410: 2020 2020 2020 2061 7373 6572 7428 6973         assert(is
-00007420: 5f6e 756d 2863 6861 6d66 6572 2920 7c7c  _num(chamfer) ||
-00007430: 2069 735f 7665 6374 6f72 2863 6861 6d66   is_vector(chamf
-00007440: 6572 2c34 292c 2022 4261 6420 6368 616d  er,4), "Bad cham
-00007450: 6665 7220 6172 6775 6d65 6e74 2e22 290a  fer argument.").
-00007460: 2020 2020 2020 2020 6173 7365 7274 2869          assert(i
-00007470: 735f 756e 6465 6628 6368 616d 6665 7231  s_undef(chamfer1
-00007480: 2920 7c7c 2069 735f 6e75 6d28 6368 616d  ) || is_num(cham
-00007490: 6665 7231 2920 7c7c 2069 735f 7665 6374  fer1) || is_vect
-000074a0: 6f72 2863 6861 6d66 6572 312c 3429 2c20  or(chamfer1,4), 
-000074b0: 2242 6164 2063 6861 6d66 6572 3120 6172  "Bad chamfer1 ar
-000074c0: 6775 6d65 6e74 2e22 290a 2020 2020 2020  gument.").      
-000074d0: 2020 6173 7365 7274 2869 735f 756e 6465    assert(is_unde
-000074e0: 6628 6368 616d 6665 7232 2920 7c7c 2069  f(chamfer2) || i
-000074f0: 735f 6e75 6d28 6368 616d 6665 7232 2920  s_num(chamfer2) 
-00007500: 7c7c 2069 735f 7665 6374 6f72 2863 6861  || is_vector(cha
-00007510: 6d66 6572 322c 3429 2c20 2242 6164 2063  mfer2,4), "Bad c
-00007520: 6861 6d66 6572 3220 6172 6775 6d65 6e74  hamfer2 argument
-00007530: 2e22 293b 0a20 2020 2065 7073 203d 2070  .");.    eps = p
-00007540: 6f77 2832 2c2d 3134 293b 0a20 2020 2073  ow(2,-14);.    s
-00007550: 697a 6531 203d 2069 735f 6e75 6d28 7369  ize1 = is_num(si
-00007560: 7a65 3129 3f20 5b73 697a 6531 2c73 697a  ze1)? [size1,siz
-00007570: 6531 5d20 3a20 7369 7a65 313b 0a20 2020  e1] : size1;.   
-00007580: 2073 697a 6532 203d 2069 735f 6e75 6d28   size2 = is_num(
-00007590: 7369 7a65 3229 3f20 5b73 697a 6532 2c73  size2)? [size2,s
-000075a0: 697a 6532 5d20 3a20 7369 7a65 323b 0a20  ize2] : size2;. 
-000075b0: 2020 2063 6865 636b 7332 203d 200a 2020     checks2 = .  
-000075c0: 2020 2020 2020 6173 7365 7274 2861 6c6c        assert(all
-000075d0: 5f6e 6f6e 6e65 6761 7469 7665 2873 697a  _nonnegative(siz
-000075e0: 6531 2929 0a20 2020 2020 2020 2061 7373  e1)).        ass
-000075f0: 6572 7428 616c 6c5f 6e6f 6e6e 6567 6174  ert(all_nonnegat
-00007600: 6976 6528 7369 7a65 3229 290a 2020 2020  ive(size2)).    
-00007610: 2020 2020 6173 7365 7274 2873 697a 6531      assert(size1
-00007620: 2e78 202b 2073 697a 6532 2e78 203e 2030  .x + size2.x > 0
-00007630: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
-00007640: 2873 697a 6531 2e79 202b 2073 697a 6532  (size1.y + size2
-00007650: 2e79 203e 2030 293b 0a20 2020 2073 3120  .y > 0);.    s1 
-00007660: 3d20 5b6d 6178 2873 697a 6531 2e78 2c20  = [max(size1.x, 
-00007670: 6570 7329 2c20 6d61 7828 7369 7a65 312e  eps), max(size1.
-00007680: 792c 2065 7073 295d 3b0a 2020 2020 7332  y, eps)];.    s2
-00007690: 203d 205b 6d61 7828 7369 7a65 322e 782c   = [max(size2.x,
-000076a0: 2065 7073 292c 206d 6178 2873 697a 6532   eps), max(size2
-000076b0: 2e79 2c20 6570 7329 5d3b 0a20 2020 2072  .y, eps)];.    r
-000076c0: 6f75 6e64 696e 6731 203d 2064 6566 6175  ounding1 = defau
-000076d0: 6c74 2872 6f75 6e64 696e 6731 2c20 726f  lt(rounding1, ro
-000076e0: 756e 6469 6e67 293b 0a20 2020 2072 6f75  unding);.    rou
-000076f0: 6e64 696e 6732 203d 2064 6566 6175 6c74  nding2 = default
-00007700: 2872 6f75 6e64 696e 6732 2c20 726f 756e  (rounding2, roun
-00007710: 6469 6e67 293b 0a20 2020 2063 6861 6d66  ding);.    chamf
-00007720: 6572 3120 3d20 6465 6661 756c 7428 6368  er1 = default(ch
-00007730: 616d 6665 7231 2c20 6368 616d 6665 7229  amfer1, chamfer)
-00007740: 3b0a 2020 2020 6368 616d 6665 7232 203d  ;.    chamfer2 =
-00007750: 2064 6566 6175 6c74 2863 6861 6d66 6572   default(chamfer
-00007760: 322c 2063 6861 6d66 6572 293b 0a20 2020  2, chamfer);.   
-00007770: 2061 6e63 686f 7220 3d20 6765 745f 616e   anchor = get_an
-00007780: 6368 6f72 2861 6e63 686f 722c 2063 656e  chor(anchor, cen
-00007790: 7465 722c 2042 4f54 2c20 424f 5429 3b0a  ter, BOT, BOT);.
-000077a0: 2020 2020 766e 6620 3d20 7072 6973 6d6f      vnf = prismo
-000077b0: 6964 280a 2020 2020 2020 2020 7369 7a65  id(.        size
-000077c0: 313d 7369 7a65 312c 2073 697a 6532 3d73  1=size1, size2=s
-000077d0: 697a 6532 2c20 683d 682c 2073 6869 6674  ize2, h=h, shift
-000077e0: 3d73 6869 6674 2c0a 2020 2020 2020 2020  =shift,.        
-000077f0: 726f 756e 6469 6e67 313d 726f 756e 6469  rounding1=roundi
-00007800: 6e67 312c 2072 6f75 6e64 696e 6732 3d72  ng1, rounding2=r
-00007810: 6f75 6e64 696e 6732 2c0a 2020 2020 2020  ounding2,.      
-00007820: 2020 6368 616d 6665 7231 3d63 6861 6d66    chamfer1=chamf
-00007830: 6572 312c 2063 6861 6d66 6572 323d 6368  er1, chamfer2=ch
-00007840: 616d 6665 7232 2c0a 2020 2020 2020 2020  amfer2,.        
-00007850: 6c3d 6c2c 2063 656e 7465 723d 4345 4e54  l=l, center=CENT
-00007860: 4552 0a20 2020 2029 3b0a 2020 2020 6174  ER.    );.    at
-00007870: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
-00007880: 7370 696e 2c6f 7269 656e 742c 2073 697a  spin,orient, siz
-00007890: 653d 5b73 312e 782c 7331 2e79 2c68 5d2c  e=[s1.x,s1.y,h],
-000078a0: 2073 697a 6532 3d73 322c 2073 6869 6674   size2=s2, shift
-000078b0: 3d73 6869 6674 2920 7b0a 2020 2020 2020  =shift) {.      
-000078c0: 2020 766e 665f 706f 6c79 6865 6472 6f6e    vnf_polyhedron
-000078d0: 2876 6e66 2c20 636f 6e76 6578 6974 793d  (vnf, convexity=
-000078e0: 3429 3b0a 2020 2020 2020 2020 6368 696c  4);.        chil
-000078f0: 6472 656e 2829 3b0a 2020 2020 7d0a 7d0a  dren();.    }.}.
-00007900: 0a66 756e 6374 696f 6e20 7072 6973 6d6f  .function prismo
-00007910: 6964 280a 2020 2020 7369 7a65 312c 2073  id(.    size1, s
-00007920: 697a 6532 2c20 682c 2073 6869 6674 3d5b  ize2, h, shift=[
-00007930: 302c 305d 2c0a 2020 2020 726f 756e 6469  0,0],.    roundi
-00007940: 6e67 3d30 2c20 726f 756e 6469 6e67 312c  ng=0, rounding1,
-00007950: 2072 6f75 6e64 696e 6732 2c0a 2020 2020   rounding2,.    
-00007960: 6368 616d 6665 723d 302c 2063 6861 6d66  chamfer=0, chamf
-00007970: 6572 312c 2063 6861 6d66 6572 322c 0a20  er1, chamfer2,. 
-00007980: 2020 206c 2c20 6365 6e74 6572 2c0a 2020     l, center,.  
-00007990: 2020 616e 6368 6f72 3d44 4f57 4e2c 2073    anchor=DOWN, s
-000079a0: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
-000079b0: 0a29 203d 0a20 2020 2061 7373 6572 7428  .) =.    assert(
-000079c0: 6973 5f76 6563 746f 7228 7369 7a65 312c  is_vector(size1,
-000079d0: 3229 290a 2020 2020 6173 7365 7274 2869  2)).    assert(i
-000079e0: 735f 7665 6374 6f72 2873 697a 6532 2c32  s_vector(size2,2
-000079f0: 2929 0a20 2020 2061 7373 6572 7428 6973  )).    assert(is
-00007a00: 5f6e 756d 2868 2920 7c7c 2069 735f 6e75  _num(h) || is_nu
-00007a10: 6d28 6c29 290a 2020 2020 6173 7365 7274  m(l)).    assert
-00007a20: 2869 735f 7665 6374 6f72 2873 6869 6674  (is_vector(shift
-00007a30: 2c32 2929 0a20 2020 2061 7373 6572 7428  ,2)).    assert(
-00007a40: 0a20 2020 2020 2020 2028 6973 5f6e 756d  .        (is_num
-00007a50: 2872 6f75 6e64 696e 6729 2026 2620 726f  (rounding) && ro
-00007a60: 756e 6469 6e67 3e3d 3029 207c 7c0a 2020  unding>=0) ||.  
-00007a70: 2020 2020 2020 2869 735f 7665 6374 6f72        (is_vector
-00007a80: 2872 6f75 6e64 696e 672c 3429 2026 2620  (rounding,4) && 
-00007a90: 616c 6c5f 6e6f 6e6e 6567 6174 6976 6528  all_nonnegative(
-00007aa0: 726f 756e 6469 6e67 2929 2c0a 2020 2020  rounding)),.    
-00007ab0: 2020 2020 2242 6164 2072 6f75 6e64 696e      "Bad roundin
-00007ac0: 6720 6172 6775 6d65 6e74 2e22 0a20 2020  g argument.".   
-00007ad0: 2029 0a20 2020 2061 7373 6572 7428 0a20   ).    assert(. 
-00007ae0: 2020 2020 2020 2069 735f 756e 6465 6628         is_undef(
-00007af0: 726f 756e 6469 6e67 3129 207c 7c20 2869  rounding1) || (i
-00007b00: 735f 6e75 6d28 726f 756e 6469 6e67 3129  s_num(rounding1)
-00007b10: 2026 2620 726f 756e 6469 6e67 313e 3d30   && rounding1>=0
-00007b20: 2920 7c7c 0a20 2020 2020 2020 2028 6973  ) ||.        (is
-00007b30: 5f76 6563 746f 7228 726f 756e 6469 6e67  _vector(rounding
-00007b40: 312c 3429 2026 2620 616c 6c5f 6e6f 6e6e  1,4) && all_nonn
-00007b50: 6567 6174 6976 6528 726f 756e 6469 6e67  egative(rounding
-00007b60: 3129 292c 0a20 2020 2020 2020 2022 4261  1)),.        "Ba
-00007b70: 6420 726f 756e 6469 6e67 3120 6172 6775  d rounding1 argu
-00007b80: 6d65 6e74 2e22 0a20 2020 2029 0a20 2020  ment.".    ).   
-00007b90: 2061 7373 6572 7428 0a20 2020 2020 2020   assert(.       
-00007ba0: 2069 735f 756e 6465 6628 726f 756e 6469   is_undef(roundi
-00007bb0: 6e67 3229 207c 7c20 2869 735f 6e75 6d28  ng2) || (is_num(
-00007bc0: 726f 756e 6469 6e67 3229 2026 2620 726f  rounding2) && ro
-00007bd0: 756e 6469 6e67 323e 3d30 2920 7c7c 0a20  unding2>=0) ||. 
-00007be0: 2020 2020 2020 2028 6973 5f76 6563 746f         (is_vecto
-00007bf0: 7228 726f 756e 6469 6e67 322c 3429 2026  r(rounding2,4) &
-00007c00: 2620 616c 6c5f 6e6f 6e6e 6567 6174 6976  & all_nonnegativ
-00007c10: 6528 726f 756e 6469 6e67 3229 292c 0a20  e(rounding2)),. 
-00007c20: 2020 2020 2020 2022 4261 6420 726f 756e         "Bad roun
-00007c30: 6469 6e67 3220 6172 6775 6d65 6e74 2e22  ding2 argument."
-00007c40: 0a20 2020 2029 0a20 2020 2061 7373 6572  .    ).    asser
-00007c50: 7428 0a20 2020 2020 2020 2028 6973 5f6e  t(.        (is_n
-00007c60: 756d 2863 6861 6d66 6572 2920 2626 2063  um(chamfer) && c
-00007c70: 6861 6d66 6572 3e3d 3029 207c 7c0a 2020  hamfer>=0) ||.  
-00007c80: 2020 2020 2020 2869 735f 7665 6374 6f72        (is_vector
-00007c90: 2863 6861 6d66 6572 2c34 2920 2626 2061  (chamfer,4) && a
-00007ca0: 6c6c 5f6e 6f6e 6e65 6761 7469 7665 2863  ll_nonnegative(c
-00007cb0: 6861 6d66 6572 2929 2c0a 2020 2020 2020  hamfer)),.      
-00007cc0: 2020 2242 6164 2063 6861 6d66 6572 2061    "Bad chamfer a
-00007cd0: 7267 756d 656e 742e 220a 2020 2020 290a  rgument.".    ).
-00007ce0: 2020 2020 6173 7365 7274 280a 2020 2020      assert(.    
-00007cf0: 2020 2020 6973 5f75 6e64 6566 2863 6861      is_undef(cha
-00007d00: 6d66 6572 3129 207c 7c20 2869 735f 6e75  mfer1) || (is_nu
-00007d10: 6d28 6368 616d 6665 7231 2920 2626 2063  m(chamfer1) && c
-00007d20: 6861 6d66 6572 313e 3d30 2920 7c7c 0a20  hamfer1>=0) ||. 
-00007d30: 2020 2020 2020 2028 6973 5f76 6563 746f         (is_vecto
-00007d40: 7228 6368 616d 6665 7231 2c34 2920 2626  r(chamfer1,4) &&
-00007d50: 2061 6c6c 5f6e 6f6e 6e65 6761 7469 7665   all_nonnegative
-00007d60: 2863 6861 6d66 6572 3129 292c 0a20 2020  (chamfer1)),.   
-00007d70: 2020 2020 2022 4261 6420 6368 616d 6665       "Bad chamfe
-00007d80: 7231 2061 7267 756d 656e 742e 220a 2020  r1 argument.".  
-00007d90: 2020 290a 2020 2020 6173 7365 7274 280a    ).    assert(.
-00007da0: 2020 2020 2020 2020 6973 5f75 6e64 6566          is_undef
-00007db0: 2863 6861 6d66 6572 3229 207c 7c20 2869  (chamfer2) || (i
-00007dc0: 735f 6e75 6d28 6368 616d 6665 7232 2920  s_num(chamfer2) 
-00007dd0: 2626 2063 6861 6d66 6572 323e 3d30 2920  && chamfer2>=0) 
-00007de0: 7c7c 0a20 2020 2020 2020 2028 6973 5f76  ||.        (is_v
-00007df0: 6563 746f 7228 6368 616d 6665 7232 2c34  ector(chamfer2,4
-00007e00: 2920 2626 2061 6c6c 5f6e 6f6e 6e65 6761  ) && all_nonnega
-00007e10: 7469 7665 2863 6861 6d66 6572 3229 292c  tive(chamfer2)),
-00007e20: 0a20 2020 2020 2020 2022 4261 6420 6368  .        "Bad ch
-00007e30: 616d 6665 7232 2061 7267 756d 656e 742e  amfer2 argument.
-00007e40: 220a 2020 2020 290a 2020 2020 6c65 7428  ".    ).    let(
-00007e50: 0a20 2020 2020 2020 2065 7073 203d 2070  .        eps = p
-00007e60: 6f77 2832 2c2d 3134 292c 0a20 2020 2020  ow(2,-14),.     
-00007e70: 2020 2068 203d 2066 6972 7374 5f64 6566     h = first_def
-00007e80: 696e 6564 285b 682c 6c2c 315d 292c 0a20  ined([h,l,1]),. 
-00007e90: 2020 2020 2020 2073 6869 6674 6279 203d         shiftby =
-00007ea0: 2070 6f69 6e74 3364 2870 6f69 6e74 3264   point3d(point2d
-00007eb0: 2873 6869 6674 2929 2c0a 2020 2020 2020  (shift)),.      
-00007ec0: 2020 7331 203d 205b 6d61 7828 7369 7a65    s1 = [max(size
-00007ed0: 312e 782c 2065 7073 292c 206d 6178 2873  1.x, eps), max(s
-00007ee0: 697a 6531 2e79 2c20 6570 7329 5d2c 0a20  ize1.y, eps)],. 
-00007ef0: 2020 2020 2020 2073 3220 3d20 5b6d 6178         s2 = [max
-00007f00: 2873 697a 6532 2e78 2c20 6570 7329 2c20  (size2.x, eps), 
-00007f10: 6d61 7828 7369 7a65 322e 792c 2065 7073  max(size2.y, eps
-00007f20: 295d 2c0a 2020 2020 2020 2020 726f 756e  )],.        roun
-00007f30: 6469 6e67 3120 3d20 6465 6661 756c 7428  ding1 = default(
-00007f40: 726f 756e 6469 6e67 312c 2072 6f75 6e64  rounding1, round
-00007f50: 696e 6729 2c0a 2020 2020 2020 2020 726f  ing),.        ro
-00007f60: 756e 6469 6e67 3220 3d20 6465 6661 756c  unding2 = defaul
-00007f70: 7428 726f 756e 6469 6e67 322c 2072 6f75  t(rounding2, rou
-00007f80: 6e64 696e 6729 2c0a 2020 2020 2020 2020  nding),.        
-00007f90: 6368 616d 6665 7231 203d 2064 6566 6175  chamfer1 = defau
-00007fa0: 6c74 2863 6861 6d66 6572 312c 2063 6861  lt(chamfer1, cha
-00007fb0: 6d66 6572 292c 0a20 2020 2020 2020 2063  mfer),.        c
-00007fc0: 6861 6d66 6572 3220 3d20 6465 6661 756c  hamfer2 = defaul
-00007fd0: 7428 6368 616d 6665 7232 2c20 6368 616d  t(chamfer2, cham
-00007fe0: 6665 7229 2c0a 2020 2020 2020 2020 616e  fer),.        an
-00007ff0: 6368 6f72 203d 2067 6574 5f61 6e63 686f  chor = get_ancho
-00008000: 7228 616e 6368 6f72 2c20 6365 6e74 6572  r(anchor, center
-00008010: 2c20 424f 542c 2042 4f54 292c 0a20 2020  , BOT, BOT),.   
-00008020: 2020 2020 2076 6e66 203d 2028 726f 756e       vnf = (roun
-00008030: 6469 6e67 313d 3d30 2026 2620 726f 756e  ding1==0 && roun
-00008040: 6469 6e67 323d 3d30 2026 2620 6368 616d  ding2==0 && cham
-00008050: 6665 7231 3d3d 3020 2626 2063 6861 6d66  fer1==0 && chamf
-00008060: 6572 323d 3d30 293f 2028 0a20 2020 2020  er2==0)? (.     
-00008070: 2020 2020 2020 206c 6574 280a 2020 2020         let(.    
-00008080: 2020 2020 2020 2020 2020 2020 636f 726e              corn
-00008090: 6572 7320 3d20 5b5b 312c 315d 2c5b 312c  ers = [[1,1],[1,
-000080a0: 2d31 5d2c 5b2d 312c 2d31 5d2c 5b2d 312c  -1],[-1,-1],[-1,
-000080b0: 315d 5d20 2a20 302e 352c 0a20 2020 2020  1]] * 0.5,.     
-000080c0: 2020 2020 2020 2020 2020 2070 6f69 6e74             point
-000080d0: 7320 3d20 5b0a 2020 2020 2020 2020 2020  s = [.          
-000080e0: 2020 2020 2020 2020 2020 666f 7220 2870            for (p
-000080f0: 3d63 6f72 6e65 7273 2920 706f 696e 7433  =corners) point3
-00008100: 6428 765f 6d75 6c28 7332 2c70 292c 202b  d(v_mul(s2,p), +
-00008110: 682f 3229 202b 2073 6869 6674 6279 2c0a  h/2) + shiftby,.
-00008120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008130: 2020 2020 666f 7220 2870 3d63 6f72 6e65      for (p=corne
-00008140: 7273 2920 706f 696e 7433 6428 765f 6d75  rs) point3d(v_mu
-00008150: 6c28 7331 2c70 292c 202d 682f 3229 0a20  l(s1,p), -h/2). 
-00008160: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-00008170: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008180: 2020 6661 6365 733d 5b0a 2020 2020 2020    faces=[.      
-00008190: 2020 2020 2020 2020 2020 2020 2020 5b30                [0
-000081a0: 2c31 2c32 5d2c 205b 302c 322c 335d 2c20  ,1,2], [0,2,3], 
-000081b0: 5b30 2c34 2c35 5d2c 205b 302c 352c 315d  [0,4,5], [0,5,1]
-000081c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000081d0: 2020 2020 2020 5b31 2c35 2c36 5d2c 205b        [1,5,6], [
-000081e0: 312c 362c 325d 2c20 5b32 2c36 2c37 5d2c  1,6,2], [2,6,7],
-000081f0: 205b 322c 372c 335d 2c0a 2020 2020 2020   [2,7,3],.      
-00008200: 2020 2020 2020 2020 2020 2020 2020 5b33                [3
-00008210: 2c37 2c34 5d2c 205b 332c 342c 305d 2c20  ,7,4], [3,4,0], 
-00008220: 5b34 2c37 2c36 5d2c 205b 342c 362c 355d  [4,7,6], [4,6,5]
-00008230: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008240: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
-00008250: 2920 5b70 6f69 6e74 732c 2066 6163 6573  ) [points, faces
-00008260: 5d0a 2020 2020 2020 2020 2920 3a20 280a  ].        ) : (.
-00008270: 2020 2020 2020 2020 2020 2020 6c65 7428              let(
-00008280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008290: 2070 6174 6831 203d 2072 6563 7428 7369   path1 = rect(si
-000082a0: 7a65 312c 2072 6f75 6e64 696e 673d 726f  ze1, rounding=ro
-000082b0: 756e 6469 6e67 312c 2063 6861 6d66 6572  unding1, chamfer
-000082c0: 3d63 6861 6d66 6572 312c 2061 6e63 686f  =chamfer1, ancho
-000082d0: 723d 4354 5229 2c0a 2020 2020 2020 2020  r=CTR),.        
-000082e0: 2020 2020 2020 2020 7061 7468 3220 3d20          path2 = 
-000082f0: 7265 6374 2873 697a 6532 2c20 726f 756e  rect(size2, roun
-00008300: 6469 6e67 3d72 6f75 6e64 696e 6732 2c20  ding=rounding2, 
-00008310: 6368 616d 6665 723d 6368 616d 6665 7232  chamfer=chamfer2
-00008320: 2c20 616e 6368 6f72 3d43 5452 292c 0a20  , anchor=CTR),. 
-00008330: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00008340: 6f69 6e74 7320 3d20 5b0a 2020 2020 2020  oints = [.      
-00008350: 2020 2020 2020 2020 2020 2020 2020 6561                ea
-00008360: 6368 2070 6174 6833 6428 7061 7468 312c  ch path3d(path1,
-00008370: 202d 682f 3229 2c0a 2020 2020 2020 2020   -h/2),.        
-00008380: 2020 2020 2020 2020 2020 2020 6561 6368              each
-00008390: 2070 6174 6833 6428 6d6f 7665 2873 6869   path3d(move(shi
-000083a0: 6674 6279 2c20 703d 7061 7468 3229 2c20  ftby, p=path2), 
-000083b0: 2b68 2f32 292c 0a20 2020 2020 2020 2020  +h/2),.         
-000083c0: 2020 2020 2020 205d 2c0a 2020 2020 2020         ],.      
-000083d0: 2020 2020 2020 2020 2020 6661 6365 7320            faces 
-000083e0: 3d20 6875 6c6c 2870 6f69 6e74 7329 0a20  = hull(points). 
-000083f0: 2020 2020 2020 2020 2020 2029 205b 706f             ) [po
-00008400: 696e 7473 2c20 6661 6365 735d 0a20 2020  ints, faces].   
-00008410: 2020 2020 2029 0a20 2020 2029 2072 656f       ).    ) reo
-00008420: 7269 656e 7428 616e 6368 6f72 2c73 7069  rient(anchor,spi
-00008430: 6e2c 6f72 6965 6e74 2c20 7369 7a65 3d5b  n,orient, size=[
-00008440: 7331 2e78 2c73 312e 792c 685d 2c20 7369  s1.x,s1.y,h], si
-00008450: 7a65 323d 7332 2c20 7368 6966 743d 7368  ze2=s2, shift=sh
-00008460: 6966 742c 2070 3d76 6e66 293b 0a0a 0a2f  ift, p=vnf);.../
-00008470: 2f20 4675 6e63 7469 6f6e 264d 6f64 756c  / Function&Modul
-00008480: 653a 206f 6374 6168 6564 726f 6e28 290a  e: octahedron().
-00008490: 2f2f 2055 7361 6765 3a20 4173 204d 6f64  // Usage: As Mod
-000084a0: 756c 650a 2f2f 2020 206f 6374 6168 6564  ule.//   octahed
-000084b0: 726f 6e28 7369 7a65 2c20 2e2e 2e29 205b  ron(size, ...) [
-000084c0: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-000084d0: 2055 7361 6765 3a20 4173 2046 756e 6374   Usage: As Funct
-000084e0: 696f 6e0a 2f2f 2020 2076 6e66 203d 206f  ion.//   vnf = o
-000084f0: 6374 6168 6564 726f 6e28 7369 7a65 2c20  ctahedron(size, 
-00008500: 2e2e 2e29 3b0a 2f2f 2044 6573 6372 6970  ...);.// Descrip
-00008510: 7469 6f6e 3a0a 2f2f 2020 2057 6865 6e20  tion:.//   When 
-00008520: 6361 6c6c 6564 2061 7320 6120 6d6f 6475  called as a modu
-00008530: 6c65 2c20 6372 6561 7465 7320 616e 206f  le, creates an o
-00008540: 6374 6168 6564 726f 6e20 7769 7468 2061  ctahedron with a
-00008550: 7869 732d 616c 6967 6e65 6420 706f 696e  xis-aligned poin
-00008560: 7473 2e0a 2f2f 2020 2057 6865 6e20 6361  ts..//   When ca
-00008570: 6c6c 6564 2061 7320 6120 6675 6e63 7469  lled as a functi
-00008580: 6f6e 2c20 6372 6561 7465 7320 6120 5b5b  on, creates a [[
-00008590: 564e 467c 766e 662e 7363 6164 5d5d 206f  VNF|vnf.scad]] o
-000085a0: 6620 616e 206f 6374 6168 6564 726f 6e20  f an octahedron 
-000085b0: 7769 7468 2061 7869 732d 616c 6967 6e65  with axis-aligne
-000085c0: 6420 706f 696e 7473 2e0a 2f2f 2041 7267  d points..// Arg
-000085d0: 756d 656e 7473 3a0a 2f2f 2020 2073 697a  uments:.//   siz
-000085e0: 6520 3d20 5769 6474 6820 6f66 2074 6865  e = Width of the
-000085f0: 206f 6374 6168 6564 726f 6e2c 2074 6970   octahedron, tip
-00008600: 2074 6f20 7469 702e 0a2f 2f20 2020 2d2d   to tip..//   --
-00008610: 2d0a 2f2f 2020 2061 6e63 686f 7220 3d20  -.//   anchor = 
-00008620: 5472 616e 736c 6174 6520 736f 2061 6e63  Translate so anc
-00008630: 686f 7220 706f 696e 7420 6973 2061 7420  hor point is at 
-00008640: 6f72 6967 696e 2028 302c 302c 3029 2e20  origin (0,0,0). 
-00008650: 2053 6565 205b 616e 6368 6f72 5d28 6174   See [anchor](at
-00008660: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-00008670: 7562 7365 6374 696f 6e2d 616e 6368 6f72  ubsection-anchor
-00008680: 292e 2020 4465 6661 756c 743a 2060 4345  ).  Default: `CE
-00008690: 4e54 4552 600a 2f2f 2020 2073 7069 6e20  NTER`.//   spin 
-000086a0: 3d20 526f 7461 7465 2074 6869 7320 6d61  = Rotate this ma
-000086b0: 6e79 2064 6567 7265 6573 2061 726f 756e  ny degrees aroun
-000086c0: 6420 7468 6520 5a20 6178 6973 2061 6674  d the Z axis aft
-000086d0: 6572 2061 6e63 686f 722e 2020 5365 6520  er anchor.  See 
-000086e0: 5b73 7069 6e5d 2861 7474 6163 686d 656e  [spin](attachmen
-000086f0: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
-00008700: 6f6e 2d73 7069 6e29 2e20 2044 6566 6175  on-spin).  Defau
-00008710: 6c74 3a20 6030 600a 2f2f 2020 206f 7269  lt: `0`.//   ori
-00008720: 656e 7420 3d20 5665 6374 6f72 2074 6f20  ent = Vector to 
-00008730: 726f 7461 7465 2074 6f70 2074 6f77 6172  rotate top towar
-00008740: 6473 2c20 6166 7465 7220 7370 696e 2e20  ds, after spin. 
-00008750: 2053 6565 205b 6f72 6965 6e74 5d28 6174   See [orient](at
-00008760: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-00008770: 7562 7365 6374 696f 6e2d 6f72 6965 6e74  ubsection-orient
-00008780: 292e 2020 4465 6661 756c 743a 2060 5550  ).  Default: `UP
-00008790: 600a 2f2f 2045 7861 6d70 6c65 3a0a 2f2f  `.// Example:.//
-000087a0: 2020 206f 6374 6168 6564 726f 6e28 7369     octahedron(si
-000087b0: 7a65 3d34 3029 3b0a 2f2f 2045 7861 6d70  ze=40);.// Examp
-000087c0: 6c65 3a20 416e 6368 6f72 730a 2f2f 2020  le: Anchors.//  
-000087d0: 206f 6374 6168 6564 726f 6e28 7369 7a65   octahedron(size
-000087e0: 3d34 3029 2073 686f 775f 616e 6368 6f72  =40) show_anchor
-000087f0: 7328 293b 0a6d 6f64 756c 6520 6f63 7461  s();.module octa
-00008800: 6865 6472 6f6e 2873 697a 653d 312c 2061  hedron(size=1, a
-00008810: 6e63 686f 723d 4345 4e54 4552 2c20 7370  nchor=CENTER, sp
-00008820: 696e 3d30 2c20 6f72 6965 6e74 3d55 5029  in=0, orient=UP)
-00008830: 207b 0a20 2020 2076 6e66 203d 206f 6374   {.    vnf = oct
-00008840: 6168 6564 726f 6e28 7369 7a65 3d73 697a  ahedron(size=siz
-00008850: 6529 3b0a 2020 2020 6174 7461 6368 6162  e);.    attachab
-00008860: 6c65 2861 6e63 686f 722c 7370 696e 2c6f  le(anchor,spin,o
-00008870: 7269 656e 742c 2076 6e66 3d76 6e66 2c20  rient, vnf=vnf, 
-00008880: 6578 7465 6e74 3d74 7275 6529 207b 0a20  extent=true) {. 
-00008890: 2020 2020 2020 2076 6e66 5f70 6f6c 7968         vnf_polyh
-000088a0: 6564 726f 6e28 766e 662c 2063 6f6e 7665  edron(vnf, conve
-000088b0: 7869 7479 3d32 293b 0a20 2020 2020 2020  xity=2);.       
-000088c0: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
-000088d0: 207d 0a7d 0a0a 6675 6e63 7469 6f6e 206f   }.}..function o
-000088e0: 6374 6168 6564 726f 6e28 7369 7a65 3d31  ctahedron(size=1
-000088f0: 2c20 616e 6368 6f72 3d43 454e 5445 522c  , anchor=CENTER,
-00008900: 2073 7069 6e3d 302c 206f 7269 656e 743d   spin=0, orient=
-00008910: 5550 2920 3d0a 2020 2020 6c65 7428 0a20  UP) =.    let(. 
-00008920: 2020 2020 2020 2073 697a 6520 3d20 7363         size = sc
-00008930: 616c 6172 5f76 6563 3328 7369 7a65 292c  alar_vec3(size),
-00008940: 0a20 2020 2020 2020 2073 203d 2073 697a  .        s = siz
-00008950: 652f 322c 0a20 2020 2020 2020 2076 6e66  e/2,.        vnf
-00008960: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-00008970: 205b 205b 302c 302c 732e 7a5d 2c20 5b73   [ [0,0,s.z], [s
-00008980: 2e78 2c30 2c30 5d2c 205b 302c 732e 792c  .x,0,0], [0,s.y,
-00008990: 305d 2c20 5b2d 732e 782c 302c 305d 2c20  0], [-s.x,0,0], 
-000089a0: 5b30 2c2d 732e 792c 305d 2c20 5b30 2c30  [0,-s.y,0], [0,0
-000089b0: 2c2d 732e 7a5d 205d 2c0a 2020 2020 2020  ,-s.z] ],.      
-000089c0: 2020 2020 2020 5b20 5b30 2c32 2c31 5d2c        [ [0,2,1],
-000089d0: 205b 302c 332c 325d 2c20 5b30 2c34 2c33   [0,3,2], [0,4,3
-000089e0: 5d2c 205b 302c 312c 345d 2c20 5b35 2c31  ], [0,1,4], [5,1
-000089f0: 2c32 5d2c 205b 352c 322c 335d 2c20 5b35  ,2], [5,2,3], [5
-00008a00: 2c33 2c34 5d2c 205b 352c 342c 315d 205d  ,3,4], [5,4,1] ]
-00008a10: 0a20 2020 2020 2020 205d 0a20 2020 2029  .        ].    )
-00008a20: 2072 656f 7269 656e 7428 616e 6368 6f72   reorient(anchor
-00008a30: 2c73 7069 6e2c 6f72 6965 6e74 2c20 766e  ,spin,orient, vn
-00008a40: 663d 766e 662c 2065 7874 656e 743d 7472  f=vnf, extent=tr
-00008a50: 7565 2c20 703d 766e 6629 3b0a 0a0a 2f2f  ue, p=vnf);...//
-00008a60: 204d 6f64 756c 653a 2072 6563 745f 7475   Module: rect_tu
-00008a70: 6265 2829 0a2f 2f20 5573 6167 653a 2054  be().// Usage: T
-00008a80: 7970 6963 616c 2052 6563 7461 6e67 756c  ypical Rectangul
-00008a90: 6172 2054 7562 6573 0a2f 2f20 2020 7265  ar Tubes.//   re
-00008aa0: 6374 5f74 7562 6528 682c 2073 697a 652c  ct_tube(h, size,
-00008ab0: 2069 7369 7a65 2c20 5b63 656e 7465 725d   isize, [center]
-00008ac0: 2c20 5b73 6869 6674 5d29 3b0a 2f2f 2020  , [shift]);.//  
-00008ad0: 2072 6563 745f 7475 6265 2868 2c20 7369   rect_tube(h, si
-00008ae0: 7a65 2c20 7761 6c6c 3d2c 205b 6365 6e74  ze, wall=, [cent
-00008af0: 6572 3d5d 293b 0a2f 2f20 2020 7265 6374  er=]);.//   rect
-00008b00: 5f74 7562 6528 682c 2069 7369 7a65 3d2c  _tube(h, isize=,
-00008b10: 2077 616c 6c3d 2c20 5b63 656e 7465 723d   wall=, [center=
-00008b20: 5d29 3b0a 2f2f 2055 7361 6765 3a20 5461  ]);.// Usage: Ta
-00008b30: 7065 7269 6e67 2052 6563 7461 6e67 756c  pering Rectangul
-00008b40: 6172 2054 7562 6573 0a2f 2f20 2020 7265  ar Tubes.//   re
-00008b50: 6374 5f74 7562 6528 682c 2073 697a 6531  ct_tube(h, size1
-00008b60: 3d2c 2073 697a 6532 3d2c 2077 616c 6c3d  =, size2=, wall=
-00008b70: 2c20 2e2e 2e29 3b0a 2f2f 2020 2072 6563  , ...);.//   rec
-00008b80: 745f 7475 6265 2868 2c20 6973 697a 6531  t_tube(h, isize1
-00008b90: 3d2c 2069 7369 7a65 323d 2c20 7761 6c6c  =, isize2=, wall
-00008ba0: 3d2c 202e 2e2e 293b 0a2f 2f20 2020 7265  =, ...);.//   re
-00008bb0: 6374 5f74 7562 6528 682c 2073 697a 6531  ct_tube(h, size1
-00008bc0: 3d2c 2073 697a 6532 3d2c 2069 7369 7a65  =, size2=, isize
-00008bd0: 313d 2c20 6973 697a 6532 3d2c 202e 2e2e  1=, isize2=, ...
-00008be0: 293b 0a2f 2f20 5573 6167 653a 2043 6861  );.// Usage: Cha
-00008bf0: 6d66 6572 6564 0a2f 2f20 2020 7265 6374  mfered.//   rect
-00008c00: 5f74 7562 6528 682c 2073 697a 652c 2069  _tube(h, size, i
-00008c10: 7369 7a65 2c20 6368 616d 6665 723d 2c20  size, chamfer=, 
-00008c20: 2e2e 2e29 3b0a 2f2f 2020 2072 6563 745f  ...);.//   rect_
-00008c30: 7475 6265 2868 2c20 7369 7a65 2c20 6973  tube(h, size, is
-00008c40: 697a 652c 2063 6861 6d66 6572 313d 2c20  ize, chamfer1=, 
-00008c50: 6368 616d 6665 7232 3d20 2e2e 2e29 3b0a  chamfer2= ...);.
-00008c60: 2f2f 2020 2072 6563 745f 7475 6265 2868  //   rect_tube(h
-00008c70: 2c20 7369 7a65 2c20 6973 697a 652c 2069  , size, isize, i
-00008c80: 6368 616d 6665 723d 2c20 2e2e 2e29 3b0a  chamfer=, ...);.
-00008c90: 2f2f 2020 2072 6563 745f 7475 6265 2868  //   rect_tube(h
-00008ca0: 2c20 7369 7a65 2c20 6973 697a 652c 2069  , size, isize, i
-00008cb0: 6368 616d 6665 7231 3d2c 2069 6368 616d  chamfer1=, icham
-00008cc0: 6665 7232 3d20 2e2e 2e29 3b0a 2f2f 2020  fer2= ...);.//  
-00008cd0: 2072 6563 745f 7475 6265 2868 2c20 7369   rect_tube(h, si
-00008ce0: 7a65 2c20 6973 697a 652c 2063 6861 6d66  ze, isize, chamf
-00008cf0: 6572 3d2c 2069 6368 616d 6665 723d 2c20  er=, ichamfer=, 
-00008d00: 2e2e 2e29 3b0a 2f2f 2055 7361 6765 3a20  ...);.// Usage: 
-00008d10: 526f 756e 6465 640a 2f2f 2020 2072 6563  Rounded.//   rec
-00008d20: 745f 7475 6265 2868 2c20 7369 7a65 2c20  t_tube(h, size, 
-00008d30: 6973 697a 652c 2072 6f75 6e64 696e 673d  isize, rounding=
-00008d40: 2c20 2e2e 2e29 3b0a 2f2f 2020 2072 6563  , ...);.//   rec
-00008d50: 745f 7475 6265 2868 2c20 7369 7a65 2c20  t_tube(h, size, 
-00008d60: 6973 697a 652c 2072 6f75 6e64 696e 6731  isize, rounding1
-00008d70: 3d2c 2072 6f75 6e64 696e 6732 3d20 2e2e  =, rounding2= ..
-00008d80: 2e29 3b0a 2f2f 2020 2072 6563 745f 7475  .);.//   rect_tu
-00008d90: 6265 2868 2c20 7369 7a65 2c20 6973 697a  be(h, size, isiz
-00008da0: 652c 2069 726f 756e 6469 6e67 3d2c 202e  e, irounding=, .
-00008db0: 2e2e 293b 0a2f 2f20 2020 7265 6374 5f74  ..);.//   rect_t
-00008dc0: 7562 6528 682c 2073 697a 652c 2069 7369  ube(h, size, isi
-00008dd0: 7a65 2c20 6972 6f75 6e64 696e 6731 3d2c  ze, irounding1=,
-00008de0: 2069 726f 756e 6469 6e67 323d 202e 2e2e   irounding2= ...
-00008df0: 293b 0a2f 2f20 2020 7265 6374 5f74 7562  );.//   rect_tub
-00008e00: 6528 682c 2073 697a 652c 2069 7369 7a65  e(h, size, isize
-00008e10: 2c20 726f 756e 6469 6e67 3d2c 2069 726f  , rounding=, iro
-00008e20: 756e 6469 6e67 3d2c 202e 2e2e 293b 0a2f  unding=, ...);./
-00008e30: 2f20 5573 6167 653a 2041 7474 6163 6869  / Usage: Attachi
-00008e40: 6e67 2043 6869 6c64 7265 6e0a 2f2f 2020  ng Children.//  
-00008e50: 2072 6563 745f 7475 6265 282e 2e2e 2920   rect_tube(...) 
-00008e60: 4154 5441 4348 4d45 4e54 533b 0a2f 2f0a  ATTACHMENTS;.//.
-00008e70: 2f2f 2044 6573 6372 6970 7469 6f6e 3a0a  // Description:.
-00008e80: 2f2f 2020 2043 7265 6174 6573 2061 2072  //   Creates a r
-00008e90: 6563 7461 6e67 756c 6172 206f 7220 7072  ectangular or pr
-00008ea0: 6973 6d6f 6964 2074 7562 6520 7769 7468  ismoid tube with
-00008eb0: 206f 7074 696f 6e61 6c20 726f 756e 646f   optional roundo
-00008ec0: 7665 7273 2061 6e64 2f6f 7220 6368 616d  vers and/or cham
-00008ed0: 6665 7273 2e0a 2f2f 2020 2059 6f75 2063  fers..//   You c
-00008ee0: 616e 206f 6e6c 7920 726f 756e 6420 6f72  an only round or
-00008ef0: 2063 6861 6d66 6572 2074 6865 2076 6572   chamfer the ver
-00008f00: 7469 6361 6c28 6973 6829 2065 6467 6573  tical(ish) edges
-00008f10: 2e20 2046 6f72 2074 686f 7365 2065 6467  .  For those edg
-00008f20: 6573 2c20 796f 7520 6361 6e0a 2f2f 2020  es, you can.//  
-00008f30: 2073 7065 6369 6679 2072 6f75 6e64 696e   specify roundin
-00008f40: 6720 616e 642f 6f72 2063 6861 6d66 6572  g and/or chamfer
-00008f50: 7269 6e67 2070 6572 2d65 6467 652c 2061  ring per-edge, a
-00008f60: 6e64 2066 6f72 2074 6f70 2061 6e64 2062  nd for top and b
-00008f70: 6f74 746f 6d2c 2069 6e73 6964 6520 616e  ottom, inside an
-00008f80: 640a 2f2f 2020 206f 7574 7369 6465 2020  d.//   outside  
-00008f90: 7365 7061 7261 7465 6c79 2e0a 2f2f 2041  separately..// A
-00008fa0: 7267 756d 656e 7473 3a0a 2f2f 2020 2068  rguments:.//   h
-00008fb0: 2f6c 203d 2054 6865 2068 6569 6768 7420  /l = The height 
-00008fc0: 6f72 206c 656e 6774 6820 6f66 2074 6865  or length of the
-00008fd0: 2072 6563 7461 6e67 756c 6172 2074 7562   rectangular tub
-00008fe0: 652e 2020 4465 6661 756c 743a 2031 0a2f  e.  Default: 1./
-00008ff0: 2f20 2020 7369 7a65 203d 2054 6865 206f  /   size = The o
-00009000: 7574 6572 205b 582c 595d 2073 697a 6520  uter [X,Y] size 
-00009010: 6f66 2074 6865 2072 6563 7461 6e67 756c  of the rectangul
-00009020: 6172 2074 7562 652e 0a2f 2f20 2020 6973  ar tube..//   is
-00009030: 697a 6520 3d20 5468 6520 696e 6e65 7220  ize = The inner 
-00009040: 5b58 2c59 5d20 7369 7a65 206f 6620 7468  [X,Y] size of th
-00009050: 6520 7265 6374 616e 6775 6c61 7220 7475  e rectangular tu
-00009060: 6265 2e0a 2f2f 2020 2063 656e 7465 7220  be..//   center 
-00009070: 3d20 4966 2067 6976 656e 2c20 6f76 6572  = If given, over
-00009080: 7269 6465 7320 6061 6e63 686f 7260 2e20  rides `anchor`. 
-00009090: 2041 2074 7275 6520 7661 6c75 6520 7365   A true value se
-000090a0: 7473 2060 616e 6368 6f72 3d43 454e 5445  ts `anchor=CENTE
-000090b0: 5260 2c20 6661 6c73 6520 7365 7473 2060  R`, false sets `
-000090c0: 616e 6368 6f72 3d55 5060 2e0a 2f2f 2020  anchor=UP`..//  
-000090d0: 2073 6869 6674 203d 205b 582c 595d 2061   shift = [X,Y] a
-000090e0: 6d6f 756e 7420 746f 2073 6869 6674 2074  mount to shift t
-000090f0: 6865 2063 656e 7465 7220 6f66 2074 6865  he center of the
-00009100: 2074 6f70 2065 6e64 2077 6974 6820 7265   top end with re
-00009110: 7370 6563 7420 746f 2074 6865 2063 656e  spect to the cen
-00009120: 7465 7220 6f66 2074 6865 2062 6f74 746f  ter of the botto
-00009130: 6d20 656e 642e 0a2f 2f20 2020 2d2d 2d0a  m end..//   ---.
-00009140: 2f2f 2020 2077 616c 6c20 3d20 5468 6520  //   wall = The 
-00009150: 7468 6963 6b6e 6573 7320 6f66 2074 6865  thickness of the
-00009160: 2072 6563 7461 6e67 756c 6172 2074 7562   rectangular tub
-00009170: 6520 7761 6c6c 2e0a 2f2f 2020 2073 697a  e wall..//   siz
-00009180: 6531 203d 2054 6865 205b 582c 595d 2073  e1 = The [X,Y] s
-00009190: 697a 6520 6f66 2074 6865 206f 7574 7369  ize of the outsi
-000091a0: 6465 206f 6620 7468 6520 626f 7474 6f6d  de of the bottom
-000091b0: 206f 6620 7468 6520 7265 6374 616e 6775   of the rectangu
-000091c0: 6c61 7220 7475 6265 2e0a 2f2f 2020 2073  lar tube..//   s
-000091d0: 697a 6532 203d 2054 6865 205b 582c 595d  ize2 = The [X,Y]
-000091e0: 2073 697a 6520 6f66 2074 6865 206f 7574   size of the out
-000091f0: 7369 6465 206f 6620 7468 6520 746f 7020  side of the top 
-00009200: 6f66 2074 6865 2072 6563 7461 6e67 756c  of the rectangul
-00009210: 6172 2074 7562 652e 0a2f 2f20 2020 6973  ar tube..//   is
-00009220: 697a 6531 203d 2054 6865 205b 582c 595d  ize1 = The [X,Y]
-00009230: 2073 697a 6520 6f66 2074 6865 2069 6e73   size of the ins
-00009240: 6964 6520 6f66 2074 6865 2062 6f74 746f  ide of the botto
-00009250: 6d20 6f66 2074 6865 2072 6563 7461 6e67  m of the rectang
-00009260: 756c 6172 2074 7562 652e 0a2f 2f20 2020  ular tube..//   
-00009270: 6973 697a 6532 203d 2054 6865 205b 582c  isize2 = The [X,
-00009280: 595d 2073 697a 6520 6f66 2074 6865 2069  Y] size of the i
-00009290: 6e73 6964 6520 6f66 2074 6865 2074 6f70  nside of the top
-000092a0: 206f 6620 7468 6520 7265 6374 616e 6775   of the rectangu
-000092b0: 6c61 7220 7475 6265 2e0a 2f2f 2020 2072  lar tube..//   r
-000092c0: 6f75 6e64 696e 6720 3d20 5468 6520 726f  ounding = The ro
-000092d0: 756e 646f 7665 7220 7261 6469 7573 2066  undover radius f
-000092e0: 6f72 2074 6865 206f 7574 7369 6465 2065  or the outside e
-000092f0: 6467 6573 206f 6620 7468 6520 7265 6374  dges of the rect
-00009300: 616e 6775 6c61 7220 7475 6265 2e0a 2f2f  angular tube..//
-00009310: 2020 2072 6f75 6e64 696e 6731 203d 2054     rounding1 = T
-00009320: 6865 2072 6f75 6e64 6f76 6572 2072 6164  he roundover rad
-00009330: 6975 7320 666f 7220 7468 6520 6f75 7473  ius for the outs
-00009340: 6964 6520 626f 7474 6f6d 2063 6f72 6e65  ide bottom corne
-00009350: 7220 6f66 2074 6865 2072 6563 7461 6e67  r of the rectang
-00009360: 756c 6172 2074 7562 652e 0a2f 2f20 2020  ular tube..//   
-00009370: 726f 756e 6469 6e67 3220 3d20 5468 6520  rounding2 = The 
-00009380: 726f 756e 646f 7665 7220 7261 6469 7573  roundover radius
-00009390: 2066 6f72 2074 6865 206f 7574 7369 6465   for the outside
-000093a0: 2074 6f70 2063 6f72 6e65 7220 6f66 2074   top corner of t
-000093b0: 6865 2072 6563 7461 6e67 756c 6172 2074  he rectangular t
-000093c0: 7562 652e 0a2f 2f20 2020 6368 616d 6665  ube..//   chamfe
-000093d0: 7220 3d20 5468 6520 6368 616d 6665 7220  r = The chamfer 
-000093e0: 7369 7a65 2066 6f72 2074 6865 206f 7574  size for the out
-000093f0: 7369 6465 2065 6467 6573 206f 6620 7468  side edges of th
-00009400: 6520 7265 6374 616e 6775 6c61 7220 7475  e rectangular tu
-00009410: 6265 2e0a 2f2f 2020 2063 6861 6d66 6572  be..//   chamfer
-00009420: 3120 3d20 5468 6520 6368 616d 6665 7220  1 = The chamfer 
-00009430: 7369 7a65 2066 6f72 2074 6865 206f 7574  size for the out
-00009440: 7369 6465 2062 6f74 746f 6d20 636f 726e  side bottom corn
-00009450: 6572 206f 6620 7468 6520 7265 6374 616e  er of the rectan
-00009460: 6775 6c61 7220 7475 6265 2e0a 2f2f 2020  gular tube..//  
-00009470: 2063 6861 6d66 6572 3220 3d20 5468 6520   chamfer2 = The 
-00009480: 6368 616d 6665 7220 7369 7a65 2066 6f72  chamfer size for
-00009490: 2074 6865 206f 7574 7369 6465 2074 6f70   the outside top
-000094a0: 2063 6f72 6e65 7220 6f66 2074 6865 2072   corner of the r
-000094b0: 6563 7461 6e67 756c 6172 2074 7562 652e  ectangular tube.
-000094c0: 0a2f 2f20 2020 6972 6f75 6e64 696e 6720  .//   irounding 
-000094d0: 3d20 5468 6520 726f 756e 646f 7665 7220  = The roundover 
-000094e0: 7261 6469 7573 2066 6f72 2074 6865 2069  radius for the i
-000094f0: 6e73 6964 6520 6564 6765 7320 6f66 2074  nside edges of t
-00009500: 6865 2072 6563 7461 6e67 756c 6172 2074  he rectangular t
-00009510: 7562 652e 2044 6566 6175 6c74 3a20 5361  ube. Default: Sa
-00009520: 6d65 2061 7320 6072 6f75 6e64 696e 6760  me as `rounding`
-00009530: 0a2f 2f20 2020 6972 6f75 6e64 696e 6731  .//   irounding1
-00009540: 203d 2054 6865 2072 6f75 6e64 6f76 6572   = The roundover
-00009550: 2072 6164 6975 7320 666f 7220 7468 6520   radius for the 
-00009560: 696e 7369 6465 2062 6f74 746f 6d20 636f  inside bottom co
-00009570: 726e 6572 206f 6620 7468 6520 7265 6374  rner of the rect
-00009580: 616e 6775 6c61 7220 7475 6265 2e0a 2f2f  angular tube..//
-00009590: 2020 2069 726f 756e 6469 6e67 3220 3d20     irounding2 = 
-000095a0: 5468 6520 726f 756e 646f 7665 7220 7261  The roundover ra
-000095b0: 6469 7573 2066 6f72 2074 6865 2069 6e73  dius for the ins
-000095c0: 6964 6520 746f 7020 636f 726e 6572 206f  ide top corner o
-000095d0: 6620 7468 6520 7265 6374 616e 6775 6c61  f the rectangula
-000095e0: 7220 7475 6265 2e0a 2f2f 2020 2069 6368  r tube..//   ich
-000095f0: 616d 6665 7220 3d20 5468 6520 6368 616d  amfer = The cham
-00009600: 6665 7220 7369 7a65 2066 6f72 2074 6865  fer size for the
-00009610: 2069 6e73 6964 6520 6564 6765 7320 6f66   inside edges of
-00009620: 2074 6865 2072 6563 7461 6e67 756c 6172   the rectangular
-00009630: 2074 7562 652e 2020 4465 6661 756c 743a   tube.  Default:
-00009640: 2053 616d 6520 6173 2060 6368 616d 6665   Same as `chamfe
-00009650: 7260 0a2f 2f20 2020 6963 6861 6d66 6572  r`.//   ichamfer
-00009660: 3120 3d20 5468 6520 6368 616d 6665 7220  1 = The chamfer 
-00009670: 7369 7a65 2066 6f72 2074 6865 2069 6e73  size for the ins
-00009680: 6964 6520 626f 7474 6f6d 2063 6f72 6e65  ide bottom corne
-00009690: 7220 6f66 2074 6865 2072 6563 7461 6e67  r of the rectang
-000096a0: 756c 6172 2074 7562 652e 0a2f 2f20 2020  ular tube..//   
-000096b0: 6963 6861 6d66 6572 3220 3d20 5468 6520  ichamfer2 = The 
-000096c0: 6368 616d 6665 7220 7369 7a65 2066 6f72  chamfer size for
-000096d0: 2074 6865 2069 6e73 6964 6520 746f 7020   the inside top 
-000096e0: 636f 726e 6572 206f 6620 7468 6520 7265  corner of the re
-000096f0: 6374 616e 6775 6c61 7220 7475 6265 2e0a  ctangular tube..
-00009700: 2f2f 2020 2061 6e63 686f 7220 3d20 5472  //   anchor = Tr
-00009710: 616e 736c 6174 6520 736f 2061 6e63 686f  anslate so ancho
-00009720: 7220 706f 696e 7420 6973 2061 7420 6f72  r point is at or
-00009730: 6967 696e 2028 302c 302c 3029 2e20 2053  igin (0,0,0).  S
-00009740: 6565 205b 616e 6368 6f72 5d28 6174 7461  ee [anchor](atta
-00009750: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
-00009760: 7365 6374 696f 6e2d 616e 6368 6f72 292e  section-anchor).
-00009770: 2020 4465 6661 756c 743a 2060 424f 5454    Default: `BOTT
-00009780: 4f4d 600a 2f2f 2020 2073 7069 6e20 3d20  OM`.//   spin = 
-00009790: 526f 7461 7465 2074 6869 7320 6d61 6e79  Rotate this many
-000097a0: 2064 6567 7265 6573 2061 726f 756e 6420   degrees around 
-000097b0: 7468 6520 5a20 6178 6973 2061 6674 6572  the Z axis after
-000097c0: 2061 6e63 686f 722e 2020 5365 6520 5b73   anchor.  See [s
-000097d0: 7069 6e5d 2861 7474 6163 686d 656e 7473  pin](attachments
-000097e0: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
-000097f0: 2d73 7069 6e29 2e20 2044 6566 6175 6c74  -spin).  Default
-00009800: 3a20 6030 600a 2f2f 2020 206f 7269 656e  : `0`.//   orien
-00009810: 7420 3d20 5665 6374 6f72 2074 6f20 726f  t = Vector to ro
-00009820: 7461 7465 2074 6f70 2074 6f77 6172 6473  tate top towards
-00009830: 2c20 6166 7465 7220 7370 696e 2e20 2053  , after spin.  S
-00009840: 6565 205b 6f72 6965 6e74 5d28 6174 7461  ee [orient](atta
-00009850: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
-00009860: 7365 6374 696f 6e2d 6f72 6965 6e74 292e  section-orient).
-00009870: 2020 4465 6661 756c 743a 2060 5550 600a    Default: `UP`.
-00009880: 2f2f 2045 7861 6d70 6c65 733a 0a2f 2f20  // Examples:.// 
-00009890: 2020 7265 6374 5f74 7562 6528 7369 7a65    rect_tube(size
-000098a0: 3d35 302c 2077 616c 6c3d 352c 2068 3d33  =50, wall=5, h=3
-000098b0: 3029 3b0a 2f2f 2020 2072 6563 745f 7475  0);.//   rect_tu
-000098c0: 6265 2873 697a 653d 5b31 3030 2c36 305d  be(size=[100,60]
-000098d0: 2c20 7761 6c6c 3d35 2c20 683d 3330 293b  , wall=5, h=30);
-000098e0: 0a2f 2f20 2020 7265 6374 5f74 7562 6528  .//   rect_tube(
-000098f0: 6973 697a 653d 5b36 302c 3830 5d2c 2077  isize=[60,80], w
-00009900: 616c 6c3d 352c 2068 3d33 3029 3b0a 2f2f  all=5, h=30);.//
-00009910: 2020 2072 6563 745f 7475 6265 2873 697a     rect_tube(siz
-00009920: 653d 5b31 3030 2c36 305d 2c20 6973 697a  e=[100,60], isiz
-00009930: 653d 5b39 302c 3530 5d2c 2068 3d33 3029  e=[90,50], h=30)
-00009940: 3b0a 2f2f 2020 2072 6563 745f 7475 6265  ;.//   rect_tube
-00009950: 2873 697a 6531 3d5b 3130 302c 3630 5d2c  (size1=[100,60],
-00009960: 2073 697a 6532 3d5b 3730 2c34 305d 2c20   size2=[70,40], 
-00009970: 7761 6c6c 3d35 2c20 683d 3330 293b 0a2f  wall=5, h=30);./
-00009980: 2f20 4578 616d 706c 653a 0a2f 2f20 2020  / Example:.//   
-00009990: 7265 6374 5f74 7562 6528 0a2f 2f20 2020  rect_tube(.//   
-000099a0: 2020 2020 7369 7a65 313d 5b31 3030 2c36      size1=[100,6
-000099b0: 305d 2c20 7369 7a65 323d 5b37 302c 3430  0], size2=[70,40
-000099c0: 5d2c 0a2f 2f20 2020 2020 2020 6973 697a  ],.//       isiz
-000099d0: 6531 3d5b 3430 2c32 305d 2c20 6973 697a  e1=[40,20], isiz
-000099e0: 6532 3d5b 3635 2c33 355d 2c20 683d 3135  e2=[65,35], h=15
-000099f0: 0a2f 2f20 2020 293b 0a2f 2f20 4578 616d  .//   );.// Exam
-00009a00: 706c 653a 204f 7574 6572 2052 6f75 6e64  ple: Outer Round
-00009a10: 696e 6720 4f6e 6c79 0a2f 2f20 2020 7265  ing Only.//   re
-00009a20: 6374 5f74 7562 6528 7369 7a65 3d31 3030  ct_tube(size=100
-00009a30: 2c20 7761 6c6c 3d35 2c20 726f 756e 6469  , wall=5, roundi
-00009a40: 6e67 3d31 302c 2069 726f 756e 6469 6e67  ng=10, irounding
-00009a50: 3d30 2c20 683d 3330 293b 0a2f 2f20 4578  =0, h=30);.// Ex
-00009a60: 616d 706c 653a 204f 7574 6572 2043 6861  ample: Outer Cha
-00009a70: 6d66 6572 204f 6e6c 790a 2f2f 2020 2072  mfer Only.//   r
-00009a80: 6563 745f 7475 6265 2873 697a 653d 3130  ect_tube(size=10
-00009a90: 302c 2077 616c 6c3d 352c 2063 6861 6d66  0, wall=5, chamf
-00009aa0: 6572 3d35 2c20 6963 6861 6d66 6572 3d30  er=5, ichamfer=0
-00009ab0: 2c20 683d 3330 293b 0a2f 2f20 4578 616d  , h=30);.// Exam
-00009ac0: 706c 653a 204f 7574 6572 2052 6f75 6e64  ple: Outer Round
-00009ad0: 696e 672c 2049 6e6e 6572 2043 6861 6d66  ing, Inner Chamf
-00009ae0: 6572 0a2f 2f20 2020 7265 6374 5f74 7562  er.//   rect_tub
-00009af0: 6528 7369 7a65 3d31 3030 2c20 7761 6c6c  e(size=100, wall
-00009b00: 3d35 2c20 726f 756e 6469 6e67 3d31 302c  =5, rounding=10,
-00009b10: 2069 6368 616d 6665 723d 382c 2068 3d33   ichamfer=8, h=3
-00009b20: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
-00009b30: 496e 6e65 7220 526f 756e 6469 6e67 2c20  Inner Rounding, 
-00009b40: 4f75 7465 7220 4368 616d 6665 720a 2f2f  Outer Chamfer.//
-00009b50: 2020 2072 6563 745f 7475 6265 2873 697a     rect_tube(siz
-00009b60: 653d 3130 302c 2077 616c 6c3d 352c 2063  e=100, wall=5, c
-00009b70: 6861 6d66 6572 3d31 302c 2069 726f 756e  hamfer=10, iroun
-00009b80: 6469 6e67 3d38 2c20 683d 3330 293b 0a2f  ding=8, h=30);./
-00009b90: 2f20 4578 616d 706c 653a 2047 7261 6469  / Example: Gradi
-00009ba0: 616e 7420 526f 756e 6469 6e67 0a2f 2f20  ant Rounding.// 
-00009bb0: 2020 7265 6374 5f74 7562 6528 0a2f 2f20    rect_tube(.// 
-00009bc0: 2020 2020 2020 7369 7a65 313d 3130 302c        size1=100,
-00009bd0: 2073 697a 6532 3d38 302c 2077 616c 6c3d   size2=80, wall=
-00009be0: 352c 2068 3d33 302c 0a2f 2f20 2020 2020  5, h=30,.//     
-00009bf0: 2020 726f 756e 6469 6e67 313d 3130 2c20    rounding1=10, 
-00009c00: 726f 756e 6469 6e67 323d 302c 0a2f 2f20  rounding2=0,.// 
-00009c10: 2020 2020 2020 6972 6f75 6e64 696e 6731        irounding1
-00009c20: 3d38 2c20 6972 6f75 6e64 696e 6732 3d30  =8, irounding2=0
-00009c30: 0a2f 2f20 2020 293b 0a2f 2f20 4578 616d  .//   );.// Exam
-00009c40: 706c 653a 2050 6572 2043 6f72 6e65 7220  ple: Per Corner 
-00009c50: 526f 756e 6469 6e67 0a2f 2f20 2020 7265  Rounding.//   re
-00009c60: 6374 5f74 7562 6528 0a2f 2f20 2020 2020  ct_tube(.//     
-00009c70: 2020 7369 7a65 3d31 3030 2c20 7761 6c6c    size=100, wall
-00009c80: 3d31 302c 2068 3d33 302c 0a2f 2f20 2020  =10, h=30,.//   
-00009c90: 2020 2020 726f 756e 6469 6e67 3d5b 302c      rounding=[0,
-00009ca0: 352c 3130 2c31 355d 2c20 6972 6f75 6e64  5,10,15], iround
-00009cb0: 696e 673d 300a 2f2f 2020 2029 3b0a 2f2f  ing=0.//   );.//
-00009cc0: 2045 7861 6d70 6c65 3a20 5065 7220 436f   Example: Per Co
-00009cd0: 726e 6572 2043 6861 6d66 6572 0a2f 2f20  rner Chamfer.// 
-00009ce0: 2020 7265 6374 5f74 7562 6528 0a2f 2f20    rect_tube(.// 
-00009cf0: 2020 2020 2020 7369 7a65 3d31 3030 2c20        size=100, 
-00009d00: 7761 6c6c 3d31 302c 2068 3d33 302c 0a2f  wall=10, h=30,./
-00009d10: 2f20 2020 2020 2020 6368 616d 6665 723d  /       chamfer=
-00009d20: 5b30 2c35 2c31 302c 3135 5d2c 2069 6368  [0,5,10,15], ich
-00009d30: 616d 6665 723d 300a 2f2f 2020 2029 3b0a  amfer=0.//   );.
-00009d40: 2f2f 2045 7861 6d70 6c65 3a20 4d69 7869  // Example: Mixi
-00009d50: 6e67 2043 6861 6d66 6572 2061 6e64 2052  ng Chamfer and R
-00009d60: 6f75 6e64 696e 670a 2f2f 2020 2072 6563  ounding.//   rec
-00009d70: 745f 7475 6265 280a 2f2f 2020 2020 2020  t_tube(.//      
-00009d80: 2073 697a 653d 3130 302c 2077 616c 6c3d   size=100, wall=
-00009d90: 3130 2c20 683d 3330 2c0a 2f2f 2020 2020  10, h=30,.//    
-00009da0: 2020 2063 6861 6d66 6572 3d5b 302c 352c     chamfer=[0,5,
-00009db0: 302c 3130 5d2c 2069 6368 616d 6665 723d  0,10], ichamfer=
-00009dc0: 302c 0a2f 2f20 2020 2020 2020 726f 756e  0,.//       roun
-00009dd0: 6469 6e67 3d5b 352c 302c 3130 2c30 5d2c  ding=[5,0,10,0],
-00009de0: 2069 726f 756e 6469 6e67 3d30 0a2f 2f20   irounding=0.// 
-00009df0: 2020 293b 0a2f 2f20 4578 616d 706c 653a    );.// Example:
-00009e00: 2052 6561 6c6c 7920 4d69 7869 6e67 2049   Really Mixing I
-00009e10: 7420 5570 0a2f 2f20 2020 7265 6374 5f74  t Up.//   rect_t
-00009e20: 7562 6528 0a2f 2f20 2020 2020 2020 7369  ube(.//       si
-00009e30: 7a65 313d 5b31 3030 2c38 305d 2c20 7369  ze1=[100,80], si
-00009e40: 7a65 323d 5b38 302c 3630 5d2c 0a2f 2f20  ze2=[80,60],.// 
-00009e50: 2020 2020 2020 6973 697a 6531 3d5b 3530        isize1=[50
-00009e60: 2c33 305d 2c20 6973 697a 6532 3d5b 3730  ,30], isize2=[70
-00009e70: 2c35 305d 2c20 683d 3230 2c0a 2f2f 2020  ,50], h=20,.//  
-00009e80: 2020 2020 2063 6861 6d66 6572 313d 5b30       chamfer1=[0
-00009e90: 2c35 2c30 2c31 305d 2c20 6963 6861 6d66  ,5,0,10], ichamf
-00009ea0: 6572 313d 5b30 2c33 2c30 2c38 5d2c 0a2f  er1=[0,3,0,8],./
-00009eb0: 2f20 2020 2020 2020 6368 616d 6665 7232  /       chamfer2
-00009ec0: 3d5b 352c 302c 3130 2c30 5d2c 2069 6368  =[5,0,10,0], ich
-00009ed0: 616d 6665 7232 3d5b 332c 302c 382c 305d  amfer2=[3,0,8,0]
-00009ee0: 2c0a 2f2f 2020 2020 2020 2072 6f75 6e64  ,.//       round
-00009ef0: 696e 6731 3d5b 352c 302c 3130 2c30 5d2c  ing1=[5,0,10,0],
-00009f00: 2069 726f 756e 6469 6e67 313d 5b33 2c30   irounding1=[3,0
-00009f10: 2c38 2c30 5d2c 0a2f 2f20 2020 2020 2020  ,8,0],.//       
-00009f20: 726f 756e 6469 6e67 323d 5b30 2c35 2c30  rounding2=[0,5,0
-00009f30: 2c31 305d 2c20 6972 6f75 6e64 696e 6732  ,10], irounding2
-00009f40: 3d5b 302c 332c 302c 385d 0a2f 2f20 2020  =[0,3,0,8].//   
-00009f50: 293b 0a6d 6f64 756c 6520 7265 6374 5f74  );.module rect_t
-00009f60: 7562 6528 0a20 2020 2068 2c20 7369 7a65  ube(.    h, size
-00009f70: 2c20 6973 697a 652c 2063 656e 7465 722c  , isize, center,
-00009f80: 2073 6869 6674 3d5b 302c 305d 2c0a 2020   shift=[0,0],.  
-00009f90: 2020 7761 6c6c 2c20 7369 7a65 312c 2073    wall, size1, s
-00009fa0: 697a 6532 2c20 6973 697a 6531 2c20 6973  ize2, isize1, is
-00009fb0: 697a 6532 2c0a 2020 2020 726f 756e 6469  ize2,.    roundi
-00009fc0: 6e67 3d30 2c20 726f 756e 6469 6e67 312c  ng=0, rounding1,
-00009fd0: 2072 6f75 6e64 696e 6732 2c0a 2020 2020   rounding2,.    
-00009fe0: 6972 6f75 6e64 696e 673d 302c 2069 726f  irounding=0, iro
-00009ff0: 756e 6469 6e67 312c 2069 726f 756e 6469  unding1, iroundi
-0000a000: 6e67 322c 0a20 2020 2063 6861 6d66 6572  ng2,.    chamfer
-0000a010: 3d30 2c20 6368 616d 6665 7231 2c20 6368  =0, chamfer1, ch
-0000a020: 616d 6665 7232 2c0a 2020 2020 6963 6861  amfer2,.    icha
-0000a030: 6d66 6572 3d30 2c20 6963 6861 6d66 6572  mfer=0, ichamfer
-0000a040: 312c 2069 6368 616d 6665 7232 2c0a 2020  1, ichamfer2,.  
-0000a050: 2020 616e 6368 6f72 2c20 7370 696e 3d30    anchor, spin=0
-0000a060: 2c20 6f72 6965 6e74 3d55 502c 0a20 2020  , orient=UP,.   
-0000a070: 206c 0a29 207b 0a20 2020 2068 203d 206f   l.) {.    h = o
-0000a080: 6e65 5f64 6566 696e 6564 285b 682c 6c5d  ne_defined([h,l]
-0000a090: 2c22 682c 6c22 293b 0a20 2020 2063 6865  ,"h,l");.    che
-0000a0a0: 636b 7320 3d0a 2020 2020 2020 2020 6173  cks =.        as
-0000a0b0: 7365 7274 2869 735f 6e75 6d28 6829 2c20  sert(is_num(h), 
-0000a0c0: 226c 206f 7220 6820 6172 6775 6d65 6e74  "l or h argument
-0000a0d0: 2072 6571 7569 7265 642e 2229 0a20 2020   required.").   
-0000a0e0: 2020 2020 2061 7373 6572 7428 6973 5f76       assert(is_v
-0000a0f0: 6563 746f 7228 7368 6966 742c 3229 293b  ector(shift,2));
-0000a100: 0a20 2020 2073 3120 3d20 6973 5f6e 756d  .    s1 = is_num
-0000a110: 2873 697a 6531 293f 205b 7369 7a65 312c  (size1)? [size1,
-0000a120: 2073 697a 6531 5d20 3a0a 2020 2020 2020   size1] :.      
-0000a130: 2020 6973 5f76 6563 746f 7228 7369 7a65    is_vector(size
-0000a140: 312c 3229 3f20 7369 7a65 3120 3a0a 2020  1,2)? size1 :.  
-0000a150: 2020 2020 2020 6973 5f6e 756d 2873 697a        is_num(siz
-0000a160: 6529 3f20 5b73 697a 652c 2073 697a 655d  e)? [size, size]
-0000a170: 203a 0a20 2020 2020 2020 2069 735f 7665   :.        is_ve
-0000a180: 6374 6f72 2873 697a 652c 3229 3f20 7369  ctor(size,2)? si
-0000a190: 7a65 203a 0a20 2020 2020 2020 2075 6e64  ze :.        und
-0000a1a0: 6566 3b0a 2020 2020 7332 203d 2069 735f  ef;.    s2 = is_
-0000a1b0: 6e75 6d28 7369 7a65 3229 3f20 5b73 697a  num(size2)? [siz
-0000a1c0: 6532 2c20 7369 7a65 325d 203a 0a20 2020  e2, size2] :.   
-0000a1d0: 2020 2020 2069 735f 7665 6374 6f72 2873       is_vector(s
-0000a1e0: 697a 6532 2c32 293f 2073 697a 6532 203a  ize2,2)? size2 :
-0000a1f0: 0a20 2020 2020 2020 2069 735f 6e75 6d28  .        is_num(
-0000a200: 7369 7a65 293f 205b 7369 7a65 2c20 7369  size)? [size, si
-0000a210: 7a65 5d20 3a0a 2020 2020 2020 2020 6973  ze] :.        is
-0000a220: 5f76 6563 746f 7228 7369 7a65 2c32 293f  _vector(size,2)?
-0000a230: 2073 697a 6520 3a0a 2020 2020 2020 2020   size :.        
-0000a240: 756e 6465 663b 0a20 2020 2069 7331 203d  undef;.    is1 =
-0000a250: 2069 735f 6e75 6d28 6973 697a 6531 293f   is_num(isize1)?
-0000a260: 205b 6973 697a 6531 2c20 6973 697a 6531   [isize1, isize1
-0000a270: 5d20 3a0a 2020 2020 2020 2020 6973 5f76  ] :.        is_v
-0000a280: 6563 746f 7228 6973 697a 6531 2c32 293f  ector(isize1,2)?
-0000a290: 2069 7369 7a65 3120 3a0a 2020 2020 2020   isize1 :.      
-0000a2a0: 2020 6973 5f6e 756d 2869 7369 7a65 293f    is_num(isize)?
-0000a2b0: 205b 6973 697a 652c 2069 7369 7a65 5d20   [isize, isize] 
-0000a2c0: 3a0a 2020 2020 2020 2020 6973 5f76 6563  :.        is_vec
-0000a2d0: 746f 7228 6973 697a 652c 3229 3f20 6973  tor(isize,2)? is
-0000a2e0: 697a 6520 3a0a 2020 2020 2020 2020 756e  ize :.        un
-0000a2f0: 6465 663b 0a20 2020 2069 7332 203d 2069  def;.    is2 = i
-0000a300: 735f 6e75 6d28 6973 697a 6532 293f 205b  s_num(isize2)? [
-0000a310: 6973 697a 6532 2c20 6973 697a 6532 5d20  isize2, isize2] 
-0000a320: 3a0a 2020 2020 2020 2020 6973 5f76 6563  :.        is_vec
-0000a330: 746f 7228 6973 697a 6532 2c32 293f 2069  tor(isize2,2)? i
-0000a340: 7369 7a65 3220 3a0a 2020 2020 2020 2020  size2 :.        
-0000a350: 6973 5f6e 756d 2869 7369 7a65 293f 205b  is_num(isize)? [
-0000a360: 6973 697a 652c 2069 7369 7a65 5d20 3a0a  isize, isize] :.
-0000a370: 2020 2020 2020 2020 6973 5f76 6563 746f          is_vecto
-0000a380: 7228 6973 697a 652c 3229 3f20 6973 697a  r(isize,2)? isiz
-0000a390: 6520 3a0a 2020 2020 2020 2020 756e 6465  e :.        unde
-0000a3a0: 663b 0a20 2020 2073 697a 6531 203d 2069  f;.    size1 = i
-0000a3b0: 735f 6465 6628 7331 293f 2073 3120 3a0a  s_def(s1)? s1 :.
-0000a3c0: 2020 2020 2020 2020 2869 735f 6465 6628          (is_def(
-0000a3d0: 7761 6c6c 2920 2626 2069 735f 6465 6628  wall) && is_def(
-0000a3e0: 6973 3129 293f 2028 6973 312b 322a 5b77  is1))? (is1+2*[w
-0000a3f0: 616c 6c2c 7761 6c6c 5d29 203a 0a20 2020  all,wall]) :.   
-0000a400: 2020 2020 2075 6e64 6566 3b0a 2020 2020       undef;.    
-0000a410: 7369 7a65 3220 3d20 6973 5f64 6566 2873  size2 = is_def(s
-0000a420: 3229 3f20 7332 203a 0a20 2020 2020 2020  2)? s2 :.       
-0000a430: 2028 6973 5f64 6566 2877 616c 6c29 2026   (is_def(wall) &
-0000a440: 2620 6973 5f64 6566 2869 7332 2929 3f20  & is_def(is2))? 
-0000a450: 2869 7332 2b32 2a5b 7761 6c6c 2c77 616c  (is2+2*[wall,wal
-0000a460: 6c5d 2920 3a0a 2020 2020 2020 2020 756e  l]) :.        un
-0000a470: 6465 663b 0a20 2020 2069 7369 7a65 3120  def;.    isize1 
-0000a480: 3d20 6973 5f64 6566 2869 7331 293f 2069  = is_def(is1)? i
-0000a490: 7331 203a 0a20 2020 2020 2020 2028 6973  s1 :.        (is
-0000a4a0: 5f64 6566 2877 616c 6c29 2026 2620 6973  _def(wall) && is
-0000a4b0: 5f64 6566 2873 3129 293f 2028 7331 2d32  _def(s1))? (s1-2
-0000a4c0: 2a5b 7761 6c6c 2c77 616c 6c5d 2920 3a0a  *[wall,wall]) :.
-0000a4d0: 2020 2020 2020 2020 756e 6465 663b 0a20          undef;. 
-0000a4e0: 2020 2069 7369 7a65 3220 3d20 6973 5f64     isize2 = is_d
-0000a4f0: 6566 2869 7332 293f 2069 7332 203a 0a20  ef(is2)? is2 :. 
-0000a500: 2020 2020 2020 2028 6973 5f64 6566 2877         (is_def(w
-0000a510: 616c 6c29 2026 2620 6973 5f64 6566 2873  all) && is_def(s
-0000a520: 3229 293f 2028 7332 2d32 2a5b 7761 6c6c  2))? (s2-2*[wall
-0000a530: 2c77 616c 6c5d 2920 3a0a 2020 2020 2020  ,wall]) :.      
-0000a540: 2020 756e 6465 663b 0a20 2020 2063 6865    undef;.    che
-0000a550: 636b 7332 203d 200a 2020 2020 2020 2020  cks2 = .        
-0000a560: 6173 7365 7274 2877 616c 6c3d 3d75 6e64  assert(wall==und
-0000a570: 6566 207c 7c20 6973 5f6e 756d 2877 616c  ef || is_num(wal
-0000a580: 6c29 290a 2020 2020 2020 2020 6173 7365  l)).        asse
-0000a590: 7274 2873 697a 6531 213d 756e 6465 662c  rt(size1!=undef,
-0000a5a0: 2022 4261 6420 7369 7a65 2f73 697a 6531   "Bad size/size1
-0000a5b0: 2061 7267 756d 656e 742e 2229 0a20 2020   argument.").   
-0000a5c0: 2020 2020 2061 7373 6572 7428 7369 7a65       assert(size
-0000a5d0: 3221 3d75 6e64 6566 2c20 2242 6164 2073  2!=undef, "Bad s
-0000a5e0: 697a 652f 7369 7a65 3220 6172 6775 6d65  ize/size2 argume
-0000a5f0: 6e74 2e22 290a 2020 2020 2020 2020 6173  nt.").        as
-0000a600: 7365 7274 2869 7369 7a65 3121 3d75 6e64  sert(isize1!=und
-0000a610: 6566 2c20 2242 6164 2069 7369 7a65 2f69  ef, "Bad isize/i
-0000a620: 7369 7a65 3120 6172 6775 6d65 6e74 2e22  size1 argument."
-0000a630: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
-0000a640: 2869 7369 7a65 3221 3d75 6e64 6566 2c20  (isize2!=undef, 
-0000a650: 2242 6164 2069 7369 7a65 2f69 7369 7a65  "Bad isize/isize
-0000a660: 3220 6172 6775 6d65 6e74 2e22 290a 2020  2 argument.").  
-0000a670: 2020 2020 2020 6173 7365 7274 2869 7369        assert(isi
-0000a680: 7a65 312e 7820 3c20 7369 7a65 312e 782c  ze1.x < size1.x,
-0000a690: 2022 496e 6e65 7220 7369 7a65 2069 7320   "Inner size is 
-0000a6a0: 6c61 7267 6572 2074 6861 6e20 6f75 7465  larger than oute
-0000a6b0: 7220 7369 7a65 2e22 290a 2020 2020 2020  r size.").      
-0000a6c0: 2020 6173 7365 7274 2869 7369 7a65 312e    assert(isize1.
-0000a6d0: 7920 3c20 7369 7a65 312e 792c 2022 496e  y < size1.y, "In
-0000a6e0: 6e65 7220 7369 7a65 2069 7320 6c61 7267  ner size is larg
-0000a6f0: 6572 2074 6861 6e20 6f75 7465 7220 7369  er than outer si
-0000a700: 7a65 2e22 290a 2020 2020 2020 2020 6173  ze.").        as
-0000a710: 7365 7274 2869 7369 7a65 322e 7820 3c20  sert(isize2.x < 
-0000a720: 7369 7a65 322e 782c 2022 496e 6e65 7220  size2.x, "Inner 
-0000a730: 7369 7a65 2069 7320 6c61 7267 6572 2074  size is larger t
-0000a740: 6861 6e20 6f75 7465 7220 7369 7a65 2e22  han outer size."
-0000a750: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
-0000a760: 2869 7369 7a65 322e 7920 3c20 7369 7a65  (isize2.y < size
-0000a770: 322e 792c 2022 496e 6e65 7220 7369 7a65  2.y, "Inner size
-0000a780: 2069 7320 6c61 7267 6572 2074 6861 6e20   is larger than 
-0000a790: 6f75 7465 7220 7369 7a65 2e22 293b 0a20  outer size.");. 
-0000a7a0: 2020 2061 6e63 686f 7220 3d20 6765 745f     anchor = get_
-0000a7b0: 616e 6368 6f72 2861 6e63 686f 722c 2063  anchor(anchor, c
-0000a7c0: 656e 7465 722c 2042 4f54 2c20 424f 5429  enter, BOT, BOT)
-0000a7d0: 3b0a 2020 2020 6174 7461 6368 6162 6c65  ;.    attachable
-0000a7e0: 2861 6e63 686f 722c 7370 696e 2c6f 7269  (anchor,spin,ori
-0000a7f0: 656e 742c 2073 697a 653d 5b65 6163 6820  ent, size=[each 
-0000a800: 7369 7a65 312c 2068 5d2c 2073 697a 6532  size1, h], size2
-0000a810: 3d73 697a 6532 2c20 7368 6966 743d 7368  =size2, shift=sh
-0000a820: 6966 7429 207b 0a20 2020 2020 2020 2064  ift) {.        d
-0000a830: 6966 6628 225f 485f 6f5f 4c5f 655f 2229  iff("_H_o_L_e_")
-0000a840: 0a20 2020 2020 2020 2070 7269 736d 6f69  .        prismoi
-0000a850: 6428 0a20 2020 2020 2020 2020 2020 2073  d(.            s
-0000a860: 697a 6531 2c20 7369 7a65 322c 2068 3d68  ize1, size2, h=h
-0000a870: 2c20 7368 6966 743d 7368 6966 742c 0a20  , shift=shift,. 
-0000a880: 2020 2020 2020 2020 2020 2072 6f75 6e64             round
-0000a890: 696e 673d 726f 756e 6469 6e67 2c20 726f  ing=rounding, ro
-0000a8a0: 756e 6469 6e67 313d 726f 756e 6469 6e67  unding1=rounding
-0000a8b0: 312c 2072 6f75 6e64 696e 6732 3d72 6f75  1, rounding2=rou
-0000a8c0: 6e64 696e 6732 2c0a 2020 2020 2020 2020  nding2,.        
-0000a8d0: 2020 2020 6368 616d 6665 723d 6368 616d      chamfer=cham
-0000a8e0: 6665 722c 2063 6861 6d66 6572 313d 6368  fer, chamfer1=ch
-0000a8f0: 616d 6665 7231 2c20 6368 616d 6665 7232  amfer1, chamfer2
-0000a900: 3d63 6861 6d66 6572 322c 0a20 2020 2020  =chamfer2,.     
-0000a910: 2020 2020 2020 2061 6e63 686f 723d 4354         anchor=CT
-0000a920: 520a 2020 2020 2020 2020 2920 7b0a 2020  R.        ) {.  
-0000a930: 2020 2020 2020 2020 2020 6368 696c 6472            childr
-0000a940: 656e 2829 3b0a 2020 2020 2020 2020 2020  en();.          
-0000a950: 2020 7461 6728 225f 485f 6f5f 4c5f 655f    tag("_H_o_L_e_
-0000a960: 2229 2070 7269 736d 6f69 6428 0a20 2020  ") prismoid(.   
-0000a970: 2020 2020 2020 2020 2020 2020 2069 7369               isi
-0000a980: 7a65 312c 2069 7369 7a65 322c 2068 3d68  ze1, isize2, h=h
-0000a990: 2b30 2e30 352c 2073 6869 6674 3d73 6869  +0.05, shift=shi
-0000a9a0: 6674 2c0a 2020 2020 2020 2020 2020 2020  ft,.            
-0000a9b0: 2020 2020 726f 756e 6469 6e67 3d69 726f      rounding=iro
-0000a9c0: 756e 6469 6e67 2c20 726f 756e 6469 6e67  unding, rounding
-0000a9d0: 313d 6972 6f75 6e64 696e 6731 2c20 726f  1=irounding1, ro
-0000a9e0: 756e 6469 6e67 323d 6972 6f75 6e64 696e  unding2=iroundin
-0000a9f0: 6732 2c0a 2020 2020 2020 2020 2020 2020  g2,.            
-0000aa00: 2020 2020 6368 616d 6665 723d 6963 6861      chamfer=icha
-0000aa10: 6d66 6572 2c20 6368 616d 6665 7231 3d69  mfer, chamfer1=i
-0000aa20: 6368 616d 6665 7231 2c20 6368 616d 6665  chamfer1, chamfe
-0000aa30: 7232 3d69 6368 616d 6665 7232 2c0a 2020  r2=ichamfer2,.  
-0000aa40: 2020 2020 2020 2020 2020 2020 2020 616e                an
-0000aa50: 6368 6f72 3d43 5452 0a20 2020 2020 2020  chor=CTR.       
-0000aa60: 2020 2020 2029 3b0a 2020 2020 2020 2020       );.        
-0000aa70: 7d0a 2020 2020 2020 2020 6368 696c 6472  }.        childr
-0000aa80: 656e 2829 3b0a 2020 2020 7d0a 7d0a 0a66  en();.    }.}..f
-0000aa90: 756e 6374 696f 6e20 7265 6374 5f74 7562  unction rect_tub
-0000aaa0: 6528 0a20 2020 2068 2c20 7369 7a65 2c20  e(.    h, size, 
-0000aab0: 6973 697a 652c 2063 656e 7465 722c 2073  isize, center, s
-0000aac0: 6869 6674 3d5b 302c 305d 2c0a 2020 2020  hift=[0,0],.    
-0000aad0: 7761 6c6c 2c20 7369 7a65 312c 2073 697a  wall, size1, siz
-0000aae0: 6532 2c20 6973 697a 6531 2c20 6973 697a  e2, isize1, isiz
-0000aaf0: 6532 2c0a 2020 2020 726f 756e 6469 6e67  e2,.    rounding
-0000ab00: 3d30 2c20 726f 756e 6469 6e67 312c 2072  =0, rounding1, r
-0000ab10: 6f75 6e64 696e 6732 2c0a 2020 2020 6972  ounding2,.    ir
-0000ab20: 6f75 6e64 696e 673d 302c 2069 726f 756e  ounding=0, iroun
-0000ab30: 6469 6e67 312c 2069 726f 756e 6469 6e67  ding1, irounding
-0000ab40: 322c 0a20 2020 2063 6861 6d66 6572 3d30  2,.    chamfer=0
-0000ab50: 2c20 6368 616d 6665 7231 2c20 6368 616d  , chamfer1, cham
-0000ab60: 6665 7232 2c0a 2020 2020 6963 6861 6d66  fer2,.    ichamf
-0000ab70: 6572 3d30 2c20 6963 6861 6d66 6572 312c  er=0, ichamfer1,
-0000ab80: 2069 6368 616d 6665 7232 2c0a 2020 2020   ichamfer2,.    
-0000ab90: 616e 6368 6f72 2c20 7370 696e 3d30 2c20  anchor, spin=0, 
-0000aba0: 6f72 6965 6e74 3d55 502c 0a20 2020 206c  orient=UP,.    l
-0000abb0: 0a29 203d 206e 6f5f 6675 6e63 7469 6f6e  .) = no_function
-0000abc0: 2822 7265 6374 5f74 7562 6522 293b 0a0a  ("rect_tube");..
-0000abd0: 0a2f 2f20 4675 6e63 7469 6f6e 264d 6f64  .// Function&Mod
-0000abe0: 756c 653a 2077 6564 6765 2829 0a2f 2f0a  ule: wedge().//.
-0000abf0: 2f2f 2055 7361 6765 3a20 4173 204d 6f64  // Usage: As Mod
-0000ac00: 756c 650a 2f2f 2020 2077 6564 6765 2873  ule.//   wedge(s
-0000ac10: 697a 652c 205b 6365 6e74 6572 5d2c 202e  ize, [center], .
-0000ac20: 2e2e 2920 5b41 5454 4143 484d 454e 5453  ..) [ATTACHMENTS
-0000ac30: 5d3b 0a2f 2f20 5573 6167 653a 2041 7320  ];.// Usage: As 
-0000ac40: 4675 6e63 7469 6f6e 0a2f 2f20 2020 766e  Function.//   vn
-0000ac50: 6620 3d20 7765 6467 6528 7369 7a65 2c20  f = wedge(size, 
-0000ac60: 5b63 656e 7465 725d 2c20 2e2e 2e29 3b0a  [center], ...);.
-0000ac70: 2f2f 0a2f 2f20 4465 7363 7269 7074 696f  //.// Descriptio
-0000ac80: 6e3a 0a2f 2f20 2020 5768 656e 2063 616c  n:.//   When cal
-0000ac90: 6c65 6420 6173 2061 206d 6f64 756c 652c  led as a module,
-0000aca0: 2063 7265 6174 6573 2061 2033 4420 7472   creates a 3D tr
-0000acb0: 6961 6e67 756c 6172 2077 6564 6765 2077  iangular wedge w
-0000acc0: 6974 6820 7468 6520 6879 706f 7465 6e75  ith the hypotenu
-0000acd0: 7365 2069 6e20 7468 6520 582b 5a2b 2071  se in the X+Z+ q
-0000ace0: 7561 6472 616e 742e 0a2f 2f20 2020 5768  uadrant..//   Wh
-0000acf0: 656e 2063 616c 6c65 6420 6173 2061 2066  en called as a f
-0000ad00: 756e 6374 696f 6e2c 2063 7265 6174 6573  unction, creates
-0000ad10: 2061 2056 4e46 2066 6f72 2061 2033 4420   a VNF for a 3D 
-0000ad20: 7472 6961 6e67 756c 6172 2077 6564 6765  triangular wedge
-0000ad30: 2077 6974 6820 7468 6520 6879 706f 7465   with the hypote
-0000ad40: 6e75 7365 2069 6e20 7468 6520 582b 5a2b  nuse in the X+Z+
-0000ad50: 2071 7561 6472 616e 742e 0a2f 2f0a 2f2f   quadrant..//.//
-0000ad60: 2041 7267 756d 656e 7473 3a0a 2f2f 2020   Arguments:.//  
-0000ad70: 2073 697a 6520 3d20 5b77 6964 7468 2c20   size = [width, 
-0000ad80: 7468 6963 6b6e 6573 732c 2068 6569 6768  thickness, heigh
-0000ad90: 745d 0a2f 2f20 2020 6365 6e74 6572 203d  t].//   center =
-0000ada0: 2049 6620 6769 7665 6e2c 206f 7665 7272   If given, overr
-0000adb0: 6964 6573 2060 616e 6368 6f72 602e 2020  ides `anchor`.  
-0000adc0: 4120 7472 7565 2076 616c 7565 2073 6574  A true value set
-0000add0: 7320 6061 6e63 686f 723d 4345 4e54 4552  s `anchor=CENTER
-0000ade0: 602c 2066 616c 7365 2073 6574 7320 6061  `, false sets `a
-0000adf0: 6e63 686f 723d 5550 602e 0a2f 2f20 2020  nchor=UP`..//   
-0000ae00: 2d2d 2d0a 2f2f 2020 2061 6e63 686f 7220  ---.//   anchor 
-0000ae10: 3d20 5472 616e 736c 6174 6520 736f 2061  = Translate so a
-0000ae20: 6e63 686f 7220 706f 696e 7420 6973 2061  nchor point is a
-0000ae30: 7420 6f72 6967 696e 2028 302c 302c 3029  t origin (0,0,0)
-0000ae40: 2e20 2053 6565 205b 616e 6368 6f72 5d28  .  See [anchor](
-0000ae50: 6174 7461 6368 6d65 6e74 732e 7363 6164  attachments.scad
-0000ae60: 2373 7562 7365 6374 696f 6e2d 616e 6368  #subsection-anch
-0000ae70: 6f72 292e 2020 4465 6661 756c 743a 2060  or).  Default: `
-0000ae80: 4652 4f4e 542b 4c45 4654 2b42 4f54 544f  FRONT+LEFT+BOTTO
-0000ae90: 4d60 0a2f 2f20 2020 7370 696e 203d 2052  M`.//   spin = R
-0000aea0: 6f74 6174 6520 7468 6973 206d 616e 7920  otate this many 
-0000aeb0: 6465 6772 6565 7320 6172 6f75 6e64 2074  degrees around t
-0000aec0: 6865 205a 2061 7869 7320 6166 7465 7220  he Z axis after 
-0000aed0: 616e 6368 6f72 2e20 2053 6565 205b 7370  anchor.  See [sp
-0000aee0: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
-0000aef0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-0000af00: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
-0000af10: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
-0000af20: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
-0000af30: 6174 6520 746f 7020 746f 7761 7264 732c  ate top towards,
-0000af40: 2061 6674 6572 2073 7069 6e2e 2020 5365   after spin.  Se
-0000af50: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
-0000af60: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
-0000af70: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
-0000af80: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
-0000af90: 2f0a 2f2f 2045 7861 6d70 6c65 3a20 4365  /.// Example: Ce
-0000afa0: 6e74 6572 6564 0a2f 2f20 2020 7765 6467  ntered.//   wedg
-0000afb0: 6528 5b32 302c 2034 302c 2031 355d 2c20  e([20, 40, 15], 
-0000afc0: 6365 6e74 6572 3d74 7275 6529 3b0a 2f2f  center=true);.//
-0000afd0: 2045 7861 6d70 6c65 3a20 2a4e 6f6e 2a2d   Example: *Non*-
-0000afe0: 4365 6e74 6572 6564 0a2f 2f20 2020 7765  Centered.//   we
-0000aff0: 6467 6528 5b32 302c 2034 302c 2031 355d  dge([20, 40, 15]
-0000b000: 293b 0a2f 2f20 4578 616d 706c 653a 2053  );.// Example: S
-0000b010: 7461 6e64 6172 6420 436f 6e6e 6563 746f  tandard Connecto
-0000b020: 7273 0a2f 2f20 2020 7765 6467 6528 5b32  rs.//   wedge([2
-0000b030: 302c 2034 302c 2031 355d 2920 7368 6f77  0, 40, 15]) show
-0000b040: 5f61 6e63 686f 7273 2829 3b0a 6d6f 6475  _anchors();.modu
-0000b050: 6c65 2077 6564 6765 2873 697a 653d 5b31  le wedge(size=[1
-0000b060: 2c20 312c 2031 5d2c 2063 656e 7465 722c  , 1, 1], center,
-0000b070: 2061 6e63 686f 722c 2073 7069 6e3d 302c   anchor, spin=0,
-0000b080: 206f 7269 656e 743d 5550 290a 7b0a 2020   orient=UP).{.  
-0000b090: 2020 7369 7a65 203d 2073 6361 6c61 725f    size = scalar_
-0000b0a0: 7665 6333 2873 697a 6529 3b0a 2020 2020  vec3(size);.    
-0000b0b0: 616e 6368 6f72 203d 2067 6574 5f61 6e63  anchor = get_anc
-0000b0c0: 686f 7228 616e 6368 6f72 2c20 6365 6e74  hor(anchor, cent
-0000b0d0: 6572 2c20 2d5b 312c 312c 315d 2c20 2d5b  er, -[1,1,1], -[
-0000b0e0: 312c 312c 315d 293b 0a20 2020 2076 6e66  1,1,1]);.    vnf
-0000b0f0: 203d 2077 6564 6765 2873 697a 652c 2063   = wedge(size, c
-0000b100: 656e 7465 723d 7472 7565 293b 0a20 2020  enter=true);.   
-0000b110: 2061 7474 6163 6861 626c 6528 616e 6368   attachable(anch
-0000b120: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
-0000b130: 7369 7a65 3d73 697a 652c 2073 697a 6532  size=size, size2
-0000b140: 3d5b 7369 7a65 2e78 2c30 5d2c 2073 6869  =[size.x,0], shi
-0000b150: 6674 3d5b 302c 2d73 697a 652e 792f 325d  ft=[0,-size.y/2]
-0000b160: 2920 7b0a 2020 2020 2020 2020 6966 2028  ) {.        if (
-0000b170: 7369 7a65 2e7a 203e 2030 2920 7b0a 2020  size.z > 0) {.  
-0000b180: 2020 2020 2020 2020 2020 766e 665f 706f            vnf_po
-0000b190: 6c79 6865 6472 6f6e 2876 6e66 293b 0a20  lyhedron(vnf);. 
-0000b1a0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000b1b0: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
-0000b1c0: 207d 0a7d 0a0a 0a66 756e 6374 696f 6e20   }.}...function 
-0000b1d0: 7765 6467 6528 7369 7a65 3d5b 312c 312c  wedge(size=[1,1,
-0000b1e0: 315d 2c20 6365 6e74 6572 2c20 616e 6368  1], center, anch
-0000b1f0: 6f72 2c20 7370 696e 3d30 2c20 6f72 6965  or, spin=0, orie
-0000b200: 6e74 3d55 5029 203d 0a20 2020 206c 6574  nt=UP) =.    let
-0000b210: 280a 2020 2020 2020 2020 7369 7a65 203d  (.        size =
-0000b220: 2073 6361 6c61 725f 7665 6333 2873 697a   scalar_vec3(siz
-0000b230: 6529 2c0a 2020 2020 2020 2020 616e 6368  e),.        anch
-0000b240: 6f72 203d 2067 6574 5f61 6e63 686f 7228  or = get_anchor(
-0000b250: 616e 6368 6f72 2c20 6365 6e74 6572 2c20  anchor, center, 
-0000b260: 2d5b 312c 312c 315d 2c20 2d5b 312c 312c  -[1,1,1], -[1,1,
-0000b270: 315d 292c 0a20 2020 2020 2020 2070 7473  1]),.        pts
-0000b280: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-0000b290: 205b 2031 2c31 2c2d 315d 2c20 5b20 312c   [ 1,1,-1], [ 1,
-0000b2a0: 2d31 2c2d 315d 2c20 5b20 312c 2d31 2c31  -1,-1], [ 1,-1,1
-0000b2b0: 5d2c 0a20 2020 2020 2020 2020 2020 205b  ],.            [
-0000b2c0: 2d31 2c31 2c2d 315d 2c20 5b2d 312c 2d31  -1,1,-1], [-1,-1
-0000b2d0: 2c2d 315d 2c20 5b2d 312c 2d31 2c31 5d2c  ,-1], [-1,-1,1],
-0000b2e0: 0a20 2020 2020 2020 205d 2c0a 2020 2020  .        ],.    
-0000b2f0: 2020 2020 6661 6365 7320 3d20 5b0a 2020      faces = [.  
-0000b300: 2020 2020 2020 2020 2020 5b30 2c31 2c32            [0,1,2
-0000b310: 5d2c 205b 332c 352c 345d 2c20 5b30 2c33  ], [3,5,4], [0,3
-0000b320: 2c31 5d2c 205b 312c 332c 345d 2c0a 2020  ,1], [1,3,4],.  
-0000b330: 2020 2020 2020 2020 2020 5b31 2c34 2c32            [1,4,2
-0000b340: 5d2c 205b 322c 342c 355d 2c20 5b32 2c35  ], [2,4,5], [2,5
-0000b350: 2c33 5d2c 205b 302c 322c 335d 2c0a 2020  ,3], [0,2,3],.  
-0000b360: 2020 2020 2020 5d2c 0a20 2020 2020 2020        ],.       
-0000b370: 2076 6e66 203d 205b 7363 616c 6528 7369   vnf = [scale(si
-0000b380: 7a65 2f32 2c70 3d70 7473 292c 2066 6163  ze/2,p=pts), fac
-0000b390: 6573 5d0a 2020 2020 290a 2020 2020 7265  es].    ).    re
-0000b3a0: 6f72 6965 6e74 2861 6e63 686f 722c 7370  orient(anchor,sp
-0000b3b0: 696e 2c6f 7269 656e 742c 2073 697a 653d  in,orient, size=
-0000b3c0: 7369 7a65 2c20 7369 7a65 323d 5b73 697a  size, size2=[siz
-0000b3d0: 652e 782c 305d 2c20 7368 6966 743d 5b30  e.x,0], shift=[0
-0000b3e0: 2c2d 7369 7a65 2e79 2f32 5d2c 2070 3d76  ,-size.y/2], p=v
-0000b3f0: 6e66 293b 0a0a 0a2f 2f20 5365 6374 696f  nf);...// Sectio
-0000b400: 6e3a 2043 796c 696e 6465 7273 0a0a 0a2f  n: Cylinders.../
-0000b410: 2f20 4675 6e63 7469 6f6e 264d 6f64 756c  / Function&Modul
-0000b420: 653a 2063 796c 696e 6465 7228 290a 2f2f  e: cylinder().//
-0000b430: 2054 6f70 6963 733a 2053 6861 7065 7320   Topics: Shapes 
-0000b440: 2833 4429 2c20 4174 7461 6368 6162 6c65  (3D), Attachable
-0000b450: 2c20 564e 4620 4765 6e65 7261 746f 7273  , VNF Generators
-0000b460: 0a2f 2f20 5573 6167 653a 2041 7320 4d6f  .// Usage: As Mo
-0000b470: 6475 6c65 0a2f 2f20 2020 6379 6c69 6e64  dule.//   cylind
-0000b480: 6572 2868 2c20 723d 2f64 3d2c 205b 6365  er(h, r=/d=, [ce
-0000b490: 6e74 6572 3d5d 2c20 2e2e 2e29 205b 4154  nter=], ...) [AT
-0000b4a0: 5441 4348 4d45 4e54 535d 3b0a 2f2f 2020  TACHMENTS];.//  
-0000b4b0: 2063 796c 696e 6465 7228 682c 2072 312f   cylinder(h, r1/
-0000b4c0: 6431 3d2c 2072 322f 6432 3d2c 205b 6365  d1=, r2/d2=, [ce
-0000b4d0: 6e74 6572 3d5d 2c20 2e2e 2e29 205b 4154  nter=], ...) [AT
-0000b4e0: 5441 4348 4d45 4e54 535d 3b0a 2f2f 2055  TACHMENTS];.// U
-0000b4f0: 7361 6765 3a20 4173 2046 756e 6374 696f  sage: As Functio
-0000b500: 6e0a 2f2f 2020 2076 6e66 203d 2063 796c  n.//   vnf = cyl
-0000b510: 696e 6465 7228 682c 2072 3d2f 643d 2c20  inder(h, r=/d=, 
-0000b520: 5b63 656e 7465 723d 5d2c 202e 2e2e 293b  [center=], ...);
-0000b530: 0a2f 2f20 2020 766e 6620 3d20 6379 6c69  .//   vnf = cyli
-0000b540: 6e64 6572 2868 2c20 7231 2f64 313d 2c20  nder(h, r1/d1=, 
-0000b550: 7232 2f64 323d 2c20 5b63 656e 7465 723d  r2/d2=, [center=
-0000b560: 5d2c 202e 2e2e 293b 0a2f 2f20 5365 6520  ], ...);.// See 
-0000b570: 416c 736f 3a20 6379 6c28 290a 2f2f 2044  Also: cyl().// D
-0000b580: 6573 6372 6970 7469 6f6e 3a0a 2f2f 2020  escription:.//  
-0000b590: 2043 7265 6174 6573 2061 2033 4420 6379   Creates a 3D cy
-0000b5a0: 6c69 6e64 6572 206f 7220 636f 6e69 6320  linder or conic 
-0000b5b0: 6f62 6a65 6374 2077 6974 6820 7375 7070  object with supp
-0000b5c0: 6f72 7420 666f 7220 616e 6368 6f72 696e  ort for anchorin
-0000b5d0: 6720 616e 6420 6174 7461 6368 6d65 6e74  g and attachment
-0000b5e0: 732e 0a2f 2f20 2020 5468 6973 2063 616e  s..//   This can
-0000b5f0: 2062 6520 7573 6564 2061 7320 6120 6472   be used as a dr
-0000b600: 6f70 2d69 6e20 7265 706c 6163 656d 656e  op-in replacemen
-0000b610: 7420 666f 7220 7468 6520 6275 696c 742d  t for the built-
-0000b620: 696e 2060 6379 6c69 6e64 6572 2829 6020  in `cylinder()` 
-0000b630: 6d6f 6475 6c65 2e0a 2f2f 2020 2057 6865  module..//   Whe
-0000b640: 6e20 6361 6c6c 6564 2061 7320 6120 6675  n called as a fu
-0000b650: 6e63 7469 6f6e 2c20 7265 7475 726e 7320  nction, returns 
-0000b660: 6120 5b56 4e46 5d28 766e 662e 7363 6164  a [VNF](vnf.scad
-0000b670: 2920 666f 7220 6120 6379 6c69 6e64 6572  ) for a cylinder
-0000b680: 2e0a 2f2f 2041 7267 756d 656e 7473 3a0a  ..// Arguments:.
-0000b690: 2f2f 2020 206c 202f 2068 203d 2054 6865  //   l / h = The
-0000b6a0: 2068 6569 6768 7420 6f66 2074 6865 2063   height of the c
-0000b6b0: 796c 696e 6465 722e 0a2f 2f20 2020 7231  ylinder..//   r1
-0000b6c0: 203d 2054 6865 2062 6f74 746f 6d20 7261   = The bottom ra
-0000b6d0: 6469 7573 206f 6620 7468 6520 6379 6c69  dius of the cyli
-0000b6e0: 6e64 6572 2e20 2028 4265 666f 7265 206f  nder.  (Before o
-0000b6f0: 7269 656e 7461 7469 6f6e 2e29 0a2f 2f20  rientation.).// 
-0000b700: 2020 7232 203d 2054 6865 2074 6f70 2072    r2 = The top r
-0000b710: 6164 6975 7320 6f66 2074 6865 2063 796c  adius of the cyl
-0000b720: 696e 6465 722e 2020 2842 6566 6f72 6520  inder.  (Before 
-0000b730: 6f72 6965 6e74 6174 696f 6e2e 290a 2f2f  orientation.).//
-0000b740: 2020 2063 656e 7465 7220 3d20 4966 2067     center = If g
-0000b750: 6976 656e 2c20 6f76 6572 7269 6465 7320  iven, overrides 
-0000b760: 6061 6e63 686f 7260 2e20 2041 2074 7275  `anchor`.  A tru
-0000b770: 6520 7661 6c75 6520 7365 7473 2060 616e  e value sets `an
-0000b780: 6368 6f72 3d43 454e 5445 5260 2c20 6661  chor=CENTER`, fa
-0000b790: 6c73 6520 7365 7473 2060 616e 6368 6f72  lse sets `anchor
-0000b7a0: 3d42 4f54 544f 4d60 2e0a 2f2f 2020 202d  =BOTTOM`..//   -
-0000b7b0: 2d2d 0a2f 2f20 2020 6431 203d 2054 6865  --.//   d1 = The
-0000b7c0: 2062 6f74 746f 6d20 6469 616d 6574 6572   bottom diameter
-0000b7d0: 206f 6620 7468 6520 6379 6c69 6e64 6572   of the cylinder
-0000b7e0: 2e20 2028 4265 666f 7265 206f 7269 656e  .  (Before orien
-0000b7f0: 7461 7469 6f6e 2e29 0a2f 2f20 2020 6432  tation.).//   d2
-0000b800: 203d 2054 6865 2074 6f70 2064 6961 6d65   = The top diame
-0000b810: 7465 7220 6f66 2074 6865 2063 796c 696e  ter of the cylin
-0000b820: 6465 722e 2020 2842 6566 6f72 6520 6f72  der.  (Before or
-0000b830: 6965 6e74 6174 696f 6e2e 290a 2f2f 2020  ientation.).//  
-0000b840: 2072 203d 2054 6865 2072 6164 6975 7320   r = The radius 
-0000b850: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
-0000b860: 0a2f 2f20 2020 6420 3d20 5468 6520 6469  .//   d = The di
-0000b870: 616d 6574 6572 206f 6620 7468 6520 6379  ameter of the cy
-0000b880: 6c69 6e64 6572 2e0a 2f2f 2020 2061 6e63  linder..//   anc
-0000b890: 686f 7220 3d20 5472 616e 736c 6174 6520  hor = Translate 
-0000b8a0: 736f 2061 6e63 686f 7220 706f 696e 7420  so anchor point 
-0000b8b0: 6973 2061 7420 6f72 6967 696e 2028 302c  is at origin (0,
-0000b8c0: 302c 3029 2e20 2053 6565 205b 616e 6368  0,0).  See [anch
-0000b8d0: 6f72 5d28 6174 7461 6368 6d65 6e74 732e  or](attachments.
-0000b8e0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-0000b8f0: 616e 6368 6f72 292e 2020 4465 6661 756c  anchor).  Defaul
-0000b900: 743a 2060 4345 4e54 4552 600a 2f2f 2020  t: `CENTER`.//  
-0000b910: 2073 7069 6e20 3d20 526f 7461 7465 2074   spin = Rotate t
-0000b920: 6869 7320 6d61 6e79 2064 6567 7265 6573  his many degrees
-0000b930: 2061 726f 756e 6420 7468 6520 5a20 6178   around the Z ax
-0000b940: 6973 2061 6674 6572 2061 6e63 686f 722e  is after anchor.
-0000b950: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
-0000b960: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
-0000b970: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
-0000b980: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
-0000b990: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
-0000b9a0: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
-0000b9b0: 2074 6f77 6172 6473 2c20 6166 7465 7220   towards, after 
-0000b9c0: 7370 696e 2e20 2053 6565 205b 6f72 6965  spin.  See [orie
-0000b9d0: 6e74 5d28 6174 7461 6368 6d65 6e74 732e  nt](attachments.
-0000b9e0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-0000b9f0: 6f72 6965 6e74 292e 2020 4465 6661 756c  orient).  Defaul
-0000ba00: 743a 2060 5550 600a 2f2f 2045 7861 6d70  t: `UP`.// Examp
-0000ba10: 6c65 3a20 4279 2052 6164 6975 730a 2f2f  le: By Radius.//
-0000ba20: 2020 2078 6469 7374 7269 6275 7465 2833     xdistribute(3
-0000ba30: 3029 207b 0a2f 2f20 2020 2020 2020 6379  0) {.//       cy
-0000ba40: 6c69 6e64 6572 2868 3d34 302c 2072 3d31  linder(h=40, r=1
-0000ba50: 3029 3b0a 2f2f 2020 2020 2020 2063 796c  0);.//       cyl
-0000ba60: 696e 6465 7228 683d 3430 2c20 7231 3d31  inder(h=40, r1=1
-0000ba70: 302c 2072 323d 3529 3b0a 2f2f 2020 207d  0, r2=5);.//   }
-0000ba80: 0a2f 2f20 4578 616d 706c 653a 2042 7920  .// Example: By 
-0000ba90: 4469 616d 6574 6572 0a2f 2f20 2020 7864  Diameter.//   xd
-0000baa0: 6973 7472 6962 7574 6528 3330 2920 7b0a  istribute(30) {.
-0000bab0: 2f2f 2020 2020 2020 2063 796c 696e 6465  //       cylinde
-0000bac0: 7228 683d 3430 2c20 643d 3235 293b 0a2f  r(h=40, d=25);./
-0000bad0: 2f20 2020 2020 2020 6379 6c69 6e64 6572  /       cylinder
-0000bae0: 2868 3d34 302c 2064 313d 3235 2c20 6432  (h=40, d1=25, d2
-0000baf0: 3d31 3029 3b0a 2f2f 2020 207d 0a2f 2f20  =10);.//   }.// 
-0000bb00: 4578 616d 706c 6528 4d65 6429 3a20 416e  Example(Med): An
-0000bb10: 6368 6f72 696e 670a 2f2f 2020 2063 796c  choring.//   cyl
-0000bb20: 696e 6465 7228 683d 3430 2c20 7231 3d31  inder(h=40, r1=1
-0000bb30: 302c 2072 323d 352c 2061 6e63 686f 723d  0, r2=5, anchor=
-0000bb40: 424f 5454 4f4d 2b46 524f 4e54 293b 0a2f  BOTTOM+FRONT);./
-0000bb50: 2f20 4578 616d 706c 6528 4d65 6429 3a20  / Example(Med): 
-0000bb60: 5370 696e 0a2f 2f20 2020 6379 6c69 6e64  Spin.//   cylind
-0000bb70: 6572 2868 3d34 302c 2072 313d 3130 2c20  er(h=40, r1=10, 
-0000bb80: 7232 3d35 2c20 616e 6368 6f72 3d42 4f54  r2=5, anchor=BOT
-0000bb90: 544f 4d2b 4652 4f4e 542c 2073 7069 6e3d  TOM+FRONT, spin=
-0000bba0: 3435 293b 0a2f 2f20 4578 616d 706c 6528  45);.// Example(
-0000bbb0: 4d65 6429 3a20 4f72 6965 6e74 0a2f 2f20  Med): Orient.// 
-0000bbc0: 2020 6379 6c69 6e64 6572 2868 3d34 302c    cylinder(h=40,
-0000bbd0: 2072 313d 3130 2c20 7232 3d35 2c20 616e   r1=10, r2=5, an
-0000bbe0: 6368 6f72 3d42 4f54 544f 4d2b 4652 4f4e  chor=BOTTOM+FRON
-0000bbf0: 542c 2073 7069 6e3d 3435 2c20 6f72 6965  T, spin=45, orie
-0000bc00: 6e74 3d46 5744 293b 0a2f 2f20 4578 616d  nt=FWD);.// Exam
-0000bc10: 706c 6528 4269 6729 3a20 5374 616e 6461  ple(Big): Standa
-0000bc20: 7264 2043 6f6e 6e65 6374 6f72 730a 2f2f  rd Connectors.//
-0000bc30: 2020 2078 6469 7374 7269 6275 7465 2834     xdistribute(4
-0000bc40: 3029 207b 0a2f 2f20 2020 2020 2020 6379  0) {.//       cy
-0000bc50: 6c69 6e64 6572 2868 3d33 302c 2064 3d32  linder(h=30, d=2
-0000bc60: 3529 2073 686f 775f 616e 6368 6f72 7328  5) show_anchors(
-0000bc70: 293b 0a2f 2f20 2020 2020 2020 6379 6c69  );.//       cyli
-0000bc80: 6e64 6572 2868 3d33 302c 2064 313d 3235  nder(h=30, d1=25
-0000bc90: 2c20 6432 3d31 3029 2073 686f 775f 616e  , d2=10) show_an
-0000bca0: 6368 6f72 7328 293b 0a2f 2f20 2020 7d0a  chors();.//   }.
-0000bcb0: 6d6f 6475 6c65 2063 796c 696e 6465 7228  module cylinder(
-0000bcc0: 682c 2072 312c 2072 322c 2063 656e 7465  h, r1, r2, cente
-0000bcd0: 722c 206c 2c20 722c 2064 2c20 6431 2c20  r, l, r, d, d1, 
-0000bce0: 6432 2c20 616e 6368 6f72 2c20 7370 696e  d2, anchor, spin
-0000bcf0: 3d30 2c20 6f72 6965 6e74 3d55 5029 0a7b  =0, orient=UP).{
-0000bd00: 0a20 2020 2061 6e63 686f 7220 3d20 6765  .    anchor = ge
-0000bd10: 745f 616e 6368 6f72 2861 6e63 686f 722c  t_anchor(anchor,
-0000bd20: 2063 656e 7465 722c 2042 4f54 544f 4d2c   center, BOTTOM,
-0000bd30: 2042 4f54 544f 4d29 3b0a 2020 2020 7231   BOTTOM);.    r1
-0000bd40: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
-0000bd50: 3d72 312c 2072 3d72 2c20 6431 3d64 312c  =r1, r=r, d1=d1,
-0000bd60: 2064 3d64 2c20 6466 6c74 3d31 293b 0a20   d=d, dflt=1);. 
-0000bd70: 2020 2072 3220 3d20 6765 745f 7261 6469     r2 = get_radi
-0000bd80: 7573 2872 313d 7232 2c20 723d 722c 2064  us(r1=r2, r=r, d
-0000bd90: 313d 6432 2c20 643d 642c 2064 666c 743d  1=d2, d=d, dflt=
-0000bda0: 3129 3b0a 2020 2020 6c20 3d20 6669 7273  1);.    l = firs
-0000bdb0: 745f 6465 6669 6e65 6428 5b68 2c20 6c2c  t_defined([h, l,
-0000bdc0: 2031 5d29 3b0a 2020 2020 6174 7461 6368   1]);.    attach
-0000bdd0: 6162 6c65 2861 6e63 686f 722c 7370 696e  able(anchor,spin
-0000bde0: 2c6f 7269 656e 742c 2072 313d 7231 2c20  ,orient, r1=r1, 
-0000bdf0: 7232 3d72 322c 206c 3d6c 2920 7b0a 2020  r2=r2, l=l) {.  
-0000be00: 2020 2020 2020 5f63 796c 696e 6465 7228        _cylinder(
-0000be10: 683d 6c2c 2072 313d 7231 2c20 7232 3d72  h=l, r1=r1, r2=r
-0000be20: 322c 2063 656e 7465 723d 7472 7565 293b  2, center=true);
-0000be30: 0a20 2020 2020 2020 2063 6869 6c64 7265  .        childre
-0000be40: 6e28 293b 0a20 2020 207d 0a7d 0a0a 6675  n();.    }.}..fu
-0000be50: 6e63 7469 6f6e 2063 796c 696e 6465 7228  nction cylinder(
-0000be60: 682c 2072 312c 2072 322c 2063 656e 7465  h, r1, r2, cente
-0000be70: 722c 206c 2c20 722c 2064 2c20 6431 2c20  r, l, r, d, d1, 
-0000be80: 6432 2c20 616e 6368 6f72 2c20 7370 696e  d2, anchor, spin
-0000be90: 3d30 2c20 6f72 6965 6e74 3d55 5029 203d  =0, orient=UP) =
-0000bea0: 0a20 2020 206c 6574 280a 2020 2020 2020  .    let(.      
-0000beb0: 2020 616e 6368 6f72 203d 2067 6574 5f61    anchor = get_a
-0000bec0: 6e63 686f 7228 616e 6368 6f72 2c20 6365  nchor(anchor, ce
-0000bed0: 6e74 6572 2c20 424f 5454 4f4d 2c20 424f  nter, BOTTOM, BO
-0000bee0: 5454 4f4d 292c 0a20 2020 2020 2020 2072  TTOM),.        r
-0000bef0: 3120 3d20 6765 745f 7261 6469 7573 2872  1 = get_radius(r
-0000bf00: 313d 7231 2c20 723d 722c 2064 313d 6431  1=r1, r=r, d1=d1
-0000bf10: 2c20 643d 642c 2064 666c 743d 3129 2c0a  , d=d, dflt=1),.
-0000bf20: 2020 2020 2020 2020 7232 203d 2067 6574          r2 = get
-0000bf30: 5f72 6164 6975 7328 7231 3d72 322c 2072  _radius(r1=r2, r
-0000bf40: 3d72 2c20 6431 3d64 322c 2064 3d64 2c20  =r, d1=d2, d=d, 
-0000bf50: 6466 6c74 3d31 292c 0a20 2020 2020 2020  dflt=1),.       
-0000bf60: 206c 203d 2066 6972 7374 5f64 6566 696e   l = first_defin
-0000bf70: 6564 285b 682c 206c 2c20 315d 292c 0a20  ed([h, l, 1]),. 
-0000bf80: 2020 2020 2020 2073 6964 6573 203d 2073         sides = s
-0000bf90: 6567 7328 6d61 7828 7231 2c72 3229 292c  egs(max(r1,r2)),
-0000bfa0: 0a20 2020 2020 2020 2076 6572 7473 203d  .        verts =
-0000bfb0: 205b 0a20 2020 2020 2020 2020 2020 2066   [.            f
-0000bfc0: 6f72 2028 693d 5b30 3a31 3a73 6964 6573  or (i=[0:1:sides
-0000bfd0: 2d31 5d29 206c 6574 2861 3d33 3630 2a28  -1]) let(a=360*(
-0000bfe0: 312d 692f 7369 6465 7329 2920 5b72 312a  1-i/sides)) [r1*
-0000bff0: 636f 7328 6129 2c72 312a 7369 6e28 6129  cos(a),r1*sin(a)
-0000c000: 2c2d 6c2f 325d 2c0a 2020 2020 2020 2020  ,-l/2],.        
-0000c010: 2020 2020 666f 7220 2869 3d5b 303a 313a      for (i=[0:1:
-0000c020: 7369 6465 732d 315d 2920 6c65 7428 613d  sides-1]) let(a=
-0000c030: 3336 302a 2831 2d69 2f73 6964 6573 2929  360*(1-i/sides))
-0000c040: 205b 7232 2a63 6f73 2861 292c 7232 2a73   [r2*cos(a),r2*s
-0000c050: 696e 2861 292c 206c 2f32 5d2c 0a20 2020  in(a), l/2],.   
-0000c060: 2020 2020 205d 2c0a 2020 2020 2020 2020       ],.        
-0000c070: 6661 6365 7320 3d20 5b0a 2020 2020 2020  faces = [.      
-0000c080: 2020 2020 2020 5b66 6f72 2028 693d 5b30        [for (i=[0
-0000c090: 3a31 3a73 6964 6573 2d31 5d29 2073 6964  :1:sides-1]) sid
-0000c0a0: 6573 2d31 2d69 5d2c 0a20 2020 2020 2020  es-1-i],.       
-0000c0b0: 2020 2020 2066 6f72 2028 693d 5b30 3a31       for (i=[0:1
-0000c0c0: 3a73 6964 6573 2d31 5d29 205b 692c 2028  :sides-1]) [i, (
-0000c0d0: 2869 2b31 2925 7369 6465 7329 2b73 6964  (i+1)%sides)+sid
-0000c0e0: 6573 2c20 692b 7369 6465 735d 2c0a 2020  es, i+sides],.  
-0000c0f0: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
-0000c100: 3d5b 303a 313a 7369 6465 732d 315d 2920  =[0:1:sides-1]) 
-0000c110: 5b69 2c20 2869 2b31 2925 7369 6465 732c  [i, (i+1)%sides,
-0000c120: 2028 2869 2b31 2925 7369 6465 7329 2b73   ((i+1)%sides)+s
-0000c130: 6964 6573 5d2c 0a20 2020 2020 2020 2020  ides],.         
-0000c140: 2020 205b 666f 7220 2869 3d5b 303a 313a     [for (i=[0:1:
-0000c150: 7369 6465 732d 315d 2920 7369 6465 732b  sides-1]) sides+
-0000c160: 695d 0a20 2020 2020 2020 205d 0a20 2020  i].        ].   
-0000c170: 2029 205b 7265 6f72 6965 6e74 2861 6e63   ) [reorient(anc
-0000c180: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
-0000c190: 206c 3d6c 2c20 7231 3d72 312c 2072 323d   l=l, r1=r1, r2=
-0000c1a0: 7232 2c20 703d 7665 7274 7329 2c20 6661  r2, p=verts), fa
-0000c1b0: 6365 735d 3b0a 0a0a 0a2f 2f20 4d6f 6475  ces];....// Modu
-0000c1c0: 6c65 3a20 6379 6c28 290a 2f2f 0a2f 2f20  le: cyl().//.// 
-0000c1d0: 4465 7363 7269 7074 696f 6e3a 0a2f 2f20  Description:.// 
-0000c1e0: 2020 4372 6561 7465 7320 6379 6c69 6e64    Creates cylind
-0000c1f0: 6572 7320 696e 2076 6172 696f 7573 2061  ers in various a
-0000c200: 6e63 686f 7269 6e67 7320 616e 6420 6f72  nchorings and or
-0000c210: 6965 6e74 6174 696f 6e73 2c20 7769 7468  ientations, with
-0000c220: 206f 7074 696f 6e61 6c20 726f 756e 6469   optional roundi
-0000c230: 6e67 2061 6e64 2063 6861 6d66 6572 732e  ng and chamfers.
-0000c240: 0a2f 2f20 2020 596f 7520 6361 6e20 7573  .//   You can us
-0000c250: 6520 6068 6020 616e 6420 606c 6020 696e  e `h` and `l` in
-0000c260: 7465 7263 6861 6e67 6162 6c79 2c20 616e  terchangably, an
-0000c270: 6420 616c 6c20 7661 7269 616e 7473 2061  d all variants a
-0000c280: 6c6c 6f77 2073 7065 6369 6679 696e 6720  llow specifying 
-0000c290: 7369 7a65 2062 7920 6569 7468 6572 2060  size by either `
-0000c2a0: 7260 7c60 6460 2c0a 2f2f 2020 206f 7220  r`|`d`,.//   or 
-0000c2b0: 6072 3160 7c60 6431 6020 616e 6420 6072  `r1`|`d1` and `r
-0000c2c0: 3260 7c60 6432 602e 2020 4e6f 7465 3a20  2`|`d2`.  Note: 
-0000c2d0: 7468 6520 6368 616d 6665 7273 2061 6e64  the chamfers and
-0000c2e0: 2072 6f75 6e64 696e 6720 6361 6e6e 6f74   rounding cannot
-0000c2f0: 2062 6520 6375 6d75 6c61 7469 7665 6c79   be cumulatively
-0000c300: 206c 6f6e 6765 7220 7468 616e 0a2f 2f20   longer than.// 
-0000c310: 2020 7468 6520 6379 6c69 6e64 6572 2773    the cylinder's
-0000c320: 206c 656e 6774 682e 0a2f 2f0a 2f2f 2055   length..//.// U
-0000c330: 7361 6765 3a20 4e6f 726d 616c 2043 796c  sage: Normal Cyl
-0000c340: 696e 6465 7273 0a2f 2f20 2020 6379 6c28  inders.//   cyl(
-0000c350: 6c7c 682c 2072 2c20 5b63 656e 7465 725d  l|h, r, [center]
-0000c360: 2c20 5b63 6972 6375 6d3d 5d2c 205b 7265  , [circum=], [re
-0000c370: 616c 6967 6e3d 5d29 205b 4154 5441 4348  align=]) [ATTACH
-0000c380: 4d45 4e54 535d 3b0a 2f2f 2020 2063 796c  MENTS];.//   cyl
-0000c390: 286c 7c68 2c20 643d 2c20 2e2e 2e29 205b  (l|h, d=, ...) [
-0000c3a0: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-0000c3b0: 2020 2063 796c 286c 7c68 2c20 7231 3d2c     cyl(l|h, r1=,
-0000c3c0: 2072 323d 2c20 2e2e 2e29 205b 4154 5441   r2=, ...) [ATTA
-0000c3d0: 4348 4d45 4e54 535d 3b0a 2f2f 2020 2063  CHMENTS];.//   c
-0000c3e0: 796c 286c 7c68 2c20 6431 3d2c 2064 323d  yl(l|h, d1=, d2=
-0000c3f0: 2c20 2e2e 2e29 205b 4154 5441 4348 4d45  , ...) [ATTACHME
-0000c400: 4e54 535d 3b0a 2f2f 0a2f 2f20 5573 6167  NTS];.//.// Usag
-0000c410: 653a 2043 6861 6d66 6572 7265 6420 4379  e: Chamferred Cy
-0000c420: 6c69 6e64 6572 730a 2f2f 2020 2063 796c  linders.//   cyl
-0000c430: 286c 7c68 2c20 727c 642c 2063 6861 6d66  (l|h, r|d, chamf
-0000c440: 6572 3d2c 205b 6368 616d 6661 6e67 3d5d  er=, [chamfang=]
-0000c450: 2c20 5b66 726f 6d5f 656e 643d 5d2c 202e  , [from_end=], .
-0000c460: 2e2e 293b 0a2f 2f20 2020 6379 6c28 6c7c  ..);.//   cyl(l|
-0000c470: 682c 2072 7c64 2c20 6368 616d 6665 7231  h, r|d, chamfer1
-0000c480: 3d2c 205b 6368 616d 6661 6e67 313d 5d2c  =, [chamfang1=],
-0000c490: 205b 6672 6f6d 5f65 6e64 3d5d 2c20 2e2e   [from_end=], ..
-0000c4a0: 2e29 3b0a 2f2f 2020 2063 796c 286c 7c68  .);.//   cyl(l|h
-0000c4b0: 2c20 727c 642c 2063 6861 6d66 6572 323d  , r|d, chamfer2=
-0000c4c0: 2c20 5b63 6861 6d66 616e 6732 3d5d 2c20  , [chamfang2=], 
-0000c4d0: 5b66 726f 6d5f 656e 643d 5d2c 202e 2e2e  [from_end=], ...
-0000c4e0: 293b 0a2f 2f20 2020 6379 6c28 6c7c 682c  );.//   cyl(l|h,
-0000c4f0: 2072 7c64 2c20 6368 616d 6665 7231 3d2c   r|d, chamfer1=,
-0000c500: 2063 6861 6d66 6572 323d 2c20 5b63 6861   chamfer2=, [cha
-0000c510: 6d66 616e 6731 3d5d 2c20 5b63 6861 6d66  mfang1=], [chamf
-0000c520: 616e 6732 3d5d 2c20 5b66 726f 6d5f 656e  ang2=], [from_en
-0000c530: 643d 5d2c 202e 2e2e 293b 0a2f 2f0a 2f2f  d=], ...);.//.//
-0000c540: 2055 7361 6765 3a20 526f 756e 6465 6420   Usage: Rounded 
-0000c550: 456e 6420 4379 6c69 6e64 6572 730a 2f2f  End Cylinders.//
-0000c560: 2020 2063 796c 286c 7c68 2c20 727c 642c     cyl(l|h, r|d,
-0000c570: 2072 6f75 6e64 696e 673d 2c20 2e2e 2e29   rounding=, ...)
-0000c580: 3b0a 2f2f 2020 2063 796c 286c 7c68 2c20  ;.//   cyl(l|h, 
-0000c590: 727c 642c 2072 6f75 6e64 696e 6731 3d2c  r|d, rounding1=,
-0000c5a0: 202e 2e2e 293b 0a2f 2f20 2020 6379 6c28   ...);.//   cyl(
-0000c5b0: 6c7c 682c 2072 7c64 2c20 726f 756e 6469  l|h, r|d, roundi
-0000c5c0: 6e67 323d 2c20 2e2e 2e29 3b0a 2f2f 2020  ng2=, ...);.//  
-0000c5d0: 2063 796c 286c 7c68 2c20 727c 642c 2072   cyl(l|h, r|d, r
-0000c5e0: 6f75 6e64 696e 6731 3d2c 2072 6f75 6e64  ounding1=, round
-0000c5f0: 696e 6732 3d2c 202e 2e2e 293b 0a2f 2f0a  ing2=, ...);.//.
-0000c600: 2f2f 2041 7267 756d 656e 7473 3a0a 2f2f  // Arguments:.//
-0000c610: 2020 206c 202f 2068 203d 204c 656e 6774     l / h = Lengt
-0000c620: 6820 6f66 2063 796c 696e 6465 7220 616c  h of cylinder al
-0000c630: 6f6e 6720 6f72 6965 6e74 6564 2061 7869  ong oriented axi
-0000c640: 732e 2020 4465 6661 756c 743a 2031 0a2f  s.  Default: 1./
-0000c650: 2f20 2020 7220 3d20 5261 6469 7573 206f  /   r = Radius o
-0000c660: 6620 6379 6c69 6e64 6572 2e20 2044 6566  f cylinder.  Def
-0000c670: 6175 6c74 3a20 310a 2f2f 2020 2063 656e  ault: 1.//   cen
-0000c680: 7465 7220 3d20 4966 2067 6976 656e 2c20  ter = If given, 
-0000c690: 6f76 6572 7269 6465 7320 6061 6e63 686f  overrides `ancho
-0000c6a0: 7260 2e20 2041 2074 7275 6520 7661 6c75  r`.  A true valu
-0000c6b0: 6520 7365 7473 2060 616e 6368 6f72 3d43  e sets `anchor=C
-0000c6c0: 454e 5445 5260 2c20 6661 6c73 6520 7365  ENTER`, false se
-0000c6d0: 7473 2060 616e 6368 6f72 3d44 4f57 4e60  ts `anchor=DOWN`
-0000c6e0: 2e0a 2f2f 2020 202d 2d2d 0a2f 2f20 2020  ..//   ---.//   
-0000c6f0: 7231 203d 2052 6164 6975 7320 6f66 2074  r1 = Radius of t
-0000c700: 6865 206e 6567 6174 6976 6520 2858 2d2c  he negative (X-,
-0000c710: 2059 2d2c 205a 2d29 2065 6e64 206f 6620   Y-, Z-) end of 
-0000c720: 6379 6c69 6e64 6572 2e0a 2f2f 2020 2072  cylinder..//   r
-0000c730: 3220 3d20 5261 6469 7573 206f 6620 7468  2 = Radius of th
-0000c740: 6520 706f 7369 7469 7665 2028 582b 2c20  e positive (X+, 
-0000c750: 592b 2c20 5a2b 2920 656e 6420 6f66 2063  Y+, Z+) end of c
-0000c760: 796c 696e 6465 722e 0a2f 2f20 2020 6420  ylinder..//   d 
-0000c770: 3d20 4469 616d 6574 6572 206f 6620 6379  = Diameter of cy
-0000c780: 6c69 6e64 6572 2e0a 2f2f 2020 2064 3120  linder..//   d1 
-0000c790: 3d20 4469 616d 6574 6572 206f 6620 7468  = Diameter of th
-0000c7a0: 6520 6e65 6761 7469 7665 2028 582d 2c20  e negative (X-, 
-0000c7b0: 592d 2c20 5a2d 2920 656e 6420 6f66 2063  Y-, Z-) end of c
-0000c7c0: 796c 696e 6465 722e 0a2f 2f20 2020 6432  ylinder..//   d2
-0000c7d0: 203d 2044 6961 6d65 7465 7220 6f66 2074   = Diameter of t
-0000c7e0: 6865 2070 6f73 6974 6976 6520 2858 2b2c  he positive (X+,
-0000c7f0: 2059 2b2c 205a 2b29 2065 6e64 206f 6620   Y+, Z+) end of 
-0000c800: 6379 6c69 6e64 6572 2e0a 2f2f 2020 2063  cylinder..//   c
-0000c810: 6972 6375 6d20 3d20 4966 2074 7275 652c  ircum = If true,
-0000c820: 2063 796c 696e 6465 7220 7368 6f75 6c64   cylinder should
-0000c830: 2063 6972 6375 6d73 6372 6962 6520 7468   circumscribe th
-0000c840: 6520 6369 7263 6c65 206f 6620 7468 6520  e circle of the 
-0000c850: 6769 7665 6e20 7369 7a65 2e20 204f 7468  given size.  Oth
-0000c860: 6572 7769 7365 2069 6e73 6372 6962 6573  erwise inscribes
-0000c870: 2e20 2044 6566 6175 6c74 3a20 6066 616c  .  Default: `fal
-0000c880: 7365 600a 2f2f 2020 2063 6861 6d66 6572  se`.//   chamfer
-0000c890: 203d 2054 6865 2073 697a 6520 6f66 2074   = The size of t
-0000c8a0: 6865 2063 6861 6d66 6572 7320 6f6e 2074  he chamfers on t
-0000c8b0: 6865 2065 6e64 7320 6f66 2074 6865 2063  he ends of the c
-0000c8c0: 796c 696e 6465 722e 2020 4465 6661 756c  ylinder.  Defaul
-0000c8d0: 743a 206e 6f6e 652e 0a2f 2f20 2020 6368  t: none..//   ch
-0000c8e0: 616d 6665 7231 203d 2054 6865 2073 697a  amfer1 = The siz
-0000c8f0: 6520 6f66 2074 6865 2063 6861 6d66 6572  e of the chamfer
-0000c900: 206f 6e20 7468 6520 626f 7474 6f6d 2065   on the bottom e
-0000c910: 6e64 206f 6620 7468 6520 6379 6c69 6e64  nd of the cylind
-0000c920: 6572 2e20 2044 6566 6175 6c74 3a20 6e6f  er.  Default: no
-0000c930: 6e65 2e0a 2f2f 2020 2063 6861 6d66 6572  ne..//   chamfer
-0000c940: 3220 3d20 5468 6520 7369 7a65 206f 6620  2 = The size of 
-0000c950: 7468 6520 6368 616d 6665 7220 6f6e 2074  the chamfer on t
-0000c960: 6865 2074 6f70 2065 6e64 206f 6620 7468  he top end of th
-0000c970: 6520 6379 6c69 6e64 6572 2e20 2044 6566  e cylinder.  Def
-0000c980: 6175 6c74 3a20 6e6f 6e65 2e0a 2f2f 2020  ault: none..//  
-0000c990: 2063 6861 6d66 616e 6720 3d20 5468 6520   chamfang = The 
-0000c9a0: 616e 676c 6520 696e 2064 6567 7265 6573  angle in degrees
-0000c9b0: 206f 6620 7468 6520 6368 616d 6665 7273   of the chamfers
-0000c9c0: 206f 6e20 7468 6520 656e 6473 206f 6620   on the ends of 
-0000c9d0: 7468 6520 6379 6c69 6e64 6572 2e0a 2f2f  the cylinder..//
-0000c9e0: 2020 2063 6861 6d66 616e 6731 203d 2054     chamfang1 = T
-0000c9f0: 6865 2061 6e67 6c65 2069 6e20 6465 6772  he angle in degr
-0000ca00: 6565 7320 6f66 2074 6865 2063 6861 6d66  ees of the chamf
-0000ca10: 6572 206f 6e20 7468 6520 626f 7474 6f6d  er on the bottom
-0000ca20: 2065 6e64 206f 6620 7468 6520 6379 6c69   end of the cyli
-0000ca30: 6e64 6572 2e0a 2f2f 2020 2063 6861 6d66  nder..//   chamf
-0000ca40: 616e 6732 203d 2054 6865 2061 6e67 6c65  ang2 = The angle
-0000ca50: 2069 6e20 6465 6772 6565 7320 6f66 2074   in degrees of t
-0000ca60: 6865 2063 6861 6d66 6572 206f 6e20 7468  he chamfer on th
-0000ca70: 6520 746f 7020 656e 6420 6f66 2074 6865  e top end of the
-0000ca80: 2063 796c 696e 6465 722e 0a2f 2f20 2020   cylinder..//   
-0000ca90: 6672 6f6d 5f65 6e64 203d 2049 6620 7472  from_end = If tr
-0000caa0: 7565 2c20 6368 616d 6665 7220 6973 206d  ue, chamfer is m
-0000cab0: 6561 7375 7265 6420 6672 6f6d 2074 6865  easured from the
-0000cac0: 2065 6e64 206f 6620 7468 6520 6379 6c69   end of the cyli
-0000cad0: 6e64 6572 2c20 696e 7374 6561 6420 6f66  nder, instead of
-0000cae0: 2069 6e73 6574 2066 726f 6d20 7468 6520   inset from the 
-0000caf0: 6564 6765 2e20 2044 6566 6175 6c74 3a20  edge.  Default: 
-0000cb00: 6066 616c 7365 602e 0a2f 2f20 2020 726f  `false`..//   ro
-0000cb10: 756e 6469 6e67 203d 2054 6865 2072 6164  unding = The rad
-0000cb20: 6975 7320 6f66 2074 6865 2072 6f75 6e64  ius of the round
-0000cb30: 696e 6720 6f6e 2074 6865 2065 6e64 7320  ing on the ends 
-0000cb40: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
-0000cb50: 2020 4465 6661 756c 743a 206e 6f6e 652e    Default: none.
-0000cb60: 0a2f 2f20 2020 726f 756e 6469 6e67 3120  .//   rounding1 
-0000cb70: 3d20 5468 6520 7261 6469 7573 206f 6620  = The radius of 
-0000cb80: 7468 6520 726f 756e 6469 6e67 206f 6e20  the rounding on 
-0000cb90: 7468 6520 626f 7474 6f6d 2065 6e64 206f  the bottom end o
-0000cba0: 6620 7468 6520 6379 6c69 6e64 6572 2e0a  f the cylinder..
-0000cbb0: 2f2f 2020 2072 6f75 6e64 696e 6732 203d  //   rounding2 =
-0000cbc0: 2054 6865 2072 6164 6975 7320 6f66 2074   The radius of t
-0000cbd0: 6865 2072 6f75 6e64 696e 6720 6f6e 2074  he rounding on t
-0000cbe0: 6865 2074 6f70 2065 6e64 206f 6620 7468  he top end of th
-0000cbf0: 6520 6379 6c69 6e64 6572 2e0a 2f2f 2020  e cylinder..//  
-0000cc00: 2072 6561 6c69 676e 203d 2049 6620 7472   realign = If tr
-0000cc10: 7565 2c20 726f 7461 7465 2074 6865 2063  ue, rotate the c
-0000cc20: 796c 696e 6465 7220 6279 2068 616c 6620  ylinder by half 
-0000cc30: 7468 6520 616e 676c 6520 6f66 206f 6e65  the angle of one
-0000cc40: 2066 6163 652e 0a2f 2f20 2020 616e 6368   face..//   anch
-0000cc50: 6f72 203d 2054 7261 6e73 6c61 7465 2073  or = Translate s
-0000cc60: 6f20 616e 6368 6f72 2070 6f69 6e74 2069  o anchor point i
-0000cc70: 7320 6174 206f 7269 6769 6e20 2830 2c30  s at origin (0,0
-0000cc80: 2c30 292e 2020 5365 6520 5b61 6e63 686f  ,0).  See [ancho
-0000cc90: 725d 2861 7474 6163 686d 656e 7473 2e73  r](attachments.s
-0000cca0: 6361 6423 7375 6273 6563 7469 6f6e 2d61  cad#subsection-a
-0000ccb0: 6e63 686f 7229 2e20 2044 6566 6175 6c74  nchor).  Default
-0000ccc0: 3a20 6043 454e 5445 5260 0a2f 2f20 2020  : `CENTER`.//   
-0000ccd0: 7370 696e 203d 2052 6f74 6174 6520 7468  spin = Rotate th
-0000cce0: 6973 206d 616e 7920 6465 6772 6565 7320  is many degrees 
-0000ccf0: 6172 6f75 6e64 2074 6865 205a 2061 7869  around the Z axi
-0000cd00: 7320 6166 7465 7220 616e 6368 6f72 2e20  s after anchor. 
-0000cd10: 2053 6565 205b 7370 696e 5d28 6174 7461   See [spin](atta
-0000cd20: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
-0000cd30: 7365 6374 696f 6e2d 7370 696e 292e 2020  section-spin).  
-0000cd40: 4465 6661 756c 743a 2060 3060 0a2f 2f20  Default: `0`.// 
-0000cd50: 2020 6f72 6965 6e74 203d 2056 6563 746f    orient = Vecto
-0000cd60: 7220 746f 2072 6f74 6174 6520 746f 7020  r to rotate top 
-0000cd70: 746f 7761 7264 732c 2061 6674 6572 2073  towards, after s
-0000cd80: 7069 6e2e 2020 5365 6520 5b6f 7269 656e  pin.  See [orien
-0000cd90: 745d 2861 7474 6163 686d 656e 7473 2e73  t](attachments.s
-0000cda0: 6361 6423 7375 6273 6563 7469 6f6e 2d6f  cad#subsection-o
-0000cdb0: 7269 656e 7429 2e20 2044 6566 6175 6c74  rient).  Default
-0000cdc0: 3a20 6055 5060 0a2f 2f0a 2f2f 2045 7861  : `UP`.//.// Exa
-0000cdd0: 6d70 6c65 3a20 4279 2052 6164 6975 730a  mple: By Radius.
-0000cde0: 2f2f 2020 2078 6469 7374 7269 6275 7465  //   xdistribute
-0000cdf0: 2833 3029 207b 0a2f 2f20 2020 2020 2020  (30) {.//       
-0000ce00: 6379 6c28 6c3d 3430 2c20 723d 3130 293b  cyl(l=40, r=10);
-0000ce10: 0a2f 2f20 2020 2020 2020 6379 6c28 6c3d  .//       cyl(l=
-0000ce20: 3430 2c20 7231 3d31 302c 2072 323d 3529  40, r1=10, r2=5)
-0000ce30: 3b0a 2f2f 2020 207d 0a2f 2f0a 2f2f 2045  ;.//   }.//.// E
-0000ce40: 7861 6d70 6c65 3a20 4279 2044 6961 6d65  xample: By Diame
-0000ce50: 7465 720a 2f2f 2020 2078 6469 7374 7269  ter.//   xdistri
-0000ce60: 6275 7465 2833 3029 207b 0a2f 2f20 2020  bute(30) {.//   
-0000ce70: 2020 2020 6379 6c28 6c3d 3430 2c20 643d      cyl(l=40, d=
-0000ce80: 3235 293b 0a2f 2f20 2020 2020 2020 6379  25);.//       cy
-0000ce90: 6c28 6c3d 3430 2c20 6431 3d32 352c 2064  l(l=40, d1=25, d
-0000cea0: 323d 3130 293b 0a2f 2f20 2020 7d0a 2f2f  2=10);.//   }.//
-0000ceb0: 0a2f 2f20 4578 616d 706c 653a 2043 6861  .// Example: Cha
-0000cec0: 6d66 6572 7269 6e67 0a2f 2f20 2020 7864  mferring.//   xd
-0000ced0: 6973 7472 6962 7574 6528 3630 2920 7b0a  istribute(60) {.
-0000cee0: 2f2f 2020 2020 2020 202f 2f20 5368 6f77  //       // Show
-0000cef0: 6e20 4c65 6674 2074 6f20 7269 6768 742e  n Left to right.
-0000cf00: 0a2f 2f20 2020 2020 2020 6379 6c28 6c3d  .//       cyl(l=
-0000cf10: 3430 2c20 643d 3430 2c20 6368 616d 6665  40, d=40, chamfe
-0000cf20: 723d 3729 3b20 202f 2f20 4465 6661 756c  r=7);  // Defaul
-0000cf30: 7420 6368 616d 6661 6e67 3d34 350a 2f2f  t chamfang=45.//
-0000cf40: 2020 2020 2020 2063 796c 286c 3d34 302c         cyl(l=40,
-0000cf50: 2064 3d34 302c 2063 6861 6d66 6572 3d37   d=40, chamfer=7
-0000cf60: 2c20 6368 616d 6661 6e67 3d33 302c 2066  , chamfang=30, f
-0000cf70: 726f 6d5f 656e 643d 6661 6c73 6529 3b0a  rom_end=false);.
-0000cf80: 2f2f 2020 2020 2020 2063 796c 286c 3d34  //       cyl(l=4
-0000cf90: 302c 2064 3d34 302c 2063 6861 6d66 6572  0, d=40, chamfer
-0000cfa0: 3d37 2c20 6368 616d 6661 6e67 3d33 302c  =7, chamfang=30,
-0000cfb0: 2066 726f 6d5f 656e 643d 7472 7565 293b   from_end=true);
-0000cfc0: 0a2f 2f20 2020 7d0a 2f2f 0a2f 2f20 4578  .//   }.//.// Ex
-0000cfd0: 616d 706c 653a 2052 6f75 6e64 696e 670a  ample: Rounding.
-0000cfe0: 2f2f 2020 2063 796c 286c 3d34 302c 2064  //   cyl(l=40, d
-0000cff0: 3d34 302c 2072 6f75 6e64 696e 673d 3130  =40, rounding=10
-0000d000: 293b 0a2f 2f0a 2f2f 2045 7861 6d70 6c65  );.//.// Example
-0000d010: 3a20 4865 7465 726f 6765 6e6f 7573 2043  : Heterogenous C
-0000d020: 6861 6d66 6572 7320 616e 6420 526f 756e  hamfers and Roun
-0000d030: 6469 6e67 0a2f 2f20 2020 7964 6973 7472  ding.//   ydistr
-0000d040: 6962 7574 6528 3830 2920 7b0a 2f2f 2020  ibute(80) {.//  
-0000d050: 2020 2020 202f 2f20 5368 6f77 6e20 4672       // Shown Fr
-0000d060: 6f6e 7420 746f 2042 6163 6b2e 0a2f 2f20  ont to Back..// 
-0000d070: 2020 2020 2020 6379 6c28 6c3d 3430 2c20        cyl(l=40, 
-0000d080: 643d 3430 2c20 726f 756e 6469 6e67 313d  d=40, rounding1=
-0000d090: 3135 2c20 6f72 6965 6e74 3d55 5029 3b0a  15, orient=UP);.
-0000d0a0: 2f2f 2020 2020 2020 2063 796c 286c 3d34  //       cyl(l=4
-0000d0b0: 302c 2064 3d34 302c 2063 6861 6d66 6572  0, d=40, chamfer
-0000d0c0: 323d 352c 206f 7269 656e 743d 5550 293b  2=5, orient=UP);
-0000d0d0: 0a2f 2f20 2020 2020 2020 6379 6c28 6c3d  .//       cyl(l=
-0000d0e0: 3430 2c20 643d 3430 2c20 6368 616d 6665  40, d=40, chamfe
-0000d0f0: 7231 3d31 322c 2072 6f75 6e64 696e 6732  r1=12, rounding2
-0000d100: 3d31 302c 206f 7269 656e 743d 5550 293b  =10, orient=UP);
-0000d110: 0a2f 2f20 2020 7d0a 2f2f 0a2f 2f20 4578  .//   }.//.// Ex
-0000d120: 616d 706c 653a 2050 7574 7469 6e67 2069  ample: Putting i
-0000d130: 7420 616c 6c20 746f 6765 7468 6572 0a2f  t all together./
-0000d140: 2f20 2020 6379 6c28 0a2f 2f20 2020 2020  /   cyl(.//     
-0000d150: 2020 6c3d 3430 2c20 6431 3d32 352c 2064    l=40, d1=25, d
-0000d160: 323d 3135 2c0a 2f2f 2020 2020 2020 2063  2=15,.//       c
-0000d170: 6861 6d66 6572 313d 3130 2c20 6368 616d  hamfer1=10, cham
-0000d180: 6661 6e67 313d 3330 2c0a 2f2f 2020 2020  fang1=30,.//    
-0000d190: 2020 2066 726f 6d5f 656e 643d 7472 7565     from_end=true
-0000d1a0: 2c20 726f 756e 6469 6e67 323d 350a 2f2f  , rounding2=5.//
-0000d1b0: 2020 2029 3b0a 2f2f 0a2f 2f20 4578 616d     );.//.// Exam
-0000d1c0: 706c 653a 2045 7874 6572 6e61 6c20 4368  ple: External Ch
-0000d1d0: 616d 6665 7273 0a2f 2f20 2020 6379 6c28  amfers.//   cyl(
-0000d1e0: 6c3d 3530 2c20 723d 3330 2c20 6368 616d  l=50, r=30, cham
-0000d1f0: 6665 723d 2d35 2c20 6368 616d 6661 6e67  fer=-5, chamfang
-0000d200: 3d33 302c 2024 6661 3d31 2c20 2466 733d  =30, $fa=1, $fs=
-0000d210: 3129 3b0a 2f2f 0a2f 2f20 4578 616d 706c  1);.//.// Exampl
-0000d220: 653a 2045 7874 6572 6e61 6c20 526f 756e  e: External Roun
-0000d230: 6469 6e67 730a 2f2f 2020 2063 796c 286c  dings.//   cyl(l
-0000d240: 3d35 302c 2072 3d33 302c 2072 6f75 6e64  =50, r=30, round
-0000d250: 696e 6731 3d2d 352c 2072 6f75 6e64 696e  ing1=-5, roundin
-0000d260: 6732 3d35 2c20 2466 613d 312c 2024 6673  g2=5, $fa=1, $fs
-0000d270: 3d31 293b 0a2f 2f0a 2f2f 2045 7861 6d70  =1);.//.// Examp
-0000d280: 6c65 3a20 5374 616e 6461 7264 2043 6f6e  le: Standard Con
-0000d290: 6e65 6374 6f72 730a 2f2f 2020 2078 6469  nectors.//   xdi
-0000d2a0: 7374 7269 6275 7465 2834 3029 207b 0a2f  stribute(40) {./
-0000d2b0: 2f20 2020 2020 2020 6379 6c28 6c3d 3330  /       cyl(l=30
-0000d2c0: 2c20 643d 3235 2920 7368 6f77 5f61 6e63  , d=25) show_anc
-0000d2d0: 686f 7273 2829 3b0a 2f2f 2020 2020 2020  hors();.//      
-0000d2e0: 2063 796c 286c 3d33 302c 2064 313d 3235   cyl(l=30, d1=25
-0000d2f0: 2c20 6432 3d31 3029 2073 686f 775f 616e  , d2=10) show_an
-0000d300: 6368 6f72 7328 293b 0a2f 2f20 2020 7d0a  chors();.//   }.
-0000d310: 2f2f 0a6d 6f64 756c 6520 6379 6c28 0a20  //.module cyl(. 
-0000d320: 2020 2068 2c20 722c 2063 656e 7465 722c     h, r, center,
-0000d330: 0a20 2020 206c 2c20 7231 2c20 7232 2c0a  .    l, r1, r2,.
-0000d340: 2020 2020 642c 2064 312c 2064 322c 0a20      d, d1, d2,. 
-0000d350: 2020 2063 6861 6d66 6572 2c20 6368 616d     chamfer, cham
-0000d360: 6665 7231 2c20 6368 616d 6665 7232 2c0a  fer1, chamfer2,.
-0000d370: 2020 2020 6368 616d 6661 6e67 2c20 6368      chamfang, ch
-0000d380: 616d 6661 6e67 312c 2063 6861 6d66 616e  amfang1, chamfan
-0000d390: 6732 2c0a 2020 2020 726f 756e 6469 6e67  g2,.    rounding
-0000d3a0: 2c20 726f 756e 6469 6e67 312c 2072 6f75  , rounding1, rou
-0000d3b0: 6e64 696e 6732 2c0a 2020 2020 6369 7263  nding2,.    circ
-0000d3c0: 756d 3d66 616c 7365 2c20 7265 616c 6967  um=false, realig
-0000d3d0: 6e3d 6661 6c73 652c 2066 726f 6d5f 656e  n=false, from_en
-0000d3e0: 643d 6661 6c73 652c 0a20 2020 2061 6e63  d=false,.    anc
-0000d3f0: 686f 722c 2073 7069 6e3d 302c 206f 7269  hor, spin=0, ori
-0000d400: 656e 743d 5550 0a29 207b 0a20 2020 206c  ent=UP.) {.    l
-0000d410: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-0000d420: 285b 6c2c 2068 2c20 315d 293b 0a20 2020  ([l, h, 1]);.   
-0000d430: 205f 7231 203d 2067 6574 5f72 6164 6975   _r1 = get_radiu
-0000d440: 7328 7231 3d72 312c 2072 3d72 2c20 6431  s(r1=r1, r=r, d1
-0000d450: 3d64 312c 2064 3d64 2c20 6466 6c74 3d31  =d1, d=d, dflt=1
-0000d460: 293b 0a20 2020 205f 7232 203d 2067 6574  );.    _r2 = get
-0000d470: 5f72 6164 6975 7328 7231 3d72 322c 2072  _radius(r1=r2, r
-0000d480: 3d72 2c20 6431 3d64 322c 2064 3d64 2c20  =r, d1=d2, d=d, 
-0000d490: 6466 6c74 3d31 293b 0a20 2020 2073 6964  dflt=1);.    sid
-0000d4a0: 6573 203d 2073 6567 7328 6d61 7828 5f72  es = segs(max(_r
-0000d4b0: 312c 5f72 3229 293b 0a20 2020 2073 6320  1,_r2));.    sc 
-0000d4c0: 3d20 6369 7263 756d 3f20 312f 636f 7328  = circum? 1/cos(
-0000d4d0: 3138 302f 7369 6465 7329 203a 2031 3b0a  180/sides) : 1;.
-0000d4e0: 2020 2020 7231 3d5f 7231 2a73 633b 0a20      r1=_r1*sc;. 
-0000d4f0: 2020 2072 323d 5f72 322a 7363 3b0a 2020     r2=_r2*sc;.  
-0000d500: 2020 7068 6920 3d20 6174 616e 3228 6c2c    phi = atan2(l,
-0000d510: 2072 322d 7231 293b 0a20 2020 2061 6e63   r2-r1);.    anc
-0000d520: 686f 7220 3d20 6765 745f 616e 6368 6f72  hor = get_anchor
-0000d530: 2861 6e63 686f 722c 6365 6e74 6572 2c42  (anchor,center,B
-0000d540: 4f54 2c43 454e 5445 5229 3b0a 2020 2020  OT,CENTER);.    
-0000d550: 6174 7461 6368 6162 6c65 2861 6e63 686f  attachable(ancho
-0000d560: 722c 7370 696e 2c6f 7269 656e 742c 2072  r,spin,orient, r
-0000d570: 313d 7231 2c20 7232 3d72 322c 206c 3d6c  1=r1, r2=r2, l=l
-0000d580: 2920 7b0a 2020 2020 2020 2020 7a72 6f74  ) {.        zrot
-0000d590: 2872 6561 6c69 676e 3f20 3138 302f 7369  (realign? 180/si
-0000d5a0: 6465 7320 3a20 3029 207b 0a20 2020 2020  des : 0) {.     
-0000d5b0: 2020 2020 2020 2069 6620 2821 616e 795f         if (!any_
-0000d5c0: 6465 6669 6e65 6428 5b63 6861 6d66 6572  defined([chamfer
-0000d5d0: 2c20 6368 616d 6665 7231 2c20 6368 616d  , chamfer1, cham
-0000d5e0: 6665 7232 2c20 726f 756e 6469 6e67 2c20  fer2, rounding, 
-0000d5f0: 726f 756e 6469 6e67 312c 2072 6f75 6e64  rounding1, round
-0000d600: 696e 6732 5d29 2920 7b0a 2020 2020 2020  ing2])) {.      
-0000d610: 2020 2020 2020 2020 2020 6379 6c69 6e64            cylind
-0000d620: 6572 2868 3d6c 2c20 7231 3d72 312c 2072  er(h=l, r1=r1, r
-0000d630: 323d 7232 2c20 6365 6e74 6572 3d74 7275  2=r2, center=tru
-0000d640: 652c 2024 666e 3d73 6964 6573 293b 0a20  e, $fn=sides);. 
-0000d650: 2020 2020 2020 2020 2020 207d 2065 6c73             } els
-0000d660: 6520 7b0a 2020 2020 2020 2020 2020 2020  e {.            
-0000d670: 2020 2020 7661 6e67 203d 2061 7461 6e32      vang = atan2
-0000d680: 286c 2c20 7231 2d72 3229 2f32 3b0a 2020  (l, r1-r2)/2;.  
-0000d690: 2020 2020 2020 2020 2020 2020 2020 6368                ch
-0000d6a0: 616e 6731 203d 2039 302d 6669 7273 745f  ang1 = 90-first_
-0000d6b0: 6465 6669 6e65 6428 5b63 6861 6d66 616e  defined([chamfan
-0000d6c0: 6731 2c20 6368 616d 6661 6e67 2c20 7661  g1, chamfang, va
-0000d6d0: 6e67 5d29 3b0a 2020 2020 2020 2020 2020  ng]);.          
-0000d6e0: 2020 2020 2020 6368 616e 6732 203d 2039        chang2 = 9
-0000d6f0: 302d 6669 7273 745f 6465 6669 6e65 6428  0-first_defined(
-0000d700: 5b63 6861 6d66 616e 6732 2c20 6368 616d  [chamfang2, cham
-0000d710: 6661 6e67 2c20 3930 2d76 616e 675d 293b  fang, 90-vang]);
-0000d720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d730: 2063 6861 6d31 203d 2075 5f6d 756c 2866   cham1 = u_mul(f
-0000d740: 6972 7374 5f64 6566 696e 6564 285b 6368  irst_defined([ch
-0000d750: 616d 6665 7231 2c20 6368 616d 6665 725d  amfer1, chamfer]
-0000d760: 2920 2c20 2866 726f 6d5f 656e 643f 2031  ) , (from_end? 1
-0000d770: 203a 2074 616e 2863 6861 6e67 3129 2929   : tan(chang1)))
-0000d780: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000d790: 2020 6368 616d 3220 3d20 755f 6d75 6c28    cham2 = u_mul(
-0000d7a0: 6669 7273 745f 6465 6669 6e65 6428 5b63  first_defined([c
-0000d7b0: 6861 6d66 6572 322c 2063 6861 6d66 6572  hamfer2, chamfer
-0000d7c0: 5d29 202c 2028 6672 6f6d 5f65 6e64 3f20  ]) , (from_end? 
-0000d7d0: 3120 3a20 7461 6e28 6368 616e 6732 2929  1 : tan(chang2))
-0000d7e0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000d7f0: 2020 2066 696c 3120 3d20 6669 7273 745f     fil1 = first_
-0000d800: 6465 6669 6e65 6428 5b72 6f75 6e64 696e  defined([roundin
-0000d810: 6731 2c20 726f 756e 6469 6e67 5d29 3b0a  g1, rounding]);.
-0000d820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d830: 6669 6c32 203d 2066 6972 7374 5f64 6566  fil2 = first_def
-0000d840: 696e 6564 285b 726f 756e 6469 6e67 322c  ined([rounding2,
-0000d850: 2072 6f75 6e64 696e 675d 293b 0a20 2020   rounding]);.   
-0000d860: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000d870: 2863 6861 6d66 6572 2021 3d20 756e 6465  (chamfer != unde
-0000d880: 6629 207b 0a20 2020 2020 2020 2020 2020  f) {.           
-0000d890: 2020 2020 2020 2020 2063 6865 636b 7320           checks 
-0000d8a0: 3d0a 2020 2020 2020 2020 2020 2020 2020  =.              
-0000d8b0: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-0000d8c0: 2863 6861 6d66 6572 203c 3d20 7231 2c20  (chamfer <= r1, 
-0000d8d0: 2022 6368 616d 6665 7220 6973 206c 6172   "chamfer is lar
-0000d8e0: 6765 7220 7468 616e 2074 6865 2072 3120  ger than the r1 
-0000d8f0: 7261 6469 7573 206f 6620 7468 6520 6379  radius of the cy
-0000d900: 6c69 6e64 6572 2e22 290a 2020 2020 2020  linder.").      
-0000d910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d920: 2020 6173 7365 7274 2863 6861 6d66 6572    assert(chamfer
-0000d930: 203c 3d20 7232 2c20 2022 6368 616d 6665   <= r2,  "chamfe
-0000d940: 7220 6973 206c 6172 6765 7220 7468 616e  r is larger than
-0000d950: 2074 6865 2072 3220 7261 6469 7573 206f   the r2 radius o
-0000d960: 6620 7468 6520 6379 6c69 6e64 6572 2e22  f the cylinder."
-0000d970: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000d980: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-0000d990: 2020 2020 2069 6620 2863 6861 6d31 2021       if (cham1 !
-0000d9a0: 3d20 756e 6465 6629 207b 0a20 2020 2020  = undef) {.     
-0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000d9c0: 6865 636b 203d 2061 7373 6572 7428 6368  heck = assert(ch
-0000d9d0: 616d 3120 3c3d 2072 312c 2020 2263 6861  am1 <= r1,  "cha
-0000d9e0: 6d66 6572 3120 6973 206c 6172 6765 7220  mfer1 is larger 
-0000d9f0: 7468 616e 2074 6865 2072 3120 7261 6469  than the r1 radi
-0000da00: 7573 206f 6620 7468 6520 6379 6c69 6e64  us of the cylind
-0000da10: 6572 2e22 293b 0a20 2020 2020 2020 2020  er.");.         
-0000da20: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000da30: 2020 2020 2020 2020 2069 6620 2863 6861           if (cha
-0000da40: 6d32 2021 3d20 756e 6465 6629 207b 0a20  m2 != undef) {. 
-0000da50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da60: 2020 2063 6865 636b 203d 2061 7373 6572     check = asser
-0000da70: 7428 6368 616d 3220 3c3d 2072 322c 2020  t(cham2 <= r2,  
-0000da80: 2263 6861 6d66 6572 3220 6973 206c 6172  "chamfer2 is lar
-0000da90: 6765 7220 7468 616e 2074 6865 2072 3220  ger than the r2 
-0000daa0: 7261 6469 7573 206f 6620 7468 6520 6379  radius of the cy
-0000dab0: 6c69 6e64 6572 2e22 293b 0a20 2020 2020  linder.");.     
-0000dac0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0000dad0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000dae0: 2872 6f75 6e64 696e 6720 213d 2075 6e64  (rounding != und
-0000daf0: 6566 2920 7b0a 2020 2020 2020 2020 2020  ef) {.          
-0000db00: 2020 2020 2020 2020 2020 6368 6563 6b73            checks
-0000db10: 203d 0a20 2020 2020 2020 2020 2020 2020   =.             
-0000db20: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-0000db30: 7428 726f 756e 6469 6e67 203c 3d20 7231  t(rounding <= r1
-0000db40: 2c20 2022 726f 756e 6469 6e67 2069 7320  ,  "rounding is 
-0000db50: 6c61 7267 6572 2074 6861 6e20 7468 6520  larger than the 
-0000db60: 7231 2072 6164 6975 7320 6f66 2074 6865  r1 radius of the
-0000db70: 2063 796c 696e 6465 722e 2229 0a20 2020   cylinder.").   
-0000db80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db90: 2020 2020 2061 7373 6572 7428 726f 756e       assert(roun
-0000dba0: 6469 6e67 203c 3d20 7232 2c20 2022 726f  ding <= r2,  "ro
-0000dbb0: 756e 6469 6e67 2069 7320 6c61 7267 6572  unding is larger
-0000dbc0: 2074 6861 6e20 7468 6520 7232 2072 6164   than the r2 rad
-0000dbd0: 6975 7320 6f66 2074 6865 2063 796c 696e  ius of the cylin
-0000dbe0: 6465 722e 2229 3b0a 2020 2020 2020 2020  der.");.        
-0000dbf0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-0000dc00: 2020 2020 2020 2020 2020 6966 2028 6669            if (fi
-0000dc10: 6c31 2021 3d20 756e 6465 6629 207b 0a20  l1 != undef) {. 
-0000dc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc30: 2020 2063 6865 636b 203d 2061 7373 6572     check = asser
-0000dc40: 7428 6669 6c31 203c 3d20 7231 2c20 2022  t(fil1 <= r1,  "
-0000dc50: 726f 756e 6469 6e67 3120 6973 206c 6172  rounding1 is lar
-0000dc60: 6765 7220 7468 616e 2074 6865 2072 3120  ger than the r1 
-0000dc70: 7261 6469 7573 206f 6620 7468 6520 6379  radius of the cy
-0000dc80: 6c69 6e64 6572 2e22 293b 0a20 2020 2020  linder.");.     
-0000dc90: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0000dca0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000dcb0: 2866 696c 3220 213d 2075 6e64 6566 2920  (fil2 != undef) 
-0000dcc0: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000dcd0: 2020 2020 2020 6368 6563 6b20 3d20 6173        check = as
-0000dce0: 7365 7274 2866 696c 3220 3c3d 2072 322c  sert(fil2 <= r2,
-0000dcf0: 2020 2272 6f75 6e64 696e 6732 2069 7320    "rounding2 is 
-0000dd00: 6c61 7267 6572 2074 6861 6e20 7468 6520  larger than the 
-0000dd10: 7231 2072 6164 6975 7320 6f66 2074 6865  r1 radius of the
-0000dd20: 2063 796c 696e 6465 722e 2229 3b0a 2020   cylinder.");.  
-0000dd30: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
-0000dd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd50: 6479 3120 3d20 6162 7328 6669 7273 745f  dy1 = abs(first_
-0000dd60: 6465 6669 6e65 6428 5b63 6861 6d31 2c20  defined([cham1, 
-0000dd70: 6669 6c31 2c20 305d 2929 3b0a 2020 2020  fil1, 0]));.    
-0000dd80: 2020 2020 2020 2020 2020 2020 6479 3220              dy2 
-0000dd90: 3d20 6162 7328 6669 7273 745f 6465 6669  = abs(first_defi
-0000dda0: 6e65 6428 5b63 6861 6d32 2c20 6669 6c32  ned([cham2, fil2
-0000ddb0: 2c20 305d 2929 3b0a 2020 2020 2020 2020  , 0]));.        
-0000ddc0: 2020 2020 2020 2020 6368 6563 6b20 3d20          check = 
-0000ddd0: 6173 7365 7274 2864 7931 2b64 7932 203c  assert(dy1+dy2 <
-0000dde0: 3d20 6c2c 2022 5375 6d20 6f66 2066 696c  = l, "Sum of fil
-0000ddf0: 6c65 7473 2061 6e64 2063 6861 6d66 6572  lets and chamfer
-0000de00: 2073 697a 6573 206d 7573 7420 6265 206c   sizes must be l
-0000de10: 6573 7320 7468 616e 2074 6865 206c 656e  ess than the len
-0000de20: 6774 6820 6f66 2074 6865 2063 796c 696e  gth of the cylin
-0000de30: 6465 722e 2229 3b0a 0a20 2020 2020 2020  der.");..       
-0000de40: 2020 2020 2020 2020 2070 6174 6820 3d20           path = 
-0000de50: 636f 6e63 6174 280a 2020 2020 2020 2020  concat(.        
-0000de60: 2020 2020 2020 2020 2020 2020 5b5b 302c              [[0,
-0000de70: 6c2f 325d 5d2c 0a0a 2020 2020 2020 2020  l/2]],..        
-0000de80: 2020 2020 2020 2020 2020 2020 2169 735f              !is_
-0000de90: 756e 6465 6628 6368 616d 3229 3f20 280a  undef(cham2)? (.
-0000dea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000deb0: 2020 2020 2020 2020 6c65 7428 0a20 2020          let(.   
-0000dec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ded0: 2020 2020 2020 2020 2070 3120 3d20 5b72           p1 = [r
-0000dee0: 322d 6368 616d 322f 7461 6e28 6368 616e  2-cham2/tan(chan
-0000def0: 6732 292c 6c2f 325d 2c0a 2020 2020 2020  g2),l/2],.      
-0000df00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df10: 2020 2020 2020 7032 203d 206c 6572 7028        p2 = lerp(
-0000df20: 5b72 322c 6c2f 325d 2c5b 7231 2c2d 6c2f  [r2,l/2],[r1,-l/
-0000df30: 325d 2c61 6273 2863 6861 6d32 292f 6c29  2],abs(cham2)/l)
-0000df40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000df50: 2020 2020 2020 2020 2029 205b 7031 2c70           ) [p1,p
-0000df60: 325d 0a20 2020 2020 2020 2020 2020 2020  2].             
-0000df70: 2020 2020 2020 2029 203a 2021 6973 5f75         ) : !is_u
-0000df80: 6e64 6566 2866 696c 3229 3f20 280a 2020  ndef(fil2)? (.  
-0000df90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfa0: 2020 2020 2020 6c65 7428 0a20 2020 2020        let(.     
-0000dfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfc0: 2020 2020 2020 2063 6e20 3d20 6369 7263         cn = circ
-0000dfd0: 6c65 5f32 7461 6e67 656e 7473 2861 6273  le_2tangents(abs
-0000dfe0: 2866 696c 3229 2c20 5b72 322d 6669 6c32  (fil2), [r2-fil2
-0000dff0: 2c6c 2f32 5d2c 205b 7232 2c6c 2f32 5d2c  ,l/2], [r2,l/2],
-0000e000: 205b 7231 2c2d 6c2f 325d 292c 0a20 2020   [r1,-l/2]),.   
-0000e010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e020: 2020 2020 2020 2020 2061 6e67 203d 2066           ang = f
-0000e030: 696c 323c 303f 2070 6869 203a 2070 6869  il2<0? phi : phi
-0000e040: 2d31 3830 2c0a 2020 2020 2020 2020 2020  -180,.          
-0000e050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e060: 2020 7374 6570 7320 3d20 6365 696c 2861    steps = ceil(a
-0000e070: 6273 2861 6e67 292f 3336 302a 7365 6773  bs(ang)/360*segs
-0000e080: 2861 6273 2866 696c 3229 2929 2c0a 2020  (abs(fil2))),.  
-0000e090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0a0: 2020 2020 2020 2020 2020 7374 6570 203d            step =
-0000e0b0: 2061 6e67 2f73 7465 7073 2c0a 2020 2020   ang/steps,.    
-0000e0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0d0: 2020 2020 2020 2020 7074 7320 3d20 5b66          pts = [f
-0000e0e0: 6f72 2028 693d 5b30 3a31 3a73 7465 7073  or (i=[0:1:steps
-0000e0f0: 5d29 206c 6574 2861 3d39 302b 692a 7374  ]) let(a=90+i*st
-0000e100: 6570 2920 636e 5b30 5d2b 6162 7328 6669  ep) cn[0]+abs(fi
-0000e110: 6c32 292a 5b63 6f73 2861 292c 7369 6e28  l2)*[cos(a),sin(
-0000e120: 6129 5d5d 0a20 2020 2020 2020 2020 2020  a)]].           
-0000e130: 2020 2020 2020 2020 2020 2020 2029 2070               ) p
-0000e140: 7473 0a20 2020 2020 2020 2020 2020 2020  ts.             
-0000e150: 2020 2020 2020 2029 203a 205b 5b72 322c         ) : [[r2,
-0000e160: 6c2f 325d 5d2c 0a0a 2020 2020 2020 2020  l/2]],..        
-0000e170: 2020 2020 2020 2020 2020 2020 2169 735f              !is_
-0000e180: 756e 6465 6628 6368 616d 3129 3f20 280a  undef(cham1)? (.
-0000e190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1a0: 2020 2020 2020 2020 6c65 7428 0a20 2020          let(.   
-0000e1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1c0: 2020 2020 2020 2020 2070 3120 3d20 6c65           p1 = le
-0000e1d0: 7270 285b 7231 2c2d 6c2f 325d 2c5b 7232  rp([r1,-l/2],[r2
-0000e1e0: 2c6c 2f32 5d2c 6162 7328 6368 616d 3129  ,l/2],abs(cham1)
-0000e1f0: 2f6c 292c 0a20 2020 2020 2020 2020 2020  /l),.           
-0000e200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e210: 2070 3220 3d20 5b72 312d 6368 616d 312f   p2 = [r1-cham1/
-0000e220: 7461 6e28 6368 616e 6731 292c 2d6c 2f32  tan(chang1),-l/2
-0000e230: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000e240: 2020 2020 2020 2020 2020 2920 5b70 312c            ) [p1,
-0000e250: 7032 5d0a 2020 2020 2020 2020 2020 2020  p2].            
-0000e260: 2020 2020 2020 2020 2920 3a20 2169 735f          ) : !is_
-0000e270: 756e 6465 6628 6669 6c31 293f 2028 0a20  undef(fil1)? (. 
-0000e280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e290: 2020 2020 2020 206c 6574 280a 2020 2020         let(.    
-0000e2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2b0: 2020 2020 2020 2020 636e 203d 2063 6972          cn = cir
-0000e2c0: 636c 655f 3274 616e 6765 6e74 7328 6162  cle_2tangents(ab
-0000e2d0: 7328 6669 6c31 292c 205b 7231 2d66 696c  s(fil1), [r1-fil
-0000e2e0: 312c 2d6c 2f32 5d2c 205b 7231 2c2d 6c2f  1,-l/2], [r1,-l/
-0000e2f0: 325d 2c20 5b72 322c 6c2f 325d 292c 0a20  2], [r2,l/2]),. 
-0000e300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e310: 2020 2020 2020 2020 2020 2061 6e67 203d             ang =
-0000e320: 2066 696c 313c 303f 2031 3830 2d70 6869   fil1<0? 180-phi
-0000e330: 203a 202d 7068 692c 0a20 2020 2020 2020   : -phi,.       
-0000e340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e350: 2020 2020 2073 7465 7073 203d 2063 6569       steps = cei
-0000e360: 6c28 6162 7328 616e 6729 2f33 3630 2a73  l(abs(ang)/360*s
-0000e370: 6567 7328 6162 7328 6669 6c31 2929 292c  egs(abs(fil1))),
-0000e380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e390: 2020 2020 2020 2020 2020 2020 2073 7465               ste
-0000e3a0: 7020 3d20 616e 672f 7374 6570 732c 0a20  p = ang/steps,. 
-0000e3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e3c0: 2020 2020 2020 2020 2020 2070 7473 203d             pts =
-0000e3d0: 205b 666f 7220 2869 3d5b 303a 313a 7374   [for (i=[0:1:st
-0000e3e0: 6570 735d 2920 6c65 7428 613d 2866 696c  eps]) let(a=(fil
-0000e3f0: 313c 303f 3138 303a 3029 2b28 7068 692d  1<0?180:0)+(phi-
-0000e400: 3930 292b 692a 7374 6570 2920 636e 5b30  90)+i*step) cn[0
-0000e410: 5d2b 6162 7328 6669 6c31 292a 5b63 6f73  ]+abs(fil1)*[cos
-0000e420: 2861 292c 7369 6e28 6129 5d5d 0a20 2020  (a),sin(a)]].   
-0000e430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e440: 2020 2020 2029 2070 7473 0a20 2020 2020       ) pts.     
-0000e450: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000e460: 203a 205b 5b72 312c 2d6c 2f32 5d5d 2c0a   : [[r1,-l/2]],.
-0000e470: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e480: 2020 2020 205b 5b30 2c2d 6c2f 325d 5d0a       [[0,-l/2]].
-0000e490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e4a0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000e4b0: 2020 2072 6f74 6174 655f 6578 7472 7564     rotate_extrud
-0000e4c0: 6528 636f 6e76 6578 6974 793d 3229 207b  e(convexity=2) {
-0000e4d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e4e0: 2020 2020 2070 6f6c 7967 6f6e 2870 6174       polygon(pat
-0000e4f0: 6829 3b0a 2020 2020 2020 2020 2020 2020  h);.            
-0000e500: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-0000e510: 2020 7d0a 2020 2020 2020 2020 7d0a 2020    }.        }.  
-0000e520: 2020 2020 2020 6368 696c 6472 656e 2829        children()
-0000e530: 3b0a 2020 2020 7d0a 7d0a 0a0a 0a2f 2f20  ;.    }.}....// 
-0000e540: 4d6f 6475 6c65 3a20 7863 796c 2829 0a2f  Module: xcyl()./
-0000e550: 2f0a 2f2f 2044 6573 6372 6970 7469 6f6e  /.// Description
-0000e560: 3a0a 2f2f 2020 2043 7265 6174 6573 2061  :.//   Creates a
-0000e570: 2063 796c 696e 6465 7220 6f72 6965 6e74   cylinder orient
-0000e580: 6564 2061 6c6f 6e67 2074 6865 2058 2061  ed along the X a
-0000e590: 7869 732e 0a2f 2f0a 2f2f 2055 7361 6765  xis..//.// Usage
-0000e5a0: 3a20 5479 7069 6361 6c0a 2f2f 2020 2078  : Typical.//   x
-0000e5b0: 6379 6c28 6c7c 682c 2072 7c64 3d2c 205b  cyl(l|h, r|d=, [
-0000e5c0: 616e 6368 6f72 3d5d 2c20 2e2e 2e29 205b  anchor=], ...) [
-0000e5d0: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-0000e5e0: 2020 2078 6379 6c28 6c7c 682c 2072 313d     xcyl(l|h, r1=
-0000e5f0: 7c64 313d 2c20 7232 3d7c 6432 3d2c 205b  |d1=, r2=|d2=, [
-0000e600: 616e 6368 6f72 3d5d 2c20 2e2e 2e29 205b  anchor=], ...) [
-0000e610: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-0000e620: 0a2f 2f20 4172 6775 6d65 6e74 733a 0a2f  .// Arguments:./
-0000e630: 2f20 2020 6c20 2f20 6820 3d20 4c65 6e67  /   l / h = Leng
-0000e640: 7468 206f 6620 6379 6c69 6e64 6572 2061  th of cylinder a
-0000e650: 6c6f 6e67 206f 7269 656e 7465 6420 6178  long oriented ax
-0000e660: 6973 2e20 4465 6661 756c 743a 2031 0a2f  is. Default: 1./
-0000e670: 2f20 2020 7220 3d20 5261 6469 7573 206f  /   r = Radius o
-0000e680: 6620 6379 6c69 6e64 6572 2e20 2044 6566  f cylinder.  Def
-0000e690: 6175 6c74 3a20 310a 2f2f 2020 202d 2d2d  ault: 1.//   ---
-0000e6a0: 0a2f 2f20 2020 7231 203d 204f 7074 696f  .//   r1 = Optio
-0000e6b0: 6e61 6c20 7261 6469 7573 206f 6620 6c65  nal radius of le
-0000e6c0: 6674 2028 582d 2920 656e 6420 6f66 2063  ft (X-) end of c
-0000e6d0: 796c 696e 6465 722e 0a2f 2f20 2020 7232  ylinder..//   r2
-0000e6e0: 203d 204f 7074 696f 6e61 6c20 7261 6469   = Optional radi
-0000e6f0: 7573 206f 6620 7269 6768 7420 2858 2b29  us of right (X+)
-0000e700: 2065 6e64 206f 6620 6379 6c69 6e64 6572   end of cylinder
-0000e710: 2e0a 2f2f 2020 2064 203d 204f 7074 696f  ..//   d = Optio
-0000e720: 6e61 6c20 6469 616d 6574 6572 206f 6620  nal diameter of 
-0000e730: 6379 6c69 6e64 6572 2e20 2875 7365 2069  cylinder. (use i
-0000e740: 6e73 7465 6164 206f 6620 6072 6029 0a2f  nstead of `r`)./
-0000e750: 2f20 2020 6431 203d 204f 7074 696f 6e61  /   d1 = Optiona
-0000e760: 6c20 6469 616d 6574 6572 206f 6620 6c65  l diameter of le
-0000e770: 6674 2028 582d 2920 656e 6420 6f66 2063  ft (X-) end of c
-0000e780: 796c 696e 6465 722e 0a2f 2f20 2020 6432  ylinder..//   d2
-0000e790: 203d 204f 7074 696f 6e61 6c20 6469 616d   = Optional diam
-0000e7a0: 6574 6572 206f 6620 7269 6768 7420 2858  eter of right (X
-0000e7b0: 2b29 2065 6e64 206f 6620 6379 6c69 6e64  +) end of cylind
-0000e7c0: 6572 2e0a 2f2f 2020 2063 6972 6375 6d20  er..//   circum 
-0000e7d0: 3d20 4966 2074 7275 652c 2063 796c 696e  = If true, cylin
-0000e7e0: 6465 7220 7368 6f75 6c64 2063 6972 6375  der should circu
-0000e7f0: 6d73 6372 6962 6520 7468 6520 6369 7263  mscribe the circ
-0000e800: 6c65 206f 6620 7468 6520 6769 7665 6e20  le of the given 
-0000e810: 7369 7a65 2e20 204f 7468 6572 7769 7365  size.  Otherwise
-0000e820: 2069 6e73 6372 6962 6573 2e20 2044 6566   inscribes.  Def
-0000e830: 6175 6c74 3a20 6066 616c 7365 600a 2f2f  ault: `false`.//
-0000e840: 2020 2063 6861 6d66 6572 203d 2054 6865     chamfer = The
-0000e850: 2073 697a 6520 6f66 2074 6865 2063 6861   size of the cha
-0000e860: 6d66 6572 7320 6f6e 2074 6865 2065 6e64  mfers on the end
-0000e870: 7320 6f66 2074 6865 2063 796c 696e 6465  s of the cylinde
-0000e880: 722e 2020 4465 6661 756c 743a 206e 6f6e  r.  Default: non
-0000e890: 652e 0a2f 2f20 2020 6368 616d 6665 7231  e..//   chamfer1
-0000e8a0: 203d 2054 6865 2073 697a 6520 6f66 2074   = The size of t
-0000e8b0: 6865 2063 6861 6d66 6572 206f 6e20 7468  he chamfer on th
-0000e8c0: 6520 6c65 6674 2065 6e64 206f 6620 7468  e left end of th
-0000e8d0: 6520 6379 6c69 6e64 6572 2e20 2044 6566  e cylinder.  Def
-0000e8e0: 6175 6c74 3a20 6e6f 6e65 2e0a 2f2f 2020  ault: none..//  
-0000e8f0: 2063 6861 6d66 6572 3220 3d20 5468 6520   chamfer2 = The 
-0000e900: 7369 7a65 206f 6620 7468 6520 6368 616d  size of the cham
-0000e910: 6665 7220 6f6e 2074 6865 2072 6967 6874  fer on the right
-0000e920: 2065 6e64 206f 6620 7468 6520 6379 6c69   end of the cyli
-0000e930: 6e64 6572 2e20 2044 6566 6175 6c74 3a20  nder.  Default: 
-0000e940: 6e6f 6e65 2e0a 2f2f 2020 2063 6861 6d66  none..//   chamf
-0000e950: 616e 6720 3d20 5468 6520 616e 676c 6520  ang = The angle 
-0000e960: 696e 2064 6567 7265 6573 206f 6620 7468  in degrees of th
-0000e970: 6520 6368 616d 6665 7273 206f 6e20 7468  e chamfers on th
-0000e980: 6520 656e 6473 206f 6620 7468 6520 6379  e ends of the cy
-0000e990: 6c69 6e64 6572 2e0a 2f2f 2020 2063 6861  linder..//   cha
-0000e9a0: 6d66 616e 6731 203d 2054 6865 2061 6e67  mfang1 = The ang
-0000e9b0: 6c65 2069 6e20 6465 6772 6565 7320 6f66  le in degrees of
-0000e9c0: 2074 6865 2063 6861 6d66 6572 206f 6e20   the chamfer on 
-0000e9d0: 7468 6520 6c65 6674 2065 6e64 206f 6620  the left end of 
-0000e9e0: 7468 6520 6379 6c69 6e64 6572 2e0a 2f2f  the cylinder..//
-0000e9f0: 2020 2063 6861 6d66 616e 6732 203d 2054     chamfang2 = T
-0000ea00: 6865 2061 6e67 6c65 2069 6e20 6465 6772  he angle in degr
-0000ea10: 6565 7320 6f66 2074 6865 2063 6861 6d66  ees of the chamf
-0000ea20: 6572 206f 6e20 7468 6520 7269 6768 7420  er on the right 
-0000ea30: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
-0000ea40: 6465 722e 0a2f 2f20 2020 6672 6f6d 5f65  der..//   from_e
-0000ea50: 6e64 203d 2049 6620 7472 7565 2c20 6368  nd = If true, ch
-0000ea60: 616d 6665 7220 6973 206d 6561 7375 7265  amfer is measure
-0000ea70: 6420 6672 6f6d 2074 6865 2065 6e64 206f  d from the end o
-0000ea80: 6620 7468 6520 6379 6c69 6e64 6572 2c20  f the cylinder, 
-0000ea90: 696e 7374 6561 6420 6f66 2069 6e73 6574  instead of inset
-0000eaa0: 2066 726f 6d20 7468 6520 6564 6765 2e20   from the edge. 
-0000eab0: 2044 6566 6175 6c74 3a20 6066 616c 7365   Default: `false
-0000eac0: 602e 0a2f 2f20 2020 726f 756e 6469 6e67  `..//   rounding
-0000ead0: 203d 2054 6865 2072 6164 6975 7320 6f66   = The radius of
-0000eae0: 2074 6865 2072 6f75 6e64 696e 6720 6f6e   the rounding on
-0000eaf0: 2074 6865 2065 6e64 7320 6f66 2074 6865   the ends of the
-0000eb00: 2063 796c 696e 6465 722e 2020 4465 6661   cylinder.  Defa
-0000eb10: 756c 743a 206e 6f6e 652e 0a2f 2f20 2020  ult: none..//   
-0000eb20: 726f 756e 6469 6e67 3120 3d20 5468 6520  rounding1 = The 
-0000eb30: 7261 6469 7573 206f 6620 7468 6520 726f  radius of the ro
-0000eb40: 756e 6469 6e67 206f 6e20 7468 6520 6c65  unding on the le
-0000eb50: 6674 2065 6e64 206f 6620 7468 6520 6379  ft end of the cy
-0000eb60: 6c69 6e64 6572 2e0a 2f2f 2020 2072 6f75  linder..//   rou
-0000eb70: 6e64 696e 6732 203d 2054 6865 2072 6164  nding2 = The rad
-0000eb80: 6975 7320 6f66 2074 6865 2072 6f75 6e64  ius of the round
-0000eb90: 696e 6720 6f6e 2074 6865 2072 6967 6874  ing on the right
-0000eba0: 2065 6e64 206f 6620 7468 6520 6379 6c69   end of the cyli
-0000ebb0: 6e64 6572 2e0a 2f2f 2020 2072 6561 6c69  nder..//   reali
-0000ebc0: 676e 203d 2049 6620 7472 7565 2c20 726f  gn = If true, ro
-0000ebd0: 7461 7465 2074 6865 2063 796c 696e 6465  tate the cylinde
-0000ebe0: 7220 6279 2068 616c 6620 7468 6520 616e  r by half the an
-0000ebf0: 676c 6520 6f66 206f 6e65 2066 6163 652e  gle of one face.
-0000ec00: 0a2f 2f20 2020 616e 6368 6f72 203d 2054  .//   anchor = T
-0000ec10: 7261 6e73 6c61 7465 2073 6f20 616e 6368  ranslate so anch
-0000ec20: 6f72 2070 6f69 6e74 2069 7320 6174 206f  or point is at o
-0000ec30: 7269 6769 6e20 2830 2c30 2c30 292e 2020  rigin (0,0,0).  
-0000ec40: 5365 6520 5b61 6e63 686f 725d 2861 7474  See [anchor](att
-0000ec50: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
-0000ec60: 6273 6563 7469 6f6e 2d61 6e63 686f 7229  bsection-anchor)
-0000ec70: 2e20 2044 6566 6175 6c74 3a20 6043 454e  .  Default: `CEN
-0000ec80: 5445 5260 0a2f 2f20 2020 7370 696e 203d  TER`.//   spin =
-0000ec90: 2052 6f74 6174 6520 7468 6973 206d 616e   Rotate this man
-0000eca0: 7920 6465 6772 6565 7320 6172 6f75 6e64  y degrees around
-0000ecb0: 2074 6865 205a 2061 7869 7320 6166 7465   the Z axis afte
-0000ecc0: 7220 616e 6368 6f72 2e20 2053 6565 205b  r anchor.  See [
-0000ecd0: 7370 696e 5d28 6174 7461 6368 6d65 6e74  spin](attachment
-0000ece0: 732e 7363 6164 2373 7562 7365 6374 696f  s.scad#subsectio
-0000ecf0: 6e2d 7370 696e 292e 2020 4465 6661 756c  n-spin).  Defaul
-0000ed00: 743a 2060 3060 0a2f 2f20 2020 6f72 6965  t: `0`.//   orie
-0000ed10: 6e74 203d 2056 6563 746f 7220 746f 2072  nt = Vector to r
-0000ed20: 6f74 6174 6520 746f 7020 746f 7761 7264  otate top toward
-0000ed30: 732c 2061 6674 6572 2073 7069 6e2e 2020  s, after spin.  
-0000ed40: 5365 6520 5b6f 7269 656e 745d 2861 7474  See [orient](att
-0000ed50: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
-0000ed60: 6273 6563 7469 6f6e 2d6f 7269 656e 7429  bsection-orient)
-0000ed70: 2e20 2044 6566 6175 6c74 3a20 6055 5060  .  Default: `UP`
-0000ed80: 0a2f 2f0a 2f2f 2045 7861 6d70 6c65 3a20  .//.// Example: 
-0000ed90: 4279 2052 6164 6975 730a 2f2f 2020 2079  By Radius.//   y
-0000eda0: 6469 7374 7269 6275 7465 2835 3029 207b  distribute(50) {
-0000edb0: 0a2f 2f20 2020 2020 2020 7863 796c 286c  .//       xcyl(l
-0000edc0: 3d33 352c 2072 3d31 3029 3b0a 2f2f 2020  =35, r=10);.//  
-0000edd0: 2020 2020 2078 6379 6c28 6c3d 3335 2c20       xcyl(l=35, 
-0000ede0: 7231 3d31 352c 2072 323d 3529 3b0a 2f2f  r1=15, r2=5);.//
-0000edf0: 2020 207d 0a2f 2f0a 2f2f 2045 7861 6d70     }.//.// Examp
-0000ee00: 6c65 3a20 4279 2044 6961 6d65 7465 720a  le: By Diameter.
-0000ee10: 2f2f 2020 2079 6469 7374 7269 6275 7465  //   ydistribute
-0000ee20: 2835 3029 207b 0a2f 2f20 2020 2020 2020  (50) {.//       
-0000ee30: 7863 796c 286c 3d33 352c 2064 3d32 3029  xcyl(l=35, d=20)
-0000ee40: 3b0a 2f2f 2020 2020 2020 2078 6379 6c28  ;.//       xcyl(
-0000ee50: 6c3d 3335 2c20 6431 3d33 302c 2064 323d  l=35, d1=30, d2=
-0000ee60: 3130 293b 0a2f 2f20 2020 7d0a 6d6f 6475  10);.//   }.modu
-0000ee70: 6c65 2078 6379 6c28 0a20 2020 2068 2c20  le xcyl(.    h, 
-0000ee80: 722c 2064 2c20 7231 2c20 7232 2c20 6431  r, d, r1, r2, d1
-0000ee90: 2c20 6432 2c20 6c2c 0a20 2020 2063 6861  , d2, l,.    cha
-0000eea0: 6d66 6572 2c20 6368 616d 6665 7231 2c20  mfer, chamfer1, 
-0000eeb0: 6368 616d 6665 7232 2c0a 2020 2020 6368  chamfer2,.    ch
-0000eec0: 616d 6661 6e67 2c20 6368 616d 6661 6e67  amfang, chamfang
-0000eed0: 312c 2063 6861 6d66 616e 6732 2c0a 2020  1, chamfang2,.  
-0000eee0: 2020 726f 756e 6469 6e67 2c20 726f 756e    rounding, roun
-0000eef0: 6469 6e67 312c 2072 6f75 6e64 696e 6732  ding1, rounding2
-0000ef00: 2c0a 2020 2020 6369 7263 756d 3d66 616c  ,.    circum=fal
-0000ef10: 7365 2c20 7265 616c 6967 6e3d 6661 6c73  se, realign=fals
-0000ef20: 652c 2066 726f 6d5f 656e 643d 6661 6c73  e, from_end=fals
-0000ef30: 652c 0a20 2020 2061 6e63 686f 723d 4345  e,.    anchor=CE
-0000ef40: 4e54 4552 2c20 7370 696e 3d30 2c20 6f72  NTER, spin=0, or
-0000ef50: 6965 6e74 3d55 500a 2920 7b0a 2020 2020  ient=UP.) {.    
-0000ef60: 7231 203d 2067 6574 5f72 6164 6975 7328  r1 = get_radius(
-0000ef70: 7231 3d72 312c 2072 3d72 2c20 6431 3d64  r1=r1, r=r, d1=d
-0000ef80: 312c 2064 3d64 2c20 6466 6c74 3d31 293b  1, d=d, dflt=1);
-0000ef90: 0a20 2020 2072 3220 3d20 6765 745f 7261  .    r2 = get_ra
-0000efa0: 6469 7573 2872 313d 7232 2c20 723d 722c  dius(r1=r2, r=r,
-0000efb0: 2064 313d 6432 2c20 643d 642c 2064 666c   d1=d2, d=d, dfl
-0000efc0: 743d 3129 3b0a 2020 2020 6c20 3d20 6669  t=1);.    l = fi
-0000efd0: 7273 745f 6465 6669 6e65 6428 5b6c 2c20  rst_defined([l, 
-0000efe0: 682c 2031 5d29 3b0a 2020 2020 6174 7461  h, 1]);.    atta
-0000eff0: 6368 6162 6c65 2861 6e63 686f 722c 7370  chable(anchor,sp
-0000f000: 696e 2c6f 7269 656e 742c 2072 313d 7231  in,orient, r1=r1
-0000f010: 2c20 7232 3d72 322c 206c 3d6c 2c20 6178  , r2=r2, l=l, ax
-0000f020: 6973 3d52 4947 4854 2920 7b0a 2020 2020  is=RIGHT) {.    
-0000f030: 2020 2020 6379 6c28 0a20 2020 2020 2020      cyl(.       
-0000f040: 2020 2020 206c 3d6c 2c20 7231 3d72 312c       l=l, r1=r1,
-0000f050: 2072 323d 7232 2c0a 2020 2020 2020 2020   r2=r2,.        
-0000f060: 2020 2020 6368 616d 6665 723d 6368 616d      chamfer=cham
-0000f070: 6665 722c 2063 6861 6d66 6572 313d 6368  fer, chamfer1=ch
-0000f080: 616d 6665 7231 2c20 6368 616d 6665 7232  amfer1, chamfer2
-0000f090: 3d63 6861 6d66 6572 322c 0a20 2020 2020  =chamfer2,.     
-0000f0a0: 2020 2020 2020 2063 6861 6d66 616e 673d         chamfang=
-0000f0b0: 6368 616d 6661 6e67 2c20 6368 616d 6661  chamfang, chamfa
-0000f0c0: 6e67 313d 6368 616d 6661 6e67 312c 2063  ng1=chamfang1, c
-0000f0d0: 6861 6d66 616e 6732 3d63 6861 6d66 616e  hamfang2=chamfan
-0000f0e0: 6732 2c0a 2020 2020 2020 2020 2020 2020  g2,.            
-0000f0f0: 726f 756e 6469 6e67 3d72 6f75 6e64 696e  rounding=roundin
-0000f100: 672c 2072 6f75 6e64 696e 6731 3d72 6f75  g, rounding1=rou
-0000f110: 6e64 696e 6731 2c20 726f 756e 6469 6e67  nding1, rounding
-0000f120: 323d 726f 756e 6469 6e67 322c 0a20 2020  2=rounding2,.   
-0000f130: 2020 2020 2020 2020 2063 6972 6375 6d3d           circum=
-0000f140: 6369 7263 756d 2c20 7265 616c 6967 6e3d  circum, realign=
-0000f150: 7265 616c 6967 6e2c 2066 726f 6d5f 656e  realign, from_en
-0000f160: 643d 6672 6f6d 5f65 6e64 2c0a 2020 2020  d=from_end,.    
-0000f170: 2020 2020 2020 2020 616e 6368 6f72 3d43          anchor=C
-0000f180: 454e 5445 522c 206f 7269 656e 743d 5249  ENTER, orient=RI
-0000f190: 4748 540a 2020 2020 2020 2020 293b 0a20  GHT.        );. 
-0000f1a0: 2020 2020 2020 2063 6869 6c64 7265 6e28         children(
-0000f1b0: 293b 0a20 2020 207d 0a7d 0a0a 0a2f 2f20  );.    }.}...// 
-0000f1c0: 4d6f 6475 6c65 3a20 7963 796c 2829 0a2f  Module: ycyl()./
-0000f1d0: 2f0a 2f2f 2044 6573 6372 6970 7469 6f6e  /.// Description
-0000f1e0: 3a0a 2f2f 2020 2043 7265 6174 6573 2061  :.//   Creates a
-0000f1f0: 2063 796c 696e 6465 7220 6f72 6965 6e74   cylinder orient
-0000f200: 6564 2061 6c6f 6e67 2074 6865 2059 2061  ed along the Y a
-0000f210: 7869 732e 0a2f 2f0a 2f2f 2055 7361 6765  xis..//.// Usage
-0000f220: 3a20 5479 7069 6361 6c0a 2f2f 2020 2079  : Typical.//   y
-0000f230: 6379 6c28 6c7c 682c 2072 7c64 3d2c 205b  cyl(l|h, r|d=, [
-0000f240: 616e 6368 6f72 3d5d 2c20 2e2e 2e29 205b  anchor=], ...) [
-0000f250: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-0000f260: 2020 2079 6379 6c28 6c7c 682c 2072 313d     ycyl(l|h, r1=
-0000f270: 7c64 313d 2c20 7232 3d7c 6432 3d2c 205b  |d1=, r2=|d2=, [
-0000f280: 616e 6368 6f72 3d5d 2c20 2e2e 2e29 205b  anchor=], ...) [
-0000f290: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-0000f2a0: 0a2f 2f20 4172 6775 6d65 6e74 733a 0a2f  .// Arguments:./
-0000f2b0: 2f20 2020 6c20 2f20 6820 3d20 4c65 6e67  /   l / h = Leng
-0000f2c0: 7468 206f 6620 6379 6c69 6e64 6572 2061  th of cylinder a
-0000f2d0: 6c6f 6e67 206f 7269 656e 7465 6420 6178  long oriented ax
-0000f2e0: 6973 2e20 2844 6566 6175 6c74 3a20 6031  is. (Default: `1
-0000f2f0: 2e30 6029 0a2f 2f20 2020 7220 3d20 5261  .0`).//   r = Ra
-0000f300: 6469 7573 206f 6620 6379 6c69 6e64 6572  dius of cylinder
-0000f310: 2e0a 2f2f 2020 202d 2d2d 0a2f 2f20 2020  ..//   ---.//   
-0000f320: 7231 203d 2052 6164 6975 7320 6f66 2066  r1 = Radius of f
-0000f330: 726f 6e74 2028 592d 2920 656e 6420 6f66  ront (Y-) end of
-0000f340: 2063 6f6e 652e 0a2f 2f20 2020 7232 203d   cone..//   r2 =
-0000f350: 2052 6164 6975 7320 6f66 2062 6163 6b20   Radius of back 
-0000f360: 2859 2b29 2065 6e64 206f 6620 6f6e 652e  (Y+) end of one.
-0000f370: 0a2f 2f20 2020 6420 3d20 4469 616d 6574  .//   d = Diamet
-0000f380: 6572 206f 6620 6379 6c69 6e64 6572 2e0a  er of cylinder..
-0000f390: 2f2f 2020 2064 3120 3d20 4469 616d 6574  //   d1 = Diamet
-0000f3a0: 6572 206f 6620 6672 6f6e 7420 2859 2d29  er of front (Y-)
-0000f3b0: 2065 6e64 206f 6620 6f6e 652e 0a2f 2f20   end of one..// 
-0000f3c0: 2020 6432 203d 2044 6961 6d65 7465 7220    d2 = Diameter 
-0000f3d0: 6f66 2062 6163 6b20 2859 2b29 2065 6e64  of back (Y+) end
-0000f3e0: 206f 6620 6f6e 652e 0a2f 2f20 2020 6369   of one..//   ci
-0000f3f0: 7263 756d 203d 2049 6620 7472 7565 2c20  rcum = If true, 
-0000f400: 6379 6c69 6e64 6572 2073 686f 756c 6420  cylinder should 
-0000f410: 6369 7263 756d 7363 7269 6265 2074 6865  circumscribe the
-0000f420: 2063 6972 636c 6520 6f66 2074 6865 2067   circle of the g
-0000f430: 6976 656e 2073 697a 652e 2020 4f74 6865  iven size.  Othe
-0000f440: 7277 6973 6520 696e 7363 7269 6265 732e  rwise inscribes.
-0000f450: 2020 4465 6661 756c 743a 2060 6661 6c73    Default: `fals
-0000f460: 6560 0a2f 2f20 2020 6368 616d 6665 7220  e`.//   chamfer 
-0000f470: 3d20 5468 6520 7369 7a65 206f 6620 7468  = The size of th
-0000f480: 6520 6368 616d 6665 7273 206f 6e20 7468  e chamfers on th
-0000f490: 6520 656e 6473 206f 6620 7468 6520 6379  e ends of the cy
-0000f4a0: 6c69 6e64 6572 2e20 2044 6566 6175 6c74  linder.  Default
-0000f4b0: 3a20 6e6f 6e65 2e0a 2f2f 2020 2063 6861  : none..//   cha
-0000f4c0: 6d66 6572 3120 3d20 5468 6520 7369 7a65  mfer1 = The size
-0000f4d0: 206f 6620 7468 6520 6368 616d 6665 7220   of the chamfer 
-0000f4e0: 6f6e 2074 6865 2066 726f 6e74 2065 6e64  on the front end
-0000f4f0: 206f 6620 7468 6520 6379 6c69 6e64 6572   of the cylinder
-0000f500: 2e20 2044 6566 6175 6c74 3a20 6e6f 6e65  .  Default: none
-0000f510: 2e0a 2f2f 2020 2063 6861 6d66 6572 3220  ..//   chamfer2 
-0000f520: 3d20 5468 6520 7369 7a65 206f 6620 7468  = The size of th
-0000f530: 6520 6368 616d 6665 7220 6f6e 2074 6865  e chamfer on the
-0000f540: 2062 6163 6b20 656e 6420 6f66 2074 6865   back end of the
-0000f550: 2063 796c 696e 6465 722e 2020 4465 6661   cylinder.  Defa
-0000f560: 756c 743a 206e 6f6e 652e 0a2f 2f20 2020  ult: none..//   
-0000f570: 6368 616d 6661 6e67 203d 2054 6865 2061  chamfang = The a
-0000f580: 6e67 6c65 2069 6e20 6465 6772 6565 7320  ngle in degrees 
-0000f590: 6f66 2074 6865 2063 6861 6d66 6572 7320  of the chamfers 
-0000f5a0: 6f6e 2074 6865 2065 6e64 7320 6f66 2074  on the ends of t
-0000f5b0: 6865 2063 796c 696e 6465 722e 0a2f 2f20  he cylinder..// 
-0000f5c0: 2020 6368 616d 6661 6e67 3120 3d20 5468    chamfang1 = Th
-0000f5d0: 6520 616e 676c 6520 696e 2064 6567 7265  e angle in degre
-0000f5e0: 6573 206f 6620 7468 6520 6368 616d 6665  es of the chamfe
-0000f5f0: 7220 6f6e 2074 6865 2066 726f 6e74 2065  r on the front e
-0000f600: 6e64 206f 6620 7468 6520 6379 6c69 6e64  nd of the cylind
-0000f610: 6572 2e0a 2f2f 2020 2063 6861 6d66 616e  er..//   chamfan
-0000f620: 6732 203d 2054 6865 2061 6e67 6c65 2069  g2 = The angle i
-0000f630: 6e20 6465 6772 6565 7320 6f66 2074 6865  n degrees of the
-0000f640: 2063 6861 6d66 6572 206f 6e20 7468 6520   chamfer on the 
-0000f650: 6261 636b 2065 6e64 206f 6620 7468 6520  back end of the 
-0000f660: 6379 6c69 6e64 6572 2e0a 2f2f 2020 2066  cylinder..//   f
-0000f670: 726f 6d5f 656e 6420 3d20 4966 2074 7275  rom_end = If tru
-0000f680: 652c 2063 6861 6d66 6572 2069 7320 6d65  e, chamfer is me
-0000f690: 6173 7572 6564 2066 726f 6d20 7468 6520  asured from the 
-0000f6a0: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
-0000f6b0: 6465 722c 2069 6e73 7465 6164 206f 6620  der, instead of 
-0000f6c0: 696e 7365 7420 6672 6f6d 2074 6865 2065  inset from the e
-0000f6d0: 6467 652e 2020 4465 6661 756c 743a 2060  dge.  Default: `
-0000f6e0: 6661 6c73 6560 2e0a 2f2f 2020 2072 6f75  false`..//   rou
-0000f6f0: 6e64 696e 6720 3d20 5468 6520 7261 6469  nding = The radi
-0000f700: 7573 206f 6620 7468 6520 726f 756e 6469  us of the roundi
-0000f710: 6e67 206f 6e20 7468 6520 656e 6473 206f  ng on the ends o
-0000f720: 6620 7468 6520 6379 6c69 6e64 6572 2e20  f the cylinder. 
-0000f730: 2044 6566 6175 6c74 3a20 6e6f 6e65 2e0a   Default: none..
-0000f740: 2f2f 2020 2072 6f75 6e64 696e 6731 203d  //   rounding1 =
-0000f750: 2054 6865 2072 6164 6975 7320 6f66 2074   The radius of t
-0000f760: 6865 2072 6f75 6e64 696e 6720 6f6e 2074  he rounding on t
-0000f770: 6865 2066 726f 6e74 2065 6e64 206f 6620  he front end of 
-0000f780: 7468 6520 6379 6c69 6e64 6572 2e0a 2f2f  the cylinder..//
-0000f790: 2020 2072 6f75 6e64 696e 6732 203d 2054     rounding2 = T
-0000f7a0: 6865 2072 6164 6975 7320 6f66 2074 6865  he radius of the
-0000f7b0: 2072 6f75 6e64 696e 6720 6f6e 2074 6865   rounding on the
-0000f7c0: 2062 6163 6b20 656e 6420 6f66 2074 6865   back end of the
-0000f7d0: 2063 796c 696e 6465 722e 0a2f 2f20 2020   cylinder..//   
-0000f7e0: 7265 616c 6967 6e20 3d20 4966 2074 7275  realign = If tru
-0000f7f0: 652c 2072 6f74 6174 6520 7468 6520 6379  e, rotate the cy
-0000f800: 6c69 6e64 6572 2062 7920 6861 6c66 2074  linder by half t
-0000f810: 6865 2061 6e67 6c65 206f 6620 6f6e 6520  he angle of one 
-0000f820: 6661 6365 2e0a 2f2f 2020 2061 6e63 686f  face..//   ancho
-0000f830: 7220 3d20 5472 616e 736c 6174 6520 736f  r = Translate so
-0000f840: 2061 6e63 686f 7220 706f 696e 7420 6973   anchor point is
-0000f850: 2061 7420 6f72 6967 696e 2028 302c 302c   at origin (0,0,
-0000f860: 3029 2e20 2053 6565 205b 616e 6368 6f72  0).  See [anchor
-0000f870: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
-0000f880: 6164 2373 7562 7365 6374 696f 6e2d 616e  ad#subsection-an
-0000f890: 6368 6f72 292e 2020 4465 6661 756c 743a  chor).  Default:
-0000f8a0: 2060 4345 4e54 4552 600a 2f2f 2020 2073   `CENTER`.//   s
-0000f8b0: 7069 6e20 3d20 526f 7461 7465 2074 6869  pin = Rotate thi
-0000f8c0: 7320 6d61 6e79 2064 6567 7265 6573 2061  s many degrees a
-0000f8d0: 726f 756e 6420 7468 6520 5a20 6178 6973  round the Z axis
-0000f8e0: 2061 6674 6572 2061 6e63 686f 722e 2020   after anchor.  
-0000f8f0: 5365 6520 5b73 7069 6e5d 2861 7474 6163  See [spin](attac
-0000f900: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
-0000f910: 6563 7469 6f6e 2d73 7069 6e29 2e20 2044  ection-spin).  D
-0000f920: 6566 6175 6c74 3a20 6030 600a 2f2f 2020  efault: `0`.//  
-0000f930: 206f 7269 656e 7420 3d20 5665 6374 6f72   orient = Vector
-0000f940: 2074 6f20 726f 7461 7465 2074 6f70 2074   to rotate top t
-0000f950: 6f77 6172 6473 2c20 6166 7465 7220 7370  owards, after sp
-0000f960: 696e 2e20 2053 6565 205b 6f72 6965 6e74  in.  See [orient
-0000f970: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
-0000f980: 6164 2373 7562 7365 6374 696f 6e2d 6f72  ad#subsection-or
-0000f990: 6965 6e74 292e 2020 4465 6661 756c 743a  ient).  Default:
-0000f9a0: 2060 5550 600a 2f2f 0a2f 2f20 4578 616d   `UP`.//.// Exam
-0000f9b0: 706c 653a 2042 7920 5261 6469 7573 0a2f  ple: By Radius./
-0000f9c0: 2f20 2020 7864 6973 7472 6962 7574 6528  /   xdistribute(
-0000f9d0: 3530 2920 7b0a 2f2f 2020 2020 2020 2079  50) {.//       y
-0000f9e0: 6379 6c28 6c3d 3335 2c20 723d 3130 293b  cyl(l=35, r=10);
-0000f9f0: 0a2f 2f20 2020 2020 2020 7963 796c 286c  .//       ycyl(l
-0000fa00: 3d33 352c 2072 313d 3135 2c20 7232 3d35  =35, r1=15, r2=5
-0000fa10: 293b 0a2f 2f20 2020 7d0a 2f2f 0a2f 2f20  );.//   }.//.// 
-0000fa20: 4578 616d 706c 653a 2042 7920 4469 616d  Example: By Diam
-0000fa30: 6574 6572 0a2f 2f20 2020 7864 6973 7472  eter.//   xdistr
-0000fa40: 6962 7574 6528 3530 2920 7b0a 2f2f 2020  ibute(50) {.//  
-0000fa50: 2020 2020 2079 6379 6c28 6c3d 3335 2c20       ycyl(l=35, 
-0000fa60: 643d 3230 293b 0a2f 2f20 2020 2020 2020  d=20);.//       
-0000fa70: 7963 796c 286c 3d33 352c 2064 313d 3330  ycyl(l=35, d1=30
-0000fa80: 2c20 6432 3d31 3029 3b0a 2f2f 2020 207d  , d2=10);.//   }
-0000fa90: 0a6d 6f64 756c 6520 7963 796c 280a 2020  .module ycyl(.  
-0000faa0: 2020 682c 2072 2c20 642c 2072 312c 2072    h, r, d, r1, r
-0000fab0: 322c 2064 312c 2064 322c 206c 2c0a 2020  2, d1, d2, l,.  
-0000fac0: 2020 6368 616d 6665 722c 2063 6861 6d66    chamfer, chamf
-0000fad0: 6572 312c 2063 6861 6d66 6572 322c 0a20  er1, chamfer2,. 
-0000fae0: 2020 2063 6861 6d66 616e 672c 2063 6861     chamfang, cha
-0000faf0: 6d66 616e 6731 2c20 6368 616d 6661 6e67  mfang1, chamfang
-0000fb00: 322c 0a20 2020 2072 6f75 6e64 696e 672c  2,.    rounding,
-0000fb10: 2072 6f75 6e64 696e 6731 2c20 726f 756e   rounding1, roun
-0000fb20: 6469 6e67 322c 0a20 2020 2063 6972 6375  ding2,.    circu
-0000fb30: 6d3d 6661 6c73 652c 2072 6561 6c69 676e  m=false, realign
-0000fb40: 3d66 616c 7365 2c20 6672 6f6d 5f65 6e64  =false, from_end
-0000fb50: 3d66 616c 7365 2c0a 2020 2020 616e 6368  =false,.    anch
-0000fb60: 6f72 3d43 454e 5445 522c 2073 7069 6e3d  or=CENTER, spin=
-0000fb70: 302c 206f 7269 656e 743d 5550 0a29 207b  0, orient=UP.) {
-0000fb80: 0a20 2020 2072 3120 3d20 6765 745f 7261  .    r1 = get_ra
-0000fb90: 6469 7573 2872 313d 7231 2c20 723d 722c  dius(r1=r1, r=r,
-0000fba0: 2064 313d 6431 2c20 643d 642c 2064 666c   d1=d1, d=d, dfl
-0000fbb0: 743d 3129 3b0a 2020 2020 7232 203d 2067  t=1);.    r2 = g
-0000fbc0: 6574 5f72 6164 6975 7328 7231 3d72 322c  et_radius(r1=r2,
-0000fbd0: 2072 3d72 2c20 6431 3d64 322c 2064 3d64   r=r, d1=d2, d=d
-0000fbe0: 2c20 6466 6c74 3d31 293b 0a20 2020 206c  , dflt=1);.    l
-0000fbf0: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-0000fc00: 285b 6c2c 2068 2c20 315d 293b 0a20 2020  ([l, h, 1]);.   
-0000fc10: 2061 7474 6163 6861 626c 6528 616e 6368   attachable(anch
-0000fc20: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
-0000fc30: 7231 3d72 312c 2072 323d 7232 2c20 6c3d  r1=r1, r2=r2, l=
-0000fc40: 6c2c 2061 7869 733d 4241 434b 2920 7b0a  l, axis=BACK) {.
-0000fc50: 2020 2020 2020 2020 6379 6c28 0a20 2020          cyl(.   
-0000fc60: 2020 2020 2020 2020 206c 3d6c 2c20 7231           l=l, r1
-0000fc70: 3d72 312c 2072 323d 7232 2c0a 2020 2020  =r1, r2=r2,.    
-0000fc80: 2020 2020 2020 2020 6368 616d 6665 723d          chamfer=
-0000fc90: 6368 616d 6665 722c 2063 6861 6d66 6572  chamfer, chamfer
-0000fca0: 313d 6368 616d 6665 7231 2c20 6368 616d  1=chamfer1, cham
-0000fcb0: 6665 7232 3d63 6861 6d66 6572 322c 0a20  fer2=chamfer2,. 
-0000fcc0: 2020 2020 2020 2020 2020 2063 6861 6d66             chamf
-0000fcd0: 616e 673d 6368 616d 6661 6e67 2c20 6368  ang=chamfang, ch
-0000fce0: 616d 6661 6e67 313d 6368 616d 6661 6e67  amfang1=chamfang
-0000fcf0: 312c 2063 6861 6d66 616e 6732 3d63 6861  1, chamfang2=cha
-0000fd00: 6d66 616e 6732 2c0a 2020 2020 2020 2020  mfang2,.        
-0000fd10: 2020 2020 726f 756e 6469 6e67 3d72 6f75      rounding=rou
-0000fd20: 6e64 696e 672c 2072 6f75 6e64 696e 6731  nding, rounding1
-0000fd30: 3d72 6f75 6e64 696e 6731 2c20 726f 756e  =rounding1, roun
-0000fd40: 6469 6e67 323d 726f 756e 6469 6e67 322c  ding2=rounding2,
-0000fd50: 0a20 2020 2020 2020 2020 2020 2063 6972  .            cir
-0000fd60: 6375 6d3d 6369 7263 756d 2c20 7265 616c  cum=circum, real
-0000fd70: 6967 6e3d 7265 616c 6967 6e2c 2066 726f  ign=realign, fro
-0000fd80: 6d5f 656e 643d 6672 6f6d 5f65 6e64 2c0a  m_end=from_end,.
-0000fd90: 2020 2020 2020 2020 2020 2020 616e 6368              anch
-0000fda0: 6f72 3d43 454e 5445 522c 206f 7269 656e  or=CENTER, orien
-0000fdb0: 743d 4241 434b 0a20 2020 2020 2020 2029  t=BACK.        )
-0000fdc0: 3b0a 2020 2020 2020 2020 6368 696c 6472  ;.        childr
-0000fdd0: 656e 2829 3b0a 2020 2020 7d0a 7d0a 0a0a  en();.    }.}...
-0000fde0: 0a2f 2f20 4d6f 6475 6c65 3a20 7a63 796c  .// Module: zcyl
-0000fdf0: 2829 0a2f 2f0a 2f2f 2044 6573 6372 6970  ().//.// Descrip
-0000fe00: 7469 6f6e 3a0a 2f2f 2020 2043 7265 6174  tion:.//   Creat
-0000fe10: 6573 2061 2063 796c 696e 6465 7220 6f72  es a cylinder or
-0000fe20: 6965 6e74 6564 2061 6c6f 6e67 2074 6865  iented along the
-0000fe30: 205a 2061 7869 732e 0a2f 2f0a 2f2f 2055   Z axis..//.// U
-0000fe40: 7361 6765 3a20 5479 7069 6361 6c0a 2f2f  sage: Typical.//
-0000fe50: 2020 207a 6379 6c28 6c7c 682c 2072 7c64     zcyl(l|h, r|d
-0000fe60: 3d2c 205b 616e 6368 6f72 3d5d 2c2e 2e2e  =, [anchor=],...
-0000fe70: 2920 5b41 5454 4143 484d 454e 5453 5d3b  ) [ATTACHMENTS];
-0000fe80: 0a2f 2f20 2020 7a63 796c 286c 7c68 2c20  .//   zcyl(l|h, 
-0000fe90: 7231 3d7c 6431 3d2c 2072 323d 7c64 323d  r1=|d1=, r2=|d2=
-0000fea0: 2c20 5b61 6e63 686f 723d 5d2c 2e2e 2e29  , [anchor=],...)
-0000feb0: 3b0a 2f2f 0a2f 2f20 4172 6775 6d65 6e74  ;.//.// Argument
-0000fec0: 733a 0a2f 2f20 2020 6c20 2f20 6820 3d20  s:.//   l / h = 
-0000fed0: 4c65 6e67 7468 206f 6620 6379 6c69 6e64  Length of cylind
-0000fee0: 6572 2061 6c6f 6e67 206f 7269 656e 7465  er along oriente
-0000fef0: 6420 6178 6973 2e20 2844 6566 6175 6c74  d axis. (Default
-0000ff00: 3a20 312e 3029 0a2f 2f20 2020 7220 3d20  : 1.0).//   r = 
-0000ff10: 5261 6469 7573 206f 6620 6379 6c69 6e64  Radius of cylind
-0000ff20: 6572 2e0a 2f2f 2020 202d 2d2d 0a2f 2f20  er..//   ---.// 
-0000ff30: 2020 7231 203d 2052 6164 6975 7320 6f66    r1 = Radius of
-0000ff40: 2066 726f 6e74 2028 592d 2920 656e 6420   front (Y-) end 
-0000ff50: 6f66 2063 6f6e 652e 0a2f 2f20 2020 7232  of cone..//   r2
-0000ff60: 203d 2052 6164 6975 7320 6f66 2062 6163   = Radius of bac
-0000ff70: 6b20 2859 2b29 2065 6e64 206f 6620 6f6e  k (Y+) end of on
-0000ff80: 652e 0a2f 2f20 2020 6420 3d20 4469 616d  e..//   d = Diam
-0000ff90: 6574 6572 206f 6620 6379 6c69 6e64 6572  eter of cylinder
-0000ffa0: 2e0a 2f2f 2020 2064 3120 3d20 4469 616d  ..//   d1 = Diam
-0000ffb0: 6574 6572 206f 6620 6672 6f6e 7420 2859  eter of front (Y
-0000ffc0: 2d29 2065 6e64 206f 6620 6f6e 652e 0a2f  -) end of one../
-0000ffd0: 2f20 2020 6432 203d 2044 6961 6d65 7465  /   d2 = Diamete
-0000ffe0: 7220 6f66 2062 6163 6b20 2859 2b29 2065  r of back (Y+) e
-0000fff0: 6e64 206f 6620 6f6e 652e 0a2f 2f20 2020  nd of one..//   
-00010000: 6369 7263 756d 203d 2049 6620 7472 7565  circum = If true
-00010010: 2c20 6379 6c69 6e64 6572 2073 686f 756c  , cylinder shoul
-00010020: 6420 6369 7263 756d 7363 7269 6265 2074  d circumscribe t
-00010030: 6865 2063 6972 636c 6520 6f66 2074 6865  he circle of the
-00010040: 2067 6976 656e 2073 697a 652e 2020 4f74   given size.  Ot
-00010050: 6865 7277 6973 6520 696e 7363 7269 6265  herwise inscribe
-00010060: 732e 2020 4465 6661 756c 743a 2060 6661  s.  Default: `fa
-00010070: 6c73 6560 0a2f 2f20 2020 6368 616d 6665  lse`.//   chamfe
-00010080: 7220 3d20 5468 6520 7369 7a65 206f 6620  r = The size of 
-00010090: 7468 6520 6368 616d 6665 7273 206f 6e20  the chamfers on 
-000100a0: 7468 6520 656e 6473 206f 6620 7468 6520  the ends of the 
-000100b0: 6379 6c69 6e64 6572 2e20 2044 6566 6175  cylinder.  Defau
-000100c0: 6c74 3a20 6e6f 6e65 2e0a 2f2f 2020 2063  lt: none..//   c
-000100d0: 6861 6d66 6572 3120 3d20 5468 6520 7369  hamfer1 = The si
-000100e0: 7a65 206f 6620 7468 6520 6368 616d 6665  ze of the chamfe
-000100f0: 7220 6f6e 2074 6865 2062 6f74 746f 6d20  r on the bottom 
-00010100: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
-00010110: 6465 722e 2020 4465 6661 756c 743a 206e  der.  Default: n
-00010120: 6f6e 652e 0a2f 2f20 2020 6368 616d 6665  one..//   chamfe
-00010130: 7232 203d 2054 6865 2073 697a 6520 6f66  r2 = The size of
-00010140: 2074 6865 2063 6861 6d66 6572 206f 6e20   the chamfer on 
-00010150: 7468 6520 746f 7020 656e 6420 6f66 2074  the top end of t
-00010160: 6865 2063 796c 696e 6465 722e 2020 4465  he cylinder.  De
-00010170: 6661 756c 743a 206e 6f6e 652e 0a2f 2f20  fault: none..// 
-00010180: 2020 6368 616d 6661 6e67 203d 2054 6865    chamfang = The
-00010190: 2061 6e67 6c65 2069 6e20 6465 6772 6565   angle in degree
-000101a0: 7320 6f66 2074 6865 2063 6861 6d66 6572  s of the chamfer
-000101b0: 7320 6f6e 2074 6865 2065 6e64 7320 6f66  s on the ends of
-000101c0: 2074 6865 2063 796c 696e 6465 722e 0a2f   the cylinder../
-000101d0: 2f20 2020 6368 616d 6661 6e67 3120 3d20  /   chamfang1 = 
-000101e0: 5468 6520 616e 676c 6520 696e 2064 6567  The angle in deg
-000101f0: 7265 6573 206f 6620 7468 6520 6368 616d  rees of the cham
-00010200: 6665 7220 6f6e 2074 6865 2062 6f74 746f  fer on the botto
-00010210: 6d20 656e 6420 6f66 2074 6865 2063 796c  m end of the cyl
-00010220: 696e 6465 722e 0a2f 2f20 2020 6368 616d  inder..//   cham
-00010230: 6661 6e67 3220 3d20 5468 6520 616e 676c  fang2 = The angl
-00010240: 6520 696e 2064 6567 7265 6573 206f 6620  e in degrees of 
-00010250: 7468 6520 6368 616d 6665 7220 6f6e 2074  the chamfer on t
-00010260: 6865 2074 6f70 2065 6e64 206f 6620 7468  he top end of th
-00010270: 6520 6379 6c69 6e64 6572 2e0a 2f2f 2020  e cylinder..//  
-00010280: 2066 726f 6d5f 656e 6420 3d20 4966 2074   from_end = If t
-00010290: 7275 652c 2063 6861 6d66 6572 2069 7320  rue, chamfer is 
-000102a0: 6d65 6173 7572 6564 2066 726f 6d20 7468  measured from th
-000102b0: 6520 656e 6420 6f66 2074 6865 2063 796c  e end of the cyl
-000102c0: 696e 6465 722c 2069 6e73 7465 6164 206f  inder, instead o
-000102d0: 6620 696e 7365 7420 6672 6f6d 2074 6865  f inset from the
-000102e0: 2065 6467 652e 2020 4465 6661 756c 743a   edge.  Default:
-000102f0: 2060 6661 6c73 6560 2e0a 2f2f 2020 2072   `false`..//   r
-00010300: 6f75 6e64 696e 6720 3d20 5468 6520 7261  ounding = The ra
-00010310: 6469 7573 206f 6620 7468 6520 726f 756e  dius of the roun
-00010320: 6469 6e67 206f 6e20 7468 6520 656e 6473  ding on the ends
-00010330: 206f 6620 7468 6520 6379 6c69 6e64 6572   of the cylinder
-00010340: 2e20 2044 6566 6175 6c74 3a20 6e6f 6e65  .  Default: none
-00010350: 2e0a 2f2f 2020 2072 6f75 6e64 696e 6731  ..//   rounding1
-00010360: 203d 2054 6865 2072 6164 6975 7320 6f66   = The radius of
-00010370: 2074 6865 2072 6f75 6e64 696e 6720 6f6e   the rounding on
-00010380: 2074 6865 2062 6f74 746f 6d20 656e 6420   the bottom end 
-00010390: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
-000103a0: 0a2f 2f20 2020 726f 756e 6469 6e67 3220  .//   rounding2 
-000103b0: 3d20 5468 6520 7261 6469 7573 206f 6620  = The radius of 
-000103c0: 7468 6520 726f 756e 6469 6e67 206f 6e20  the rounding on 
-000103d0: 7468 6520 746f 7020 656e 6420 6f66 2074  the top end of t
-000103e0: 6865 2063 796c 696e 6465 722e 0a2f 2f20  he cylinder..// 
-000103f0: 2020 7265 616c 6967 6e20 3d20 4966 2074    realign = If t
-00010400: 7275 652c 2072 6f74 6174 6520 7468 6520  rue, rotate the 
-00010410: 6379 6c69 6e64 6572 2062 7920 6861 6c66  cylinder by half
-00010420: 2074 6865 2061 6e67 6c65 206f 6620 6f6e   the angle of on
-00010430: 6520 6661 6365 2e0a 2f2f 2020 2061 6e63  e face..//   anc
-00010440: 686f 7220 3d20 5472 616e 736c 6174 6520  hor = Translate 
-00010450: 736f 2061 6e63 686f 7220 706f 696e 7420  so anchor point 
-00010460: 6973 2061 7420 6f72 6967 696e 2028 302c  is at origin (0,
-00010470: 302c 3029 2e20 2053 6565 205b 616e 6368  0,0).  See [anch
-00010480: 6f72 5d28 6174 7461 6368 6d65 6e74 732e  or](attachments.
-00010490: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-000104a0: 616e 6368 6f72 292e 2020 4465 6661 756c  anchor).  Defaul
-000104b0: 743a 2060 4345 4e54 4552 600a 2f2f 2020  t: `CENTER`.//  
-000104c0: 2073 7069 6e20 3d20 526f 7461 7465 2074   spin = Rotate t
-000104d0: 6869 7320 6d61 6e79 2064 6567 7265 6573  his many degrees
-000104e0: 2061 726f 756e 6420 7468 6520 5a20 6178   around the Z ax
-000104f0: 6973 2061 6674 6572 2061 6e63 686f 722e  is after anchor.
-00010500: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
-00010510: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
-00010520: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
-00010530: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
-00010540: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
-00010550: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
-00010560: 2074 6f77 6172 6473 2c20 6166 7465 7220   towards, after 
-00010570: 7370 696e 2e20 2053 6565 205b 6f72 6965  spin.  See [orie
-00010580: 6e74 5d28 6174 7461 6368 6d65 6e74 732e  nt](attachments.
-00010590: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-000105a0: 6f72 6965 6e74 292e 2020 4465 6661 756c  orient).  Defaul
-000105b0: 743a 2060 5550 600a 2f2f 0a2f 2f20 4578  t: `UP`.//.// Ex
-000105c0: 616d 706c 653a 2042 7920 5261 6469 7573  ample: By Radius
-000105d0: 0a2f 2f20 2020 7864 6973 7472 6962 7574  .//   xdistribut
-000105e0: 6528 3530 2920 7b0a 2f2f 2020 2020 2020  e(50) {.//      
-000105f0: 207a 6379 6c28 6c3d 3335 2c20 723d 3130   zcyl(l=35, r=10
-00010600: 293b 0a2f 2f20 2020 2020 2020 7a63 796c  );.//       zcyl
-00010610: 286c 3d33 352c 2072 313d 3135 2c20 7232  (l=35, r1=15, r2
-00010620: 3d35 293b 0a2f 2f20 2020 7d0a 2f2f 0a2f  =5);.//   }.//./
-00010630: 2f20 4578 616d 706c 653a 2042 7920 4469  / Example: By Di
-00010640: 616d 6574 6572 0a2f 2f20 2020 7864 6973  ameter.//   xdis
-00010650: 7472 6962 7574 6528 3530 2920 7b0a 2f2f  tribute(50) {.//
-00010660: 2020 2020 2020 207a 6379 6c28 6c3d 3335         zcyl(l=35
-00010670: 2c20 643d 3230 293b 0a2f 2f20 2020 2020  , d=20);.//     
-00010680: 2020 7a63 796c 286c 3d33 352c 2064 313d    zcyl(l=35, d1=
-00010690: 3330 2c20 6432 3d31 3029 3b0a 2f2f 2020  30, d2=10);.//  
-000106a0: 207d 0a6d 6f64 756c 6520 7a63 796c 280a   }.module zcyl(.
-000106b0: 2020 2020 682c 2072 2c20 642c 2072 312c      h, r, d, r1,
-000106c0: 2072 322c 2064 312c 2064 322c 206c 2c0a   r2, d1, d2, l,.
-000106d0: 2020 2020 6368 616d 6665 722c 2063 6861      chamfer, cha
-000106e0: 6d66 6572 312c 2063 6861 6d66 6572 322c  mfer1, chamfer2,
-000106f0: 0a20 2020 2063 6861 6d66 616e 672c 2063  .    chamfang, c
-00010700: 6861 6d66 616e 6731 2c20 6368 616d 6661  hamfang1, chamfa
-00010710: 6e67 322c 0a20 2020 2072 6f75 6e64 696e  ng2,.    roundin
-00010720: 672c 2072 6f75 6e64 696e 6731 2c20 726f  g, rounding1, ro
-00010730: 756e 6469 6e67 322c 0a20 2020 2063 6972  unding2,.    cir
-00010740: 6375 6d3d 6661 6c73 652c 2072 6561 6c69  cum=false, reali
-00010750: 676e 3d66 616c 7365 2c20 6672 6f6d 5f65  gn=false, from_e
-00010760: 6e64 3d66 616c 7365 2c0a 2020 2020 616e  nd=false,.    an
-00010770: 6368 6f72 3d43 454e 5445 522c 2073 7069  chor=CENTER, spi
-00010780: 6e3d 302c 206f 7269 656e 743d 5550 0a29  n=0, orient=UP.)
-00010790: 207b 0a20 2020 2072 3120 3d20 6765 745f   {.    r1 = get_
-000107a0: 7261 6469 7573 2872 313d 7231 2c20 723d  radius(r1=r1, r=
-000107b0: 722c 2064 313d 6431 2c20 643d 642c 2064  r, d1=d1, d=d, d
-000107c0: 666c 743d 3129 3b0a 2020 2020 7232 203d  flt=1);.    r2 =
-000107d0: 2067 6574 5f72 6164 6975 7328 7231 3d72   get_radius(r1=r
-000107e0: 322c 2072 3d72 2c20 6431 3d64 322c 2064  2, r=r, d1=d2, d
-000107f0: 3d64 2c20 6466 6c74 3d31 293b 0a20 2020  =d, dflt=1);.   
-00010800: 206c 203d 2066 6972 7374 5f64 6566 696e   l = first_defin
-00010810: 6564 285b 6c2c 2068 2c20 315d 293b 0a20  ed([l, h, 1]);. 
-00010820: 2020 2061 7474 6163 6861 626c 6528 616e     attachable(an
-00010830: 6368 6f72 2c73 7069 6e2c 6f72 6965 6e74  chor,spin,orient
-00010840: 2c20 7231 3d72 312c 2072 323d 7232 2c20  , r1=r1, r2=r2, 
-00010850: 6c3d 6c29 207b 0a20 2020 2020 2020 2063  l=l) {.        c
-00010860: 796c 280a 2020 2020 2020 2020 2020 2020  yl(.            
-00010870: 6c3d 6c2c 2072 313d 7231 2c20 7232 3d72  l=l, r1=r1, r2=r
-00010880: 322c 0a20 2020 2020 2020 2020 2020 2063  2,.            c
-00010890: 6861 6d66 6572 3d63 6861 6d66 6572 2c20  hamfer=chamfer, 
-000108a0: 6368 616d 6665 7231 3d63 6861 6d66 6572  chamfer1=chamfer
-000108b0: 312c 2063 6861 6d66 6572 323d 6368 616d  1, chamfer2=cham
-000108c0: 6665 7232 2c0a 2020 2020 2020 2020 2020  fer2,.          
-000108d0: 2020 6368 616d 6661 6e67 3d63 6861 6d66    chamfang=chamf
-000108e0: 616e 672c 2063 6861 6d66 616e 6731 3d63  ang, chamfang1=c
-000108f0: 6861 6d66 616e 6731 2c20 6368 616d 6661  hamfang1, chamfa
-00010900: 6e67 323d 6368 616d 6661 6e67 322c 0a20  ng2=chamfang2,. 
-00010910: 2020 2020 2020 2020 2020 2072 6f75 6e64             round
-00010920: 696e 673d 726f 756e 6469 6e67 2c20 726f  ing=rounding, ro
-00010930: 756e 6469 6e67 313d 726f 756e 6469 6e67  unding1=rounding
-00010940: 312c 2072 6f75 6e64 696e 6732 3d72 6f75  1, rounding2=rou
-00010950: 6e64 696e 6732 2c0a 2020 2020 2020 2020  nding2,.        
-00010960: 2020 2020 6369 7263 756d 3d63 6972 6375      circum=circu
-00010970: 6d2c 2072 6561 6c69 676e 3d72 6561 6c69  m, realign=reali
-00010980: 676e 2c20 6672 6f6d 5f65 6e64 3d66 726f  gn, from_end=fro
-00010990: 6d5f 656e 642c 0a20 2020 2020 2020 2020  m_end,.         
-000109a0: 2020 2061 6e63 686f 723d 4345 4e54 4552     anchor=CENTER
-000109b0: 0a20 2020 2020 2020 2029 3b0a 2020 2020  .        );.    
-000109c0: 2020 2020 6368 696c 6472 656e 2829 3b0a      children();.
-000109d0: 2020 2020 7d0a 7d0a 0a0a 0a2f 2f20 4d6f      }.}....// Mo
-000109e0: 6475 6c65 3a20 7475 6265 2829 0a2f 2f0a  dule: tube().//.
-000109f0: 2f2f 2044 6573 6372 6970 7469 6f6e 3a0a  // Description:.
-00010a00: 2f2f 2020 204d 616b 6573 2061 2068 6f6c  //   Makes a hol
-00010a10: 6c6f 7720 7475 6265 2077 6974 6820 7468  low tube with th
-00010a20: 6520 6769 7665 6e20 6f75 7465 7220 7369  e given outer si
-00010a30: 7a65 2061 6e64 2077 616c 6c20 7468 6963  ze and wall thic
-00010a40: 6b6e 6573 732e 0a2f 2f0a 2f2f 2055 7361  kness..//.// Usa
-00010a50: 6765 3a20 5479 7069 6361 6c0a 2f2f 2020  ge: Typical.//  
-00010a60: 2074 7562 6528 687c 6c2c 206f 722c 2069   tube(h|l, or, i
-00010a70: 722c 205b 6365 6e74 6572 5d2c 205b 7265  r, [center], [re
-00010a80: 616c 6967 6e3d 5d29 3b0a 2f2f 2020 2074  align=]);.//   t
-00010a90: 7562 6528 687c 6c2c 206f 723d 7c6f 643d  ube(h|l, or=|od=
-00010aa0: 2c20 6972 3d7c 6964 3d2c 202e 2e2e 293b  , ir=|id=, ...);
-00010ab0: 0a2f 2f20 2020 7475 6265 2868 7c6c 2c20  .//   tube(h|l, 
-00010ac0: 6972 7c69 642c 2077 616c 6c2c 202e 2e2e  ir|id, wall, ...
-00010ad0: 293b 0a2f 2f20 2020 7475 6265 2868 7c6c  );.//   tube(h|l
-00010ae0: 2c20 6f72 7c6f 642c 2077 616c 6c2c 202e  , or|od, wall, .
-00010af0: 2e2e 293b 0a2f 2f20 2020 7475 6265 2868  ..);.//   tube(h
-00010b00: 7c6c 2c20 6972 317c 6964 312c 2069 7232  |l, ir1|id1, ir2
-00010b10: 7c69 6432 2c20 7761 6c6c 2c20 2e2e 2e29  |id2, wall, ...)
-00010b20: 3b0a 2f2f 2020 2074 7562 6528 687c 6c2c  ;.//   tube(h|l,
-00010b30: 206f 7231 7c6f 6431 2c20 6f72 327c 6f64   or1|od1, or2|od
-00010b40: 322c 2077 616c 6c2c 202e 2e2e 293b 0a2f  2, wall, ...);./
-00010b50: 2f20 2020 7475 6265 2868 7c6c 2c20 6972  /   tube(h|l, ir
-00010b60: 317c 6964 312c 2069 7232 7c69 6432 2c20  1|id1, ir2|id2, 
-00010b70: 6f72 317c 6f64 312c 206f 7232 7c6f 6432  or1|od1, or2|od2
-00010b80: 2c20 5b72 6561 6c69 676e 5d29 3b0a 2f2f  , [realign]);.//
-00010b90: 2055 7361 6765 3a20 4174 7461 6368 696e   Usage: Attachin
-00010ba0: 6720 4368 696c 6472 656e 0a2f 2f20 2020  g Children.//   
-00010bb0: 7475 6265 282e 2e2e 2920 4154 5441 4348  tube(...) ATTACH
-00010bc0: 4d45 4e54 533b 0a2f 2f0a 2f2f 2041 7267  MENTS;.//.// Arg
-00010bd0: 756d 656e 7473 3a0a 2f2f 2020 2068 202f  uments:.//   h /
-00010be0: 206c 203d 2068 6569 6768 7420 6f66 2074   l = height of t
-00010bf0: 7562 652e 2044 6566 6175 6c74 3a20 310a  ube. Default: 1.
-00010c00: 2f2f 2020 206f 7220 3d20 4f75 7465 7220  //   or = Outer 
-00010c10: 7261 6469 7573 206f 6620 7475 6265 2e20  radius of tube. 
-00010c20: 4465 6661 756c 743a 2031 0a2f 2f20 2020  Default: 1.//   
-00010c30: 6972 203d 2049 6e6e 6572 2072 6164 6975  ir = Inner radiu
-00010c40: 7320 6f66 2074 7562 652e 0a2f 2f20 2020  s of tube..//   
-00010c50: 6365 6e74 6572 203d 2049 6620 6769 7665  center = If give
-00010c60: 6e2c 206f 7665 7272 6964 6573 2060 616e  n, overrides `an
-00010c70: 6368 6f72 602e 2020 4120 7472 7565 2076  chor`.  A true v
-00010c80: 616c 7565 2073 6574 7320 6061 6e63 686f  alue sets `ancho
-00010c90: 723d 4345 4e54 4552 602c 2066 616c 7365  r=CENTER`, false
-00010ca0: 2073 6574 7320 6061 6e63 686f 723d 444f   sets `anchor=DO
-00010cb0: 574e 602e 0a2f 2f20 2020 2d2d 2d0a 2f2f  WN`..//   ---.//
-00010cc0: 2020 206f 6420 3d20 4f75 7465 7220 6469     od = Outer di
-00010cd0: 616d 6574 6572 206f 6620 7475 6265 2e0a  ameter of tube..
-00010ce0: 2f2f 2020 2069 6420 3d20 496e 6e65 7220  //   id = Inner 
-00010cf0: 6469 616d 6574 6572 206f 6620 7475 6265  diameter of tube
-00010d00: 2e0a 2f2f 2020 2077 616c 6c20 3d20 686f  ..//   wall = ho
-00010d10: 7269 7a6f 6e74 616c 2074 6869 636b 6e65  rizontal thickne
-00010d20: 7373 206f 6620 7475 6265 2077 616c 6c2e  ss of tube wall.
-00010d30: 2044 6566 6175 6c74 2031 0a2f 2f20 2020   Default 1.//   
-00010d40: 6f72 3120 3d20 4f75 7465 7220 7261 6469  or1 = Outer radi
-00010d50: 7573 206f 6620 626f 7474 6f6d 206f 6620  us of bottom of 
-00010d60: 7475 6265 2e20 2044 6566 6175 6c74 3a20  tube.  Default: 
-00010d70: 7661 6c75 6520 6f66 2072 290a 2f2f 2020  value of r).//  
-00010d80: 206f 7232 203d 204f 7574 6572 2072 6164   or2 = Outer rad
-00010d90: 6975 7320 6f66 2074 6f70 206f 6620 7475  ius of top of tu
-00010da0: 6265 2e20 2044 6566 6175 6c74 3a20 7661  be.  Default: va
-00010db0: 6c75 6520 6f66 2072 290a 2f2f 2020 206f  lue of r).//   o
-00010dc0: 6431 203d 204f 7574 6572 2064 6961 6d65  d1 = Outer diame
-00010dd0: 7465 7220 6f66 2062 6f74 746f 6d20 6f66  ter of bottom of
-00010de0: 2074 7562 652e 0a2f 2f20 2020 6f64 3220   tube..//   od2 
-00010df0: 3d20 4f75 7465 7220 6469 616d 6574 6572  = Outer diameter
-00010e00: 206f 6620 746f 7020 6f66 2074 7562 652e   of top of tube.
-00010e10: 0a2f 2f20 2020 6972 3120 3d20 496e 6e65  .//   ir1 = Inne
-00010e20: 7220 7261 6469 7573 206f 6620 626f 7474  r radius of bott
-00010e30: 6f6d 206f 6620 7475 6265 2e0a 2f2f 2020  om of tube..//  
-00010e40: 2069 7232 203d 2049 6e6e 6572 2072 6164   ir2 = Inner rad
-00010e50: 6975 7320 6f66 2074 6f70 206f 6620 7475  ius of top of tu
-00010e60: 6265 2e0a 2f2f 2020 2069 6431 203d 2049  be..//   id1 = I
-00010e70: 6e6e 6572 2064 6961 6d65 7465 7220 6f66  nner diameter of
-00010e80: 2062 6f74 746f 6d20 6f66 2074 7562 652e   bottom of tube.
-00010e90: 0a2f 2f20 2020 6964 3220 3d20 496e 6e65  .//   id2 = Inne
-00010ea0: 7220 6469 616d 6574 6572 206f 6620 746f  r diameter of to
-00010eb0: 7020 6f66 2074 7562 652e 0a2f 2f20 2020  p of tube..//   
-00010ec0: 7265 616c 6967 6e20 3d20 4966 2074 7275  realign = If tru
-00010ed0: 652c 2072 6f74 6174 6520 7468 6520 7475  e, rotate the tu
-00010ee0: 6265 2062 7920 6861 6c66 2074 6865 2061  be by half the a
-00010ef0: 6e67 6c65 206f 6620 6f6e 6520 6661 6365  ngle of one face
-00010f00: 2e0a 2f2f 2020 2061 6e63 686f 7220 3d20  ..//   anchor = 
-00010f10: 5472 616e 736c 6174 6520 736f 2061 6e63  Translate so anc
-00010f20: 686f 7220 706f 696e 7420 6973 2061 7420  hor point is at 
-00010f30: 6f72 6967 696e 2028 302c 302c 3029 2e20  origin (0,0,0). 
-00010f40: 2053 6565 205b 616e 6368 6f72 5d28 6174   See [anchor](at
-00010f50: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-00010f60: 7562 7365 6374 696f 6e2d 616e 6368 6f72  ubsection-anchor
-00010f70: 292e 2020 4465 6661 756c 743a 2060 4345  ).  Default: `CE
-00010f80: 4e54 4552 600a 2f2f 2020 2073 7069 6e20  NTER`.//   spin 
-00010f90: 3d20 526f 7461 7465 2074 6869 7320 6d61  = Rotate this ma
-00010fa0: 6e79 2064 6567 7265 6573 2061 726f 756e  ny degrees aroun
-00010fb0: 6420 7468 6520 5a20 6178 6973 2061 6674  d the Z axis aft
-00010fc0: 6572 2061 6e63 686f 722e 2020 5365 6520  er anchor.  See 
-00010fd0: 5b73 7069 6e5d 2861 7474 6163 686d 656e  [spin](attachmen
-00010fe0: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
-00010ff0: 6f6e 2d73 7069 6e29 2e20 2044 6566 6175  on-spin).  Defau
-00011000: 6c74 3a20 6030 600a 2f2f 2020 206f 7269  lt: `0`.//   ori
-00011010: 656e 7420 3d20 5665 6374 6f72 2074 6f20  ent = Vector to 
-00011020: 726f 7461 7465 2074 6f70 2074 6f77 6172  rotate top towar
-00011030: 6473 2c20 6166 7465 7220 7370 696e 2e20  ds, after spin. 
-00011040: 2053 6565 205b 6f72 6965 6e74 5d28 6174   See [orient](at
-00011050: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-00011060: 7562 7365 6374 696f 6e2d 6f72 6965 6e74  ubsection-orient
-00011070: 292e 2020 4465 6661 756c 743a 2060 5550  ).  Default: `UP
-00011080: 600a 2f2f 0a2f 2f20 4578 616d 706c 653a  `.//.// Example:
-00011090: 2054 6865 7365 2061 6c6c 2050 726f 6475   These all Produ
-000110a0: 6365 2074 6865 2053 616d 6520 5475 6265  ce the Same Tube
-000110b0: 0a2f 2f20 2020 7475 6265 2868 3d33 302c  .//   tube(h=30,
-000110c0: 206f 723d 3430 2c20 7761 6c6c 3d35 293b   or=40, wall=5);
-000110d0: 0a2f 2f20 2020 7475 6265 2868 3d33 302c  .//   tube(h=30,
-000110e0: 2069 723d 3335 2c20 7761 6c6c 3d35 293b   ir=35, wall=5);
-000110f0: 0a2f 2f20 2020 7475 6265 2868 3d33 302c  .//   tube(h=30,
-00011100: 206f 723d 3430 2c20 6972 3d33 3529 3b0a   or=40, ir=35);.
-00011110: 2f2f 2020 2074 7562 6528 683d 3330 2c20  //   tube(h=30, 
-00011120: 6f64 3d38 302c 2069 643d 3730 293b 0a2f  od=80, id=70);./
-00011130: 2f20 4578 616d 706c 653a 2054 6865 7365  / Example: These
-00011140: 2061 6c6c 2050 726f 6475 6365 2074 6865   all Produce the
-00011150: 2053 616d 6520 436f 6e69 6361 6c20 5475   Same Conical Tu
-00011160: 6265 0a2f 2f20 2020 7475 6265 2868 3d33  be.//   tube(h=3
-00011170: 302c 206f 7231 3d34 302c 206f 7232 3d32  0, or1=40, or2=2
-00011180: 352c 2077 616c 6c3d 3529 3b0a 2f2f 2020  5, wall=5);.//  
-00011190: 2074 7562 6528 683d 3330 2c20 6972 313d   tube(h=30, ir1=
-000111a0: 3335 2c20 6f72 323d 3230 2c20 7761 6c6c  35, or2=20, wall
-000111b0: 3d35 293b 0a2f 2f20 2020 7475 6265 2868  =5);.//   tube(h
-000111c0: 3d33 302c 206f 7231 3d34 302c 206f 7232  =30, or1=40, or2
-000111d0: 3d32 352c 2069 7231 3d33 352c 2069 7232  =25, ir1=35, ir2
-000111e0: 3d32 3029 3b0a 2f2f 2045 7861 6d70 6c65  =20);.// Example
-000111f0: 3a20 4369 7263 756c 6172 2057 6564 6765  : Circular Wedge
-00011200: 0a2f 2f20 2020 7475 6265 2868 3d33 302c  .//   tube(h=30,
-00011210: 206f 7231 3d34 302c 206f 7232 3d33 302c   or1=40, or2=30,
-00011220: 2069 7231 3d32 302c 2069 7232 3d33 3029   ir1=20, ir2=30)
-00011230: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 5374  ;.// Example: St
-00011240: 616e 6461 7264 2043 6f6e 6e65 6374 6f72  andard Connector
-00011250: 730a 2f2f 2020 2074 7562 6528 683d 3330  s.//   tube(h=30
-00011260: 2c20 6f72 3d34 302c 2077 616c 6c3d 3529  , or=40, wall=5)
-00011270: 2073 686f 775f 616e 6368 6f72 7328 293b   show_anchors();
-00011280: 0a6d 6f64 756c 6520 7475 6265 280a 2020  .module tube(.  
-00011290: 2020 682c 206f 722c 2069 722c 2063 656e    h, or, ir, cen
-000112a0: 7465 722c 0a20 2020 206f 642c 2069 642c  ter,.    od, id,
-000112b0: 2077 616c 6c2c 0a20 2020 206f 7231 2c20   wall,.    or1, 
-000112c0: 6f72 322c 206f 6431 2c20 6f64 322c 0a20  or2, od1, od2,. 
-000112d0: 2020 2069 7231 2c20 6972 322c 2069 6431     ir1, ir2, id1
-000112e0: 2c20 6964 322c 0a20 2020 2072 6561 6c69  , id2,.    reali
-000112f0: 676e 3d66 616c 7365 2c20 6c2c 0a20 2020  gn=false, l,.   
-00011300: 2061 6e63 686f 722c 2073 7069 6e3d 302c   anchor, spin=0,
-00011310: 206f 7269 656e 743d 5550 0a29 207b 0a20   orient=UP.) {. 
-00011320: 2020 2068 203d 2066 6972 7374 5f64 6566     h = first_def
-00011330: 696e 6564 285b 682c 6c2c 315d 293b 0a20  ined([h,l,1]);. 
-00011340: 2020 206f 7272 3120 3d20 6765 745f 7261     orr1 = get_ra
-00011350: 6469 7573 2872 313d 6f72 312c 2072 3d6f  dius(r1=or1, r=o
-00011360: 722c 2064 313d 6f64 312c 2064 3d6f 642c  r, d1=od1, d=od,
-00011370: 2064 666c 743d 756e 6465 6629 3b0a 2020   dflt=undef);.  
-00011380: 2020 6f72 7232 203d 2067 6574 5f72 6164    orr2 = get_rad
-00011390: 6975 7328 7231 3d6f 7232 2c20 723d 6f72  ius(r1=or2, r=or
-000113a0: 2c20 6431 3d6f 6432 2c20 643d 6f64 2c20  , d1=od2, d=od, 
-000113b0: 6466 6c74 3d75 6e64 6566 293b 0a20 2020  dflt=undef);.   
-000113c0: 2069 7272 3120 3d20 6765 745f 7261 6469   irr1 = get_radi
-000113d0: 7573 2872 313d 6972 312c 2072 3d69 722c  us(r1=ir1, r=ir,
-000113e0: 2064 313d 6964 312c 2064 3d69 642c 2064   d1=id1, d=id, d
-000113f0: 666c 743d 756e 6465 6629 3b0a 2020 2020  flt=undef);.    
-00011400: 6972 7232 203d 2067 6574 5f72 6164 6975  irr2 = get_radiu
-00011410: 7328 7231 3d69 7232 2c20 723d 6972 2c20  s(r1=ir2, r=ir, 
-00011420: 6431 3d69 6432 2c20 643d 6964 2c20 6466  d1=id2, d=id, df
-00011430: 6c74 3d75 6e64 6566 293b 0a20 2020 2077  lt=undef);.    w
-00011440: 616c 6c20 3d20 6465 6661 756c 7428 7761  all = default(wa
-00011450: 6c6c 2c20 3129 3b0a 2020 2020 7231 203d  ll, 1);.    r1 =
-00011460: 2064 6566 6175 6c74 286f 7272 312c 2075   default(orr1, u
-00011470: 5f61 6464 2869 7272 312c 7761 6c6c 2929  _add(irr1,wall))
-00011480: 3b0a 2020 2020 7232 203d 2064 6566 6175  ;.    r2 = defau
-00011490: 6c74 286f 7272 322c 2075 5f61 6464 2869  lt(orr2, u_add(i
-000114a0: 7272 322c 7761 6c6c 2929 3b0a 2020 2020  rr2,wall));.    
-000114b0: 6972 3120 3d20 6465 6661 756c 7428 6972  ir1 = default(ir
-000114c0: 7231 2c20 755f 7375 6228 6f72 7231 2c77  r1, u_sub(orr1,w
-000114d0: 616c 6c29 293b 0a20 2020 2069 7232 203d  all));.    ir2 =
-000114e0: 2064 6566 6175 6c74 2869 7272 322c 2075   default(irr2, u
-000114f0: 5f73 7562 286f 7272 322c 7761 6c6c 2929  _sub(orr2,wall))
-00011500: 3b0a 2020 2020 6368 6563 6b73 203d 0a20  ;.    checks =. 
-00011510: 2020 2020 2020 2061 7373 6572 7428 616c         assert(al
-00011520: 6c5f 6465 6669 6e65 6428 5b72 312c 2072  l_defined([r1, r
-00011530: 322c 2069 7231 2c20 6972 325d 292c 2022  2, ir1, ir2]), "
-00011540: 4d75 7374 2073 7065 6369 6679 2074 776f  Must specify two
-00011550: 206f 6620 696e 6e65 7220 7261 6469 7573   of inner radius
-00011560: 2f64 6961 6d2c 206f 7574 6572 2072 6164  /diam, outer rad
-00011570: 6975 732f 6469 616d 2c20 616e 6420 7761  ius/diam, and wa
-00011580: 6c6c 2077 6964 7468 2e22 290a 2020 2020  ll width.").    
-00011590: 2020 2020 6173 7365 7274 2869 7231 203c      assert(ir1 <
-000115a0: 3d20 7231 2c20 2249 6e6e 6572 2072 6164  = r1, "Inner rad
-000115b0: 6975 7320 6973 206c 6172 6765 7220 7468  ius is larger th
-000115c0: 616e 206f 7574 6572 2072 6164 6975 732e  an outer radius.
-000115d0: 2229 0a20 2020 2020 2020 2061 7373 6572  ").        asser
-000115e0: 7428 6972 3220 3c3d 2072 322c 2022 496e  t(ir2 <= r2, "In
-000115f0: 6e65 7220 7261 6469 7573 2069 7320 6c61  ner radius is la
-00011600: 7267 6572 2074 6861 6e20 6f75 7465 7220  rger than outer 
-00011610: 7261 6469 7573 2e22 293b 0a20 2020 2073  radius.");.    s
-00011620: 6964 6573 203d 2073 6567 7328 6d61 7828  ides = segs(max(
-00011630: 7231 2c72 3229 293b 0a20 2020 2061 6e63  r1,r2));.    anc
-00011640: 686f 7220 3d20 6765 745f 616e 6368 6f72  hor = get_anchor
-00011650: 2861 6e63 686f 722c 2063 656e 7465 722c  (anchor, center,
-00011660: 2042 4f54 2c20 4345 4e54 4552 293b 0a20   BOT, CENTER);. 
-00011670: 2020 2061 7474 6163 6861 626c 6528 616e     attachable(an
-00011680: 6368 6f72 2c73 7069 6e2c 6f72 6965 6e74  chor,spin,orient
-00011690: 2c20 7231 3d72 312c 2072 323d 7232 2c20  , r1=r1, r2=r2, 
-000116a0: 6c3d 6829 207b 0a20 2020 2020 2020 207a  l=h) {.        z
-000116b0: 726f 7428 7265 616c 6967 6e3f 2031 3830  rot(realign? 180
-000116c0: 2f73 6964 6573 203a 2030 2920 7b0a 2020  /sides : 0) {.  
-000116d0: 2020 2020 2020 2020 2020 6469 6666 6572            differ
-000116e0: 656e 6365 2829 207b 0a20 2020 2020 2020  ence() {.       
-000116f0: 2020 2020 2020 2020 2063 796c 2868 3d68           cyl(h=h
-00011700: 2c20 7231 3d72 312c 2072 323d 7232 2c20  , r1=r1, r2=r2, 
-00011710: 2466 6e3d 7369 6465 7329 2063 6869 6c64  $fn=sides) child
-00011720: 7265 6e28 293b 0a20 2020 2020 2020 2020  ren();.         
-00011730: 2020 2020 2020 2063 796c 2868 3d68 2b30         cyl(h=h+0
-00011740: 2e30 352c 2072 313d 6972 312c 2072 323d  .05, r1=ir1, r2=
-00011750: 6972 3229 3b0a 2020 2020 2020 2020 2020  ir2);.          
-00011760: 2020 7d0a 2020 2020 2020 2020 7d0a 2020    }.        }.  
-00011770: 2020 2020 2020 6368 696c 6472 656e 2829        children()
-00011780: 3b0a 2020 2020 7d0a 7d0a 0a0a 0a2f 2f20  ;.    }.}....// 
-00011790: 4675 6e63 7469 6f6e 264d 6f64 756c 653a  Function&Module:
-000117a0: 2070 6965 5f73 6c69 6365 2829 0a2f 2f0a   pie_slice().//.
-000117b0: 2f2f 2044 6573 6372 6970 7469 6f6e 3a0a  // Description:.
-000117c0: 2f2f 2020 2043 7265 6174 6573 2061 2070  //   Creates a p
-000117d0: 6965 2073 6c69 6365 2073 6861 7065 2e0a  ie slice shape..
-000117e0: 2f2f 0a2f 2f20 5573 6167 653a 2041 7320  //.// Usage: As 
-000117f0: 4d6f 6475 6c65 0a2f 2f20 2020 7069 655f  Module.//   pie_
-00011800: 736c 6963 6528 6c7c 682c 2072 2c20 616e  slice(l|h, r, an
-00011810: 672c 205b 6365 6e74 6572 5d29 3b0a 2f2f  g, [center]);.//
-00011820: 2020 2070 6965 5f73 6c69 6365 286c 7c68     pie_slice(l|h
-00011830: 2c20 643d 2c20 616e 673d 2c20 2e2e 2e29  , d=, ang=, ...)
-00011840: 3b0a 2f2f 2020 2070 6965 5f73 6c69 6365  ;.//   pie_slice
-00011850: 286c 7c68 2c20 7231 3d7c 6431 3d2c 2072  (l|h, r1=|d1=, r
-00011860: 323d 7c64 323d 2c20 616e 673d 2c20 2e2e  2=|d2=, ang=, ..
-00011870: 2e29 3b0a 2f2f 2055 7361 6765 3a20 4173  .);.// Usage: As
-00011880: 2046 756e 6374 696f 6e0a 2f2f 2020 2076   Function.//   v
-00011890: 6e66 203d 2070 6965 5f73 6c69 6365 286c  nf = pie_slice(l
-000118a0: 7c68 2c20 722c 2061 6e67 2c20 5b63 656e  |h, r, ang, [cen
-000118b0: 7465 725d 293b 0a2f 2f20 2020 766e 6620  ter]);.//   vnf 
-000118c0: 3d20 7069 655f 736c 6963 6528 6c7c 682c  = pie_slice(l|h,
-000118d0: 2064 3d2c 2061 6e67 3d2c 202e 2e2e 293b   d=, ang=, ...);
-000118e0: 0a2f 2f20 2020 766e 6620 3d20 7069 655f  .//   vnf = pie_
-000118f0: 736c 6963 6528 6c7c 682c 2072 313d 7c64  slice(l|h, r1=|d
-00011900: 313d 2c20 7232 3d7c 6432 3d2c 2061 6e67  1=, r2=|d2=, ang
-00011910: 3d2c 202e 2e2e 293b 0a2f 2f20 5573 6167  =, ...);.// Usag
-00011920: 653a 2041 7474 6163 6869 6e67 2043 6869  e: Attaching Chi
-00011930: 6c64 7265 6e0a 2f2f 2020 2070 6965 5f73  ldren.//   pie_s
-00011940: 6c69 6365 286c 7c68 2c20 722c 2061 6e67  lice(l|h, r, ang
-00011950: 2c20 2e2e 2e29 2041 5454 4143 484d 454e  , ...) ATTACHMEN
-00011960: 5453 3b0a 2f2f 0a2f 2f20 4172 6775 6d65  TS;.//.// Argume
-00011970: 6e74 733a 0a2f 2f20 2020 6820 2f20 6c20  nts:.//   h / l 
-00011980: 3d20 6865 6967 6874 206f 6620 7069 6520  = height of pie 
-00011990: 736c 6963 652e 0a2f 2f20 2020 7220 3d20  slice..//   r = 
-000119a0: 7261 6469 7573 206f 6620 7069 6520 736c  radius of pie sl
-000119b0: 6963 652e 0a2f 2f20 2020 616e 6720 3d20  ice..//   ang = 
-000119c0: 7069 6520 736c 6963 6520 616e 676c 6520  pie slice angle 
-000119d0: 696e 2064 6567 7265 6573 2e0a 2f2f 2020  in degrees..//  
-000119e0: 2063 656e 7465 7220 3d20 4966 2067 6976   center = If giv
-000119f0: 656e 2c20 6f76 6572 7269 6465 7320 6061  en, overrides `a
-00011a00: 6e63 686f 7260 2e20 2041 2074 7275 6520  nchor`.  A true 
-00011a10: 7661 6c75 6520 7365 7473 2060 616e 6368  value sets `anch
-00011a20: 6f72 3d43 454e 5445 5260 2c20 6661 6c73  or=CENTER`, fals
-00011a30: 6520 7365 7473 2060 616e 6368 6f72 3d55  e sets `anchor=U
-00011a40: 5060 2e0a 2f2f 2020 202d 2d2d 0a2f 2f20  P`..//   ---.// 
-00011a50: 2020 7231 203d 2062 6f74 746f 6d20 7261    r1 = bottom ra
-00011a60: 6469 7573 206f 6620 7069 6520 736c 6963  dius of pie slic
-00011a70: 652e 0a2f 2f20 2020 7232 203d 2074 6f70  e..//   r2 = top
-00011a80: 2072 6164 6975 7320 6f66 2070 6965 2073   radius of pie s
-00011a90: 6c69 6365 2e0a 2f2f 2020 2064 203d 2064  lice..//   d = d
-00011aa0: 6961 6d65 7465 7220 6f66 2070 6965 2073  iameter of pie s
-00011ab0: 6c69 6365 2e0a 2f2f 2020 2064 3120 3d20  lice..//   d1 = 
-00011ac0: 626f 7474 6f6d 2064 6961 6d65 7465 7220  bottom diameter 
-00011ad0: 6f66 2070 6965 2073 6c69 6365 2e0a 2f2f  of pie slice..//
-00011ae0: 2020 2064 3220 3d20 746f 7020 6469 616d     d2 = top diam
-00011af0: 6574 6572 206f 6620 7069 6520 736c 6963  eter of pie slic
-00011b00: 652e 0a2f 2f20 2020 616e 6368 6f72 203d  e..//   anchor =
-00011b10: 2054 7261 6e73 6c61 7465 2073 6f20 616e   Translate so an
-00011b20: 6368 6f72 2070 6f69 6e74 2069 7320 6174  chor point is at
-00011b30: 206f 7269 6769 6e20 2830 2c30 2c30 292e   origin (0,0,0).
-00011b40: 2020 5365 6520 5b61 6e63 686f 725d 2861    See [anchor](a
-00011b50: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
-00011b60: 7375 6273 6563 7469 6f6e 2d61 6e63 686f  subsection-ancho
-00011b70: 7229 2e20 2044 6566 6175 6c74 3a20 6043  r).  Default: `C
-00011b80: 454e 5445 5260 0a2f 2f20 2020 7370 696e  ENTER`.//   spin
-00011b90: 203d 2052 6f74 6174 6520 7468 6973 206d   = Rotate this m
-00011ba0: 616e 7920 6465 6772 6565 7320 6172 6f75  any degrees arou
-00011bb0: 6e64 2074 6865 205a 2061 7869 7320 6166  nd the Z axis af
-00011bc0: 7465 7220 616e 6368 6f72 2e20 2053 6565  ter anchor.  See
-00011bd0: 205b 7370 696e 5d28 6174 7461 6368 6d65   [spin](attachme
-00011be0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
-00011bf0: 696f 6e2d 7370 696e 292e 2020 4465 6661  ion-spin).  Defa
-00011c00: 756c 743a 2060 3060 0a2f 2f20 2020 6f72  ult: `0`.//   or
-00011c10: 6965 6e74 203d 2056 6563 746f 7220 746f  ient = Vector to
-00011c20: 2072 6f74 6174 6520 746f 7020 746f 7761   rotate top towa
-00011c30: 7264 732c 2061 6674 6572 2073 7069 6e2e  rds, after spin.
-00011c40: 2020 5365 6520 5b6f 7269 656e 745d 2861    See [orient](a
-00011c50: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
-00011c60: 7375 6273 6563 7469 6f6e 2d6f 7269 656e  subsection-orien
-00011c70: 7429 2e20 2044 6566 6175 6c74 3a20 6055  t).  Default: `U
-00011c80: 5060 0a2f 2f0a 2f2f 2045 7861 6d70 6c65  P`.//.// Example
-00011c90: 3a20 4379 6c69 6e64 7269 6361 6c20 5069  : Cylindrical Pi
-00011ca0: 6520 536c 6963 650a 2f2f 2020 2070 6965  e Slice.//   pie
-00011cb0: 5f73 6c69 6365 2861 6e67 3d34 352c 206c  _slice(ang=45, l
-00011cc0: 3d32 302c 2072 3d33 3029 3b0a 2f2f 2045  =20, r=30);.// E
-00011cd0: 7861 6d70 6c65 3a20 436f 6e69 6361 6c20  xample: Conical 
-00011ce0: 5069 6520 536c 6963 650a 2f2f 2020 2070  Pie Slice.//   p
-00011cf0: 6965 5f73 6c69 6365 2861 6e67 3d36 302c  ie_slice(ang=60,
-00011d00: 206c 3d32 302c 2064 313d 3530 2c20 6432   l=20, d1=50, d2
-00011d10: 3d37 3029 3b0a 2f2f 2045 7861 6d70 6c65  =70);.// Example
-00011d20: 3a20 4269 6720 536c 6963 650a 2f2f 2020  : Big Slice.//  
-00011d30: 2070 6965 5f73 6c69 6365 2861 6e67 3d33   pie_slice(ang=3
-00011d40: 3030 2c20 6c3d 3230 2c20 6431 3d35 302c  00, l=20, d1=50,
-00011d50: 2064 323d 3730 293b 0a2f 2f20 4578 616d   d2=70);.// Exam
-00011d60: 706c 653a 2047 656e 6572 6174 696e 6720  ple: Generating 
-00011d70: 6120 564e 460a 2f2f 2020 2076 6e66 203d  a VNF.//   vnf =
-00011d80: 2070 6965 5f73 6c69 6365 2861 6e67 3d31   pie_slice(ang=1
-00011d90: 3530 2c20 6c3d 3230 2c20 7231 3d33 302c  50, l=20, r1=30,
-00011da0: 2072 323d 3530 293b 0a2f 2f20 2020 766e   r2=50);.//   vn
-00011db0: 665f 706f 6c79 6865 6472 6f6e 2876 6e66  f_polyhedron(vnf
-00011dc0: 293b 0a6d 6f64 756c 6520 7069 655f 736c  );.module pie_sl
-00011dd0: 6963 6528 0a20 2020 2068 2c20 722c 2061  ice(.    h, r, a
-00011de0: 6e67 3d33 302c 2063 656e 7465 722c 0a20  ng=30, center,. 
-00011df0: 2020 2072 312c 2072 322c 2064 2c20 6431     r1, r2, d, d1
-00011e00: 2c20 6432 2c20 6c2c 0a20 2020 2061 6e63  , d2, l,.    anc
-00011e10: 686f 722c 2073 7069 6e3d 302c 206f 7269  hor, spin=0, ori
-00011e20: 656e 743d 5550 0a29 207b 0a20 2020 206c  ent=UP.) {.    l
-00011e30: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-00011e40: 285b 6c2c 2068 2c20 315d 293b 0a20 2020  ([l, h, 1]);.   
-00011e50: 2072 3120 3d20 6765 745f 7261 6469 7573   r1 = get_radius
-00011e60: 2872 313d 7231 2c20 723d 722c 2064 313d  (r1=r1, r=r, d1=
-00011e70: 6431 2c20 643d 642c 2064 666c 743d 3130  d1, d=d, dflt=10
-00011e80: 293b 0a20 2020 2072 3220 3d20 6765 745f  );.    r2 = get_
-00011e90: 7261 6469 7573 2872 313d 7232 2c20 723d  radius(r1=r2, r=
-00011ea0: 722c 2064 313d 6432 2c20 643d 642c 2064  r, d1=d2, d=d, d
-00011eb0: 666c 743d 3130 293b 0a20 2020 206d 6178  flt=10);.    max
-00011ec0: 6420 3d20 6d61 7828 7231 2c72 3229 2b30  d = max(r1,r2)+0
-00011ed0: 2e31 3b0a 2020 2020 616e 6368 6f72 203d  .1;.    anchor =
-00011ee0: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
-00011ef0: 6f72 2c20 6365 6e74 6572 2c20 424f 542c  or, center, BOT,
-00011f00: 2042 4f54 293b 0a20 2020 2061 7474 6163   BOT);.    attac
-00011f10: 6861 626c 6528 616e 6368 6f72 2c73 7069  hable(anchor,spi
-00011f20: 6e2c 6f72 6965 6e74 2c20 7231 3d72 312c  n,orient, r1=r1,
-00011f30: 2072 323d 7232 2c20 6c3d 6c29 207b 0a20   r2=r2, l=l) {. 
-00011f40: 2020 2020 2020 2064 6966 6665 7265 6e63         differenc
-00011f50: 6528 2920 7b0a 2020 2020 2020 2020 2020  e() {.          
-00011f60: 2020 6379 6c28 7231 3d72 312c 2072 323d    cyl(r1=r1, r2=
-00011f70: 7232 2c20 683d 6c29 3b0a 2020 2020 2020  r2, h=l);.      
-00011f80: 2020 2020 2020 6966 2028 616e 673c 3138        if (ang<18
-00011f90: 3029 2072 6f74 6174 6528 616e 6729 2062  0) rotate(ang) b
-00011fa0: 6163 6b28 6d61 7864 2f32 2920 6375 6265  ack(maxd/2) cube
-00011fb0: 285b 322a 6d61 7864 2c20 6d61 7864 2c20  ([2*maxd, maxd, 
-00011fc0: 6c2b 302e 315d 2c20 6365 6e74 6572 3d74  l+0.1], center=t
-00011fd0: 7275 6529 3b0a 2020 2020 2020 2020 2020  rue);.          
-00011fe0: 2020 6469 6666 6572 656e 6365 2829 207b    difference() {
-00011ff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012000: 2066 7764 286d 6178 642f 3229 2063 7562   fwd(maxd/2) cub
-00012010: 6528 5b32 2a6d 6178 642c 206d 6178 642c  e([2*maxd, maxd,
-00012020: 206c 2b30 2e32 5d2c 2063 656e 7465 723d   l+0.2], center=
-00012030: 7472 7565 293b 0a20 2020 2020 2020 2020  true);.         
-00012040: 2020 2020 2020 2069 6620 2861 6e67 3e31         if (ang>1
-00012050: 3830 2920 726f 7461 7465 2861 6e67 2d31  80) rotate(ang-1
-00012060: 3830 2920 6261 636b 286d 6178 642f 3229  80) back(maxd/2)
-00012070: 2063 7562 6528 5b32 2a6d 6178 642c 206d   cube([2*maxd, m
-00012080: 6178 642c 206c 2b30 2e31 5d2c 2063 656e  axd, l+0.1], cen
-00012090: 7465 723d 7472 7565 293b 0a20 2020 2020  ter=true);.     
-000120a0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-000120b0: 207d 0a20 2020 2020 2020 2063 6869 6c64   }.        child
-000120c0: 7265 6e28 293b 0a20 2020 207d 0a7d 0a0a  ren();.    }.}..
-000120d0: 0a66 756e 6374 696f 6e20 7069 655f 736c  .function pie_sl
-000120e0: 6963 6528 0a20 2020 2068 2c20 722c 2061  ice(.    h, r, a
-000120f0: 6e67 3d33 302c 2063 656e 7465 722c 0a20  ng=30, center,. 
-00012100: 2020 2072 312c 2072 322c 2064 2c20 6431     r1, r2, d, d1
-00012110: 2c20 6432 2c20 6c2c 0a20 2020 2061 6e63  , d2, l,.    anc
-00012120: 686f 722c 2073 7069 6e3d 302c 206f 7269  hor, spin=0, ori
-00012130: 656e 743d 5550 0a29 203d 206c 6574 280a  ent=UP.) = let(.
-00012140: 2020 2020 2020 2020 616e 6368 6f72 203d          anchor =
-00012150: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
-00012160: 6f72 2c20 6365 6e74 6572 2c20 424f 542c  or, center, BOT,
-00012170: 2042 4f54 292c 0a20 2020 2020 2020 206c   BOT),.        l
-00012180: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-00012190: 285b 6c2c 2068 2c20 315d 292c 0a20 2020  ([l, h, 1]),.   
-000121a0: 2020 2020 2072 3120 3d20 6765 745f 7261       r1 = get_ra
-000121b0: 6469 7573 2872 313d 7231 2c20 723d 722c  dius(r1=r1, r=r,
-000121c0: 2064 313d 6431 2c20 643d 642c 2064 666c   d1=d1, d=d, dfl
-000121d0: 743d 3130 292c 0a20 2020 2020 2020 2072  t=10),.        r
-000121e0: 3220 3d20 6765 745f 7261 6469 7573 2872  2 = get_radius(r
-000121f0: 313d 7232 2c20 723d 722c 2064 313d 6432  1=r2, r=r, d1=d2
-00012200: 2c20 643d 642c 2064 666c 743d 3130 292c  , d=d, dflt=10),
-00012210: 0a20 2020 2020 2020 206d 6178 6420 3d20  .        maxd = 
-00012220: 6d61 7828 7231 2c72 3229 2b30 2e31 2c0a  max(r1,r2)+0.1,.
-00012230: 2020 2020 2020 2020 7369 6465 7320 3d20          sides = 
-00012240: 6365 696c 2873 6567 7328 6d61 7828 7231  ceil(segs(max(r1
-00012250: 2c72 3229 292a 616e 672f 3336 3029 2c0a  ,r2))*ang/360),.
-00012260: 2020 2020 2020 2020 7374 6570 203d 2061          step = a
-00012270: 6e67 2f73 6964 6573 2c0a 2020 2020 2020  ng/sides,.      
-00012280: 2020 766e 6620 3d20 766e 665f 7665 7274    vnf = vnf_vert
-00012290: 6578 5f61 7272 6179 280a 2020 2020 2020  ex_array(.      
-000122a0: 2020 2020 2020 706f 696e 7473 3d5b 0a20        points=[. 
-000122b0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000122c0: 6f72 2028 7520 3d20 5b30 2c31 5d29 206c  or (u = [0,1]) l
-000122d0: 6574 280a 2020 2020 2020 2020 2020 2020  et(.            
-000122e0: 2020 2020 2020 2020 6820 3d20 6c65 7270          h = lerp
-000122f0: 282d 6c2f 322c 6c2f 322c 7529 2c0a 2020  (-l/2,l/2,u),.  
-00012300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012310: 2020 7220 3d20 6c65 7270 2872 312c 7232    r = lerp(r1,r2
-00012320: 2c75 290a 2020 2020 2020 2020 2020 2020  ,u).            
-00012330: 2020 2020 2920 5b0a 2020 2020 2020 2020      ) [.        
-00012340: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00012350: 2874 6865 7461 203d 205b 303a 7374 6570  (theta = [0:step
-00012360: 3a61 6e67 2b45 5053 494c 4f4e 5d29 0a20  :ang+EPSILON]). 
-00012370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012380: 2020 2020 2020 2063 796c 696e 6472 6963         cylindric
-00012390: 616c 5f74 6f5f 7879 7a28 722c 7468 6574  al_to_xyz(r,thet
-000123a0: 612c 6829 2c0a 2020 2020 2020 2020 2020  a,h),.          
-000123b0: 2020 2020 2020 2020 2020 5b30 2c30 2c68            [0,0,h
-000123c0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-000123d0: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
-000123e0: 5d2c 0a20 2020 2020 2020 2020 2020 2063  ],.            c
-000123f0: 6f6c 5f77 7261 703d 7472 7565 2c20 6361  ol_wrap=true, ca
-00012400: 7073 3d74 7275 652c 2072 6576 6572 7365  ps=true, reverse
-00012410: 3d74 7275 650a 2020 2020 2020 2020 290a  =true.        ).
-00012420: 2020 2020 2920 7265 6f72 6965 6e74 2861      ) reorient(a
-00012430: 6e63 686f 722c 7370 696e 2c6f 7269 656e  nchor,spin,orien
-00012440: 742c 2072 313d 7231 2c20 7232 3d72 322c  t, r1=r1, r2=r2,
-00012450: 206c 3d6c 2c20 703d 766e 6629 3b0a 0a0a   l=l, p=vnf);...
-00012460: 0a2f 2f20 5365 6374 696f 6e3a 204f 7468  .// Section: Oth
-00012470: 6572 2052 6f75 6e64 204f 626a 6563 7473  er Round Objects
-00012480: 0a0a 0a2f 2f20 4675 6e63 7469 6f6e 264d  ...// Function&M
-00012490: 6f64 756c 653a 2073 7068 6572 6528 290a  odule: sphere().
-000124a0: 2f2f 2054 6f70 6963 733a 2053 6861 7065  // Topics: Shape
-000124b0: 7320 2833 4429 2c20 4174 7461 6368 6162  s (3D), Attachab
-000124c0: 6c65 2c20 564e 4620 4765 6e65 7261 746f  le, VNF Generato
-000124d0: 7273 0a2f 2f20 5573 6167 653a 2041 7320  rs.// Usage: As 
-000124e0: 4d6f 6475 6c65 0a2f 2f20 2020 7370 6865  Module.//   sphe
-000124f0: 7265 2872 7c64 3d2c 205b 6369 7263 756d  re(r|d=, [circum
-00012500: 3d5d 2c20 5b73 7479 6c65 3d5d 2c20 2e2e  =], [style=], ..
-00012510: 2e29 205b 4154 5441 4348 4d45 4e54 535d  .) [ATTACHMENTS]
-00012520: 3b0a 2f2f 2055 7361 6765 3a20 4173 2046  ;.// Usage: As F
-00012530: 756e 6374 696f 6e0a 2f2f 2020 2076 6e66  unction.//   vnf
-00012540: 203d 2073 7068 6572 6528 727c 643d 2c20   = sphere(r|d=, 
-00012550: 5b63 6972 6375 6d3d 5d2c 205b 7374 796c  [circum=], [styl
-00012560: 653d 5d2c 202e 2e2e 293b 0a2f 2f20 5365  e=], ...);.// Se
-00012570: 6520 416c 736f 3a20 7370 6865 726f 6964  e Also: spheroid
-00012580: 2829 0a2f 2f20 4465 7363 7269 7074 696f  ().// Descriptio
-00012590: 6e3a 0a2f 2f20 2020 4372 6561 7465 7320  n:.//   Creates 
-000125a0: 6120 7370 6865 7265 206f 626a 6563 742c  a sphere object,
-000125b0: 2077 6974 6820 7375 7070 6f72 7420 666f   with support fo
-000125c0: 7220 616e 6368 6f72 696e 6720 616e 6420  r anchoring and 
-000125d0: 6174 7461 6368 6d65 6e74 732e 0a2f 2f20  attachments..// 
-000125e0: 2020 5468 6973 2069 7320 6120 6472 6f70    This is a drop
-000125f0: 2d69 6e20 7265 706c 6163 656d 656e 7420  -in replacement 
-00012600: 666f 7220 7468 6520 6275 696c 742d 696e  for the built-in
-00012610: 2060 7370 6865 7265 2829 6020 6d6f 6475   `sphere()` modu
-00012620: 6c65 2e0a 2f2f 2020 2057 6865 6e20 6361  le..//   When ca
-00012630: 6c6c 6564 2061 7320 6120 6675 6e63 7469  lled as a functi
-00012640: 6f6e 2c20 7265 7475 726e 7320 6120 5b56  on, returns a [V
-00012650: 4e46 5d28 766e 662e 7363 6164 2920 666f  NF](vnf.scad) fo
-00012660: 7220 6120 7370 6865 7265 2e0a 2f2f 2041  r a sphere..// A
-00012670: 7267 756d 656e 7473 3a0a 2f2f 2020 2072  rguments:.//   r
-00012680: 203d 2052 6164 6975 7320 6f66 2074 6865   = Radius of the
-00012690: 2073 7068 6572 652e 0a2f 2f20 2020 2d2d   sphere..//   --
-000126a0: 2d0a 2f2f 2020 2064 203d 2044 6961 6d65  -.//   d = Diame
-000126b0: 7465 7220 6f66 2074 6865 2073 7068 6572  ter of the spher
-000126c0: 652e 0a2f 2f20 2020 6369 7263 756d 203d  e..//   circum =
-000126d0: 2049 6620 7472 7565 2c20 7468 6520 7370   If true, the sp
-000126e0: 6865 7265 2069 7320 6d61 6465 206c 6172  here is made lar
-000126f0: 6765 2065 6e6f 7567 6820 746f 2063 6972  ge enough to cir
-00012700: 6375 6d73 6372 6962 6520 7468 6520 7370  cumscribe the sp
-00012710: 6865 7265 206f 6620 7468 6520 6964 6561  here of the idea
-00012720: 6c20 7369 6465 2e20 204f 7468 6572 7769  l side.  Otherwi
-00012730: 7365 2069 6e73 6372 6962 6573 2e20 2044  se inscribes.  D
-00012740: 6566 6175 6c74 3a20 6661 6c73 6520 2869  efault: false (i
-00012750: 6e73 6372 6962 6573 290a 2f2f 2020 2073  nscribes).//   s
-00012760: 7479 6c65 203d 2054 6865 2073 7479 6c65  tyle = The style
-00012770: 206f 6620 7468 6520 7370 6865 7265 2773   of the sphere's
-00012780: 2063 6f6e 7374 7275 6374 696f 6e2e 204f   construction. O
-00012790: 6e65 206f 6620 226f 7269 6722 2c20 2261  ne of "orig", "a
-000127a0: 6c69 676e 6564 222c 2022 7374 6167 6765  ligned", "stagge
-000127b0: 7222 2c20 226f 6374 6122 2c20 6f72 2022  r", "octa", or "
-000127c0: 6963 6f73 6122 2e20 2044 6566 6175 6c74  icosa".  Default
-000127d0: 3a20 226f 7269 6722 0a2f 2f20 2020 616e  : "orig".//   an
-000127e0: 6368 6f72 203d 2054 7261 6e73 6c61 7465  chor = Translate
-000127f0: 2073 6f20 616e 6368 6f72 2070 6f69 6e74   so anchor point
-00012800: 2069 7320 6174 206f 7269 6769 6e20 2830   is at origin (0
-00012810: 2c30 2c30 292e 2020 5365 6520 5b61 6e63  ,0,0).  See [anc
-00012820: 686f 725d 2861 7474 6163 686d 656e 7473  hor](attachments
-00012830: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
-00012840: 2d61 6e63 686f 7229 2e20 2044 6566 6175  -anchor).  Defau
-00012850: 6c74 3a20 6043 454e 5445 5260 0a2f 2f20  lt: `CENTER`.// 
-00012860: 2020 7370 696e 203d 2052 6f74 6174 6520    spin = Rotate 
-00012870: 7468 6973 206d 616e 7920 6465 6772 6565  this many degree
-00012880: 7320 6172 6f75 6e64 2074 6865 205a 2061  s around the Z a
-00012890: 7869 7320 6166 7465 7220 616e 6368 6f72  xis after anchor
-000128a0: 2e20 2053 6565 205b 7370 696e 5d28 6174  .  See [spin](at
-000128b0: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
-000128c0: 7562 7365 6374 696f 6e2d 7370 696e 292e  ubsection-spin).
-000128d0: 2020 4465 6661 756c 743a 2060 3060 0a2f    Default: `0`./
-000128e0: 2f20 2020 6f72 6965 6e74 203d 2056 6563  /   orient = Vec
-000128f0: 746f 7220 746f 2072 6f74 6174 6520 746f  tor to rotate to
-00012900: 7020 746f 7761 7264 732c 2061 6674 6572  p towards, after
-00012910: 2073 7069 6e2e 2020 5365 6520 5b6f 7269   spin.  See [ori
-00012920: 656e 745d 2861 7474 6163 686d 656e 7473  ent](attachments
-00012930: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
-00012940: 2d6f 7269 656e 7429 2e20 2044 6566 6175  -orient).  Defau
-00012950: 6c74 3a20 6055 5060 0a2f 2f20 4578 616d  lt: `UP`.// Exam
-00012960: 706c 653a 2042 7920 5261 6469 7573 0a2f  ple: By Radius./
-00012970: 2f20 2020 7370 6865 7265 2872 3d35 3029  /   sphere(r=50)
-00012980: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4279  ;.// Example: By
-00012990: 2044 6961 6d65 7465 720a 2f2f 2020 2073   Diameter.//   s
-000129a0: 7068 6572 6528 643d 3130 3029 3b0a 2f2f  phere(d=100);.//
-000129b0: 2045 7861 6d70 6c65 3a20 7374 796c 653d   Example: style=
-000129c0: 226f 7269 6722 0a2f 2f20 2020 7370 6865  "orig".//   sphe
-000129d0: 7265 2864 3d31 3030 2c20 7374 796c 653d  re(d=100, style=
-000129e0: 226f 7269 6722 2c20 2466 6e3d 3130 293b  "orig", $fn=10);
-000129f0: 0a2f 2f20 4578 616d 706c 653a 2073 7479  .// Example: sty
-00012a00: 6c65 3d22 616c 6967 6e65 6422 0a2f 2f20  le="aligned".// 
-00012a10: 2020 7370 6865 7265 2864 3d31 3030 2c20    sphere(d=100, 
-00012a20: 7374 796c 653d 2261 6c69 676e 6564 222c  style="aligned",
-00012a30: 2024 666e 3d31 3029 3b0a 2f2f 2045 7861   $fn=10);.// Exa
-00012a40: 6d70 6c65 3a20 7374 796c 653d 2273 7461  mple: style="sta
-00012a50: 6767 6572 220a 2f2f 2020 2073 7068 6572  gger".//   spher
-00012a60: 6528 643d 3130 302c 2073 7479 6c65 3d22  e(d=100, style="
-00012a70: 7374 6167 6765 7222 2c20 2466 6e3d 3130  stagger", $fn=10
-00012a80: 293b 0a2f 2f20 4578 616d 706c 653a 2073  );.// Example: s
-00012a90: 7479 6c65 3d22 6963 6f73 6122 0a2f 2f20  tyle="icosa".// 
-00012aa0: 2020 7370 6865 7265 2864 3d31 3030 2c20    sphere(d=100, 
-00012ab0: 7374 796c 653d 2269 636f 7361 222c 2024  style="icosa", $
-00012ac0: 666e 3d31 3029 3b0a 2f2f 2020 202f 2f20  fn=10);.//   // 
-00012ad0: 496e 2022 6963 6f73 6122 2073 7479 6c65  In "icosa" style
-00012ae0: 2c20 2466 6e20 6973 2071 7561 6e74 697a  , $fn is quantiz
-00012af0: 6564 0a2f 2f20 2020 2f2f 2020 2074 6f20  ed.//   //   to 
-00012b00: 7468 6520 6e65 6172 6573 7420 6d75 6c74  the nearest mult
-00012b10: 6970 6c65 206f 6620 352e 0a2f 2f20 4578  iple of 5..// Ex
-00012b20: 616d 706c 653a 2041 6e63 686f 7269 6e67  ample: Anchoring
-00012b30: 0a2f 2f20 2020 7370 6865 7265 2864 3d31  .//   sphere(d=1
-00012b40: 3030 2c20 616e 6368 6f72 3d46 524f 4e54  00, anchor=FRONT
-00012b50: 293b 0a2f 2f20 4578 616d 706c 653a 2053  );.// Example: S
-00012b60: 7069 6e0a 2f2f 2020 2073 7068 6572 6528  pin.//   sphere(
-00012b70: 643d 3130 302c 2061 6e63 686f 723d 4652  d=100, anchor=FR
-00012b80: 4f4e 542c 2073 7069 6e3d 3435 293b 0a2f  ONT, spin=45);./
-00012b90: 2f20 4578 616d 706c 653a 204f 7269 656e  / Example: Orien
-00012ba0: 7461 7469 6f6e 0a2f 2f20 2020 7370 6865  tation.//   sphe
-00012bb0: 7265 2864 3d31 3030 2c20 616e 6368 6f72  re(d=100, anchor
-00012bc0: 3d46 524f 4e54 2c20 7370 696e 3d34 352c  =FRONT, spin=45,
-00012bd0: 206f 7269 656e 743d 4657 4429 3b0a 2f2f   orient=FWD);.//
-00012be0: 2045 7861 6d70 6c65 3a20 5374 616e 6461   Example: Standa
-00012bf0: 7264 2043 6f6e 6e65 6374 6f72 730a 2f2f  rd Connectors.//
-00012c00: 2020 2073 7068 6572 6528 643d 3530 2920     sphere(d=50) 
-00012c10: 7368 6f77 5f61 6e63 686f 7273 2829 3b0a  show_anchors();.
-00012c20: 2f2f 2045 7861 6d70 6c65 3a20 4361 6c6c  // Example: Call
-00012c30: 6564 2061 7320 4675 6e63 7469 6f6e 0a2f  ed as Function./
-00012c40: 2f20 2020 766e 6620 3d20 7370 6865 7265  /   vnf = sphere
-00012c50: 2864 3d31 3030 2c20 7374 796c 653d 2269  (d=100, style="i
-00012c60: 636f 7361 2229 3b0a 2f2f 2020 2076 6e66  cosa");.//   vnf
-00012c70: 5f70 6f6c 7968 6564 726f 6e28 766e 6629  _polyhedron(vnf)
-00012c80: 3b0a 6d6f 6475 6c65 2073 7068 6572 6528  ;.module sphere(
-00012c90: 722c 2064 2c20 6369 7263 756d 3d66 616c  r, d, circum=fal
-00012ca0: 7365 2c20 7374 796c 653d 226f 7269 6722  se, style="orig"
-00012cb0: 2c20 616e 6368 6f72 3d43 454e 5445 522c  , anchor=CENTER,
-00012cc0: 2073 7069 6e3d 302c 206f 7269 656e 743d   spin=0, orient=
-00012cd0: 5550 2920 7b0a 2020 2020 7220 3d20 6765  UP) {.    r = ge
-00012ce0: 745f 7261 6469 7573 2872 3d72 2c20 643d  t_radius(r=r, d=
-00012cf0: 642c 2064 666c 743d 3129 3b0a 2020 2020  d, dflt=1);.    
-00012d00: 6966 2028 2163 6972 6375 6d20 2626 2073  if (!circum && s
-00012d10: 7479 6c65 3d3d 226f 7269 6722 2026 2620  tyle=="orig" && 
-00012d20: 6973 5f6e 756d 2872 2929 207b 0a20 2020  is_num(r)) {.   
-00012d30: 2020 2020 2061 7474 6163 6861 626c 6528       attachable(
-00012d40: 616e 6368 6f72 2c73 7069 6e2c 6f72 6965  anchor,spin,orie
-00012d50: 6e74 2c20 723d 7229 207b 0a20 2020 2020  nt, r=r) {.     
-00012d60: 2020 2020 2020 205f 7370 6865 7265 2872         _sphere(r
-00012d70: 3d72 293b 0a20 2020 2020 2020 2020 2020  =r);.           
-00012d80: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
-00012d90: 2020 2020 207d 0a20 2020 207d 2065 6c73       }.    } els
-00012da0: 6520 7b0a 2020 2020 2020 2020 7370 6865  e {.        sphe
-00012db0: 726f 6964 280a 2020 2020 2020 2020 2020  roid(.          
-00012dc0: 2020 723d 722c 2063 6972 6375 6d3d 6369    r=r, circum=ci
-00012dd0: 7263 756d 2c20 7374 796c 653d 7374 796c  rcum, style=styl
-00012de0: 652c 0a20 2020 2020 2020 2020 2020 2061  e,.            a
-00012df0: 6e63 686f 723d 616e 6368 6f72 2c20 7370  nchor=anchor, sp
-00012e00: 696e 3d73 7069 6e2c 206f 7269 656e 743d  in=spin, orient=
-00012e10: 6f72 6965 6e74 0a20 2020 2020 2020 2029  orient.        )
-00012e20: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
-00012e30: 207d 0a7d 0a0a 0a66 756e 6374 696f 6e20   }.}...function 
-00012e40: 7370 6865 7265 2872 2c20 642c 2063 6972  sphere(r, d, cir
-00012e50: 6375 6d3d 6661 6c73 652c 2073 7479 6c65  cum=false, style
-00012e60: 3d22 6f72 6967 222c 2061 6e63 686f 723d  ="orig", anchor=
-00012e70: 4345 4e54 4552 2c20 7370 696e 3d30 2c20  CENTER, spin=0, 
-00012e80: 6f72 6965 6e74 3d55 5029 203d 0a20 2020  orient=UP) =.   
-00012e90: 2073 7068 6572 6f69 6428 723d 722c 2064   spheroid(r=r, d
-00012ea0: 3d64 2c20 6369 7263 756d 3d63 6972 6375  =d, circum=circu
-00012eb0: 6d2c 2073 7479 6c65 3d73 7479 6c65 2c20  m, style=style, 
-00012ec0: 616e 6368 6f72 3d61 6e63 686f 722c 2073  anchor=anchor, s
-00012ed0: 7069 6e3d 7370 696e 2c20 6f72 6965 6e74  pin=spin, orient
-00012ee0: 3d6f 7269 656e 7429 3b0a 0a0a 2f2f 2046  =orient);...// F
-00012ef0: 756e 6374 696f 6e26 4d6f 6475 6c65 3a20  unction&Module: 
-00012f00: 7370 6865 726f 6964 2829 0a2f 2f20 5573  spheroid().// Us
-00012f10: 6167 653a 2054 7970 6963 616c 0a2f 2f20  age: Typical.// 
-00012f20: 2020 7370 6865 726f 6964 2872 7c64 2c20    spheroid(r|d, 
-00012f30: 5b63 6972 6375 6d5d 2c20 5b73 7479 6c65  [circum], [style
-00012f40: 5d29 205b 4154 5441 4348 4d45 4e54 535d  ]) [ATTACHMENTS]
-00012f50: 3b0a 2f2f 2055 7361 6765 3a20 4173 2046  ;.// Usage: As F
-00012f60: 756e 6374 696f 6e0a 2f2f 2020 2076 6e66  unction.//   vnf
-00012f70: 203d 2073 7068 6572 6f69 6428 727c 642c   = spheroid(r|d,
-00012f80: 205b 6369 7263 756d 5d2c 205b 7374 796c   [circum], [styl
-00012f90: 655d 293b 0a2f 2f20 4465 7363 7269 7074  e]);.// Descript
-00012fa0: 696f 6e3a 0a2f 2f20 2020 4372 6561 7465  ion:.//   Create
-00012fb0: 7320 6120 7370 6865 726f 6964 206f 626a  s a spheroid obj
-00012fc0: 6563 742c 2077 6974 6820 7375 7070 6f72  ect, with suppor
-00012fd0: 7420 666f 7220 616e 6368 6f72 696e 6720  t for anchoring 
-00012fe0: 616e 6420 6174 7461 6368 6d65 6e74 732e  and attachments.
-00012ff0: 0a2f 2f20 2020 5468 6973 2069 7320 6120  .//   This is a 
-00013000: 6472 6f70 2d69 6e20 7265 706c 6163 656d  drop-in replacem
-00013010: 656e 7420 666f 7220 7468 6520 6275 696c  ent for the buil
-00013020: 742d 696e 2060 7370 6865 7265 2829 6020  t-in `sphere()` 
-00013030: 6d6f 6475 6c65 2e0a 2f2f 2020 2057 6865  module..//   Whe
-00013040: 6e20 6361 6c6c 6564 2061 7320 6120 6675  n called as a fu
-00013050: 6e63 7469 6f6e 2c20 7265 7475 726e 7320  nction, returns 
-00013060: 6120 5b56 4e46 5d28 766e 662e 7363 6164  a [VNF](vnf.scad
-00013070: 2920 666f 7220 6120 7370 6865 726f 6964  ) for a spheroid
-00013080: 2e0a 2f2f 2020 2054 6865 2065 7861 6374  ..//   The exact
-00013090: 2074 7269 616e 6775 6c61 7469 6f6e 206f   triangulation o
-000130a0: 6620 7468 6973 2073 7068 6572 6f69 6420  f this spheroid 
-000130b0: 6361 6e20 6265 2063 6f6e 7472 6f6c 6c65  can be controlle
-000130c0: 6420 7669 6120 7468 6520 6073 7479 6c65  d via the `style
-000130d0: 3d60 0a2f 2f20 2020 6172 6775 6d65 6e74  =`.//   argument
-000130e0: 2c20 7768 6572 6520 7468 6520 7661 6c75  , where the valu
-000130f0: 6520 6361 6e20 6265 206f 6e65 206f 6620  e can be one of 
-00013100: 6022 6f72 6967 2260 2c20 6022 616c 6967  `"orig"`, `"alig
-00013110: 6e65 6422 602c 2060 2273 7461 6767 6572  ned"`, `"stagger
-00013120: 2260 2c0a 2f2f 2020 2060 226f 6374 6122  "`,.//   `"octa"
-00013130: 602c 206f 7220 6022 6963 6f73 6122 602e  `, or `"icosa"`.
-00013140: 2020 0a2f 2f20 2020 2d20 6073 7479 6c65    .//   - `style
-00013150: 3d22 6f72 6967 2260 2063 6f6e 7374 7275  ="orig"` constru
-00013160: 6374 7320 6120 7370 6865 7265 2074 6865  cts a sphere the
-00013170: 2073 616d 6520 7761 7920 7468 6174 2074   same way that t
-00013180: 6865 204f 7065 6e53 4341 4420 6073 7068  he OpenSCAD `sph
-00013190: 6572 6528 2960 2062 7569 6c74 2d69 6e20  ere()` built-in 
-000131a0: 646f 6573 2e0a 2f2f 2020 202d 2060 7374  does..//   - `st
-000131b0: 796c 653d 2261 6c69 676e 6564 2260 2063  yle="aligned"` c
-000131c0: 6f6e 7374 7275 6374 7320 6120 7370 6865  onstructs a sphe
-000131d0: 7265 2077 6865 7265 2c20 6966 2060 2466  re where, if `$f
-000131e0: 6e60 2069 7320 6120 6d75 6c74 6970 6c65  n` is a multiple
-000131f0: 206f 6620 342c 2069 7420 6861 7320 7665   of 4, it has ve
-00013200: 7274 6963 6573 2061 7420 616c 6c20 6178  rtices at all ax
-00013210: 6973 206d 6178 696d 6120 616e 6420 6d69  is maxima and mi
-00013220: 6e69 6d61 2e20 2069 653a 2069 7473 2062  nima.  ie: its b
-00013230: 6f75 6e64 696e 6720 626f 7820 6973 2065  ounding box is e
-00013240: 7861 6374 6c79 2074 6865 2073 7068 6572  xactly the spher
-00013250: 6520 6469 616d 6574 6572 2069 6e20 6c65  e diameter in le
-00013260: 6e67 7468 206f 6e20 616c 6c20 7468 7265  ngth on all thre
-00013270: 6520 6178 6573 2e20 2054 6869 7320 6973  e axes.  This is
-00013280: 2074 6865 2064 6566 6175 6c74 2e0a 2f2f   the default..//
-00013290: 2020 202d 2060 7374 796c 653d 2273 7461     - `style="sta
-000132a0: 6767 6572 2260 2066 6f72 6d73 2061 2073  gger"` forms a s
-000132b0: 7068 6572 6520 7768 6572 6520 616c 6c20  phere where all 
-000132c0: 6661 6365 7320 6172 6520 7472 6961 6e67  faces are triang
-000132d0: 756c 6172 2c20 6275 7420 7468 6520 746f  ular, but the to
-000132e0: 7020 616e 6420 626f 7474 6f6d 2070 6f6c  p and bottom pol
-000132f0: 6573 2068 6176 6520 7468 696e 6e65 7220  es have thinner 
-00013300: 7472 6961 6e67 6c65 732e 0a2f 2f20 2020  triangles..//   
-00013310: 2d20 6073 7479 6c65 3d22 6f63 7461 2260  - `style="octa"`
-00013320: 2066 6f72 6d73 2061 2073 7068 6572 6520   forms a sphere 
-00013330: 6279 2073 7562 6469 7669 6469 6e67 2061  by subdividing a
-00013340: 6e20 6f63 7461 6865 6472 6f6e 2e20 2054  n octahedron.  T
-00013350: 6869 7320 6d61 6b65 7320 6d6f 7265 2075  his makes more u
-00013360: 6e69 666f 726d 2066 6163 6573 206f 7665  niform faces ove
-00013370: 7220 7468 6520 656e 7469 7265 7479 206f  r the entirety o
-00013380: 6620 7468 6520 7370 6865 7265 2c20 616e  f the sphere, an
-00013390: 6420 6775 6172 616e 7465 6573 2074 6865  d guarantees the
-000133a0: 2062 6f75 6e64 696e 6720 626f 7820 6973   bounding box is
-000133b0: 2074 6865 2073 7068 6572 6520 6469 616d   the sphere diam
-000133c0: 6574 6572 2069 6e20 7369 7a65 206f 6e20  eter in size on 
-000133d0: 616c 6c20 6178 6573 2e20 2054 6865 2065  all axes.  The e
-000133e0: 6666 6563 7469 7665 2060 2466 6e60 2076  ffective `$fn` v
-000133f0: 616c 7565 2069 7320 7175 616e 7469 7a65  alue is quantize
-00013400: 6420 746f 2061 206d 756c 7469 706c 6520  d to a multiple 
-00013410: 6f66 2034 2e20 2054 6869 7320 6973 2075  of 4.  This is u
-00013420: 7365 6420 696e 2063 6f6e 7374 7275 6374  sed in construct
-00013430: 696e 6720 726f 756e 6465 6420 636f 726e  ing rounded corn
-00013440: 6572 7320 666f 7220 7661 7269 6f75 7320  ers for various 
-00013450: 6f74 6865 7220 7368 6170 6573 2e0a 2f2f  other shapes..//
-00013460: 2020 202d 2060 7374 796c 653d 2269 636f     - `style="ico
-00013470: 7361 2260 2066 6f72 6d73 2061 2073 7068  sa"` forms a sph
-00013480: 6572 6520 6279 2073 7562 6469 7669 6469  ere by subdividi
-00013490: 6e67 2061 6e20 6963 6f73 6168 6564 726f  ng an icosahedro
-000134a0: 6e2e 2020 5468 6973 206d 616b 6573 2065  n.  This makes e
-000134b0: 7665 6e20 6d6f 7265 2075 6e69 666f 726d  ven more uniform
-000134c0: 2066 6163 6573 206f 7665 7220 7468 6520   faces over the 
-000134d0: 7768 6f6c 6520 7370 6865 7265 2e20 2054  whole sphere.  T
-000134e0: 6865 2065 6666 6563 7469 7665 2060 2466  he effective `$f
-000134f0: 6e60 2076 616c 7565 2069 7320 7175 616e  n` value is quan
-00013500: 7469 7a65 6420 746f 2061 206d 756c 7469  tized to a multi
-00013510: 706c 6520 6f66 2035 2e20 2054 6869 7320  ple of 5.  This 
-00013520: 7370 6865 7265 2068 6173 2061 2067 7561  sphere has a gua
-00013530: 7261 6e74 6565 6420 626f 756e 6469 6e67  ranteed bounding
-00013540: 2062 6f78 2077 6865 6e20 6024 666e 6020   box when `$fn` 
-00013550: 6973 2061 206d 756c 7469 706c 6520 6f66  is a multiple of
-00013560: 2031 302e 2020 0a2f 2f20 2020 2e0a 2f2f   10.  .//   ..//
-00013570: 2020 2042 7920 6465 6661 756c 7420 7468     By default th
-00013580: 6520 6f62 6a65 6374 2073 7068 6572 6f69  e object spheroi
-00013590: 6428 2920 7072 6f64 7563 6573 2069 7320  d() produces is 
-000135a0: 6120 706f 6c79 6865 6472 6f6e 2077 686f  a polyhedron who
-000135b0: 7365 2076 6572 7469 6365 7320 616c 6c20  se vertices all 
-000135c0: 6c69 6520 6f6e 2074 6865 2072 6571 7565  lie on the reque
-000135d0: 7374 6564 2073 7068 6572 652e 2020 5468  sted sphere.  Th
-000135e0: 6973 206d 6561 6e73 0a2f 2f20 2020 7468  is means.//   th
-000135f0: 6520 6170 7072 6f78 696d 6174 696e 6720  e approximating 
-00013600: 706f 6c79 6865 6472 6f6e 2069 7320 696e  polyhedron is in
-00013610: 7363 7269 6265 6420 696e 2074 6865 2073  scribed in the s
-00013620: 7068 6572 652e 0a2f 2f20 2020 5468 6520  phere..//   The 
-00013630: 6063 6972 6375 6d60 2061 7267 756d 656e  `circum` argumen
-00013640: 7420 7265 7175 6573 7473 2061 2063 6972  t requests a cir
-00013650: 6375 6d73 6372 6962 696e 6720 7370 6865  cumscribing sphe
-00013660: 7265 2c20 7768 6572 6520 7468 6520 7472  re, where the tr
-00013670: 7565 2073 7068 6572 6520 6973 0a2f 2f20  ue sphere is.// 
-00013680: 2020 696e 7369 6465 2061 6e64 2074 616e    inside and tan
-00013690: 6765 6e74 2074 6f20 616c 6c20 7468 6520  gent to all the 
-000136a0: 6661 6365 7320 6f66 2074 6865 2061 7070  faces of the app
-000136b0: 726f 7869 6d61 7469 6e67 2070 6f6c 7968  roximating polyh
-000136c0: 6564 726f 6e2e 2020 546f 2070 726f 6475  edron.  To produ
-000136d0: 6365 0a2f 2f20 2020 6120 6369 7263 756d  ce.//   a circum
-000136e0: 7363 7269 6269 6e67 2070 6f6c 7968 6564  scribing polyhed
-000136f0: 726f 6e2c 2077 6520 7573 6520 7468 6520  ron, we use the 
-00013700: 6475 616c 2070 6f6c 7968 6564 726f 6e20  dual polyhedron 
-00013710: 6f66 2074 6865 2062 6173 6963 2066 6f72  of the basic for
-00013720: 6d2e 2020 5468 6520 6475 616c 206f 6620  m.  The dual of 
-00013730: 6120 706f 6c79 6865 6472 6f6e 2069 730a  a polyhedron is.
-00013740: 2f2f 2020 2061 206e 6577 2070 6f6c 7968  //   a new polyh
-00013750: 6564 726f 6e20 7768 6f73 6520 7665 7274  edron whose vert
-00013760: 6963 6573 2061 7265 206f 6274 6169 6e65  ices are obtaine
-00013770: 6420 6672 6f6d 2074 6865 2066 6163 6573  d from the faces
-00013780: 206f 6620 7468 6520 7061 7265 6e74 2070   of the parent p
-00013790: 6f6c 7968 6564 726f 6e2e 2020 0a2f 2f20  olyhedron.  .// 
-000137a0: 2020 5468 6520 226f 7269 6722 2061 6e64    The "orig" and
-000137b0: 2022 616c 6967 6e22 2066 6f72 6d73 2061   "align" forms a
-000137c0: 7265 2064 7561 6c73 206f 6620 6561 6368  re duals of each
-000137d0: 206f 7468 6572 2e20 2049 6620 796f 7520   other.  If you 
-000137e0: 7265 7175 6573 7420 6120 6369 7263 756d  request a circum
-000137f0: 7363 7269 6269 6e67 2070 6f6c 7968 6564  scribing polyhed
-00013800: 726f 6e20 696e 0a2f 2f20 2020 7468 6573  ron in.//   thes
-00013810: 6520 7374 796c 6573 2074 6865 6e20 7468  e styles then th
-00013820: 6520 706f 6c79 6865 6472 6f6e 2077 696c  e polyhedron wil
-00013830: 6c20 6c6f 6f6b 2074 6865 2073 616d 6520  l look the same 
-00013840: 6173 2074 6865 2064 6566 6175 6c74 2069  as the default i
-00013850: 6e73 6372 6962 696e 6720 666f 726d 2e20  nscribing form. 
-00013860: 2042 7574 2066 6f72 2074 6865 206f 7468   But for the oth
-00013870: 6572 0a2f 2f20 2020 7374 796c 6573 2c20  er.//   styles, 
-00013880: 7468 6520 6475 616c 7320 6172 6520 636f  the duals are co
-00013890: 6d70 6c65 7465 6c79 2064 6966 6665 7265  mpletely differe
-000138a0: 6e74 2066 726f 6d20 7468 6569 7220 7061  nt from their pa
-000138b0: 7265 6e74 732c 2061 6e64 2066 726f 6d20  rents, and from 
-000138c0: 6561 6368 206f 7468 6572 2e20 2047 656e  each other.  Gen
-000138d0: 6572 6174 696f 6e20 6f66 2074 6865 2063  eration of the c
-000138e0: 6972 6375 6d73 6372 6962 6564 2076 6572  ircumscribed ver
-000138f0: 7369 6f6e 7320 2864 7561 6c73 290a 2f2f  sions (duals).//
-00013900: 2020 2066 6f72 2022 6f63 7461 2220 616e     for "octa" an
-00013910: 6420 2269 636f 7361 2220 6973 2066 6173  d "icosa" is fas
-00013920: 7420 6966 2079 6f75 2075 7365 2074 6865  t if you use the
-00013930: 206d 6f64 756c 6520 666f 726d 2062 7574   module form but
-00013940: 2063 616e 2062 6520 7665 7279 2073 6c6f   can be very slo
-00013950: 7720 2873 6576 6572 616c 206d 696e 7574  w (several minut
-00013960: 6573 2920 6966 2079 6f75 2075 7365 2074  es) if you use t
-00013970: 6865 2066 756e 6374 696f 6e61 6c0a 2f2f  he functional.//
-00013980: 2020 2066 6f72 6d20 616e 6420 6368 6f6f     form and choo
-00013990: 7365 2061 206c 6172 6765 2024 666e 2076  se a large $fn v
-000139a0: 616c 7565 2e0a 2f2f 2020 202e 0a2f 2f20  alue..//   ..// 
-000139b0: 2020 5769 7468 2073 7479 6c65 3d22 616c    With style="al
-000139c0: 6967 6e22 2c20 7468 6520 6369 7263 756d  ign", the circum
-000139d0: 7363 7269 6265 6420 7370 6865 7265 2068  scribed sphere h
-000139e0: 6173 2069 7473 206d 6178 696d 756d 2072  as its maximum r
-000139f0: 6164 6975 7320 6f6e 2074 6865 2058 2061  adius on the X a
-00013a00: 6e64 2059 2061 7865 730a 2f2f 2020 2062  nd Y axes.//   b
-00013a10: 7574 2069 7320 756e 6465 7273 697a 6564  ut is undersized
-00013a20: 206f 6e20 7468 6520 5a20 6178 6973 2e20   on the Z axis. 
-00013a30: 2057 6974 6820 7374 796c 653d 226f 6374   With style="oct
-00013a40: 6122 2074 6865 2063 6972 6375 6d73 6372  a" the circumscr
-00013a50: 6962 6564 2073 7068 6572 6520 6861 7320  ibed sphere has 
-00013a60: 6661 6365 7320 6174 2065 6163 6820 6178  faces at each ax
-00013a70: 6973 2c20 736f 0a2f 2f20 2020 7468 6520  is, so.//   the 
-00013a80: 7261 6469 7573 206f 6e20 7468 6520 6178  radius on the ax
-00013a90: 6573 2069 7320 6571 7561 6c20 746f 2074  es is equal to t
-00013aa0: 6865 2073 7065 6369 6669 6564 2072 6164  he specified rad
-00013ab0: 6975 732c 2077 6869 6368 2069 7320 7468  ius, which is th
-00013ac0: 6520 2a6d 696e 696d 756d 2a20 7261 6469  e *minimum* radi
-00013ad0: 7573 206f 6620 7468 6520 6369 7263 756d  us of the circum
-00013ae0: 7363 7269 6265 6420 7370 6865 7265 2e0a  scribed sphere..
-00013af0: 2f2f 2020 2054 6865 2073 616d 6520 7468  //   The same th
-00013b00: 696e 6720 6973 2074 7275 6520 666f 7220  ing is true for 
-00013b10: 7374 796c 653d 2269 636f 7361 2220 7768  style="icosa" wh
-00013b20: 656e 2024 666e 2069 7320 6120 6d75 6c74  en $fn is a mult
-00013b30: 6970 6c65 206f 6620 3130 2e20 2054 6869  iple of 10.  Thi
-00013b40: 7320 776f 756c 6420 656e 6162 6c65 2079  s would enable y
-00013b50: 6f75 2074 6f20 6372 6561 7465 2073 7068  ou to create sph
-00013b60: 6572 6963 616c 0a2f 2f20 2020 686f 6c65  erical.//   hole
-00013b70: 7320 7769 7468 2067 7561 7261 6e74 6565  s with guarantee
-00013b80: 6420 6f6e 2d61 7869 7320 6469 6d65 6e73  d on-axis dimens
-00013b90: 696f 6e73 2e20 200a 2f2f 2041 7267 756d  ions.  .// Argum
-00013ba0: 656e 7473 3a0a 2f2f 2020 2072 203d 2052  ents:.//   r = R
-00013bb0: 6164 6975 7320 6f66 2074 6865 2073 7068  adius of the sph
-00013bc0: 6572 6f69 642e 0a2f 2f20 2020 7374 796c  eroid..//   styl
-00013bd0: 6520 3d20 5468 6520 7374 796c 6520 6f66  e = The style of
-00013be0: 2074 6865 2073 7068 6572 6f69 6427 7320   the spheroid's 
-00013bf0: 636f 6e73 7472 7563 7469 6f6e 2e20 4f6e  construction. On
-00013c00: 6520 6f66 2022 6f72 6967 222c 2022 616c  e of "orig", "al
-00013c10: 6967 6e65 6422 2c20 2273 7461 6767 6572  igned", "stagger
-00013c20: 222c 2022 6f63 7461 222c 206f 7220 2269  ", "octa", or "i
-00013c30: 636f 7361 222e 2020 4465 6661 756c 743a  cosa".  Default:
-00013c40: 2022 616c 6967 6e65 6422 0a2f 2f20 2020   "aligned".//   
-00013c50: 2d2d 2d0a 2f2f 2020 2064 203d 2044 6961  ---.//   d = Dia
-00013c60: 6d65 7465 7220 6f66 2074 6865 2073 7068  meter of the sph
-00013c70: 6572 6f69 642e 0a2f 2f20 2020 6369 7263  eroid..//   circ
-00013c80: 756d 203d 2049 6620 7472 7565 2c20 7468  um = If true, th
-00013c90: 6520 6170 7072 6f78 696d 6174 6520 7370  e approximate sp
-00013ca0: 6865 7265 2063 6972 6375 6d73 6372 6962  here circumscrib
-00013cb0: 6573 2074 6865 2074 7275 6520 7370 6865  es the true sphe
-00013cc0: 7265 206f 6620 7468 6520 7265 7175 6573  re of the reques
-00013cd0: 7465 6420 7369 7a65 2e20 204f 7468 6572  ted size.  Other
-00013ce0: 7769 7365 2069 6e73 6372 6962 6573 2e20  wise inscribes. 
-00013cf0: 204e 6f74 6520 7468 6174 2066 6f72 2073   Note that for s
-00013d00: 6f6d 6520 7374 796c 6573 2c20 7468 6520  ome styles, the 
-00013d10: 6369 7263 756d 7363 7269 6265 6420 7370  circumscribed sp
-00013d20: 6865 7265 206c 6f6f 6b73 2064 6966 6665  here looks diffe
-00013d30: 7265 6e74 2074 6861 6e20 7468 6520 696e  rent than the in
-00013d40: 7363 7269 6265 6420 7370 6865 7265 2e20  scribed sphere. 
-00013d50: 2044 6566 6175 6c74 3a20 6661 6c73 6520   Default: false 
-00013d60: 2869 6e73 6372 6962 6573 290a 2f2f 2020  (inscribes).//  
-00013d70: 2061 6e63 686f 7220 3d20 5472 616e 736c   anchor = Transl
-00013d80: 6174 6520 736f 2061 6e63 686f 7220 706f  ate so anchor po
-00013d90: 696e 7420 6973 2061 7420 6f72 6967 696e  int is at origin
-00013da0: 2028 302c 302c 3029 2e20 2053 6565 205b   (0,0,0).  See [
-00013db0: 616e 6368 6f72 5d28 6174 7461 6368 6d65  anchor](attachme
-00013dc0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
-00013dd0: 696f 6e2d 616e 6368 6f72 292e 2020 4465  ion-anchor).  De
-00013de0: 6661 756c 743a 2060 4345 4e54 4552 600a  fault: `CENTER`.
-00013df0: 2f2f 2020 2073 7069 6e20 3d20 526f 7461  //   spin = Rota
-00013e00: 7465 2074 6869 7320 6d61 6e79 2064 6567  te this many deg
-00013e10: 7265 6573 2061 726f 756e 6420 7468 6520  rees around the 
-00013e20: 5a20 6178 6973 2061 6674 6572 2061 6e63  Z axis after anc
-00013e30: 686f 722e 2020 5365 6520 5b73 7069 6e5d  hor.  See [spin]
-00013e40: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-00013e50: 6423 7375 6273 6563 7469 6f6e 2d73 7069  d#subsection-spi
-00013e60: 6e29 2e20 2044 6566 6175 6c74 3a20 6030  n).  Default: `0
-00013e70: 600a 2f2f 2020 206f 7269 656e 7420 3d20  `.//   orient = 
-00013e80: 5665 6374 6f72 2074 6f20 726f 7461 7465  Vector to rotate
-00013e90: 2074 6f70 2074 6f77 6172 6473 2c20 6166   top towards, af
-00013ea0: 7465 7220 7370 696e 2e20 2053 6565 205b  ter spin.  See [
-00013eb0: 6f72 6965 6e74 5d28 6174 7461 6368 6d65  orient](attachme
-00013ec0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
-00013ed0: 696f 6e2d 6f72 6965 6e74 292e 2020 4465  ion-orient).  De
-00013ee0: 6661 756c 743a 2060 5550 600a 2f2f 2045  fault: `UP`.// E
-00013ef0: 7861 6d70 6c65 3a20 4279 2052 6164 6975  xample: By Radiu
-00013f00: 730a 2f2f 2020 2073 7068 6572 6f69 6428  s.//   spheroid(
-00013f10: 723d 3530 293b 0a2f 2f20 4578 616d 706c  r=50);.// Exampl
-00013f20: 653a 2042 7920 4469 616d 6574 6572 0a2f  e: By Diameter./
-00013f30: 2f20 2020 7370 6865 726f 6964 2864 3d31  /   spheroid(d=1
-00013f40: 3030 293b 0a2f 2f20 4578 616d 706c 653a  00);.// Example:
-00013f50: 2073 7479 6c65 3d22 6f72 6967 220a 2f2f   style="orig".//
-00013f60: 2020 2073 7068 6572 6f69 6428 643d 3130     spheroid(d=10
-00013f70: 302c 2073 7479 6c65 3d22 6f72 6967 222c  0, style="orig",
-00013f80: 2024 666e 3d31 3029 3b0a 2f2f 2045 7861   $fn=10);.// Exa
-00013f90: 6d70 6c65 3a20 7374 796c 653d 2261 6c69  mple: style="ali
-00013fa0: 676e 6564 220a 2f2f 2020 2073 7068 6572  gned".//   spher
-00013fb0: 6f69 6428 643d 3130 302c 2073 7479 6c65  oid(d=100, style
-00013fc0: 3d22 616c 6967 6e65 6422 2c20 2466 6e3d  ="aligned", $fn=
-00013fd0: 3130 293b 0a2f 2f20 4578 616d 706c 653a  10);.// Example:
-00013fe0: 2073 7479 6c65 3d22 7374 6167 6765 7222   style="stagger"
-00013ff0: 0a2f 2f20 2020 7370 6865 726f 6964 2864  .//   spheroid(d
-00014000: 3d31 3030 2c20 7374 796c 653d 2273 7461  =100, style="sta
-00014010: 6767 6572 222c 2024 666e 3d31 3029 3b0a  gger", $fn=10);.
-00014020: 2f2f 2045 7861 6d70 6c65 3a20 7374 796c  // Example: styl
-00014030: 653d 2273 7461 6767 6572 2220 7769 7468  e="stagger" with
-00014040: 2063 6972 6375 6d3d 7472 7565 0a2f 2f20   circum=true.// 
-00014050: 2020 7370 6865 726f 6964 2864 3d31 3030    spheroid(d=100
-00014060: 2c20 7374 796c 653d 2273 7461 6767 6572  , style="stagger
-00014070: 222c 2063 6972 6375 6d3d 7472 7565 2c20  ", circum=true, 
-00014080: 2466 6e3d 3130 293b 0a2f 2f20 4578 616d  $fn=10);.// Exam
-00014090: 706c 653a 2073 7479 6c65 3d22 6f63 7461  ple: style="octa
-000140a0: 222c 206f 6374 6168 6564 7261 6c20 6261  ", octahedral ba
-000140b0: 7365 6420 7465 7373 656c 6174 696f 6e2e  sed tesselation.
-000140c0: 2020 496e 2074 6869 7320 7374 796c 652c    In this style,
-000140d0: 2024 666e 2069 7320 7175 616e 7469 7a65   $fn is quantize
-000140e0: 6420 746f 2061 206d 756c 7469 706c 6520  d to a multiple 
-000140f0: 6f66 2034 2e20 0a2f 2f20 2020 7370 6865  of 4. .//   sphe
-00014100: 726f 6964 2864 3d31 3030 2c20 7374 796c  roid(d=100, styl
-00014110: 653d 226f 6374 6122 2c20 2466 6e3d 3130  e="octa", $fn=10
-00014120: 293b 0a2f 2f20 4578 616d 706c 653a 2073  );.// Example: s
-00014130: 7479 6c65 3d22 6f63 7461 222c 2077 6974  tyle="octa", wit
-00014140: 6820 6369 7263 756d 3d74 7275 652c 2070  h circum=true, p
-00014150: 726f 6475 6365 7320 6d6f 7374 6c79 2076  roduces mostly v
-00014160: 6572 7920 6972 7265 6775 6c61 7220 6865  ery irregular he
-00014170: 7861 676f 6e61 6c20 6661 6365 730a 2f2f  xagonal faces.//
-00014180: 2020 2073 7068 6572 6f69 6428 643d 3130     spheroid(d=10
-00014190: 302c 2073 7479 6c65 3d22 6f63 7461 222c  0, style="octa",
-000141a0: 2063 6972 6375 6d3d 7472 7565 2c20 2466   circum=true, $f
-000141b0: 6e3d 3136 293b 0a2f 2f20 4578 616d 706c  n=16);.// Exampl
-000141c0: 653a 2073 7479 6c65 3d22 6963 6f73 6122  e: style="icosa"
-000141d0: 2c20 6963 6f73 6168 6564 7261 6c20 6261  , icosahedral ba
-000141e0: 7365 6420 7465 7373 656c 6174 696f 6e2e  sed tesselation.
-000141f0: 2020 496e 2074 6869 7320 7374 796c 652c    In this style,
-00014200: 2024 666e 2069 7320 7175 616e 7469 7a65   $fn is quantize
-00014210: 6420 746f 2061 206d 756c 7469 706c 6520  d to a multiple 
-00014220: 6f66 2035 2e0a 2f2f 2020 2073 7068 6572  of 5..//   spher
-00014230: 6f69 6428 643d 3130 302c 2073 7479 6c65  oid(d=100, style
-00014240: 3d22 6963 6f73 6122 2c20 2466 6e3d 3130  ="icosa", $fn=10
-00014250: 293b 2020 0a2f 2f20 4578 616d 706c 653a  );  .// Example:
-00014260: 2073 7479 6c65 3d22 6963 6f73 6122 2c20   style="icosa", 
-00014270: 6369 7263 756d 3d74 7275 652e 2020 5468  circum=true.  Th
-00014280: 6973 2073 7479 6c65 2068 6173 2068 6578  is style has hex
-00014290: 6167 6f6e 7320 616e 6420 3132 2070 656e  agons and 12 pen
-000142a0: 7461 676f 6e73 2c20 7369 6d69 6c61 7220  tagons, similar 
-000142b0: 746f 2028 6275 7420 6e6f 7420 7468 6520  to (but not the 
-000142c0: 7361 6d65 2061 7329 2061 2073 6f63 6365  same as) a socce
-000142d0: 7220 6261 6c6c 2e0a 2f2f 2020 2073 7068  r ball..//   sph
-000142e0: 6572 6f69 6428 643d 3130 302c 2073 7479  eroid(d=100, sty
-000142f0: 6c65 3d22 6963 6f73 6122 2c20 6369 7263  le="icosa", circ
-00014300: 756d 3d74 7275 652c 2024 666e 3d31 3029  um=true, $fn=10)
-00014310: 3b20 200a 2f2f 2045 7861 6d70 6c65 3a20  ;  .// Example: 
-00014320: 416e 6368 6f72 696e 670a 2f2f 2020 2073  Anchoring.//   s
-00014330: 7068 6572 6f69 6428 643d 3130 302c 2061  pheroid(d=100, a
-00014340: 6e63 686f 723d 4652 4f4e 5429 3b0a 2f2f  nchor=FRONT);.//
-00014350: 2045 7861 6d70 6c65 3a20 5370 696e 0a2f   Example: Spin./
-00014360: 2f20 2020 7370 6865 726f 6964 2864 3d31  /   spheroid(d=1
-00014370: 3030 2c20 616e 6368 6f72 3d46 524f 4e54  00, anchor=FRONT
-00014380: 2c20 7370 696e 3d34 3529 3b0a 2f2f 2045  , spin=45);.// E
-00014390: 7861 6d70 6c65 3a20 4f72 6965 6e74 6174  xample: Orientat
-000143a0: 696f 6e0a 2f2f 2020 2073 7068 6572 6f69  ion.//   spheroi
-000143b0: 6428 643d 3130 302c 2061 6e63 686f 723d  d(d=100, anchor=
-000143c0: 4652 4f4e 542c 2073 7069 6e3d 3435 2c20  FRONT, spin=45, 
-000143d0: 6f72 6965 6e74 3d46 5744 293b 0a2f 2f20  orient=FWD);.// 
-000143e0: 4578 616d 706c 653a 2053 7461 6e64 6172  Example: Standar
-000143f0: 6420 436f 6e6e 6563 746f 7273 0a2f 2f20  d Connectors.// 
-00014400: 2020 7370 6865 726f 6964 2864 3d35 3029    spheroid(d=50)
-00014410: 2073 686f 775f 616e 6368 6f72 7328 293b   show_anchors();
-00014420: 0a2f 2f20 4578 616d 706c 653a 2043 616c  .// Example: Cal
-00014430: 6c65 6420 6173 2046 756e 6374 696f 6e0a  led as Function.
-00014440: 2f2f 2020 2076 6e66 203d 2073 7068 6572  //   vnf = spher
-00014450: 6f69 6428 643d 3130 302c 2073 7479 6c65  oid(d=100, style
-00014460: 3d22 6963 6f73 6122 293b 0a2f 2f20 2020  ="icosa");.//   
-00014470: 766e 665f 706f 6c79 6865 6472 6f6e 2876  vnf_polyhedron(v
-00014480: 6e66 293b 0a2f 2f20 4578 616d 706c 653a  nf);.// Example:
-00014490: 2057 6974 6820 226f 7269 6722 2074 6865   With "orig" the
-000144a0: 2063 6972 6375 6d73 6372 6962 696e 6720   circumscribing 
-000144b0: 7370 6865 7265 2068 6173 2074 6865 2073  sphere has the s
-000144c0: 616d 6520 666f 726d 2e20 2054 6865 2067  ame form.  The g
-000144d0: 7265 656e 2073 7068 6572 6520 6973 2061  reen sphere is a
-000144e0: 2074 696e 7920 6269 7420 6f76 6572 7369   tiny bit oversi
-000144f0: 7a65 6420 736f 2069 7420 706f 6b65 7320  zed so it pokes 
-00014500: 7468 726f 7567 6820 7468 6520 6c6f 7720  through the low 
-00014510: 706f 696e 7473 2069 6e20 7468 6520 6369  points in the ci
-00014520: 7263 756d 7363 7269 6265 6420 7370 6865  rcumscribed sphe
-00014530: 7265 2077 6974 6820 6c6f 7720 2466 6e2e  re with low $fn.
-00014540: 2020 5468 6973 2064 656d 6f6e 7374 7261    This demonstra
-00014550: 7465 7320 7468 6174 2074 6865 7365 2073  tes that these s
-00014560: 7068 6572 6573 2061 7265 2069 6e20 6661  pheres are in fa
-00014570: 6374 2063 6972 6375 6d73 6372 6962 696e  ct circumscribin
-00014580: 672e 2020 0a2f 2f20 2020 636f 6c6f 7228  g.  .//   color(
-00014590: 2267 7265 656e 2229 7370 6865 726f 6964  "green")spheroid
-000145a0: 2872 3d31 302e 3031 2c20 2466 6e3d 3235  (r=10.01, $fn=25
-000145b0: 3629 3b0a 2f2f 2020 2073 7068 6572 6f69  6);.//   spheroi
-000145c0: 6428 723d 3130 2c20 7374 796c 653d 226f  d(r=10, style="o
-000145d0: 7269 6722 2c20 6369 7263 756d 3d74 7275  rig", circum=tru
-000145e0: 652c 2024 666e 3d31 3629 3b0a 2f2f 2045  e, $fn=16);.// E
-000145f0: 7861 6d70 6c65 3a20 5769 7468 2022 616c  xample: With "al
-00014600: 6967 6e65 6422 2074 6865 2073 616d 6520  igned" the same 
-00014610: 6973 2074 7275 653a 2074 6865 2063 6972  is true: the cir
-00014620: 6375 6d73 6372 6962 696e 6720 7370 6865  cumscribing sphe
-00014630: 7265 2069 7320 616c 736f 2061 6c69 676e  re is also align
-00014640: 6564 2c20 6966 2024 666e 2069 7320 6469  ed, if $fn is di
-00014650: 7669 7369 626c 6520 6279 2034 2e20 0a2f  visible by 4. ./
-00014660: 2f20 2020 636f 6c6f 7228 2267 7265 656e  /   color("green
-00014670: 2229 7370 6865 726f 6964 2872 3d31 302e  ")spheroid(r=10.
-00014680: 3031 2c20 2466 6e3d 3235 3629 3b0a 2f2f  01, $fn=256);.//
-00014690: 2020 2073 7068 6572 6f69 6428 723d 3130     spheroid(r=10
-000146a0: 2c20 7374 796c 653d 2261 6c69 676e 6564  , style="aligned
-000146b0: 222c 2063 6972 6375 6d3d 7472 7565 2c20  ", circum=true, 
-000146c0: 2466 6e3d 3136 293b 0a2f 2f20 4578 616d  $fn=16);.// Exam
-000146d0: 706c 653a 2046 6f72 2074 6865 206f 7468  ple: For the oth
-000146e0: 6572 2073 7479 6c65 732c 2074 6865 2063  er styles, the c
-000146f0: 6972 6375 6d73 6372 6962 696e 6720 7370  ircumscribing sp
-00014700: 6865 7265 2069 7320 6469 6666 6572 656e  here is differen
-00014710: 742c 2061 7320 7368 6f77 6e20 6865 7265  t, as shown here
-00014720: 2077 6974 6820 2273 7461 6767 6572 220a   with "stagger".
-00014730: 2f2f 2020 2063 6f6c 6f72 2822 6772 6565  //   color("gree
-00014740: 6e22 2973 7068 6572 6f69 6428 723d 3130  n")spheroid(r=10
-00014750: 2e30 312c 2024 666e 3d32 3536 293b 0a2f  .01, $fn=256);./
-00014760: 2f20 2020 7370 6865 726f 6964 2872 3d31  /   spheroid(r=1
-00014770: 302c 2073 7479 6c65 3d22 7374 6167 6765  0, style="stagge
-00014780: 7222 2c20 6369 7263 756d 3d74 7275 652c  r", circum=true,
-00014790: 2024 666e 3d31 3629 3b0a 2f2f 2045 7861   $fn=16);.// Exa
-000147a0: 6d70 6c65 3a20 5468 6520 6475 616c 206f  mple: The dual o
-000147b0: 6620 226f 6374 6122 2074 6861 7420 7072  f "octa" that pr
-000147c0: 6f76 6964 6573 2074 6865 2063 6972 6375  ovides the circu
-000147d0: 6d73 6372 6962 696e 6720 7370 6865 7265  mscribing sphere
-000147e0: 2068 6173 2077 6569 7264 2061 7379 6d6d   has weird asymm
-000147f0: 6574 7269 6320 6865 7861 676f 6e61 6c20  etric hexagonal 
-00014800: 6661 6365 733a 0a2f 2f20 2020 636f 6c6f  faces:.//   colo
-00014810: 7228 2267 7265 656e 2229 7370 6865 726f  r("green")sphero
-00014820: 6964 2872 3d31 302e 3031 2c20 2466 6e3d  id(r=10.01, $fn=
-00014830: 3235 3629 3b0a 2f2f 2020 2073 7068 6572  256);.//   spher
-00014840: 6f69 6428 723d 3130 2c20 7374 796c 653d  oid(r=10, style=
-00014850: 226f 6374 6122 2c20 6369 7263 756d 3d74  "octa", circum=t
-00014860: 7275 652c 2024 666e 3d31 3629 3b0a 2f2f  rue, $fn=16);.//
-00014870: 2045 7861 6d70 6c65 3a20 5468 6520 6475   Example: The du
-00014880: 616c 206f 6620 2269 636f 7361 2220 6665  al of "icosa" fe
-00014890: 6174 7572 6573 2068 6578 6167 6f6e 7320  atures hexagons 
-000148a0: 616e 6420 616c 7761 7973 2031 3220 7065  and always 12 pe
-000148b0: 6e74 6167 6f6e 733a 0a2f 2f20 2020 636f  ntagons:.//   co
-000148c0: 6c6f 7228 2267 7265 656e 2229 7370 6865  lor("green")sphe
-000148d0: 726f 6964 2872 3d31 302e 3031 2c20 2466  roid(r=10.01, $f
-000148e0: 6e3d 3235 3629 3b0a 2f2f 2020 2073 7068  n=256);.//   sph
-000148f0: 6572 6f69 6428 723d 3130 2c20 7374 796c  eroid(r=10, styl
-00014900: 653d 2269 636f 7361 222c 2063 6972 6375  e="icosa", circu
-00014910: 6d3d 7472 7565 2c20 2466 6e3d 3136 293b  m=true, $fn=16);
-00014920: 0a6d 6f64 756c 6520 7370 6865 726f 6964  .module spheroid
-00014930: 2872 2c20 7374 796c 653d 2261 6c69 676e  (r, style="align
-00014940: 6564 222c 2064 2c20 6369 7263 756d 3d66  ed", d, circum=f
-00014950: 616c 7365 2c20 6475 616c 3d66 616c 7365  alse, dual=false
-00014960: 2c20 616e 6368 6f72 3d43 454e 5445 522c  , anchor=CENTER,
-00014970: 2073 7069 6e3d 302c 206f 7269 656e 743d   spin=0, orient=
-00014980: 5550 290a 7b0a 2020 2020 7220 3d20 6765  UP).{.    r = ge
-00014990: 745f 7261 6469 7573 2872 3d72 2c20 643d  t_radius(r=r, d=
-000149a0: 642c 2064 666c 743d 3129 3b0a 2020 2020  d, dflt=1);.    
-000149b0: 7369 6465 7320 3d20 7365 6773 2872 293b  sides = segs(r);
-000149c0: 0a20 2020 2076 7369 6465 7320 3d20 6365  .    vsides = ce
-000149d0: 696c 2873 6964 6573 2f32 293b 0a20 2020  il(sides/2);.   
-000149e0: 2061 7474 6163 6861 626c 6528 616e 6368   attachable(anch
-000149f0: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
-00014a00: 723d 7229 207b 0a20 2020 2020 2020 2069  r=r) {.        i
-00014a10: 6620 2873 7479 6c65 3d3d 226f 7269 6722  f (style=="orig"
-00014a20: 2026 2620 2163 6972 6375 6d29 207b 0a20   && !circum) {. 
-00014a30: 2020 2020 2020 2020 2020 206d 6572 6964             merid
-00014a40: 7320 3d20 5b20 666f 7220 2869 3d5b 303a  s = [ for (i=[0:
-00014a50: 313a 7673 6964 6573 2d31 5d29 2039 302d  1:vsides-1]) 90-
-00014a60: 2869 2b30 2e35 292a 3138 302f 7673 6964  (i+0.5)*180/vsid
-00014a70: 6573 205d 3b0a 2020 2020 2020 2020 2020  es ];.          
-00014a80: 2020 7061 7468 203d 205b 0a20 2020 2020    path = [.     
-00014a90: 2020 2020 2020 2020 2020 206c 6574 2861             let(a
-00014aa0: 203d 206d 6572 6964 735b 305d 2920 5b30   = merids[0]) [0
-00014ab0: 2c20 7369 6e28 6129 5d2c 0a20 2020 2020  , sin(a)],.     
-00014ac0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-00014ad0: 613d 6d65 7269 6473 2920 5b63 6f73 2861  a=merids) [cos(a
-00014ae0: 292c 2073 696e 2861 295d 2c0a 2020 2020  ), sin(a)],.    
-00014af0: 2020 2020 2020 2020 2020 2020 6c65 7428              let(
-00014b00: 6120 3d20 6c61 7374 286d 6572 6964 7329  a = last(merids)
-00014b10: 2920 5b30 2c20 7369 6e28 6129 5d0a 2020  ) [0, sin(a)].  
-00014b20: 2020 2020 2020 2020 2020 5d3b 0a20 2020            ];.   
-00014b30: 2020 2020 2020 2020 2073 6361 6c65 2872           scale(r
-00014b40: 2920 726f 7461 7465 2831 3830 2920 726f  ) rotate(180) ro
-00014b50: 7461 7465 5f65 7874 7275 6465 2863 6f6e  tate_extrude(con
-00014b60: 7665 7869 7479 3d32 2c24 666e 3d73 6964  vexity=2,$fn=sid
-00014b70: 6573 2920 706f 6c79 676f 6e28 7061 7468  es) polygon(path
-00014b80: 293b 0a20 2020 2020 2020 207d 0a20 2020  );.        }.   
-00014b90: 2020 2020 202f 2f20 446f 6e27 7420 6e6f       // Don't no
-00014ba0: 7720 686f 7720 746f 2063 6f6e 7374 7275  w how to constru
-00014bb0: 6374 2066 6163 6573 2066 6f72 2074 6865  ct faces for the
-00014bc0: 7365 2065 6666 6963 6965 6e74 6c79 2c20  se efficiently, 
-00014bd0: 736f 2075 7365 2068 756c 6c5f 706f 696e  so use hull_poin
-00014be0: 7473 2c20 7768 6963 680a 2020 2020 2020  ts, which.      
-00014bf0: 2020 2f2f 2069 7320 7665 7279 206d 7563    // is very muc
-00014c00: 6820 6661 7374 6572 2074 6861 6e20 7573  h faster than us
-00014c10: 696e 6720 6875 6c6c 2829 2061 7320 6861  ing hull() as ha
-00014c20: 7070 656e 7320 696e 2074 6865 2073 7068  ppens in the sph
-00014c30: 6572 6f69 6428 2920 6675 6e63 7469 6f6e  eroid() function
-00014c40: 0a20 2020 2020 2020 2065 6c73 6520 6966  .        else if
-00014c50: 2028 6369 7263 756d 2026 2620 2873 7479   (circum && (sty
-00014c60: 6c65 3d3d 226f 6374 6122 207c 7c20 7374  le=="octa" || st
-00014c70: 796c 653d 3d22 6963 6f73 6122 2929 207b  yle=="icosa")) {
-00014c80: 0a20 2020 2020 2020 2020 2020 206f 7269  .            ori
-00014c90: 675f 7370 6865 7265 203d 2073 7068 6572  g_sphere = spher
-00014ca0: 6f69 6428 722c 7374 796c 652c 6369 7263  oid(r,style,circ
-00014cb0: 756d 3d66 616c 7365 293b 0a20 2020 2020  um=false);.     
-00014cc0: 2020 2020 2020 2064 7561 6c76 6572 7420         dualvert 
-00014cd0: 3d20 5f64 7561 6c5f 7665 7274 6963 6573  = _dual_vertices
-00014ce0: 286f 7269 675f 7370 6865 7265 293b 0a20  (orig_sphere);. 
-00014cf0: 2020 2020 2020 2020 2020 2068 756c 6c5f             hull_
-00014d00: 706f 696e 7473 2864 7561 6c76 6572 742c  points(dualvert,
-00014d10: 6661 7374 3d74 7275 6529 3b0a 2020 2020  fast=true);.    
-00014d20: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
-00014d30: 2020 2020 2020 2020 2076 6e66 203d 2073           vnf = s
-00014d40: 7068 6572 6f69 6428 723d 722c 2063 6972  pheroid(r=r, cir
-00014d50: 6375 6d3d 6369 7263 756d 2c20 7374 796c  cum=circum, styl
-00014d60: 653d 7374 796c 6529 3b0a 2020 2020 2020  e=style);.      
-00014d70: 2020 2020 2020 766e 665f 706f 6c79 6865        vnf_polyhe
-00014d80: 6472 6f6e 2876 6e66 2c20 636f 6e76 6578  dron(vnf, convex
-00014d90: 6974 793d 3229 3b0a 2020 2020 2020 2020  ity=2);.        
-00014da0: 7d0a 2020 2020 2020 2020 6368 696c 6472  }.        childr
-00014db0: 656e 2829 3b0a 2020 2020 7d0a 7d0a 0a0a  en();.    }.}...
-00014dc0: 2f2f 2070 2069 7320 6120 6c69 7374 206f  // p is a list o
-00014dd0: 6620 3320 706f 696e 7473 2064 6566 696e  f 3 points defin
-00014de0: 696e 6720 6120 7472 6961 6e67 6c65 2069  ing a triangle i
-00014df0: 6e20 616e 7920 6469 6d65 6e73 696f 6e2e  n any dimension.
-00014e00: 2020 4e20 6973 2074 6865 206e 756d 6265    N is the numbe
-00014e10: 7220 6f66 2065 7874 7261 2070 6f69 6e74  r of extra point
-00014e20: 730a 2f2f 2074 6f20 6164 642c 2073 6f20  s.// to add, so 
-00014e30: 6f75 7470 7574 2074 7269 616e 676c 6520  output triangle 
-00014e40: 6861 7320 4e2b 3220 706f 696e 7473 206f  has N+2 points o
-00014e50: 6e20 6561 6368 2073 6964 652e 2020 0a66  n each side.  .f
-00014e60: 756e 6374 696f 6e20 5f73 7562 7361 6d70  unction _subsamp
-00014e70: 6c65 5f74 7269 616e 676c 6528 702c 4e29  le_triangle(p,N)
-00014e80: 203d 200a 2020 2020 5b66 6f72 2869 3d5b   = .    [for(i=[
-00014e90: 303a 4e2b 315d 2920 5b66 6f72 2028 6a3d  0:N+1]) [for (j=
-00014ea0: 5b30 3a4e 2b31 2d69 5d29 2075 6e69 7428  [0:N+1-i]) unit(
-00014eb0: 6c65 7270 2870 5b30 5d2c 705b 315d 2c69  lerp(p[0],p[1],i
-00014ec0: 2f28 4e2b 3129 2920 2b20 2870 5b32 5d2d  /(N+1)) + (p[2]-
-00014ed0: 705b 305d 292a 6a2f 284e 2b31 2929 5d5d  p[0])*j/(N+1))]]
-00014ee0: 3b0a 0a0a 2f2f 2049 6e70 7574 2073 686f  ;...// Input sho
-00014ef0: 756c 6420 6861 7665 206f 6e6c 7920 7472  uld have only tr
-00014f00: 6961 6e67 756c 6172 2066 6163 6573 0a66  iangular faces.f
-00014f10: 756e 6374 696f 6e20 5f64 7561 6c5f 7665  unction _dual_ve
-00014f20: 7274 6963 6573 2876 6e66 2920 3d0a 2020  rtices(vnf) =.  
-00014f30: 6c65 7428 7665 7274 3d76 6e66 5b30 5d29  let(vert=vnf[0])
-00014f40: 0a20 205b 666f 7228 6661 6365 3d76 6e66  .  [for(face=vnf
-00014f50: 5b31 5d29 0a20 2020 2020 206c 6574 2870  [1]).      let(p
-00014f60: 6c61 6e65 7320 3d20 7365 6c65 6374 2876  lanes = select(v
-00014f70: 6572 742c 6661 6365 2929 0a20 2020 2020  ert,face)).     
-00014f80: 202f 2f6c 696e 6561 725f 736f 6c76 6533   //linear_solve3
-00014f90: 2870 6c61 6e65 732c 205b 666f 7228 703d  (planes, [for(p=
-00014fa0: 706c 616e 6573 2920 702a 705d 290a 2020  planes) p*p]).  
-00014fb0: 2020 2020 6c69 6e65 6172 5f73 6f6c 7665      linear_solve
-00014fc0: 3328 7365 6c65 6374 2870 6c61 6e65 732c  3(select(planes,
-00014fd0: 302c 3229 2c20 5b66 6f72 2869 3d5b 303a  0,2), [for(i=[0:
-00014fe0: 325d 2920 706c 616e 6573 5b69 5d2a 706c  2]) planes[i]*pl
-00014ff0: 616e 6573 5b69 5d5d 2920 2f2f 2048 616e  anes[i]]) // Han
-00015000: 646c 6520 6c61 7267 6572 2066 6163 6573  dle larger faces
-00015010: 2c20 6d61 7962 653f 0a20 205d 3b0a 0a0a  , maybe?.  ];...
-00015020: 6675 6e63 7469 6f6e 2073 7068 6572 6f69  function spheroi
-00015030: 6428 722c 2073 7479 6c65 3d22 616c 6967  d(r, style="alig
-00015040: 6e65 6422 2c20 642c 2063 6972 6375 6d3d  ned", d, circum=
-00015050: 6661 6c73 652c 2061 6e63 686f 723d 4345  false, anchor=CE
-00015060: 4e54 4552 2c20 7370 696e 3d30 2c20 6f72  NTER, spin=0, or
-00015070: 6965 6e74 3d55 5029 203d 0a20 2020 206c  ient=UP) =.    l
-00015080: 6574 280a 2020 2020 2020 2020 7220 3d20  et(.        r = 
-00015090: 6765 745f 7261 6469 7573 2872 3d72 2c20  get_radius(r=r, 
-000150a0: 643d 642c 2064 666c 743d 3129 2c0a 2020  d=d, dflt=1),.  
-000150b0: 2020 2020 2020 6873 6964 6573 203d 2073        hsides = s
-000150c0: 6567 7328 7229 2c0a 2020 2020 2020 2020  egs(r),.        
-000150d0: 7673 6964 6573 203d 206d 6178 2832 2c63  vsides = max(2,c
-000150e0: 6569 6c28 6873 6964 6573 2f32 2929 2c0a  eil(hsides/2)),.
-000150f0: 2020 2020 2020 2020 6f63 7461 5f73 7465          octa_ste
-00015100: 7073 203d 2072 6f75 6e64 286d 6178 2834  ps = round(max(4
-00015110: 2c68 7369 6465 7329 2f34 292c 0a20 2020  ,hsides)/4),.   
-00015120: 2020 2020 2069 636f 7361 5f73 7465 7073       icosa_steps
-00015130: 203d 2072 6f75 6e64 286d 6178 2835 2c68   = round(max(5,h
-00015140: 7369 6465 7329 2f35 292c 0a20 2020 2020  sides)/5),.     
-00015150: 2020 2073 7461 6767 6572 203d 2073 7479     stagger = sty
-00015160: 6c65 3d3d 2273 7461 6767 6572 220a 2020  le=="stagger".  
-00015170: 2020 2029 0a20 2020 2020 6369 7263 756d     ).     circum
-00015180: 2026 2620 7374 796c 653d 3d22 6f72 6967   && style=="orig
-00015190: 2220 3f0a 2020 2020 2020 2020 206c 6574  " ?.         let
-000151a0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000151b0: 6f72 6967 5f73 7068 6572 6520 3d20 7370  orig_sphere = sp
-000151c0: 6865 726f 6964 2872 2c22 616c 6967 6e65  heroid(r,"aligne
-000151d0: 6422 2c63 6972 6375 6d3d 6661 6c73 6529  d",circum=false)
-000151e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000151f0: 6475 616c 7665 7274 203d 207a 726f 7428  dualvert = zrot(
-00015200: 3336 302f 6873 6964 6573 2f32 2c5f 6475  360/hsides/2,_du
-00015210: 616c 5f76 6572 7469 6365 7328 6f72 6967  al_vertices(orig
-00015220: 5f73 7068 6572 6529 292c 0a20 2020 2020  _sphere)),.     
-00015230: 2020 2020 2020 2020 2063 756c 6c65 6476           culledv
-00015240: 6572 7420 3d20 5b0a 2020 2020 2020 2020  ert = [.        
-00015250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015260: 2020 2020 2020 5b66 6f72 2869 3d5b 303a        [for(i=[0:
-00015270: 323a 322a 6873 6964 6573 2d31 5d29 2064  2:2*hsides-1]) d
-00015280: 7561 6c76 6572 745b 695d 5d2c 0a20 2020  ualvert[i]],.   
-00015290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152a0: 2020 2020 2020 2020 2020 2066 6f72 286a             for(j
-000152b0: 3d5b 313a 7673 6964 6573 2d32 5d29 0a20  =[1:vsides-2]). 
-000152c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000152e0: 5b66 6f72 2869 3d5b 303a 323a 322a 6873  [for(i=[0:2:2*hs
-000152f0: 6964 6573 2d31 5d29 2064 7561 6c76 6572  ides-1]) dualver
-00015300: 745b 6a2a 322a 6873 6964 6573 2b69 5d5d  t[j*2*hsides+i]]
-00015310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015330: 5b66 6f72 2869 3d5b 313a 323a 322a 6873  [for(i=[1:2:2*hs
-00015340: 6964 6573 2d31 5d29 2064 7561 6c76 6572  ides-1]) dualver
-00015350: 745b 695d 5d0a 2020 2020 2020 2020 2020  t[i]].          
-00015360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015370: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
-00015380: 2020 766e 6620 3d20 766e 665f 7665 7274    vnf = vnf_vert
-00015390: 6578 5f61 7272 6179 2863 756c 6c65 6476  ex_array(culledv
-000153a0: 6572 742c 636f 6c5f 7772 6170 3d74 7275  ert,col_wrap=tru
-000153b0: 652c 6361 7073 3d74 7275 6529 0a20 2020  e,caps=true).   
-000153c0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-000153d0: 2020 205b 7265 6f72 6965 6e74 2861 6e63     [reorient(anc
-000153e0: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
-000153f0: 2072 3d72 2c20 703d 766e 665b 305d 292c   r=r, p=vnf[0]),
-00015400: 2076 6e66 5b31 5d5d 0a20 2020 2020 3a0a   vnf[1]].     :.
-00015410: 2020 2020 2063 6972 6375 6d20 2626 2028       circum && (
-00015420: 7374 796c 653d 3d22 6f63 7461 2220 7c7c  style=="octa" ||
-00015430: 2073 7479 6c65 3d3d 2269 636f 7361 2229   style=="icosa")
-00015440: 203f 0a20 2020 2020 2020 2020 6c65 7428   ?.         let(
-00015450: 0a20 2020 2020 2020 2020 2020 2020 206f  .              o
-00015460: 7269 675f 7370 6865 7265 203d 2073 7068  rig_sphere = sph
-00015470: 6572 6f69 6428 722c 7374 796c 652c 6369  eroid(r,style,ci
-00015480: 7263 756d 3d66 616c 7365 292c 0a20 2020  rcum=false),.   
-00015490: 2020 2020 2020 2020 2020 2064 7561 6c76             dualv
-000154a0: 6572 7420 3d20 5f64 7561 6c5f 7665 7274  ert = _dual_vert
-000154b0: 6963 6573 286f 7269 675f 7370 6865 7265  ices(orig_sphere
-000154c0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-000154d0: 2066 6163 6573 203d 2068 756c 6c28 6475   faces = hull(du
-000154e0: 616c 7665 7274 290a 2020 2020 2020 2020  alvert).        
-000154f0: 2029 0a20 2020 2020 2020 2020 5b72 656f   ).         [reo
-00015500: 7269 656e 7428 616e 6368 6f72 2c73 7069  rient(anchor,spi
-00015510: 6e2c 6f72 6965 6e74 2c20 723d 722c 2070  n,orient, r=r, p
-00015520: 3d64 7561 6c76 6572 7429 2c20 6661 6365  =dualvert), face
-00015530: 735d 0a20 2020 2020 3a0a 2020 2020 2073  s].     :.     s
-00015540: 7479 6c65 3d3d 2269 636f 7361 2220 3f20  tyle=="icosa" ? 
-00015550: 2020 202f 2f20 7375 6264 6976 6964 6520     // subdivide 
-00015560: 6661 6365 7320 6f66 2061 6e20 6963 6f73  faces of an icos
-00015570: 6168 6564 726f 6e20 616e 6420 7072 6f6a  ahedron and proj
-00015580: 6563 7420 7468 656d 206f 6e74 6f20 6120  ect them onto a 
-00015590: 7370 6865 7265 0a20 2020 2020 2020 2020  sphere.         
-000155a0: 6c65 7428 2020 0a20 2020 2020 2020 2020  let(  .         
-000155b0: 2020 2020 4e20 3d20 6963 6f73 615f 7374      N = icosa_st
-000155c0: 6570 732d 312c 0a20 2020 2020 2020 2020  eps-1,.         
-000155d0: 2020 2020 2f2f 2063 6f6e 7374 7275 6374      // construct
-000155e0: 2061 6e20 6963 6f73 6168 6564 726f 6e0a   an icosahedron.
-000155f0: 2020 2020 2020 2020 2020 2020 2069 636f               ico
-00015600: 7665 7274 3d5b 2066 6f72 2869 3d5b 2d31  vert=[ for(i=[-1
-00015610: 2c31 5d2c 206a 3d5b 2d31 2c31 5d29 2065  ,1], j=[-1,1]) e
-00015620: 6163 6820 5b5b 302c 692c 6a2a 5048 495d  ach [[0,i,j*PHI]
-00015630: 2c20 5b69 2c6a 2a50 4849 2c30 5d2c 205b  , [i,j*PHI,0], [
-00015640: 6a2a 5048 492c 302c 695d 5d5d 2c0a 2020  j*PHI,0,i]]],.  
-00015650: 2020 2020 2020 2020 2020 2069 636f 6661             icofa
-00015660: 6365 203d 2068 756c 6c28 6963 6f76 6572  ce = hull(icover
-00015670: 7429 2c0a 2020 2020 2020 2020 2020 2020  t),.            
-00015680: 202f 2f20 5375 6273 616d 706c 6520 6661   // Subsample fa
-00015690: 6365 2030 206f 6620 7468 6520 6963 6f73  ce 0 of the icos
-000156a0: 6168 6564 726f 6e0a 2020 2020 2020 2020  ahedron.        
-000156b0: 2020 2020 2066 6163 6530 203d 2073 656c       face0 = sel
-000156c0: 6563 7428 6963 6f76 6572 742c 6963 6f66  ect(icovert,icof
-000156d0: 6163 655b 305d 292c 0a20 2020 2020 2020  ace[0]),.       
-000156e0: 2020 2020 2020 7361 6d70 6c65 6420 3d20        sampled = 
-000156f0: 7220 2a20 5f73 7562 7361 6d70 6c65 5f74  r * _subsample_t
-00015700: 7269 616e 676c 6528 6661 6365 302c 4e29  riangle(face0,N)
-00015710: 2c0a 2020 2020 2020 2020 2020 2020 2064  ,.             d
-00015720: 6972 3020 3d20 6d65 616e 2866 6163 6530  ir0 = mean(face0
-00015730: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00015740: 706f 696e 7430 203d 2066 6163 6530 5b30  point0 = face0[0
-00015750: 5d2d 6469 7230 2c0a 2020 2020 2020 2020  ]-dir0,.        
-00015760: 2020 2020 202f 2f20 4d61 6b65 2061 2072       // Make a r
-00015770: 6f74 6174 6564 2063 6f70 7920 6f66 2074  otated copy of t
-00015780: 6865 2073 7562 7361 6d70 6c65 6420 7472  he subsampled tr
-00015790: 6961 6e67 6c65 206f 6e20 6561 6368 2069  iangle on each i
-000157a0: 636f 7361 6865 6472 616c 2066 6163 650a  cosahedral face.
-000157b0: 2020 2020 2020 2020 2020 2020 2074 7269               tri
-000157c0: 5f6c 6973 7420 3d20 5b73 616d 706c 6564  _list = [sampled
-000157d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000157e0: 2020 2020 2020 2020 2020 2066 6f72 2869             for(i
-000157f0: 3d5b 313a 313a 6c65 6e28 6963 6f66 6163  =[1:1:len(icofac
-00015800: 6529 2d31 5d29 0a20 2020 2020 2020 2020  e)-1]).         
-00015810: 2020 2020 2020 2020 6c65 7428 6661 6365          let(face
-00015820: 203d 2073 656c 6563 7428 6963 6f76 6572   = select(icover
-00015830: 742c 6963 6f66 6163 655b 695d 2929 0a20  t,icoface[i])). 
-00015840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015850: 6170 706c 7928 6672 616d 655f 6d61 7028  apply(frame_map(
-00015860: 7a3d 6d65 616e 2866 6163 6529 2c78 3d66  z=mean(face),x=f
-00015870: 6163 655b 305d 2d6d 6561 6e28 6661 6365  ace[0]-mean(face
-00015880: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00015890: 2020 2020 2020 2020 2020 202a 6672 616d             *fram
-000158a0: 655f 6d61 7028 7a3d 6469 7230 2c78 3d70  e_map(z=dir0,x=p
-000158b0: 6f69 6e74 302c 7265 7665 7273 653d 7472  oint0,reverse=tr
-000158c0: 7565 292c 0a20 2020 2020 2020 2020 2020  ue),.           
-000158d0: 2020 2020 2020 2020 2020 2020 7361 6d70              samp
-000158e0: 6c65 6429 5d2c 0a20 2020 2020 2020 2020  led)],.         
-000158f0: 2020 2020 2f2f 2066 6163 6573 2066 6f72      // faces for
-00015900: 2074 6865 2066 6972 7374 2074 7269 616e   the first trian
-00015910: 676c 6520 6772 6f75 700a 2020 2020 2020  gle group.      
-00015920: 2020 2020 2020 2066 6163 6573 203d 2076         faces = v
-00015930: 6e66 5f74 7269 5f61 7272 6179 2874 7269  nf_tri_array(tri
-00015940: 5f6c 6973 745b 305d 2c72 6576 6572 7365  _list[0],reverse
-00015950: 3d74 7275 6529 5b31 5d2c 0a20 2020 2020  =true)[1],.     
-00015960: 2020 2020 2020 2020 7369 7a65 203d 2072          size = r
-00015970: 6570 6561 7428 284e 2b32 292a 284e 2b33  epeat((N+2)*(N+3
-00015980: 292f 322c 3329 2c0a 2020 2020 2020 2020  )/2,3),.        
-00015990: 2020 2020 202f 2f20 4578 7061 6e64 2074       // Expand t
-000159a0: 6f20 6675 6c6c 2066 6163 6520 6c69 7374  o full face list
-000159b0: 0a20 2020 2020 2020 2020 2020 2020 6675  .             fu
-000159c0: 6c6c 6661 6365 7320 3d20 5b66 6f72 2869  llfaces = [for(i
-000159d0: 3d69 6478 2874 7269 5f6c 6973 7429 2920  =idx(tri_list)) 
-000159e0: 6561 6368 205b 666f 7228 663d 6661 6365  each [for(f=face
-000159f0: 7329 2066 2b69 2a73 697a 655d 5d2c 0a20  s) f+i*size]],. 
-00015a00: 2020 2020 2020 2020 2020 2020 6675 6c6c              full
-00015a10: 7665 7274 203d 2066 6c61 7474 656e 2866  vert = flatten(f
-00015a20: 6c61 7474 656e 2874 7269 5f6c 6973 7429  latten(tri_list)
-00015a30: 2920 2020 202f 2f20 656c 696d 696e 6174  )    // eliminat
-00015a40: 6520 7472 6961 6e67 6c65 2073 7472 7563  e triangle struc
-00015a50: 7475 7265 0a20 2020 2020 2020 2020 2920  ture.         ) 
-00015a60: 0a20 2020 2020 2020 2020 5b72 656f 7269  .         [reori
-00015a70: 656e 7428 616e 6368 6f72 2c73 7069 6e2c  ent(anchor,spin,
-00015a80: 6f72 6965 6e74 2c20 723d 722c 2070 3d66  orient, r=r, p=f
-00015a90: 756c 6c76 6572 7429 2c20 6675 6c6c 6661  ullvert), fullfa
-00015aa0: 6365 735d 0a20 2020 2020 3a0a 2020 2020  ces].     :.    
-00015ab0: 206c 6574 280a 2020 2020 2020 2020 7665   let(.        ve
-00015ac0: 7274 7320 3d20 6369 7263 756d 2026 2620  rts = circum && 
-00015ad0: 7374 796c 653d 3d22 7374 6167 6765 7222  style=="stagger"
-00015ae0: 203f 205f 6475 616c 5f76 6572 7469 6365   ? _dual_vertice
-00015af0: 7328 7370 6865 726f 6964 2872 2c73 7479  s(spheroid(r,sty
-00015b00: 6c65 2c63 6972 6375 6d3d 6661 6c73 6529  le,circum=false)
-00015b10: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00015b20: 3a20 6369 7263 756d 2026 2620 7374 796c  : circum && styl
-00015b30: 653d 3d22 616c 6967 6e65 6422 203f 0a20  e=="aligned" ?. 
-00015b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015b50: 2020 2020 6c65 7428 0a20 2020 2020 2020      let(.       
-00015b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015b70: 2020 6f72 6967 5f73 7068 6572 6520 3d20    orig_sphere = 
-00015b80: 7370 6865 726f 6964 2872 2c22 6f72 6967  spheroid(r,"orig
-00015b90: 222c 6369 7263 756d 3d66 616c 7365 292c  ",circum=false),
-00015ba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015bb0: 2020 2020 2020 2020 2020 6475 616c 7665            dualve
-00015bc0: 7274 203d 205f 6475 616c 5f76 6572 7469  rt = _dual_verti
-00015bd0: 6365 7328 6f72 6967 5f73 7068 6572 6529  ces(orig_sphere)
-00015be0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00015bf0: 2020 2020 2020 2020 2020 2063 756c 6c65             culle
-00015c00: 6476 6572 7420 3d20 7a72 6f74 2833 3630  dvert = zrot(360
-00015c10: 2f68 7369 6465 732f 322c 0a20 2020 2020  /hsides/2,.     
-00015c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c40: 2020 2020 2020 5b64 7561 6c76 6572 745b        [dualvert[
-00015c50: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
-00015c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015c80: 666f 7228 693d 5b32 3a32 3a6c 656e 2864  for(i=[2:2:len(d
-00015c90: 7561 6c76 6572 7429 2d31 5d29 2064 7561  ualvert)-1]) dua
-00015ca0: 6c76 6572 745b 695d 2c0a 2020 2020 2020  lvert[i],.      
-00015cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015cd0: 2020 2020 2020 6475 616c 7665 7274 5b31        dualvert[1
-00015ce0: 5d5d 290a 2020 2020 2020 2020 2020 2020  ]]).            
-00015cf0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00015d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d10: 2020 6375 6c6c 6564 7665 7274 0a20 2020    culledvert.   
-00015d20: 2020 2020 2020 2020 2020 203a 2073 7479             : sty
-00015d30: 6c65 3d3d 226f 7269 6722 3f20 5b0a 2020  le=="orig"? [.  
-00015d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d50: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00015d60: 6f72 2028 693d 5b30 3a31 3a76 7369 6465  or (i=[0:1:vside
-00015d70: 732d 315d 290a 2020 2020 2020 2020 2020  s-1]).          
-00015d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d90: 2020 2020 2020 2020 2020 206c 6574 2870             let(p
-00015da0: 6869 203d 2028 692b 302e 3529 2a31 3830  hi = (i+0.5)*180
-00015db0: 2f28 7673 6964 6573 2929 0a20 2020 2020  /(vsides)).     
-00015dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015de0: 666f 7220 286a 3d5b 303a 313a 6873 6964  for (j=[0:1:hsid
-00015df0: 6573 2d31 5d29 0a20 2020 2020 2020 2020  es-1]).         
-00015e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e20: 6c65 7428 7468 6574 6120 3d20 6a2a 3336  let(theta = j*36
-00015e30: 302f 6873 6964 6573 290a 2020 2020 2020  0/hsides).      
-00015e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015e60: 2020 2073 7068 6572 6963 616c 5f74 6f5f     spherical_to_
-00015e70: 7879 7a28 722c 2074 6865 7461 2c20 7068  xyz(r, theta, ph
-00015e80: 6929 2c0a 2020 2020 2020 2020 2020 2020  i),.            
-00015e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ea0: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
-00015eb0: 2020 203a 2073 7479 6c65 3d3d 2261 6c69     : style=="ali
-00015ec0: 676e 6564 2220 7c7c 2073 7479 6c65 3d3d  gned" || style==
-00015ed0: 2273 7461 6767 6572 223f 0a20 2020 2020  "stagger"?.     
-00015ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ef0: 2020 2020 5b20 7370 6865 7269 6361 6c5f      [ spherical_
-00015f00: 746f 5f78 797a 2872 2c20 302c 2030 292c  to_xyz(r, 0, 0),
-00015f10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015f20: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00015f30: 2869 3d5b 313a 313a 7673 6964 6573 2d31  (i=[1:1:vsides-1
-00015f40: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00015f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015f60: 2020 6c65 7428 7068 6920 3d20 692a 3138    let(phi = i*18
-00015f70: 302f 7673 6964 6573 290a 2020 2020 2020  0/vsides).      
-00015f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015f90: 2020 2020 2020 2020 2066 6f72 2028 6a3d           for (j=
-00015fa0: 5b30 3a31 3a68 7369 6465 732d 315d 290a  [0:1:hsides-1]).
-00015fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015fd0: 2020 206c 6574 2874 6865 7461 203d 2028     let(theta = (
-00015fe0: 6a2b 2828 7374 6167 6765 7220 2626 2069  j+((stagger && i
-00015ff0: 2532 213d 3029 3f30 2e35 3a30 2929 2a33  %2!=0)?0.5:0))*3
-00016000: 3630 2f68 7369 6465 7329 0a20 2020 2020  60/hsides).     
-00016010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016020: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-00016030: 6865 7269 6361 6c5f 746f 5f78 797a 2872  herical_to_xyz(r
-00016040: 2c20 7468 6574 612c 2070 6869 292c 0a20  , theta, phi),. 
-00016050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016060: 2020 2020 2020 2020 2020 7370 6865 7269            spheri
-00016070: 6361 6c5f 746f 5f78 797a 2872 2c20 302c  cal_to_xyz(r, 0,
-00016080: 2031 3830 290a 2020 2020 2020 2020 2020   180).          
-00016090: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-000160a0: 0a20 2020 2020 2020 2020 2020 2020 203a  .              :
-000160b0: 2073 7479 6c65 3d3d 226f 6374 6122 3f0a   style=="octa"?.
-000160c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000160d0: 2020 2020 2020 6c65 7428 0a20 2020 2020        let(.     
-000160e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000160f0: 2020 2020 2020 6d65 7269 6469 616e 7320        meridians 
-00016100: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
-00016110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016120: 2020 2020 2020 2020 2020 2020 312c 0a20              1,. 
-00016130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016150: 2020 2020 2020 2066 6f72 2028 6920 3d20         for (i = 
-00016160: 5b31 3a31 3a6f 6374 615f 7374 6570 735d  [1:1:octa_steps]
-00016170: 2920 692a 342c 0a20 2020 2020 2020 2020  ) i*4,.         
-00016180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016190: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000161a0: 6f72 2028 6920 3d20 5b6f 6374 615f 7374  or (i = [octa_st
-000161b0: 6570 732d 313a 2d31 3a31 5d29 2069 2a34  eps-1:-1:1]) i*4
-000161c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000161d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000161e0: 2020 2020 2020 2020 2020 312c 0a20 2020            1,.   
-000161f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016210: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
-00016220: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00016230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016240: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
-00016250: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00016260: 2028 693d 6964 7828 6d65 7269 6469 616e   (i=idx(meridian
-00016270: 7329 2c20 6a3d 5b30 3a31 3a6d 6572 6964  s), j=[0:1:merid
-00016280: 6961 6e73 5b69 5d2d 315d 290a 2020 2020  ians[i]-1]).    
-00016290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000162a0: 2020 2020 2020 2073 7068 6572 6963 616c         spherical
-000162b0: 5f74 6f5f 7879 7a28 722c 206a 2a33 3630  _to_xyz(r, j*360
-000162c0: 2f6d 6572 6964 6961 6e73 5b69 5d2c 2069  /meridians[i], i
-000162d0: 2a31 3830 2f28 6c65 6e28 6d65 7269 6469  *180/(len(meridi
-000162e0: 616e 7329 2d31 2929 0a20 2020 2020 2020  ans)-1)).       
-000162f0: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-00016300: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00016310: 2020 2020 2020 3a20 6173 7365 7274 2869        : assert(i
-00016320: 6e5f 6c69 7374 2873 7479 6c65 2c5b 226f  n_list(style,["o
-00016330: 7269 6722 2c22 616c 6967 6e65 6422 2c22  rig","aligned","
-00016340: 7374 6167 6765 7222 2c22 6f63 7461 222c  stagger","octa",
-00016350: 2269 636f 7361 225d 2929 2c0a 2020 2020  "icosa"])),.    
-00016360: 2020 2020 6c76 203d 206c 656e 2876 6572      lv = len(ver
-00016370: 7473 292c 0a20 2020 2020 2020 2066 6163  ts),.        fac
-00016380: 6573 203d 2063 6972 6375 6d20 2626 2073  es = circum && s
-00016390: 7479 6c65 3d3d 2273 7461 6767 6572 2220  tyle=="stagger" 
-000163a0: 3f20 200a 2020 2020 2020 2020 2020 2020  ?  .            
-000163b0: 2020 2020 2020 2020 206c 6574 2870 7463           let(ptc
-000163c0: 6f75 6e74 3d32 2a68 7369 6465 7329 0a20  ount=2*hsides). 
-000163d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163e0: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
-000163f0: 2020 2020 2020 2020 2020 2020 205b 666f               [fo
-00016400: 7228 693d 5b70 7463 6f75 6e74 2d32 3a2d  r(i=[ptcount-2:-
-00016410: 323a 305d 2920 695d 2c0a 2020 2020 2020  2:0]) i],.      
-00016420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016430: 2066 6f72 286a 3d5b 303a 6873 6964 6573   for(j=[0:hsides
-00016440: 2d31 5d29 0a20 2020 2020 2020 2020 2020  -1]).           
-00016450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016460: 5b6a 2a32 2c20 286a 2a32 2b32 2925 7074  [j*2, (j*2+2)%pt
-00016470: 636f 756e 742c 7074 636f 756e 742b 286a  count,ptcount+(j
-00016480: 2a32 2b32 2925 7074 636f 756e 742c 7074  *2+2)%ptcount,pt
-00016490: 636f 756e 742b 286a 2a32 2b33 2925 7074  count+(j*2+3)%pt
-000164a0: 636f 756e 742c 7074 636f 756e 742b 6a2a  count,ptcount+j*
-000164b0: 325d 2c0a 2020 2020 2020 2020 2020 2020  2],.            
-000164c0: 2020 2020 2020 2020 2020 2066 6f72 2869             for(i
-000164d0: 3d5b 313a 7673 6964 6573 2d33 5d29 0a20  =[1:vsides-3]). 
-000164e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000164f0: 2020 2020 2020 2020 2020 6c65 7428 6261            let(ba
-00016500: 7365 3d70 7463 6f75 6e74 2a69 290a 2020  se=ptcount*i).  
-00016510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016520: 2020 2020 2020 2020 2066 6f72 286a 3d5b           for(j=[
-00016530: 303a 6873 6964 6573 2d31 5d29 0a20 2020  0:hsides-1]).   
-00016540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016550: 2020 2020 2020 2020 2020 2020 6925 323d              i%2=
-00016560: 3d30 203f 205b 6261 7365 2b32 2a6a 2c20  =0 ? [base+2*j, 
-00016570: 6261 7365 2b28 322a 6a2b 3129 2570 7463  base+(2*j+1)%ptc
-00016580: 6f75 6e74 2c20 6261 7365 2b28 322a 6a2b  ount, base+(2*j+
-00016590: 3229 2570 7463 6f75 6e74 2c0a 2020 2020  2)%ptcount,.    
-000165a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000165b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000165c0: 2020 2020 6261 7365 2b70 7463 6f75 6e74      base+ptcount
-000165d0: 2b28 322a 6a29 2570 7463 6f75 6e74 2c20  +(2*j)%ptcount, 
-000165e0: 6261 7365 2b70 7463 6f75 6e74 2b28 322a  base+ptcount+(2*
-000165f0: 6a2b 3129 2570 7463 6f75 6e74 2c20 6261  j+1)%ptcount, ba
-00016600: 7365 2b70 7463 6f75 6e74 2b28 322a 6a2d  se+ptcount+(2*j-
-00016610: 322b 7074 636f 756e 7429 2570 7463 6f75  2+ptcount)%ptcou
-00016620: 6e74 5d0a 2020 2020 2020 2020 2020 2020  nt].            
-00016630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016640: 2020 2020 2020 2020 2020 3a20 5b62 6173            : [bas
-00016650: 652b 2831 2b32 2a6a 2925 7074 636f 756e  e+(1+2*j)%ptcoun
-00016660: 742c 2062 6173 652b 2832 2a6a 2925 7074  t, base+(2*j)%pt
-00016670: 636f 756e 742c 2062 6173 652b 2832 2a6a  count, base+(2*j
-00016680: 2b33 2925 7074 636f 756e 742c 0a20 2020  +3)%ptcount,.   
-00016690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000166a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000166b0: 2020 2020 2020 6261 7365 2b70 7463 6f75        base+ptcou
-000166c0: 6e74 2b28 332b 322a 6a29 2570 7463 6f75  nt+(3+2*j)%ptcou
-000166d0: 6e74 2c20 6261 7365 2b70 7463 6f75 6e74  nt, base+ptcount
-000166e0: 2b28 322a 6a2b 3229 2570 7463 6f75 6e74  +(2*j+2)%ptcount
-000166f0: 2c62 6173 652b 7074 636f 756e 742b 2832  ,base+ptcount+(2
-00016700: 2a6a 2b31 2925 7074 636f 756e 745d 2c0a  *j+1)%ptcount],.
-00016710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016720: 2020 2020 2020 2066 6f72 286a 3d5b 303a         for(j=[0:
-00016730: 6873 6964 6573 2d31 5d29 0a20 2020 2020  hsides-1]).     
-00016740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016750: 2020 2020 2076 7369 6465 7325 323d 3d30       vsides%2==0
-00016760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016770: 2020 2020 2020 2020 2020 2020 203f 205b               ? [
-00016780: 286a 2a32 2b33 2925 7074 636f 756e 742c  (j*2+3)%ptcount,
-00016790: 206a 2a32 2b31 2c20 6c76 2d70 7463 6f75   j*2+1, lv-ptcou
-000167a0: 6e74 2b28 322b 6a2a 3229 2570 7463 6f75  nt+(2+j*2)%ptcou
-000167b0: 6e74 2c20 6c76 2d70 7463 6f75 6e74 2b28  nt, lv-ptcount+(
-000167c0: 332b 6a2a 3229 2570 7463 6f75 6e74 2c20  3+j*2)%ptcount, 
-000167d0: 6c76 2d70 7463 6f75 6e74 2b28 342b 6a2a  lv-ptcount+(4+j*
-000167e0: 3229 2570 7463 6f75 6e74 5d0a 2020 2020  2)%ptcount].    
-000167f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016800: 2020 2020 2020 2020 3a20 5b28 6a2a 322b          : [(j*2+
-00016810: 3329 2570 7463 6f75 6e74 2c20 6a2a 322b  3)%ptcount, j*2+
-00016820: 312c 206c 762d 7074 636f 756e 742b 2831  1, lv-ptcount+(1
-00016830: 2b6a 2a32 2925 7074 636f 756e 742c 206c  +j*2)%ptcount, l
-00016840: 762d 7074 636f 756e 742b 286a 2a32 2925  v-ptcount+(j*2)%
-00016850: 7074 636f 756e 742c 206c 762d 7074 636f  ptcount, lv-ptco
-00016860: 756e 742b 2833 2b6a 2a32 2925 7074 636f  unt+(3+j*2)%ptco
-00016870: 756e 745d 2c0a 2020 2020 2020 2020 2020  unt],.          
-00016880: 2020 2020 2020 2020 2020 2020 205b 666f               [fo
-00016890: 7228 693d 5b31 3a32 3a70 7463 6f75 6e74  r(i=[1:2:ptcount
-000168a0: 2d31 5d29 2069 5d2c 0a20 2020 2020 2020  -1]) i],.       
-000168b0: 2020 2020 2020 2020 2020 2020 2020 5d20                ] 
-000168c0: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
-000168d0: 2020 2020 203a 2073 7479 6c65 3d3d 2261       : style=="a
-000168e0: 6c69 676e 6564 2220 7c7c 2073 7479 6c65  ligned" || style
-000168f0: 3d3d 2273 7461 6767 6572 2220 3f20 202f  =="stagger" ?  /
-00016900: 2f20 696e 636c 7564 6573 2063 6173 6520  / includes case 
-00016910: 6f66 2061 6c69 676e 6564 2077 6974 6820  of aligned with 
-00016920: 6369 7263 756d 203d 3d20 7472 7565 0a20  circum == true. 
-00016930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016940: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
-00016950: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00016960: 2028 693d 5b30 3a31 3a68 7369 6465 732d   (i=[0:1:hsides-
-00016970: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
-00016980: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00016990: 6574 2862 3220 3d20 6c76 2d32 2d68 7369  et(b2 = lv-2-hsi
-000169a0: 6465 7329 0a20 2020 2020 2020 2020 2020  des).           
-000169b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169c0: 6561 6368 205b 0a20 2020 2020 2020 2020  each [.         
-000169d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169e0: 2020 2020 2020 2020 5b69 2b31 2c20 302c          [i+1, 0,
-000169f0: 2028 2869 2b31 2925 6873 6964 6573 292b   ((i+1)%hsides)+
-00016a00: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-00016a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a20: 2020 2020 205b 6c76 2d31 2c20 6232 2b69       [lv-1, b2+i
-00016a30: 2b31 2c20 6232 2b28 2869 2b31 2925 6873  +1, b2+((i+1)%hs
-00016a40: 6964 6573 292b 315d 2c0a 2020 2020 2020  ides)+1],.      
-00016a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a60: 2020 2020 2020 2020 2020 5d2c 0a20 2020            ],.   
-00016a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a80: 2020 2020 666f 7220 2869 3d5b 303a 313a      for (i=[0:1:
-00016a90: 7673 6964 6573 2d33 5d2c 206a 3d5b 303a  vsides-3], j=[0:
-00016aa0: 313a 6873 6964 6573 2d31 5d29 0a20 2020  1:hsides-1]).   
-00016ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ac0: 2020 2020 2020 2020 6c65 7428 6261 7365          let(base
-00016ad0: 203d 2031 202b 2068 7369 6465 732a 6929   = 1 + hsides*i)
-00016ae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016af0: 2020 2020 2020 2020 2020 2020 6561 6368              each
-00016b00: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00016b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b20: 2020 2020 2873 7461 6767 6572 2026 2620      (stagger && 
-00016b30: 6925 3221 3d30 293f 205b 0a20 2020 2020  i%2!=0)? [.     
-00016b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b60: 5b62 6173 652b 6a2c 2062 6173 652b 6873  [base+j, base+hs
-00016b70: 6964 6573 2b6a 2568 7369 6465 732c 2062  ides+j%hsides, b
-00016b80: 6173 652b 6873 6964 6573 2b28 6a2b 6873  ase+hsides+(j+hs
-00016b90: 6964 6573 2d31 2925 6873 6964 6573 5d2c  ides-1)%hsides],
-00016ba0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016bc0: 2020 2020 2020 5b62 6173 652b 6a2c 2062        [base+j, b
-00016bd0: 6173 652b 286a 2b31 2925 6873 6964 6573  ase+(j+1)%hsides
-00016be0: 2c20 6261 7365 2b68 7369 6465 732b 6a5d  , base+hsides+j]
-00016bf0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00016c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016c10: 2020 205d 203a 205b 0a20 2020 2020 2020     ] : [.       
-00016c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016c30: 2020 2020 2020 2020 2020 2020 2020 5b62                [b
-00016c40: 6173 652b 6a2c 2062 6173 652b 286a 2b31  ase+j, base+(j+1
-00016c50: 2925 6873 6964 6573 2c20 6261 7365 2b68  )%hsides, base+h
-00016c60: 7369 6465 732b 286a 2b31 2925 6873 6964  sides+(j+1)%hsid
-00016c70: 6573 5d2c 0a20 2020 2020 2020 2020 2020  es],.           
-00016c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016c90: 2020 2020 2020 2020 2020 5b62 6173 652b            [base+
-00016ca0: 6a2c 2062 6173 652b 6873 6964 6573 2b28  j, base+hsides+(
-00016cb0: 6a2b 3129 2568 7369 6465 732c 2062 6173  j+1)%hsides, bas
-00016cc0: 652b 6873 6964 6573 2b6a 5d2c 0a20 2020  e+hsides+j],.   
-00016cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ce0: 2020 2020 2020 2020 2020 2020 2020 5d20                ] 
-00016cf0: 200a 2020 2020 2020 2020 2020 2020 2020   .              
-00016d00: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-00016d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016d20: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
-00016d30: 2020 2020 3a20 7374 796c 653d 3d22 6f72      : style=="or
-00016d40: 6967 223f 205b 0a20 2020 2020 2020 2020  ig"? [.         
-00016d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016d60: 2020 2020 2020 205b 666f 7220 2869 3d5b         [for (i=[
-00016d70: 303a 313a 6873 6964 6573 2d31 5d29 2068  0:1:hsides-1]) h
-00016d80: 7369 6465 732d 692d 315d 2c0a 2020 2020  sides-i-1],.    
-00016d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016da0: 2020 2020 2020 2020 2020 2020 5b66 6f72              [for
-00016db0: 2028 693d 5b30 3a31 3a68 7369 6465 732d   (i=[0:1:hsides-
-00016dc0: 315d 2920 6c76 2d68 7369 6465 732b 695d  1]) lv-hsides+i]
-00016dd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00016de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016df0: 2020 666f 7220 2869 3d5b 303a 313a 7673    for (i=[0:1:vs
-00016e00: 6964 6573 2d32 5d2c 206a 3d5b 303a 313a  ides-2], j=[0:1:
-00016e10: 6873 6964 6573 2d31 5d29 0a20 2020 2020  hsides-1]).     
-00016e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016e30: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00016e40: 6163 6820 5b0a 2020 2020 2020 2020 2020  ach [.          
-00016e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016e70: 5b28 692b 3129 2a68 7369 6465 732b 6a2c  [(i+1)*hsides+j,
-00016e80: 2069 2a68 7369 6465 732b 6a2c 2069 2a68   i*hsides+j, i*h
-00016e90: 7369 6465 732b 286a 2b31 2925 6873 6964  sides+(j+1)%hsid
-00016ea0: 6573 5d2c 0a20 2020 2020 2020 2020 2020  es],.           
-00016eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ec0: 2020 2020 2020 2020 2020 2020 2020 205b                 [
-00016ed0: 2869 2b31 292a 6873 6964 6573 2b6a 2c20  (i+1)*hsides+j, 
-00016ee0: 692a 6873 6964 6573 2b28 6a2b 3129 2568  i*hsides+(j+1)%h
-00016ef0: 7369 6465 732c 2028 692b 3129 2a68 7369  sides, (i+1)*hsi
-00016f00: 6465 732b 286a 2b31 2925 6873 6964 6573  des+(j+1)%hsides
-00016f10: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-00016f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f30: 2020 2020 2020 205d 2020 2020 2020 2020         ]        
-00016f40: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-00016f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f60: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
-00016f70: 2020 2020 2020 2020 2020 203a 202f 2a73             : /*s
-00016f80: 7479 6c65 3d3d 226f 6374 6122 3f2a 2f0a  tyle=="octa"?*/.
-00016f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016fa0: 2020 2020 206c 6574 280a 2020 2020 2020       let(.      
-00016fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016fc0: 2020 206d 6572 6964 6961 6e73 203d 205b     meridians = [
-00016fd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ff0: 2020 2020 2020 2030 2c20 312c 0a20 2020         0, 1,.   
-00017000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017020: 2020 2066 6f72 2028 6920 3d20 5b31 3a31     for (i = [1:1
-00017030: 3a6f 6374 615f 7374 6570 735d 2920 692a  :octa_steps]) i*
-00017040: 342c 0a20 2020 2020 2020 2020 2020 2020  4,.             
-00017050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017060: 2020 2020 2020 2020 2066 6f72 2028 6920           for (i 
-00017070: 3d20 5b6f 6374 615f 7374 6570 732d 313a  = [octa_steps-1:
-00017080: 2d31 3a31 5d29 2069 2a34 2c0a 2020 2020  -1:1]) i*4,.    
-00017090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170b0: 2020 312c 2020 2020 2020 200a 2020 2020    1,       .    
-000170c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000170e0: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
-000170f0: 2020 2020 2020 2020 2020 2020 206f 6666               off
-00017100: 7320 3d20 6375 6d73 756d 286d 6572 6964  s = cumsum(merid
-00017110: 6961 6e73 292c 0a20 2020 2020 2020 2020  ians),.         
-00017120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017130: 7063 203d 206c 6173 7428 6f66 6673 292d  pc = last(offs)-
-00017140: 312c 0a20 2020 2020 2020 2020 2020 2020  1,.             
-00017150: 2020 2020 2020 2020 2020 2020 6f73 203d              os =
-00017160: 206f 6374 615f 7374 6570 7320 2a20 320a   octa_steps * 2.
-00017170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017180: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00017190: 2020 2020 2020 2020 2020 2020 5b0a 2020              [.  
-000171a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000171b0: 2020 2020 666f 7220 2869 3d5b 303a 313a      for (i=[0:1:
-000171c0: 335d 2920 5b30 2c20 312b 2869 2b31 2925  3]) [0, 1+(i+1)%
-000171d0: 342c 2031 2b69 5d2c 0a20 2020 2020 2020  4, 1+i],.       
-000171e0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000171f0: 6f72 2028 693d 5b30 3a31 3a33 5d29 205b  or (i=[0:1:3]) [
-00017200: 7063 2d30 2c20 7063 2d28 312b 2869 2b31  pc-0, pc-(1+(i+1
-00017210: 2925 3429 2c20 7063 2d28 312b 6929 5d2c  )%4), pc-(1+i)],
-00017220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017230: 2020 2020 2020 2066 6f72 2028 693d 5b31         for (i=[1
-00017240: 3a31 3a6f 6374 615f 7374 6570 732d 315d  :1:octa_steps-1]
-00017250: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00017260: 2020 2020 2020 2020 2020 2020 6c65 7428              let(
-00017270: 6d20 3d20 6d65 7269 6469 616e 735b 692b  m = meridians[i+
-00017280: 325d 2f34 290a 2020 2020 2020 2020 2020  2]/4).          
-00017290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000172a0: 666f 7220 286a 3d5b 303a 313a 335d 2c20  for (j=[0:1:3], 
-000172b0: 6b3d 5b30 3a31 3a6d 2d31 5d29 0a20 2020  k=[0:1:m-1]).   
-000172c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000172d0: 2020 2020 2020 2020 2020 206c 6574 280a             let(.
-000172e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000172f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017300: 2020 6d31 203d 206d 6572 6964 6961 6e73    m1 = meridians
-00017310: 5b69 2b31 5d2c 0a20 2020 2020 2020 2020  [i+1],.         
-00017320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017330: 2020 2020 2020 2020 206d 3220 3d20 6d65           m2 = me
-00017340: 7269 6469 616e 735b 692b 325d 2c0a 2020  ridians[i+2],.  
-00017350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017370: 7031 203d 206f 6666 735b 692b 305d 202b  p1 = offs[i+0] +
-00017380: 2028 6a2a 6d31 2f34 202b 206b 2b30 2920   (j*m1/4 + k+0) 
-00017390: 2520 6d31 2c0a 2020 2020 2020 2020 2020  % m1,.          
-000173a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000173b0: 2020 2020 2020 2020 7032 203d 206f 6666          p2 = off
-000173c0: 735b 692b 305d 202b 2028 6a2a 6d31 2f34  s[i+0] + (j*m1/4
-000173d0: 202b 206b 2b31 2920 2520 6d31 2c0a 2020   + k+1) % m1,.  
-000173e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000173f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017400: 7033 203d 206f 6666 735b 692b 315d 202b  p3 = offs[i+1] +
-00017410: 2028 6a2a 6d32 2f34 202b 206b 2b30 2920   (j*m2/4 + k+0) 
-00017420: 2520 6d32 2c0a 2020 2020 2020 2020 2020  % m2,.          
-00017430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017440: 2020 2020 2020 2020 7034 203d 206f 6666          p4 = off
-00017450: 735b 692b 315d 202b 2028 6a2a 6d32 2f34  s[i+1] + (j*m2/4
-00017460: 202b 206b 2b31 2920 2520 6d32 2c0a 2020   + k+1) % m2,.  
-00017470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017490: 7035 203d 206f 6666 735b 6f73 2d69 2b30  p5 = offs[os-i+0
-000174a0: 5d20 2b20 286a 2a6d 312f 3420 2b20 6b2b  ] + (j*m1/4 + k+
-000174b0: 3029 2025 206d 312c 0a20 2020 2020 2020  0) % m1,.       
-000174c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000174d0: 2020 2020 2020 2020 2020 2070 3620 3d20             p6 = 
-000174e0: 6f66 6673 5b6f 732d 692b 305d 202b 2028  offs[os-i+0] + (
-000174f0: 6a2a 6d31 2f34 202b 206b 2b31 2920 2520  j*m1/4 + k+1) % 
-00017500: 6d31 2c0a 2020 2020 2020 2020 2020 2020  m1,.            
-00017510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017520: 2020 2020 2020 7037 203d 206f 6666 735b        p7 = offs[
-00017530: 6f73 2d69 2d31 5d20 2b20 286a 2a6d 322f  os-i-1] + (j*m2/
-00017540: 3420 2b20 6b2b 3029 2025 206d 322c 0a20  4 + k+0) % m2,. 
-00017550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017570: 2070 3820 3d20 6f66 6673 5b6f 732d 692d   p8 = offs[os-i-
-00017580: 315d 202b 2028 6a2a 6d32 2f34 202b 206b  1] + (j*m2/4 + k
-00017590: 2b31 2920 2520 6d32 0a20 2020 2020 2020  +1) % m2.       
-000175a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000175b0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-000175c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000175d0: 2020 2020 2020 2065 6163 6820 5b0a 2020         each [.  
-000175e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000175f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017600: 2020 5b70 312c 2070 342c 2070 335d 2c0a    [p1, p4, p3],.
-00017610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017630: 2020 2020 6966 2028 6b3c 6d2d 3129 205b      if (k<m-1) [
-00017640: 7031 2c20 7032 2c20 7034 5d2c 0a20 2020  p1, p2, p4],.   
-00017650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017670: 205b 7035 2c20 7037 2c20 7038 5d2c 0a20   [p5, p7, p8],. 
-00017680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000176a0: 2020 2069 6620 286b 3c6d 2d31 2920 5b70     if (k<m-1) [p
-000176b0: 352c 2070 382c 2070 365d 2c0a 2020 2020  5, p8, p6],.    
-000176c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000176d0: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
-000176e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000176f0: 2020 2020 2020 205d 200a 2020 2020 2920         ] .    ) 
-00017700: 5b72 656f 7269 656e 7428 616e 6368 6f72  [reorient(anchor
-00017710: 2c73 7069 6e2c 6f72 6965 6e74 2c20 723d  ,spin,orient, r=
-00017720: 722c 2070 3d76 6572 7473 292c 2066 6163  r, p=verts), fac
-00017730: 6573 5d3b 0a0a 0a0a 2f2f 2046 756e 6374  es];....// Funct
-00017740: 696f 6e26 4d6f 6475 6c65 3a20 746f 7275  ion&Module: toru
-00017750: 7328 290a 2f2f 0a2f 2f20 5573 6167 653a  s().//.// Usage:
-00017760: 2041 7320 4d6f 6475 6c65 0a2f 2f20 2020   As Module.//   
-00017770: 746f 7275 7328 725f 6d61 6a7c 645f 6d61  torus(r_maj|d_ma
-00017780: 6a2c 2072 5f6d 696e 7c64 5f6d 696e 2c20  j, r_min|d_min, 
-00017790: 5b63 656e 7465 725d 2c20 2e2e 2e29 205b  [center], ...) [
-000177a0: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-000177b0: 2020 2074 6f72 7573 286f 727c 6f64 2c20     torus(or|od, 
-000177c0: 6972 7c69 642c 202e 2e2e 2920 5b41 5454  ir|id, ...) [ATT
-000177d0: 4143 484d 454e 5453 5d3b 0a2f 2f20 2020  ACHMENTS];.//   
-000177e0: 746f 7275 7328 725f 6d61 6a7c 645f 6d61  torus(r_maj|d_ma
-000177f0: 6a2c 206f 727c 6f64 2c20 2e2e 2e29 205b  j, or|od, ...) [
-00017800: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
-00017810: 2020 2074 6f72 7573 2872 5f6d 616a 7c64     torus(r_maj|d
-00017820: 5f6d 616a 2c20 6972 7c69 642c 202e 2e2e  _maj, ir|id, ...
-00017830: 2920 5b41 5454 4143 484d 454e 5453 5d3b  ) [ATTACHMENTS];
-00017840: 0a2f 2f20 2020 746f 7275 7328 725f 6d69  .//   torus(r_mi
-00017850: 6e7c 645f 6d69 6e2c 206f 727c 6f64 2c20  n|d_min, or|od, 
-00017860: 2e2e 2e29 205b 4154 5441 4348 4d45 4e54  ...) [ATTACHMENT
-00017870: 535d 3b0a 2f2f 2020 2074 6f72 7573 2872  S];.//   torus(r
-00017880: 5f6d 696e 7c64 5f6d 696e 2c20 6972 7c69  _min|d_min, ir|i
-00017890: 642c 202e 2e2e 2920 5b41 5454 4143 484d  d, ...) [ATTACHM
-000178a0: 454e 5453 5d3b 0a2f 2f20 5573 6167 653a  ENTS];.// Usage:
-000178b0: 2041 7320 4675 6e63 7469 6f6e 0a2f 2f20   As Function.// 
-000178c0: 2020 766e 6620 3d20 746f 7275 7328 725f    vnf = torus(r_
-000178d0: 6d61 6a7c 645f 6d61 6a2c 2072 5f6d 696e  maj|d_maj, r_min
-000178e0: 7c64 5f6d 696e 2c20 5b63 656e 7465 725d  |d_min, [center]
-000178f0: 2c20 2e2e 2e29 3b0a 2f2f 2020 2076 6e66  , ...);.//   vnf
-00017900: 203d 2074 6f72 7573 286f 727c 6f64 2c20   = torus(or|od, 
-00017910: 6972 7c69 642c 202e 2e2e 293b 0a2f 2f20  ir|id, ...);.// 
-00017920: 2020 766e 6620 3d20 746f 7275 7328 725f    vnf = torus(r_
-00017930: 6d61 6a7c 645f 6d61 6a2c 206f 727c 6f64  maj|d_maj, or|od
-00017940: 2c20 2e2e 2e29 3b0a 2f2f 2020 2076 6e66  , ...);.//   vnf
-00017950: 203d 2074 6f72 7573 2872 5f6d 616a 7c64   = torus(r_maj|d
-00017960: 5f6d 616a 2c20 6972 7c69 642c 202e 2e2e  _maj, ir|id, ...
-00017970: 293b 0a2f 2f20 2020 766e 6620 3d20 746f  );.//   vnf = to
-00017980: 7275 7328 725f 6d69 6e7c 645f 6d69 6e2c  rus(r_min|d_min,
-00017990: 206f 727c 6f64 2c20 2e2e 2e29 3b0a 2f2f   or|od, ...);.//
-000179a0: 2020 2076 6e66 203d 2074 6f72 7573 2872     vnf = torus(r
-000179b0: 5f6d 696e 7c64 5f6d 696e 2c20 6972 7c69  _min|d_min, ir|i
-000179c0: 642c 202e 2e2e 293b 0a2f 2f0a 2f2f 2044  d, ...);.//.// D
-000179d0: 6573 6372 6970 7469 6f6e 3a0a 2f2f 2020  escription:.//  
-000179e0: 2043 7265 6174 6573 2061 2074 6f72 7573   Creates a torus
-000179f0: 2073 6861 7065 2e0a 2f2f 0a2f 2f20 4669   shape..//.// Fi
-00017a00: 6775 7265 2832 442c 4d65 6429 3a0a 2f2f  gure(2D,Med):.//
-00017a10: 2020 206d 6f64 756c 6520 6461 7368 6369     module dashci
-00017a20: 7263 2872 2c73 7461 7274 3d30 2c61 6e67  rc(r,start=0,ang
-00017a30: 6c65 3d33 3539 2e39 2c64 6173 686c 656e  le=359.9,dashlen
-00017a40: 3d35 2920 6c65 7428 7374 6570 3d33 3630  =5) let(step=360
-00017a50: 2a64 6173 686c 656e 2f28 322a 722a 5049  *dashlen/(2*r*PI
-00017a60: 2929 2066 6f72 2861 3d5b 7374 6172 743a  )) for(a=[start:
-00017a70: 7374 6570 3a73 7461 7274 2b61 6e67 6c65  step:start+angle
-00017a80: 5d29 2073 7472 6f6b 6528 6172 6328 723d  ]) stroke(arc(r=
-00017a90: 722c 7374 6172 743d 612c 616e 676c 653d  r,start=a,angle=
-00017aa0: 7374 6570 2f32 2929 3b0a 2f2f 2020 2072  step/2));.//   r
-00017ab0: 203d 2037 353b 2072 3220 3d20 3330 3b0a   = 75; r2 = 30;.
-00017ac0: 2f2f 2020 2064 6f77 6e28 7232 2b30 2e31  //   down(r2+0.1
-00017ad0: 2920 2374 6f72 7573 2872 5f6d 616a 3d72  ) #torus(r_maj=r
-00017ae0: 2c20 725f 6d69 6e3d 7232 2c20 2466 6e3d  , r_min=r2, $fn=
-00017af0: 3732 293b 0a2f 2f20 2020 636f 6c6f 7228  72);.//   color(
-00017b00: 2262 6c75 6522 2920 6c69 6e65 6172 5f65  "blue") linear_e
-00017b10: 7874 7275 6465 2868 6569 6768 743d 302e  xtrude(height=0.
-00017b20: 3031 2920 7b0a 2f2f 2020 2020 2020 2064  01) {.//       d
-00017b30: 6173 6863 6972 6328 723d 722c 7374 6172  ashcirc(r=r,star
-00017b40: 743d 3135 2c61 6e67 6c65 3d34 3529 3b0a  t=15,angle=45);.
-00017b50: 2f2f 2020 2020 2020 2064 6173 6863 6972  //       dashcir
-00017b60: 6328 723d 722d 7232 2c20 7374 6172 743d  c(r=r-r2, start=
-00017b70: 3930 2b31 352c 2061 6e67 6c65 3d36 3029  90+15, angle=60)
-00017b80: 3b0a 2f2f 2020 2020 2020 2064 6173 6863  ;.//       dashc
-00017b90: 6972 6328 723d 722b 7232 2c20 7374 6172  irc(r=r+r2, star
-00017ba0: 743d 3138 302b 3435 2c20 616e 676c 653d  t=180+45, angle=
-00017bb0: 3330 293b 0a2f 2f20 2020 2020 2020 6461  30);.//       da
-00017bc0: 7368 6369 7263 2872 3d72 2b72 322c 2073  shcirc(r=r+r2, s
-00017bd0: 7461 7274 3d31 352c 2061 6e67 6c65 3d33  tart=15, angle=3
-00017be0: 3029 3b0a 2f2f 2020 207d 0a2f 2f20 2020  0);.//   }.//   
-00017bf0: 726f 7428 3234 3029 2063 6f6c 6f72 2822  rot(240) color("
-00017c00: 626c 7565 2229 206c 696e 6561 725f 6578  blue") linear_ex
-00017c10: 7472 7564 6528 6865 6967 6874 3d30 2e30  trude(height=0.0
-00017c20: 3129 207b 0a2f 2f20 2020 2020 2020 7374  1) {.//       st
-00017c30: 726f 6b65 285b 5b30 2c30 5d2c 5b72 2b72  roke([[0,0],[r+r
-00017c40: 322c 305d 5d2c 2065 6e64 6361 7073 3d22  2,0]], endcaps="
-00017c50: 6172 726f 7732 222c 7769 6474 683d 3229  arrow2",width=2)
-00017c60: 3b0a 2f2f 2020 2020 2020 2072 6967 6874  ;.//       right
-00017c70: 2872 2920 6677 6428 3929 2072 6f74 282d  (r) fwd(9) rot(-
-00017c80: 3234 3029 2074 6578 7428 226f 7222 2c73  240) text("or",s
-00017c90: 697a 653d 3130 2c61 6e63 686f 723d 4345  ize=10,anchor=CE
-00017ca0: 4e54 4552 293b 0a2f 2f20 2020 7d0a 2f2f  NTER);.//   }.//
-00017cb0: 2020 2072 6f74 2831 3335 2920 636f 6c6f     rot(135) colo
-00017cc0: 7228 2262 6c75 6522 2920 6c69 6e65 6172  r("blue") linear
-00017cd0: 5f65 7874 7275 6465 2868 6569 6768 743d  _extrude(height=
-00017ce0: 302e 3031 2920 7b0a 2f2f 2020 2020 2020  0.01) {.//      
-00017cf0: 2073 7472 6f6b 6528 5b5b 302c 305d 2c5b   stroke([[0,0],[
-00017d00: 722d 7232 2c30 5d5d 2c20 656e 6463 6170  r-r2,0]], endcap
-00017d10: 733d 2261 7272 6f77 3222 2c77 6964 7468  s="arrow2",width
-00017d20: 3d32 293b 0a2f 2f20 2020 2020 2020 7269  =2);.//       ri
-00017d30: 6768 7428 2872 2d72 3229 2f32 2920 6261  ght((r-r2)/2) ba
-00017d40: 636b 2838 2920 726f 7428 2d31 3335 2920  ck(8) rot(-135) 
-00017d50: 7465 7874 2822 6972 222c 7369 7a65 3d31  text("ir",size=1
-00017d60: 302c 616e 6368 6f72 3d43 454e 5445 5229  0,anchor=CENTER)
-00017d70: 3b0a 2f2f 2020 207d 0a2f 2f20 2020 726f  ;.//   }.//   ro
-00017d80: 7428 3435 2920 636f 6c6f 7228 2262 6c75  t(45) color("blu
-00017d90: 6522 2920 6c69 6e65 6172 5f65 7874 7275  e") linear_extru
-00017da0: 6465 2868 6569 6768 743d 302e 3031 2920  de(height=0.01) 
-00017db0: 7b0a 2f2f 2020 2020 2020 2073 7472 6f6b  {.//       strok
-00017dc0: 6528 5b5b 302c 305d 2c5b 722c 305d 5d2c  e([[0,0],[r,0]],
-00017dd0: 2065 6e64 6361 7073 3d22 6172 726f 7732   endcaps="arrow2
-00017de0: 222c 7769 6474 683d 3229 3b0a 2f2f 2020  ",width=2);.//  
-00017df0: 2020 2020 2072 6967 6874 2872 2f32 2920       right(r/2) 
-00017e00: 6261 636b 2838 2920 7465 7874 2822 725f  back(8) text("r_
-00017e10: 6d61 6a22 2c73 697a 653d 392c 616e 6368  maj",size=9,anch
-00017e20: 6f72 3d43 454e 5445 5229 3b0a 2f2f 2020  or=CENTER);.//  
-00017e30: 207d 0a2f 2f20 2020 726f 7428 3330 2920   }.//   rot(30) 
-00017e40: 636f 6c6f 7228 2262 6c75 6522 2920 6c69  color("blue") li
-00017e50: 6e65 6172 5f65 7874 7275 6465 2868 6569  near_extrude(hei
-00017e60: 6768 743d 302e 3031 2920 7b0a 2f2f 2020  ght=0.01) {.//  
-00017e70: 2020 2020 2073 7472 6f6b 6528 5b5b 722c       stroke([[r,
-00017e80: 305d 2c5b 722b 7232 2c30 5d5d 2c20 656e  0],[r+r2,0]], en
-00017e90: 6463 6170 733d 2261 7272 6f77 3222 2c77  dcaps="arrow2",w
-00017ea0: 6964 7468 3d32 293b 0a2f 2f20 2020 2020  idth=2);.//     
-00017eb0: 2020 7269 6768 7428 722b 7232 2f32 2920    right(r+r2/2) 
-00017ec0: 6677 6428 3829 2074 6578 7428 2272 5f6d  fwd(8) text("r_m
-00017ed0: 696e 222c 7369 7a65 3d37 2c61 6e63 686f  in",size=7,ancho
-00017ee0: 723d 4345 4e54 4552 293b 0a2f 2f20 2020  r=CENTER);.//   
-00017ef0: 7d0a 2f2f 0a2f 2f20 4172 6775 6d65 6e74  }.//.// Argument
-00017f00: 733a 0a2f 2f20 2020 725f 6d61 6a20 3d20  s:.//   r_maj = 
-00017f10: 6d61 6a6f 7220 7261 6469 7573 206f 6620  major radius of 
-00017f20: 746f 7275 7320 7269 6e67 2e20 2875 7365  torus ring. (use
-00017f30: 2077 6974 6820 2772 5f6d 696e 272c 206f   with 'r_min', o
-00017f40: 7220 2764 5f6d 696e 2729 0a2f 2f20 2020  r 'd_min').//   
-00017f50: 725f 6d69 6e20 3d20 6d69 6e6f 7220 7261  r_min = minor ra
-00017f60: 6469 7573 206f 6620 746f 7275 7320 7269  dius of torus ri
-00017f70: 6e67 2e20 2875 7365 2077 6974 6820 2772  ng. (use with 'r
-00017f80: 5f6d 616a 272c 206f 7220 2764 5f6d 616a  _maj', or 'd_maj
-00017f90: 2729 0a2f 2f20 2020 6365 6e74 6572 203d  ').//   center =
-00017fa0: 2049 6620 6769 7665 6e2c 206f 7665 7272   If given, overr
-00017fb0: 6964 6573 2060 616e 6368 6f72 602e 2020  ides `anchor`.  
-00017fc0: 4120 7472 7565 2076 616c 7565 2073 6574  A true value set
-00017fd0: 7320 6061 6e63 686f 723d 4345 4e54 4552  s `anchor=CENTER
-00017fe0: 602c 2066 616c 7365 2073 6574 7320 6061  `, false sets `a
-00017ff0: 6e63 686f 723d 444f 574e 602e 0a2f 2f20  nchor=DOWN`..// 
-00018000: 2020 2d2d 2d0a 2f2f 2020 2064 5f6d 616a    ---.//   d_maj
-00018010: 2020 3d20 6d61 6a6f 7220 6469 616d 6574    = major diamet
-00018020: 6572 206f 6620 746f 7275 7320 7269 6e67  er of torus ring
-00018030: 2e20 2875 7365 2077 6974 6820 2772 5f6d  . (use with 'r_m
-00018040: 696e 272c 206f 7220 2764 5f6d 696e 2729  in', or 'd_min')
-00018050: 0a2f 2f20 2020 645f 6d69 6e20 3d20 6d69  .//   d_min = mi
-00018060: 6e6f 7220 6469 616d 6574 6572 206f 6620  nor diameter of 
-00018070: 746f 7275 7320 7269 6e67 2e20 2875 7365  torus ring. (use
-00018080: 2077 6974 6820 2772 5f6d 616a 272c 206f   with 'r_maj', o
-00018090: 7220 2764 5f6d 616a 2729 0a2f 2f20 2020  r 'd_maj').//   
-000180a0: 6f72 203d 206f 7574 6572 2072 6164 6975  or = outer radiu
-000180b0: 7320 6f66 2074 6865 2074 6f72 7573 2e20  s of the torus. 
-000180c0: 2875 7365 2077 6974 6820 2769 7227 2c20  (use with 'ir', 
-000180d0: 6f72 2027 6964 2729 0a2f 2f20 2020 6972  or 'id').//   ir
-000180e0: 203d 2069 6e73 6964 6520 7261 6469 7573   = inside radius
-000180f0: 206f 6620 7468 6520 746f 7275 732e 2028   of the torus. (
-00018100: 7573 6520 7769 7468 2027 6f72 272c 206f  use with 'or', o
-00018110: 7220 276f 6427 290a 2f2f 2020 206f 6420  r 'od').//   od 
-00018120: 3d20 6f75 7465 7220 6469 616d 6574 6572  = outer diameter
-00018130: 206f 6620 7468 6520 746f 7275 732e 2028   of the torus. (
-00018140: 7573 6520 7769 7468 2027 6972 2720 6f72  use with 'ir' or
-00018150: 2027 6964 2729 0a2f 2f20 2020 6964 203d   'id').//   id =
-00018160: 2069 6e73 6964 6520 6469 616d 6574 6572   inside diameter
-00018170: 206f 6620 7468 6520 746f 7275 732e 2028   of the torus. (
-00018180: 7573 6520 7769 7468 2027 6f72 2720 6f72  use with 'or' or
-00018190: 2027 6f64 2729 0a2f 2f20 2020 616e 6368   'od').//   anch
-000181a0: 6f72 203d 2054 7261 6e73 6c61 7465 2073  or = Translate s
-000181b0: 6f20 616e 6368 6f72 2070 6f69 6e74 2069  o anchor point i
-000181c0: 7320 6174 206f 7269 6769 6e20 2830 2c30  s at origin (0,0
-000181d0: 2c30 292e 2020 5365 6520 5b61 6e63 686f  ,0).  See [ancho
-000181e0: 725d 2861 7474 6163 686d 656e 7473 2e73  r](attachments.s
-000181f0: 6361 6423 7375 6273 6563 7469 6f6e 2d61  cad#subsection-a
-00018200: 6e63 686f 7229 2e20 2044 6566 6175 6c74  nchor).  Default
-00018210: 3a20 6043 454e 5445 5260 0a2f 2f20 2020  : `CENTER`.//   
-00018220: 6f72 6965 6e74 203d 2056 6563 746f 7220  orient = Vector 
-00018230: 746f 2072 6f74 6174 6520 746f 7020 746f  to rotate top to
-00018240: 7761 7264 732c 2061 6674 6572 2073 7069  wards, after spi
-00018250: 6e2e 2020 5365 6520 5b6f 7269 656e 745d  n.  See [orient]
-00018260: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-00018270: 6423 7375 6273 6563 7469 6f6e 2d6f 7269  d#subsection-ori
-00018280: 656e 7429 2e20 2044 6566 6175 6c74 3a20  ent).  Default: 
-00018290: 6055 5060 0a2f 2f0a 2f2f 2045 7861 6d70  `UP`.//.// Examp
-000182a0: 6c65 3a0a 2f2f 2020 202f 2f20 5468 6573  le:.//   // Thes
-000182b0: 6520 616c 6c20 7072 6f64 7563 6520 7468  e all produce th
-000182c0: 6520 7361 6d65 2074 6f72 7573 2e0a 2f2f  e same torus..//
-000182d0: 2020 2074 6f72 7573 2872 5f6d 616a 3d32     torus(r_maj=2
-000182e0: 322e 352c 2072 5f6d 696e 3d37 2e35 293b  2.5, r_min=7.5);
-000182f0: 0a2f 2f20 2020 746f 7275 7328 645f 6d61  .//   torus(d_ma
-00018300: 6a3d 3435 2c20 645f 6d69 6e3d 3135 293b  j=45, d_min=15);
-00018310: 0a2f 2f20 2020 746f 7275 7328 6f72 3d33  .//   torus(or=3
-00018320: 302c 2069 723d 3135 293b 0a2f 2f20 2020  0, ir=15);.//   
-00018330: 746f 7275 7328 6f64 3d36 302c 2069 643d  torus(od=60, id=
-00018340: 3330 293b 0a2f 2f20 2020 746f 7275 7328  30);.//   torus(
-00018350: 645f 6d61 6a3d 3435 2c20 6964 3d33 3029  d_maj=45, id=30)
-00018360: 3b0a 2f2f 2020 2074 6f72 7573 2864 5f6d  ;.//   torus(d_m
-00018370: 616a 3d34 352c 206f 643d 3630 293b 0a2f  aj=45, od=60);./
-00018380: 2f20 2020 746f 7275 7328 645f 6d69 6e3d  /   torus(d_min=
-00018390: 3135 2c20 6964 3d33 3029 3b0a 2f2f 2020  15, id=30);.//  
-000183a0: 2074 6f72 7573 2864 5f6d 696e 3d31 352c   torus(d_min=15,
-000183b0: 206f 643d 3630 293b 0a2f 2f20 2020 766e   od=60);.//   vn
-000183c0: 665f 706f 6c79 6865 6472 6f6e 2874 6f72  f_polyhedron(tor
-000183d0: 7573 2864 5f6d 696e 3d31 352c 206f 643d  us(d_min=15, od=
-000183e0: 3630 292c 2063 6f6e 7665 7869 7479 3d34  60), convexity=4
-000183f0: 293b 0a2f 2f20 4578 616d 706c 653a 2053  );.// Example: S
-00018400: 7461 6e64 6172 6420 436f 6e6e 6563 746f  tandard Connecto
-00018410: 7273 0a2f 2f20 2020 746f 7275 7328 6f64  rs.//   torus(od
-00018420: 3d36 302c 2069 643d 3330 2920 7368 6f77  =60, id=30) show
-00018430: 5f61 6e63 686f 7273 2829 3b0a 6d6f 6475  _anchors();.modu
-00018440: 6c65 2074 6f72 7573 280a 2020 2020 725f  le torus(.    r_
-00018450: 6d61 6a2c 2072 5f6d 696e 2c20 6365 6e74  maj, r_min, cent
-00018460: 6572 2c0a 2020 2020 645f 6d61 6a2c 2064  er,.    d_maj, d
-00018470: 5f6d 696e 2c0a 2020 2020 6f72 2c20 6f64  _min,.    or, od
-00018480: 2c20 6972 2c20 6964 2c0a 2020 2020 616e  , ir, id,.    an
-00018490: 6368 6f72 2c20 7370 696e 3d30 2c20 6f72  chor, spin=0, or
-000184a0: 6965 6e74 3d55 500a 2920 7b0a 2020 2020  ient=UP.) {.    
-000184b0: 5f6f 7220 3d20 6765 745f 7261 6469 7573  _or = get_radius
-000184c0: 2872 3d6f 722c 2064 3d6f 642c 2064 666c  (r=or, d=od, dfl
-000184d0: 743d 756e 6465 6629 3b0a 2020 2020 5f69  t=undef);.    _i
-000184e0: 7220 3d20 6765 745f 7261 6469 7573 2872  r = get_radius(r
-000184f0: 3d69 722c 2064 3d69 642c 2064 666c 743d  =ir, d=id, dflt=
-00018500: 756e 6465 6629 3b0a 2020 2020 5f72 5f6d  undef);.    _r_m
-00018510: 616a 203d 2067 6574 5f72 6164 6975 7328  aj = get_radius(
-00018520: 723d 725f 6d61 6a2c 2064 3d64 5f6d 616a  r=r_maj, d=d_maj
-00018530: 2c20 6466 6c74 3d75 6e64 6566 293b 0a20  , dflt=undef);. 
-00018540: 2020 205f 725f 6d69 6e20 3d20 6765 745f     _r_min = get_
-00018550: 7261 6469 7573 2872 3d72 5f6d 696e 2c20  radius(r=r_min, 
-00018560: 643d 645f 6d69 6e2c 2064 666c 743d 756e  d=d_min, dflt=un
-00018570: 6465 6629 3b0a 2020 2020 6d61 6a5f 7261  def);.    maj_ra
-00018580: 6420 3d20 6973 5f66 696e 6974 6528 5f72  d = is_finite(_r
-00018590: 5f6d 616a 293f 205f 725f 6d61 6a20 3a0a  _maj)? _r_maj :.
-000185a0: 2020 2020 2020 2020 6973 5f66 696e 6974          is_finit
-000185b0: 6528 5f69 7229 2026 2620 6973 5f66 696e  e(_ir) && is_fin
-000185c0: 6974 6528 5f6f 7229 3f20 285f 6f72 202b  ite(_or)? (_or +
-000185d0: 205f 6972 292f 3220 3a0a 2020 2020 2020   _ir)/2 :.      
-000185e0: 2020 6973 5f66 696e 6974 6528 5f69 7229    is_finite(_ir)
-000185f0: 2026 2620 6973 5f66 696e 6974 6528 5f72   && is_finite(_r
-00018600: 5f6d 696e 293f 2028 5f69 7220 2b20 5f72  _min)? (_ir + _r
-00018610: 5f6d 696e 2920 3a0a 2020 2020 2020 2020  _min) :.        
-00018620: 6973 5f66 696e 6974 6528 5f6f 7229 2026  is_finite(_or) &
-00018630: 2620 6973 5f66 696e 6974 6528 5f72 5f6d  & is_finite(_r_m
-00018640: 696e 293f 2028 5f6f 7220 2d20 5f72 5f6d  in)? (_or - _r_m
-00018650: 696e 2920 3a0a 2020 2020 2020 2020 6173  in) :.        as
-00018660: 7365 7274 2866 616c 7365 2c20 2242 6164  sert(false, "Bad
-00018670: 2050 6172 616d 6574 6572 7322 293b 0a20   Parameters");. 
-00018680: 2020 206d 696e 5f72 6164 203d 2069 735f     min_rad = is_
-00018690: 6669 6e69 7465 285f 725f 6d69 6e29 3f20  finite(_r_min)? 
-000186a0: 5f72 5f6d 696e 203a 0a20 2020 2020 2020  _r_min :.       
-000186b0: 2069 735f 6669 6e69 7465 285f 6972 293f   is_finite(_ir)?
-000186c0: 2028 6d61 6a5f 7261 6420 2d20 5f69 7229   (maj_rad - _ir)
-000186d0: 203a 0a20 2020 2020 2020 2069 735f 6669   :.        is_fi
-000186e0: 6e69 7465 285f 6f72 293f 2028 5f6f 7220  nite(_or)? (_or 
-000186f0: 2d20 6d61 6a5f 7261 6429 203a 0a20 2020  - maj_rad) :.   
-00018700: 2020 2020 2061 7373 6572 7428 6661 6c73       assert(fals
-00018710: 652c 2022 4261 6420 5061 7261 6d65 7465  e, "Bad Paramete
-00018720: 7273 2229 3b0a 2020 2020 616e 6368 6f72  rs");.    anchor
-00018730: 203d 2067 6574 5f61 6e63 686f 7228 616e   = get_anchor(an
-00018740: 6368 6f72 2c20 6365 6e74 6572 2c20 424f  chor, center, BO
-00018750: 542c 2043 454e 5445 5229 3b0a 2020 2020  T, CENTER);.    
-00018760: 6174 7461 6368 6162 6c65 2861 6e63 686f  attachable(ancho
-00018770: 722c 7370 696e 2c6f 7269 656e 742c 2072  r,spin,orient, r
-00018780: 3d28 6d61 6a5f 7261 642b 6d69 6e5f 7261  =(maj_rad+min_ra
-00018790: 6429 2c20 6c3d 6d69 6e5f 7261 642a 3229  d), l=min_rad*2)
-000187a0: 207b 0a20 2020 2020 2020 2072 6f74 6174   {.        rotat
-000187b0: 655f 6578 7472 7564 6528 636f 6e76 6578  e_extrude(convex
-000187c0: 6974 793d 3429 207b 0a20 2020 2020 2020  ity=4) {.       
-000187d0: 2020 2020 2072 6967 6874 5f68 616c 6628       right_half(
-000187e0: 733d 6d69 6e5f 7261 642a 322c 2070 6c61  s=min_rad*2, pla
-000187f0: 6e61 723d 7472 7565 290a 2020 2020 2020  nar=true).      
-00018800: 2020 2020 2020 2020 2020 7269 6768 7428            right(
-00018810: 6d61 6a5f 7261 6429 0a20 2020 2020 2020  maj_rad).       
-00018820: 2020 2020 2020 2020 2020 2020 2063 6972               cir
-00018830: 636c 6528 723d 6d69 6e5f 7261 6429 3b0a  cle(r=min_rad);.
-00018840: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-00018850: 2020 6368 696c 6472 656e 2829 3b0a 2020    children();.  
-00018860: 2020 7d0a 7d0a 0a0a 6675 6e63 7469 6f6e    }.}...function
-00018870: 2074 6f72 7573 280a 2020 2020 725f 6d61   torus(.    r_ma
-00018880: 6a2c 2072 5f6d 696e 2c20 6365 6e74 6572  j, r_min, center
-00018890: 2c0a 2020 2020 645f 6d61 6a2c 2064 5f6d  ,.    d_maj, d_m
-000188a0: 696e 2c0a 2020 2020 6f72 2c20 6f64 2c20  in,.    or, od, 
-000188b0: 6972 2c20 6964 2c0a 2020 2020 616e 6368  ir, id,.    anch
-000188c0: 6f72 2c20 7370 696e 3d30 2c20 6f72 6965  or, spin=0, orie
-000188d0: 6e74 3d55 500a 2920 3d20 6c65 7428 0a20  nt=UP.) = let(. 
-000188e0: 2020 205f 6f72 203d 2067 6574 5f72 6164     _or = get_rad
-000188f0: 6975 7328 723d 6f72 2c20 643d 6f64 2c20  ius(r=or, d=od, 
-00018900: 6466 6c74 3d75 6e64 6566 292c 0a20 2020  dflt=undef),.   
-00018910: 205f 6972 203d 2067 6574 5f72 6164 6975   _ir = get_radiu
-00018920: 7328 723d 6972 2c20 643d 6964 2c20 6466  s(r=ir, d=id, df
-00018930: 6c74 3d75 6e64 6566 292c 0a20 2020 205f  lt=undef),.    _
-00018940: 725f 6d61 6a20 3d20 6765 745f 7261 6469  r_maj = get_radi
-00018950: 7573 2872 3d72 5f6d 616a 2c20 643d 645f  us(r=r_maj, d=d_
-00018960: 6d61 6a2c 2064 666c 743d 756e 6465 6629  maj, dflt=undef)
-00018970: 2c0a 2020 2020 5f72 5f6d 696e 203d 2067  ,.    _r_min = g
-00018980: 6574 5f72 6164 6975 7328 723d 725f 6d69  et_radius(r=r_mi
-00018990: 6e2c 2064 3d64 5f6d 696e 2c20 6466 6c74  n, d=d_min, dflt
-000189a0: 3d75 6e64 6566 292c 0a20 2020 206d 616a  =undef),.    maj
-000189b0: 5f72 6164 203d 2069 735f 6669 6e69 7465  _rad = is_finite
-000189c0: 285f 725f 6d61 6a29 3f20 5f72 5f6d 616a  (_r_maj)? _r_maj
-000189d0: 203a 0a20 2020 2020 2020 2069 735f 6669   :.        is_fi
-000189e0: 6e69 7465 285f 6972 2920 2626 2069 735f  nite(_ir) && is_
-000189f0: 6669 6e69 7465 285f 6f72 293f 2028 5f6f  finite(_or)? (_o
-00018a00: 7220 2b20 5f69 7229 2f32 203a 0a20 2020  r + _ir)/2 :.   
-00018a10: 2020 2020 2069 735f 6669 6e69 7465 285f       is_finite(_
-00018a20: 6972 2920 2626 2069 735f 6669 6e69 7465  ir) && is_finite
-00018a30: 285f 725f 6d69 6e29 3f20 285f 6972 202b  (_r_min)? (_ir +
-00018a40: 205f 725f 6d69 6e29 203a 0a20 2020 2020   _r_min) :.     
-00018a50: 2020 2069 735f 6669 6e69 7465 285f 6f72     is_finite(_or
-00018a60: 2920 2626 2069 735f 6669 6e69 7465 285f  ) && is_finite(_
-00018a70: 725f 6d69 6e29 3f20 285f 6f72 202d 205f  r_min)? (_or - _
-00018a80: 725f 6d69 6e29 203a 0a20 2020 2020 2020  r_min) :.       
-00018a90: 2061 7373 6572 7428 6661 6c73 652c 2022   assert(false, "
-00018aa0: 4261 6420 5061 7261 6d65 7465 7273 2229  Bad Parameters")
-00018ab0: 2c0a 2020 2020 6d69 6e5f 7261 6420 3d20  ,.    min_rad = 
-00018ac0: 6973 5f66 696e 6974 6528 5f72 5f6d 696e  is_finite(_r_min
-00018ad0: 293f 205f 725f 6d69 6e20 3a0a 2020 2020  )? _r_min :.    
-00018ae0: 2020 2020 6973 5f66 696e 6974 6528 5f69      is_finite(_i
-00018af0: 7229 3f20 286d 616a 5f72 6164 202d 205f  r)? (maj_rad - _
-00018b00: 6972 2920 3a0a 2020 2020 2020 2020 6973  ir) :.        is
-00018b10: 5f66 696e 6974 6528 5f6f 7229 3f20 285f  _finite(_or)? (_
-00018b20: 6f72 202d 206d 616a 5f72 6164 2920 3a0a  or - maj_rad) :.
-00018b30: 2020 2020 2020 2020 6173 7365 7274 2866          assert(f
-00018b40: 616c 7365 2c20 2242 6164 2050 6172 616d  alse, "Bad Param
-00018b50: 6574 6572 7322 292c 0a20 2020 2061 6e63  eters"),.    anc
-00018b60: 686f 7220 3d20 6765 745f 616e 6368 6f72  hor = get_anchor
-00018b70: 2861 6e63 686f 722c 2063 656e 7465 722c  (anchor, center,
-00018b80: 2042 4f54 2c20 4345 4e54 4552 292c 0a20   BOT, CENTER),. 
-00018b90: 2020 206d 616a 5f73 6964 6573 203d 2073     maj_sides = s
-00018ba0: 6567 7328 6d61 6a5f 7261 642b 6d69 6e5f  egs(maj_rad+min_
-00018bb0: 7261 6429 2c0a 2020 2020 6d61 6a5f 7374  rad),.    maj_st
-00018bc0: 6570 203d 2033 3630 202f 206d 616a 5f73  ep = 360 / maj_s
-00018bd0: 6964 6573 2c0a 2020 2020 6d69 6e5f 7369  ides,.    min_si
-00018be0: 6465 7320 3d20 7365 6773 286d 696e 5f72  des = segs(min_r
-00018bf0: 6164 292c 0a20 2020 206d 696e 5f73 7465  ad),.    min_ste
-00018c00: 7020 3d20 3336 3020 2f20 6d69 6e5f 7369  p = 360 / min_si
-00018c10: 6465 732c 0a20 2020 2078 7970 726f 6669  des,.    xyprofi
-00018c20: 6c65 203d 206d 696e 5f72 6164 203c 3d20  le = min_rad <= 
-00018c30: 6d61 6a5f 7261 643f 2072 6967 6874 286d  maj_rad? right(m
-00018c40: 616a 5f72 6164 2c20 703d 6369 7263 6c65  aj_rad, p=circle
-00018c50: 2872 3d6d 696e 5f72 6164 2929 203a 0a20  (r=min_rad)) :. 
-00018c60: 2020 2020 2020 2072 6967 6874 5f68 616c         right_hal
-00018c70: 6628 703d 7269 6768 7428 6d61 6a5f 7261  f(p=right(maj_ra
-00018c80: 642c 2070 3d63 6972 636c 6528 723d 6d69  d, p=circle(r=mi
-00018c90: 6e5f 7261 6429 2929 5b30 5d2c 0a20 2020  n_rad)))[0],.   
-00018ca0: 2070 726f 6669 6c65 203d 2078 726f 7428   profile = xrot(
-00018cb0: 3930 2c20 703d 7061 7468 3364 2878 7970  90, p=path3d(xyp
-00018cc0: 726f 6669 6c65 2929 2c0a 2020 2020 766e  rofile)),.    vn
-00018cd0: 6620 3d20 766e 665f 7665 7274 6578 5f61  f = vnf_vertex_a
-00018ce0: 7272 6179 280a 2020 2020 2020 2020 706f  rray(.        po
-00018cf0: 696e 7473 3d5b 666f 7220 2861 3d5b 303a  ints=[for (a=[0:
-00018d00: 6d61 6a5f 7374 6570 3a33 3630 2d45 5053  maj_step:360-EPS
-00018d10: 494c 4f4e 5d29 207a 726f 7428 612c 2070  ILON]) zrot(a, p
-00018d20: 3d70 726f 6669 6c65 295d 2c0a 2020 2020  =profile)],.    
-00018d30: 2020 2020 6361 7073 3d66 616c 7365 2c20      caps=false, 
-00018d40: 636f 6c5f 7772 6170 3d74 7275 652c 2072  col_wrap=true, r
-00018d50: 6f77 5f77 7261 703d 7472 7565 2c20 7265  ow_wrap=true, re
-00018d60: 7665 7273 653d 7472 7565 0a20 2020 2029  verse=true.    )
-00018d70: 0a29 2072 656f 7269 656e 7428 616e 6368  .) reorient(anch
-00018d80: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
-00018d90: 723d 286d 616a 5f72 6164 2b6d 696e 5f72  r=(maj_rad+min_r
-00018da0: 6164 292c 206c 3d6d 696e 5f72 6164 2a32  ad), l=min_rad*2
-00018db0: 2c20 703d 766e 6629 3b0a 0a0a 2f2f 2046  , p=vnf);...// F
-00018dc0: 756e 6374 696f 6e26 4d6f 6475 6c65 3a20  unction&Module: 
-00018dd0: 7465 6172 6472 6f70 2829 0a2f 2f0a 2f2f  teardrop().//.//
-00018de0: 2044 6573 6372 6970 7469 6f6e 3a0a 2f2f   Description:.//
-00018df0: 2020 204d 616b 6573 2061 2074 6561 7264     Makes a teard
-00018e00: 726f 7020 7368 6170 6520 696e 2074 6865  rop shape in the
-00018e10: 2058 5a20 706c 616e 652e 2055 7365 6675   XZ plane. Usefu
-00018e20: 6c20 666f 7220 3344 2070 7269 6e74 6162  l for 3D printab
-00018e30: 6c65 2068 6f6c 6573 2e0a 2f2f 0a2f 2f20  le holes..//.// 
-00018e40: 5573 6167 653a 2054 7970 6963 616c 0a2f  Usage: Typical./
-00018e50: 2f20 2020 7465 6172 6472 6f70 2868 7c6c  /   teardrop(h|l
-00018e60: 2c20 722c 205b 616e 675d 2c20 5b63 6170  , r, [ang], [cap
-00018e70: 5f68 5d2c 202e 2e2e 2920 5b41 5454 4143  _h], ...) [ATTAC
-00018e80: 484d 454e 5453 5d3b 0a2f 2f20 2020 7465  HMENTS];.//   te
-00018e90: 6172 6472 6f70 2868 7c6c 2c20 643d 2c20  ardrop(h|l, d=, 
-00018ea0: 5b61 6e67 3d5d 2c20 5b63 6170 5f68 3d5d  [ang=], [cap_h=]
-00018eb0: 2c20 2e2e 2e29 205b 4154 5441 4348 4d45  , ...) [ATTACHME
-00018ec0: 4e54 535d 3b0a 2f2f 2055 7361 6765 3a20  NTS];.// Usage: 
-00018ed0: 5073 7565 646f 2d43 6f6e 6963 616c 0a2f  Psuedo-Conical./
-00018ee0: 2f20 2020 7465 6172 6472 6f70 2868 7c6c  /   teardrop(h|l
-00018ef0: 2c20 7231 3d2c 2072 323d 2c20 5b61 6e67  , r1=, r2=, [ang
-00018f00: 3d5d 2c20 5b63 6170 5f68 313d 5d2c 205b  =], [cap_h1=], [
-00018f10: 6361 705f 6832 3d5d 2c20 2e2e 2e29 2020  cap_h2=], ...)  
-00018f20: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
-00018f30: 2f20 2020 7465 6172 6472 6f70 2868 7c6c  /   teardrop(h|l
-00018f40: 2c20 6431 3d2c 2064 323d 2c20 5b61 6e67  , d1=, d2=, [ang
-00018f50: 3d5d 2c20 5b63 6170 5f68 313d 5d2c 205b  =], [cap_h1=], [
-00018f60: 6361 705f 6832 3d5d 2c20 2e2e 2e29 2020  cap_h2=], ...)  
-00018f70: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
-00018f80: 2f20 5573 6167 653a 2041 7320 4675 6e63  / Usage: As Func
-00018f90: 7469 6f6e 0a2f 2f20 2020 766e 6620 3d20  tion.//   vnf = 
-00018fa0: 7465 6172 6472 6f70 2868 7c6c 3d2c 2072  teardrop(h|l=, r
-00018fb0: 7c64 3d2c 205b 616e 673d 5d2c 205b 6361  |d=, [ang=], [ca
-00018fc0: 705f 683d 5d2c 202e 2e2e 293b 0a2f 2f20  p_h=], ...);.// 
-00018fd0: 2020 766e 6620 3d20 7465 6172 6472 6f70    vnf = teardrop
-00018fe0: 2868 7c6c 3d2c 2072 313d 7c64 313d 2c20  (h|l=, r1=|d1=, 
-00018ff0: 7232 3d7c 6432 3d2c 205b 616e 673d 5d2c  r2=|d2=, [ang=],
-00019000: 205b 6361 705f 683d 5d2c 202e 2e2e 293b   [cap_h=], ...);
-00019010: 0a2f 2f20 2020 766e 6620 3d20 7465 6172  .//   vnf = tear
-00019020: 6472 6f70 2868 7c6c 3d2c 2072 313d 7c64  drop(h|l=, r1=|d
-00019030: 313d 2c20 7232 3d7c 6432 3d2c 205b 616e  1=, r2=|d2=, [an
-00019040: 673d 5d2c 205b 6361 705f 6831 3d5d 2c20  g=], [cap_h1=], 
-00019050: 5b63 6170 5f68 323d 5d2c 202e 2e2e 293b  [cap_h2=], ...);
-00019060: 0a2f 2f0a 2f2f 2041 7267 756d 656e 7473  .//.// Arguments
-00019070: 3a0a 2f2f 2020 2068 202f 206c 203d 2054  :.//   h / l = T
-00019080: 6869 636b 6e65 7373 206f 6620 7465 6172  hickness of tear
-00019090: 6472 6f70 2e20 4465 6661 756c 743a 2031  drop. Default: 1
-000190a0: 0a2f 2f20 2020 7220 3d20 5261 6469 7573  .//   r = Radius
-000190b0: 206f 6620 6369 7263 756c 6172 2070 6172   of circular par
-000190c0: 7420 6f66 2074 6561 7264 726f 702e 2020  t of teardrop.  
-000190d0: 4465 6661 756c 743a 2031 0a2f 2f20 2020  Default: 1.//   
-000190e0: 616e 6720 3d20 416e 676c 6520 6f66 2068  ang = Angle of h
-000190f0: 6174 2077 616c 6c73 2066 726f 6d20 7468  at walls from th
-00019100: 6520 5a20 6178 6973 2e20 2044 6566 6175  e Z axis.  Defau
-00019110: 6c74 3a20 3435 2064 6567 7265 6573 0a2f  lt: 45 degrees./
-00019120: 2f20 2020 6361 705f 6820 3d20 4966 2067  /   cap_h = If g
-00019130: 6976 656e 2c20 6865 6967 6874 2061 626f  iven, height abo
-00019140: 7665 2063 656e 7465 7220 7768 6572 6520  ve center where 
-00019150: 7468 6520 7368 6170 6520 7769 6c6c 2062  the shape will b
-00019160: 6520 7472 756e 6361 7465 642e 2044 6566  e truncated. Def
-00019170: 6175 6c74 3a20 6075 6e64 6566 6020 286e  ault: `undef` (n
-00019180: 6f20 7472 756e 6361 7469 6f6e 290a 2f2f  o truncation).//
-00019190: 2020 202d 2d2d 0a2f 2f20 2020 7231 203d     ---.//   r1 =
-000191a0: 2052 6164 6975 7320 6f66 2063 6972 6375   Radius of circu
-000191b0: 6c61 7220 706f 7274 696f 6e20 6f66 2074  lar portion of t
-000191c0: 6865 2066 726f 6e74 2065 6e64 206f 6620  he front end of 
-000191d0: 7468 6520 7465 6172 6472 6f70 2073 6861  the teardrop sha
-000191e0: 7065 2e0a 2f2f 2020 2072 3220 3d20 5261  pe..//   r2 = Ra
-000191f0: 6469 7573 206f 6620 6369 7263 756c 6172  dius of circular
-00019200: 2070 6f72 7469 6f6e 206f 6620 7468 6520   portion of the 
-00019210: 6261 636b 2065 6e64 206f 6620 7468 6520  back end of the 
-00019220: 7465 6172 6472 6f70 2073 6861 7065 2e0a  teardrop shape..
-00019230: 2f2f 2020 2064 203d 2044 6961 6d65 7465  //   d = Diamete
-00019240: 7220 6f66 2063 6972 6375 6c61 7220 706f  r of circular po
-00019250: 7274 696f 6e20 6f66 2074 6865 2074 6561  rtion of the tea
-00019260: 7264 726f 7020 7368 6170 652e 0a2f 2f20  rdrop shape..// 
-00019270: 2020 6431 203d 2044 6961 6d65 7465 7220    d1 = Diameter 
-00019280: 6f66 2063 6972 6375 6c61 7220 706f 7274  of circular port
-00019290: 696f 6e20 6f66 2074 6865 2066 726f 6e74  ion of the front
-000192a0: 2065 6e64 206f 6620 7468 6520 7465 6172   end of the tear
-000192b0: 6472 6f70 2073 6861 7065 2e0a 2f2f 2020  drop shape..//  
-000192c0: 2064 3220 3d20 4469 616d 6574 6572 206f   d2 = Diameter o
-000192d0: 6620 6369 7263 756c 6172 2070 6f72 7469  f circular porti
-000192e0: 6f6e 206f 6620 7468 6520 6261 636b 2065  on of the back e
-000192f0: 6e64 206f 6620 7468 6520 7465 6172 6472  nd of the teardr
-00019300: 6f70 2073 6861 7065 2e0a 2f2f 2020 2063  op shape..//   c
-00019310: 6170 5f68 3120 3d20 4966 2067 6976 656e  ap_h1 = If given
-00019320: 2c20 6865 6967 6874 2061 626f 7665 2063  , height above c
-00019330: 656e 7465 7220 7768 6572 6520 7468 6520  enter where the 
-00019340: 7368 6170 6520 7769 6c6c 2062 6520 7472  shape will be tr
-00019350: 756e 6361 7465 642c 206f 6e20 7468 6520  uncated, on the 
-00019360: 6672 6f6e 7420 7369 6465 2e20 4465 6661  front side. Defa
-00019370: 756c 743a 2060 756e 6465 6660 2028 6e6f  ult: `undef` (no
-00019380: 2074 7275 6e63 6174 696f 6e29 0a2f 2f20   truncation).// 
-00019390: 2020 6361 705f 6832 203d 2049 6620 6769    cap_h2 = If gi
-000193a0: 7665 6e2c 2068 6569 6768 7420 6162 6f76  ven, height abov
-000193b0: 6520 6365 6e74 6572 2077 6865 7265 2074  e center where t
-000193c0: 6865 2073 6861 7065 2077 696c 6c20 6265  he shape will be
-000193d0: 2074 7275 6e63 6174 6564 2c20 6f6e 2074   truncated, on t
-000193e0: 6865 2062 6163 6b20 7369 6465 2e20 4465  he back side. De
-000193f0: 6661 756c 743a 2060 756e 6465 6660 2028  fault: `undef` (
-00019400: 6e6f 2074 7275 6e63 6174 696f 6e29 0a2f  no truncation)./
-00019410: 2f20 2020 616e 6368 6f72 203d 2054 7261  /   anchor = Tra
-00019420: 6e73 6c61 7465 2073 6f20 616e 6368 6f72  nslate so anchor
-00019430: 2070 6f69 6e74 2069 7320 6174 206f 7269   point is at ori
-00019440: 6769 6e20 2830 2c30 2c30 292e 2020 5365  gin (0,0,0).  Se
-00019450: 6520 5b61 6e63 686f 725d 2861 7474 6163  e [anchor](attac
-00019460: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
-00019470: 6563 7469 6f6e 2d61 6e63 686f 7229 2e20  ection-anchor). 
-00019480: 2044 6566 6175 6c74 3a20 6043 454e 5445   Default: `CENTE
-00019490: 5260 0a2f 2f20 2020 7370 696e 203d 2052  R`.//   spin = R
-000194a0: 6f74 6174 6520 7468 6973 206d 616e 7920  otate this many 
-000194b0: 6465 6772 6565 7320 6172 6f75 6e64 2074  degrees around t
-000194c0: 6865 205a 2061 7869 7320 6166 7465 7220  he Z axis after 
-000194d0: 616e 6368 6f72 2e20 2053 6565 205b 7370  anchor.  See [sp
-000194e0: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
-000194f0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-00019500: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
-00019510: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
-00019520: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
-00019530: 6174 6520 746f 7020 746f 7761 7264 732c  ate top towards,
-00019540: 2061 6674 6572 2073 7069 6e2e 2020 5365   after spin.  Se
-00019550: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
-00019560: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
-00019570: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
-00019580: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
-00019590: 2f0a 2f2f 2045 7874 7261 2041 6e63 686f  /.// Extra Ancho
-000195a0: 7273 3a0a 2f2f 2020 2063 6170 203d 2054  rs:.//   cap = T
-000195b0: 6865 2063 656e 7465 7220 6f66 2074 6865  he center of the
-000195c0: 2074 6f70 206f 6620 7468 6520 6361 702c   top of the cap,
-000195d0: 206f 7269 656e 7465 6420 7769 7468 2074   oriented with t
-000195e0: 6865 2063 6170 2066 6163 6520 6e6f 726d  he cap face norm
-000195f0: 616c 2e0a 2f2f 2020 2063 6170 5f66 7764  al..//   cap_fwd
-00019600: 203d 2054 6865 2066 726f 6e74 2065 6467   = The front edg
-00019610: 6520 6f66 2074 6865 2063 6170 2e0a 2f2f  e of the cap..//
-00019620: 2020 2063 6170 5f62 6163 6b20 3d20 5468     cap_back = Th
-00019630: 6520 6261 636b 2065 6467 6520 6f66 2074  e back edge of t
-00019640: 6865 2063 6170 2e0a 2f2f 0a2f 2f20 4578  he cap..//.// Ex
-00019650: 616d 706c 653a 2054 7970 6963 616c 2053  ample: Typical S
-00019660: 6861 7065 0a2f 2f20 2020 7465 6172 6472  hape.//   teardr
-00019670: 6f70 2872 3d33 302c 2068 3d31 302c 2061  op(r=30, h=10, a
-00019680: 6e67 3d33 3029 3b0a 2f2f 2045 7861 6d70  ng=30);.// Examp
-00019690: 6c65 3a20 4372 6f70 2043 6170 0a2f 2f20  le: Crop Cap.// 
-000196a0: 2020 7465 6172 6472 6f70 2872 3d33 302c    teardrop(r=30,
-000196b0: 2068 3d31 302c 2061 6e67 3d33 302c 2063   h=10, ang=30, c
-000196c0: 6170 5f68 3d34 3029 3b0a 2f2f 2045 7861  ap_h=40);.// Exa
-000196d0: 6d70 6c65 3a20 436c 6f73 6520 4372 6f70  mple: Close Crop
-000196e0: 0a2f 2f20 2020 7465 6172 6472 6f70 2872  .//   teardrop(r
-000196f0: 3d33 302c 2068 3d31 302c 2061 6e67 3d33  =30, h=10, ang=3
-00019700: 302c 2063 6170 5f68 3d32 3029 3b0a 2f2f  0, cap_h=20);.//
-00019710: 2045 7861 6d70 6c65 3a20 5073 7565 646f   Example: Psuedo
-00019720: 2d43 6f6e 6963 616c 0a2f 2f20 2020 7465  -Conical.//   te
-00019730: 6172 6472 6f70 2872 313d 3230 2c20 7232  ardrop(r1=20, r2
-00019740: 3d33 302c 2068 3d34 302c 2063 6170 5f68  =30, h=40, cap_h
-00019750: 313d 3235 2c20 6361 705f 6832 3d33 3529  1=25, cap_h2=35)
-00019760: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 4765  ;.// Example: Ge
-00019770: 7474 696e 6720 6120 564e 460a 2f2f 2020  tting a VNF.//  
-00019780: 2076 6e66 203d 2074 6561 7264 726f 7028   vnf = teardrop(
-00019790: 7231 3d32 352c 2072 323d 3330 2c20 6c3d  r1=25, r2=30, l=
-000197a0: 3230 2c20 6361 705f 6831 3d32 352c 2063  20, cap_h1=25, c
-000197b0: 6170 5f68 323d 3335 293b 0a2f 2f20 2020  ap_h2=35);.//   
-000197c0: 766e 665f 706f 6c79 6865 6472 6f6e 2876  vnf_polyhedron(v
-000197d0: 6e66 293b 0a2f 2f20 4578 616d 706c 653a  nf);.// Example:
-000197e0: 2053 7461 6e64 6172 6420 436f 6e69 6361   Standard Conica
-000197f0: 6c20 436f 6e6e 6563 746f 7273 0a2f 2f20  l Connectors.// 
-00019800: 2020 7465 6172 6472 6f70 2864 313d 3230    teardrop(d1=20
-00019810: 2c20 6432 3d33 302c 2068 3d32 302c 2063  , d2=30, h=20, c
-00019820: 6170 5f68 313d 3131 2c20 6361 705f 6832  ap_h1=11, cap_h2
-00019830: 3d31 3629 0a2f 2f20 2020 2020 2020 7368  =16).//       sh
-00019840: 6f77 5f61 6e63 686f 7273 2863 7573 746f  ow_anchors(custo
-00019850: 6d3d 6661 6c73 6529 3b0a 2f2f 2045 7861  m=false);.// Exa
-00019860: 6d70 6c65 2853 7069 6e2c 5650 443d 3135  mple(Spin,VPD=15
-00019870: 302c 4d65 6429 3a20 4e61 6d65 6420 436f  0,Med): Named Co
-00019880: 6e69 6361 6c20 436f 6e6e 6563 746f 7273  nical Connectors
-00019890: 0a2f 2f20 2020 7465 6172 6472 6f70 2864  .//   teardrop(d
-000198a0: 313d 3230 2c20 6432 3d33 302c 2068 3d32  1=20, d2=30, h=2
-000198b0: 302c 2063 6170 5f68 313d 3131 2c20 6361  0, cap_h1=11, ca
-000198c0: 705f 6832 3d31 3629 0a2f 2f20 2020 2020  p_h2=16).//     
-000198d0: 2020 7368 6f77 5f61 6e63 686f 7273 2873    show_anchors(s
-000198e0: 7464 3d66 616c 7365 293b 0a6d 6f64 756c  td=false);.modul
-000198f0: 6520 7465 6172 6472 6f70 2868 2c20 722c  e teardrop(h, r,
-00019900: 2061 6e67 3d34 352c 2063 6170 5f68 2c20   ang=45, cap_h, 
-00019910: 7231 2c20 7232 2c20 642c 2064 312c 2064  r1, r2, d, d1, d
-00019920: 322c 2063 6170 5f68 312c 2063 6170 5f68  2, cap_h1, cap_h
-00019930: 322c 206c 2c20 616e 6368 6f72 3d43 454e  2, l, anchor=CEN
-00019940: 5445 522c 2073 7069 6e3d 302c 206f 7269  TER, spin=0, ori
-00019950: 656e 743d 5550 290a 7b0a 2020 2020 7231  ent=UP).{.    r1
-00019960: 203d 2067 6574 5f72 6164 6975 7328 723d   = get_radius(r=
-00019970: 722c 2072 313d 7231 2c20 643d 642c 2064  r, r1=r1, d=d, d
-00019980: 313d 6431 2c20 6466 6c74 3d31 293b 0a20  1=d1, dflt=1);. 
-00019990: 2020 2072 3220 3d20 6765 745f 7261 6469     r2 = get_radi
-000199a0: 7573 2872 3d72 2c20 7231 3d72 322c 2064  us(r=r, r1=r2, d
-000199b0: 3d64 2c20 6431 3d64 322c 2064 666c 743d  =d, d1=d2, dflt=
-000199c0: 3129 3b0a 2020 2020 6c20 3d20 6669 7273  1);.    l = firs
-000199d0: 745f 6465 6669 6e65 6428 5b6c 2c20 682c  t_defined([l, h,
-000199e0: 2031 5d29 3b0a 2020 2020 6361 705f 6831   1]);.    cap_h1
-000199f0: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
-00019a00: 285b 6361 705f 6831 2c20 6361 705f 685d  ([cap_h1, cap_h]
-00019a10: 293b 0a20 2020 2063 6170 5f68 3220 3d20  );.    cap_h2 = 
-00019a20: 6669 7273 745f 6465 6669 6e65 6428 5b63  first_defined([c
-00019a30: 6170 5f68 322c 2063 6170 5f68 5d29 3b0a  ap_h2, cap_h]);.
-00019a40: 2020 2020 7369 6465 7320 3d20 7365 6773      sides = segs
-00019a50: 286d 6178 2872 312c 7232 2929 3b0a 2020  (max(r1,r2));.  
-00019a60: 2020 7072 6f66 696c 6531 203d 2074 6561    profile1 = tea
-00019a70: 7264 726f 7032 6428 723d 7231 2c20 616e  rdrop2d(r=r1, an
-00019a80: 673d 616e 672c 2063 6170 5f68 3d63 6170  g=ang, cap_h=cap
-00019a90: 5f68 312c 2024 666e 3d73 6964 6573 293b  _h1, $fn=sides);
-00019aa0: 0a20 2020 2070 726f 6669 6c65 3220 3d20  .    profile2 = 
-00019ab0: 7465 6172 6472 6f70 3264 2872 3d72 322c  teardrop2d(r=r2,
-00019ac0: 2061 6e67 3d61 6e67 2c20 6361 705f 683d   ang=ang, cap_h=
-00019ad0: 6361 705f 6832 2c20 2466 6e3d 7369 6465  cap_h2, $fn=side
-00019ae0: 7329 3b0a 2020 2020 7469 705f 7931 203d  s);.    tip_y1 =
-00019af0: 206d 6178 2863 6f6c 756d 6e28 7072 6f66   max(column(prof
-00019b00: 696c 6531 2c31 2929 3b0a 2020 2020 7469  ile1,1));.    ti
-00019b10: 705f 7932 203d 206d 6178 2863 6f6c 756d  p_y2 = max(colum
-00019b20: 6e28 7072 6f66 696c 6532 2c31 2929 3b0a  n(profile2,1));.
-00019b30: 2020 2020 5f63 6170 5f68 3120 3d20 6d69      _cap_h1 = mi
-00019b40: 6e28 6465 6661 756c 7428 6361 705f 6831  n(default(cap_h1
-00019b50: 2c20 7469 705f 7931 292c 2074 6970 5f79  , tip_y1), tip_y
-00019b60: 3129 3b0a 2020 2020 5f63 6170 5f68 3220  1);.    _cap_h2 
-00019b70: 3d20 6d69 6e28 6465 6661 756c 7428 6361  = min(default(ca
-00019b80: 705f 6832 2c20 7469 705f 7932 292c 2074  p_h2, tip_y2), t
-00019b90: 6970 5f79 3229 3b0a 2020 2020 6361 7076  ip_y2);.    capv
-00019ba0: 6563 203d 2075 6e69 7428 5b30 2c20 5f63  ec = unit([0, _c
-00019bb0: 6170 5f68 312d 5f63 6170 5f68 322c 206c  ap_h1-_cap_h2, l
-00019bc0: 5d29 3b0a 2020 2020 616e 6368 6f72 7320  ]);.    anchors 
-00019bd0: 3d20 5b0a 2020 2020 2020 2020 6e61 6d65  = [.        name
-00019be0: 645f 616e 6368 6f72 2822 6361 7022 2c20  d_anchor("cap", 
-00019bf0: 2020 2020 205b 302c 302c 285f 6361 705f       [0,0,(_cap_
-00019c00: 6831 2b5f 6361 705f 6832 292f 325d 2c20  h1+_cap_h2)/2], 
-00019c10: 6361 7076 6563 292c 0a20 2020 2020 2020  capvec),.       
-00019c20: 206e 616d 6564 5f61 6e63 686f 7228 2263   named_anchor("c
-00019c30: 6170 5f66 7764 222c 2020 5b30 2c2d 6c2f  ap_fwd",  [0,-l/
-00019c40: 322c 5f63 6170 5f68 315d 2c20 2020 2020  2,_cap_h1],     
-00019c50: 2020 2020 756e 6974 2828 6361 7076 6563      unit((capvec
-00019c60: 2b46 5744 292f 3229 292c 0a20 2020 2020  +FWD)/2)),.     
-00019c70: 2020 206e 616d 6564 5f61 6e63 686f 7228     named_anchor(
-00019c80: 2263 6170 5f62 6163 6b22 2c20 5b30 2c2b  "cap_back", [0,+
-00019c90: 6c2f 322c 5f63 6170 5f68 325d 2c20 2020  l/2,_cap_h2],   
-00019ca0: 2020 2020 2020 756e 6974 2828 6361 7076        unit((capv
-00019cb0: 6563 2b42 4143 4b29 2f32 292c 2031 3830  ec+BACK)/2), 180
-00019cc0: 292c 0a20 2020 205d 3b0a 2020 2020 6174  ),.    ];.    at
-00019cd0: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
-00019ce0: 7370 696e 2c6f 7269 656e 742c 2072 313d  spin,orient, r1=
-00019cf0: 7231 2c20 7232 3d72 322c 206c 3d6c 2c20  r1, r2=r2, l=l, 
-00019d00: 6178 6973 3d42 4143 4b2c 2061 6e63 686f  axis=BACK, ancho
-00019d10: 7273 3d61 6e63 686f 7273 2920 7b0a 2020  rs=anchors) {.  
-00019d20: 2020 2020 2020 726f 7428 6672 6f6d 3d55        rot(from=U
-00019d30: 502c 746f 3d46 5744 2920 7b0a 2020 2020  P,to=FWD) {.    
-00019d40: 2020 2020 2020 2020 6966 2028 6c20 3e20          if (l > 
-00019d50: 3029 207b 0a20 2020 2020 2020 2020 2020  0) {.           
-00019d60: 2020 2020 2069 6620 2872 3120 3d3d 2072       if (r1 == r
-00019d70: 3229 207b 0a20 2020 2020 2020 2020 2020  2) {.           
-00019d80: 2020 2020 2020 2020 206c 696e 6561 725f           linear_
-00019d90: 6578 7472 7564 6528 6865 6967 6874 3d6c  extrude(height=l
-00019da0: 2c20 6365 6e74 6572 3d74 7275 652c 2073  , center=true, s
-00019db0: 6c69 6365 733d 3229 207b 0a20 2020 2020  lices=2) {.     
-00019dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019dd0: 2020 2070 6f6c 7967 6f6e 2870 726f 6669     polygon(profi
-00019de0: 6c65 3129 3b0a 2020 2020 2020 2020 2020  le1);.          
-00019df0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00019e00: 2020 2020 2020 2020 2020 2020 7d20 656c              } el
-00019e10: 7365 207b 0a20 2020 2020 2020 2020 2020  se {.           
-00019e20: 2020 2020 2020 2020 2068 756c 6c28 2920           hull() 
-00019e30: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00019e40: 2020 2020 2020 2020 2020 7570 286c 2f32            up(l/2
-00019e50: 2d30 2e30 3031 2920 7b0a 2020 2020 2020  -0.001) {.      
-00019e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019e70: 2020 2020 2020 6c69 6e65 6172 5f65 7874        linear_ext
-00019e80: 7275 6465 2868 6569 6768 743d 302e 3030  rude(height=0.00
-00019e90: 312c 2063 656e 7465 723d 6661 6c73 6529  1, center=false)
-00019ea0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-00019eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019ec0: 2020 2070 6f6c 7967 6f6e 2870 726f 6669     polygon(profi
-00019ed0: 6c65 3129 3b0a 2020 2020 2020 2020 2020  le1);.          
-00019ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019ef0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
-00019f00: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-00019f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019f20: 2020 2020 2020 646f 776e 286c 2f32 2920        down(l/2) 
-00019f30: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-00019f40: 2020 2020 2020 2020 2020 2020 2020 6c69                li
-00019f50: 6e65 6172 5f65 7874 7275 6465 2868 6569  near_extrude(hei
-00019f60: 6768 743d 302e 3030 312c 2063 656e 7465  ght=0.001, cente
-00019f70: 723d 6661 6c73 6529 207b 0a20 2020 2020  r=false) {.     
-00019f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019f90: 2020 2020 2020 2020 2020 2070 6f6c 7967             polyg
-00019fa0: 6f6e 2870 726f 6669 6c65 3229 3b0a 2020  on(profile2);.  
-00019fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019fc0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00019fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019fe0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-00019ff0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0001a000: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
-0001a010: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0001a020: 2020 2020 7d0a 2020 2020 2020 2020 6368      }.        ch
-0001a030: 696c 6472 656e 2829 3b0a 2020 2020 7d0a  ildren();.    }.
-0001a040: 7d0a 0a0a 6675 6e63 7469 6f6e 2074 6561  }...function tea
-0001a050: 7264 726f 7028 682c 2072 2c20 616e 673d  rdrop(h, r, ang=
-0001a060: 3435 2c20 6361 705f 682c 2072 312c 2072  45, cap_h, r1, r
-0001a070: 322c 2064 2c20 6431 2c20 6432 2c20 6361  2, d, d1, d2, ca
-0001a080: 705f 6831 2c20 6361 705f 6832 2c20 6c2c  p_h1, cap_h2, l,
-0001a090: 2061 6e63 686f 723d 4345 4e54 4552 2c20   anchor=CENTER, 
-0001a0a0: 7370 696e 3d30 2c20 6f72 6965 6e74 3d55  spin=0, orient=U
-0001a0b0: 5029 203d 0a20 2020 206c 6574 280a 2020  P) =.    let(.  
-0001a0c0: 2020 2020 2020 7231 203d 2067 6574 5f72        r1 = get_r
-0001a0d0: 6164 6975 7328 723d 722c 2072 313d 7231  adius(r=r, r1=r1
-0001a0e0: 2c20 643d 642c 2064 313d 6431 2c20 6466  , d=d, d1=d1, df
-0001a0f0: 6c74 3d31 292c 0a20 2020 2020 2020 2072  lt=1),.        r
-0001a100: 3220 3d20 6765 745f 7261 6469 7573 2872  2 = get_radius(r
-0001a110: 3d72 2c20 7231 3d72 322c 2064 3d64 2c20  =r, r1=r2, d=d, 
-0001a120: 6431 3d64 322c 2064 666c 743d 3129 2c0a  d1=d2, dflt=1),.
-0001a130: 2020 2020 2020 2020 6c20 3d20 6669 7273          l = firs
-0001a140: 745f 6465 6669 6e65 6428 5b6c 2c20 682c  t_defined([l, h,
-0001a150: 2031 5d29 2c0a 2020 2020 2020 2020 6361   1]),.        ca
-0001a160: 705f 6831 203d 2066 6972 7374 5f64 6566  p_h1 = first_def
-0001a170: 696e 6564 285b 6361 705f 6831 2c20 6361  ined([cap_h1, ca
-0001a180: 705f 685d 292c 0a20 2020 2020 2020 2063  p_h]),.        c
-0001a190: 6170 5f68 3220 3d20 6669 7273 745f 6465  ap_h2 = first_de
-0001a1a0: 6669 6e65 6428 5b63 6170 5f68 322c 2063  fined([cap_h2, c
-0001a1b0: 6170 5f68 5d29 2c0a 2020 2020 2020 2020  ap_h]),.        
-0001a1c0: 7369 6465 7320 3d20 7365 6773 286d 6178  sides = segs(max
-0001a1d0: 2872 312c 7232 2929 2c0a 2020 2020 2020  (r1,r2)),.      
-0001a1e0: 2020 7072 6f66 696c 6531 203d 2074 6561    profile1 = tea
-0001a1f0: 7264 726f 7032 6428 723d 7231 2c20 616e  rdrop2d(r=r1, an
-0001a200: 673d 616e 672c 2063 6170 5f68 3d63 6170  g=ang, cap_h=cap
-0001a210: 5f68 312c 2024 666e 3d73 6964 6573 292c  _h1, $fn=sides),
-0001a220: 0a20 2020 2020 2020 2070 726f 6669 6c65  .        profile
-0001a230: 3220 3d20 7465 6172 6472 6f70 3264 2872  2 = teardrop2d(r
-0001a240: 3d72 322c 2061 6e67 3d61 6e67 2c20 6361  =r2, ang=ang, ca
-0001a250: 705f 683d 6361 705f 6832 2c20 2466 6e3d  p_h=cap_h2, $fn=
-0001a260: 7369 6465 7329 2c0a 2020 2020 2020 2020  sides),.        
-0001a270: 7469 705f 7931 203d 206d 6178 2863 6f6c  tip_y1 = max(col
-0001a280: 756d 6e28 7072 6f66 696c 6531 2c31 2929  umn(profile1,1))
-0001a290: 2c0a 2020 2020 2020 2020 7469 705f 7932  ,.        tip_y2
-0001a2a0: 203d 206d 6178 2863 6f6c 756d 6e28 7072   = max(column(pr
-0001a2b0: 6f66 696c 6532 2c31 2929 2c0a 2020 2020  ofile2,1)),.    
-0001a2c0: 2020 2020 5f63 6170 5f68 3120 3d20 6d69      _cap_h1 = mi
-0001a2d0: 6e28 6465 6661 756c 7428 6361 705f 6831  n(default(cap_h1
-0001a2e0: 2c20 7469 705f 7931 292c 2074 6970 5f79  , tip_y1), tip_y
-0001a2f0: 3129 2c0a 2020 2020 2020 2020 5f63 6170  1),.        _cap
-0001a300: 5f68 3220 3d20 6d69 6e28 6465 6661 756c  _h2 = min(defaul
-0001a310: 7428 6361 705f 6832 2c20 7469 705f 7932  t(cap_h2, tip_y2
-0001a320: 292c 2074 6970 5f79 3229 2c0a 2020 2020  ), tip_y2),.    
-0001a330: 2020 2020 6361 7076 6563 203d 2075 6e69      capvec = uni
-0001a340: 7428 5b30 2c20 5f63 6170 5f68 312d 5f63  t([0, _cap_h1-_c
-0001a350: 6170 5f68 322c 206c 5d29 2c0a 2020 2020  ap_h2, l]),.    
-0001a360: 2020 2020 616e 6368 6f72 7320 3d20 5b0a      anchors = [.
-0001a370: 2020 2020 2020 2020 2020 2020 6e61 6d65              name
-0001a380: 645f 616e 6368 6f72 2822 6361 7022 2c20  d_anchor("cap", 
-0001a390: 2020 2020 205b 302c 302c 285f 6361 705f       [0,0,(_cap_
-0001a3a0: 6831 2b5f 6361 705f 6832 292f 325d 2c20  h1+_cap_h2)/2], 
-0001a3b0: 6361 7076 6563 292c 0a20 2020 2020 2020  capvec),.       
-0001a3c0: 2020 2020 206e 616d 6564 5f61 6e63 686f       named_ancho
-0001a3d0: 7228 2263 6170 5f66 7764 222c 2020 5b30  r("cap_fwd",  [0
-0001a3e0: 2c2d 6c2f 322c 5f63 6170 5f68 315d 2c20  ,-l/2,_cap_h1], 
-0001a3f0: 2020 2020 2020 2020 756e 6974 2828 6361          unit((ca
-0001a400: 7076 6563 2b46 5744 292f 3229 292c 0a20  pvec+FWD)/2)),. 
-0001a410: 2020 2020 2020 2020 2020 206e 616d 6564             named
-0001a420: 5f61 6e63 686f 7228 2263 6170 5f62 6163  _anchor("cap_bac
-0001a430: 6b22 2c20 5b30 2c2b 6c2f 322c 5f63 6170  k", [0,+l/2,_cap
-0001a440: 5f68 325d 2c20 2020 2020 2020 2020 756e  _h2],         un
-0001a450: 6974 2828 6361 7076 6563 2b42 4143 4b29  it((capvec+BACK)
-0001a460: 2f32 292c 2031 3830 292c 0a20 2020 2020  /2), 180),.     
-0001a470: 2020 205d 2c0a 2020 2020 2020 2020 766e     ],.        vn
-0001a480: 6620 3d20 766e 665f 7665 7274 6578 5f61  f = vnf_vertex_a
-0001a490: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
-0001a4a0: 2020 706f 696e 7473 203d 205b 0a20 2020    points = [.   
-0001a4b0: 2020 2020 2020 2020 2020 2020 2066 7764               fwd
-0001a4c0: 286c 2f32 2c20 703d 7872 6f74 2839 302c  (l/2, p=xrot(90,
-0001a4d0: 2070 3d70 6174 6833 6428 7072 6f66 696c   p=path3d(profil
-0001a4e0: 6531 2929 292c 0a20 2020 2020 2020 2020  e1))),.         
-0001a4f0: 2020 2020 2020 2062 6163 6b28 6c2f 322c         back(l/2,
-0001a500: 2070 3d78 726f 7428 3930 2c20 703d 7061   p=xrot(90, p=pa
-0001a510: 7468 3364 2870 726f 6669 6c65 3229 2929  th3d(profile2)))
-0001a520: 2c0a 2020 2020 2020 2020 2020 2020 5d2c  ,.            ],
-0001a530: 0a20 2020 2020 2020 2020 2020 2063 6170  .            cap
-0001a540: 733d 7472 7565 2c20 636f 6c5f 7772 6170  s=true, col_wrap
-0001a550: 3d74 7275 652c 2072 6576 6572 7365 3d74  =true, reverse=t
-0001a560: 7275 650a 2020 2020 2020 2020 290a 2020  rue.        ).  
-0001a570: 2020 2920 7265 6f72 6965 6e74 2861 6e63    ) reorient(anc
-0001a580: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
-0001a590: 2072 313d 7231 2c20 7232 3d72 322c 206c   r1=r1, r2=r2, l
-0001a5a0: 3d6c 2c20 6178 6973 3d42 4143 4b2c 2061  =l, axis=BACK, a
-0001a5b0: 6e63 686f 7273 3d61 6e63 686f 7273 2c20  nchors=anchors, 
-0001a5c0: 703d 766e 6629 3b0a 0a0a 2f2f 2046 756e  p=vnf);...// Fun
-0001a5d0: 6374 696f 6e26 4d6f 6475 6c65 3a20 6f6e  ction&Module: on
-0001a5e0: 696f 6e28 290a 2f2f 0a2f 2f20 4465 7363  ion().//.// Desc
-0001a5f0: 7269 7074 696f 6e3a 0a2f 2f20 2020 4372  ription:.//   Cr
-0001a600: 6561 7465 7320 6120 7370 6865 7265 2077  eates a sphere w
-0001a610: 6974 6820 6120 636f 6e69 6361 6c20 6861  ith a conical ha
-0001a620: 742c 2074 6f20 6d61 6b65 2061 2033 4420  t, to make a 3D 
-0001a630: 7465 6172 6472 6f70 2e0a 2f2f 0a2f 2f20  teardrop..//.// 
-0001a640: 5573 6167 653a 2041 7320 4d6f 6475 6c65  Usage: As Module
-0001a650: 0a2f 2f20 2020 6f6e 696f 6e28 727c 643d  .//   onion(r|d=
-0001a660: 2c20 5b61 6e67 3d5d 2c20 5b63 6170 5f68  , [ang=], [cap_h
-0001a670: 3d5d 2c20 2e2e 2e29 205b 4154 5441 4348  =], ...) [ATTACH
-0001a680: 4d45 4e54 535d 3b0a 2f2f 2055 7361 6765  MENTS];.// Usage
-0001a690: 3a20 4173 2046 756e 6374 696f 6e0a 2f2f  : As Function.//
-0001a6a0: 2020 2076 6e66 203d 206f 6e69 6f6e 2872     vnf = onion(r
-0001a6b0: 7c64 3d2c 205b 616e 673d 5d2c 205b 6361  |d=, [ang=], [ca
-0001a6c0: 705f 683d 5d2c 202e 2e2e 293b 0a2f 2f0a  p_h=], ...);.//.
-0001a6d0: 2f2f 2041 7267 756d 656e 7473 3a0a 2f2f  // Arguments:.//
-0001a6e0: 2020 2072 203d 2072 6164 6975 7320 6f66     r = radius of
-0001a6f0: 2073 7068 6572 6963 616c 2070 6f72 7469   spherical porti
-0001a700: 6f6e 206f 6620 7468 6520 626f 7474 6f6d  on of the bottom
-0001a710: 2e20 4465 6661 756c 743a 2031 0a2f 2f20  . Default: 1.// 
-0001a720: 2020 616e 6720 3d20 416e 676c 6520 6f66    ang = Angle of
-0001a730: 2063 6f6e 6520 6f6e 2074 6f70 2066 726f   cone on top fro
-0001a740: 6d20 7665 7274 6963 616c 2e20 4465 6661  m vertical. Defa
-0001a750: 756c 743a 2034 3520 6465 6772 6565 730a  ult: 45 degrees.
-0001a760: 2f2f 2020 2063 6170 5f68 203d 2049 6620  //   cap_h = If 
-0001a770: 6769 7665 6e2c 2068 6569 6768 7420 6162  given, height ab
-0001a780: 6f76 6520 7370 6865 7265 2063 656e 7465  ove sphere cente
-0001a790: 7220 746f 2074 7275 6e63 6174 6520 7465  r to truncate te
-0001a7a0: 6172 6472 6f70 2073 6861 7065 2e20 2044  ardrop shape.  D
-0001a7b0: 6566 6175 6c74 3a20 6075 6e64 6566 6020  efault: `undef` 
-0001a7c0: 286e 6f20 7472 756e 6361 7469 6f6e 290a  (no truncation).
-0001a7d0: 2f2f 2020 202d 2d2d 0a2f 2f20 2020 6420  //   ---.//   d 
-0001a7e0: 3d20 6469 616d 6574 6572 206f 6620 7370  = diameter of sp
-0001a7f0: 6865 7269 6361 6c20 706f 7274 696f 6e20  herical portion 
-0001a800: 6f66 2062 6f74 746f 6d2e 0a2f 2f20 2020  of bottom..//   
-0001a810: 616e 6368 6f72 203d 2054 7261 6e73 6c61  anchor = Transla
-0001a820: 7465 2073 6f20 616e 6368 6f72 2070 6f69  te so anchor poi
-0001a830: 6e74 2069 7320 6174 206f 7269 6769 6e20  nt is at origin 
-0001a840: 2830 2c30 2c30 292e 2020 5365 6520 5b61  (0,0,0).  See [a
-0001a850: 6e63 686f 725d 2861 7474 6163 686d 656e  nchor](attachmen
-0001a860: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
-0001a870: 6f6e 2d61 6e63 686f 7229 2e20 2044 6566  on-anchor).  Def
-0001a880: 6175 6c74 3a20 6043 454e 5445 5260 0a2f  ault: `CENTER`./
-0001a890: 2f20 2020 7370 696e 203d 2052 6f74 6174  /   spin = Rotat
-0001a8a0: 6520 7468 6973 206d 616e 7920 6465 6772  e this many degr
-0001a8b0: 6565 7320 6172 6f75 6e64 2074 6865 205a  ees around the Z
-0001a8c0: 2061 7869 7320 6166 7465 7220 616e 6368   axis after anch
-0001a8d0: 6f72 2e20 2053 6565 205b 7370 696e 5d28  or.  See [spin](
-0001a8e0: 6174 7461 6368 6d65 6e74 732e 7363 6164  attachments.scad
-0001a8f0: 2373 7562 7365 6374 696f 6e2d 7370 696e  #subsection-spin
-0001a900: 292e 2020 4465 6661 756c 743a 2060 3060  ).  Default: `0`
-0001a910: 0a2f 2f20 2020 6f72 6965 6e74 203d 2056  .//   orient = V
-0001a920: 6563 746f 7220 746f 2072 6f74 6174 6520  ector to rotate 
-0001a930: 746f 7020 746f 7761 7264 732c 2061 6674  top towards, aft
-0001a940: 6572 2073 7069 6e2e 2020 5365 6520 5b6f  er spin.  See [o
-0001a950: 7269 656e 745d 2861 7474 6163 686d 656e  rient](attachmen
-0001a960: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
-0001a970: 6f6e 2d6f 7269 656e 7429 2e20 2044 6566  on-orient).  Def
-0001a980: 6175 6c74 3a20 6055 5060 0a2f 2f0a 2f2f  ault: `UP`.//.//
-0001a990: 2045 7874 7261 2041 6e63 686f 7273 3a0a   Extra Anchors:.
-0001a9a0: 2f2f 2020 2063 6170 203d 2054 6865 2063  //   cap = The c
-0001a9b0: 656e 7465 7220 6f66 2074 6865 2074 6f70  enter of the top
-0001a9c0: 206f 6620 7468 6520 6361 702c 206f 7269   of the cap, ori
-0001a9d0: 656e 7465 6420 7769 7468 2074 6865 2063  ented with the c
-0001a9e0: 6170 2066 6163 6520 6e6f 726d 616c 2e0a  ap face normal..
-0001a9f0: 2f2f 2020 2074 6970 203d 2054 6865 2070  //   tip = The p
-0001aa00: 6f73 6974 696f 6e20 7768 6572 6520 616e  osition where an
-0001aa10: 2075 6e2d 6361 7070 6564 206f 6e69 6f6e   un-capped onion
-0001aa20: 2077 6f75 6c64 2063 6f6d 6520 746f 2061   would come to a
-0001aa30: 2070 6f69 6e74 2c20 6f72 6965 6e74 6564   point, oriented
-0001aa40: 2069 6e20 7468 6520 6469 7265 6374 696f   in the directio
-0001aa50: 6e20 7468 6520 706f 696e 7420 6973 2066  n the point is f
-0001aa60: 726f 6d20 7468 6520 6365 6e74 6572 2e0a  rom the center..
-0001aa70: 2f2f 0a2f 2f20 4578 616d 706c 653a 2054  //.// Example: T
-0001aa80: 7970 6963 616c 2053 6861 7065 0a2f 2f20  ypical Shape.// 
-0001aa90: 2020 6f6e 696f 6e28 723d 3330 2c20 616e    onion(r=30, an
-0001aaa0: 673d 3330 293b 0a2f 2f20 4578 616d 706c  g=30);.// Exampl
-0001aab0: 653a 2043 726f 7020 4361 700a 2f2f 2020  e: Crop Cap.//  
-0001aac0: 206f 6e69 6f6e 2872 3d33 302c 2061 6e67   onion(r=30, ang
-0001aad0: 3d33 302c 2063 6170 5f68 3d34 3029 3b0a  =30, cap_h=40);.
-0001aae0: 2f2f 2045 7861 6d70 6c65 3a20 436c 6f73  // Example: Clos
-0001aaf0: 6520 4372 6f70 0a2f 2f20 2020 6f6e 696f  e Crop.//   onio
-0001ab00: 6e28 723d 3330 2c20 616e 673d 3330 2c20  n(r=30, ang=30, 
-0001ab10: 6361 705f 683d 3230 293b 0a2f 2f20 4578  cap_h=20);.// Ex
-0001ab20: 616d 706c 653a 204f 6e69 6f6e 7320 6172  ample: Onions ar
-0001ab30: 6520 7573 6566 756c 2066 6f72 206d 616b  e useful for mak
-0001ab40: 696e 6720 7468 6520 746f 7073 206f 6620  ing the tops of 
-0001ab50: 6c61 7267 6520 6379 6c69 6e64 7269 6361  large cylindrica
-0001ab60: 6c20 766f 6964 732e 0a2f 2f20 2020 6469  l voids..//   di
-0001ab70: 6666 6572 656e 6365 2829 207b 0a2f 2f20  fference() {.// 
-0001ab80: 2020 2020 2020 6375 626f 6964 285b 3130        cuboid([10
-0001ab90: 302c 3530 2c31 3030 5d2c 2061 6e63 686f  0,50,100], ancho
-0001aba0: 723d 4657 442b 424f 5429 3b0a 2f2f 2020  r=FWD+BOT);.//  
-0001abb0: 2020 2020 2064 6f77 6e28 302e 3129 0a2f       down(0.1)./
-0001abc0: 2f20 2020 2020 2020 2020 2020 6379 6c69  /           cyli
-0001abd0: 6e64 6572 2868 3d35 302c 643d 3530 2c61  nder(h=50,d=50,a
-0001abe0: 6e63 686f 723d 424f 5429 0a2f 2f20 2020  nchor=BOT).//   
-0001abf0: 2020 2020 2020 2020 2020 2020 6174 7461              atta
-0001ac00: 6368 2854 4f50 290a 2f2f 2020 2020 2020  ch(TOP).//      
-0001ac10: 2020 2020 2020 2020 2020 2020 206f 6e69               oni
-0001ac20: 6f6e 2864 3d35 302c 2063 6170 5f68 3d33  on(d=50, cap_h=3
-0001ac30: 3029 3b0a 2f2f 2020 207d 0a2f 2f20 4578  0);.//   }.// Ex
-0001ac40: 616d 706c 653a 2053 7461 6e64 6172 6420  ample: Standard 
-0001ac50: 436f 6e6e 6563 746f 7273 0a2f 2f20 2020  Connectors.//   
-0001ac60: 6f6e 696f 6e28 643d 3330 2c20 616e 673d  onion(d=30, ang=
-0001ac70: 3330 2c20 6361 705f 683d 3230 2920 7368  30, cap_h=20) sh
-0001ac80: 6f77 5f61 6e63 686f 7273 2829 3b0a 6d6f  ow_anchors();.mo
-0001ac90: 6475 6c65 206f 6e69 6f6e 2872 2c20 616e  dule onion(r, an
-0001aca0: 673d 3435 2c20 6361 705f 682c 2064 2c20  g=45, cap_h, d, 
-0001acb0: 616e 6368 6f72 3d43 454e 5445 522c 2073  anchor=CENTER, s
-0001acc0: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
-0001acd0: 290a 7b0a 2020 2020 7220 3d20 6765 745f  ).{.    r = get_
-0001ace0: 7261 6469 7573 2872 3d72 2c20 643d 642c  radius(r=r, d=d,
-0001acf0: 2064 666c 743d 3129 3b0a 2020 2020 7879   dflt=1);.    xy
-0001ad00: 7072 6f66 696c 6520 3d20 7465 6172 6472  profile = teardr
-0001ad10: 6f70 3264 2872 3d72 2c20 616e 673d 616e  op2d(r=r, ang=an
-0001ad20: 672c 2063 6170 5f68 3d63 6170 5f68 293b  g, cap_h=cap_h);
-0001ad30: 0a20 2020 2074 6970 5f68 203d 206d 6178  .    tip_h = max
-0001ad40: 2863 6f6c 756d 6e28 7879 7072 6f66 696c  (column(xyprofil
-0001ad50: 652c 3129 293b 0a20 2020 205f 6361 705f  e,1));.    _cap_
-0001ad60: 6820 3d20 6d69 6e28 6465 6661 756c 7428  h = min(default(
-0001ad70: 6361 705f 682c 7469 705f 6829 2c20 7469  cap_h,tip_h), ti
-0001ad80: 705f 6829 3b0a 2020 2020 616e 6368 6f72  p_h);.    anchor
-0001ad90: 7320 3d20 5b0a 2020 2020 2020 2020 5b22  s = [.        ["
-0001ada0: 6361 7022 2c20 5b30 2c30 2c5f 6361 705f  cap", [0,0,_cap_
-0001adb0: 685d 2c20 5550 2c20 305d 2c0a 2020 2020  h], UP, 0],.    
-0001adc0: 2020 2020 5b22 7469 7022 2c20 5b30 2c30      ["tip", [0,0
-0001add0: 2c74 6970 5f68 5d2c 2055 502c 2030 5d0a  ,tip_h], UP, 0].
-0001ade0: 2020 2020 5d3b 0a20 2020 2061 7474 6163      ];.    attac
-0001adf0: 6861 626c 6528 616e 6368 6f72 2c73 7069  hable(anchor,spi
-0001ae00: 6e2c 6f72 6965 6e74 2c20 723d 722c 2061  n,orient, r=r, a
-0001ae10: 6e63 686f 7273 3d61 6e63 686f 7273 2920  nchors=anchors) 
-0001ae20: 7b0a 2020 2020 2020 2020 726f 7461 7465  {.        rotate
-0001ae30: 5f65 7874 7275 6465 2863 6f6e 7665 7869  _extrude(convexi
-0001ae40: 7479 3d32 2920 7b0a 2020 2020 2020 2020  ty=2) {.        
-0001ae50: 2020 2020 6469 6666 6572 656e 6365 2829      difference()
-0001ae60: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0001ae70: 2020 2070 6f6c 7967 6f6e 2878 7970 726f     polygon(xypro
-0001ae80: 6669 6c65 293b 0a20 2020 2020 2020 2020  file);.         
-0001ae90: 2020 2020 2020 2073 7175 6172 6528 5b32         square([2
-0001aea0: 2a72 2c32 2a6d 6178 285f 6361 705f 682c  *r,2*max(_cap_h,
-0001aeb0: 7229 2b31 5d2c 2061 6e63 686f 723d 5249  r)+1], anchor=RI
-0001aec0: 4748 5429 3b0a 2020 2020 2020 2020 2020  GHT);.          
-0001aed0: 2020 7d0a 2020 2020 2020 2020 7d0a 2020    }.        }.  
-0001aee0: 2020 2020 2020 6368 696c 6472 656e 2829        children()
-0001aef0: 3b0a 2020 2020 7d0a 7d0a 0a0a 6675 6e63  ;.    }.}...func
-0001af00: 7469 6f6e 206f 6e69 6f6e 2872 2c20 616e  tion onion(r, an
-0001af10: 673d 3435 2c20 6361 705f 682c 2064 2c20  g=45, cap_h, d, 
-0001af20: 616e 6368 6f72 3d43 454e 5445 522c 2073  anchor=CENTER, s
-0001af30: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
-0001af40: 2920 3d0a 2020 2020 6c65 7428 0a20 2020  ) =.    let(.   
-0001af50: 2020 2020 2072 203d 2067 6574 5f72 6164       r = get_rad
-0001af60: 6975 7328 723d 722c 2064 3d64 2c20 6466  ius(r=r, d=d, df
-0001af70: 6c74 3d31 292c 0a20 2020 2020 2020 2078  lt=1),.        x
-0001af80: 7970 726f 6669 6c65 203d 2072 6967 6874  yprofile = right
-0001af90: 5f68 616c 6628 703d 7465 6172 6472 6f70  _half(p=teardrop
-0001afa0: 3264 2872 3d72 2c20 616e 673d 616e 672c  2d(r=r, ang=ang,
-0001afb0: 2063 6170 5f68 3d63 6170 5f68 2929 5b30   cap_h=cap_h))[0
-0001afc0: 5d2c 0a20 2020 2020 2020 2070 726f 6669  ],.        profi
-0001afd0: 6c65 203d 2078 726f 7428 3930 2c20 703d  le = xrot(90, p=
-0001afe0: 7061 7468 3364 2878 7970 726f 6669 6c65  path3d(xyprofile
-0001aff0: 2929 2c0a 2020 2020 2020 2020 7469 705f  )),.        tip_
-0001b000: 6820 3d20 6d61 7828 636f 6c75 6d6e 2878  h = max(column(x
-0001b010: 7970 726f 6669 6c65 2c31 2929 2c0a 2020  yprofile,1)),.  
-0001b020: 2020 2020 2020 5f63 6170 5f68 203d 206d        _cap_h = m
-0001b030: 696e 2864 6566 6175 6c74 2863 6170 5f68  in(default(cap_h
-0001b040: 2c74 6970 5f68 292c 2074 6970 5f68 292c  ,tip_h), tip_h),
-0001b050: 0a20 2020 2020 2020 2061 6e63 686f 7273  .        anchors
-0001b060: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-0001b070: 205b 2263 6170 222c 205b 302c 302c 5f63   ["cap", [0,0,_c
-0001b080: 6170 5f68 5d2c 2055 502c 2030 5d2c 0a20  ap_h], UP, 0],. 
-0001b090: 2020 2020 2020 2020 2020 205b 2274 6970             ["tip
-0001b0a0: 222c 205b 302c 302c 7469 705f 685d 2c20  ", [0,0,tip_h], 
-0001b0b0: 5550 2c20 305d 0a20 2020 2020 2020 205d  UP, 0].        ]
-0001b0c0: 2c0a 2020 2020 2020 2020 7369 6465 7320  ,.        sides 
-0001b0d0: 3d20 7365 6773 2872 292c 0a20 2020 2020  = segs(r),.     
-0001b0e0: 2020 2073 7465 7020 3d20 3336 3020 2f20     step = 360 / 
-0001b0f0: 7369 6465 732c 0a20 2020 2020 2020 2076  sides,.        v
-0001b100: 6e66 203d 2076 6e66 5f76 6572 7465 785f  nf = vnf_vertex_
-0001b110: 6172 7261 7928 0a20 2020 2020 2020 2020  array(.         
-0001b120: 2020 2070 6f69 6e74 733d 5b66 6f72 2028     points=[for (
-0001b130: 6120 3d20 5b30 3a73 7465 703a 3336 302d  a = [0:step:360-
-0001b140: 4550 5349 4c4f 4e5d 2920 7a72 6f74 2861  EPSILON]) zrot(a
-0001b150: 2c20 703d 7072 6f66 696c 6529 5d2c 0a20  , p=profile)],. 
-0001b160: 2020 2020 2020 2020 2020 2063 6170 733d             caps=
-0001b170: 6661 6c73 652c 2063 6f6c 5f77 7261 703d  false, col_wrap=
-0001b180: 7472 7565 2c20 726f 775f 7772 6170 3d74  true, row_wrap=t
-0001b190: 7275 652c 2072 6576 6572 7365 3d74 7275  rue, reverse=tru
-0001b1a0: 650a 2020 2020 2020 2020 290a 2020 2020  e.        ).    
-0001b1b0: 2920 7265 6f72 6965 6e74 2861 6e63 686f  ) reorient(ancho
-0001b1c0: 722c 7370 696e 2c6f 7269 656e 742c 2072  r,spin,orient, r
-0001b1d0: 3d72 2c20 616e 6368 6f72 733d 616e 6368  =r, anchors=anch
-0001b1e0: 6f72 732c 2070 3d76 6e66 293b 0a0a 0a2f  ors, p=vnf);.../
-0001b1f0: 2f20 5365 6374 696f 6e3a 2054 6578 740a  / Section: Text.
-0001b200: 0a2f 2f20 4d6f 6475 6c65 3a20 7465 7874  .// Module: text
-0001b210: 3364 2829 0a2f 2f20 546f 7069 6373 3a20  3d().// Topics: 
-0001b220: 4174 7461 6368 6d65 6e74 732c 2054 6578  Attachments, Tex
-0001b230: 740a 2f2f 2055 7361 6765 3a0a 2f2f 2020  t.// Usage:.//  
-0001b240: 2074 6578 7433 6428 7465 7874 2c20 5b68   text3d(text, [h
-0001b250: 5d2c 205b 7369 7a65 5d2c 205b 666f 6e74  ], [size], [font
-0001b260: 5d2c 202e 2e2e 293b 0a2f 2f20 4465 7363  ], ...);.// Desc
-0001b270: 7269 7074 696f 6e3a 0a2f 2f20 2020 4372  ription:.//   Cr
-0001b280: 6561 7465 7320 6120 3344 2074 6578 7420  eates a 3D text 
-0001b290: 626c 6f63 6b20 7468 6174 2063 616e 2062  block that can b
-0001b2a0: 6520 6174 7461 6368 6564 2074 6f20 6f74  e attached to ot
-0001b2b0: 6865 7220 6174 7461 6368 6162 6c65 206f  her attachable o
-0001b2c0: 626a 6563 7473 2e0a 2f2f 2020 204e 4f54  bjects..//   NOT
-0001b2d0: 453a 2054 6869 7320 6361 6e6e 6f74 2068  E: This cannot h
-0001b2e0: 6176 6520 6368 696c 6472 656e 2061 7474  ave children att
-0001b2f0: 6163 6865 6420 746f 2069 742e 0a2f 2f20  ached to it..// 
-0001b300: 4172 6775 6d65 6e74 733a 0a2f 2f20 2020  Arguments:.//   
-0001b310: 7465 7874 203d 2054 6865 2074 6578 7420  text = The text 
-0001b320: 7374 7269 6e67 2074 6f20 696e 7374 616e  string to instan
-0001b330: 7469 6174 6520 6173 2061 6e20 6f62 6a65  tiate as an obje
-0001b340: 6374 2e0a 2f2f 2020 2068 203d 2054 6865  ct..//   h = The
-0001b350: 2068 6569 6768 7420 746f 2077 6869 6368   height to which
-0001b360: 2074 6865 2074 6578 7420 7368 6f75 6c64   the text should
-0001b370: 2062 6520 6578 7472 7564 6564 2e20 2044   be extruded.  D
-0001b380: 6566 6175 6c74 3a20 310a 2f2f 2020 2073  efault: 1.//   s
-0001b390: 697a 6520 3d20 5468 6520 666f 6e74 2073  ize = The font s
-0001b3a0: 697a 6520 7573 6564 2074 6f20 6372 6561  ize used to crea
-0001b3b0: 7465 2074 6865 2074 6578 7420 626c 6f63  te the text bloc
-0001b3c0: 6b2e 2020 4465 6661 756c 743a 2031 300a  k.  Default: 10.
-0001b3d0: 2f2f 2020 2066 6f6e 7420 3d20 5468 6520  //   font = The 
-0001b3e0: 6e61 6d65 206f 6620 7468 6520 666f 6e74  name of the font
-0001b3f0: 2075 7365 6420 746f 2063 7265 6174 6520   used to create 
-0001b400: 7468 6520 7465 7874 2062 6c6f 636b 2e20  the text block. 
-0001b410: 2044 6566 6175 6c74 3a20 2248 656c 7665   Default: "Helve
-0001b420: 7469 6361 220a 2f2f 2020 202d 2d2d 0a2f  tica".//   ---./
-0001b430: 2f20 2020 6861 6c69 676e 203d 2049 6620  /   halign = If 
-0001b440: 6769 7665 6e2c 2073 7065 6369 6669 6573  given, specifies
-0001b450: 2074 6865 2068 6f72 697a 6f6e 7461 6c20   the horizontal 
-0001b460: 616c 6967 6e6d 656e 7420 6f66 2074 6865  alignment of the
-0001b470: 2074 6578 742e 2020 6022 6c65 6674 2260   text.  `"left"`
-0001b480: 2c20 6022 6365 6e74 6572 2260 2c20 6f72  , `"center"`, or
-0001b490: 2060 2272 6967 6874 2260 2e20 204f 7665   `"right"`.  Ove
-0001b4a0: 7272 6964 6573 2060 616e 6368 6f72 3d60  rrides `anchor=`
-0001b4b0: 2e0a 2f2f 2020 2076 616c 6967 6e20 3d20  ..//   valign = 
-0001b4c0: 4966 2067 6976 656e 2c20 7370 6563 6966  If given, specif
-0001b4d0: 6965 7320 7468 6520 7665 7274 6963 616c  ies the vertical
-0001b4e0: 2061 6c69 676e 6d65 6e74 206f 6620 7468   alignment of th
-0001b4f0: 6520 7465 7874 2e20 2060 2274 6f70 2260  e text.  `"top"`
-0001b500: 2c20 6022 6365 6e74 6572 2260 2c20 6022  , `"center"`, `"
-0001b510: 6261 7365 6c69 6e65 2260 206f 7220 6022  baseline"` or `"
-0001b520: 626f 7474 6f6d 2260 2e20 204f 7665 7272  bottom"`.  Overr
-0001b530: 6964 6573 2060 616e 6368 6f72 3d60 2e0a  ides `anchor=`..
-0001b540: 2f2f 2020 2073 7061 6369 6e67 203d 2054  //   spacing = T
-0001b550: 6865 2072 656c 6174 6976 6520 7370 6163  he relative spac
-0001b560: 696e 6720 6d75 6c74 6970 6c69 6572 2062  ing multiplier b
-0001b570: 6574 7765 656e 2063 6861 7261 6374 6572  etween character
-0001b580: 732e 2020 4465 6661 756c 743a 2060 312e  s.  Default: `1.
-0001b590: 3060 0a2f 2f20 2020 6469 7265 6374 696f  0`.//   directio
-0001b5a0: 6e20 3d20 5468 6520 7465 7874 2064 6972  n = The text dir
-0001b5b0: 6563 7469 6f6e 2e20 2060 226c 7472 2260  ection.  `"ltr"`
-0001b5c0: 2066 6f72 206c 6566 7420 746f 2072 6967   for left to rig
-0001b5d0: 6874 2e20 2060 2272 746c 2260 2066 6f72  ht.  `"rtl"` for
-0001b5e0: 2072 6967 6874 2074 6f20 6c65 6674 2e20   right to left. 
-0001b5f0: 6022 7474 6222 6020 666f 7220 746f 7020  `"ttb"` for top 
-0001b600: 746f 2062 6f74 746f 6d2e 2060 2262 7474  to bottom. `"btt
-0001b610: 2260 2066 6f72 2062 6f74 746f 6d20 746f  "` for bottom to
-0001b620: 2074 6f70 2e20 2044 6566 6175 6c74 3a20   top.  Default: 
-0001b630: 6022 6c74 7222 600a 2f2f 2020 206c 616e  `"ltr"`.//   lan
-0001b640: 6775 6167 6520 3d20 5468 6520 6c61 6e67  guage = The lang
-0001b650: 7561 6765 2074 6865 2074 6578 7420 6973  uage the text is
-0001b660: 2069 6e2e 2020 4465 6661 756c 743a 2060   in.  Default: `
-0001b670: 2265 6e22 600a 2f2f 2020 2073 6372 6970  "en"`.//   scrip
-0001b680: 7420 3d20 5468 6520 7363 7269 7074 2074  t = The script t
-0001b690: 6865 2074 6578 7420 6973 2069 6e2e 2020  he text is in.  
-0001b6a0: 4465 6661 756c 743a 2060 226c 6174 696e  Default: `"latin
-0001b6b0: 2260 0a2f 2f20 2020 616e 6368 6f72 203d  "`.//   anchor =
-0001b6c0: 2054 7261 6e73 6c61 7465 2073 6f20 616e   Translate so an
-0001b6d0: 6368 6f72 2070 6f69 6e74 2069 7320 6174  chor point is at
-0001b6e0: 206f 7269 6769 6e20 2830 2c30 2c30 292e   origin (0,0,0).
-0001b6f0: 2020 5365 6520 5b61 6e63 686f 725d 2861    See [anchor](a
-0001b700: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
-0001b710: 7375 6273 6563 7469 6f6e 2d61 6e63 686f  subsection-ancho
-0001b720: 7229 2e20 2044 6566 6175 6c74 3a20 6022  r).  Default: `"
-0001b730: 6261 7365 6c69 6e65 2260 0a2f 2f20 2020  baseline"`.//   
-0001b740: 7370 696e 203d 2052 6f74 6174 6520 7468  spin = Rotate th
-0001b750: 6973 206d 616e 7920 6465 6772 6565 7320  is many degrees 
-0001b760: 6172 6f75 6e64 2074 6865 205a 2061 7869  around the Z axi
-0001b770: 732e 2020 5365 6520 5b73 7069 6e5d 2861  s.  See [spin](a
-0001b780: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
-0001b790: 7375 6273 6563 7469 6f6e 2d73 7069 6e29  subsection-spin)
-0001b7a0: 2e20 2044 6566 6175 6c74 3a20 6030 600a  .  Default: `0`.
-0001b7b0: 2f2f 2020 206f 7269 656e 7420 3d20 5665  //   orient = Ve
-0001b7c0: 6374 6f72 2074 6f20 726f 7461 7465 2074  ctor to rotate t
-0001b7d0: 6f70 2074 6f77 6172 6473 2e20 2053 6565  op towards.  See
-0001b7e0: 205b 6f72 6965 6e74 5d28 6174 7461 6368   [orient](attach
-0001b7f0: 6d65 6e74 732e 7363 6164 2373 7562 7365  ments.scad#subse
-0001b800: 6374 696f 6e2d 6f72 6965 6e74 292e 2020  ction-orient).  
-0001b810: 4465 6661 756c 743a 2060 5550 600a 2f2f  Default: `UP`.//
-0001b820: 2053 6565 2041 6c73 6f3a 2070 6174 685f   See Also: path_
-0001b830: 7465 7874 2829 0a2f 2f20 4578 7472 6120  text().// Extra 
-0001b840: 416e 6368 6f72 733a 0a2f 2f20 2020 2262  Anchors:.//   "b
-0001b850: 6173 656c 696e 6522 203d 2041 6e63 686f  aseline" = Ancho
-0001b860: 7273 2061 7420 7468 6520 6261 7365 6c69  rs at the baseli
-0001b870: 6e65 206f 6620 7468 6520 7465 7874 2c20  ne of the text, 
-0001b880: 6174 2074 6865 2073 7461 7274 206f 6620  at the start of 
-0001b890: 7468 6520 7374 7269 6e67 2e0a 2f2f 2020  the string..//  
-0001b8a0: 2073 7472 2822 6261 7365 6c69 6e65 222c   str("baseline",
-0001b8b0: 5645 4354 4f52 2920 3d20 416e 6368 6f72  VECTOR) = Anchor
-0001b8c0: 7320 6174 2074 6865 2062 6173 656c 696e  s at the baselin
-0001b8d0: 6520 6f66 2074 6865 2074 6578 742c 206d  e of the text, m
-0001b8e0: 6f64 6966 6965 6420 6279 2074 6865 2058  odified by the X
-0001b8f0: 2061 6e64 205a 2063 6f6d 706f 6e65 6e74   and Z component
-0001b900: 7320 6f66 2074 6865 2061 7070 656e 6465  s of the appende
-0001b910: 6420 7665 6374 6f72 2e0a 2f2f 2045 7861  d vector..// Exa
-0001b920: 6d70 6c65 733a 0a2f 2f20 2020 7465 7874  mples:.//   text
-0001b930: 3364 2822 466f 6f62 6172 222c 2068 3d33  3d("Foobar", h=3
-0001b940: 2c20 7369 7a65 3d31 3029 3b0a 2f2f 2020  , size=10);.//  
-0001b950: 2074 6578 7433 6428 2246 6f6f 6261 7222   text3d("Foobar"
-0001b960: 2c20 683d 322c 2073 697a 653d 3132 2c20  , h=2, size=12, 
-0001b970: 666f 6e74 3d22 4865 6c76 6574 6963 6122  font="Helvetica"
-0001b980: 293b 0a2f 2f20 2020 7465 7874 3364 2822  );.//   text3d("
-0001b990: 466f 6f62 6172 222c 2068 3d32 2c20 616e  Foobar", h=2, an
-0001b9a0: 6368 6f72 3d43 454e 5445 5229 3b0a 2f2f  chor=CENTER);.//
-0001b9b0: 2020 2074 6578 7433 6428 2246 6f6f 6261     text3d("Fooba
-0001b9c0: 7222 2c20 683d 322c 2061 6e63 686f 723d  r", h=2, anchor=
-0001b9d0: 7374 7228 2262 6173 656c 696e 6522 2c43  str("baseline",C
-0001b9e0: 454e 5445 5229 293b 0a2f 2f20 2020 7465  ENTER));.//   te
-0001b9f0: 7874 3364 2822 466f 6f62 6172 222c 2068  xt3d("Foobar", h
-0001ba00: 3d32 2c20 616e 6368 6f72 3d73 7472 2822  =2, anchor=str("
-0001ba10: 6261 7365 6c69 6e65 222c 424f 5454 4f4d  baseline",BOTTOM
-0001ba20: 2b52 4947 4854 2929 3b0a 6d6f 6475 6c65  +RIGHT));.module
-0001ba30: 2074 6578 7433 6428 7465 7874 2c20 683d   text3d(text, h=
-0001ba40: 312c 2073 697a 653d 3130 2c20 666f 6e74  1, size=10, font
-0001ba50: 3d22 4865 6c76 6574 6963 6122 2c20 6861  ="Helvetica", ha
-0001ba60: 6c69 676e 2c20 7661 6c69 676e 2c20 7370  lign, valign, sp
-0001ba70: 6163 696e 673d 312e 302c 2064 6972 6563  acing=1.0, direc
-0001ba80: 7469 6f6e 3d22 6c74 7222 2c20 6c61 6e67  tion="ltr", lang
-0001ba90: 7561 6765 3d22 656d 222c 2073 6372 6970  uage="em", scrip
-0001baa0: 743d 226c 6174 696e 222c 2061 6e63 686f  t="latin", ancho
-0001bab0: 723d 2262 6173 656c 696e 655b 2d31 2c30  r="baseline[-1,0
-0001bac0: 2c2d 315d 222c 2073 7069 6e3d 302c 206f  ,-1]", spin=0, o
-0001bad0: 7269 656e 743d 5550 2920 7b0a 2020 2020  rient=UP) {.    
-0001bae0: 6e6f 5f63 6869 6c64 7265 6e28 2463 6869  no_children($chi
-0001baf0: 6c64 7265 6e29 3b0a 2020 2020 6475 6d6d  ldren);.    dumm
-0001bb00: 7931 203d 0a20 2020 2020 2020 2061 7373  y1 =.        ass
-0001bb10: 6572 7428 6973 5f75 6e64 6566 2861 6e63  ert(is_undef(anc
-0001bb20: 686f 7229 207c 7c20 6973 5f76 6563 746f  hor) || is_vecto
-0001bb30: 7228 616e 6368 6f72 2920 7c7c 2069 735f  r(anchor) || is_
-0001bb40: 7374 7269 6e67 2861 6e63 686f 7229 2c20  string(anchor), 
-0001bb50: 7374 7228 2247 6f74 3a20 222c 616e 6368  str("Got: ",anch
-0001bb60: 6f72 2929 0a20 2020 2020 2020 2061 7373  or)).        ass
-0001bb70: 6572 7428 6973 5f75 6e64 6566 2873 7069  ert(is_undef(spi
-0001bb80: 6e29 2020 207c 7c20 6973 5f76 6563 746f  n)   || is_vecto
-0001bb90: 7228 7370 696e 2c33 2920 7c7c 2069 735f  r(spin,3) || is_
-0001bba0: 6e75 6d28 7370 696e 292c 2073 7472 2822  num(spin), str("
-0001bbb0: 476f 743a 2022 2c73 7069 6e29 290a 2020  Got: ",spin)).  
-0001bbc0: 2020 2020 2020 6173 7365 7274 2869 735f        assert(is_
-0001bbd0: 756e 6465 6628 6f72 6965 6e74 2920 7c7c  undef(orient) ||
-0001bbe0: 2069 735f 7665 6374 6f72 286f 7269 656e   is_vector(orien
-0001bbf0: 742c 3329 2c20 7374 7228 2247 6f74 3a20  t,3), str("Got: 
-0001bc00: 222c 6f72 6965 6e74 2929 3b0a 2020 2020  ",orient));.    
-0001bc10: 616e 6368 6f72 203d 2064 6566 6175 6c74  anchor = default
-0001bc20: 2861 6e63 686f 722c 2043 454e 5445 5229  (anchor, CENTER)
-0001bc30: 3b0a 2020 2020 7370 696e 203d 2020 2064  ;.    spin =   d
-0001bc40: 6566 6175 6c74 2873 7069 6e2c 2020 2030  efault(spin,   0
-0001bc50: 293b 0a20 2020 206f 7269 656e 7420 3d20  );.    orient = 
-0001bc60: 6465 6661 756c 7428 6f72 6965 6e74 2c20  default(orient, 
-0001bc70: 5550 293b 0a20 2020 2067 656f 6d20 3d20  UP);.    geom = 
-0001bc80: 6174 7461 6368 5f67 656f 6d28 7369 7a65  attach_geom(size
-0001bc90: 3d5b 7369 7a65 2c73 697a 652c 685d 293b  =[size,size,h]);
-0001bca0: 0a20 2020 2061 6e63 6820 3d20 2161 6e79  .    anch = !any
-0001bcb0: 285b 666f 7220 2863 3d61 6e63 686f 7229  ([for (c=anchor)
-0001bcc0: 2063 3d3d 225b 225d 293f 2061 6e63 686f   c=="["])? ancho
-0001bcd0: 7220 3a0a 2020 2020 2020 2020 6c65 7428  r :.        let(
-0001bce0: 0a20 2020 2020 2020 2020 2020 2070 6172  .            par
-0001bcf0: 7473 203d 2073 7472 5f73 706c 6974 2873  ts = str_split(s
-0001bd00: 7472 5f73 706c 6974 2873 7472 5f73 706c  tr_split(str_spl
-0001bd10: 6974 2861 6e63 686f 722c 225d 2229 5b30  it(anchor,"]")[0
-0001bd20: 5d2c 225b 2229 5b31 5d2c 222c 2229 2c0a  ],"[")[1],","),.
-0001bd30: 2020 2020 2020 2020 2020 2020 7665 6320              vec 
-0001bd40: 3d20 5b66 6f72 2028 703d 7061 7274 7329  = [for (p=parts)
-0001bd50: 2070 6172 7365 5f66 6c6f 6174 2873 7472   parse_float(str
-0001bd60: 5f73 7472 6970 2870 2c22 2022 2c73 7461  _strip(p," ",sta
-0001bd70: 7274 3d74 7275 6529 295d 0a20 2020 2020  rt=true))].     
-0001bd80: 2020 2029 2076 6563 3b0a 2020 2020 6861     ) vec;.    ha
-0001bd90: 203d 2061 6e63 686f 723d 3d22 6261 7365   = anchor=="base
-0001bda0: 6c69 6e65 223f 2022 6c65 6674 2220 3a0a  line"? "left" :.
-0001bdb0: 2020 2020 2020 2020 616e 6368 6f72 3d3d          anchor==
-0001bdc0: 616e 6368 2026 2620 6973 5f73 7472 696e  anch && is_strin
-0001bdd0: 6728 616e 6368 6f72 293f 2022 6365 6e74  g(anchor)? "cent
-0001bde0: 6572 2220 3a0a 2020 2020 2020 2020 616e  er" :.        an
-0001bdf0: 6368 2e78 3c30 3f20 226c 6566 7422 203a  ch.x<0? "left" :
-0001be00: 0a20 2020 2020 2020 2061 6e63 682e 783e  .        anch.x>
-0001be10: 303f 2022 7269 6768 7422 203a 0a20 2020  0? "right" :.   
-0001be20: 2020 2020 2022 6365 6e74 6572 223b 0a20       "center";. 
-0001be30: 2020 2076 6120 3d20 7374 6172 7473 5f77     va = starts_w
-0001be40: 6974 6828 616e 6368 6f72 2c22 6261 7365  ith(anchor,"base
-0001be50: 6c69 6e65 2229 3f20 2262 6173 656c 696e  line")? "baselin
-0001be60: 6522 203a 0a20 2020 2020 2020 2061 6e63  e" :.        anc
-0001be70: 686f 723d 3d61 6e63 6820 2626 2069 735f  hor==anch && is_
-0001be80: 7374 7269 6e67 2861 6e63 686f 7229 3f20  string(anchor)? 
-0001be90: 2263 656e 7465 7222 203a 0a20 2020 2020  "center" :.     
-0001bea0: 2020 2061 6e63 682e 793c 303f 2022 626f     anch.y<0? "bo
-0001beb0: 7474 6f6d 2220 3a0a 2020 2020 2020 2020  ttom" :.        
-0001bec0: 616e 6368 2e79 3e30 3f20 2274 6f70 2220  anch.y>0? "top" 
-0001bed0: 3a0a 2020 2020 2020 2020 2263 656e 7465  :.        "cente
-0001bee0: 7222 3b0a 2020 2020 6261 7365 203d 2061  r";.    base = a
-0001bef0: 6e63 686f 723d 3d22 6261 7365 6c69 6e65  nchor=="baseline
-0001bf00: 223f 2043 454e 5445 5220 3a0a 2020 2020  "? CENTER :.    
-0001bf10: 2020 2020 616e 6368 6f72 3d3d 616e 6368      anchor==anch
-0001bf20: 2026 2620 6973 5f73 7472 696e 6728 616e   && is_string(an
-0001bf30: 6368 6f72 293f 2043 454e 5445 5220 3a0a  chor)? CENTER :.
-0001bf40: 2020 2020 2020 2020 616e 6368 2e7a 3c30          anch.z<0
-0001bf50: 3f20 424f 5454 4f4d 203a 0a20 2020 2020  ? BOTTOM :.     
-0001bf60: 2020 2061 6e63 682e 7a3e 303f 2054 4f50     anch.z>0? TOP
-0001bf70: 203a 0a20 2020 2020 2020 2043 454e 5445   :.        CENTE
-0001bf80: 523b 0a20 2020 206d 203d 205f 6174 7461  R;.    m = _atta
-0001bf90: 6368 5f74 7261 6e73 666f 726d 2862 6173  ch_transform(bas
-0001bfa0: 652c 7370 696e 2c6f 7269 656e 742c 6765  e,spin,orient,ge
-0001bfb0: 6f6d 293b 0a20 2020 206d 756c 746d 6174  om);.    multmat
-0001bfc0: 7269 7828 6d29 207b 0a20 2020 2020 2020  rix(m) {.       
-0001bfd0: 2024 7061 7265 6e74 5f61 6e63 686f 7220   $parent_anchor 
-0001bfe0: 3d20 616e 6368 6f72 3b0a 2020 2020 2020  = anchor;.      
-0001bff0: 2020 2470 6172 656e 745f 7370 696e 2020    $parent_spin  
-0001c000: 203d 2073 7069 6e3b 0a20 2020 2020 2020   = spin;.       
-0001c010: 2024 7061 7265 6e74 5f6f 7269 656e 7420   $parent_orient 
-0001c020: 3d20 6f72 6965 6e74 3b0a 2020 2020 2020  = orient;.      
-0001c030: 2020 2470 6172 656e 745f 6765 6f6d 2020    $parent_geom  
-0001c040: 203d 2067 656f 6d3b 0a20 2020 2020 2020   = geom;.       
-0001c050: 2024 7061 7265 6e74 5f73 697a 6520 2020   $parent_size   
-0001c060: 3d20 5f61 7474 6163 685f 6765 6f6d 5f73  = _attach_geom_s
-0001c070: 697a 6528 6765 6f6d 293b 0a20 2020 2020  ize(geom);.     
-0001c080: 2020 2024 6174 7461 6368 5f74 6f20 2020     $attach_to   
-0001c090: 3d20 756e 6465 663b 0a20 2020 2020 2020  = undef;.       
-0001c0a0: 2069 6620 285f 6973 5f73 686f 776e 2829   if (_is_shown()
-0001c0b0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
-0001c0c0: 5f63 6f6c 6f72 2824 636f 6c6f 7229 207b  _color($color) {
-0001c0d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001c0e0: 206c 696e 6561 725f 6578 7472 7564 6528   linear_extrude(
-0001c0f0: 6865 6967 6874 3d68 2c20 6365 6e74 6572  height=h, center
-0001c100: 3d74 7275 6529 0a20 2020 2020 2020 2020  =true).         
-0001c110: 2020 2020 2020 2020 2020 205f 7465 7874             _text
-0001c120: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0001c130: 2020 2020 2020 2020 2020 7465 7874 3d74            text=t
-0001c140: 6578 742c 2073 697a 653d 7369 7a65 2c20  ext, size=size, 
-0001c150: 666f 6e74 3d66 6f6e 742c 0a20 2020 2020  font=font,.     
+00005c70: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00005c80: 6563 203d 2045 4447 455f 4f46 4653 4554  ec = EDGE_OFFSET
+00005c90: 535b 6178 6973 5d5b 695d 3b0a 2020 2020  S[axis][i];.    
+00005ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005cb0: 2020 2020 2020 2020 2020 2020 7472 616e              tran
+00005cc0: 736c 6174 6528 765f 6d75 6c28 7665 632f  slate(v_mul(vec/
+00005cd0: 322c 2073 697a 652b 5b32 2a61 7264 2c32  2, size+[2*ard,2
+00005ce0: 2a61 7264 2c2d 322a 6172 645d 2929 207b  *ard,-2*ard])) {
+00005cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005d10: 2020 2020 2072 6f74 6174 6528 6d61 6a72       rotate(majr
+00005d20: 6f74 735b 6178 6973 5d29 207b 0a20 2020  ots[axis]) {.   
+00005d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005d50: 2020 2020 2063 796c 286c 3d73 697a 655b       cyl(l=size[
+00005d60: 6178 6973 5d2b 322e 312a 6172 642c 2072  axis]+2.1*ard, r
+00005d70: 3d61 7264 293b 0a20 2020 2020 2020 2020  =ard);.         
+00005d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005d90: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00005da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005db0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00005dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005dd0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00005de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005df0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
+00005e00: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
+00005e10: 2020 2020 2020 2020 2020 2020 207d 2065               } e
+00005e20: 6c73 6520 7b0a 2020 2020 2020 2020 2020  lse {.          
+00005e30: 2020 2020 2020 2020 2020 6875 6c6c 2829            hull()
+00005e40: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00005e50: 2020 2020 2020 2020 2020 2063 6f72 6e65             corne
+00005e60: 725f 7368 6170 6528 5b2d 312c 2d31 2c2d  r_shape([-1,-1,-
+00005e70: 315d 293b 0a20 2020 2020 2020 2020 2020  1]);.           
+00005e80: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
+00005e90: 6e65 725f 7368 6170 6528 5b20 312c 2d31  ner_shape([ 1,-1
+00005ea0: 2c2d 315d 293b 0a20 2020 2020 2020 2020  ,-1]);.         
+00005eb0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00005ec0: 6f72 6e65 725f 7368 6170 6528 5b2d 312c  orner_shape([-1,
+00005ed0: 2031 2c2d 315d 293b 0a20 2020 2020 2020   1,-1]);.       
+00005ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ef0: 2063 6f72 6e65 725f 7368 6170 6528 5b20   corner_shape([ 
+00005f00: 312c 2031 2c2d 315d 293b 0a20 2020 2020  1, 1,-1]);.     
+00005f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f20: 2020 2063 6f72 6e65 725f 7368 6170 6528     corner_shape(
+00005f30: 5b2d 312c 2d31 2c20 315d 293b 0a20 2020  [-1,-1, 1]);.   
+00005f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f50: 2020 2020 2063 6f72 6e65 725f 7368 6170       corner_shap
+00005f60: 6528 5b20 312c 2d31 2c20 315d 293b 0a20  e([ 1,-1, 1]);. 
+00005f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f80: 2020 2020 2020 2063 6f72 6e65 725f 7368         corner_sh
+00005f90: 6170 6528 5b2d 312c 2031 2c20 315d 293b  ape([-1, 1, 1]);
+00005fa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005fb0: 2020 2020 2020 2020 2063 6f72 6e65 725f           corner_
+00005fc0: 7368 6170 6528 5b20 312c 2031 2c20 315d  shape([ 1, 1, 1]
+00005fd0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00005fe0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00005ff0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00006000: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
+00006010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006020: 6375 6265 2873 697a 653d 7369 7a65 2c20  cube(size=size, 
+00006030: 6365 6e74 6572 3d74 7275 6529 3b0a 2020  center=true);.  
+00006040: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00006050: 2020 2020 2020 2020 6368 696c 6472 656e          children
+00006060: 2829 3b0a 2020 2020 2020 2020 7d0a 2020  ();.        }.  
+00006070: 2020 7d0a 7d0a 0a0a 6675 6e63 7469 6f6e    }.}...function
+00006080: 2063 7562 6f69 6428 0a20 2020 2073 697a   cuboid(.    siz
+00006090: 653d 5b31 2c31 2c31 5d2c 0a20 2020 2070  e=[1,1,1],.    p
+000060a0: 312c 2070 322c 0a20 2020 2063 6861 6d66  1, p2,.    chamf
+000060b0: 6572 2c0a 2020 2020 726f 756e 6469 6e67  er,.    rounding
+000060c0: 2c0a 2020 2020 6564 6765 733d 4544 4745  ,.    edges=EDGE
+000060d0: 535f 414c 4c2c 0a20 2020 2065 7863 6570  S_ALL,.    excep
+000060e0: 745f 6564 6765 733d 5b5d 2c0a 2020 2020  t_edges=[],.    
+000060f0: 7472 696d 636f 726e 6572 733d 7472 7565  trimcorners=true
+00006100: 2c0a 2020 2020 616e 6368 6f72 3d43 454e  ,.    anchor=CEN
+00006110: 5445 522c 0a20 2020 2073 7069 6e3d 302c  TER,.    spin=0,
+00006120: 0a20 2020 206f 7269 656e 743d 5550 0a29  .    orient=UP.)
+00006130: 203d 206e 6f5f 6675 6e63 7469 6f6e 2822   = no_function("
+00006140: 6375 626f 6964 2229 3b0a 0a0a 0a2f 2f20  cuboid");....// 
+00006150: 4675 6e63 7469 6f6e 264d 6f64 756c 653a  Function&Module:
+00006160: 2070 7269 736d 6f69 6428 290a 2f2f 2053   prismoid().// S
+00006170: 796e 6f70 7369 733a 2043 7265 6174 6573  ynopsis: Creates
+00006180: 2061 2072 6563 7461 6e67 756c 6172 2070   a rectangular p
+00006190: 7269 736d 6f69 6420 7368 6170 6520 7769  rismoid shape wi
+000061a0: 7468 206f 7074 696f 6e61 6c20 726f 756e  th optional roun
+000061b0: 646f 7665 7273 2061 6e64 2063 6861 6d66  dovers and chamf
+000061c0: 6572 696e 672c 206f 7220 7265 7475 726e  ering, or return
+000061d0: 7320 6120 766e 662e 0a2f 2f20 546f 7069  s a vnf..// Topi
+000061e0: 6373 3a20 5368 6170 6573 2028 3344 292c  cs: Shapes (3D),
+000061f0: 2041 7474 6163 6861 626c 652c 2056 4e46   Attachable, VNF
+00006200: 2047 656e 6572 6174 6f72 730a 2f2f 2053   Generators.// S
+00006210: 6565 2041 6c73 6f3a 2063 7562 6f69 6428  ee Also: cuboid(
+00006220: 292c 2072 6f75 6e64 6564 5f70 7269 736d  ), rounded_prism
+00006230: 2829 2c20 7472 6170 657a 6f69 6428 290a  (), trapezoid().
+00006240: 2f2f 2055 7361 6765 3a20 0a2f 2f20 2020  // Usage: .//   
+00006250: 7072 6973 6d6f 6964 2873 697a 6531 2c20  prismoid(size1, 
+00006260: 7369 7a65 322c 205b 687c 6c7c 6865 6967  size2, [h|l|heig
+00006270: 6874 7c6c 656e 6774 685d 2c20 5b73 6869  ht|length], [shi
+00006280: 6674 5d2c 205b 7861 6e67 3d5d 2c20 5b79  ft], [xang=], [y
+00006290: 616e 673d 5d2c 202e 2e2e 2920 5b41 5454  ang=], ...) [ATT
+000062a0: 4143 484d 454e 5453 5d3b 0a2f 2f20 5573  ACHMENTS];.// Us
+000062b0: 6167 653a 2043 6861 6d66 6572 6564 2061  age: Chamfered a
+000062c0: 6e64 2f6f 7220 526f 756e 6465 6420 5072  nd/or Rounded Pr
+000062d0: 6973 6d6f 6964 730a 2f2f 2020 2070 7269  ismoids.//   pri
+000062e0: 736d 6f69 6428 7369 7a65 312c 2073 697a  smoid(size1, siz
+000062f0: 6532 2c20 687c 6c7c 6865 6967 6874 7c6c  e2, h|l|height|l
+00006300: 656e 6774 682c 205b 6368 616d 6665 723d  ength, [chamfer=
+00006310: 5d2c 205b 726f 756e 6469 6e67 3d5d 2e2e  ], [rounding=]..
+00006320: 2e29 205b 4154 5441 4348 4d45 4e54 535d  .) [ATTACHMENTS]
+00006330: 3b0a 2f2f 2020 2070 7269 736d 6f69 6428  ;.//   prismoid(
+00006340: 7369 7a65 312c 2073 697a 6532 2c20 687c  size1, size2, h|
+00006350: 6c7c 6865 6967 6874 7c6c 656e 6774 682c  l|height|length,
+00006360: 205b 6368 616d 6665 7231 3d5d 2c20 5b63   [chamfer1=], [c
+00006370: 6861 6d66 6572 323d 5d2c 205b 726f 756e  hamfer2=], [roun
+00006380: 6469 6e67 313d 5d2c 205b 726f 756e 6469  ding1=], [roundi
+00006390: 6e67 323d 5d2c 202e 2e2e 2920 5b41 5454  ng2=], ...) [ATT
+000063a0: 4143 484d 454e 5453 5d3b 0a2f 2f20 5573  ACHMENTS];.// Us
+000063b0: 6167 653a 2041 7320 4675 6e63 7469 6f6e  age: As Function
+000063c0: 0a2f 2f20 2020 766e 6620 3d20 7072 6973  .//   vnf = pris
+000063d0: 6d6f 6964 282e 2e2e 293b 0a2f 2f20 4465  moid(...);.// De
+000063e0: 7363 7269 7074 696f 6e3a 0a2f 2f20 2020  scription:.//   
+000063f0: 4372 6561 7465 7320 6120 7265 6374 616e  Creates a rectan
+00006400: 6775 6c61 7220 7072 6973 6d6f 6964 2073  gular prismoid s
+00006410: 6861 7065 2077 6974 6820 6f70 7469 6f6e  hape with option
+00006420: 616c 2072 6f75 6e64 6f76 6572 7320 616e  al roundovers an
+00006430: 6420 6368 616d 6665 7269 6e67 2e0a 2f2f  d chamfering..//
+00006440: 2020 2059 6f75 2063 616e 206f 6e6c 7920     You can only 
+00006450: 726f 756e 6420 6f72 2063 6861 6d66 6572  round or chamfer
+00006460: 2074 6865 2076 6572 7469 6361 6c28 6973   the vertical(is
+00006470: 6829 2065 6467 6573 2e20 2046 6f72 2074  h) edges.  For t
+00006480: 686f 7365 2065 6467 6573 2c20 796f 7520  hose edges, you 
+00006490: 6361 6e0a 2f2f 2020 2073 7065 6369 6679  can.//   specify
+000064a0: 2072 6f75 6e64 696e 6720 616e 642f 6f72   rounding and/or
+000064b0: 2063 6861 6d66 6572 7269 6e67 2070 6572   chamferring per
+000064c0: 2d65 6467 652c 2061 6e64 2066 6f72 2074  -edge, and for t
+000064d0: 6f70 2061 6e64 2062 6f74 746f 6d20 7365  op and bottom se
+000064e0: 7061 7261 7465 6c79 2e0a 2f2f 2020 2049  parately..//   I
+000064f0: 6620 796f 7520 7761 6e74 2074 6f20 726f  f you want to ro
+00006500: 756e 6420 7468 6520 626f 7474 6f6d 206f  und the bottom o
+00006510: 7220 746f 7020 6564 6765 7320 7365 6520  r top edges see 
+00006520: 7b7b 726f 756e 6465 645f 7072 6973 6d28  {{rounded_prism(
+00006530: 297d 7d2e 0a2f 2f20 2020 2e0a 2f2f 2020  )}}..//   ..//  
+00006540: 2053 7065 6369 6669 6361 7469 6f6e 206f   Specification o
+00006550: 6620 7468 6520 7072 6973 6d6f 6964 2069  f the prismoid i
+00006560: 7320 7369 6d69 6c61 7220 746f 2073 7065  s similar to spe
+00006570: 6369 6669 6361 7469 6f6e 2066 6f72 207b  cification for {
+00006580: 7b74 7261 7065 7a6f 6964 2829 7d7d 2e20  {trapezoid()}}. 
+00006590: 2059 6f75 2063 616e 2073 7065 6369 6679   You can specify
+000065a0: 2074 6865 2064 696d 656e 7369 6f6e 7320   the dimensions 
+000065b0: 6f66 2074 6865 0a2f 2f20 2020 626f 7474  of the.//   bott
+000065c0: 6f6d 2061 6e64 2074 6f70 2061 6e64 2069  om and top and i
+000065d0: 7473 2068 6569 6768 7420 746f 2067 6574  ts height to get
+000065e0: 2061 2073 796d 6d65 7472 6963 2070 7269   a symmetric pri
+000065f0: 736d 6f69 642e 2020 596f 7520 6361 6e20  smoid.  You can 
+00006600: 7573 6520 7468 6520 7368 6966 7420 6172  use the shift ar
+00006610: 6775 6d65 6e74 2074 6f20 7368 6966 7420  gument to shift 
+00006620: 7468 6520 746f 7020 6661 6365 2061 726f  the top face aro
+00006630: 756e 642e 0a2f 2f20 2020 596f 7520 6361  und..//   You ca
+00006640: 6e20 616c 736f 2073 7065 6369 6679 2062  n also specify b
+00006650: 6173 6520 616e 676c 6573 2065 6974 6865  ase angles eithe
+00006660: 7220 696e 2074 6865 2058 2064 6972 6563  r in the X direc
+00006670: 7469 6f6e 2c20 5920 6469 7265 6374 696f  tion, Y directio
+00006680: 6e20 6f72 2062 6f74 682e 2020 496e 206f  n or both.  In o
+00006690: 7264 6572 2074 6f20 6176 6f69 6420 6f76  rder to avoid ov
+000066a0: 6572 7370 6563 6966 6963 6174 696f 6e2c  erspecification,
+000066b0: 0a2f 2f20 2020 796f 7520 6d61 7920 6e65  .//   you may ne
+000066c0: 6564 2074 6f20 7370 6563 6966 7920 6120  ed to specify a 
+000066d0: 7061 7261 6d65 7465 7220 7375 6368 2061  parameter such a
+000066e0: 7320 7369 7a65 3220 6173 2061 206c 6973  s size2 as a lis
+000066f0: 7420 6f66 2074 776f 2076 616c 7565 732c  t of two values,
+00006700: 206f 6e65 206f 6620 7768 6963 6820 6973   one of which is
+00006710: 2075 6e64 6566 2e20 2046 6f72 2065 7861   undef.  For exa
+00006720: 6d70 6c65 2c0a 2f2f 2020 2073 7065 6369  mple,.//   speci
+00006730: 6679 696e 6720 6073 697a 6532 3d5b 3130  fying `size2=[10
+00006740: 302c 756e 6465 665d 6020 7365 7473 2074  0,undef]` sets t
+00006750: 6865 2073 697a 6520 696e 2074 6865 2058  he size in the X
+00006760: 2064 6972 6563 7469 6f6e 2062 7574 2061   direction but a
+00006770: 6c6c 6f77 7320 7468 6520 7369 7a65 2069  llows the size i
+00006780: 6e20 7468 6520 5920 6469 7265 6374 696f  n the Y directio
+00006790: 6e20 746f 2062 6520 636f 6d70 7574 6564  n to be computed
+000067a0: 2062 6173 6564 206f 6e20 7961 6e67 2e0a   based on yang..
+000067b0: 2f2f 2041 7267 756d 656e 7473 3a0a 2f2f  // Arguments:.//
+000067c0: 2020 2073 697a 6531 203d 205b 7769 6474     size1 = [widt
+000067d0: 682c 206c 656e 6774 685d 206f 6620 7468  h, length] of th
+000067e0: 6520 626f 7474 6f6d 2065 6e64 206f 6620  e bottom end of 
+000067f0: 7468 6520 7072 6973 6d2e 0a2f 2f20 2020  the prism..//   
+00006800: 7369 7a65 3220 3d20 5b77 6964 7468 2c20  size2 = [width, 
+00006810: 6c65 6e67 7468 5d20 6f66 2074 6865 2074  length] of the t
+00006820: 6f70 2065 6e64 206f 6620 7468 6520 7072  op end of the pr
+00006830: 6973 6d2e 0a2f 2f20 2020 682f 6c2f 6865  ism..//   h/l/he
+00006840: 6967 6874 2f6c 656e 6774 6820 3d20 4865  ight/length = He
+00006850: 6967 6874 206f 6620 7468 6520 7072 6973  ight of the pris
+00006860: 6d2e 0a2f 2f20 2020 7368 6966 7420 3d20  m..//   shift = 
+00006870: 5b58 2c59 5d20 616d 6f75 6e74 2074 6f20  [X,Y] amount to 
+00006880: 7368 6966 7420 7468 6520 6365 6e74 6572  shift the center
+00006890: 206f 6620 7468 6520 746f 7020 656e 6420   of the top end 
+000068a0: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
+000068b0: 7468 6520 6365 6e74 6572 206f 6620 7468  the center of th
+000068c0: 6520 626f 7474 6f6d 2065 6e64 2e0a 2f2f  e bottom end..//
+000068d0: 2020 202d 2d2d 0a2f 2f20 2020 7861 6e67     ---.//   xang
+000068e0: 203d 2062 6173 6520 616e 676c 6520 696e   = base angle in
+000068f0: 2074 6865 2058 2064 6972 6563 7469 6f6e   the X direction
+00006900: 2e20 2043 616e 2062 6520 6120 7363 616c  .  Can be a scal
+00006910: 6172 206f 7220 6c69 7374 206f 6620 7477  ar or list of tw
+00006920: 6f20 7661 6c75 6573 2c20 6f6e 6520 6f66  o values, one of
+00006930: 2077 6869 6368 206d 6179 2062 6520 756e   which may be un
+00006940: 6465 660a 2f2f 2020 2079 616e 6720 3d20  def.//   yang = 
+00006950: 6261 7365 2061 6e67 6c65 2069 6e20 7468  base angle in th
+00006960: 6520 5920 6469 7265 6374 696f 6e2e 2020  e Y direction.  
+00006970: 4361 6e20 6265 2061 2073 6361 6c61 7220  Can be a scalar 
+00006980: 6f72 206c 6973 7420 6f66 2074 776f 2076  or list of two v
+00006990: 616c 7565 732c 206f 6e65 206f 6620 7768  alues, one of wh
+000069a0: 6963 6820 6d61 7920 6265 2075 6e64 6566  ich may be undef
+000069b0: 0a2f 2f20 2020 726f 756e 6469 6e67 203d  .//   rounding =
+000069c0: 2054 6865 2072 6f75 6e64 6f76 6572 2072   The roundover r
+000069d0: 6164 6975 7320 666f 7220 7468 6520 7665  adius for the ve
+000069e0: 7274 6963 616c 2d69 7368 2065 6467 6573  rtical-ish edges
+000069f0: 206f 6620 7468 6520 7072 6973 6d6f 6964   of the prismoid
+00006a00: 2e20 2049 6620 6769 7665 6e20 6173 2061  .  If given as a
+00006a10: 206c 6973 7420 6f66 2066 6f75 7220 6e75   list of four nu
+00006a20: 6d62 6572 732c 2067 6976 6573 2069 6e64  mbers, gives ind
+00006a30: 6976 6964 7561 6c20 7261 6469 6920 666f  ividual radii fo
+00006a40: 7220 6561 6368 2063 6f72 6e65 722c 2069  r each corner, i
+00006a50: 6e20 7468 6520 6f72 6465 7220 5b58 2b59  n the order [X+Y
+00006a60: 2b2c 582d 592b 2c58 2d59 2d2c 582b 592d  +,X-Y+,X-Y-,X+Y-
+00006a70: 5d2e 2044 6566 6175 6c74 3a20 3020 286e  ]. Default: 0 (n
+00006a80: 6f20 726f 756e 6469 6e67 290a 2f2f 2020  o rounding).//  
+00006a90: 2072 6f75 6e64 696e 6731 203d 2054 6865   rounding1 = The
+00006aa0: 2072 6f75 6e64 6f76 6572 2072 6164 6975   roundover radiu
+00006ab0: 7320 666f 7220 7468 6520 626f 7474 6f6d  s for the bottom
+00006ac0: 206f 6620 7468 6520 7665 7274 6963 616c   of the vertical
+00006ad0: 2d69 7368 2065 6467 6573 206f 6620 7468  -ish edges of th
+00006ae0: 6520 7072 6973 6d6f 6964 2e20 2049 6620  e prismoid.  If 
+00006af0: 6769 7665 6e20 6173 2061 206c 6973 7420  given as a list 
+00006b00: 6f66 2066 6f75 7220 6e75 6d62 6572 732c  of four numbers,
+00006b10: 2067 6976 6573 2069 6e64 6976 6964 7561   gives individua
+00006b20: 6c20 7261 6469 6920 666f 7220 6561 6368  l radii for each
+00006b30: 2063 6f72 6e65 722c 2069 6e20 7468 6520   corner, in the 
+00006b40: 6f72 6465 7220 5b58 2b59 2b2c 582d 592b  order [X+Y+,X-Y+
+00006b50: 2c58 2d59 2d2c 582b 592d 5d2e 0a2f 2f20  ,X-Y-,X+Y-]..// 
+00006b60: 2020 726f 756e 6469 6e67 3220 3d20 5468    rounding2 = Th
+00006b70: 6520 726f 756e 646f 7665 7220 7261 6469  e roundover radi
+00006b80: 7573 2066 6f72 2074 6865 2074 6f70 206f  us for the top o
+00006b90: 6620 7468 6520 7665 7274 6963 616c 2d69  f the vertical-i
+00006ba0: 7368 2065 6467 6573 206f 6620 7468 6520  sh edges of the 
+00006bb0: 7072 6973 6d6f 6964 2e20 2049 6620 6769  prismoid.  If gi
+00006bc0: 7665 6e20 6173 2061 206c 6973 7420 6f66  ven as a list of
+00006bd0: 2066 6f75 7220 6e75 6d62 6572 732c 2067   four numbers, g
+00006be0: 6976 6573 2069 6e64 6976 6964 7561 6c20  ives individual 
+00006bf0: 7261 6469 6920 666f 7220 6561 6368 2063  radii for each c
+00006c00: 6f72 6e65 722c 2069 6e20 7468 6520 6f72  orner, in the or
+00006c10: 6465 7220 5b58 2b59 2b2c 582d 592b 2c58  der [X+Y+,X-Y+,X
+00006c20: 2d59 2d2c 582b 592d 5d2e 0a2f 2f20 2020  -Y-,X+Y-]..//   
+00006c30: 6368 616d 6665 7220 3d20 5468 6520 6368  chamfer = The ch
+00006c40: 616d 6665 7220 7369 7a65 2066 6f72 2074  amfer size for t
+00006c50: 6865 2076 6572 7469 6361 6c2d 6973 6820  he vertical-ish 
+00006c60: 6564 6765 7320 6f66 2074 6865 2070 7269  edges of the pri
+00006c70: 736d 6f69 642e 2020 4966 2067 6976 656e  smoid.  If given
+00006c80: 2061 7320 6120 6c69 7374 206f 6620 666f   as a list of fo
+00006c90: 7572 206e 756d 6265 7273 2c20 6769 7665  ur numbers, give
+00006ca0: 7320 696e 6469 7669 6475 616c 2063 6861  s individual cha
+00006cb0: 6d66 6572 7320 666f 7220 6561 6368 2063  mfers for each c
+00006cc0: 6f72 6e65 722c 2069 6e20 7468 6520 6f72  orner, in the or
+00006cd0: 6465 7220 5b58 2b59 2b2c 582d 592b 2c58  der [X+Y+,X-Y+,X
+00006ce0: 2d59 2d2c 582b 592d 5d2e 2020 4465 6661  -Y-,X+Y-].  Defa
+00006cf0: 756c 743a 2030 2028 6e6f 2063 6861 6d66  ult: 0 (no chamf
+00006d00: 6572 290a 2f2f 2020 2063 6861 6d66 6572  er).//   chamfer
+00006d10: 3120 3d20 5468 6520 6368 616d 6665 7220  1 = The chamfer 
+00006d20: 7369 7a65 2066 6f72 2074 6865 2062 6f74  size for the bot
+00006d30: 746f 6d20 6f66 2074 6865 2076 6572 7469  tom of the verti
+00006d40: 6361 6c2d 6973 6820 6564 6765 7320 6f66  cal-ish edges of
+00006d50: 2074 6865 2070 7269 736d 6f69 642e 2020   the prismoid.  
+00006d60: 4966 2067 6976 656e 2061 7320 6120 6c69  If given as a li
+00006d70: 7374 206f 6620 666f 7572 206e 756d 6265  st of four numbe
+00006d80: 7273 2c20 6769 7665 7320 696e 6469 7669  rs, gives indivi
+00006d90: 6475 616c 2063 6861 6d66 6572 7320 666f  dual chamfers fo
+00006da0: 7220 6561 6368 2063 6f72 6e65 722c 2069  r each corner, i
+00006db0: 6e20 7468 6520 6f72 6465 7220 5b58 2b59  n the order [X+Y
+00006dc0: 2b2c 582d 592b 2c58 2d59 2d2c 582b 592d  +,X-Y+,X-Y-,X+Y-
+00006dd0: 5d2e 0a2f 2f20 2020 6368 616d 6665 7232  ]..//   chamfer2
+00006de0: 203d 2054 6865 2063 6861 6d66 6572 2073   = The chamfer s
+00006df0: 697a 6520 666f 7220 7468 6520 746f 7020  ize for the top 
+00006e00: 6f66 2074 6865 2076 6572 7469 6361 6c2d  of the vertical-
+00006e10: 6973 6820 6564 6765 7320 6f66 2074 6865  ish edges of the
+00006e20: 2070 7269 736d 6f69 642e 2020 4966 2067   prismoid.  If g
+00006e30: 6976 656e 2061 7320 6120 6c69 7374 206f  iven as a list o
+00006e40: 6620 666f 7572 206e 756d 6265 7273 2c20  f four numbers, 
+00006e50: 6769 7665 7320 696e 6469 7669 6475 616c  gives individual
+00006e60: 2063 6861 6d66 6572 7320 666f 7220 6561   chamfers for ea
+00006e70: 6368 2063 6f72 6e65 722c 2069 6e20 7468  ch corner, in th
+00006e80: 6520 6f72 6465 7220 5b58 2b59 2b2c 582d  e order [X+Y+,X-
+00006e90: 592b 2c58 2d59 2d2c 582b 592d 5d2e 0a2f  Y+,X-Y-,X+Y-]../
+00006ea0: 2f20 2020 616e 6368 6f72 203d 2054 7261  /   anchor = Tra
+00006eb0: 6e73 6c61 7465 2073 6f20 616e 6368 6f72  nslate so anchor
+00006ec0: 2070 6f69 6e74 2069 7320 6174 206f 7269   point is at ori
+00006ed0: 6769 6e20 2830 2c30 2c30 292e 2020 5365  gin (0,0,0).  Se
+00006ee0: 6520 5b61 6e63 686f 725d 2861 7474 6163  e [anchor](attac
+00006ef0: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+00006f00: 6563 7469 6f6e 2d61 6e63 686f 7229 2e20  ection-anchor). 
+00006f10: 2044 6566 6175 6c74 3a20 6043 454e 5445   Default: `CENTE
+00006f20: 5260 0a2f 2f20 2020 7370 696e 203d 2052  R`.//   spin = R
+00006f30: 6f74 6174 6520 7468 6973 206d 616e 7920  otate this many 
+00006f40: 6465 6772 6565 7320 6172 6f75 6e64 2074  degrees around t
+00006f50: 6865 205a 2061 7869 7320 6166 7465 7220  he Z axis after 
+00006f60: 616e 6368 6f72 2e20 2053 6565 205b 7370  anchor.  See [sp
+00006f70: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
+00006f80: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
+00006f90: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
+00006fa0: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
+00006fb0: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
+00006fc0: 6174 6520 746f 7020 746f 7761 7264 732c  ate top towards,
+00006fd0: 2061 6674 6572 2073 7069 6e2e 2020 5365   after spin.  Se
+00006fe0: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
+00006ff0: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+00007000: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
+00007010: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
+00007020: 2f0a 2f2f 2045 7861 6d70 6c65 3a20 5472  /.// Example: Tr
+00007030: 756e 6361 7465 6420 5079 7261 6d69 640a  uncated Pyramid.
+00007040: 2f2f 2020 2070 7269 736d 6f69 6428 7369  //   prismoid(si
+00007050: 7a65 313d 5b33 352c 3530 5d2c 2073 697a  ze1=[35,50], siz
+00007060: 6532 3d5b 3230 2c33 305d 2c20 683d 3230  e2=[20,30], h=20
+00007070: 293b 0a2f 2f20 4578 616d 706c 653a 2052  );.// Example: R
+00007080: 6563 7461 6e67 756c 6172 2050 7972 616d  ectangular Pyram
+00007090: 6964 0a2f 2f20 2020 7072 6973 6d6f 6964  id.//   prismoid
+000070a0: 285b 3430 2c34 305d 2c20 5b30 2c30 5d2c  ([40,40], [0,0],
+000070b0: 2068 3d32 3029 3b0a 2f2f 2045 7861 6d70   h=20);.// Examp
+000070c0: 6c65 3a20 5072 6973 6d0a 2f2f 2020 2070  le: Prism.//   p
+000070d0: 7269 736d 6f69 6428 7369 7a65 313d 5b34  rismoid(size1=[4
+000070e0: 302c 3430 5d2c 2073 697a 6532 3d5b 302c  0,40], size2=[0,
+000070f0: 3430 5d2c 2068 3d32 3029 3b0a 2f2f 2045  40], h=20);.// E
+00007100: 7861 6d70 6c65 3a20 5765 6467 650a 2f2f  xample: Wedge.//
+00007110: 2020 2070 7269 736d 6f69 6428 7369 7a65     prismoid(size
+00007120: 313d 5b36 302c 3335 5d2c 2073 697a 6532  1=[60,35], size2
+00007130: 3d5b 3330 2c30 5d2c 2068 3d33 3029 3b0a  =[30,0], h=30);.
+00007140: 2f2f 2045 7861 6d70 6c65 3a20 5472 756e  // Example: Trun
+00007150: 6361 7465 6420 5465 7472 6168 6564 726f  cated Tetrahedro
+00007160: 6e0a 2f2f 2020 2070 7269 736d 6f69 6428  n.//   prismoid(
+00007170: 7369 7a65 313d 5b31 302c 3430 5d2c 2073  size1=[10,40], s
+00007180: 697a 6532 3d5b 3430 2c31 305d 2c20 683d  ize2=[40,10], h=
+00007190: 3430 293b 0a2f 2f20 4578 616d 706c 653a  40);.// Example:
+000071a0: 2049 6e76 6572 7465 6420 5472 756e 6361   Inverted Trunca
+000071b0: 7465 6420 5079 7261 6d69 640a 2f2f 2020  ted Pyramid.//  
+000071c0: 2070 7269 736d 6f69 6428 7369 7a65 313d   prismoid(size1=
+000071d0: 5b31 352c 355d 2c20 7369 7a65 323d 5b33  [15,5], size2=[3
+000071e0: 302c 3230 5d2c 2068 3d32 3029 3b0a 2f2f  0,20], h=20);.//
+000071f0: 2045 7861 6d70 6c65 3a20 5269 6768 7420   Example: Right 
+00007200: 5072 6973 6d0a 2f2f 2020 2070 7269 736d  Prism.//   prism
+00007210: 6f69 6428 7369 7a65 313d 5b33 302c 3630  oid(size1=[30,60
+00007220: 5d2c 2073 697a 6532 3d5b 302c 3630 5d2c  ], size2=[0,60],
+00007230: 2073 6869 6674 3d5b 2d31 352c 305d 2c20   shift=[-15,0], 
+00007240: 683d 3330 293b 0a2f 2f20 4578 616d 706c  h=30);.// Exampl
+00007250: 6528 466c 6174 5370 696e 2c56 5044 3d31  e(FlatSpin,VPD=1
+00007260: 3630 2c56 5054 3d5b 302c 302c 3130 5d29  60,VPT=[0,0,10])
+00007270: 3a20 5368 6966 7469 6e67 2f53 6b65 7769  : Shifting/Skewi
+00007280: 6e67 0a2f 2f20 2020 7072 6973 6d6f 6964  ng.//   prismoid
+00007290: 2873 697a 6531 3d5b 3530 2c33 305d 2c20  (size1=[50,30], 
+000072a0: 7369 7a65 323d 5b32 302c 3230 5d2c 2068  size2=[20,20], h
+000072b0: 3d32 302c 2073 6869 6674 3d5b 3135 2c35  =20, shift=[15,5
+000072c0: 5d29 3b0a 2f2f 2045 7861 6d70 6c65 3a20  ]);.// Example: 
+000072d0: 5370 6563 6966 7969 6e67 2062 6f74 746f  Specifying botto
+000072e0: 6d2c 2068 6569 6768 7420 616e 6420 616e  m, height and an
+000072f0: 676c 650a 2f2f 2020 2070 7269 736d 6f69  gle.//   prismoi
+00007300: 6428 7369 7a65 313d 5b31 3030 2c37 355d  d(size1=[100,75]
+00007310: 2c20 683d 3330 2c20 7861 6e67 3d35 302c  , h=30, xang=50,
+00007320: 2079 616e 673d 3730 293b 0a2f 2f20 4578   yang=70);.// Ex
+00007330: 616d 706c 653a 2053 7065 6369 6679 696e  ample: Specifyin
+00007340: 6720 746f 702c 2068 6569 6768 7420 616e  g top, height an
+00007350: 6420 616e 676c 652c 2077 6974 6820 6173  d angle, with as
+00007360: 796d 6d65 7472 6963 2061 6e67 6c65 730a  ymmetric angles.
+00007370: 2f2f 2020 2070 7269 736d 6f69 6428 7369  //   prismoid(si
+00007380: 7a65 323d 5b31 3030 2c37 355d 2c20 683d  ze2=[100,75], h=
+00007390: 3330 2c20 7861 6e67 3d5b 3530 2c36 305d  30, xang=[50,60]
+000073a0: 2c20 7961 6e67 3d5b 3730 2c34 305d 293b  , yang=[70,40]);
+000073b0: 0a2f 2f20 4578 616d 706c 653a 2053 7065  .// Example: Spe
+000073c0: 6369 6679 696e 6720 746f 702c 2062 6f74  cifying top, bot
+000073d0: 746f 6d20 616e 6420 616e 676c 6520 666f  tom and angle fo
+000073e0: 7220 5820 616e 6420 7573 696e 6720 7468  r X and using th
+000073f0: 6174 2074 6f20 6465 6669 6e65 2068 6569  at to define hei
+00007400: 6768 742e 2020 4e6f 7465 2074 6861 7420  ght.  Note that 
+00007410: 6769 7669 6e67 2079 616e 6720 6865 7265  giving yang here
+00007420: 2077 6f75 6c64 206c 696b 656c 7920 6769   would likely gi
+00007430: 7665 2061 2063 6f6e 666c 6963 7469 6e67  ve a conflicting
+00007440: 2068 6569 6768 7420 6361 6c63 756c 6174   height calculat
+00007450: 696f 6e2c 2077 6869 6368 2069 7320 6e6f  ion, which is no
+00007460: 7420 616c 6c6f 7765 642e 2020 0a2f 2f20  t allowed.  .// 
+00007470: 2020 7072 6973 6d6f 6964 2873 697a 6531    prismoid(size1
+00007480: 3d5b 3130 302c 3735 5d2c 2073 697a 6532  =[100,75], size2
+00007490: 3d5b 3735 2c33 355d 2c20 7861 6e67 3d35  =[75,35], xang=5
+000074a0: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
+000074b0: 5468 6520 7361 6d65 2061 7320 7468 6520  The same as the 
+000074c0: 7072 6576 696f 7573 2065 7861 6d70 6c65  previous example
+000074d0: 2062 7574 2077 6520 6769 7665 2061 2073   but we give a s
+000074e0: 6869 6674 2069 6e20 592e 2020 4e6f 7465  hift in Y.  Note
+000074f0: 2074 6861 7420 7368 6966 742e 7820 6d75   that shift.x mu
+00007500: 7374 2062 6520 756e 6465 6620 6265 6361  st be undef beca
+00007510: 7573 6520 796f 7520 6361 6e6e 6f74 2067  use you cannot g
+00007520: 6976 6520 636f 6d62 696e 6520 616e 2061  ive combine an a
+00007530: 6e67 6c65 2077 6974 6820 6120 7368 6966  ngle with a shif
+00007540: 742c 2073 6f20 6120 7368 6966 742e 7820  t, so a shift.x 
+00007550: 7661 6c75 6520 776f 756c 6420 636f 6e66  value would conf
+00007560: 6c69 6374 2077 6974 6820 7861 6e67 2062  lict with xang b
+00007570: 6569 6e67 2064 6566 696e 6564 2e20 200a  eing defined.  .
+00007580: 2f2f 2020 2070 7269 736d 6f69 6428 7369  //   prismoid(si
+00007590: 7a65 313d 5b31 3030 2c37 355d 2c20 7369  ze1=[100,75], si
+000075a0: 7a65 323d 5b37 352c 3335 5d2c 2078 616e  ze2=[75,35], xan
+000075b0: 673d 3530 2c20 7368 6966 743d 5b75 6e64  g=50, shift=[und
+000075c0: 6566 2c32 305d 293b 0a2f 2f20 4578 616d  ef,20]);.// Exam
+000075d0: 706c 653a 2020 5468 6520 5820 6469 6d65  ple:  The X dime
+000075e0: 6e73 696f 6e73 2064 6566 696e 6564 2062  nsions defined b
+000075f0: 7920 7468 6520 6261 7365 206c 656e 6774  y the base lengt
+00007600: 682c 2061 6e67 6c65 2061 6e64 2068 6569  h, angle and hei
+00007610: 6768 743b 2074 6865 2059 2064 696d 656e  ght; the Y dimen
+00007620: 7369 6f6e 7320 6465 6669 6e65 6420 6279  sions defined by
+00007630: 2074 6865 2074 6f70 206c 656e 6774 682c   the top length,
+00007640: 2061 6e67 6c65 2c20 616e 6420 6865 6967   angle, and heig
+00007650: 6874 2e20 0a2f 2f20 2020 7072 6973 6d6f  ht. .//   prismo
+00007660: 6964 2873 697a 6531 3d5b 3130 302c 756e  id(size1=[100,un
+00007670: 6465 665d 2c20 7369 7a65 323d 5b75 6e64  def], size2=[und
+00007680: 6566 2c37 355d 2c20 683d 3330 2c20 7861  ef,75], h=30, xa
+00007690: 6e67 3d5b 3230 2c39 305d 2c20 7961 6e67  ng=[20,90], yang
+000076a0: 3d33 3029 3b0a 2f2f 2045 7861 6d70 6c65  =30);.// Example
+000076b0: 3a20 526f 756e 6469 6e67 0a2f 2f20 2020  : Rounding.//   
+000076c0: 7072 6973 6d6f 6964 2831 3030 2c20 3830  prismoid(100, 80
+000076d0: 2c20 726f 756e 6469 6e67 3d31 302c 2068  , rounding=10, h
+000076e0: 3d33 3029 3b0a 2f2f 2045 7861 6d70 6c65  =30);.// Example
+000076f0: 3a20 4368 616d 6665 7273 0a2f 2f20 2020  : Chamfers.//   
+00007700: 7072 6973 6d6f 6964 2831 3030 2c20 3830  prismoid(100, 80
+00007710: 2c20 6368 616d 6665 723d 352c 2068 3d33  , chamfer=5, h=3
+00007720: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
+00007730: 4772 6164 6961 6e74 2052 6f75 6e64 696e  Gradiant Roundin
+00007740: 670a 2f2f 2020 2070 7269 736d 6f69 6428  g.//   prismoid(
+00007750: 3130 302c 2038 302c 2072 6f75 6e64 696e  100, 80, roundin
+00007760: 6731 3d31 302c 2072 6f75 6e64 696e 6732  g1=10, rounding2
+00007770: 3d30 2c20 683d 3330 293b 0a2f 2f20 4578  =0, h=30);.// Ex
+00007780: 616d 706c 653a 2050 6572 2043 6f72 6e65  ample: Per Corne
+00007790: 7220 526f 756e 6469 6e67 0a2f 2f20 2020  r Rounding.//   
+000077a0: 7072 6973 6d6f 6964 2831 3030 2c20 3830  prismoid(100, 80
+000077b0: 2c20 726f 756e 6469 6e67 3d5b 302c 352c  , rounding=[0,5,
+000077c0: 3130 2c31 355d 2c20 683d 3330 293b 0a2f  10,15], h=30);./
+000077d0: 2f20 4578 616d 706c 653a 2050 6572 2043  / Example: Per C
+000077e0: 6f72 6e65 7220 4368 616d 6665 720a 2f2f  orner Chamfer.//
+000077f0: 2020 2070 7269 736d 6f69 6428 3130 302c     prismoid(100,
+00007800: 2038 302c 2063 6861 6d66 6572 3d5b 302c   80, chamfer=[0,
+00007810: 352c 3130 2c31 355d 2c20 683d 3330 293b  5,10,15], h=30);
+00007820: 0a2f 2f20 4578 616d 706c 653a 204d 6978  .// Example: Mix
+00007830: 696e 6720 4368 616d 6665 7220 616e 6420  ing Chamfer and 
+00007840: 526f 756e 6469 6e67 0a2f 2f20 2020 7072  Rounding.//   pr
+00007850: 6973 6d6f 6964 280a 2f2f 2020 2020 2020  ismoid(.//      
+00007860: 2031 3030 2c20 3830 2c20 683d 3330 2c0a   100, 80, h=30,.
+00007870: 2f2f 2020 2020 2020 2063 6861 6d66 6572  //       chamfer
+00007880: 3d5b 302c 352c 302c 3130 5d2c 0a2f 2f20  =[0,5,0,10],.// 
+00007890: 2020 2020 2020 726f 756e 6469 6e67 3d5b        rounding=[
+000078a0: 352c 302c 3130 2c30 5d0a 2f2f 2020 2029  5,0,10,0].//   )
+000078b0: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 5265  ;.// Example: Re
+000078c0: 616c 6c79 204d 6978 696e 6720 4974 2055  ally Mixing It U
+000078d0: 700a 2f2f 2020 2070 7269 736d 6f69 6428  p.//   prismoid(
+000078e0: 0a2f 2f20 2020 2020 2020 7369 7a65 313d  .//       size1=
+000078f0: 5b31 3030 2c38 305d 2c20 7369 7a65 323d  [100,80], size2=
+00007900: 5b38 302c 3630 5d2c 2068 3d32 302c 0a2f  [80,60], h=20,./
+00007910: 2f20 2020 2020 2020 6368 616d 6665 7231  /       chamfer1
+00007920: 3d5b 302c 352c 302c 3130 5d2c 2063 6861  =[0,5,0,10], cha
+00007930: 6d66 6572 323d 5b35 2c30 2c31 302c 305d  mfer2=[5,0,10,0]
+00007940: 2c0a 2f2f 2020 2020 2020 2072 6f75 6e64  ,.//       round
+00007950: 696e 6731 3d5b 352c 302c 3130 2c30 5d2c  ing1=[5,0,10,0],
+00007960: 2072 6f75 6e64 696e 6732 3d5b 302c 352c   rounding2=[0,5,
+00007970: 302c 3130 5d0a 2f2f 2020 2029 3b0a 2f2f  0,10].//   );.//
+00007980: 2045 7861 6d70 6c65 2853 7069 6e2c 5650   Example(Spin,VP
+00007990: 443d 3136 302c 5650 543d 5b30 2c30 2c31  D=160,VPT=[0,0,1
+000079a0: 305d 293a 2053 7461 6e64 6172 6420 436f  0]): Standard Co
+000079b0: 6e6e 6563 746f 7273 0a2f 2f20 2020 7072  nnectors.//   pr
+000079c0: 6973 6d6f 6964 2873 697a 6531 3d5b 3530  ismoid(size1=[50
+000079d0: 2c33 305d 2c20 7369 7a65 323d 5b32 302c  ,30], size2=[20,
+000079e0: 3230 5d2c 2068 3d32 302c 2073 6869 6674  20], h=20, shift
+000079f0: 3d5b 3135 2c35 5d29 0a2f 2f20 2020 2020  =[15,5]).//     
+00007a00: 2020 7368 6f77 5f61 6e63 686f 7273 2829    show_anchors()
+00007a10: 3b0a 0a6d 6f64 756c 6520 7072 6973 6d6f  ;..module prismo
+00007a20: 6964 280a 2020 2020 7369 7a65 313d 756e  id(.    size1=un
+00007a30: 6465 662c 2073 697a 6532 3d75 6e64 6566  def, size2=undef
+00007a40: 2c20 682c 2073 6869 6674 3d5b 756e 6465  , h, shift=[unde
+00007a50: 662c 756e 6465 665d 2c0a 2020 2020 7861  f,undef],.    xa
+00007a60: 6e67 2c20 7961 6e67 2c0a 2020 2020 726f  ng, yang,.    ro
+00007a70: 756e 6469 6e67 3d30 2c20 726f 756e 6469  unding=0, roundi
+00007a80: 6e67 312c 2072 6f75 6e64 696e 6732 2c0a  ng1, rounding2,.
+00007a90: 2020 2020 6368 616d 6665 723d 302c 2063      chamfer=0, c
+00007aa0: 6861 6d66 6572 312c 2063 6861 6d66 6572  hamfer1, chamfer
+00007ab0: 322c 0a20 2020 206c 2c20 6865 6967 6874  2,.    l, height
+00007ac0: 2c20 6c65 6e67 7468 2c20 6365 6e74 6572  , length, center
+00007ad0: 2c0a 2020 2020 616e 6368 6f72 2c20 7370  ,.    anchor, sp
+00007ae0: 696e 3d30 2c20 6f72 6965 6e74 3d55 500a  in=0, orient=UP.
+00007af0: 290a 7b0a 2020 2020 766e 665f 7331 5f73  ).{.    vnf_s1_s
+00007b00: 325f 7368 6966 7420 3d20 7072 6973 6d6f  2_shift = prismo
+00007b10: 6964 280a 2020 2020 2020 2020 7369 7a65  id(.        size
+00007b20: 313d 7369 7a65 312c 2073 697a 6532 3d73  1=size1, size2=s
+00007b30: 697a 6532 2c20 683d 682c 2073 6869 6674  ize2, h=h, shift
+00007b40: 3d73 6869 6674 2c0a 2020 2020 2020 2020  =shift,.        
+00007b50: 7861 6e67 3d78 616e 672c 2079 616e 673d  xang=xang, yang=
+00007b60: 7961 6e67 2c20 0a20 2020 2020 2020 2072  yang, .        r
+00007b70: 6f75 6e64 696e 673d 726f 756e 6469 6e67  ounding=rounding
+00007b80: 2c20 6368 616d 6665 723d 6368 616d 6665  , chamfer=chamfe
+00007b90: 722c 200a 2020 2020 2020 2020 726f 756e  r, .        roun
+00007ba0: 6469 6e67 313d 726f 756e 6469 6e67 312c  ding1=rounding1,
+00007bb0: 2072 6f75 6e64 696e 6732 3d72 6f75 6e64   rounding2=round
+00007bc0: 696e 6732 2c0a 2020 2020 2020 2020 6368  ing2,.        ch
+00007bd0: 616d 6665 7231 3d63 6861 6d66 6572 312c  amfer1=chamfer1,
+00007be0: 2063 6861 6d66 6572 323d 6368 616d 6665   chamfer2=chamfe
+00007bf0: 7232 2c0a 2020 2020 2020 2020 6c3d 6c2c  r2,.        l=l,
+00007c00: 2068 6569 6768 743d 6865 6967 6874 2c20   height=height, 
+00007c10: 6c65 6e67 7468 3d6c 656e 6774 682c 2061  length=length, a
+00007c20: 6e63 686f 723d 424f 542c 205f 7265 7475  nchor=BOT, _retu
+00007c30: 726e 5f64 696d 3d74 7275 650a 2020 2020  rn_dim=true.    
+00007c40: 293b 0a20 2020 2061 6e63 686f 7220 3d20  );.    anchor = 
+00007c50: 6765 745f 616e 6368 6f72 2861 6e63 686f  get_anchor(ancho
+00007c60: 722c 2063 656e 7465 722c 2042 4f54 2c20  r, center, BOT, 
+00007c70: 424f 5429 3b0a 2020 2020 6174 7461 6368  BOT);.    attach
+00007c80: 6162 6c65 2861 6e63 686f 722c 7370 696e  able(anchor,spin
+00007c90: 2c6f 7269 656e 742c 2073 697a 653d 766e  ,orient, size=vn
+00007ca0: 665f 7331 5f73 325f 7368 6966 745b 315d  f_s1_s2_shift[1]
+00007cb0: 2c20 7369 7a65 323d 766e 665f 7331 5f73  , size2=vnf_s1_s
+00007cc0: 325f 7368 6966 745b 325d 2c20 7368 6966  2_shift[2], shif
+00007cd0: 743d 766e 665f 7331 5f73 325f 7368 6966  t=vnf_s1_s2_shif
+00007ce0: 745b 335d 2920 7b0a 2020 2020 2020 2020  t[3]) {.        
+00007cf0: 646f 776e 2876 6e66 5f73 315f 7332 5f73  down(vnf_s1_s2_s
+00007d00: 6869 6674 5b31 5d2e 7a2f 3229 0a20 2020  hift[1].z/2).   
+00007d10: 2020 2020 2020 2020 2076 6e66 5f70 6f6c           vnf_pol
+00007d20: 7968 6564 726f 6e28 766e 665f 7331 5f73  yhedron(vnf_s1_s
+00007d30: 325f 7368 6966 745b 305d 2c20 636f 6e76  2_shift[0], conv
+00007d40: 6578 6974 793d 3429 3b0a 2020 2020 2020  exity=4);.      
+00007d50: 2020 6368 696c 6472 656e 2829 3b0a 2020    children();.  
+00007d60: 2020 7d0a 7d0a 0a66 756e 6374 696f 6e20    }.}..function 
+00007d70: 7072 6973 6d6f 6964 280a 2020 2020 7369  prismoid(.    si
+00007d80: 7a65 312c 2073 697a 6532 2c20 682c 2073  ze1, size2, h, s
+00007d90: 6869 6674 3d5b 302c 305d 2c0a 2020 2020  hift=[0,0],.    
+00007da0: 726f 756e 6469 6e67 3d30 2c20 726f 756e  rounding=0, roun
+00007db0: 6469 6e67 312c 2072 6f75 6e64 696e 6732  ding1, rounding2
+00007dc0: 2c0a 2020 2020 6368 616d 6665 723d 302c  ,.    chamfer=0,
+00007dd0: 2063 6861 6d66 6572 312c 2063 6861 6d66   chamfer1, chamf
+00007de0: 6572 322c 0a20 2020 206c 2c20 6865 6967  er2,.    l, heig
+00007df0: 6874 2c20 6c65 6e67 7468 2c20 6365 6e74  ht, length, cent
+00007e00: 6572 2c0a 2020 2020 616e 6368 6f72 3d44  er,.    anchor=D
+00007e10: 4f57 4e2c 2073 7069 6e3d 302c 206f 7269  OWN, spin=0, ori
+00007e20: 656e 743d 5550 2c20 7861 6e67 2c20 7961  ent=UP, xang, ya
+00007e30: 6e67 2c0a 2020 2020 5f72 6574 7572 6e5f  ng,.    _return_
+00007e40: 6469 6d3d 6661 6c73 650a 2020 2020 0a29  dim=false.    .)
+00007e50: 203d 0a20 2020 2061 7373 6572 7428 6973   =.    assert(is
+00007e60: 5f75 6e64 6566 2873 6869 6674 2920 7c7c  _undef(shift) ||
+00007e70: 2069 735f 6e75 6d28 7368 6966 7429 207c   is_num(shift) |
+00007e80: 7c20 6c65 6e28 7368 6966 7429 3d3d 322c  | len(shift)==2,
+00007e90: 2022 7368 6966 7420 6d75 7374 2062 6520   "shift must be 
+00007ea0: 6120 6e75 6d62 6572 206f 7220 6c69 7374  a number or list
+00007eb0: 206f 6620 6c65 6e67 7468 2032 2229 0a20   of length 2"). 
+00007ec0: 2020 2061 7373 6572 7428 6973 5f75 6e64     assert(is_und
+00007ed0: 6566 2873 697a 6531 2920 7c7c 2069 735f  ef(size1) || is_
+00007ee0: 6e75 6d28 7369 7a65 3129 207c 7c20 6c65  num(size1) || le
+00007ef0: 6e28 7369 7a65 3129 3d3d 322c 2022 7369  n(size1)==2, "si
+00007f00: 7a65 3120 6d75 7374 2062 6520 6120 6e75  ze1 must be a nu
+00007f10: 6d62 6572 206f 7220 6c69 7374 206f 6620  mber or list of 
+00007f20: 6c65 6e67 7468 2032 2229 0a20 2020 2061  length 2").    a
+00007f30: 7373 6572 7428 6973 5f75 6e64 6566 2873  ssert(is_undef(s
+00007f40: 697a 6532 2920 7c7c 2069 735f 6e75 6d28  ize2) || is_num(
+00007f50: 7369 7a65 3229 207c 7c20 6c65 6e28 7369  size2) || len(si
+00007f60: 7a65 3229 3d3d 322c 2022 7369 7a65 3220  ze2)==2, "size2 
+00007f70: 6d75 7374 2062 6520 6120 6e75 6d62 6572  must be a number
+00007f80: 206f 7220 6c69 7374 206f 6620 6c65 6e67   or list of leng
+00007f90: 7468 2032 2229 2020 0a20 2020 206c 6574  th 2")  .    let
+00007fa0: 280a 2020 2020 2020 2020 7861 6e67 203d  (.        xang =
+00007fb0: 2066 6f72 6365 5f6c 6973 7428 7861 6e67   force_list(xang
+00007fc0: 2c32 292c 0a20 2020 2020 2020 2079 616e  ,2),.        yan
+00007fd0: 6720 3d20 666f 7263 655f 6c69 7374 2879  g = force_list(y
+00007fe0: 616e 672c 3229 2c0a 2020 2020 2020 2020  ang,2),.        
+00007ff0: 7961 6e67 4f4b 203d 206c 656e 2879 616e  yangOK = len(yan
+00008000: 6729 3d3d 3220 2626 2028 7961 6e67 3d3d  g)==2 && (yang==
+00008010: 5b75 6e64 6566 2c75 6e64 6566 5d20 7c7c  [undef,undef] ||
+00008020: 2028 616c 6c5f 706f 7369 7469 7665 2879   (all_positive(y
+00008030: 616e 6729 2026 2620 7961 6e67 5b30 5d3c  ang) && yang[0]<
+00008040: 3138 3020 2626 2079 616e 675b 315d 3c31  180 && yang[1]<1
+00008050: 3830 2929 2c0a 2020 2020 2020 2020 7861  80)),.        xa
+00008060: 6e67 4f4b 203d 206c 656e 2878 616e 6729  ngOK = len(xang)
+00008070: 3d3d 3220 2626 2028 7861 6e67 3d3d 5b75  ==2 && (xang==[u
+00008080: 6e64 6566 2c75 6e64 6566 5d20 7c7c 2028  ndef,undef] || (
+00008090: 616c 6c5f 706f 7369 7469 7665 2878 616e  all_positive(xan
+000080a0: 6729 2026 2620 7861 6e67 5b30 5d3c 3138  g) && xang[0]<18
+000080b0: 3020 2626 2078 616e 675b 315d 3c31 3830  0 && xang[1]<180
+000080c0: 2929 2c0a 2020 2020 2020 2020 7369 7a65  )),.        size
+000080d0: 313d 666f 7263 655f 6c69 7374 2873 697a  1=force_list(siz
+000080e0: 6531 2c32 292c 0a20 2020 2020 2020 2073  e1,2),.        s
+000080f0: 697a 6532 3d66 6f72 6365 5f6c 6973 7428  ize2=force_list(
+00008100: 7369 7a65 322c 3229 2c0a 2020 2020 2020  size2,2),.      
+00008110: 2020 683d 6669 7273 745f 6465 6669 6e65    h=first_define
+00008120: 6428 5b6c 2c68 2c6c 656e 6774 682c 6865  d([l,h,length,he
+00008130: 6967 6874 5d29 2c0a 2020 2020 2020 2020  ight]),.        
+00008140: 7368 6966 7420 3d20 666f 7263 655f 6c69  shift = force_li
+00008150: 7374 2873 6869 6674 2c32 290a 2020 2020  st(shift,2).    
+00008160: 290a 2020 2020 6173 7365 7274 2878 616e  ).    assert(xan
+00008170: 674f 4b2c 2022 7072 6973 6d6f 6964 2061  gOK, "prismoid a
+00008180: 6e67 6c65 7320 6d75 7374 2062 6520 7363  ngles must be sc
+00008190: 616c 6172 206f 7220 322d 7665 6374 6f72  alar or 2-vector
+000081a0: 2c20 7374 7269 6374 6c79 2062 6574 7765  , strictly betwe
+000081b0: 656e 2030 2061 6e64 2031 3830 2229 0a20  en 0 and 180"). 
+000081c0: 2020 2061 7373 6572 7428 7961 6e67 4f4b     assert(yangOK
+000081d0: 2c20 2270 7269 736d 6f69 6420 616e 676c  , "prismoid angl
+000081e0: 6573 206d 7573 7420 6265 2073 6361 6c61  es must be scala
+000081f0: 7220 6f72 2032 2d76 6563 746f 722c 2073  r or 2-vector, s
+00008200: 7472 6963 746c 7920 6265 7477 6565 6e20  trictly between 
+00008210: 3020 616e 6420 3138 3022 290a 2020 2020  0 and 180").    
+00008220: 6173 7365 7274 2878 616e 673d 3d5b 756e  assert(xang==[un
+00008230: 6465 662c 756e 6465 665d 207c 7c20 7368  def,undef] || sh
+00008240: 6966 742e 783d 3d75 6e64 6566 2c20 2243  ift.x==undef, "C
+00008250: 616e 6e6f 7420 7370 6563 6966 7920 7861  annot specify xa
+00008260: 6e67 2061 6e64 2061 2073 6869 6674 2e78  ng and a shift.x
+00008270: 2076 616c 7565 2074 6f67 6574 6865 7222   value together"
+00008280: 290a 2020 2020 6173 7365 7274 2879 616e  ).    assert(yan
+00008290: 673d 3d5b 756e 6465 662c 756e 6465 665d  g==[undef,undef]
+000082a0: 207c 7c20 7368 6966 742e 793d 3d75 6e64   || shift.y==und
+000082b0: 6566 2c20 2243 616e 6e6f 7420 7370 6563  ef, "Cannot spec
+000082c0: 6966 7920 7961 6e67 2061 6e64 2061 2073  ify yang and a s
+000082d0: 6869 6674 2e79 2076 616c 7565 2074 6f67  hift.y value tog
+000082e0: 6574 6865 7222 290a 2020 2020 6173 7365  ether").    asse
+000082f0: 7274 2861 6c6c 5f70 6f73 6974 6976 6528  rt(all_positive(
+00008300: 5b68 5d29 207c 7c20 6973 5f75 6e64 6566  [h]) || is_undef
+00008310: 2868 292c 2022 6820 6d75 7374 2062 6520  (h), "h must be 
+00008320: 6120 706f 7369 7469 7665 2076 616c 7565  a positive value
+00008330: 2229 0a20 2020 206c 6574 280a 2020 2020  ").    let(.    
+00008340: 2020 2020 6878 203d 205f 7472 6170 657a      hx = _trapez
+00008350: 6f69 645f 6469 6d73 2868 2c73 697a 6531  oid_dims(h,size1
+00008360: 2e78 2c73 697a 6532 2e78 2c73 6869 6674  .x,size2.x,shift
+00008370: 2e78 2c78 616e 6729 5b30 5d2c 0a20 2020  .x,xang)[0],.   
+00008380: 2020 2020 2068 7920 3d20 5f74 7261 7065       hy = _trape
+00008390: 7a6f 6964 5f64 696d 7328 682c 7369 7a65  zoid_dims(h,size
+000083a0: 312e 792c 7369 7a65 322e 792c 7368 6966  1.y,size2.y,shif
+000083b0: 742e 792c 7961 6e67 295b 305d 0a20 2020  t.y,yang)[0].   
+000083c0: 2029 0a20 2020 2061 7373 6572 7428 6e75   ).    assert(nu
+000083d0: 6d5f 6465 6669 6e65 6428 5b68 782c 6879  m_defined([hx,hy
+000083e0: 5d29 3e30 2c20 2248 6569 6768 7420 6e6f  ])>0, "Height no
+000083f0: 7420 6769 7665 6e20 616e 6420 7370 6563  t given and spec
+00008400: 6966 6963 6174 696f 6e20 646f 6573 206e  ification does n
+00008410: 6f74 2064 6574 6572 6d69 6e65 2070 7269  ot determine pri
+00008420: 736d 6f69 6420 6865 6967 6874 2229 0a20  smoid height"). 
+00008430: 2020 2061 7373 6572 7428 6878 3d3d 756e     assert(hx==un
+00008440: 6465 6620 7c7c 2068 793d 3d75 6e64 6566  def || hy==undef
+00008450: 207c 7c20 6170 7072 6f78 2868 782c 6879   || approx(hx,hy
+00008460: 292c 0a20 2020 2020 2020 2020 2020 7374  ),.           st
+00008470: 7228 2258 2061 6e64 2059 2061 6e67 6c65  r("X and Y angle
+00008480: 2073 7065 6369 6669 6361 7469 6f6e 7320   specifications 
+00008490: 6769 7665 2072 6973 6520 746f 2063 6f6e  give rise to con
+000084a0: 666c 6963 7469 6e67 2068 6569 6768 7420  flicting height 
+000084b0: 7661 6c75 6573 2022 2c68 782c 2220 616e  values ",hx," an
+000084c0: 6420 222c 6879 2929 0a20 2020 206c 6574  d ",hy)).    let
+000084d0: 280a 2020 2020 2020 2020 6820 3d20 6669  (.        h = fi
+000084e0: 7273 745f 6465 6669 6e65 6428 5b68 782c  rst_defined([hx,
+000084f0: 6879 5d29 2c0a 2020 2020 2020 2020 785f  hy]),.        x_
+00008500: 685f 7731 5f77 325f 7368 6966 7420 3d20  h_w1_w2_shift = 
+00008510: 5f74 7261 7065 7a6f 6964 5f64 696d 7328  _trapezoid_dims(
+00008520: 682c 7369 7a65 312e 782c 7369 7a65 322e  h,size1.x,size2.
+00008530: 782c 7368 6966 742e 782c 7861 6e67 292c  x,shift.x,xang),
+00008540: 0a20 2020 2020 2020 2079 5f68 5f77 315f  .        y_h_w1_
+00008550: 7732 5f73 6869 6674 203d 205f 7472 6170  w2_shift = _trap
+00008560: 657a 6f69 645f 6469 6d73 2868 2c73 697a  ezoid_dims(h,siz
+00008570: 6531 2e79 2c73 697a 6532 2e79 2c73 6869  e1.y,size2.y,shi
+00008580: 6674 2e79 2c79 616e 6729 0a20 2020 2029  ft.y,yang).    )
+00008590: 0a20 2020 206c 6574 280a 2020 2020 2020  .    let(.      
+000085a0: 2020 7331 203d 205b 785f 685f 7731 5f77    s1 = [x_h_w1_w
+000085b0: 325f 7368 6966 745b 315d 2c20 795f 685f  2_shift[1], y_h_
+000085c0: 7731 5f77 325f 7368 6966 745b 315d 5d2c  w1_w2_shift[1]],
+000085d0: 0a20 2020 2020 2020 2073 3220 3d20 5b78  .        s2 = [x
+000085e0: 5f68 5f77 315f 7732 5f73 6869 6674 5b32  _h_w1_w2_shift[2
+000085f0: 5d2c 2079 5f68 5f77 315f 7732 5f73 6869  ], y_h_w1_w2_shi
+00008600: 6674 5b32 5d5d 2c0a 2020 2020 2020 2020  ft[2]],.        
+00008610: 7368 6966 7420 3d20 5b78 5f68 5f77 315f  shift = [x_h_w1_
+00008620: 7732 5f73 6869 6674 5b33 5d2c 2079 5f68  w2_shift[3], y_h
+00008630: 5f77 315f 7732 5f73 6869 6674 5b33 5d5d  _w1_w2_shift[3]]
+00008640: 0a20 2020 2029 0a20 2020 2061 7373 6572  .    ).    asser
+00008650: 7428 6973 5f76 6563 746f 7228 7331 2c32  t(is_vector(s1,2
+00008660: 292c 2022 496e 7375 6666 6963 6965 6e74  ), "Insufficient
+00008670: 2069 6e66 6f72 6d61 7469 6f6e 2074 6f20   information to 
+00008680: 6465 6669 6e65 2070 7269 736d 6f69 6422  define prismoid"
+00008690: 290a 2020 2020 6173 7365 7274 2869 735f  ).    assert(is_
+000086a0: 7665 6374 6f72 2873 322c 3229 2c20 2249  vector(s2,2), "I
+000086b0: 6e73 7566 6669 6369 656e 7420 696e 666f  nsufficient info
+000086c0: 726d 6174 696f 6e20 746f 2064 6566 696e  rmation to defin
+000086d0: 6520 7072 6973 6d6f 6964 2229 0a20 2020  e prismoid").   
+000086e0: 2061 7373 6572 7428 616c 6c5f 6e6f 6e6e   assert(all_nonn
+000086f0: 6567 6174 6976 6528 636f 6e63 6174 2873  egative(concat(s
+00008700: 312c 7332 2929 2c22 4465 6765 6e65 7261  1,s2)),"Degenera
+00008710: 7465 2070 7269 736d 6f69 6420 6765 6f6d  te prismoid geom
+00008720: 6574 7279 2229 0a20 2020 2061 7373 6572  etry").    asser
+00008730: 7428 7331 2e78 2b73 322e 783e 3020 2626  t(s1.x+s2.x>0 &&
+00008740: 2073 312e 792b 7332 2e79 3e30 2c20 2244   s1.y+s2.y>0, "D
+00008750: 6567 656e 6572 6174 6520 7072 6973 6d6f  egenerate prismo
+00008760: 6964 2067 656f 6d65 7472 7922 290a 2020  id geometry").  
+00008770: 2020 6173 7365 7274 2869 735f 6e75 6d28    assert(is_num(
+00008780: 726f 756e 6469 6e67 2920 7c7c 2069 735f  rounding) || is_
+00008790: 7665 6374 6f72 2872 6f75 6e64 696e 672c  vector(rounding,
+000087a0: 3429 2c20 2272 6f75 6e64 696e 6720 6d75  4), "rounding mu
+000087b0: 7374 2062 6520 6120 6e75 6d62 6572 206f  st be a number o
+000087c0: 7220 342d 7665 6374 6f72 2229 0a20 2020  r 4-vector").   
+000087d0: 2061 7373 6572 7428 6973 5f75 6e64 6566   assert(is_undef
+000087e0: 2872 6f75 6e64 696e 6731 2920 7c7c 2069  (rounding1) || i
+000087f0: 735f 6e75 6d28 726f 756e 6469 6e67 3129  s_num(rounding1)
+00008800: 207c 7c20 6973 5f76 6563 746f 7228 726f   || is_vector(ro
+00008810: 756e 6469 6e67 312c 3429 2c20 2272 6f75  unding1,4), "rou
+00008820: 6e64 696e 6731 206d 7573 7420 6265 2061  nding1 must be a
+00008830: 206e 756d 6265 7220 6f72 2034 2d76 6563   number or 4-vec
+00008840: 746f 7222 290a 2020 2020 6173 7365 7274  tor").    assert
+00008850: 2869 735f 756e 6465 6628 726f 756e 6469  (is_undef(roundi
+00008860: 6e67 3229 207c 7c20 6973 5f6e 756d 2872  ng2) || is_num(r
+00008870: 6f75 6e64 696e 6732 2920 7c7c 2069 735f  ounding2) || is_
+00008880: 7665 6374 6f72 2872 6f75 6e64 696e 6732  vector(rounding2
+00008890: 2c34 292c 2022 726f 756e 6469 6e67 3220  ,4), "rounding2 
+000088a0: 6d75 7374 2062 6520 6120 6e75 6d62 6572  must be a number
+000088b0: 206f 7220 342d 7665 6374 6f72 2229 0a20   or 4-vector"). 
+000088c0: 2020 2061 7373 6572 7428 6973 5f6e 756d     assert(is_num
+000088d0: 2863 6861 6d66 6572 2920 7c7c 2069 735f  (chamfer) || is_
+000088e0: 7665 6374 6f72 2863 6861 6d66 6572 2c34  vector(chamfer,4
+000088f0: 292c 2022 6368 616d 6665 7220 6d75 7374  ), "chamfer must
+00008900: 2062 6520 6120 6e75 6d62 6572 206f 7220   be a number or 
+00008910: 342d 7665 6374 6f72 2229 0a20 2020 2061  4-vector").    a
+00008920: 7373 6572 7428 6973 5f75 6e64 6566 2863  ssert(is_undef(c
+00008930: 6861 6d66 6572 3129 207c 7c20 6973 5f6e  hamfer1) || is_n
+00008940: 756d 2863 6861 6d66 6572 3129 207c 7c20  um(chamfer1) || 
+00008950: 6973 5f76 6563 746f 7228 6368 616d 6665  is_vector(chamfe
+00008960: 7231 2c34 292c 2022 6368 616d 6665 7231  r1,4), "chamfer1
+00008970: 206d 7573 7420 6265 2061 206e 756d 6265   must be a numbe
+00008980: 7220 6f72 2034 2d76 6563 746f 7222 290a  r or 4-vector").
+00008990: 2020 2020 6173 7365 7274 2869 735f 756e      assert(is_un
+000089a0: 6465 6628 6368 616d 6665 7232 2920 7c7c  def(chamfer2) ||
+000089b0: 2069 735f 6e75 6d28 6368 616d 6665 7232   is_num(chamfer2
+000089c0: 2920 7c7c 2069 735f 7665 6374 6f72 2863  ) || is_vector(c
+000089d0: 6861 6d66 6572 322c 3429 2c20 2263 6861  hamfer2,4), "cha
+000089e0: 6d66 6572 3220 6d75 7374 2062 6520 6120  mfer2 must be a 
+000089f0: 6e75 6d62 6572 206f 7220 342d 7665 6374  number or 4-vect
+00008a00: 6f72 2229 0a20 2020 206c 6574 280a 2020  or").    let(.  
+00008a10: 2020 2020 2020 6368 616d 6665 7231 3d66        chamfer1=f
+00008a20: 6f72 6365 5f6c 6973 7428 6465 6661 756c  orce_list(defaul
+00008a30: 7428 6368 616d 6665 7231 2c63 6861 6d66  t(chamfer1,chamf
+00008a40: 6572 292c 3429 2c0a 2020 2020 2020 2020  er),4),.        
+00008a50: 6368 616d 6665 7232 3d66 6f72 6365 5f6c  chamfer2=force_l
+00008a60: 6973 7428 6465 6661 756c 7428 6368 616d  ist(default(cham
+00008a70: 6665 7232 2c63 6861 6d66 6572 292c 3429  fer2,chamfer),4)
+00008a80: 2c0a 2020 2020 2020 2020 726f 756e 6469  ,.        roundi
+00008a90: 6e67 313d 666f 7263 655f 6c69 7374 2864  ng1=force_list(d
+00008aa0: 6566 6175 6c74 2872 6f75 6e64 696e 6731  efault(rounding1
+00008ab0: 2c72 6f75 6e64 696e 6729 2c34 292c 0a20  ,rounding),4),. 
+00008ac0: 2020 2020 2020 2072 6f75 6e64 696e 6732         rounding2
+00008ad0: 3d66 6f72 6365 5f6c 6973 7428 6465 6661  =force_list(defa
+00008ae0: 756c 7428 726f 756e 6469 6e67 322c 726f  ult(rounding2,ro
+00008af0: 756e 6469 6e67 292c 3429 0a20 2020 2029  unding),4).    )
+00008b00: 0a20 2020 2061 7373 6572 7428 616c 6c5f  .    assert(all_
+00008b10: 6e6f 6e6e 6567 6174 6976 6528 6368 616d  nonnegative(cham
+00008b20: 6665 7231 292c 2022 6368 616d 6665 722f  fer1), "chamfer/
+00008b30: 6368 616d 6665 7231 206d 7573 7420 6265  chamfer1 must be
+00008b40: 206e 6f6e 2d6e 6567 6174 6976 6522 290a   non-negative").
+00008b50: 2020 2020 6173 7365 7274 2861 6c6c 5f6e      assert(all_n
+00008b60: 6f6e 6e65 6761 7469 7665 2863 6861 6d66  onnegative(chamf
+00008b70: 6572 3229 2c20 2263 6861 6d66 6572 2f63  er2), "chamfer/c
+00008b80: 6861 6d66 6572 3220 6d75 7374 2062 6520  hamfer2 must be 
+00008b90: 6e6f 6e2d 6e65 6761 7469 7665 2229 0a20  non-negative"). 
+00008ba0: 2020 2061 7373 6572 7428 616c 6c5f 6e6f     assert(all_no
+00008bb0: 6e6e 6567 6174 6976 6528 726f 756e 6469  nnegative(roundi
+00008bc0: 6e67 3129 2c20 2272 6f75 6e64 696e 672f  ng1), "rounding/
+00008bd0: 726f 756e 6469 6e67 3120 6d75 7374 2062  rounding1 must b
+00008be0: 6520 6e6f 6e2d 6e65 6761 7469 7665 2229  e non-negative")
+00008bf0: 0a20 2020 2061 7373 6572 7428 616c 6c5f  .    assert(all_
+00008c00: 6e6f 6e6e 6567 6174 6976 6528 726f 756e  nonnegative(roun
+00008c10: 6469 6e67 3229 2c20 2272 6f75 6e64 696e  ding2), "roundin
+00008c20: 672f 726f 756e 6469 6e67 3220 6d75 7374  g/rounding2 must
+00008c30: 2062 6520 6e6f 6e2d 6e65 6761 7469 7665   be non-negative
+00008c40: 2229 2020 2020 2020 2020 0a20 2020 2061  ")        .    a
+00008c50: 7373 6572 7428 616c 6c5f 7a65 726f 2876  ssert(all_zero(v
+00008c60: 5f6d 756c 2872 6f75 6e64 696e 6731 2c63  _mul(rounding1,c
+00008c70: 6861 6d66 6572 3129 2c30 292c 0a20 2020  hamfer1),0),.   
+00008c80: 2020 2020 2020 2020 2272 6f75 6e64 696e          "roundin
+00008c90: 6731 2061 6e64 2063 6861 6d66 6572 3120  g1 and chamfer1 
+00008ca0: 2870 6f73 7369 626c 7920 696e 6865 7269  (possibly inheri
+00008cb0: 7465 6420 6672 6f6d 2072 6f75 6e64 696e  ted from roundin
+00008cc0: 6720 616e 6420 6368 616d 6665 7229 2063  g and chamfer) c
+00008cd0: 616e 6e6f 7420 626f 7468 2062 6520 6e6f  annot both be no
+00008ce0: 6e7a 6572 6f20 6174 2074 6865 2073 616d  nzero at the sam
+00008cf0: 6520 636f 726e 6572 2229 0a20 2020 2061  e corner").    a
+00008d00: 7373 6572 7428 616c 6c5f 7a65 726f 2876  ssert(all_zero(v
+00008d10: 5f6d 756c 2872 6f75 6e64 696e 6732 2c63  _mul(rounding2,c
+00008d20: 6861 6d66 6572 3229 2c30 292c 0a20 2020  hamfer2),0),.   
+00008d30: 2020 2020 2020 2020 2272 6f75 6e64 696e          "roundin
+00008d40: 6732 2061 6e64 2063 6861 6d66 6572 3220  g2 and chamfer2 
+00008d50: 2870 6f73 7369 626c 7920 696e 6865 7269  (possibly inheri
+00008d60: 7465 6420 6672 6f6d 2072 6f75 6e64 696e  ted from roundin
+00008d70: 6720 616e 6420 6368 616d 6665 7229 2063  g and chamfer) c
+00008d80: 616e 6e6f 7420 626f 7468 2062 6520 6e6f  annot both be no
+00008d90: 6e7a 6572 6f20 6174 2074 6865 2073 616d  nzero at the sam
+00008da0: 6520 636f 726e 6572 2229 0a20 2020 206c  e corner").    l
+00008db0: 6574 280a 2020 2020 2020 2020 726f 756e  et(.        roun
+00008dc0: 6469 6e67 3120 3d20 6465 6661 756c 7428  ding1 = default(
+00008dd0: 726f 756e 6469 6e67 312c 2072 6f75 6e64  rounding1, round
+00008de0: 696e 6729 2c0a 2020 2020 2020 2020 726f  ing),.        ro
+00008df0: 756e 6469 6e67 3220 3d20 6465 6661 756c  unding2 = defaul
+00008e00: 7428 726f 756e 6469 6e67 322c 2072 6f75  t(rounding2, rou
+00008e10: 6e64 696e 6729 2c0a 2020 2020 2020 2020  nding),.        
+00008e20: 6368 616d 6665 7231 203d 2064 6566 6175  chamfer1 = defau
+00008e30: 6c74 2863 6861 6d66 6572 312c 2063 6861  lt(chamfer1, cha
+00008e40: 6d66 6572 292c 0a20 2020 2020 2020 2063  mfer),.        c
+00008e50: 6861 6d66 6572 3220 3d20 6465 6661 756c  hamfer2 = defaul
+00008e60: 7428 6368 616d 6665 7232 2c20 6368 616d  t(chamfer2, cham
+00008e70: 6665 7229 2c0a 2020 2020 2020 2020 616e  fer),.        an
+00008e80: 6368 6f72 203d 2067 6574 5f61 6e63 686f  chor = get_ancho
+00008e90: 7228 616e 6368 6f72 2c20 6365 6e74 6572  r(anchor, center
+00008ea0: 2c20 424f 542c 2042 4f54 292c 0a20 2020  , BOT, BOT),.   
+00008eb0: 2020 2020 2070 6174 6831 203d 2072 6563       path1 = rec
+00008ec0: 7428 7331 2c20 726f 756e 6469 6e67 3d72  t(s1, rounding=r
+00008ed0: 6f75 6e64 696e 6731 2c20 6368 616d 6665  ounding1, chamfe
+00008ee0: 723d 6368 616d 6665 7231 2c20 616e 6368  r=chamfer1, anch
+00008ef0: 6f72 3d43 5452 292c 0a20 2020 2020 2020  or=CTR),.       
+00008f00: 2070 6174 6832 203d 2072 6563 7428 7332   path2 = rect(s2
+00008f10: 2c20 726f 756e 6469 6e67 3d72 6f75 6e64  , rounding=round
+00008f20: 696e 6732 2c20 6368 616d 6665 723d 6368  ing2, chamfer=ch
+00008f30: 616d 6665 7232 2c20 616e 6368 6f72 3d43  amfer2, anchor=C
+00008f40: 5452 292c 0a20 2020 2020 2020 2070 6f69  TR),.        poi
+00008f50: 6e74 7320 3d20 5b0a 2020 2020 2020 2020  nts = [.        
+00008f60: 2020 2020 2020 2020 2020 2020 6561 6368              each
+00008f70: 2070 6174 6833 6428 7061 7468 312c 202d   path3d(path1, -
+00008f80: 682f 3229 2c0a 2020 2020 2020 2020 2020  h/2),.          
+00008f90: 2020 2020 2020 2020 2020 6561 6368 2070            each p
+00008fa0: 6174 6833 6428 6d6f 7665 2873 6869 6674  ath3d(move(shift
+00008fb0: 2c20 7061 7468 3229 2c20 2b68 2f32 292c  , path2), +h/2),
+00008fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008fd0: 2020 5d2c 0a20 2020 2020 2020 2066 6163    ],.        fac
+00008fe0: 6573 203d 2068 756c 6c28 706f 696e 7473  es = hull(points
+00008ff0: 292c 0a20 2020 2020 2020 2076 6e66 203d  ),.        vnf =
+00009000: 205b 706f 696e 7473 2c20 6661 6365 735d   [points, faces]
+00009010: 0a20 2020 2029 0a20 2020 205f 7265 7475  .    ).    _retu
+00009020: 726e 5f64 696d 203f 205b 7265 6f72 6965  rn_dim ? [reorie
+00009030: 6e74 2861 6e63 686f 722c 7370 696e 2c6f  nt(anchor,spin,o
+00009040: 7269 656e 742c 2073 697a 653d 5b73 312e  rient, size=[s1.
+00009050: 782c 7331 2e79 2c68 5d2c 2073 697a 6532  x,s1.y,h], size2
+00009060: 3d73 322c 2073 6869 6674 3d73 6869 6674  =s2, shift=shift
+00009070: 2c20 703d 766e 6629 2c70 6f69 6e74 3364  , p=vnf),point3d
+00009080: 2873 312c 6829 2c73 322c 7368 6966 745d  (s1,h),s2,shift]
+00009090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000090a0: 203a 2072 656f 7269 656e 7428 616e 6368   : reorient(anch
+000090b0: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
+000090c0: 7369 7a65 3d5b 7331 2e78 2c73 312e 792c  size=[s1.x,s1.y,
+000090d0: 685d 2c20 7369 7a65 323d 7332 2c20 7368  h], size2=s2, sh
+000090e0: 6966 743d 7368 6966 742c 2070 3d76 6e66  ift=shift, p=vnf
+000090f0: 293b 0a0a 0a2f 2f20 4675 6e63 7469 6f6e  );...// Function
+00009100: 264d 6f64 756c 653a 206f 6374 6168 6564  &Module: octahed
+00009110: 726f 6e28 290a 2f2f 2053 796e 6f70 7369  ron().// Synopsi
+00009120: 733a 2043 7265 6174 6573 2061 6e20 6f63  s: Creates an oc
+00009130: 7461 6865 6472 6f6e 2077 6974 6820 6178  tahedron with ax
+00009140: 6973 2d61 6c69 676e 6564 2070 6f69 6e74  is-aligned point
+00009150: 732c 206f 7220 7265 7475 726e 7320 6120  s, or returns a 
+00009160: 766e 662e 0a2f 2f20 546f 7069 6373 3a20  vnf..// Topics: 
+00009170: 5368 6170 6573 2028 3344 292c 2041 7474  Shapes (3D), Att
+00009180: 6163 6861 626c 652c 2056 4e46 2047 656e  achable, VNF Gen
+00009190: 6572 6174 6f72 730a 2f2f 2053 6565 2041  erators.// See A
+000091a0: 6c73 6f3a 2070 7269 736d 6f69 6428 290a  lso: prismoid().
+000091b0: 2f2f 2055 7361 6765 3a20 4173 204d 6f64  // Usage: As Mod
+000091c0: 756c 650a 2f2f 2020 206f 6374 6168 6564  ule.//   octahed
+000091d0: 726f 6e28 7369 7a65 2c20 2e2e 2e29 205b  ron(size, ...) [
+000091e0: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
+000091f0: 2055 7361 6765 3a20 4173 2046 756e 6374   Usage: As Funct
+00009200: 696f 6e0a 2f2f 2020 2076 6e66 203d 206f  ion.//   vnf = o
+00009210: 6374 6168 6564 726f 6e28 7369 7a65 2c20  ctahedron(size, 
+00009220: 2e2e 2e29 3b0a 2f2f 2044 6573 6372 6970  ...);.// Descrip
+00009230: 7469 6f6e 3a0a 2f2f 2020 2057 6865 6e20  tion:.//   When 
+00009240: 6361 6c6c 6564 2061 7320 6120 6d6f 6475  called as a modu
+00009250: 6c65 2c20 6372 6561 7465 7320 616e 206f  le, creates an o
+00009260: 6374 6168 6564 726f 6e20 7769 7468 2061  ctahedron with a
+00009270: 7869 732d 616c 6967 6e65 6420 706f 696e  xis-aligned poin
+00009280: 7473 2e0a 2f2f 2020 2057 6865 6e20 6361  ts..//   When ca
+00009290: 6c6c 6564 2061 7320 6120 6675 6e63 7469  lled as a functi
+000092a0: 6f6e 2c20 6372 6561 7465 7320 6120 5b5b  on, creates a [[
+000092b0: 564e 467c 766e 662e 7363 6164 5d5d 206f  VNF|vnf.scad]] o
+000092c0: 6620 616e 206f 6374 6168 6564 726f 6e20  f an octahedron 
+000092d0: 7769 7468 2061 7869 732d 616c 6967 6e65  with axis-aligne
+000092e0: 6420 706f 696e 7473 2e0a 2f2f 2041 7267  d points..// Arg
+000092f0: 756d 656e 7473 3a0a 2f2f 2020 2073 697a  uments:.//   siz
+00009300: 6520 3d20 5769 6474 6820 6f66 2074 6865  e = Width of the
+00009310: 206f 6374 6168 6564 726f 6e2c 2074 6970   octahedron, tip
+00009320: 2074 6f20 7469 702e 0a2f 2f20 2020 2d2d   to tip..//   --
+00009330: 2d0a 2f2f 2020 2061 6e63 686f 7220 3d20  -.//   anchor = 
+00009340: 5472 616e 736c 6174 6520 736f 2061 6e63  Translate so anc
+00009350: 686f 7220 706f 696e 7420 6973 2061 7420  hor point is at 
+00009360: 6f72 6967 696e 2028 302c 302c 3029 2e20  origin (0,0,0). 
+00009370: 2053 6565 205b 616e 6368 6f72 5d28 6174   See [anchor](at
+00009380: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
+00009390: 7562 7365 6374 696f 6e2d 616e 6368 6f72  ubsection-anchor
+000093a0: 292e 2020 4465 6661 756c 743a 2060 4345  ).  Default: `CE
+000093b0: 4e54 4552 600a 2f2f 2020 2073 7069 6e20  NTER`.//   spin 
+000093c0: 3d20 526f 7461 7465 2074 6869 7320 6d61  = Rotate this ma
+000093d0: 6e79 2064 6567 7265 6573 2061 726f 756e  ny degrees aroun
+000093e0: 6420 7468 6520 5a20 6178 6973 2061 6674  d the Z axis aft
+000093f0: 6572 2061 6e63 686f 722e 2020 5365 6520  er anchor.  See 
+00009400: 5b73 7069 6e5d 2861 7474 6163 686d 656e  [spin](attachmen
+00009410: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
+00009420: 6f6e 2d73 7069 6e29 2e20 2044 6566 6175  on-spin).  Defau
+00009430: 6c74 3a20 6030 600a 2f2f 2020 206f 7269  lt: `0`.//   ori
+00009440: 656e 7420 3d20 5665 6374 6f72 2074 6f20  ent = Vector to 
+00009450: 726f 7461 7465 2074 6f70 2074 6f77 6172  rotate top towar
+00009460: 6473 2c20 6166 7465 7220 7370 696e 2e20  ds, after spin. 
+00009470: 2053 6565 205b 6f72 6965 6e74 5d28 6174   See [orient](at
+00009480: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
+00009490: 7562 7365 6374 696f 6e2d 6f72 6965 6e74  ubsection-orient
+000094a0: 292e 2020 4465 6661 756c 743a 2060 5550  ).  Default: `UP
+000094b0: 600a 2f2f 2045 7861 6d70 6c65 3a0a 2f2f  `.// Example:.//
+000094c0: 2020 206f 6374 6168 6564 726f 6e28 7369     octahedron(si
+000094d0: 7a65 3d34 3029 3b0a 2f2f 2045 7861 6d70  ze=40);.// Examp
+000094e0: 6c65 3a20 416e 6368 6f72 730a 2f2f 2020  le: Anchors.//  
+000094f0: 206f 6374 6168 6564 726f 6e28 7369 7a65   octahedron(size
+00009500: 3d34 3029 2073 686f 775f 616e 6368 6f72  =40) show_anchor
+00009510: 7328 293b 0a0a 6d6f 6475 6c65 206f 6374  s();..module oct
+00009520: 6168 6564 726f 6e28 7369 7a65 3d31 2c20  ahedron(size=1, 
+00009530: 616e 6368 6f72 3d43 454e 5445 522c 2073  anchor=CENTER, s
+00009540: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
+00009550: 2920 7b0a 2020 2020 766e 6620 3d20 6f63  ) {.    vnf = oc
+00009560: 7461 6865 6472 6f6e 2873 697a 653d 7369  tahedron(size=si
+00009570: 7a65 293b 0a20 2020 2061 7474 6163 6861  ze);.    attacha
+00009580: 626c 6528 616e 6368 6f72 2c73 7069 6e2c  ble(anchor,spin,
+00009590: 6f72 6965 6e74 2c20 766e 663d 766e 662c  orient, vnf=vnf,
+000095a0: 2065 7874 656e 743d 7472 7565 2920 7b0a   extent=true) {.
+000095b0: 2020 2020 2020 2020 766e 665f 706f 6c79          vnf_poly
+000095c0: 6865 6472 6f6e 2876 6e66 2c20 636f 6e76  hedron(vnf, conv
+000095d0: 6578 6974 793d 3229 3b0a 2020 2020 2020  exity=2);.      
+000095e0: 2020 6368 696c 6472 656e 2829 3b0a 2020    children();.  
+000095f0: 2020 7d0a 7d0a 0a66 756e 6374 696f 6e20    }.}..function 
+00009600: 6f63 7461 6865 6472 6f6e 2873 697a 653d  octahedron(size=
+00009610: 312c 2061 6e63 686f 723d 4345 4e54 4552  1, anchor=CENTER
+00009620: 2c20 7370 696e 3d30 2c20 6f72 6965 6e74  , spin=0, orient
+00009630: 3d55 5029 203d 0a20 2020 206c 6574 280a  =UP) =.    let(.
+00009640: 2020 2020 2020 2020 7369 7a65 203d 2073          size = s
+00009650: 6361 6c61 725f 7665 6333 2873 697a 6529  calar_vec3(size)
+00009660: 2c0a 2020 2020 2020 2020 7320 3d20 7369  ,.        s = si
+00009670: 7a65 2f32 2c0a 2020 2020 2020 2020 766e  ze/2,.        vn
+00009680: 6620 3d20 5b0a 2020 2020 2020 2020 2020  f = [.          
+00009690: 2020 5b20 5b30 2c30 2c73 2e7a 5d2c 205b    [ [0,0,s.z], [
+000096a0: 732e 782c 302c 305d 2c20 5b30 2c73 2e79  s.x,0,0], [0,s.y
+000096b0: 2c30 5d2c 205b 2d73 2e78 2c30 2c30 5d2c  ,0], [-s.x,0,0],
+000096c0: 205b 302c 2d73 2e79 2c30 5d2c 205b 302c   [0,-s.y,0], [0,
+000096d0: 302c 2d73 2e7a 5d20 5d2c 0a20 2020 2020  0,-s.z] ],.     
+000096e0: 2020 2020 2020 205b 205b 302c 322c 315d         [ [0,2,1]
+000096f0: 2c20 5b30 2c33 2c32 5d2c 205b 302c 342c  , [0,3,2], [0,4,
+00009700: 335d 2c20 5b30 2c31 2c34 5d2c 205b 352c  3], [0,1,4], [5,
+00009710: 312c 325d 2c20 5b35 2c32 2c33 5d2c 205b  1,2], [5,2,3], [
+00009720: 352c 332c 345d 2c20 5b35 2c34 2c31 5d20  5,3,4], [5,4,1] 
+00009730: 5d0a 2020 2020 2020 2020 5d0a 2020 2020  ].        ].    
+00009740: 2920 7265 6f72 6965 6e74 2861 6e63 686f  ) reorient(ancho
+00009750: 722c 7370 696e 2c6f 7269 656e 742c 2076  r,spin,orient, v
+00009760: 6e66 3d76 6e66 2c20 6578 7465 6e74 3d74  nf=vnf, extent=t
+00009770: 7275 652c 2070 3d76 6e66 293b 0a0a 0a2f  rue, p=vnf);.../
+00009780: 2f20 4d6f 6475 6c65 3a20 7265 6374 5f74  / Module: rect_t
+00009790: 7562 6528 290a 2f2f 2053 796e 6f70 7369  ube().// Synopsi
+000097a0: 733a 2043 7265 6174 6573 2061 2072 6563  s: Creates a rec
+000097b0: 7461 6e67 756c 6172 2074 7562 652c 206f  tangular tube, o
+000097c0: 7220 7265 7475 726e 7320 6120 766e 662e  r returns a vnf.
+000097d0: 0a2f 2f20 546f 7069 6373 3a20 5368 6170  .// Topics: Shap
+000097e0: 6573 2028 3344 292c 2041 7474 6163 6861  es (3D), Attacha
+000097f0: 626c 652c 2056 4e46 2047 656e 6572 6174  ble, VNF Generat
+00009800: 6f72 730a 2f2f 2053 6565 2041 6c73 6f3a  ors.// See Also:
+00009810: 2074 7562 6528 290a 2f2f 2055 7361 6765   tube().// Usage
+00009820: 3a20 5479 7069 6361 6c20 5265 6374 616e  : Typical Rectan
+00009830: 6775 6c61 7220 5475 6265 730a 2f2f 2020  gular Tubes.//  
+00009840: 2072 6563 745f 7475 6265 2868 2c20 7369   rect_tube(h, si
+00009850: 7a65 2c20 6973 697a 652c 205b 6365 6e74  ze, isize, [cent
+00009860: 6572 5d2c 205b 7368 6966 745d 293b 0a2f  er], [shift]);./
+00009870: 2f20 2020 7265 6374 5f74 7562 6528 682c  /   rect_tube(h,
+00009880: 2073 697a 652c 2077 616c 6c3d 2c20 5b63   size, wall=, [c
+00009890: 656e 7465 723d 5d29 3b0a 2f2f 2020 2072  enter=]);.//   r
+000098a0: 6563 745f 7475 6265 2868 2c20 6973 697a  ect_tube(h, isiz
+000098b0: 653d 2c20 7761 6c6c 3d2c 205b 6365 6e74  e=, wall=, [cent
+000098c0: 6572 3d5d 293b 0a2f 2f20 5573 6167 653a  er=]);.// Usage:
+000098d0: 2054 6170 6572 696e 6720 5265 6374 616e   Tapering Rectan
+000098e0: 6775 6c61 7220 5475 6265 730a 2f2f 2020  gular Tubes.//  
+000098f0: 2072 6563 745f 7475 6265 2868 2c20 7369   rect_tube(h, si
+00009900: 7a65 313d 2c20 7369 7a65 323d 2c20 7761  ze1=, size2=, wa
+00009910: 6c6c 3d2c 202e 2e2e 293b 0a2f 2f20 2020  ll=, ...);.//   
+00009920: 7265 6374 5f74 7562 6528 682c 2069 7369  rect_tube(h, isi
+00009930: 7a65 313d 2c20 6973 697a 6532 3d2c 2077  ze1=, isize2=, w
+00009940: 616c 6c3d 2c20 2e2e 2e29 3b0a 2f2f 2020  all=, ...);.//  
+00009950: 2072 6563 745f 7475 6265 2868 2c20 7369   rect_tube(h, si
+00009960: 7a65 313d 2c20 7369 7a65 323d 2c20 6973  ze1=, size2=, is
+00009970: 697a 6531 3d2c 2069 7369 7a65 323d 2c20  ize1=, isize2=, 
+00009980: 2e2e 2e29 3b0a 2f2f 2055 7361 6765 3a20  ...);.// Usage: 
+00009990: 4368 616d 6665 7265 640a 2f2f 2020 2072  Chamfered.//   r
+000099a0: 6563 745f 7475 6265 2868 2c20 7369 7a65  ect_tube(h, size
+000099b0: 2c20 6973 697a 652c 2063 6861 6d66 6572  , isize, chamfer
+000099c0: 3d2c 202e 2e2e 293b 0a2f 2f20 2020 7265  =, ...);.//   re
+000099d0: 6374 5f74 7562 6528 682c 2073 697a 652c  ct_tube(h, size,
+000099e0: 2069 7369 7a65 2c20 6368 616d 6665 7231   isize, chamfer1
+000099f0: 3d2c 2063 6861 6d66 6572 323d 202e 2e2e  =, chamfer2= ...
+00009a00: 293b 0a2f 2f20 2020 7265 6374 5f74 7562  );.//   rect_tub
+00009a10: 6528 682c 2073 697a 652c 2069 7369 7a65  e(h, size, isize
+00009a20: 2c20 6963 6861 6d66 6572 3d2c 202e 2e2e  , ichamfer=, ...
+00009a30: 293b 0a2f 2f20 2020 7265 6374 5f74 7562  );.//   rect_tub
+00009a40: 6528 682c 2073 697a 652c 2069 7369 7a65  e(h, size, isize
+00009a50: 2c20 6963 6861 6d66 6572 313d 2c20 6963  , ichamfer1=, ic
+00009a60: 6861 6d66 6572 323d 202e 2e2e 293b 0a2f  hamfer2= ...);./
+00009a70: 2f20 2020 7265 6374 5f74 7562 6528 682c  /   rect_tube(h,
+00009a80: 2073 697a 652c 2069 7369 7a65 2c20 6368   size, isize, ch
+00009a90: 616d 6665 723d 2c20 6963 6861 6d66 6572  amfer=, ichamfer
+00009aa0: 3d2c 202e 2e2e 293b 0a2f 2f20 5573 6167  =, ...);.// Usag
+00009ab0: 653a 2052 6f75 6e64 6564 0a2f 2f20 2020  e: Rounded.//   
+00009ac0: 7265 6374 5f74 7562 6528 682c 2073 697a  rect_tube(h, siz
+00009ad0: 652c 2069 7369 7a65 2c20 726f 756e 6469  e, isize, roundi
+00009ae0: 6e67 3d2c 202e 2e2e 293b 0a2f 2f20 2020  ng=, ...);.//   
+00009af0: 7265 6374 5f74 7562 6528 682c 2073 697a  rect_tube(h, siz
+00009b00: 652c 2069 7369 7a65 2c20 726f 756e 6469  e, isize, roundi
+00009b10: 6e67 313d 2c20 726f 756e 6469 6e67 323d  ng1=, rounding2=
+00009b20: 202e 2e2e 293b 0a2f 2f20 2020 7265 6374   ...);.//   rect
+00009b30: 5f74 7562 6528 682c 2073 697a 652c 2069  _tube(h, size, i
+00009b40: 7369 7a65 2c20 6972 6f75 6e64 696e 673d  size, irounding=
+00009b50: 2c20 2e2e 2e29 3b0a 2f2f 2020 2072 6563  , ...);.//   rec
+00009b60: 745f 7475 6265 2868 2c20 7369 7a65 2c20  t_tube(h, size, 
+00009b70: 6973 697a 652c 2069 726f 756e 6469 6e67  isize, irounding
+00009b80: 313d 2c20 6972 6f75 6e64 696e 6732 3d20  1=, irounding2= 
+00009b90: 2e2e 2e29 3b0a 2f2f 2020 2072 6563 745f  ...);.//   rect_
+00009ba0: 7475 6265 2868 2c20 7369 7a65 2c20 6973  tube(h, size, is
+00009bb0: 697a 652c 2072 6f75 6e64 696e 673d 2c20  ize, rounding=, 
+00009bc0: 6972 6f75 6e64 696e 673d 2c20 2e2e 2e29  irounding=, ...)
+00009bd0: 3b0a 2f2f 2055 7361 6765 3a20 4174 7461  ;.// Usage: Atta
+00009be0: 6368 696e 6720 4368 696c 6472 656e 0a2f  ching Children./
+00009bf0: 2f20 2020 7265 6374 5f74 7562 6528 2e2e  /   rect_tube(..
+00009c00: 2e29 2041 5454 4143 484d 454e 5453 3b0a  .) ATTACHMENTS;.
+00009c10: 2f2f 0a2f 2f20 4465 7363 7269 7074 696f  //.// Descriptio
+00009c20: 6e3a 0a2f 2f20 2020 4372 6561 7465 7320  n:.//   Creates 
+00009c30: 6120 7265 6374 616e 6775 6c61 7220 6f72  a rectangular or
+00009c40: 2070 7269 736d 6f69 6420 7475 6265 2077   prismoid tube w
+00009c50: 6974 6820 6f70 7469 6f6e 616c 2072 6f75  ith optional rou
+00009c60: 6e64 6f76 6572 7320 616e 642f 6f72 2063  ndovers and/or c
+00009c70: 6861 6d66 6572 732e 0a2f 2f20 2020 596f  hamfers..//   Yo
+00009c80: 7520 6361 6e20 6f6e 6c79 2072 6f75 6e64  u can only round
+00009c90: 206f 7220 6368 616d 6665 7220 7468 6520   or chamfer the 
+00009ca0: 7665 7274 6963 616c 2869 7368 2920 6564  vertical(ish) ed
+00009cb0: 6765 732e 2020 466f 7220 7468 6f73 6520  ges.  For those 
+00009cc0: 6564 6765 732c 2079 6f75 2063 616e 0a2f  edges, you can./
+00009cd0: 2f20 2020 7370 6563 6966 7920 726f 756e  /   specify roun
+00009ce0: 6469 6e67 2061 6e64 2f6f 7220 6368 616d  ding and/or cham
+00009cf0: 6665 7272 696e 6720 7065 722d 6564 6765  ferring per-edge
+00009d00: 2c20 616e 6420 666f 7220 746f 7020 616e  , and for top an
+00009d10: 6420 626f 7474 6f6d 2c20 696e 7369 6465  d bottom, inside
+00009d20: 2061 6e64 0a2f 2f20 2020 6f75 7473 6964   and.//   outsid
+00009d30: 6520 2073 6570 6172 6174 656c 792e 0a2f  e  separately../
+00009d40: 2f20 2020 2e0a 2f2f 2020 2042 7920 6465  /   ..//   By de
+00009d50: 6661 756c 7420 6966 2079 6f75 2073 7065  fault if you spe
+00009d60: 6369 6679 2061 2063 6861 6d66 6572 206f  cify a chamfer o
+00009d70: 7220 726f 756e 6469 6e67 2074 6865 6e20  r rounding then 
+00009d80: 6974 2061 7070 6c69 6573 2061 7320 7370  it applies as sp
+00009d90: 6563 6966 6965 6420 746f 2074 6865 0a2f  ecified to the./
+00009da0: 2f20 2020 6f75 7473 6964 652c 2061 6e64  /   outside, and
+00009db0: 2061 6e20 696e 7369 6465 2072 6f75 6e64   an inside round
+00009dc0: 696e 6720 6973 2063 616c 6375 6c61 7465  ing is calculate
+00009dd0: 6420 7468 6174 2077 696c 6c20 6d61 696e  d that will main
+00009de0: 7461 696e 2063 6f6e 7374 616e 7420 7769  tain constant wi
+00009df0: 6474 680a 2f2f 2020 2069 6620 796f 7572  dth.//   if your
+00009e00: 2077 616c 6c20 7468 6963 6b6e 6573 7320   wall thickness 
+00009e10: 6973 2075 6e69 666f 726d 2e20 2049 6620  is uniform.  If 
+00009e20: 7468 6520 7761 6c6c 2074 6869 636b 6e65  the wall thickne
+00009e30: 7373 2069 7320 6e6f 7420 756e 6966 6f72  ss is not unifor
+00009e40: 6d2c 2074 6865 2064 6566 6175 6c74 0a2f  m, the default./
+00009e50: 2f20 2020 696e 7369 6465 2072 6f75 6e64  /   inside round
+00009e60: 696e 6720 6973 2063 616c 6375 6c61 7465  ing is calculate
+00009e70: 6420 6261 7365 6420 6f6e 2074 6865 2073  d based on the s
+00009e80: 6d61 6c6c 6572 206f 6620 7468 6520 7477  maller of the tw
+00009e90: 6f20 7761 6c6c 2074 6869 636b 6e65 7373  o wall thickness
+00009ea0: 6573 2e0a 2f2f 2020 204e 6f74 6520 7468  es..//   Note th
+00009eb0: 6174 2074 6865 2076 616c 7565 7320 6f66  at the values of
+00009ec0: 2074 6865 206d 6f72 6520 7370 6563 6966   the more specif
+00009ed0: 6963 2063 6861 6d66 6572 7320 616e 6420  ic chamfers and 
+00009ee0: 726f 756e 6469 6e67 7320 696e 6865 7269  roundings inheri
+00009ef0: 7420 6672 6f6d 2074 6865 0a2f 2f20 2020  t from the.//   
+00009f00: 6d6f 7265 2067 656e 6572 616c 206f 6e65  more general one
+00009f10: 732c 2073 6f20 6072 6f75 6e64 696e 6732  s, so `rounding2
+00009f20: 6020 6973 2064 6574 6572 6d69 6e65 6420  ` is determined 
+00009f30: 6672 6f6d 2060 726f 756e 6469 6e67 602e  from `rounding`.
+00009f40: 2020 5468 6520 636f 6e73 7461 6e74 0a2f    The constant./
+00009f50: 2f20 2020 7769 6474 6820 6465 6661 756c  /   width defaul
+00009f60: 7420 7769 6c6c 2061 7070 6c79 2077 6865  t will apply whe
+00009f70: 6e20 7468 6520 696e 6e65 7220 726f 756e  n the inner roun
+00009f80: 6469 6e67 2061 6e64 2063 6861 6d66 6572  ding and chamfer
+00009f90: 2061 7265 2062 6f74 6820 756e 6465 662e   are both undef.
+00009fa0: 0a2f 2f20 2020 596f 7520 6361 6e20 6769  .//   You can gi
+00009fb0: 7665 2061 6e20 696e 6e65 7220 6368 616d  ve an inner cham
+00009fc0: 6665 7220 6f72 2072 6f75 6e64 696e 6720  fer or rounding 
+00009fd0: 6173 2061 206c 6973 7420 7769 7468 2075  as a list with u
+00009fe0: 6e64 6566 2065 6e74 7269 6573 2069 6620  ndef entries if 
+00009ff0: 796f 7520 7761 6e74 2074 6f20 7370 6563  you want to spec
+0000a000: 6966 790a 2f2f 2020 2073 6f6d 6520 636f  ify.//   some co
+0000a010: 726e 6572 2072 6f75 6e64 696e 6773 2061  rner roundings a
+0000a020: 6e64 2061 6c6c 6f77 206f 7468 6572 7320  nd allow others 
+0000a030: 746f 2062 6520 636f 6d70 7574 6564 2e20  to be computed. 
+0000a040: 200a 2f2f 2041 7267 756d 656e 7473 3a0a   .// Arguments:.
+0000a050: 2f2f 2020 2068 2f6c 2f68 6569 6768 742f  //   h/l/height/
+0000a060: 6c65 6e67 7468 203d 2054 6865 2068 6569  length = The hei
+0000a070: 6768 7420 6f72 206c 656e 6774 6820 6f66  ght or length of
+0000a080: 2074 6865 2072 6563 7461 6e67 756c 6172   the rectangular
+0000a090: 2074 7562 652e 2020 4465 6661 756c 743a   tube.  Default:
+0000a0a0: 2031 0a2f 2f20 2020 7369 7a65 203d 2054   1.//   size = T
+0000a0b0: 6865 206f 7574 6572 205b 582c 595d 2073  he outer [X,Y] s
+0000a0c0: 697a 6520 6f66 2074 6865 2072 6563 7461  ize of the recta
+0000a0d0: 6e67 756c 6172 2074 7562 652e 0a2f 2f20  ngular tube..// 
+0000a0e0: 2020 6973 697a 6520 3d20 5468 6520 696e    isize = The in
+0000a0f0: 6e65 7220 5b58 2c59 5d20 7369 7a65 206f  ner [X,Y] size o
+0000a100: 6620 7468 6520 7265 6374 616e 6775 6c61  f the rectangula
+0000a110: 7220 7475 6265 2e0a 2f2f 2020 2063 656e  r tube..//   cen
+0000a120: 7465 7220 3d20 4966 2067 6976 656e 2c20  ter = If given, 
+0000a130: 6f76 6572 7269 6465 7320 6061 6e63 686f  overrides `ancho
+0000a140: 7260 2e20 2041 2074 7275 6520 7661 6c75  r`.  A true valu
+0000a150: 6520 7365 7473 2060 616e 6368 6f72 3d43  e sets `anchor=C
+0000a160: 454e 5445 5260 2c20 6661 6c73 6520 7365  ENTER`, false se
+0000a170: 7473 2060 616e 6368 6f72 3d55 5060 2e0a  ts `anchor=UP`..
+0000a180: 2f2f 2020 2073 6869 6674 203d 205b 582c  //   shift = [X,
+0000a190: 595d 2061 6d6f 756e 7420 746f 2073 6869  Y] amount to shi
+0000a1a0: 6674 2074 6865 2063 656e 7465 7220 6f66  ft the center of
+0000a1b0: 2074 6865 2074 6f70 2065 6e64 2077 6974   the top end wit
+0000a1c0: 6820 7265 7370 6563 7420 746f 2074 6865  h respect to the
+0000a1d0: 2063 656e 7465 7220 6f66 2074 6865 2062   center of the b
+0000a1e0: 6f74 746f 6d20 656e 642e 0a2f 2f20 2020  ottom end..//   
+0000a1f0: 2d2d 2d0a 2f2f 2020 2077 616c 6c20 3d20  ---.//   wall = 
+0000a200: 5468 6520 7468 6963 6b6e 6573 7320 6f66  The thickness of
+0000a210: 2074 6865 2072 6563 7461 6e67 756c 6172   the rectangular
+0000a220: 2074 7562 6520 7761 6c6c 2e0a 2f2f 2020   tube wall..//  
+0000a230: 2073 697a 6531 203d 2054 6865 205b 582c   size1 = The [X,
+0000a240: 595d 2073 697a 6520 6f66 2074 6865 206f  Y] size of the o
+0000a250: 7574 7369 6465 206f 6620 7468 6520 626f  utside of the bo
+0000a260: 7474 6f6d 206f 6620 7468 6520 7265 6374  ttom of the rect
+0000a270: 616e 6775 6c61 7220 7475 6265 2e0a 2f2f  angular tube..//
+0000a280: 2020 2073 697a 6532 203d 2054 6865 205b     size2 = The [
+0000a290: 582c 595d 2073 697a 6520 6f66 2074 6865  X,Y] size of the
+0000a2a0: 206f 7574 7369 6465 206f 6620 7468 6520   outside of the 
+0000a2b0: 746f 7020 6f66 2074 6865 2072 6563 7461  top of the recta
+0000a2c0: 6e67 756c 6172 2074 7562 652e 0a2f 2f20  ngular tube..// 
+0000a2d0: 2020 6973 697a 6531 203d 2054 6865 205b    isize1 = The [
+0000a2e0: 582c 595d 2073 697a 6520 6f66 2074 6865  X,Y] size of the
+0000a2f0: 2069 6e73 6964 6520 6f66 2074 6865 2062   inside of the b
+0000a300: 6f74 746f 6d20 6f66 2074 6865 2072 6563  ottom of the rec
+0000a310: 7461 6e67 756c 6172 2074 7562 652e 0a2f  tangular tube../
+0000a320: 2f20 2020 6973 697a 6532 203d 2054 6865  /   isize2 = The
+0000a330: 205b 582c 595d 2073 697a 6520 6f66 2074   [X,Y] size of t
+0000a340: 6865 2069 6e73 6964 6520 6f66 2074 6865  he inside of the
+0000a350: 2074 6f70 206f 6620 7468 6520 7265 6374   top of the rect
+0000a360: 616e 6775 6c61 7220 7475 6265 2e0a 2f2f  angular tube..//
+0000a370: 2020 2072 6f75 6e64 696e 6720 3d20 5468     rounding = Th
+0000a380: 6520 726f 756e 646f 7665 7220 7261 6469  e roundover radi
+0000a390: 7573 2066 6f72 2074 6865 206f 7574 7369  us for the outsi
+0000a3a0: 6465 2065 6467 6573 206f 6620 7468 6520  de edges of the 
+0000a3b0: 7265 6374 616e 6775 6c61 7220 7475 6265  rectangular tube
+0000a3c0: 2e0a 2f2f 2020 2072 6f75 6e64 696e 6731  ..//   rounding1
+0000a3d0: 203d 2054 6865 2072 6f75 6e64 6f76 6572   = The roundover
+0000a3e0: 2072 6164 6975 7320 666f 7220 7468 6520   radius for the 
+0000a3f0: 6f75 7473 6964 6520 626f 7474 6f6d 2063  outside bottom c
+0000a400: 6f72 6e65 7220 6f66 2074 6865 2072 6563  orner of the rec
+0000a410: 7461 6e67 756c 6172 2074 7562 652e 0a2f  tangular tube../
+0000a420: 2f20 2020 726f 756e 6469 6e67 3220 3d20  /   rounding2 = 
+0000a430: 5468 6520 726f 756e 646f 7665 7220 7261  The roundover ra
+0000a440: 6469 7573 2066 6f72 2074 6865 206f 7574  dius for the out
+0000a450: 7369 6465 2074 6f70 2063 6f72 6e65 7220  side top corner 
+0000a460: 6f66 2074 6865 2072 6563 7461 6e67 756c  of the rectangul
+0000a470: 6172 2074 7562 652e 0a2f 2f20 2020 6368  ar tube..//   ch
+0000a480: 616d 6665 7220 3d20 5468 6520 6368 616d  amfer = The cham
+0000a490: 6665 7220 7369 7a65 2066 6f72 2074 6865  fer size for the
+0000a4a0: 206f 7574 7369 6465 2065 6467 6573 206f   outside edges o
+0000a4b0: 6620 7468 6520 7265 6374 616e 6775 6c61  f the rectangula
+0000a4c0: 7220 7475 6265 2e0a 2f2f 2020 2063 6861  r tube..//   cha
+0000a4d0: 6d66 6572 3120 3d20 5468 6520 6368 616d  mfer1 = The cham
+0000a4e0: 6665 7220 7369 7a65 2066 6f72 2074 6865  fer size for the
+0000a4f0: 206f 7574 7369 6465 2062 6f74 746f 6d20   outside bottom 
+0000a500: 636f 726e 6572 206f 6620 7468 6520 7265  corner of the re
+0000a510: 6374 616e 6775 6c61 7220 7475 6265 2e0a  ctangular tube..
+0000a520: 2f2f 2020 2063 6861 6d66 6572 3220 3d20  //   chamfer2 = 
+0000a530: 5468 6520 6368 616d 6665 7220 7369 7a65  The chamfer size
+0000a540: 2066 6f72 2074 6865 206f 7574 7369 6465   for the outside
+0000a550: 2074 6f70 2063 6f72 6e65 7220 6f66 2074   top corner of t
+0000a560: 6865 2072 6563 7461 6e67 756c 6172 2074  he rectangular t
+0000a570: 7562 652e 0a2f 2f20 2020 6972 6f75 6e64  ube..//   iround
+0000a580: 696e 6720 3d20 5468 6520 726f 756e 646f  ing = The roundo
+0000a590: 7665 7220 7261 6469 7573 2066 6f72 2074  ver radius for t
+0000a5a0: 6865 2069 6e73 6964 6520 6564 6765 7320  he inside edges 
+0000a5b0: 6f66 2074 6865 2072 6563 7461 6e67 756c  of the rectangul
+0000a5c0: 6172 2074 7562 652e 2044 6566 6175 6c74  ar tube. Default
+0000a5d0: 3a20 436f 6d70 7574 6564 2066 6f72 2075  : Computed for u
+0000a5e0: 6e69 666f 726d 2077 616c 6c20 7468 6963  niform wall thic
+0000a5f0: 6b6e 6573 7320 2873 6565 2061 626f 7665  kness (see above
+0000a600: 290a 2f2f 2020 2069 726f 756e 6469 6e67  ).//   irounding
+0000a610: 3120 3d20 5468 6520 726f 756e 646f 7665  1 = The roundove
+0000a620: 7220 7261 6469 7573 2066 6f72 2074 6865  r radius for the
+0000a630: 2069 6e73 6964 6520 626f 7474 6f6d 2063   inside bottom c
+0000a640: 6f72 6e65 7220 6f66 2074 6865 2072 6563  orner of the rec
+0000a650: 7461 6e67 756c 6172 2074 7562 652e 0a2f  tangular tube../
+0000a660: 2f20 2020 6972 6f75 6e64 696e 6732 203d  /   irounding2 =
+0000a670: 2054 6865 2072 6f75 6e64 6f76 6572 2072   The roundover r
+0000a680: 6164 6975 7320 666f 7220 7468 6520 696e  adius for the in
+0000a690: 7369 6465 2074 6f70 2063 6f72 6e65 7220  side top corner 
+0000a6a0: 6f66 2074 6865 2072 6563 7461 6e67 756c  of the rectangul
+0000a6b0: 6172 2074 7562 652e 0a2f 2f20 2020 6963  ar tube..//   ic
+0000a6c0: 6861 6d66 6572 203d 2054 6865 2063 6861  hamfer = The cha
+0000a6d0: 6d66 6572 2073 697a 6520 666f 7220 7468  mfer size for th
+0000a6e0: 6520 696e 7369 6465 2065 6467 6573 206f  e inside edges o
+0000a6f0: 6620 7468 6520 7265 6374 616e 6775 6c61  f the rectangula
+0000a700: 7220 7475 6265 2e20 2044 6566 6175 6c74  r tube.  Default
+0000a710: 3a20 436f 6d70 7574 6564 2066 6f72 2075  : Computed for u
+0000a720: 6e69 666f 726d 2077 616c 6c20 7468 6963  niform wall thic
+0000a730: 6b6e 6573 7320 2873 6565 2061 626f 7665  kness (see above
+0000a740: 290a 2f2f 2020 2069 6368 616d 6665 7231  ).//   ichamfer1
+0000a750: 203d 2054 6865 2063 6861 6d66 6572 2073   = The chamfer s
+0000a760: 697a 6520 666f 7220 7468 6520 696e 7369  ize for the insi
+0000a770: 6465 2062 6f74 746f 6d20 636f 726e 6572  de bottom corner
+0000a780: 206f 6620 7468 6520 7265 6374 616e 6775   of the rectangu
+0000a790: 6c61 7220 7475 6265 2e0a 2f2f 2020 2069  lar tube..//   i
+0000a7a0: 6368 616d 6665 7232 203d 2054 6865 2063  chamfer2 = The c
+0000a7b0: 6861 6d66 6572 2073 697a 6520 666f 7220  hamfer size for 
+0000a7c0: 7468 6520 696e 7369 6465 2074 6f70 2063  the inside top c
+0000a7d0: 6f72 6e65 7220 6f66 2074 6865 2072 6563  orner of the rec
+0000a7e0: 7461 6e67 756c 6172 2074 7562 652e 0a2f  tangular tube../
+0000a7f0: 2f20 2020 616e 6368 6f72 203d 2054 7261  /   anchor = Tra
+0000a800: 6e73 6c61 7465 2073 6f20 616e 6368 6f72  nslate so anchor
+0000a810: 2070 6f69 6e74 2069 7320 6174 206f 7269   point is at ori
+0000a820: 6769 6e20 2830 2c30 2c30 292e 2020 5365  gin (0,0,0).  Se
+0000a830: 6520 5b61 6e63 686f 725d 2861 7474 6163  e [anchor](attac
+0000a840: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+0000a850: 6563 7469 6f6e 2d61 6e63 686f 7229 2e20  ection-anchor). 
+0000a860: 2044 6566 6175 6c74 3a20 6042 4f54 544f   Default: `BOTTO
+0000a870: 4d60 0a2f 2f20 2020 7370 696e 203d 2052  M`.//   spin = R
+0000a880: 6f74 6174 6520 7468 6973 206d 616e 7920  otate this many 
+0000a890: 6465 6772 6565 7320 6172 6f75 6e64 2074  degrees around t
+0000a8a0: 6865 205a 2061 7869 7320 6166 7465 7220  he Z axis after 
+0000a8b0: 616e 6368 6f72 2e20 2053 6565 205b 7370  anchor.  See [sp
+0000a8c0: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
+0000a8d0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
+0000a8e0: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
+0000a8f0: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
+0000a900: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
+0000a910: 6174 6520 746f 7020 746f 7761 7264 732c  ate top towards,
+0000a920: 2061 6674 6572 2073 7069 6e2e 2020 5365   after spin.  Se
+0000a930: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
+0000a940: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+0000a950: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
+0000a960: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
+0000a970: 2f20 4578 616d 706c 6573 3a0a 2f2f 2020  / Examples:.//  
+0000a980: 2072 6563 745f 7475 6265 2873 697a 653d   rect_tube(size=
+0000a990: 3530 2c20 7761 6c6c 3d35 2c20 683d 3330  50, wall=5, h=30
+0000a9a0: 293b 0a2f 2f20 2020 7265 6374 5f74 7562  );.//   rect_tub
+0000a9b0: 6528 7369 7a65 3d5b 3130 302c 3630 5d2c  e(size=[100,60],
+0000a9c0: 2077 616c 6c3d 352c 2068 3d33 3029 3b0a   wall=5, h=30);.
+0000a9d0: 2f2f 2020 2072 6563 745f 7475 6265 2869  //   rect_tube(i
+0000a9e0: 7369 7a65 3d5b 3630 2c38 305d 2c20 7761  size=[60,80], wa
+0000a9f0: 6c6c 3d35 2c20 683d 3330 293b 0a2f 2f20  ll=5, h=30);.// 
+0000aa00: 2020 7265 6374 5f74 7562 6528 7369 7a65    rect_tube(size
+0000aa10: 3d5b 3130 302c 3630 5d2c 2069 7369 7a65  =[100,60], isize
+0000aa20: 3d5b 3930 2c35 305d 2c20 683d 3330 293b  =[90,50], h=30);
+0000aa30: 0a2f 2f20 2020 7265 6374 5f74 7562 6528  .//   rect_tube(
+0000aa40: 7369 7a65 313d 5b31 3030 2c36 305d 2c20  size1=[100,60], 
+0000aa50: 7369 7a65 323d 5b37 302c 3430 5d2c 2077  size2=[70,40], w
+0000aa60: 616c 6c3d 352c 2068 3d33 3029 3b0a 2f2f  all=5, h=30);.//
+0000aa70: 2045 7861 6d70 6c65 3a0a 2f2f 2020 2072   Example:.//   r
+0000aa80: 6563 745f 7475 6265 280a 2f2f 2020 2020  ect_tube(.//    
+0000aa90: 2020 2073 697a 6531 3d5b 3130 302c 3630     size1=[100,60
+0000aaa0: 5d2c 2073 697a 6532 3d5b 3730 2c34 305d  ], size2=[70,40]
+0000aab0: 2c0a 2f2f 2020 2020 2020 2069 7369 7a65  ,.//       isize
+0000aac0: 313d 5b34 302c 3230 5d2c 2069 7369 7a65  1=[40,20], isize
+0000aad0: 323d 5b36 352c 3335 5d2c 2068 3d31 350a  2=[65,35], h=15.
+0000aae0: 2f2f 2020 2029 3b0a 2f2f 2045 7861 6d70  //   );.// Examp
+0000aaf0: 6c65 3a20 5769 7468 2072 6f75 6e64 696e  le: With roundin
+0000ab00: 670a 2f2f 2020 2072 6563 745f 7475 6265  g.//   rect_tube
+0000ab10: 2873 697a 653d 3130 302c 2077 616c 6c3d  (size=100, wall=
+0000ab20: 352c 2072 6f75 6e64 696e 673d 3130 2c20  5, rounding=10, 
+0000ab30: 683d 3330 293b 0a2f 2f20 4578 616d 706c  h=30);.// Exampl
+0000ab40: 653a 2057 6974 6820 726f 756e 6469 6e67  e: With rounding
+0000ab50: 0a2f 2f20 2020 7265 6374 5f74 7562 6528  .//   rect_tube(
+0000ab60: 7369 7a65 3d31 3030 2c20 7761 6c6c 3d35  size=100, wall=5
+0000ab70: 2c20 6368 616d 6665 723d 3130 2c20 683d  , chamfer=10, h=
+0000ab80: 3330 293b 0a2f 2f20 4578 616d 706c 653a  30);.// Example:
+0000ab90: 204f 7574 6572 2052 6f75 6e64 696e 6720   Outer Rounding 
+0000aba0: 4f6e 6c79 0a2f 2f20 2020 7265 6374 5f74  Only.//   rect_t
+0000abb0: 7562 6528 7369 7a65 3d31 3030 2c20 7761  ube(size=100, wa
+0000abc0: 6c6c 3d35 2c20 726f 756e 6469 6e67 3d31  ll=5, rounding=1
+0000abd0: 302c 2069 726f 756e 6469 6e67 3d30 2c20  0, irounding=0, 
+0000abe0: 683d 3330 293b 0a2f 2f20 4578 616d 706c  h=30);.// Exampl
+0000abf0: 653a 204f 7574 6572 2043 6861 6d66 6572  e: Outer Chamfer
+0000ac00: 204f 6e6c 790a 2f2f 2020 2072 6563 745f   Only.//   rect_
+0000ac10: 7475 6265 2873 697a 653d 3130 302c 2077  tube(size=100, w
+0000ac20: 616c 6c3d 352c 2063 6861 6d66 6572 3d35  all=5, chamfer=5
+0000ac30: 2c20 6963 6861 6d66 6572 3d30 2c20 683d  , ichamfer=0, h=
+0000ac40: 3330 293b 0a2f 2f20 4578 616d 706c 653a  30);.// Example:
+0000ac50: 204f 7574 6572 2052 6f75 6e64 696e 672c   Outer Rounding,
+0000ac60: 2049 6e6e 6572 2043 6861 6d66 6572 0a2f   Inner Chamfer./
+0000ac70: 2f20 2020 7265 6374 5f74 7562 6528 7369  /   rect_tube(si
+0000ac80: 7a65 3d31 3030 2c20 7761 6c6c 3d35 2c20  ze=100, wall=5, 
+0000ac90: 726f 756e 6469 6e67 3d31 302c 2069 6368  rounding=10, ich
+0000aca0: 616d 6665 723d 382c 2068 3d33 3029 3b0a  amfer=8, h=30);.
+0000acb0: 2f2f 2045 7861 6d70 6c65 3a20 496e 6e65  // Example: Inne
+0000acc0: 7220 526f 756e 6469 6e67 2c20 4f75 7465  r Rounding, Oute
+0000acd0: 7220 4368 616d 6665 720a 2f2f 2020 2072  r Chamfer.//   r
+0000ace0: 6563 745f 7475 6265 2873 697a 653d 3130  ect_tube(size=10
+0000acf0: 302c 2077 616c 6c3d 352c 2063 6861 6d66  0, wall=5, chamf
+0000ad00: 6572 3d31 302c 2069 726f 756e 6469 6e67  er=10, irounding
+0000ad10: 3d38 2c20 683d 3330 293b 0a2f 2f20 4578  =8, h=30);.// Ex
+0000ad20: 616d 706c 653a 2047 7261 6469 616e 7420  ample: Gradiant 
+0000ad30: 526f 756e 6469 6e67 0a2f 2f20 2020 7265  Rounding.//   re
+0000ad40: 6374 5f74 7562 6528 0a2f 2f20 2020 2020  ct_tube(.//     
+0000ad50: 2020 7369 7a65 313d 3130 302c 2073 697a    size1=100, siz
+0000ad60: 6532 3d38 302c 2077 616c 6c3d 352c 2068  e2=80, wall=5, h
+0000ad70: 3d33 302c 0a2f 2f20 2020 2020 2020 726f  =30,.//       ro
+0000ad80: 756e 6469 6e67 313d 3130 2c20 726f 756e  unding1=10, roun
+0000ad90: 6469 6e67 323d 302c 0a2f 2f20 2020 2020  ding2=0,.//     
+0000ada0: 2020 6972 6f75 6e64 696e 6731 3d38 2c20    irounding1=8, 
+0000adb0: 6972 6f75 6e64 696e 6732 3d30 0a2f 2f20  irounding2=0.// 
+0000adc0: 2020 293b 0a2f 2f20 4578 616d 706c 653a    );.// Example:
+0000add0: 2050 6572 2043 6f72 6e65 7220 526f 756e   Per Corner Roun
+0000ade0: 6469 6e67 0a2f 2f20 2020 7265 6374 5f74  ding.//   rect_t
+0000adf0: 7562 6528 0a2f 2f20 2020 2020 2020 7369  ube(.//       si
+0000ae00: 7a65 3d31 3030 2c20 7761 6c6c 3d31 302c  ze=100, wall=10,
+0000ae10: 2068 3d33 302c 0a2f 2f20 2020 2020 2020   h=30,.//       
+0000ae20: 726f 756e 6469 6e67 3d5b 302c 352c 3130  rounding=[0,5,10
+0000ae30: 2c31 355d 2c20 6972 6f75 6e64 696e 673d  ,15], irounding=
+0000ae40: 300a 2f2f 2020 2029 3b0a 2f2f 2045 7861  0.//   );.// Exa
+0000ae50: 6d70 6c65 3a20 5065 7220 436f 726e 6572  mple: Per Corner
+0000ae60: 2043 6861 6d66 6572 0a2f 2f20 2020 7265   Chamfer.//   re
+0000ae70: 6374 5f74 7562 6528 0a2f 2f20 2020 2020  ct_tube(.//     
+0000ae80: 2020 7369 7a65 3d31 3030 2c20 7761 6c6c    size=100, wall
+0000ae90: 3d31 302c 2068 3d33 302c 0a2f 2f20 2020  =10, h=30,.//   
+0000aea0: 2020 2020 6368 616d 6665 723d 5b30 2c35      chamfer=[0,5
+0000aeb0: 2c31 302c 3135 5d2c 2069 6368 616d 6665  ,10,15], ichamfe
+0000aec0: 723d 300a 2f2f 2020 2029 3b0a 2f2f 2045  r=0.//   );.// E
+0000aed0: 7861 6d70 6c65 3a20 4d69 7869 6e67 2043  xample: Mixing C
+0000aee0: 6861 6d66 6572 2061 6e64 2052 6f75 6e64  hamfer and Round
+0000aef0: 696e 670a 2f2f 2020 2072 6563 745f 7475  ing.//   rect_tu
+0000af00: 6265 280a 2f2f 2020 2020 2020 2073 697a  be(.//       siz
+0000af10: 653d 3130 302c 2077 616c 6c3d 3130 2c20  e=100, wall=10, 
+0000af20: 683d 3330 2c0a 2f2f 2020 2020 2020 2063  h=30,.//       c
+0000af30: 6861 6d66 6572 3d5b 302c 3130 2c30 2c32  hamfer=[0,10,0,2
+0000af40: 305d 2c20 0a2f 2f20 2020 2020 2020 726f  0], .//       ro
+0000af50: 756e 6469 6e67 3d5b 3130 2c30 2c32 302c  unding=[10,0,20,
+0000af60: 305d 0a2f 2f20 2020 293b 0a2f 2f20 4578  0].//   );.// Ex
+0000af70: 616d 706c 653a 2052 6561 6c6c 7920 4d69  ample: Really Mi
+0000af80: 7869 6e67 2049 7420 5570 0a2f 2f20 2020  xing It Up.//   
+0000af90: 7265 6374 5f74 7562 6528 0a2f 2f20 2020  rect_tube(.//   
+0000afa0: 2020 2020 7369 7a65 313d 5b31 3030 2c38      size1=[100,8
+0000afb0: 305d 2c20 7369 7a65 323d 5b38 302c 3630  0], size2=[80,60
+0000afc0: 5d2c 0a2f 2f20 2020 2020 2020 6973 697a  ],.//       isiz
+0000afd0: 6531 3d5b 3530 2c33 305d 2c20 6973 697a  e1=[50,30], isiz
+0000afe0: 6532 3d5b 3730 2c35 305d 2c20 683d 3230  e2=[70,50], h=20
+0000aff0: 2c0a 2f2f 2020 2020 2020 2063 6861 6d66  ,.//       chamf
+0000b000: 6572 313d 5b30 2c35 2c30 2c31 305d 2c20  er1=[0,5,0,10], 
+0000b010: 6963 6861 6d66 6572 313d 5b30 2c33 2c30  ichamfer1=[0,3,0
+0000b020: 2c38 5d2c 0a2f 2f20 2020 2020 2020 6368  ,8],.//       ch
+0000b030: 616d 6665 7232 3d5b 352c 302c 3130 2c30  amfer2=[5,0,10,0
+0000b040: 5d2c 2069 6368 616d 6665 7232 3d5b 332c  ], ichamfer2=[3,
+0000b050: 302c 382c 305d 2c0a 2f2f 2020 2020 2020  0,8,0],.//      
+0000b060: 2072 6f75 6e64 696e 6731 3d5b 352c 302c   rounding1=[5,0,
+0000b070: 3130 2c30 5d2c 2069 726f 756e 6469 6e67  10,0], irounding
+0000b080: 313d 5b33 2c30 2c38 2c30 5d2c 0a2f 2f20  1=[3,0,8,0],.// 
+0000b090: 2020 2020 2020 726f 756e 6469 6e67 323d        rounding2=
+0000b0a0: 5b30 2c35 2c30 2c31 305d 2c20 6972 6f75  [0,5,0,10], irou
+0000b0b0: 6e64 696e 6732 3d5b 302c 332c 302c 385d  nding2=[0,3,0,8]
+0000b0c0: 0a2f 2f20 2020 293b 0a2f 2f20 4578 616d  .//   );.// Exam
+0000b0d0: 706c 653a 2053 6f6d 6520 696e 7465 7269  ple: Some interi
+0000b0e0: 6f72 7320 6368 616d 6665 7265 642c 206f  ors chamfered, o
+0000b0f0: 7468 6572 7320 7769 7468 2064 6566 6175  thers with defau
+0000b100: 6c74 2072 6f75 6e64 696e 670a 2f2f 2020  lt rounding.//  
+0000b110: 2072 6563 745f 7475 6265 280a 2f2f 2020   rect_tube(.//  
+0000b120: 2020 2020 2073 697a 653d 3130 302c 2077       size=100, w
+0000b130: 616c 6c3d 3130 2c20 683d 3330 2c0a 2f2f  all=10, h=30,.//
+0000b140: 2020 2020 2020 2072 6f75 6e64 696e 673d         rounding=
+0000b150: 5b30 2c31 302c 3230 2c33 305d 2c20 6963  [0,10,20,30], ic
+0000b160: 6861 6d66 6572 3d5b 382c 382c 756e 6465  hamfer=[8,8,unde
+0000b170: 662c 756e 6465 665d 0a2f 2f20 2020 293b  f,undef].//   );
+0000b180: 0a0a 0a0a 6675 6e63 7469 6f6e 205f 7265  ....function _re
+0000b190: 6374 5f74 7562 655f 726f 756e 6469 6e67  ct_tube_rounding
+0000b1a0: 2866 6163 746f 722c 6972 2c72 2c61 6c74  (factor,ir,r,alt
+0000b1b0: 6572 6e61 7469 7665 2c73 697a 652c 6973  ernative,size,is
+0000b1c0: 697a 6529 203d 0a20 2020 206c 6574 2877  ize) =.    let(w
+0000b1d0: 616c 6c20 3d20 6d69 6e28 7369 7a65 2d69  all = min(size-i
+0000b1e0: 7369 7a65 292f 322a 6661 6374 6f72 290a  size)/2*factor).
+0000b1f0: 2020 2020 5b66 6f72 2869 3d5b 303a 335d      [for(i=[0:3]
+0000b200: 290a 2020 2020 2020 6973 5f64 6566 2869  ).      is_def(i
+0000b210: 725b 695d 2920 3f20 6972 5b69 5d0a 2020  r[i]) ? ir[i].  
+0000b220: 2020 3a20 6973 5f75 6e64 6566 2861 6c74    : is_undef(alt
+0000b230: 6572 6e61 7469 7665 5b69 5d29 203f 206d  ernative[i]) ? m
+0000b240: 6178 2830 2c72 5b69 5d2d 7761 6c6c 290a  ax(0,r[i]-wall).
+0000b250: 2020 2020 3a20 300a 2020 2020 5d3b 0a20      : 0.    ];. 
+0000b260: 2020 200a 6d6f 6475 6c65 2072 6563 745f     .module rect_
+0000b270: 7475 6265 280a 2020 2020 682c 2073 697a  tube(.    h, siz
+0000b280: 652c 2069 7369 7a65 2c20 6365 6e74 6572  e, isize, center
+0000b290: 2c20 7368 6966 743d 5b30 2c30 5d2c 0a20  , shift=[0,0],. 
+0000b2a0: 2020 2077 616c 6c2c 2073 697a 6531 2c20     wall, size1, 
+0000b2b0: 7369 7a65 322c 2069 7369 7a65 312c 2069  size2, isize1, i
+0000b2c0: 7369 7a65 322c 0a20 2020 2072 6f75 6e64  size2,.    round
+0000b2d0: 696e 673d 302c 2072 6f75 6e64 696e 6731  ing=0, rounding1
+0000b2e0: 2c20 726f 756e 6469 6e67 322c 0a20 2020  , rounding2,.   
+0000b2f0: 2069 726f 756e 6469 6e67 3d75 6e64 6566   irounding=undef
+0000b300: 2c20 6972 6f75 6e64 696e 6731 3d75 6e64  , irounding1=und
+0000b310: 6566 2c20 6972 6f75 6e64 696e 6732 3d75  ef, irounding2=u
+0000b320: 6e64 6566 2c0a 2020 2020 6368 616d 6665  ndef,.    chamfe
+0000b330: 723d 302c 2063 6861 6d66 6572 312c 2063  r=0, chamfer1, c
+0000b340: 6861 6d66 6572 322c 0a20 2020 2069 6368  hamfer2,.    ich
+0000b350: 616d 6665 723d 756e 6465 662c 2069 6368  amfer=undef, ich
+0000b360: 616d 6665 7231 3d75 6e64 6566 2c20 6963  amfer1=undef, ic
+0000b370: 6861 6d66 6572 323d 756e 6465 662c 0a20  hamfer2=undef,. 
+0000b380: 2020 2061 6e63 686f 722c 2073 7069 6e3d     anchor, spin=
+0000b390: 302c 206f 7269 656e 743d 5550 2c0a 2020  0, orient=UP,.  
+0000b3a0: 2020 6c2c 206c 656e 6774 682c 2068 6569    l, length, hei
+0000b3b0: 6768 740a 2920 7b0a 2020 2020 6820 3d20  ght.) {.    h = 
+0000b3c0: 6f6e 655f 6465 6669 6e65 6428 5b68 2c6c  one_defined([h,l
+0000b3d0: 2c6c 656e 6774 682c 6865 6967 6874 5d2c  ,length,height],
+0000b3e0: 2268 2c6c 2c6c 656e 6774 682c 6865 6967  "h,l,length,heig
+0000b3f0: 6874 2229 3b0a 2020 2020 6368 6563 6b73  ht");.    checks
+0000b400: 203d 0a20 2020 2020 2020 2061 7373 6572   =.        asser
+0000b410: 7428 6973 5f6e 756d 2868 292c 2022 6c20  t(is_num(h), "l 
+0000b420: 6f72 2068 2061 7267 756d 656e 7420 7265  or h argument re
+0000b430: 7175 6972 6564 2e22 290a 2020 2020 2020  quired.").      
+0000b440: 2020 6173 7365 7274 2869 735f 7665 6374    assert(is_vect
+0000b450: 6f72 2873 6869 6674 2c32 2929 3b0a 2020  or(shift,2));.  
+0000b460: 2020 7331 203d 2069 735f 6e75 6d28 7369    s1 = is_num(si
+0000b470: 7a65 3129 3f20 5b73 697a 6531 2c20 7369  ze1)? [size1, si
+0000b480: 7a65 315d 203a 0a20 2020 2020 2020 2069  ze1] :.        i
+0000b490: 735f 7665 6374 6f72 2873 697a 6531 2c32  s_vector(size1,2
+0000b4a0: 293f 2073 697a 6531 203a 0a20 2020 2020  )? size1 :.     
+0000b4b0: 2020 2069 735f 6e75 6d28 7369 7a65 293f     is_num(size)?
+0000b4c0: 205b 7369 7a65 2c20 7369 7a65 5d20 3a0a   [size, size] :.
+0000b4d0: 2020 2020 2020 2020 6973 5f76 6563 746f          is_vecto
+0000b4e0: 7228 7369 7a65 2c32 293f 2073 697a 6520  r(size,2)? size 
+0000b4f0: 3a0a 2020 2020 2020 2020 756e 6465 663b  :.        undef;
+0000b500: 0a20 2020 2073 3220 3d20 6973 5f6e 756d  .    s2 = is_num
+0000b510: 2873 697a 6532 293f 205b 7369 7a65 322c  (size2)? [size2,
+0000b520: 2073 697a 6532 5d20 3a0a 2020 2020 2020   size2] :.      
+0000b530: 2020 6973 5f76 6563 746f 7228 7369 7a65    is_vector(size
+0000b540: 322c 3229 3f20 7369 7a65 3220 3a0a 2020  2,2)? size2 :.  
+0000b550: 2020 2020 2020 6973 5f6e 756d 2873 697a        is_num(siz
+0000b560: 6529 3f20 5b73 697a 652c 2073 697a 655d  e)? [size, size]
+0000b570: 203a 0a20 2020 2020 2020 2069 735f 7665   :.        is_ve
+0000b580: 6374 6f72 2873 697a 652c 3229 3f20 7369  ctor(size,2)? si
+0000b590: 7a65 203a 0a20 2020 2020 2020 2075 6e64  ze :.        und
+0000b5a0: 6566 3b0a 2020 2020 6973 3120 3d20 6973  ef;.    is1 = is
+0000b5b0: 5f6e 756d 2869 7369 7a65 3129 3f20 5b69  _num(isize1)? [i
+0000b5c0: 7369 7a65 312c 2069 7369 7a65 315d 203a  size1, isize1] :
+0000b5d0: 0a20 2020 2020 2020 2069 735f 7665 6374  .        is_vect
+0000b5e0: 6f72 2869 7369 7a65 312c 3229 3f20 6973  or(isize1,2)? is
+0000b5f0: 697a 6531 203a 0a20 2020 2020 2020 2069  ize1 :.        i
+0000b600: 735f 6e75 6d28 6973 697a 6529 3f20 5b69  s_num(isize)? [i
+0000b610: 7369 7a65 2c20 6973 697a 655d 203a 0a20  size, isize] :. 
+0000b620: 2020 2020 2020 2069 735f 7665 6374 6f72         is_vector
+0000b630: 2869 7369 7a65 2c32 293f 2069 7369 7a65  (isize,2)? isize
+0000b640: 203a 0a20 2020 2020 2020 2075 6e64 6566   :.        undef
+0000b650: 3b0a 2020 2020 6973 3220 3d20 6973 5f6e  ;.    is2 = is_n
+0000b660: 756d 2869 7369 7a65 3229 3f20 5b69 7369  um(isize2)? [isi
+0000b670: 7a65 322c 2069 7369 7a65 325d 203a 0a20  ze2, isize2] :. 
+0000b680: 2020 2020 2020 2069 735f 7665 6374 6f72         is_vector
+0000b690: 2869 7369 7a65 322c 3229 3f20 6973 697a  (isize2,2)? isiz
+0000b6a0: 6532 203a 0a20 2020 2020 2020 2069 735f  e2 :.        is_
+0000b6b0: 6e75 6d28 6973 697a 6529 3f20 5b69 7369  num(isize)? [isi
+0000b6c0: 7a65 2c20 6973 697a 655d 203a 0a20 2020  ze, isize] :.   
+0000b6d0: 2020 2020 2069 735f 7665 6374 6f72 2869       is_vector(i
+0000b6e0: 7369 7a65 2c32 293f 2069 7369 7a65 203a  size,2)? isize :
+0000b6f0: 0a20 2020 2020 2020 2075 6e64 6566 3b0a  .        undef;.
+0000b700: 2020 2020 7369 7a65 3120 3d20 6973 5f64      size1 = is_d
+0000b710: 6566 2873 3129 3f20 7331 203a 0a20 2020  ef(s1)? s1 :.   
+0000b720: 2020 2020 2028 6973 5f64 6566 2877 616c       (is_def(wal
+0000b730: 6c29 2026 2620 6973 5f64 6566 2869 7331  l) && is_def(is1
+0000b740: 2929 3f20 2869 7331 2b32 2a5b 7761 6c6c  ))? (is1+2*[wall
+0000b750: 2c77 616c 6c5d 2920 3a0a 2020 2020 2020  ,wall]) :.      
+0000b760: 2020 756e 6465 663b 0a20 2020 2073 697a    undef;.    siz
+0000b770: 6532 203d 2069 735f 6465 6628 7332 293f  e2 = is_def(s2)?
+0000b780: 2073 3220 3a0a 2020 2020 2020 2020 2869   s2 :.        (i
+0000b790: 735f 6465 6628 7761 6c6c 2920 2626 2069  s_def(wall) && i
+0000b7a0: 735f 6465 6628 6973 3229 293f 2028 6973  s_def(is2))? (is
+0000b7b0: 322b 322a 5b77 616c 6c2c 7761 6c6c 5d29  2+2*[wall,wall])
+0000b7c0: 203a 0a20 2020 2020 2020 2075 6e64 6566   :.        undef
+0000b7d0: 3b0a 2020 2020 6973 697a 6531 203d 2069  ;.    isize1 = i
+0000b7e0: 735f 6465 6628 6973 3129 3f20 6973 3120  s_def(is1)? is1 
+0000b7f0: 3a0a 2020 2020 2020 2020 2869 735f 6465  :.        (is_de
+0000b800: 6628 7761 6c6c 2920 2626 2069 735f 6465  f(wall) && is_de
+0000b810: 6628 7331 2929 3f20 2873 312d 322a 5b77  f(s1))? (s1-2*[w
+0000b820: 616c 6c2c 7761 6c6c 5d29 203a 0a20 2020  all,wall]) :.   
+0000b830: 2020 2020 2075 6e64 6566 3b0a 2020 2020       undef;.    
+0000b840: 6973 697a 6532 203d 2069 735f 6465 6628  isize2 = is_def(
+0000b850: 6973 3229 3f20 6973 3220 3a0a 2020 2020  is2)? is2 :.    
+0000b860: 2020 2020 2869 735f 6465 6628 7761 6c6c      (is_def(wall
+0000b870: 2920 2626 2069 735f 6465 6628 7332 2929  ) && is_def(s2))
+0000b880: 3f20 2873 322d 322a 5b77 616c 6c2c 7761  ? (s2-2*[wall,wa
+0000b890: 6c6c 5d29 203a 0a20 2020 2020 2020 2075  ll]) :.        u
+0000b8a0: 6e64 6566 3b0a 2020 2020 6368 6563 6b73  ndef;.    checks
+0000b8b0: 3220 3d0a 2020 2020 2020 2020 6173 7365  2 =.        asse
+0000b8c0: 7274 2877 616c 6c3d 3d75 6e64 6566 207c  rt(wall==undef |
+0000b8d0: 7c20 6973 5f6e 756d 2877 616c 6c29 290a  | is_num(wall)).
+0000b8e0: 2020 2020 2020 2020 6173 7365 7274 2873          assert(s
+0000b8f0: 697a 6531 213d 756e 6465 662c 2022 4261  ize1!=undef, "Ba
+0000b900: 6420 7369 7a65 2f73 697a 6531 2061 7267  d size/size1 arg
+0000b910: 756d 656e 742e 2229 0a20 2020 2020 2020  ument.").       
+0000b920: 2061 7373 6572 7428 7369 7a65 3221 3d75   assert(size2!=u
+0000b930: 6e64 6566 2c20 2242 6164 2073 697a 652f  ndef, "Bad size/
+0000b940: 7369 7a65 3220 6172 6775 6d65 6e74 2e22  size2 argument."
+0000b950: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
+0000b960: 2869 7369 7a65 3121 3d75 6e64 6566 2c20  (isize1!=undef, 
+0000b970: 2242 6164 2069 7369 7a65 2f69 7369 7a65  "Bad isize/isize
+0000b980: 3120 6172 6775 6d65 6e74 2e22 290a 2020  1 argument.").  
+0000b990: 2020 2020 2020 6173 7365 7274 2869 7369        assert(isi
+0000b9a0: 7a65 3221 3d75 6e64 6566 2c20 2242 6164  ze2!=undef, "Bad
+0000b9b0: 2069 7369 7a65 2f69 7369 7a65 3220 6172   isize/isize2 ar
+0000b9c0: 6775 6d65 6e74 2e22 290a 2020 2020 2020  gument.").      
+0000b9d0: 2020 6173 7365 7274 2869 7369 7a65 312e    assert(isize1.
+0000b9e0: 7820 3c20 7369 7a65 312e 782c 2022 496e  x < size1.x, "In
+0000b9f0: 6e65 7220 7369 7a65 2069 7320 6c61 7267  ner size is larg
+0000ba00: 6572 2074 6861 6e20 6f75 7465 7220 7369  er than outer si
+0000ba10: 7a65 2e22 290a 2020 2020 2020 2020 6173  ze.").        as
+0000ba20: 7365 7274 2869 7369 7a65 312e 7920 3c20  sert(isize1.y < 
+0000ba30: 7369 7a65 312e 792c 2022 496e 6e65 7220  size1.y, "Inner 
+0000ba40: 7369 7a65 2069 7320 6c61 7267 6572 2074  size is larger t
+0000ba50: 6861 6e20 6f75 7465 7220 7369 7a65 2e22  han outer size."
+0000ba60: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
+0000ba70: 2869 7369 7a65 322e 7820 3c20 7369 7a65  (isize2.x < size
+0000ba80: 322e 782c 2022 496e 6e65 7220 7369 7a65  2.x, "Inner size
+0000ba90: 2069 7320 6c61 7267 6572 2074 6861 6e20   is larger than 
+0000baa0: 6f75 7465 7220 7369 7a65 2e22 290a 2020  outer size.").  
+0000bab0: 2020 2020 2020 6173 7365 7274 2869 7369        assert(isi
+0000bac0: 7a65 322e 7920 3c20 7369 7a65 322e 792c  ze2.y < size2.y,
+0000bad0: 2022 496e 6e65 7220 7369 7a65 2069 7320   "Inner size is 
+0000bae0: 6c61 7267 6572 2074 6861 6e20 6f75 7465  larger than oute
+0000baf0: 7220 7369 7a65 2e22 290a 2020 2020 2020  r size.").      
+0000bb00: 2020 6173 7365 7274 2869 735f 6e75 6d28    assert(is_num(
+0000bb10: 726f 756e 6469 6e67 2920 7c7c 2069 735f  rounding) || is_
+0000bb20: 7665 6374 6f72 2872 6f75 6e64 696e 672c  vector(rounding,
+0000bb30: 3429 2c20 2272 6f75 6e64 696e 6720 6d75  4), "rounding mu
+0000bb40: 7374 2062 6520 6120 6e75 6d62 6572 206f  st be a number o
+0000bb50: 7220 342d 7665 6374 6f72 2229 0a20 2020  r 4-vector").   
+0000bb60: 2020 2020 2061 7373 6572 7428 6973 5f75       assert(is_u
+0000bb70: 6e64 6566 2872 6f75 6e64 696e 6731 2920  ndef(rounding1) 
+0000bb80: 7c7c 2069 735f 6e75 6d28 726f 756e 6469  || is_num(roundi
+0000bb90: 6e67 3129 207c 7c20 6973 5f76 6563 746f  ng1) || is_vecto
+0000bba0: 7228 726f 756e 6469 6e67 312c 3429 2c20  r(rounding1,4), 
+0000bbb0: 2272 6f75 6e64 696e 6731 206d 7573 7420  "rounding1 must 
+0000bbc0: 6265 2061 206e 756d 6265 7220 6f72 2034  be a number or 4
+0000bbd0: 2d76 6563 746f 7222 290a 2020 2020 2020  -vector").      
+0000bbe0: 2020 6173 7365 7274 2869 735f 756e 6465    assert(is_unde
+0000bbf0: 6628 726f 756e 6469 6e67 3229 207c 7c20  f(rounding2) || 
+0000bc00: 6973 5f6e 756d 2872 6f75 6e64 696e 6732  is_num(rounding2
+0000bc10: 2920 7c7c 2069 735f 7665 6374 6f72 2872  ) || is_vector(r
+0000bc20: 6f75 6e64 696e 6732 2c34 292c 2022 726f  ounding2,4), "ro
+0000bc30: 756e 6469 6e67 3220 6d75 7374 2062 6520  unding2 must be 
+0000bc40: 6120 6e75 6d62 6572 206f 7220 342d 7665  a number or 4-ve
+0000bc50: 6374 6f72 2229 0a20 2020 2020 2020 2061  ctor").        a
+0000bc60: 7373 6572 7428 6973 5f6e 756d 2863 6861  ssert(is_num(cha
+0000bc70: 6d66 6572 2920 7c7c 2069 735f 7665 6374  mfer) || is_vect
+0000bc80: 6f72 2863 6861 6d66 6572 2c34 292c 2022  or(chamfer,4), "
+0000bc90: 6368 616d 6665 7220 6d75 7374 2062 6520  chamfer must be 
+0000bca0: 6120 6e75 6d62 6572 206f 7220 342d 7665  a number or 4-ve
+0000bcb0: 6374 6f72 2229 0a20 2020 2020 2020 2061  ctor").        a
+0000bcc0: 7373 6572 7428 6973 5f75 6e64 6566 2863  ssert(is_undef(c
+0000bcd0: 6861 6d66 6572 3129 207c 7c20 6973 5f6e  hamfer1) || is_n
+0000bce0: 756d 2863 6861 6d66 6572 3129 207c 7c20  um(chamfer1) || 
+0000bcf0: 6973 5f76 6563 746f 7228 6368 616d 6665  is_vector(chamfe
+0000bd00: 7231 2c34 292c 2022 6368 616d 6665 7231  r1,4), "chamfer1
+0000bd10: 206d 7573 7420 6265 2061 206e 756d 6265   must be a numbe
+0000bd20: 7220 6f72 2034 2d76 6563 746f 7222 290a  r or 4-vector").
+0000bd30: 2020 2020 2020 2020 6173 7365 7274 2869          assert(i
+0000bd40: 735f 756e 6465 6628 6368 616d 6665 7232  s_undef(chamfer2
+0000bd50: 2920 7c7c 2069 735f 6e75 6d28 6368 616d  ) || is_num(cham
+0000bd60: 6665 7232 2920 7c7c 2069 735f 7665 6374  fer2) || is_vect
+0000bd70: 6f72 2863 6861 6d66 6572 322c 3429 2c20  or(chamfer2,4), 
+0000bd80: 2263 6861 6d66 6572 3220 6d75 7374 2062  "chamfer2 must b
+0000bd90: 6520 6120 6e75 6d62 6572 206f 7220 342d  e a number or 4-
+0000bda0: 7665 6374 6f72 2229 0a20 2020 2020 2020  vector").       
+0000bdb0: 2061 7373 6572 7428 6973 5f75 6e64 6566   assert(is_undef
+0000bdc0: 2869 726f 756e 6469 6e67 2920 7c7c 2069  (irounding) || i
+0000bdd0: 735f 6e75 6d28 6972 6f75 6e64 696e 6729  s_num(irounding)
+0000bde0: 207c 7c20 2869 735f 6c69 7374 2869 726f   || (is_list(iro
+0000bdf0: 756e 6469 6e67 2920 2626 206c 656e 2869  unding) && len(i
+0000be00: 726f 756e 6469 6e67 293d 3d34 292c 2022  rounding)==4), "
+0000be10: 6972 6f75 6e64 696e 6720 6d75 7374 2062  irounding must b
+0000be20: 6520 6120 6e75 6d62 6572 206f 7220 342d  e a number or 4-
+0000be30: 7665 6374 6f72 2229 0a20 2020 2020 2020  vector").       
+0000be40: 2061 7373 6572 7428 6973 5f75 6e64 6566   assert(is_undef
+0000be50: 2869 726f 756e 6469 6e67 3129 207c 7c20  (irounding1) || 
+0000be60: 6973 5f6e 756d 2869 726f 756e 6469 6e67  is_num(irounding
+0000be70: 3129 207c 7c20 2869 735f 6c69 7374 2869  1) || (is_list(i
+0000be80: 726f 756e 6469 6e67 3129 2026 2620 6c65  rounding1) && le
+0000be90: 6e28 6972 6f75 6e64 696e 6731 293d 3d34  n(irounding1)==4
+0000bea0: 292c 2022 6972 6f75 6e64 696e 6731 206d  ), "irounding1 m
+0000beb0: 7573 7420 6265 2061 206e 756d 6265 7220  ust be a number 
+0000bec0: 6f72 2034 2d76 6563 746f 7222 290a 2020  or 4-vector").  
+0000bed0: 2020 2020 2020 6173 7365 7274 2869 735f        assert(is_
+0000bee0: 756e 6465 6628 6972 6f75 6e64 696e 6732  undef(irounding2
+0000bef0: 2920 7c7c 2069 735f 6e75 6d28 6972 6f75  ) || is_num(irou
+0000bf00: 6e64 696e 6732 2920 7c7c 2028 6973 5f6c  nding2) || (is_l
+0000bf10: 6973 7428 6972 6f75 6e64 696e 6732 2920  ist(irounding2) 
+0000bf20: 2626 206c 656e 2869 726f 756e 6469 6e67  && len(irounding
+0000bf30: 3229 3d3d 3429 2c20 2269 726f 756e 6469  2)==4), "iroundi
+0000bf40: 6e67 3220 6d75 7374 2062 6520 6120 6e75  ng2 must be a nu
+0000bf50: 6d62 6572 206f 7220 342d 7665 6374 6f72  mber or 4-vector
+0000bf60: 2229 2020 2020 2020 0a20 2020 2020 2020  ")      .       
+0000bf70: 2061 7373 6572 7428 6973 5f75 6e64 6566   assert(is_undef
+0000bf80: 2869 6368 616d 6665 7229 207c 7c20 6973  (ichamfer) || is
+0000bf90: 5f6e 756d 2869 6368 616d 6665 7229 207c  _num(ichamfer) |
+0000bfa0: 7c20 2869 735f 6c69 7374 2869 6368 616d  | (is_list(icham
+0000bfb0: 6665 7229 2026 2620 6c65 6e28 6963 6861  fer) && len(icha
+0000bfc0: 6d66 6572 293d 3d34 292c 2022 6963 6861  mfer)==4), "icha
+0000bfd0: 6d66 6572 206d 7573 7420 6265 2061 206e  mfer must be a n
+0000bfe0: 756d 6265 7220 6f72 2034 2d76 6563 746f  umber or 4-vecto
+0000bff0: 7222 290a 2020 2020 2020 2020 6173 7365  r").        asse
+0000c000: 7274 2869 735f 756e 6465 6628 6963 6861  rt(is_undef(icha
+0000c010: 6d66 6572 3129 207c 7c20 6973 5f6e 756d  mfer1) || is_num
+0000c020: 2869 6368 616d 6665 7231 2920 7c7c 2028  (ichamfer1) || (
+0000c030: 6973 5f6c 6973 7428 6963 6861 6d66 6572  is_list(ichamfer
+0000c040: 3129 2026 2620 6c65 6e28 6963 6861 6d66  1) && len(ichamf
+0000c050: 6572 3129 3d3d 3429 2c20 2269 6368 616d  er1)==4), "icham
+0000c060: 6665 7231 206d 7573 7420 6265 2061 206e  fer1 must be a n
+0000c070: 756d 6265 7220 6f72 2034 2d76 6563 746f  umber or 4-vecto
+0000c080: 7222 290a 2020 2020 2020 2020 6173 7365  r").        asse
+0000c090: 7274 2869 735f 756e 6465 6628 6963 6861  rt(is_undef(icha
+0000c0a0: 6d66 6572 3229 207c 7c20 6973 5f6e 756d  mfer2) || is_num
+0000c0b0: 2869 6368 616d 6665 7232 2920 7c7c 2028  (ichamfer2) || (
+0000c0c0: 6973 5f6c 6973 7428 6963 6861 6d66 6572  is_list(ichamfer
+0000c0d0: 3229 2026 2620 6c65 6e28 6963 6861 6d66  2) && len(ichamf
+0000c0e0: 6572 3229 3d3d 3429 2c20 2269 6368 616d  er2)==4), "icham
+0000c0f0: 6665 7232 206d 7573 7420 6265 2061 206e  fer2 must be a n
+0000c100: 756d 6265 7220 6f72 2034 2d76 6563 746f  umber or 4-vecto
+0000c110: 7222 293b 0a20 2020 2063 6861 6d66 6572  r");.    chamfer
+0000c120: 313d 666f 7263 655f 6c69 7374 2864 6566  1=force_list(def
+0000c130: 6175 6c74 2863 6861 6d66 6572 312c 6368  ault(chamfer1,ch
+0000c140: 616d 6665 7229 2c34 293b 0a20 2020 2063  amfer),4);.    c
+0000c150: 6861 6d66 6572 323d 666f 7263 655f 6c69  hamfer2=force_li
+0000c160: 7374 2864 6566 6175 6c74 2863 6861 6d66  st(default(chamf
+0000c170: 6572 322c 6368 616d 6665 7229 2c34 293b  er2,chamfer),4);
+0000c180: 0a20 2020 2072 6f75 6e64 696e 6731 3d66  .    rounding1=f
+0000c190: 6f72 6365 5f6c 6973 7428 6465 6661 756c  orce_list(defaul
+0000c1a0: 7428 726f 756e 6469 6e67 312c 726f 756e  t(rounding1,roun
+0000c1b0: 6469 6e67 292c 3429 3b0a 2020 2020 726f  ding),4);.    ro
+0000c1c0: 756e 6469 6e67 323d 666f 7263 655f 6c69  unding2=force_li
+0000c1d0: 7374 2864 6566 6175 6c74 2872 6f75 6e64  st(default(round
+0000c1e0: 696e 6732 2c72 6f75 6e64 696e 6729 2c34  ing2,rounding),4
+0000c1f0: 293b 0a20 2020 2063 6865 636b 7333 203d  );.    checks3 =
+0000c200: 0a20 2020 2020 2020 2061 7373 6572 7428  .        assert(
+0000c210: 616c 6c5f 6e6f 6e6e 6567 6174 6976 6528  all_nonnegative(
+0000c220: 6368 616d 6665 7231 292c 2022 6368 616d  chamfer1), "cham
+0000c230: 6665 722f 6368 616d 6665 7231 206d 7573  fer/chamfer1 mus
+0000c240: 7420 6265 206e 6f6e 2d6e 6567 6174 6976  t be non-negativ
+0000c250: 6522 290a 2020 2020 2020 2020 6173 7365  e").        asse
+0000c260: 7274 2861 6c6c 5f6e 6f6e 6e65 6761 7469  rt(all_nonnegati
+0000c270: 7665 2863 6861 6d66 6572 3229 2c20 2263  ve(chamfer2), "c
+0000c280: 6861 6d66 6572 2f63 6861 6d66 6572 3220  hamfer/chamfer2 
+0000c290: 6d75 7374 2062 6520 6e6f 6e2d 6e65 6761  must be non-nega
+0000c2a0: 7469 7665 2229 0a20 2020 2020 2020 2061  tive").        a
+0000c2b0: 7373 6572 7428 616c 6c5f 6e6f 6e6e 6567  ssert(all_nonneg
+0000c2c0: 6174 6976 6528 726f 756e 6469 6e67 3129  ative(rounding1)
+0000c2d0: 2c20 2272 6f75 6e64 696e 672f 726f 756e  , "rounding/roun
+0000c2e0: 6469 6e67 3120 6d75 7374 2062 6520 6e6f  ding1 must be no
+0000c2f0: 6e2d 6e65 6761 7469 7665 2229 0a20 2020  n-negative").   
+0000c300: 2020 2020 2061 7373 6572 7428 616c 6c5f       assert(all_
+0000c310: 6e6f 6e6e 6567 6174 6976 6528 726f 756e  nonnegative(roun
+0000c320: 6469 6e67 3229 2c20 2272 6f75 6e64 696e  ding2), "roundin
+0000c330: 672f 726f 756e 6469 6e67 3220 6d75 7374  g/rounding2 must
+0000c340: 2062 6520 6e6f 6e2d 6e65 6761 7469 7665   be non-negative
+0000c350: 2229 2020 2020 2020 2020 0a20 2020 2020  ")        .     
+0000c360: 2020 2061 7373 6572 7428 616c 6c5f 7a65     assert(all_ze
+0000c370: 726f 2876 5f6d 756c 2872 6f75 6e64 696e  ro(v_mul(roundin
+0000c380: 6731 2c63 6861 6d66 6572 3129 2c30 292c  g1,chamfer1),0),
+0000c390: 2022 726f 756e 6469 6e67 3120 616e 6420   "rounding1 and 
+0000c3a0: 6368 616d 6665 7231 2028 706f 7373 6962  chamfer1 (possib
+0000c3b0: 6c79 2069 6e68 6572 6974 6564 2066 726f  ly inherited fro
+0000c3c0: 6d20 726f 756e 6469 6e67 2061 6e64 2063  m rounding and c
+0000c3d0: 6861 6d66 6572 2920 6361 6e6e 6f74 2062  hamfer) cannot b
+0000c3e0: 6f74 6820 6265 206e 6f6e 7a65 726f 2061  oth be nonzero a
+0000c3f0: 7420 7468 6520 7361 6d65 2063 6f72 6e65  t the same corne
+0000c400: 7222 290a 2020 2020 2020 2020 6173 7365  r").        asse
+0000c410: 7274 2861 6c6c 5f7a 6572 6f28 765f 6d75  rt(all_zero(v_mu
+0000c420: 6c28 726f 756e 6469 6e67 322c 6368 616d  l(rounding2,cham
+0000c430: 6665 7232 292c 3029 2c20 2272 6f75 6e64  fer2),0), "round
+0000c440: 696e 6732 2061 6e64 2063 6861 6d66 6572  ing2 and chamfer
+0000c450: 3220 2870 6f73 7369 626c 7920 696e 6865  2 (possibly inhe
+0000c460: 7269 7465 6420 6672 6f6d 2072 6f75 6e64  rited from round
+0000c470: 696e 6720 616e 6420 6368 616d 6665 7229  ing and chamfer)
+0000c480: 2063 616e 6e6f 7420 626f 7468 2062 6520   cannot both be 
+0000c490: 6e6f 6e7a 6572 6f20 6174 2074 6865 2073  nonzero at the s
+0000c4a0: 616d 6520 636f 726e 6572 2229 3b0a 2020  ame corner");.  
+0000c4b0: 2020 6972 6f75 6e64 696e 6731 5f74 656d    irounding1_tem
+0000c4c0: 7020 3d20 666f 7263 655f 6c69 7374 2864  p = force_list(d
+0000c4d0: 6566 6175 6c74 2869 726f 756e 6469 6e67  efault(irounding
+0000c4e0: 312c 6972 6f75 6e64 696e 6729 2c34 293b  1,irounding),4);
+0000c4f0: 0a20 2020 2069 726f 756e 6469 6e67 325f  .    irounding2_
+0000c500: 7465 6d70 203d 2066 6f72 6365 5f6c 6973  temp = force_lis
+0000c510: 7428 6465 6661 756c 7428 6972 6f75 6e64  t(default(iround
+0000c520: 696e 6732 2c69 726f 756e 6469 6e67 292c  ing2,irounding),
+0000c530: 3429 3b20 2020 200a 2020 2020 6963 6861  4);    .    icha
+0000c540: 6d66 6572 315f 7465 6d70 203d 2066 6f72  mfer1_temp = for
+0000c550: 6365 5f6c 6973 7428 6465 6661 756c 7428  ce_list(default(
+0000c560: 6963 6861 6d66 6572 312c 6963 6861 6d66  ichamfer1,ichamf
+0000c570: 6572 292c 3429 3b0a 2020 2020 6963 6861  er),4);.    icha
+0000c580: 6d66 6572 325f 7465 6d70 203d 2066 6f72  mfer2_temp = for
+0000c590: 6365 5f6c 6973 7428 6465 6661 756c 7428  ce_list(default(
+0000c5a0: 6963 6861 6d66 6572 322c 6963 6861 6d66  ichamfer2,ichamf
+0000c5b0: 6572 292c 3429 3b0a 2020 2020 6368 6563  er),4);.    chec
+0000c5c0: 6b73 6967 6e72 3120 3d20 5b66 6f72 2865  ksignr1 = [for(e
+0000c5d0: 6e74 7279 3d69 726f 756e 6469 6e67 315f  ntry=irounding1_
+0000c5e0: 7465 6d70 2920 6966 2028 6973 5f64 6566  temp) if (is_def
+0000c5f0: 2865 6e74 7279 2920 2626 2065 6e74 7279  (entry) && entry
+0000c600: 3c30 2920 315d 3d3d 5b5d 3b0a 2020 2020  <0) 1]==[];.    
+0000c610: 6368 6563 6b73 6967 6e72 3220 3d20 5b66  checksignr2 = [f
+0000c620: 6f72 2865 6e74 7279 3d69 726f 756e 6469  or(entry=iroundi
+0000c630: 6e67 325f 7465 6d70 2920 6966 2028 6973  ng2_temp) if (is
+0000c640: 5f64 6566 2865 6e74 7279 2920 2626 2065  _def(entry) && e
+0000c650: 6e74 7279 3c30 2920 315d 3d3d 5b5d 3b20  ntry<0) 1]==[]; 
+0000c660: 2020 200a 2020 2020 6368 6563 6b73 6967     .    checksig
+0000c670: 6e63 3120 3d20 5b66 6f72 2865 6e74 7279  nc1 = [for(entry
+0000c680: 3d69 6368 616d 6665 7231 5f74 656d 7029  =ichamfer1_temp)
+0000c690: 2069 6620 2869 735f 6465 6628 656e 7472   if (is_def(entr
+0000c6a0: 7929 2026 2620 656e 7472 793c 3029 2031  y) && entry<0) 1
+0000c6b0: 5d3d 3d5b 5d3b 0a20 2020 2063 6865 636b  ]==[];.    check
+0000c6c0: 7369 676e 6332 203d 205b 666f 7228 656e  signc2 = [for(en
+0000c6d0: 7472 793d 6963 6861 6d66 6572 325f 7465  try=ichamfer2_te
+0000c6e0: 6d70 2920 6966 2028 6973 5f64 6566 2865  mp) if (is_def(e
+0000c6f0: 6e74 7279 2920 2626 2065 6e74 7279 3c30  ntry) && entry<0
+0000c700: 2920 315d 3d3d 5b5d 3b0a 2020 2020 6368  ) 1]==[];.    ch
+0000c710: 6563 6b63 6f6e 666c 6963 7431 203d 205b  eckconflict1 = [
+0000c720: 666f 7228 693d 5b30 3a33 5d29 2069 6620  for(i=[0:3]) if 
+0000c730: 2869 735f 6465 6628 6972 6f75 6e64 696e  (is_def(iroundin
+0000c740: 6731 5f74 656d 705b 695d 2920 2626 2069  g1_temp[i]) && i
+0000c750: 735f 6465 6628 6963 6861 6d66 6572 315f  s_def(ichamfer1_
+0000c760: 7465 6d70 5b69 5d29 2026 2620 6972 6f75  temp[i]) && irou
+0000c770: 6e64 696e 6731 5f74 656d 705b 695d 213d  nding1_temp[i]!=
+0000c780: 3020 2626 2069 6368 616d 6665 7231 5f74  0 && ichamfer1_t
+0000c790: 656d 705b 695d 213d 3029 2031 5d3d 3d5b  emp[i]!=0) 1]==[
+0000c7a0: 5d3b 0a20 2020 2063 6865 636b 636f 6e66  ];.    checkconf
+0000c7b0: 6c69 6374 3220 3d20 5b66 6f72 2869 3d5b  lict2 = [for(i=[
+0000c7c0: 303a 335d 2920 6966 2028 6973 5f64 6566  0:3]) if (is_def
+0000c7d0: 2869 726f 756e 6469 6e67 325f 7465 6d70  (irounding2_temp
+0000c7e0: 5b69 5d29 2026 2620 6973 5f64 6566 2869  [i]) && is_def(i
+0000c7f0: 6368 616d 6665 7232 5f74 656d 705b 695d  chamfer2_temp[i]
+0000c800: 2920 2626 2069 726f 756e 6469 6e67 325f  ) && irounding2_
+0000c810: 7465 6d70 5b69 5d21 3d30 2026 2620 6963  temp[i]!=0 && ic
+0000c820: 6861 6d66 6572 325f 7465 6d70 5b69 5d21  hamfer2_temp[i]!
+0000c830: 3d30 2920 315d 3d3d 5b5d 3b0a 2020 2020  =0) 1]==[];.    
+0000c840: 6368 6563 6b73 3420 3d0a 2020 2020 2020  checks4 =.      
+0000c850: 2020 6173 7365 7274 2863 6865 636b 7369    assert(checksi
+0000c860: 676e 7231 2c20 2269 726f 756e 6469 6e67  gnr1, "irounding
+0000c870: 2f69 726f 756e 6469 6e67 3120 6d75 7374  /irounding1 must
+0000c880: 2062 6520 6e6f 6e2d 6e65 6761 7469 7665   be non-negative
+0000c890: 2229 0a20 2020 2020 2020 2061 7373 6572  ").        asser
+0000c8a0: 7428 6368 6563 6b73 6967 6e72 322c 2022  t(checksignr2, "
+0000c8b0: 6972 6f75 6e64 696e 672f 6972 6f75 6e64  irounding/iround
+0000c8c0: 696e 6732 206d 7573 7420 6265 206e 6f6e  ing2 must be non
+0000c8d0: 2d6e 6567 6174 6976 6522 290a 2020 2020  -negative").    
+0000c8e0: 2020 2020 6173 7365 7274 2863 6865 636b      assert(check
+0000c8f0: 7369 676e 6331 2c20 2269 6368 616d 6665  signc1, "ichamfe
+0000c900: 722f 6963 6861 6d66 6572 3120 6d75 7374  r/ichamfer1 must
+0000c910: 2062 6520 6e6f 6e2d 6e65 6761 7469 7665   be non-negative
+0000c920: 2229 0a20 2020 2020 2020 2061 7373 6572  ").        asser
+0000c930: 7428 6368 6563 6b73 6967 6e63 322c 2022  t(checksignc2, "
+0000c940: 6963 6861 6d66 6572 2f69 6368 616d 6665  ichamfer/ichamfe
+0000c950: 7232 206d 7573 7420 6265 206e 6f6e 2d6e  r2 must be non-n
+0000c960: 6567 6174 6976 6522 290a 2020 2020 2020  egative").      
+0000c970: 2020 6173 7365 7274 2863 6865 636b 636f    assert(checkco
+0000c980: 6e66 6c69 6374 312c 2022 6972 6f75 6e64  nflict1, "iround
+0000c990: 696e 6731 2061 6e64 2069 6368 616d 6665  ing1 and ichamfe
+0000c9a0: 7231 2028 706f 7373 6962 6c79 2069 6e68  r1 (possibly inh
+0000c9b0: 6572 6974 6564 2066 726f 6d20 6972 6f75  erited from irou
+0000c9c0: 6e64 696e 6720 616e 6420 6963 6861 6d66  nding and ichamf
+0000c9d0: 6572 2920 6361 6e6e 6f74 2062 6f74 6820  er) cannot both 
+0000c9e0: 6265 206e 6f6e 7a65 726f 2061 7420 7468  be nonzero at th
+0000c9f0: 6520 7377 616d 6520 636f 726e 6572 2229  e swame corner")
+0000ca00: 0a20 2020 2020 2020 2061 7373 6572 7428  .        assert(
+0000ca10: 6368 6563 6b63 6f6e 666c 6963 7432 2c20  checkconflict2, 
+0000ca20: 2269 726f 756e 6469 6e67 3220 616e 6420  "irounding2 and 
+0000ca30: 6963 6861 6d66 6572 3220 2870 6f73 7369  ichamfer2 (possi
+0000ca40: 626c 7920 696e 6865 7269 7465 6420 6672  bly inherited fr
+0000ca50: 6f6d 2069 726f 756e 6469 6e67 2061 6e64  om irounding and
+0000ca60: 2069 6368 616d 6665 7229 2063 616e 6e6f   ichamfer) canno
+0000ca70: 7420 626f 7468 2062 6520 6e6f 6e7a 6572  t both be nonzer
+0000ca80: 6f20 6174 2074 6865 2073 7761 6d65 2063  o at the swame c
+0000ca90: 6f72 6e65 7222 293b 0a20 2020 2069 726f  orner");.    iro
+0000caa0: 756e 6469 6e67 3120 3d20 5f72 6563 745f  unding1 = _rect_
+0000cab0: 7475 6265 5f72 6f75 6e64 696e 6728 312c  tube_rounding(1,
+0000cac0: 6972 6f75 6e64 696e 6731 5f74 656d 702c  irounding1_temp,
+0000cad0: 2072 6f75 6e64 696e 6731 2c20 6963 6861   rounding1, icha
+0000cae0: 6d66 6572 315f 7465 6d70 2c20 7369 7a65  mfer1_temp, size
+0000caf0: 312c 2069 7369 7a65 3129 3b0a 2020 2020  1, isize1);.    
+0000cb00: 6972 6f75 6e64 696e 6732 203d 205f 7265  irounding2 = _re
+0000cb10: 6374 5f74 7562 655f 726f 756e 6469 6e67  ct_tube_rounding
+0000cb20: 2831 2c69 726f 756e 6469 6e67 325f 7465  (1,irounding2_te
+0000cb30: 6d70 2c20 726f 756e 6469 6e67 322c 2069  mp, rounding2, i
+0000cb40: 6368 616d 6665 7232 5f74 656d 702c 2073  chamfer2_temp, s
+0000cb50: 697a 6532 2c20 6973 697a 6532 293b 0a20  ize2, isize2);. 
+0000cb60: 2020 2069 6368 616d 6665 7231 203d 205f     ichamfer1 = _
+0000cb70: 7265 6374 5f74 7562 655f 726f 756e 6469  rect_tube_roundi
+0000cb80: 6e67 2831 2f73 7172 7428 3229 2c69 6368  ng(1/sqrt(2),ich
+0000cb90: 616d 6665 7231 5f74 656d 702c 2063 6861  amfer1_temp, cha
+0000cba0: 6d66 6572 312c 2069 726f 756e 6469 6e67  mfer1, irounding
+0000cbb0: 315f 7465 6d70 2c20 7369 7a65 312c 2069  1_temp, size1, i
+0000cbc0: 7369 7a65 3129 3b0a 2020 2020 6963 6861  size1);.    icha
+0000cbd0: 6d66 6572 3220 3d20 5f72 6563 745f 7475  mfer2 = _rect_tu
+0000cbe0: 6265 5f72 6f75 6e64 696e 6728 312f 7371  be_rounding(1/sq
+0000cbf0: 7274 2832 292c 6963 6861 6d66 6572 325f  rt(2),ichamfer2_
+0000cc00: 7465 6d70 2c20 6368 616d 6665 7232 2c20  temp, chamfer2, 
+0000cc10: 6972 6f75 6e64 696e 6732 5f74 656d 702c  irounding2_temp,
+0000cc20: 2073 697a 6532 2c20 6973 697a 6532 293b   size2, isize2);
+0000cc30: 0a20 2020 2061 6e63 686f 7220 3d20 6765  .    anchor = ge
+0000cc40: 745f 616e 6368 6f72 2861 6e63 686f 722c  t_anchor(anchor,
+0000cc50: 2063 656e 7465 722c 2042 4f54 2c20 424f   center, BOT, BO
+0000cc60: 5429 3b0a 2020 2020 6174 7461 6368 6162  T);.    attachab
+0000cc70: 6c65 2861 6e63 686f 722c 7370 696e 2c6f  le(anchor,spin,o
+0000cc80: 7269 656e 742c 2073 697a 653d 5b65 6163  rient, size=[eac
+0000cc90: 6820 7369 7a65 312c 2068 5d2c 2073 697a  h size1, h], siz
+0000cca0: 6532 3d73 697a 6532 2c20 7368 6966 743d  e2=size2, shift=
+0000ccb0: 7368 6966 7429 207b 0a20 2020 2020 2020  shift) {.       
+0000ccc0: 2064 6f77 6e28 682f 3229 207b 0a20 2020   down(h/2) {.   
+0000ccd0: 2020 2020 2020 2020 2064 6966 6665 7265           differe
+0000cce0: 6e63 6528 2920 7b0a 2020 2020 2020 2020  nce() {.        
+0000ccf0: 2020 2020 2020 2020 7072 6973 6d6f 6964          prismoid
+0000cd00: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000cd10: 2020 2020 2020 7369 7a65 312c 2073 697a        size1, siz
+0000cd20: 6532 2c20 683d 682c 2073 6869 6674 3d73  e2, h=h, shift=s
+0000cd30: 6869 6674 2c0a 2020 2020 2020 2020 2020  hift,.          
+0000cd40: 2020 2020 2020 2020 2020 726f 756e 6469            roundi
+0000cd50: 6e67 313d 726f 756e 6469 6e67 312c 2072  ng1=rounding1, r
+0000cd60: 6f75 6e64 696e 6732 3d72 6f75 6e64 696e  ounding2=roundin
+0000cd70: 6732 2c0a 2020 2020 2020 2020 2020 2020  g2,.            
+0000cd80: 2020 2020 2020 2020 6368 616d 6665 7231          chamfer1
+0000cd90: 3d63 6861 6d66 6572 312c 2063 6861 6d66  =chamfer1, chamf
+0000cda0: 6572 323d 6368 616d 6665 7232 2c0a 2020  er2=chamfer2,.  
+0000cdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdc0: 2020 616e 6368 6f72 3d42 4f54 0a20 2020    anchor=BOT.   
+0000cdd0: 2020 2020 2020 2020 2020 2020 2029 3b0a               );.
+0000cde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdf0: 646f 776e 2830 2e30 3129 2070 7269 736d  down(0.01) prism
+0000ce00: 6f69 6428 0a20 2020 2020 2020 2020 2020  oid(.           
+0000ce10: 2020 2020 2020 2020 2069 7369 7a65 312c           isize1,
+0000ce20: 2069 7369 7a65 322c 2068 3d68 2b30 2e30   isize2, h=h+0.0
+0000ce30: 322c 2073 6869 6674 3d73 6869 6674 2c0a  2, shift=shift,.
+0000ce40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce50: 2020 2020 726f 756e 6469 6e67 313d 6972      rounding1=ir
+0000ce60: 6f75 6e64 696e 6731 2c20 726f 756e 6469  ounding1, roundi
+0000ce70: 6e67 323d 6972 6f75 6e64 696e 6732 2c0a  ng2=irounding2,.
+0000ce80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce90: 2020 2020 6368 616d 6665 7231 3d69 6368      chamfer1=ich
+0000cea0: 616d 6665 7231 2c20 6368 616d 6665 7232  amfer1, chamfer2
+0000ceb0: 3d69 6368 616d 6665 7232 2c0a 2020 2020  =ichamfer2,.    
+0000cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ced0: 616e 6368 6f72 3d42 4f54 0a20 2020 2020  anchor=BOT.     
+0000cee0: 2020 2020 2020 2020 2020 2029 3b0a 2020             );.  
+0000cef0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+0000cf00: 2020 2020 7d0a 2020 2020 2020 2020 6368      }.        ch
+0000cf10: 696c 6472 656e 2829 3b0a 2020 2020 7d0a  ildren();.    }.
+0000cf20: 7d0a 0a66 756e 6374 696f 6e20 7265 6374  }..function rect
+0000cf30: 5f74 7562 6528 0a20 2020 2068 2c20 7369  _tube(.    h, si
+0000cf40: 7a65 2c20 6973 697a 652c 2063 656e 7465  ze, isize, cente
+0000cf50: 722c 2073 6869 6674 3d5b 302c 305d 2c0a  r, shift=[0,0],.
+0000cf60: 2020 2020 7761 6c6c 2c20 7369 7a65 312c      wall, size1,
+0000cf70: 2073 697a 6532 2c20 6973 697a 6531 2c20   size2, isize1, 
+0000cf80: 6973 697a 6532 2c0a 2020 2020 726f 756e  isize2,.    roun
+0000cf90: 6469 6e67 3d30 2c20 726f 756e 6469 6e67  ding=0, rounding
+0000cfa0: 312c 2072 6f75 6e64 696e 6732 2c0a 2020  1, rounding2,.  
+0000cfb0: 2020 6972 6f75 6e64 696e 672c 2069 726f    irounding, iro
+0000cfc0: 756e 6469 6e67 312c 2069 726f 756e 6469  unding1, iroundi
+0000cfd0: 6e67 322c 0a20 2020 2063 6861 6d66 6572  ng2,.    chamfer
+0000cfe0: 3d30 2c20 6368 616d 6665 7231 2c20 6368  =0, chamfer1, ch
+0000cff0: 616d 6665 7232 2c0a 2020 2020 6963 6861  amfer2,.    icha
+0000d000: 6d66 6572 2c20 6963 6861 6d66 6572 312c  mfer, ichamfer1,
+0000d010: 2069 6368 616d 6665 7232 2c0a 2020 2020   ichamfer2,.    
+0000d020: 616e 6368 6f72 2c20 7370 696e 3d30 2c20  anchor, spin=0, 
+0000d030: 6f72 6965 6e74 3d55 502c 0a20 2020 206c  orient=UP,.    l
+0000d040: 2c20 6c65 6e67 7468 2c20 6865 6967 6874  , length, height
+0000d050: 0a29 203d 206e 6f5f 6675 6e63 7469 6f6e  .) = no_function
+0000d060: 2822 7265 6374 5f74 7562 6522 293b 0a0a  ("rect_tube");..
+0000d070: 0a2f 2f20 4675 6e63 7469 6f6e 264d 6f64  .// Function&Mod
+0000d080: 756c 653a 2077 6564 6765 2829 0a2f 2f20  ule: wedge().// 
+0000d090: 5379 6e6f 7073 6973 3a20 4372 6561 7465  Synopsis: Create
+0000d0a0: 7320 6120 3364 2074 7269 616e 6775 6c61  s a 3d triangula
+0000d0b0: 7220 7765 6467 652c 206f 7220 7265 7475  r wedge, or retu
+0000d0c0: 726e 7320 6120 766e 662e 0a2f 2f20 546f  rns a vnf..// To
+0000d0d0: 7069 6373 3a20 5368 6170 6573 2028 3344  pics: Shapes (3D
+0000d0e0: 292c 2041 7474 6163 6861 626c 652c 2056  ), Attachable, V
+0000d0f0: 4e46 2047 656e 6572 6174 6f72 730a 2f2f  NF Generators.//
+0000d100: 2053 6565 2061 6c73 6f3a 2070 7269 736d   See also: prism
+0000d110: 6f69 6428 292c 2072 6f75 6e64 6564 5f70  oid(), rounded_p
+0000d120: 7269 736d 2829 2c20 7069 655f 736c 6963  rism(), pie_slic
+0000d130: 6528 290a 2f2f 2055 7361 6765 3a20 4173  e().// Usage: As
+0000d140: 204d 6f64 756c 650a 2f2f 2020 2077 6564   Module.//   wed
+0000d150: 6765 2873 697a 652c 205b 6365 6e74 6572  ge(size, [center
+0000d160: 5d2c 202e 2e2e 2920 5b41 5454 4143 484d  ], ...) [ATTACHM
+0000d170: 454e 5453 5d3b 0a2f 2f20 5573 6167 653a  ENTS];.// Usage:
+0000d180: 2041 7320 4675 6e63 7469 6f6e 0a2f 2f20   As Function.// 
+0000d190: 2020 766e 6620 3d20 7765 6467 6528 7369    vnf = wedge(si
+0000d1a0: 7a65 2c20 5b63 656e 7465 725d 2c20 2e2e  ze, [center], ..
+0000d1b0: 2e29 3b0a 2f2f 0a2f 2f20 4465 7363 7269  .);.//.// Descri
+0000d1c0: 7074 696f 6e3a 0a2f 2f20 2020 5768 656e  ption:.//   When
+0000d1d0: 2063 616c 6c65 6420 6173 2061 206d 6f64   called as a mod
+0000d1e0: 756c 652c 2063 7265 6174 6573 2061 2033  ule, creates a 3
+0000d1f0: 4420 7472 6961 6e67 756c 6172 2077 6564  D triangular wed
+0000d200: 6765 2077 6974 6820 7468 6520 6879 706f  ge with the hypo
+0000d210: 7465 6e75 7365 2069 6e20 7468 6520 582b  tenuse in the X+
+0000d220: 5a2b 2071 7561 6472 616e 742e 0a2f 2f20  Z+ quadrant..// 
+0000d230: 2020 5768 656e 2063 616c 6c65 6420 6173    When called as
+0000d240: 2061 2066 756e 6374 696f 6e2c 2063 7265   a function, cre
+0000d250: 6174 6573 2061 2056 4e46 2066 6f72 2061  ates a VNF for a
+0000d260: 2033 4420 7472 6961 6e67 756c 6172 2077   3D triangular w
+0000d270: 6564 6765 2077 6974 6820 7468 6520 6879  edge with the hy
+0000d280: 706f 7465 6e75 7365 2069 6e20 7468 6520  potenuse in the 
+0000d290: 582b 5a2b 2071 7561 6472 616e 742e 0a2f  X+Z+ quadrant../
+0000d2a0: 2f0a 2f2f 2041 7267 756d 656e 7473 3a0a  /.// Arguments:.
+0000d2b0: 2f2f 2020 2073 697a 6520 3d20 5b77 6964  //   size = [wid
+0000d2c0: 7468 2c20 7468 6963 6b6e 6573 732c 2068  th, thickness, h
+0000d2d0: 6569 6768 745d 0a2f 2f20 2020 6365 6e74  eight].//   cent
+0000d2e0: 6572 203d 2049 6620 6769 7665 6e2c 206f  er = If given, o
+0000d2f0: 7665 7272 6964 6573 2060 616e 6368 6f72  verrides `anchor
+0000d300: 602e 2020 4120 7472 7565 2076 616c 7565  `.  A true value
+0000d310: 2073 6574 7320 6061 6e63 686f 723d 4345   sets `anchor=CE
+0000d320: 4e54 4552 602c 2066 616c 7365 2073 6574  NTER`, false set
+0000d330: 7320 6061 6e63 686f 723d 5550 602e 0a2f  s `anchor=UP`../
+0000d340: 2f20 2020 2d2d 2d0a 2f2f 2020 2061 6e63  /   ---.//   anc
+0000d350: 686f 7220 3d20 5472 616e 736c 6174 6520  hor = Translate 
+0000d360: 736f 2061 6e63 686f 7220 706f 696e 7420  so anchor point 
+0000d370: 6973 2061 7420 6f72 6967 696e 2028 302c  is at origin (0,
+0000d380: 302c 3029 2e20 2053 6565 205b 616e 6368  0,0).  See [anch
+0000d390: 6f72 5d28 6174 7461 6368 6d65 6e74 732e  or](attachments.
+0000d3a0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
+0000d3b0: 616e 6368 6f72 292e 2020 4465 6661 756c  anchor).  Defaul
+0000d3c0: 743a 2060 4652 4f4e 542b 4c45 4654 2b42  t: `FRONT+LEFT+B
+0000d3d0: 4f54 544f 4d60 0a2f 2f20 2020 7370 696e  OTTOM`.//   spin
+0000d3e0: 203d 2052 6f74 6174 6520 7468 6973 206d   = Rotate this m
+0000d3f0: 616e 7920 6465 6772 6565 7320 6172 6f75  any degrees arou
+0000d400: 6e64 2074 6865 205a 2061 7869 7320 6166  nd the Z axis af
+0000d410: 7465 7220 616e 6368 6f72 2e20 2053 6565  ter anchor.  See
+0000d420: 205b 7370 696e 5d28 6174 7461 6368 6d65   [spin](attachme
+0000d430: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+0000d440: 696f 6e2d 7370 696e 292e 2020 4465 6661  ion-spin).  Defa
+0000d450: 756c 743a 2060 3060 0a2f 2f20 2020 6f72  ult: `0`.//   or
+0000d460: 6965 6e74 203d 2056 6563 746f 7220 746f  ient = Vector to
+0000d470: 2072 6f74 6174 6520 746f 7020 746f 7761   rotate top towa
+0000d480: 7264 732c 2061 6674 6572 2073 7069 6e2e  rds, after spin.
+0000d490: 2020 5365 6520 5b6f 7269 656e 745d 2861    See [orient](a
+0000d4a0: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
+0000d4b0: 7375 6273 6563 7469 6f6e 2d6f 7269 656e  subsection-orien
+0000d4c0: 7429 2e20 2044 6566 6175 6c74 3a20 6055  t).  Default: `U
+0000d4d0: 5060 0a2f 2f0a 2f2f 2045 7874 7261 2041  P`.//.// Extra A
+0000d4e0: 6e63 686f 7273 3a0a 2f2f 2020 2068 7970  nchors:.//   hyp
+0000d4f0: 6f74 203d 2043 656e 7465 7220 6f66 2061  ot = Center of a
+0000d500: 6e67 6c65 6420 7765 6467 6520 6661 6365  ngled wedge face
+0000d510: 2c20 7065 7270 656e 6469 6375 6c61 7220  , perpendicular 
+0000d520: 746f 2074 6861 7420 6661 6365 2e0a 2f2f  to that face..//
+0000d530: 2020 2068 7970 6f74 5f6c 6566 7420 3d20     hypot_left = 
+0000d540: 4c65 6674 2073 6964 6520 6f66 2061 6e67  Left side of ang
+0000d550: 6c65 6420 7765 6467 6520 6661 6365 2c20  led wedge face, 
+0000d560: 6269 7365 6374 696e 6720 7468 6520 616e  bisecting the an
+0000d570: 676c 6520 6265 7477 6565 6e20 7468 6520  gle between the 
+0000d580: 6c65 6674 2073 6964 6520 616e 6420 616e  left side and an
+0000d590: 676c 6564 2066 6163 6573 2e0a 2f2f 2020  gled faces..//  
+0000d5a0: 2068 7970 6f74 5f72 6967 6874 203d 2052   hypot_right = R
+0000d5b0: 6967 6874 2073 6964 6520 6f66 2061 6e67  ight side of ang
+0000d5c0: 6c65 6420 7765 6467 6520 6661 6365 2c20  led wedge face, 
+0000d5d0: 6269 7365 6374 696e 6720 7468 6520 616e  bisecting the an
+0000d5e0: 676c 6520 6265 7477 6565 6e20 7468 6520  gle between the 
+0000d5f0: 7269 6768 7420 7369 6465 2061 6e64 2061  right side and a
+0000d600: 6e67 6c65 6420 6661 6365 732e 0a2f 2f0a  ngled faces..//.
+0000d610: 2f2f 2045 7861 6d70 6c65 3a20 4365 6e74  // Example: Cent
+0000d620: 6572 6564 0a2f 2f20 2020 7765 6467 6528  ered.//   wedge(
+0000d630: 5b32 302c 2034 302c 2031 355d 2c20 6365  [20, 40, 15], ce
+0000d640: 6e74 6572 3d74 7275 6529 3b0a 2f2f 2045  nter=true);.// E
+0000d650: 7861 6d70 6c65 3a20 2a4e 6f6e 2a2d 4365  xample: *Non*-Ce
+0000d660: 6e74 6572 6564 0a2f 2f20 2020 7765 6467  ntered.//   wedg
+0000d670: 6528 5b32 302c 2034 302c 2031 355d 293b  e([20, 40, 15]);
+0000d680: 0a2f 2f20 4578 616d 706c 653a 2053 7461  .// Example: Sta
+0000d690: 6e64 6172 6420 416e 6368 6f72 730a 2f2f  ndard Anchors.//
+0000d6a0: 2020 2077 6564 6765 285b 3430 2c20 3830     wedge([40, 80
+0000d6b0: 2c20 3330 5d2c 2063 656e 7465 723d 7472  , 30], center=tr
+0000d6c0: 7565 290a 2f2f 2020 2020 2020 2073 686f  ue).//       sho
+0000d6d0: 775f 616e 6368 6f72 7328 6375 7374 6f6d  w_anchors(custom
+0000d6e0: 3d66 616c 7365 293b 0a2f 2f20 2020 636f  =false);.//   co
+0000d6f0: 6c6f 7228 5b30 2e35 2c30 2e35 2c30 2e35  lor([0.5,0.5,0.5
+0000d700: 2c30 2e31 5d29 0a2f 2f20 2020 2020 2020  ,0.1]).//       
+0000d710: 6375 6265 285b 3430 2c20 3830 2c20 3330  cube([40, 80, 30
+0000d720: 5d2c 2063 656e 7465 723d 7472 7565 293b  ], center=true);
+0000d730: 0a2f 2f20 4578 616d 706c 653a 204e 616d  .// Example: Nam
+0000d740: 6564 2041 6e63 686f 7273 0a2f 2f20 2020  ed Anchors.//   
+0000d750: 7765 6467 6528 5b34 302c 2038 302c 2033  wedge([40, 80, 3
+0000d760: 305d 2c20 6365 6e74 6572 3d74 7275 6529  0], center=true)
+0000d770: 0a2f 2f20 2020 2020 2020 7368 6f77 5f61  .//       show_a
+0000d780: 6e63 686f 7273 2873 7464 3d66 616c 7365  nchors(std=false
+0000d790: 293b 0a0a 6d6f 6475 6c65 2077 6564 6765  );..module wedge
+0000d7a0: 2873 697a 653d 5b31 2c20 312c 2031 5d2c  (size=[1, 1, 1],
+0000d7b0: 2063 656e 7465 722c 2061 6e63 686f 722c   center, anchor,
+0000d7c0: 2073 7069 6e3d 302c 206f 7269 656e 743d   spin=0, orient=
+0000d7d0: 5550 290a 7b0a 2020 2020 7369 7a65 203d  UP).{.    size =
+0000d7e0: 2073 6361 6c61 725f 7665 6333 2873 697a   scalar_vec3(siz
+0000d7f0: 6529 3b0a 2020 2020 616e 6368 6f72 203d  e);.    anchor =
+0000d800: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
+0000d810: 6f72 2c20 6365 6e74 6572 2c20 2d5b 312c  or, center, -[1,
+0000d820: 312c 315d 2c20 2d5b 312c 312c 315d 293b  1,1], -[1,1,1]);
+0000d830: 0a20 2020 2076 6e66 203d 2077 6564 6765  .    vnf = wedge
+0000d840: 2873 697a 652c 2061 6e63 686f 723d 226f  (size, anchor="o
+0000d850: 7269 6769 6e22 293b 0a20 2020 2061 6e63  rigin");.    anc
+0000d860: 686f 7273 203d 205b 0a20 2020 2020 2020  hors = [.       
+0000d870: 206e 616d 6564 5f61 6e63 686f 7228 2268   named_anchor("h
+0000d880: 7970 6f74 222c 2043 5452 2c20 756e 6974  ypot", CTR, unit
+0000d890: 285b 302c 7369 7a65 2e7a 2c73 697a 652e  ([0,size.z,size.
+0000d8a0: 795d 2c55 5029 292c 0a20 2020 2020 2020  y],UP)),.       
+0000d8b0: 206e 616d 6564 5f61 6e63 686f 7228 2268   named_anchor("h
+0000d8c0: 7970 6f74 5f6c 6566 7422 2c20 5b2d 7369  ypot_left", [-si
+0000d8d0: 7a65 2e78 2f32 2c30 2c30 5d2c 2075 6e69  ze.x/2,0,0], uni
+0000d8e0: 7428 756e 6974 285b 302c 7369 7a65 2e7a  t(unit([0,size.z
+0000d8f0: 2c73 697a 652e 795d 2c55 5029 2b4c 4546  ,size.y],UP)+LEF
+0000d900: 5429 292c 0a20 2020 2020 2020 206e 616d  T)),.        nam
+0000d910: 6564 5f61 6e63 686f 7228 2268 7970 6f74  ed_anchor("hypot
+0000d920: 5f72 6967 6874 222c 205b 7369 7a65 2e78  _right", [size.x
+0000d930: 2f32 2c30 2c30 5d2c 2075 6e69 7428 756e  /2,0,0], unit(un
+0000d940: 6974 285b 302c 7369 7a65 2e7a 2c73 697a  it([0,size.z,siz
+0000d950: 652e 795d 2c55 5029 2b52 4947 4854 2929  e.y],UP)+RIGHT))
+0000d960: 2c0a 2020 2020 5d3b 0a20 2020 2061 7474  ,.    ];.    att
+0000d970: 6163 6861 626c 6528 616e 6368 6f72 2c73  achable(anchor,s
+0000d980: 7069 6e2c 6f72 6965 6e74 2c20 7369 7a65  pin,orient, size
+0000d990: 3d73 697a 652c 2061 6e63 686f 7273 3d61  =size, anchors=a
+0000d9a0: 6e63 686f 7273 2920 7b0a 2020 2020 2020  nchors) {.      
+0000d9b0: 2020 6966 2028 7369 7a65 2e7a 203e 2030    if (size.z > 0
+0000d9c0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+0000d9d0: 766e 665f 706f 6c79 6865 6472 6f6e 2876  vnf_polyhedron(v
+0000d9e0: 6e66 293b 0a20 2020 2020 2020 207d 0a20  nf);.        }. 
+0000d9f0: 2020 2020 2020 2063 6869 6c64 7265 6e28         children(
+0000da00: 293b 0a20 2020 207d 0a7d 0a0a 0a66 756e  );.    }.}...fun
+0000da10: 6374 696f 6e20 7765 6467 6528 7369 7a65  ction wedge(size
+0000da20: 3d5b 312c 312c 315d 2c20 6365 6e74 6572  =[1,1,1], center
+0000da30: 2c20 616e 6368 6f72 2c20 7370 696e 3d30  , anchor, spin=0
+0000da40: 2c20 6f72 6965 6e74 3d55 5029 203d 0a20  , orient=UP) =. 
+0000da50: 2020 206c 6574 280a 2020 2020 2020 2020     let(.        
+0000da60: 7369 7a65 203d 2073 6361 6c61 725f 7665  size = scalar_ve
+0000da70: 6333 2873 697a 6529 2c0a 2020 2020 2020  c3(size),.      
+0000da80: 2020 616e 6368 6f72 203d 2067 6574 5f61    anchor = get_a
+0000da90: 6e63 686f 7228 616e 6368 6f72 2c20 6365  nchor(anchor, ce
+0000daa0: 6e74 6572 2c20 2d5b 312c 312c 315d 2c20  nter, -[1,1,1], 
+0000dab0: 2d5b 312c 312c 315d 292c 0a20 2020 2020  -[1,1,1]),.     
+0000dac0: 2020 2070 7473 203d 205b 0a20 2020 2020     pts = [.     
+0000dad0: 2020 2020 2020 205b 2031 2c31 2c2d 315d         [ 1,1,-1]
+0000dae0: 2c20 5b20 312c 2d31 2c2d 315d 2c20 5b20  , [ 1,-1,-1], [ 
+0000daf0: 312c 2d31 2c31 5d2c 0a20 2020 2020 2020  1,-1,1],.       
+0000db00: 2020 2020 205b 2d31 2c31 2c2d 315d 2c20       [-1,1,-1], 
+0000db10: 5b2d 312c 2d31 2c2d 315d 2c20 5b2d 312c  [-1,-1,-1], [-1,
+0000db20: 2d31 2c31 5d2c 0a20 2020 2020 2020 205d  -1,1],.        ]
+0000db30: 2c0a 2020 2020 2020 2020 6661 6365 7320  ,.        faces 
+0000db40: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+0000db50: 5b30 2c31 2c32 5d2c 205b 332c 352c 345d  [0,1,2], [3,5,4]
+0000db60: 2c20 5b30 2c33 2c31 5d2c 205b 312c 332c  , [0,3,1], [1,3,
+0000db70: 345d 2c0a 2020 2020 2020 2020 2020 2020  4],.            
+0000db80: 5b31 2c34 2c32 5d2c 205b 322c 342c 355d  [1,4,2], [2,4,5]
+0000db90: 2c20 5b32 2c35 2c33 5d2c 205b 302c 322c  , [2,5,3], [0,2,
+0000dba0: 335d 2c0a 2020 2020 2020 2020 5d2c 0a20  3],.        ],. 
+0000dbb0: 2020 2020 2020 2076 6e66 203d 205b 7363         vnf = [sc
+0000dbc0: 616c 6528 7369 7a65 2f32 2c70 3d70 7473  ale(size/2,p=pts
+0000dbd0: 292c 2066 6163 6573 5d2c 0a20 2020 2020  ), faces],.     
+0000dbe0: 2020 2061 6e63 686f 7273 203d 205b 0a20     anchors = [. 
+0000dbf0: 2020 2020 2020 2020 2020 206e 616d 6564             named
+0000dc00: 5f61 6e63 686f 7228 2268 7970 6f74 222c  _anchor("hypot",
+0000dc10: 2043 5452 2c20 756e 6974 285b 302c 7369   CTR, unit([0,si
+0000dc20: 7a65 2e7a 2c73 697a 652e 795d 2c55 5029  ze.z,size.y],UP)
+0000dc30: 292c 0a20 2020 2020 2020 2020 2020 206e  ),.            n
+0000dc40: 616d 6564 5f61 6e63 686f 7228 2268 7970  amed_anchor("hyp
+0000dc50: 6f74 5f6c 6566 7422 2c20 5b2d 7369 7a65  ot_left", [-size
+0000dc60: 2e78 2f32 2c30 2c30 5d2c 2075 6e69 7428  .x/2,0,0], unit(
+0000dc70: 756e 6974 285b 302c 7369 7a65 2e7a 2c73  unit([0,size.z,s
+0000dc80: 697a 652e 795d 2c55 5029 2b4c 4546 5429  ize.y],UP)+LEFT)
+0000dc90: 292c 0a20 2020 2020 2020 2020 2020 206e  ),.            n
+0000dca0: 616d 6564 5f61 6e63 686f 7228 2268 7970  amed_anchor("hyp
+0000dcb0: 6f74 5f72 6967 6874 222c 205b 7369 7a65  ot_right", [size
+0000dcc0: 2e78 2f32 2c30 2c30 5d2c 2075 6e69 7428  .x/2,0,0], unit(
+0000dcd0: 756e 6974 285b 302c 7369 7a65 2e7a 2c73  unit([0,size.z,s
+0000dce0: 697a 652e 795d 2c55 5029 2b52 4947 4854  ize.y],UP)+RIGHT
+0000dcf0: 2929 2c0a 2020 2020 2020 2020 5d0a 2020  )),.        ].  
+0000dd00: 2020 290a 2020 2020 7265 6f72 6965 6e74    ).    reorient
+0000dd10: 2861 6e63 686f 722c 7370 696e 2c6f 7269  (anchor,spin,ori
+0000dd20: 656e 742c 2073 697a 653d 7369 7a65 2c20  ent, size=size, 
+0000dd30: 616e 6368 6f72 733d 616e 6368 6f72 732c  anchors=anchors,
+0000dd40: 2070 3d76 6e66 293b 0a0a 0a2f 2f20 5365   p=vnf);...// Se
+0000dd50: 6374 696f 6e3a 2043 796c 696e 6465 7273  ction: Cylinders
+0000dd60: 0a0a 0a2f 2f20 4675 6e63 7469 6f6e 264d  ...// Function&M
+0000dd70: 6f64 756c 653a 2063 796c 696e 6465 7228  odule: cylinder(
+0000dd80: 290a 2f2f 2053 796e 6f70 7369 733a 2043  ).// Synopsis: C
+0000dd90: 7265 6174 6573 2061 6e20 6174 7461 6368  reates an attach
+0000dda0: 6162 6c65 2063 796c 696e 6465 722c 206f  able cylinder, o
+0000ddb0: 7220 7265 7475 726e 7320 6120 766e 662e  r returns a vnf.
+0000ddc0: 0a2f 2f20 546f 7069 6373 3a20 5368 6170  .// Topics: Shap
+0000ddd0: 6573 2028 3344 292c 2041 7474 6163 6861  es (3D), Attacha
+0000dde0: 626c 652c 2056 4e46 2047 656e 6572 6174  ble, VNF Generat
+0000ddf0: 6f72 730a 2f2f 2053 6565 2041 6c73 6f3a  ors.// See Also:
+0000de00: 2063 796c 2829 0a2f 2f20 5573 6167 653a   cyl().// Usage:
+0000de10: 2041 7320 4d6f 6475 6c65 2028 6173 2069   As Module (as i
+0000de20: 6e20 6e61 7469 7665 204f 7065 6e53 4341  n native OpenSCA
+0000de30: 4429 0a2f 2f20 2020 6379 6c69 6e64 6572  D).//   cylinder
+0000de40: 2868 2c20 723d 2f64 3d2c 205b 6365 6e74  (h, r=/d=, [cent
+0000de50: 6572 3d5d 293b 0a2f 2f20 2020 6379 6c69  er=]);.//   cyli
+0000de60: 6e64 6572 2868 2c20 7231 2f64 313d 2c20  nder(h, r1/d1=, 
+0000de70: 7232 2f64 323d 2c20 5b63 656e 7465 723d  r2/d2=, [center=
+0000de80: 5d29 3b0a 2f2f 2055 7361 6765 3a20 5769  ]);.// Usage: Wi
+0000de90: 7468 2042 4f53 4c32 2061 6e63 686f 7269  th BOSL2 anchori
+0000dea0: 6e67 2061 6e64 2061 7474 6163 686d 656e  ng and attachmen
+0000deb0: 7420 6578 7465 6e73 696f 6e73 0a2f 2f20  t extensions.// 
+0000dec0: 2020 6379 6c69 6e64 6572 2868 2c20 723d    cylinder(h, r=
+0000ded0: 2f64 3d2c 205b 6365 6e74 6572 3d5d 2c20  /d=, [center=], 
+0000dee0: 5b61 6e63 686f 723d 5d2c 205b 7370 696e  [anchor=], [spin
+0000def0: 3d5d 2c20 5b6f 7269 656e 743d 5d29 205b  =], [orient=]) [
+0000df00: 4154 5441 4348 4d45 4e54 535d 3b0a 2f2f  ATTACHMENTS];.//
+0000df10: 2020 2063 796c 696e 6465 7228 682c 2072     cylinder(h, r
+0000df20: 312f 6431 3d2c 2072 322f 6432 3d2c 205b  1/d1=, r2/d2=, [
+0000df30: 6365 6e74 6572 3d5d 2c20 5b61 6e63 686f  center=], [ancho
+0000df40: 723d 5d2c 205b 7370 696e 3d5d 2c20 5b6f  r=], [spin=], [o
+0000df50: 7269 656e 743d 5d29 205b 4154 5441 4348  rient=]) [ATTACH
+0000df60: 4d45 4e54 535d 3b0a 2f2f 2055 7361 6765  MENTS];.// Usage
+0000df70: 3a20 4173 2046 756e 6374 696f 6e20 2842  : As Function (B
+0000df80: 4f53 4c32 2065 7874 656e 7369 6f6e 290a  OSL2 extension).
+0000df90: 2f2f 2020 2076 6e66 203d 2063 796c 696e  //   vnf = cylin
+0000dfa0: 6465 7228 682c 2072 3d2f 643d 2c20 2e2e  der(h, r=/d=, ..
+0000dfb0: 2e29 3b0a 2f2f 2020 2076 6e66 203d 2063  .);.//   vnf = c
+0000dfc0: 796c 696e 6465 7228 682c 2072 312f 6431  ylinder(h, r1/d1
+0000dfd0: 3d2c 2072 322f 6432 3d2c 202e 2e2e 293b  =, r2/d2=, ...);
+0000dfe0: 0a2f 2f20 4465 7363 7269 7074 696f 6e3a  .// Description:
+0000dff0: 0a2f 2f20 2020 4372 6561 7465 7320 6120  .//   Creates a 
+0000e000: 3344 2063 796c 696e 6465 7220 6f72 2063  3D cylinder or c
+0000e010: 6f6e 6963 206f 626a 6563 742e 0a2f 2f20  onic object..// 
+0000e020: 2020 5468 6973 206d 6f64 756c 6573 2065    This modules e
+0000e030: 7874 656e 6473 2074 6865 2062 7569 6c74  xtends the built
+0000e040: 2d69 6e20 6063 796c 696e 6465 7228 2960  -in `cylinder()`
+0000e050: 206d 6f64 756c 6520 6279 2061 6464 696e   module by addin
+0000e060: 6720 7375 7070 6f72 7420 666f 7220 6174  g support for at
+0000e070: 7461 6368 6d65 6e74 2061 6e64 2062 7920  tachment and by 
+0000e080: 6164 6469 6e67 2061 2066 756e 6374 696f  adding a functio
+0000e090: 6e20 7665 7273 696f 6e2e 2020 200a 2f2f  n version.   .//
+0000e0a0: 2020 2057 6865 6e20 6361 6c6c 6564 2061     When called a
+0000e0b0: 7320 6120 6675 6e63 7469 6f6e 2c20 7265  s a function, re
+0000e0c0: 7475 726e 7320 6120 5b56 4e46 5d28 766e  turns a [VNF](vn
+0000e0d0: 662e 7363 6164 2920 666f 7220 6120 6379  f.scad) for a cy
+0000e0e0: 6c69 6e64 6572 2e20 200a 2f2f 2041 7267  linder.  .// Arg
+0000e0f0: 756d 656e 7473 3a0a 2f2f 2020 2068 203d  uments:.//   h =
+0000e100: 2054 6865 2068 6569 6768 7420 6f66 2074   The height of t
+0000e110: 6865 2063 796c 696e 6465 722e 0a2f 2f20  he cylinder..// 
+0000e120: 2020 7231 203d 2054 6865 2062 6f74 746f    r1 = The botto
+0000e130: 6d20 7261 6469 7573 206f 6620 7468 6520  m radius of the 
+0000e140: 6379 6c69 6e64 6572 2e20 2028 4265 666f  cylinder.  (Befo
+0000e150: 7265 206f 7269 656e 7461 7469 6f6e 2e29  re orientation.)
+0000e160: 0a2f 2f20 2020 7232 203d 2054 6865 2074  .//   r2 = The t
+0000e170: 6f70 2072 6164 6975 7320 6f66 2074 6865  op radius of the
+0000e180: 2063 796c 696e 6465 722e 2020 2842 6566   cylinder.  (Bef
+0000e190: 6f72 6520 6f72 6965 6e74 6174 696f 6e2e  ore orientation.
+0000e1a0: 290a 2f2f 2020 2063 656e 7465 7220 3d20  ).//   center = 
+0000e1b0: 4966 2067 6976 656e 2c20 6f76 6572 7269  If given, overri
+0000e1c0: 6465 7320 6061 6e63 686f 7260 2e20 2041  des `anchor`.  A
+0000e1d0: 2074 7275 6520 7661 6c75 6520 7365 7473   true value sets
+0000e1e0: 2060 616e 6368 6f72 3d43 454e 5445 5260   `anchor=CENTER`
+0000e1f0: 2c20 6661 6c73 6520 7365 7473 2060 616e  , false sets `an
+0000e200: 6368 6f72 3d42 4f54 544f 4d60 2e20 2044  chor=BOTTOM`.  D
+0000e210: 6566 6175 6c74 3a20 6661 6c73 650a 2f2f  efault: false.//
+0000e220: 2020 202d 2d2d 0a2f 2f20 2020 6431 203d     ---.//   d1 =
+0000e230: 2054 6865 2062 6f74 746f 6d20 6469 616d   The bottom diam
+0000e240: 6574 6572 206f 6620 7468 6520 6379 6c69  eter of the cyli
+0000e250: 6e64 6572 2e20 2028 4265 666f 7265 206f  nder.  (Before o
+0000e260: 7269 656e 7461 7469 6f6e 2e29 0a2f 2f20  rientation.).// 
+0000e270: 2020 6432 203d 2054 6865 2074 6f70 2064    d2 = The top d
+0000e280: 6961 6d65 7465 7220 6f66 2074 6865 2063  iameter of the c
+0000e290: 796c 696e 6465 722e 2020 2842 6566 6f72  ylinder.  (Befor
+0000e2a0: 6520 6f72 6965 6e74 6174 696f 6e2e 290a  e orientation.).
+0000e2b0: 2f2f 2020 2072 203d 2054 6865 2072 6164  //   r = The rad
+0000e2c0: 6975 7320 6f66 2074 6865 2063 796c 696e  ius of the cylin
+0000e2d0: 6465 722e 0a2f 2f20 2020 6420 3d20 5468  der..//   d = Th
+0000e2e0: 6520 6469 616d 6574 6572 206f 6620 7468  e diameter of th
+0000e2f0: 6520 6379 6c69 6e64 6572 2e0a 2f2f 2020  e cylinder..//  
+0000e300: 2061 6e63 686f 7220 3d20 5472 616e 736c   anchor = Transl
+0000e310: 6174 6520 736f 2061 6e63 686f 7220 706f  ate so anchor po
+0000e320: 696e 7420 6973 2061 7420 6f72 6967 696e  int is at origin
+0000e330: 2028 302c 302c 3029 2e20 2053 6565 205b   (0,0,0).  See [
+0000e340: 616e 6368 6f72 5d28 6174 7461 6368 6d65  anchor](attachme
+0000e350: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+0000e360: 696f 6e2d 616e 6368 6f72 292e 2020 4465  ion-anchor).  De
+0000e370: 6661 756c 743a 2060 4345 4e54 4552 600a  fault: `CENTER`.
+0000e380: 2f2f 2020 2073 7069 6e20 3d20 526f 7461  //   spin = Rota
+0000e390: 7465 2074 6869 7320 6d61 6e79 2064 6567  te this many deg
+0000e3a0: 7265 6573 2061 726f 756e 6420 7468 6520  rees around the 
+0000e3b0: 5a20 6178 6973 2061 6674 6572 2061 6e63  Z axis after anc
+0000e3c0: 686f 722e 2020 5365 6520 5b73 7069 6e5d  hor.  See [spin]
+0000e3d0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+0000e3e0: 6423 7375 6273 6563 7469 6f6e 2d73 7069  d#subsection-spi
+0000e3f0: 6e29 2e20 2044 6566 6175 6c74 3a20 6030  n).  Default: `0
+0000e400: 600a 2f2f 2020 206f 7269 656e 7420 3d20  `.//   orient = 
+0000e410: 5665 6374 6f72 2074 6f20 726f 7461 7465  Vector to rotate
+0000e420: 2074 6f70 2074 6f77 6172 6473 2c20 6166   top towards, af
+0000e430: 7465 7220 7370 696e 2e20 2053 6565 205b  ter spin.  See [
+0000e440: 6f72 6965 6e74 5d28 6174 7461 6368 6d65  orient](attachme
+0000e450: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+0000e460: 696f 6e2d 6f72 6965 6e74 292e 2020 4465  ion-orient).  De
+0000e470: 6661 756c 743a 2060 5550 600a 2f2f 2045  fault: `UP`.// E
+0000e480: 7861 6d70 6c65 3a20 4279 2052 6164 6975  xample: By Radiu
+0000e490: 730a 2f2f 2020 2078 6469 7374 7269 6275  s.//   xdistribu
+0000e4a0: 7465 2833 3029 207b 0a2f 2f20 2020 2020  te(30) {.//     
+0000e4b0: 2020 6379 6c69 6e64 6572 2868 3d34 302c    cylinder(h=40,
+0000e4c0: 2072 3d31 3029 3b0a 2f2f 2020 2020 2020   r=10);.//      
+0000e4d0: 2063 796c 696e 6465 7228 683d 3430 2c20   cylinder(h=40, 
+0000e4e0: 7231 3d31 302c 2072 323d 3529 3b0a 2f2f  r1=10, r2=5);.//
+0000e4f0: 2020 207d 0a2f 2f20 4578 616d 706c 653a     }.// Example:
+0000e500: 2042 7920 4469 616d 6574 6572 0a2f 2f20   By Diameter.// 
+0000e510: 2020 7864 6973 7472 6962 7574 6528 3330    xdistribute(30
+0000e520: 2920 7b0a 2f2f 2020 2020 2020 2063 796c  ) {.//       cyl
+0000e530: 696e 6465 7228 683d 3430 2c20 643d 3235  inder(h=40, d=25
+0000e540: 293b 0a2f 2f20 2020 2020 2020 6379 6c69  );.//       cyli
+0000e550: 6e64 6572 2868 3d34 302c 2064 313d 3235  nder(h=40, d1=25
+0000e560: 2c20 6432 3d31 3029 3b0a 2f2f 2020 207d  , d2=10);.//   }
+0000e570: 0a2f 2f20 4578 616d 706c 6528 4d65 6429  .// Example(Med)
+0000e580: 3a20 416e 6368 6f72 696e 670a 2f2f 2020  : Anchoring.//  
+0000e590: 2063 796c 696e 6465 7228 683d 3430 2c20   cylinder(h=40, 
+0000e5a0: 7231 3d31 302c 2072 323d 352c 2061 6e63  r1=10, r2=5, anc
+0000e5b0: 686f 723d 424f 5454 4f4d 2b46 524f 4e54  hor=BOTTOM+FRONT
+0000e5c0: 293b 0a2f 2f20 4578 616d 706c 6528 4d65  );.// Example(Me
+0000e5d0: 6429 3a20 5370 696e 0a2f 2f20 2020 6379  d): Spin.//   cy
+0000e5e0: 6c69 6e64 6572 2868 3d34 302c 2072 313d  linder(h=40, r1=
+0000e5f0: 3130 2c20 7232 3d35 2c20 616e 6368 6f72  10, r2=5, anchor
+0000e600: 3d42 4f54 544f 4d2b 4652 4f4e 542c 2073  =BOTTOM+FRONT, s
+0000e610: 7069 6e3d 3435 293b 0a2f 2f20 4578 616d  pin=45);.// Exam
+0000e620: 706c 6528 4d65 6429 3a20 4f72 6965 6e74  ple(Med): Orient
+0000e630: 0a2f 2f20 2020 6379 6c69 6e64 6572 2868  .//   cylinder(h
+0000e640: 3d34 302c 2072 313d 3130 2c20 7232 3d35  =40, r1=10, r2=5
+0000e650: 2c20 616e 6368 6f72 3d42 4f54 544f 4d2b  , anchor=BOTTOM+
+0000e660: 4652 4f4e 542c 2073 7069 6e3d 3435 2c20  FRONT, spin=45, 
+0000e670: 6f72 6965 6e74 3d46 5744 293b 0a2f 2f20  orient=FWD);.// 
+0000e680: 4578 616d 706c 6528 4269 6729 3a20 5374  Example(Big): St
+0000e690: 616e 6461 7264 2043 6f6e 6e65 6374 6f72  andard Connector
+0000e6a0: 730a 2f2f 2020 2078 6469 7374 7269 6275  s.//   xdistribu
+0000e6b0: 7465 2834 3029 207b 0a2f 2f20 2020 2020  te(40) {.//     
+0000e6c0: 2020 6379 6c69 6e64 6572 2868 3d33 302c    cylinder(h=30,
+0000e6d0: 2064 3d32 3529 2073 686f 775f 616e 6368   d=25) show_anch
+0000e6e0: 6f72 7328 293b 0a2f 2f20 2020 2020 2020  ors();.//       
+0000e6f0: 6379 6c69 6e64 6572 2868 3d33 302c 2064  cylinder(h=30, d
+0000e700: 313d 3235 2c20 6432 3d31 3029 2073 686f  1=25, d2=10) sho
+0000e710: 775f 616e 6368 6f72 7328 293b 0a2f 2f20  w_anchors();.// 
+0000e720: 2020 7d0a 0a6d 6f64 756c 6520 6379 6c69    }..module cyli
+0000e730: 6e64 6572 2868 2c20 7231 2c20 7232 2c20  nder(h, r1, r2, 
+0000e740: 6365 6e74 6572 2c20 722c 2064 2c20 6431  center, r, d, d1
+0000e750: 2c20 6432 2c20 616e 6368 6f72 2c20 7370  , d2, anchor, sp
+0000e760: 696e 3d30 2c20 6f72 6965 6e74 3d55 5029  in=0, orient=UP)
+0000e770: 0a7b 0a20 2020 2061 6e63 686f 7220 3d20  .{.    anchor = 
+0000e780: 6765 745f 616e 6368 6f72 2861 6e63 686f  get_anchor(ancho
+0000e790: 722c 2063 656e 7465 722c 2042 4f54 544f  r, center, BOTTO
+0000e7a0: 4d2c 2042 4f54 544f 4d29 3b0a 2020 2020  M, BOTTOM);.    
+0000e7b0: 7231 203d 2067 6574 5f72 6164 6975 7328  r1 = get_radius(
+0000e7c0: 7231 3d72 312c 2072 3d72 2c20 6431 3d64  r1=r1, r=r, d1=d
+0000e7d0: 312c 2064 3d64 2c20 6466 6c74 3d31 293b  1, d=d, dflt=1);
+0000e7e0: 0a20 2020 2072 3220 3d20 6765 745f 7261  .    r2 = get_ra
+0000e7f0: 6469 7573 2872 313d 7232 2c20 723d 722c  dius(r1=r2, r=r,
+0000e800: 2064 313d 6432 2c20 643d 642c 2064 666c   d1=d2, d=d, dfl
+0000e810: 743d 3129 3b0a 2020 2020 6820 3d20 6465  t=1);.    h = de
+0000e820: 6661 756c 7428 682c 3129 3b0a 2020 2020  fault(h,1);.    
+0000e830: 6174 7461 6368 6162 6c65 2861 6e63 686f  attachable(ancho
+0000e840: 722c 7370 696e 2c6f 7269 656e 742c 2072  r,spin,orient, r
+0000e850: 313d 7231 2c20 7232 3d72 322c 206c 3d68  1=r1, r2=r2, l=h
+0000e860: 2920 7b0a 2020 2020 2020 2020 5f63 796c  ) {.        _cyl
+0000e870: 696e 6465 7228 683d 682c 2072 313d 7231  inder(h=h, r1=r1
+0000e880: 2c20 7232 3d72 322c 2063 656e 7465 723d  , r2=r2, center=
+0000e890: 7472 7565 293b 0a20 2020 2020 2020 2063  true);.        c
+0000e8a0: 6869 6c64 7265 6e28 293b 0a20 2020 207d  hildren();.    }
+0000e8b0: 0a7d 0a0a 6675 6e63 7469 6f6e 2063 796c  .}..function cyl
+0000e8c0: 696e 6465 7228 682c 2072 312c 2072 322c  inder(h, r1, r2,
+0000e8d0: 2063 656e 7465 722c 2072 2c20 642c 2064   center, r, d, d
+0000e8e0: 312c 2064 322c 2061 6e63 686f 722c 2073  1, d2, anchor, s
+0000e8f0: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
+0000e900: 2920 3d0a 2020 2020 6c65 7428 0a20 2020  ) =.    let(.   
+0000e910: 2020 2020 2061 6e63 686f 7220 3d20 6765       anchor = ge
+0000e920: 745f 616e 6368 6f72 2861 6e63 686f 722c  t_anchor(anchor,
+0000e930: 2063 656e 7465 722c 2042 4f54 544f 4d2c   center, BOTTOM,
+0000e940: 2042 4f54 544f 4d29 2c0a 2020 2020 2020   BOTTOM),.      
+0000e950: 2020 7231 203d 2067 6574 5f72 6164 6975    r1 = get_radiu
+0000e960: 7328 7231 3d72 312c 2072 3d72 2c20 6431  s(r1=r1, r=r, d1
+0000e970: 3d64 312c 2064 3d64 2c20 6466 6c74 3d31  =d1, d=d, dflt=1
+0000e980: 292c 0a20 2020 2020 2020 2072 3220 3d20  ),.        r2 = 
+0000e990: 6765 745f 7261 6469 7573 2872 313d 7232  get_radius(r1=r2
+0000e9a0: 2c20 723d 722c 2064 313d 6432 2c20 643d  , r=r, d1=d2, d=
+0000e9b0: 642c 2064 666c 743d 3129 2c0a 2020 2020  d, dflt=1),.    
+0000e9c0: 2020 2020 6c20 3d20 6465 6661 756c 7428      l = default(
+0000e9d0: 682c 3129 2c0a 2020 2020 2020 2020 7369  h,1),.        si
+0000e9e0: 6465 7320 3d20 7365 6773 286d 6178 2872  des = segs(max(r
+0000e9f0: 312c 7232 2929 2c0a 2020 2020 2020 2020  1,r2)),.        
+0000ea00: 7665 7274 7320 3d20 5b0a 2020 2020 2020  verts = [.      
+0000ea10: 2020 2020 2020 666f 7220 2869 3d5b 303a        for (i=[0:
+0000ea20: 313a 7369 6465 732d 315d 2920 6c65 7428  1:sides-1]) let(
+0000ea30: 613d 3336 302a 2831 2d69 2f73 6964 6573  a=360*(1-i/sides
+0000ea40: 2929 205b 7231 2a63 6f73 2861 292c 7231  )) [r1*cos(a),r1
+0000ea50: 2a73 696e 2861 292c 2d6c 2f32 5d2c 0a20  *sin(a),-l/2],. 
+0000ea60: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
+0000ea70: 693d 5b30 3a31 3a73 6964 6573 2d31 5d29  i=[0:1:sides-1])
+0000ea80: 206c 6574 2861 3d33 3630 2a28 312d 692f   let(a=360*(1-i/
+0000ea90: 7369 6465 7329 2920 5b72 322a 636f 7328  sides)) [r2*cos(
+0000eaa0: 6129 2c72 322a 7369 6e28 6129 2c20 6c2f  a),r2*sin(a), l/
+0000eab0: 325d 2c0a 2020 2020 2020 2020 5d2c 0a20  2],.        ],. 
+0000eac0: 2020 2020 2020 2066 6163 6573 203d 205b         faces = [
+0000ead0: 0a20 2020 2020 2020 2020 2020 205b 666f  .            [fo
+0000eae0: 7220 2869 3d5b 303a 313a 7369 6465 732d  r (i=[0:1:sides-
+0000eaf0: 315d 2920 7369 6465 732d 312d 695d 2c0a  1]) sides-1-i],.
+0000eb00: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0000eb10: 2869 3d5b 303a 313a 7369 6465 732d 315d  (i=[0:1:sides-1]
+0000eb20: 2920 5b69 2c20 2828 692b 3129 2573 6964  ) [i, ((i+1)%sid
+0000eb30: 6573 292b 7369 6465 732c 2069 2b73 6964  es)+sides, i+sid
+0000eb40: 6573 5d2c 0a20 2020 2020 2020 2020 2020  es],.           
+0000eb50: 2066 6f72 2028 693d 5b30 3a31 3a73 6964   for (i=[0:1:sid
+0000eb60: 6573 2d31 5d29 205b 692c 2028 692b 3129  es-1]) [i, (i+1)
+0000eb70: 2573 6964 6573 2c20 2828 692b 3129 2573  %sides, ((i+1)%s
+0000eb80: 6964 6573 292b 7369 6465 735d 2c0a 2020  ides)+sides],.  
+0000eb90: 2020 2020 2020 2020 2020 5b66 6f72 2028            [for (
+0000eba0: 693d 5b30 3a31 3a73 6964 6573 2d31 5d29  i=[0:1:sides-1])
+0000ebb0: 2073 6964 6573 2b69 5d0a 2020 2020 2020   sides+i].      
+0000ebc0: 2020 5d0a 2020 2020 2920 5b72 656f 7269    ].    ) [reori
+0000ebd0: 656e 7428 616e 6368 6f72 2c73 7069 6e2c  ent(anchor,spin,
+0000ebe0: 6f72 6965 6e74 2c20 6c3d 6c2c 2072 313d  orient, l=l, r1=
+0000ebf0: 7231 2c20 7232 3d72 322c 2070 3d76 6572  r1, r2=r2, p=ver
+0000ec00: 7473 292c 2066 6163 6573 5d3b 0a0a 0a0a  ts), faces];....
+0000ec10: 2f2f 2046 756e 6374 696f 6e26 4d6f 6475  // Function&Modu
+0000ec20: 6c65 3a20 6379 6c28 290a 2f2f 2053 796e  le: cyl().// Syn
+0000ec30: 6f70 7369 733a 2043 7265 6174 6573 2061  opsis: Creates a
+0000ec40: 6e20 6174 7461 6368 6162 6c65 2063 796c  n attachable cyl
+0000ec50: 696e 6465 7220 7769 7468 2072 6f75 6e64  inder with round
+0000ec60: 6f76 6572 7320 616e 6420 6368 616d 6665  overs and chamfe
+0000ec70: 7269 6e67 2c20 6f72 2072 6574 7572 6e73  ring, or returns
+0000ec80: 2061 2076 6e66 2e0a 2f2f 2054 6f70 6963   a vnf..// Topic
+0000ec90: 733a 2043 796c 696e 6465 7273 2c20 5465  s: Cylinders, Te
+0000eca0: 7874 7572 6573 2c20 526f 756e 6469 6e67  xtures, Rounding
+0000ecb0: 2c20 4368 616d 6665 7273 0a2f 2f20 5365  , Chamfers.// Se
+0000ecc0: 6520 416c 736f 3a20 7465 7874 7572 6528  e Also: texture(
+0000ecd0: 292c 2072 6f74 6174 655f 7377 6565 7028  ), rotate_sweep(
+0000ece0: 292c 2063 796c 696e 6465 7228 290a 2f2f  ), cylinder().//
+0000ecf0: 2055 7361 6765 3a20 4e6f 726d 616c 2043   Usage: Normal C
+0000ed00: 796c 696e 6465 7273 0a2f 2f20 2020 6379  ylinders.//   cy
+0000ed10: 6c28 6c7c 687c 6c65 6e67 7468 7c68 6569  l(l|h|length|hei
+0000ed20: 6768 742c 2072 2c20 5b63 656e 7465 725d  ght, r, [center]
+0000ed30: 2c20 5b63 6972 6375 6d3d 5d2c 205b 7265  , [circum=], [re
+0000ed40: 616c 6967 6e3d 5d29 205b 4154 5441 4348  align=]) [ATTACH
+0000ed50: 4d45 4e54 535d 3b0a 2f2f 2020 2063 796c  MENTS];.//   cyl
+0000ed60: 286c 7c68 7c6c 656e 6774 687c 6865 6967  (l|h|length|heig
+0000ed70: 6874 2c20 643d 2c20 2e2e 2e29 205b 4154  ht, d=, ...) [AT
+0000ed80: 5441 4348 4d45 4e54 535d 3b0a 2f2f 2020  TACHMENTS];.//  
+0000ed90: 2063 796c 286c 7c68 7c6c 656e 6774 687c   cyl(l|h|length|
+0000eda0: 6865 6967 6874 2c20 7231 3d2c 2072 323d  height, r1=, r2=
+0000edb0: 2c20 2e2e 2e29 205b 4154 5441 4348 4d45  , ...) [ATTACHME
+0000edc0: 4e54 535d 3b0a 2f2f 2020 2063 796c 286c  NTS];.//   cyl(l
+0000edd0: 7c68 7c6c 656e 6774 687c 6865 6967 6874  |h|length|height
+0000ede0: 2c20 6431 3d2c 2064 323d 2c20 2e2e 2e29  , d1=, d2=, ...)
+0000edf0: 205b 4154 5441 4348 4d45 4e54 535d 3b0a   [ATTACHMENTS];.
+0000ee00: 2f2f 0a2f 2f20 5573 6167 653a 2043 6861  //.// Usage: Cha
+0000ee10: 6d66 6572 7265 6420 4379 6c69 6e64 6572  mferred Cylinder
+0000ee20: 730a 2f2f 2020 2063 796c 286c 7c68 7c6c  s.//   cyl(l|h|l
+0000ee30: 656e 6774 687c 6865 6967 6874 2c20 727c  ength|height, r|
+0000ee40: 642c 2063 6861 6d66 6572 3d2c 205b 6368  d, chamfer=, [ch
+0000ee50: 616d 6661 6e67 3d5d 2c20 5b66 726f 6d5f  amfang=], [from_
+0000ee60: 656e 643d 5d2c 202e 2e2e 293b 0a2f 2f20  end=], ...);.// 
+0000ee70: 2020 6379 6c28 6c7c 687c 6c65 6e67 7468    cyl(l|h|length
+0000ee80: 7c68 6569 6768 742c 2072 7c64 2c20 6368  |height, r|d, ch
+0000ee90: 616d 6665 7231 3d2c 205b 6368 616d 6661  amfer1=, [chamfa
+0000eea0: 6e67 313d 5d2c 205b 6672 6f6d 5f65 6e64  ng1=], [from_end
+0000eeb0: 3d5d 2c20 2e2e 2e29 3b0a 2f2f 2020 2063  =], ...);.//   c
+0000eec0: 796c 286c 7c68 7c6c 656e 6774 687c 6865  yl(l|h|length|he
+0000eed0: 6967 6874 2c20 727c 642c 2063 6861 6d66  ight, r|d, chamf
+0000eee0: 6572 323d 2c20 5b63 6861 6d66 616e 6732  er2=, [chamfang2
+0000eef0: 3d5d 2c20 5b66 726f 6d5f 656e 643d 5d2c  =], [from_end=],
+0000ef00: 202e 2e2e 293b 0a2f 2f20 2020 6379 6c28   ...);.//   cyl(
+0000ef10: 6c7c 687c 6c65 6e67 7468 7c68 6569 6768  l|h|length|heigh
+0000ef20: 742c 2072 7c64 2c20 6368 616d 6665 7231  t, r|d, chamfer1
+0000ef30: 3d2c 2063 6861 6d66 6572 323d 2c20 5b63  =, chamfer2=, [c
+0000ef40: 6861 6d66 616e 6731 3d5d 2c20 5b63 6861  hamfang1=], [cha
+0000ef50: 6d66 616e 6732 3d5d 2c20 5b66 726f 6d5f  mfang2=], [from_
+0000ef60: 656e 643d 5d2c 202e 2e2e 293b 0a2f 2f0a  end=], ...);.//.
+0000ef70: 2f2f 2055 7361 6765 3a20 526f 756e 6465  // Usage: Rounde
+0000ef80: 6420 456e 6420 4379 6c69 6e64 6572 730a  d End Cylinders.
+0000ef90: 2f2f 2020 2063 796c 286c 7c68 7c6c 656e  //   cyl(l|h|len
+0000efa0: 6774 687c 6865 6967 6874 2c20 727c 642c  gth|height, r|d,
+0000efb0: 2072 6f75 6e64 696e 673d 2c20 2e2e 2e29   rounding=, ...)
+0000efc0: 3b0a 2f2f 2020 2063 796c 286c 7c68 7c6c  ;.//   cyl(l|h|l
+0000efd0: 656e 6774 687c 6865 6967 6874 2c20 727c  ength|height, r|
+0000efe0: 642c 2072 6f75 6e64 696e 6731 3d2c 202e  d, rounding1=, .
+0000eff0: 2e2e 293b 0a2f 2f20 2020 6379 6c28 6c7c  ..);.//   cyl(l|
+0000f000: 687c 6c65 6e67 7468 7c68 6569 6768 742c  h|length|height,
+0000f010: 2072 7c64 2c20 726f 756e 6469 6e67 323d   r|d, rounding2=
+0000f020: 2c20 2e2e 2e29 3b0a 2f2f 2020 2063 796c  , ...);.//   cyl
+0000f030: 286c 7c68 7c6c 656e 6774 687c 6865 6967  (l|h|length|heig
+0000f040: 6874 2c20 727c 642c 2072 6f75 6e64 696e  ht, r|d, roundin
+0000f050: 6731 3d2c 2072 6f75 6e64 696e 6732 3d2c  g1=, rounding2=,
+0000f060: 202e 2e2e 293b 0a2f 2f0a 2f2f 2055 7361   ...);.//.// Usa
+0000f070: 6765 3a20 5465 7874 7572 6564 2043 796c  ge: Textured Cyl
+0000f080: 696e 6465 7273 0a2f 2f20 2020 6379 6c28  inders.//   cyl(
+0000f090: 6c7c 687c 6c65 6e67 7468 7c68 6569 6768  l|h|length|heigh
+0000f0a0: 742c 2072 7c64 2c20 7465 7874 7572 653d  t, r|d, texture=
+0000f0b0: 2c20 5b74 6578 5f73 697a 653d 5d7c 5b74  , [tex_size=]|[t
+0000f0c0: 6578 5f63 6f75 6e74 733d 5d2c 205b 7465  ex_counts=], [te
+0000f0d0: 785f 7363 616c 653d 5d2c 205b 7465 785f  x_scale=], [tex_
+0000f0e0: 726f 743d 5d2c 205b 7465 785f 7361 6d70  rot=], [tex_samp
+0000f0f0: 6c65 733d 5d2c 205b 7465 785f 7374 796c  les=], [tex_styl
+0000f100: 653d 5d2c 205b 7465 785f 7461 7065 723d  e=], [tex_taper=
+0000f110: 5d2c 205b 7465 785f 696e 7365 743d 5d2c  ], [tex_inset=],
+0000f120: 202e 2e2e 293b 0a2f 2f20 2020 6379 6c28   ...);.//   cyl(
+0000f130: 6c7c 687c 6c65 6e67 7468 7c68 6569 6768  l|h|length|heigh
+0000f140: 742c 2072 313d 2c20 7232 3d2c 2074 6578  t, r1=, r2=, tex
+0000f150: 7475 7265 3d2c 205b 7465 785f 7369 7a65  ture=, [tex_size
+0000f160: 3d5d 7c5b 7465 785f 636f 756e 7473 3d5d  =]|[tex_counts=]
+0000f170: 2c20 5b74 6578 5f73 6361 6c65 3d5d 2c20  , [tex_scale=], 
+0000f180: 5b74 6578 5f72 6f74 3d5d 2c20 5b74 6578  [tex_rot=], [tex
+0000f190: 5f73 616d 706c 6573 3d5d 2c20 5b74 6578  _samples=], [tex
+0000f1a0: 5f73 7479 6c65 3d5d 2c20 5b74 6578 5f74  _style=], [tex_t
+0000f1b0: 6170 6572 3d5d 2c20 5b74 6578 5f69 6e73  aper=], [tex_ins
+0000f1c0: 6574 3d5d 2c20 2e2e 2e29 3b0a 2f2f 2020  et=], ...);.//  
+0000f1d0: 2063 796c 286c 7c68 7c6c 656e 6774 687c   cyl(l|h|length|
+0000f1e0: 6865 6967 6874 2c20 6431 3d2c 2064 323d  height, d1=, d2=
+0000f1f0: 2c20 7465 7874 7572 653d 2c20 5b74 6578  , texture=, [tex
+0000f200: 5f73 697a 653d 5d7c 5b74 6578 5f63 6f75  _size=]|[tex_cou
+0000f210: 6e74 733d 5d2c 205b 7465 785f 7363 616c  nts=], [tex_scal
+0000f220: 653d 5d2c 205b 7465 785f 726f 743d 5d2c  e=], [tex_rot=],
+0000f230: 205b 7465 785f 7361 6d70 6c65 733d 5d2c   [tex_samples=],
+0000f240: 205b 7465 785f 7374 796c 653d 5d2c 205b   [tex_style=], [
+0000f250: 7465 785f 7461 7065 723d 5d2c 205b 7465  tex_taper=], [te
+0000f260: 785f 696e 7365 743d 5d2c 202e 2e2e 293b  x_inset=], ...);
+0000f270: 0a2f 2f0a 2f2f 0a2f 2f20 4465 7363 7269  .//.//.// Descri
+0000f280: 7074 696f 6e3a 0a2f 2f20 2020 4372 6561  ption:.//   Crea
+0000f290: 7465 7320 6379 6c69 6e64 6572 7320 696e  tes cylinders in
+0000f2a0: 2076 6172 696f 7573 2061 6e63 686f 7269   various anchori
+0000f2b0: 6e67 7320 616e 6420 6f72 6965 6e74 6174  ngs and orientat
+0000f2c0: 696f 6e73 2c20 7769 7468 206f 7074 696f  ions, with optio
+0000f2d0: 6e61 6c20 726f 756e 6469 6e67 2c20 6368  nal rounding, ch
+0000f2e0: 616d 6665 7273 2c20 6f72 2074 6578 7475  amfers, or textu
+0000f2f0: 7265 732e 0a2f 2f20 2020 596f 7520 6361  res..//   You ca
+0000f300: 6e20 7573 6520 6068 6020 616e 6420 606c  n use `h` and `l
+0000f310: 6020 696e 7465 7263 6861 6e67 6162 6c79  ` interchangably
+0000f320: 2c20 616e 6420 616c 6c20 7661 7269 616e  , and all varian
+0000f330: 7473 2061 6c6c 6f77 2073 7065 6369 6679  ts allow specify
+0000f340: 696e 6720 7369 7a65 2062 7920 6569 7468  ing size by eith
+0000f350: 6572 2060 7260 7c60 6460 2c0a 2f2f 2020  er `r`|`d`,.//  
+0000f360: 206f 7220 6072 3160 7c60 6431 6020 616e   or `r1`|`d1` an
+0000f370: 6420 6072 3260 7c60 6432 602e 2020 4e6f  d `r2`|`d2`.  No
+0000f380: 7465 3a20 7468 6520 6368 616d 6665 7273  te: the chamfers
+0000f390: 2061 6e64 2072 6f75 6e64 696e 6720 6361   and rounding ca
+0000f3a0: 6e6e 6f74 2062 6520 6375 6d75 6c61 7469  nnot be cumulati
+0000f3b0: 7665 6c79 206c 6f6e 6765 7220 7468 616e  vely longer than
+0000f3c0: 0a2f 2f20 2020 7468 6520 6379 6c69 6e64  .//   the cylind
+0000f3d0: 6572 206f 7220 636f 6e65 2773 2073 6c6f  er or cone's slo
+0000f3e0: 7065 6420 7369 6465 2e20 2054 6865 206d  ped side.  The m
+0000f3f0: 6f72 6520 7370 6563 6966 6963 2070 6172  ore specific par
+0000f400: 616d 6574 6572 7320 6c69 6b65 2063 6861  ameters like cha
+0000f410: 6d66 6572 3120 6f72 2072 6f75 6e64 696e  mfer1 or roundin
+0000f420: 6732 206f 7665 7272 6964 6520 7468 6520  g2 override the 
+0000f430: 6d6f 7265 0a2f 2f20 2020 6765 6e65 7261  more.//   genera
+0000f440: 6c20 6f6e 6573 206c 696b 6520 6368 616d  l ones like cham
+0000f450: 6665 7220 6f72 2072 6f75 6e64 696e 672c  fer or rounding,
+0000f460: 2073 6f20 6966 2079 6f75 2073 7065 6369   so if you speci
+0000f470: 6679 2060 726f 756e 6469 6e67 3d33 2c20  fy `rounding=3, 
+0000f480: 6368 616d 6665 7232 3d33 6020 796f 7520  chamfer2=3` you 
+0000f490: 7769 6c6c 2067 6574 2061 2063 6861 6d66  will get a chamf
+0000f4a0: 6572 2061 7420 7468 6520 746f 7020 616e  er at the top an
+0000f4b0: 640a 2f2f 2020 2072 6f75 6e64 696e 6720  d.//   rounding 
+0000f4c0: 6174 2074 6865 2062 6f74 746f 6d2e 0a2f  at the bottom../
+0000f4d0: 2f20 4669 6775 7265 2832 442c 4269 672c  / Figure(2D,Big,
+0000f4e0: 4e6f 4178 6573 2c56 5052 203d 205b 302c  NoAxes,VPR = [0,
+0000f4f0: 2030 2c20 305d 2c20 5650 5420 3d20 5b30   0, 0], VPT = [0
+0000f500: 2c30 2c30 5d2c 2056 5044 203d 2038 3229  ,0,0], VPD = 82)
+0000f510: 3a20 4368 616d 6665 7273 206f 6e20 636f  : Chamfers on co
+0000f520: 6e65 7320 6361 6e20 6265 2074 7269 636b  nes can be trick
+0000f530: 792e 2020 5468 6973 2066 6967 7572 6520  y.  This figure 
+0000f540: 7368 6f77 7320 6368 616d 6665 7273 206f  shows chamfers o
+0000f550: 6620 7468 6520 7361 6d65 2073 697a 6520  f the same size 
+0000f560: 616e 6420 7361 6d65 2061 6e67 6c65 2c20  and same angle, 
+0000f570: 413d 3330 2064 6567 7265 6573 2e20 204e  A=30 degrees.  N
+0000f580: 6f74 6520 7468 6174 2074 6865 2061 6e67  ote that the ang
+0000f590: 6c65 2069 7320 6d65 6173 7572 6564 206f  le is measured o
+0000f5a0: 6e20 7468 6520 696e 7369 6465 2c20 616e  n the inside, an
+0000f5b0: 6420 7072 6f64 7563 6573 2061 2071 7569  d produces a qui
+0000f5c0: 7465 2064 6966 6665 7265 6e74 206c 6f6f  te different loo
+0000f5d0: 6b69 6e67 2063 6861 6d66 6572 2061 7420  king chamfer at 
+0000f5e0: 7468 6520 746f 7020 616e 6420 626f 7474  the top and bott
+0000f5f0: 6f6d 206f 6620 7468 6520 636f 6e65 2e20  om of the cone. 
+0000f600: 2053 7472 6169 6768 7420 626c 6163 6b20   Straight black 
+0000f610: 6172 726f 7773 206d 6172 6b20 7468 6520  arrows mark the 
+0000f620: 7369 7a65 206f 6620 7468 6520 6368 616d  size of the cham
+0000f630: 6665 7273 2c20 7768 6963 6820 6d61 7920  fers, which may 
+0000f640: 6e6f 7420 6576 656e 2061 7070 6561 7220  not even appear 
+0000f650: 7468 6520 7361 6d65 2073 697a 6520 7669  the same size vi
+0000f660: 7375 616c 6c79 2e20 2057 6865 6e20 796f  sually.  When yo
+0000f670: 7520 646f 206e 6f74 2067 6976 6520 616e  u do not give an
+0000f680: 2061 6e67 6c65 2c20 7468 6520 7472 6961   angle, the tria
+0000f690: 6e67 6c65 2074 6861 7420 6973 2063 7574  ngle that is cut
+0000f6a0: 206f 6666 2077 696c 6c20 6265 2069 736f   off will be iso
+0000f6b0: 6365 6c65 732c 206c 696b 6520 7468 6520  celes, like the 
+0000f6c0: 7472 6961 6e67 6c65 2061 7420 7468 6520  triangle at the 
+0000f6d0: 746f 702c 2077 6974 6820 7477 6f20 6571  top, with two eq
+0000f6e0: 7561 6c20 616e 676c 6573 2e0a 2f2f 2020  ual angles..//  
+0000f6f0: 636f 6c6f 7228 226c 6967 6874 6772 6179  color("lightgray
+0000f700: 2229 0a2f 2f20 2070 726f 6a65 6374 696f  ").//  projectio
+0000f710: 6e28 290a 2f2f 2020 2020 2020 6379 6c28  n().//      cyl(
+0000f720: 7232 3d31 302c 2072 313d 3230 2c20 6c3d  r2=10, r1=20, l=
+0000f730: 3230 2c63 6861 6d66 616e 673d 3330 2c20  20,chamfang=30, 
+0000f740: 6368 616d 6665 723d 302c 6f72 6965 6e74  chamfer=0,orient
+0000f750: 3d42 4143 4b29 3b0a 2f2f 2020 7072 6f6a  =BACK);.//  proj
+0000f760: 6563 7469 6f6e 2829 0a2f 2f20 2020 2020  ection().//     
+0000f770: 2063 796c 2872 323d 3130 2c20 7231 3d32   cyl(r2=10, r1=2
+0000f780: 302c 206c 3d32 302c 6368 616d 6661 6e67  0, l=20,chamfang
+0000f790: 3d33 302c 2063 6861 6d66 6572 3d38 2c6f  =30, chamfer=8,o
+0000f7a0: 7269 656e 743d 4241 434b 293b 0a2f 2f20  rient=BACK);.// 
+0000f7b0: 2063 6f6c 6f72 2822 626c 6163 6b22 297b   color("black"){
+0000f7c0: 0a2f 2f20 2020 2020 2066 7764 2839 2e36  .//      fwd(9.6
+0000f7d0: 2972 6967 6874 2832 302d 342e 3829 7465  )right(20-4.8)te
+0000f7e0: 7874 2822 4122 2c73 697a 653d 312e 3329  xt("A",size=1.3)
+0000f7f0: 3b0a 2f2f 2020 2020 2020 6677 6428 2d38  ;.//      fwd(-8
+0000f800: 2e34 2972 6967 6874 2831 302d 342e 3929  .4)right(10-4.9)
+0000f810: 7465 7874 2822 4122 2c73 697a 653d 312e  text("A",size=1.
+0000f820: 3329 3b0a 2f2f 2020 2020 2020 7269 6768  3);.//      righ
+0000f830: 7428 3230 2d38 2966 7764 2831 302e 3529  t(20-8)fwd(10.5)
+0000f840: 7374 726f 6b65 285b 5b30 2c30 5d2c 5b38  stroke([[0,0],[8
+0000f850: 2c30 5d5d 2c20 656e 6463 6170 733d 2261  ,0]], endcaps="a
+0000f860: 7272 6f77 3222 2c77 6964 7468 3d2e 3135  rrow2",width=.15
+0000f870: 293b 0a2f 2f20 2020 2020 2072 6967 6874  );.//      right
+0000f880: 2831 302d 3829 6677 6428 2d31 302e 3529  (10-8)fwd(-10.5)
+0000f890: 7374 726f 6b65 285b 5b30 2c30 5d2c 5b38  stroke([[0,0],[8
+0000f8a0: 2c30 5d5d 2c20 656e 6463 6170 733d 2261  ,0]], endcaps="a
+0000f8b0: 7272 6f77 3222 2c77 6964 7468 3d2e 3135  rrow2",width=.15
+0000f8c0: 293b 0a2f 2f20 2020 2020 2073 7472 6f6b  );.//      strok
+0000f8d0: 6528 6172 6328 6370 3d5b 322c 3130 5d2c  e(arc(cp=[2,10],
+0000f8e0: 2061 6e67 6c65 3d5b 302c 2d33 305d 2c20   angle=[0,-30], 
+0000f8f0: 6e3d 3230 2c20 723d 3529 2c20 7769 6474  n=20, r=5), widt
+0000f900: 683d 2e31 382c 2065 6e64 6361 7073 3d22  h=.18, endcaps="
+0000f910: 6172 726f 7732 2229 3b0a 2f2f 2020 2020  arrow2");.//    
+0000f920: 2020 7374 726f 6b65 2861 7263 2863 703d    stroke(arc(cp=
+0000f930: 5b31 322c 2d31 305d 2c20 616e 676c 653d  [12,-10], angle=
+0000f940: 5b30 2c33 305d 2c20 6e3d 3230 2c20 723d  [0,30], n=20, r=
+0000f950: 3529 2c20 7769 6474 683d 2e31 382c 2065  5), width=.18, e
+0000f960: 6e64 6361 7073 3d22 6172 726f 7732 2229  ndcaps="arrow2")
+0000f970: 3b0a 2f2f 2020 7d0a 2f2f 2046 6967 7572  ;.//  }.// Figur
+0000f980: 6528 3244 2c42 6967 2c4e 6f41 7865 732c  e(2D,Big,NoAxes,
+0000f990: 5650 5220 3d20 5b30 2c20 302c 2030 5d2c  VPR = [0, 0, 0],
+0000f9a0: 2056 5054 203d 205b 302c 302c 305d 2c20   VPT = [0,0,0], 
+0000f9b0: 5650 4420 3d20 3832 293a 2054 6865 2063  VPD = 82): The c
+0000f9c0: 6f6e 6520 696e 2074 6869 7320 6578 616d  one in this exam
+0000f9d0: 706c 6520 6973 206e 6172 726f 7720 6275  ple is narrow bu
+0000f9e0: 7420 6861 7320 7468 6520 7361 6d65 2073  t has the same s
+0000f9f0: 6c6f 7065 2e20 2057 6974 6820 6e65 6761  lope.  With nega
+0000fa00: 7469 7665 2063 6861 6d66 6572 732c 2074  tive chamfers, t
+0000fa10: 6865 2061 6e67 6c65 2041 3d33 3020 6465  he angle A=30 de
+0000fa20: 6772 6565 7320 6973 206f 6e20 7468 6520  grees is on the 
+0000fa30: 6f75 7473 6964 652e 2020 5468 6520 6368  outside.  The ch
+0000fa40: 616d 6665 7273 2061 7265 2061 6761 696e  amfers are again
+0000fa50: 2071 7569 7465 2064 6966 6665 7265 6e74   quite different
+0000fa60: 206c 6f6f 6b69 6e67 2e20 2041 7320 6265   looking.  As be
+0000fa70: 666f 7265 2c20 7468 6520 6465 6661 756c  fore, the defaul
+0000fa80: 7420 7769 6c6c 2066 6561 7475 7265 2074  t will feature t
+0000fa90: 776f 2063 6f6e 6772 7565 6e74 2061 6e67  wo congruent ang
+0000faa0: 6c65 732c 2061 6e64 2069 6e20 7468 6973  les, and in this
+0000fab0: 2063 6173 6520 6974 2068 6170 7065 6e73   case it happens
+0000fac0: 2061 7420 7468 6520 626f 7474 6f6d 206f   at the bottom o
+0000fad0: 6620 7468 6520 636f 6e65 2062 7574 206e  f the cone but n
+0000fae0: 6f74 2074 6865 2074 6f70 2e20 2054 6865  ot the top.  The
+0000faf0: 2073 7472 6169 6768 7420 6172 726f 7773   straight arrows
+0000fb00: 2061 6761 696e 2073 686f 7720 7468 6520   again show the 
+0000fb10: 7369 7a65 206f 6620 7468 6520 6368 616d  size of the cham
+0000fb20: 6665 722e 0a2f 2f20 2072 313d 3130 2d37  fer..//  r1=10-7
+0000fb30: 2e35 3b72 323d 3230 2d37 2e35 3b0a 2f2f  .5;r2=20-7.5;.//
+0000fb40: 2020 636f 6c6f 7228 226c 6967 6874 6772    color("lightgr
+0000fb50: 6179 2229 0a2f 2f20 2070 726f 6a65 6374  ay").//  project
+0000fb60: 696f 6e28 290a 2f2f 2020 2020 2020 6379  ion().//      cy
+0000fb70: 6c28 7232 3d72 312c 2072 313d 7232 2c20  l(r2=r1, r1=r2, 
+0000fb80: 6c3d 3230 2c63 6861 6d66 616e 673d 3330  l=20,chamfang=30
+0000fb90: 2c20 6368 616d 6665 723d 2d38 2c6f 7269  , chamfer=-8,ori
+0000fba0: 656e 743d 4241 434b 293b 0a2f 2f20 2070  ent=BACK);.//  p
+0000fbb0: 726f 6a65 6374 696f 6e28 290a 2f2f 2020  rojection().//  
+0000fbc0: 2020 2020 6379 6c28 7232 3d72 312c 2072      cyl(r2=r1, r
+0000fbd0: 313d 7232 2c20 6c3d 3230 2c63 6861 6d66  1=r2, l=20,chamf
+0000fbe0: 616e 673d 3330 2c20 6368 616d 6665 723d  ang=30, chamfer=
+0000fbf0: 302c 6f72 6965 6e74 3d42 4143 4b29 3b0a  0,orient=BACK);.
+0000fc00: 2f2f 2020 636f 6c6f 7228 2262 6c61 636b  //  color("black
+0000fc10: 2229 7b0a 2f2f 2020 2020 2020 6677 6428  "){.//      fwd(
+0000fc20: 392e 3729 7269 6768 7428 7232 2b33 2e38  9.7)right(r2+3.8
+0000fc30: 2974 6578 7428 2241 222c 7369 7a65 3d31  )text("A",size=1
+0000fc40: 2e33 293b 0a2f 2f20 2020 2020 2066 7764  .3);.//      fwd
+0000fc50: 282d 382e 3529 7269 6768 7428 7231 2b33  (-8.5)right(r1+3
+0000fc60: 2e37 2974 6578 7428 2241 222c 7369 7a65  .7)text("A",size
+0000fc70: 3d31 2e33 293b 0a2f 2f20 2020 2020 2072  =1.3);.//      r
+0000fc80: 6967 6874 2872 3229 6677 6428 3130 2e35  ight(r2)fwd(10.5
+0000fc90: 2973 7472 6f6b 6528 5b5b 302c 305d 2c5b  )stroke([[0,0],[
+0000fca0: 382c 305d 5d2c 2065 6e64 6361 7073 3d22  8,0]], endcaps="
+0000fcb0: 6172 726f 7732 222c 7769 6474 683d 2e31  arrow2",width=.1
+0000fcc0: 3529 3b0a 2f2f 2020 2020 2020 7269 6768  5);.//      righ
+0000fcd0: 7428 7231 2966 7764 282d 3130 2e35 2973  t(r1)fwd(-10.5)s
+0000fce0: 7472 6f6b 6528 5b5b 302c 305d 2c5b 382c  troke([[0,0],[8,
+0000fcf0: 305d 5d2c 2065 6e64 6361 7073 3d22 6172  0]], endcaps="ar
+0000fd00: 726f 7732 222c 7769 6474 683d 2e31 3529  row2",width=.15)
+0000fd10: 3b0a 2f2f 2020 2020 2020 7374 726f 6b65  ;.//      stroke
+0000fd20: 2861 7263 2863 703d 5b72 312b 382c 3130  (arc(cp=[r1+8,10
+0000fd30: 5d2c 2061 6e67 6c65 3d5b 3138 302c 3138  ], angle=[180,18
+0000fd40: 302b 3330 5d2c 206e 3d32 302c 2072 3d35  0+30], n=20, r=5
+0000fd50: 292c 2077 6964 7468 3d2e 3138 2c20 656e  ), width=.18, en
+0000fd60: 6463 6170 733d 2261 7272 6f77 3222 293b  dcaps="arrow2");
+0000fd70: 0a2f 2f20 2020 2020 2073 7472 6f6b 6528  .//      stroke(
+0000fd80: 6172 6328 6370 3d5b 7232 2b38 2c2d 3130  arc(cp=[r2+8,-10
+0000fd90: 5d2c 2061 6e67 6c65 3d5b 3138 302d 3330  ], angle=[180-30
+0000fda0: 2c31 3830 5d2c 206e 3d32 302c 2072 3d35  ,180], n=20, r=5
+0000fdb0: 292c 2077 6964 7468 3d2e 3138 2c20 656e  ), width=.18, en
+0000fdc0: 6463 6170 733d 2261 7272 6f77 3222 293b  dcaps="arrow2");
+0000fdd0: 0a2f 2f20 207d 0a2f 2f20 4172 6775 6d65  .//  }.// Argume
+0000fde0: 6e74 733a 0a2f 2f20 2020 6c20 2f20 6820  nts:.//   l / h 
+0000fdf0: 2f20 6c65 6e67 7468 202f 2068 6569 6768  / length / heigh
+0000fe00: 7420 3d20 4c65 6e67 7468 206f 6620 6379  t = Length of cy
+0000fe10: 6c69 6e64 6572 2061 6c6f 6e67 206f 7269  linder along ori
+0000fe20: 656e 7465 6420 6178 6973 2e20 2044 6566  ented axis.  Def
+0000fe30: 6175 6c74 3a20 310a 2f2f 2020 2072 203d  ault: 1.//   r =
+0000fe40: 2052 6164 6975 7320 6f66 2063 796c 696e   Radius of cylin
+0000fe50: 6465 722e 2020 4465 6661 756c 743a 2031  der.  Default: 1
+0000fe60: 0a2f 2f20 2020 6365 6e74 6572 203d 2049  .//   center = I
+0000fe70: 6620 6769 7665 6e2c 206f 7665 7272 6964  f given, overrid
+0000fe80: 6573 2060 616e 6368 6f72 602e 2020 4120  es `anchor`.  A 
+0000fe90: 7472 7565 2076 616c 7565 2073 6574 7320  true value sets 
+0000fea0: 6061 6e63 686f 723d 4345 4e54 4552 602c  `anchor=CENTER`,
+0000feb0: 2066 616c 7365 2073 6574 7320 6061 6e63   false sets `anc
+0000fec0: 686f 723d 444f 574e 602e 0a2f 2f20 2020  hor=DOWN`..//   
+0000fed0: 2d2d 2d0a 2f2f 2020 2072 3120 3d20 5261  ---.//   r1 = Ra
+0000fee0: 6469 7573 206f 6620 7468 6520 6e65 6761  dius of the nega
+0000fef0: 7469 7665 2028 582d 2c20 592d 2c20 5a2d  tive (X-, Y-, Z-
+0000ff00: 2920 656e 6420 6f66 2063 796c 696e 6465  ) end of cylinde
+0000ff10: 722e 0a2f 2f20 2020 7232 203d 2052 6164  r..//   r2 = Rad
+0000ff20: 6975 7320 6f66 2074 6865 2070 6f73 6974  ius of the posit
+0000ff30: 6976 6520 2858 2b2c 2059 2b2c 205a 2b29  ive (X+, Y+, Z+)
+0000ff40: 2065 6e64 206f 6620 6379 6c69 6e64 6572   end of cylinder
+0000ff50: 2e0a 2f2f 2020 2064 203d 2044 6961 6d65  ..//   d = Diame
+0000ff60: 7465 7220 6f66 2063 796c 696e 6465 722e  ter of cylinder.
+0000ff70: 0a2f 2f20 2020 6431 203d 2044 6961 6d65  .//   d1 = Diame
+0000ff80: 7465 7220 6f66 2074 6865 206e 6567 6174  ter of the negat
+0000ff90: 6976 6520 2858 2d2c 2059 2d2c 205a 2d29  ive (X-, Y-, Z-)
+0000ffa0: 2065 6e64 206f 6620 6379 6c69 6e64 6572   end of cylinder
+0000ffb0: 2e0a 2f2f 2020 2064 3220 3d20 4469 616d  ..//   d2 = Diam
+0000ffc0: 6574 6572 206f 6620 7468 6520 706f 7369  eter of the posi
+0000ffd0: 7469 7665 2028 582b 2c20 592b 2c20 5a2b  tive (X+, Y+, Z+
+0000ffe0: 2920 656e 6420 6f66 2063 796c 696e 6465  ) end of cylinde
+0000fff0: 722e 0a2f 2f20 2020 6369 7263 756d 203d  r..//   circum =
+00010000: 2049 6620 7472 7565 2c20 6379 6c69 6e64   If true, cylind
+00010010: 6572 2073 686f 756c 6420 6369 7263 756d  er should circum
+00010020: 7363 7269 6265 2074 6865 2063 6972 636c  scribe the circl
+00010030: 6520 6f66 2074 6865 2067 6976 656e 2073  e of the given s
+00010040: 697a 652e 2020 4f74 6865 7277 6973 6520  ize.  Otherwise 
+00010050: 696e 7363 7269 6265 732e 2020 4465 6661  inscribes.  Defa
+00010060: 756c 743a 2060 6661 6c73 6560 0a2f 2f20  ult: `false`.// 
+00010070: 2020 7368 6966 7420 3d20 5b58 2c59 5d20    shift = [X,Y] 
+00010080: 616d 6f75 6e74 2074 6f20 7368 6966 7420  amount to shift 
+00010090: 7468 6520 6365 6e74 6572 206f 6620 7468  the center of th
+000100a0: 6520 746f 7020 656e 6420 7769 7468 2072  e top end with r
+000100b0: 6573 7065 6374 2074 6f20 7468 6520 6365  espect to the ce
+000100c0: 6e74 6572 206f 6620 7468 6520 626f 7474  nter of the bott
+000100d0: 6f6d 2065 6e64 2e0a 2f2f 2020 2063 6861  om end..//   cha
+000100e0: 6d66 6572 203d 2054 6865 2073 697a 6520  mfer = The size 
+000100f0: 6f66 2074 6865 2063 6861 6d66 6572 7320  of the chamfers 
+00010100: 6f6e 2074 6865 2065 6e64 7320 6f66 2074  on the ends of t
+00010110: 6865 2063 796c 696e 6465 722e 2020 2841  he cylinder.  (A
+00010120: 6c73 6f20 7365 653a 2060 6672 6f6d 5f65  lso see: `from_e
+00010130: 6e64 3d60 2920 2044 6566 6175 6c74 3a20  nd=`)  Default: 
+00010140: 6e6f 6e65 2e0a 2f2f 2020 2063 6861 6d66  none..//   chamf
+00010150: 6572 3120 3d20 5468 6520 7369 7a65 206f  er1 = The size o
+00010160: 6620 7468 6520 6368 616d 6665 7220 6f6e  f the chamfer on
+00010170: 2074 6865 2062 6f74 746f 6d20 656e 6420   the bottom end 
+00010180: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00010190: 2020 2841 6c73 6f20 7365 653a 2060 6672    (Also see: `fr
+000101a0: 6f6d 5f65 6e64 313d 6029 2020 4465 6661  om_end1=`)  Defa
+000101b0: 756c 743a 206e 6f6e 652e 0a2f 2f20 2020  ult: none..//   
+000101c0: 6368 616d 6665 7232 203d 2054 6865 2073  chamfer2 = The s
+000101d0: 697a 6520 6f66 2074 6865 2063 6861 6d66  ize of the chamf
+000101e0: 6572 206f 6e20 7468 6520 746f 7020 656e  er on the top en
+000101f0: 6420 6f66 2074 6865 2063 796c 696e 6465  d of the cylinde
+00010200: 722e 2020 2841 6c73 6f20 7365 653a 2060  r.  (Also see: `
+00010210: 6672 6f6d 5f65 6e64 323d 6029 2020 4465  from_end2=`)  De
+00010220: 6661 756c 743a 206e 6f6e 652e 0a2f 2f20  fault: none..// 
+00010230: 2020 6368 616d 6661 6e67 203d 2054 6865    chamfang = The
+00010240: 2061 6e67 6c65 2069 6e20 6465 6772 6565   angle in degree
+00010250: 7320 6f66 2074 6865 2063 6861 6d66 6572  s of the chamfer
+00010260: 7320 6177 6179 2066 726f 6d20 7468 6520  s away from the 
+00010270: 656e 6473 206f 6620 7468 6520 6379 6c69  ends of the cyli
+00010280: 6e64 6572 2e20 2044 6566 6175 6c74 3a20  nder.  Default: 
+00010290: 4368 616d 6665 7220 616e 676c 6520 6973  Chamfer angle is
+000102a0: 2068 616c 6677 6179 2062 6574 7765 656e   halfway between
+000102b0: 2074 6865 2065 6e64 6361 7020 616e 6420   the endcap and 
+000102c0: 636f 6e65 2066 6163 652e 0a2f 2f20 2020  cone face..//   
+000102d0: 6368 616d 6661 6e67 3120 3d20 5468 6520  chamfang1 = The 
+000102e0: 616e 676c 6520 696e 2064 6567 7265 6573  angle in degrees
+000102f0: 206f 6620 7468 6520 626f 7474 6f6d 2063   of the bottom c
+00010300: 6861 6d66 6572 2061 7761 7920 6672 6f6d  hamfer away from
+00010310: 2074 6865 2062 6f74 746f 6d20 656e 6420   the bottom end 
+00010320: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00010330: 2020 4465 6661 756c 743a 2043 6861 6d66    Default: Chamf
+00010340: 6572 2061 6e67 6c65 2069 7320 6861 6c66  er angle is half
+00010350: 7761 7920 6265 7477 6565 6e20 7468 6520  way between the 
+00010360: 656e 6463 6170 2061 6e64 2063 6f6e 6520  endcap and cone 
+00010370: 6661 6365 2e0a 2f2f 2020 2063 6861 6d66  face..//   chamf
+00010380: 616e 6732 203d 2054 6865 2061 6e67 6c65  ang2 = The angle
+00010390: 2069 6e20 6465 6772 6565 7320 6f66 2074   in degrees of t
+000103a0: 6865 2074 6f70 2063 6861 6d66 6572 2061  he top chamfer a
+000103b0: 7761 7920 6672 6f6d 2074 6865 2074 6f70  way from the top
+000103c0: 2065 6e64 206f 6620 7468 6520 6379 6c69   end of the cyli
+000103d0: 6e64 6572 2e20 2044 6566 6175 6c74 3a20  nder.  Default: 
+000103e0: 4368 616d 6665 7220 616e 676c 6520 6973  Chamfer angle is
+000103f0: 2068 616c 6677 6179 2062 6574 7765 656e   halfway between
+00010400: 2074 6865 2065 6e64 6361 7020 616e 6420   the endcap and 
+00010410: 636f 6e65 2066 6163 652e 0a2f 2f20 2020  cone face..//   
+00010420: 6672 6f6d 5f65 6e64 203d 2049 6620 7472  from_end = If tr
+00010430: 7565 2c20 6368 616d 6665 7220 6973 206d  ue, chamfer is m
+00010440: 6561 7375 7265 6420 616c 6f6e 6720 7468  easured along th
+00010450: 6520 636f 6e69 6320 6661 6365 2066 726f  e conic face fro
+00010460: 6d20 7468 6520 656e 6473 206f 6620 7468  m the ends of th
+00010470: 6520 6379 6c69 6e64 6572 2c20 696e 7374  e cylinder, inst
+00010480: 6561 6420 6f66 2069 6e73 6574 2066 726f  ead of inset fro
+00010490: 6d20 7468 6520 6564 6765 2e20 2044 6566  m the edge.  Def
+000104a0: 6175 6c74 3a20 6066 616c 7365 602e 0a2f  ault: `false`../
+000104b0: 2f20 2020 6672 6f6d 5f65 6e64 3120 3d20  /   from_end1 = 
+000104c0: 4966 2074 7275 652c 2063 6861 6d66 6572  If true, chamfer
+000104d0: 206f 6e20 7468 6520 626f 7474 6f6d 2065   on the bottom e
+000104e0: 6e64 206f 6620 7468 6520 6379 6c69 6e64  nd of the cylind
+000104f0: 6572 2069 7320 6d65 6173 7572 6564 2061  er is measured a
+00010500: 6c6f 6e67 2074 6865 2063 6f6e 6963 2066  long the conic f
+00010510: 6163 6520 6672 6f6d 2074 6865 2065 6e64  ace from the end
+00010520: 206f 6620 7468 6520 6379 6c69 6e64 6572   of the cylinder
+00010530: 2c20 696e 7374 6561 6420 6f66 2069 6e73  , instead of ins
+00010540: 6574 2066 726f 6d20 7468 6520 6564 6765  et from the edge
+00010550: 2e20 2044 6566 6175 6c74 3a20 6066 616c  .  Default: `fal
+00010560: 7365 602e 0a2f 2f20 2020 6672 6f6d 5f65  se`..//   from_e
+00010570: 6e64 3220 3d20 4966 2074 7275 652c 2063  nd2 = If true, c
+00010580: 6861 6d66 6572 206f 6e20 7468 6520 746f  hamfer on the to
+00010590: 7020 656e 6420 6f66 2074 6865 2063 796c  p end of the cyl
+000105a0: 696e 6465 7220 6973 206d 6561 7375 7265  inder is measure
+000105b0: 6420 616c 6f6e 6720 7468 6520 636f 6e69  d along the coni
+000105c0: 6320 6661 6365 2066 726f 6d20 7468 6520  c face from the 
+000105d0: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
+000105e0: 6465 722c 2069 6e73 7465 6164 206f 6620  der, instead of 
+000105f0: 696e 7365 7420 6672 6f6d 2074 6865 2065  inset from the e
+00010600: 6467 652e 2020 4465 6661 756c 743a 2060  dge.  Default: `
+00010610: 6661 6c73 6560 2e0a 2f2f 2020 2072 6f75  false`..//   rou
+00010620: 6e64 696e 6720 3d20 5468 6520 7261 6469  nding = The radi
+00010630: 7573 206f 6620 7468 6520 726f 756e 6469  us of the roundi
+00010640: 6e67 206f 6e20 7468 6520 656e 6473 206f  ng on the ends o
+00010650: 6620 7468 6520 6379 6c69 6e64 6572 2e20  f the cylinder. 
+00010660: 2044 6566 6175 6c74 3a20 6e6f 6e65 2e0a   Default: none..
+00010670: 2f2f 2020 2072 6f75 6e64 696e 6731 203d  //   rounding1 =
+00010680: 2054 6865 2072 6164 6975 7320 6f66 2074   The radius of t
+00010690: 6865 2072 6f75 6e64 696e 6720 6f6e 2074  he rounding on t
+000106a0: 6865 2062 6f74 746f 6d20 656e 6420 6f66  he bottom end of
+000106b0: 2074 6865 2063 796c 696e 6465 722e 0a2f   the cylinder../
+000106c0: 2f20 2020 726f 756e 6469 6e67 3220 3d20  /   rounding2 = 
+000106d0: 5468 6520 7261 6469 7573 206f 6620 7468  The radius of th
+000106e0: 6520 726f 756e 6469 6e67 206f 6e20 7468  e rounding on th
+000106f0: 6520 746f 7020 656e 6420 6f66 2074 6865  e top end of the
+00010700: 2063 796c 696e 6465 722e 0a2f 2f20 2020   cylinder..//   
+00010710: 7265 616c 6967 6e20 3d20 4966 2074 7275  realign = If tru
+00010720: 652c 2072 6f74 6174 6520 7468 6520 6379  e, rotate the cy
+00010730: 6c69 6e64 6572 2062 7920 6861 6c66 2074  linder by half t
+00010740: 6865 2061 6e67 6c65 206f 6620 6f6e 6520  he angle of one 
+00010750: 6661 6365 2e0a 2f2f 2020 2074 6578 7475  face..//   textu
+00010760: 7265 203d 2041 2074 6578 7475 7265 206e  re = A texture n
+00010770: 616d 6520 7374 7269 6e67 2c20 6f72 2061  ame string, or a
+00010780: 2072 6563 7461 6e67 756c 6172 2061 7272   rectangular arr
+00010790: 6179 206f 6620 7363 616c 6172 2068 6569  ay of scalar hei
+000107a0: 6768 7420 7661 6c75 6573 2028 302e 3020  ght values (0.0 
+000107b0: 746f 2031 2e30 292c 206f 7220 6120 564e  to 1.0), or a VN
+000107c0: 4620 7469 6c65 2074 6861 7420 6465 6669  F tile that defi
+000107d0: 6e65 7320 7468 6520 7465 7874 7572 6520  nes the texture 
+000107e0: 746f 2061 7070 6c79 2074 6f20 7665 7274  to apply to vert
+000107f0: 6963 616c 2073 7572 6661 6365 732e 2020  ical surfaces.  
+00010800: 5365 6520 7b7b 7465 7874 7572 6528 297d  See {{texture()}
+00010810: 7d20 666f 7220 7768 6174 206e 616d 6564  } for what named
+00010820: 2074 6578 7475 7265 7320 6172 6520 7375   textures are su
+00010830: 7070 6f72 7465 642e 0a2f 2f20 2020 7465  pported..//   te
+00010840: 785f 7369 7a65 203d 2041 6e20 6f70 7469  x_size = An opti
+00010850: 6f6e 616c 2032 4420 7461 7267 6574 2073  onal 2D target s
+00010860: 697a 6520 666f 7220 7468 6520 7465 7874  ize for the text
+00010870: 7572 6573 2e20 2041 6374 7561 6c20 7465  ures.  Actual te
+00010880: 7874 7572 6520 7369 7a65 7320 7769 6c6c  xture sizes will
+00010890: 2062 6520 7363 616c 6564 2073 6f6d 6577   be scaled somew
+000108a0: 6861 7420 746f 2065 7665 6e6c 7920 6669  hat to evenly fi
+000108b0: 7420 7468 6520 6176 6169 6c61 626c 6520  t the available 
+000108c0: 7375 7266 6163 652e 2044 6566 6175 6c74  surface. Default
+000108d0: 3a20 605b 352c 355d 600a 2f2f 2020 2074  : `[5,5]`.//   t
+000108e0: 6578 5f63 6f75 6e74 7320 3d20 4966 2067  ex_counts = If g
+000108f0: 6976 656e 2069 6e73 7465 6164 206f 6620  iven instead of 
+00010900: 7465 785f 7369 7a65 2c20 6769 7665 7320  tex_size, gives 
+00010910: 7468 6520 7469 6c65 2072 6570 6574 6974  the tile repetit
+00010920: 696f 6e20 636f 756e 7473 2066 6f72 2074  ion counts for t
+00010930: 6578 7475 7265 7320 6f76 6572 2074 6865  extures over the
+00010940: 2073 7572 6661 6365 206c 656e 6774 6820   surface length 
+00010950: 616e 6420 6865 6967 6874 2e0a 2f2f 2020  and height..//  
+00010960: 2074 6578 5f69 6e73 6574 203d 2049 6620   tex_inset = If 
+00010970: 6e75 6d65 7269 632c 206c 6f77 6572 7320  numeric, lowers 
+00010980: 7468 6520 7465 7874 7572 6520 696e 746f  the texture into
+00010990: 2074 6865 2073 7572 6661 6365 2062 7920   the surface by 
+000109a0: 7468 6174 2061 6d6f 756e 742c 2062 6566  that amount, bef
+000109b0: 6f72 6520 7468 6520 7465 785f 7363 616c  ore the tex_scal
+000109c0: 6520 6d75 6c74 6970 6c69 6572 2069 7320  e multiplier is 
+000109d0: 6170 706c 6965 642e 2020 4966 2060 7472  applied.  If `tr
+000109e0: 7565 602c 2069 6e73 6574 7320 6279 2065  ue`, insets by e
+000109f0: 7861 6374 6c79 2060 3160 2e20 2044 6566  xactly `1`.  Def
+00010a00: 6175 6c74 3a20 6066 616c 7365 600a 2f2f  ault: `false`.//
+00010a10: 2020 2074 6578 5f72 6f74 203d 2049 6620     tex_rot = If 
+00010a20: 7472 7565 2c20 726f 7461 7465 7320 7468  true, rotates th
+00010a30: 6520 7465 7874 7572 6520 3930 c2ba 2e0a  e texture 90....
+00010a40: 2f2f 2020 2074 6578 5f73 6361 6c65 203d  //   tex_scale =
+00010a50: 2053 6361 6c69 6e67 206d 756c 7469 706c   Scaling multipl
+00010a60: 6965 7220 666f 7220 7468 6520 7465 7874  ier for the text
+00010a70: 7572 6520 6465 7074 682e 0a2f 2f20 2020  ure depth..//   
+00010a80: 7465 785f 7361 6d70 6c65 7320 3d20 4d69  tex_samples = Mi
+00010a90: 6e69 6d75 6d20 6e75 6d62 6572 206f 6620  nimum number of 
+00010aa0: 2262 656e 6420 706f 696e 7473 2220 746f  "bend points" to
+00010ab0: 2068 6176 6520 696e 2056 4e46 2074 6578   have in VNF tex
+00010ac0: 7475 7265 2074 696c 6573 2e20 2044 6566  ture tiles.  Def
+00010ad0: 6175 6c74 3a20 380a 2f2f 2020 2074 6578  ault: 8.//   tex
+00010ae0: 5f73 7479 6c65 203d 207b 7b76 6e66 5f76  _style = {{vnf_v
+00010af0: 6572 7465 785f 6172 7261 7928 297d 7d20  ertex_array()}} 
+00010b00: 7374 796c 6520 7573 6564 2074 6f20 7472  style used to tr
+00010b10: 6961 6e67 756c 6174 6520 6865 6967 6874  iangulate height
+00010b20: 6669 656c 6420 7465 7874 7572 6573 2e20  field textures. 
+00010b30: 2044 6566 6175 6c74 3a20 226d 696e 5f65   Default: "min_e
+00010b40: 6467 6522 0a2f 2f20 2020 7465 785f 7461  dge".//   tex_ta
+00010b50: 7065 7220 3d20 4966 2067 6976 656e 2061  per = If given a
+00010b60: 7320 6120 6e75 6d62 6572 2c20 7461 7065  s a number, tape
+00010b70: 7273 2074 6865 2074 6578 7475 7265 2068  rs the texture h
+00010b80: 6569 6768 7420 746f 207a 6572 6f20 6f76  eight to zero ov
+00010b90: 6572 2074 6865 2066 6972 7374 2061 6e64  er the first and
+00010ba0: 206c 6173 7420 6769 7665 6e20 7065 7263   last given perc
+00010bb0: 656e 7461 6765 206f 6620 7468 6520 7061  entage of the pa
+00010bc0: 7468 2e20 2049 6620 6769 7665 6e20 6173  th.  If given as
+00010bd0: 2061 206c 6f6f 6b75 7020 7461 626c 6520   a lookup table 
+00010be0: 7769 7468 2069 6e64 6963 6573 2062 6574  with indices bet
+00010bf0: 7765 656e 2030 2061 6e64 2031 3030 2c20  ween 0 and 100, 
+00010c00: 7573 6573 2074 6865 2070 6572 6365 6e74  uses the percent
+00010c10: 6167 6520 6c6f 6f6b 7570 2074 6162 6c65  age lookup table
+00010c20: 2074 6f20 7261 6d70 2074 6865 2074 6578   to ramp the tex
+00010c30: 7475 7265 2068 6569 6768 7473 2e20 2044  ture heights.  D
+00010c40: 6566 6175 6c74 3a20 6075 6e64 6566 6020  efault: `undef` 
+00010c50: 286e 6f20 7461 7065 7229 0a2f 2f20 2020  (no taper).//   
+00010c60: 616e 6368 6f72 203d 2054 7261 6e73 6c61  anchor = Transla
+00010c70: 7465 2073 6f20 616e 6368 6f72 2070 6f69  te so anchor poi
+00010c80: 6e74 2069 7320 6174 206f 7269 6769 6e20  nt is at origin 
+00010c90: 2830 2c30 2c30 292e 2020 5365 6520 5b61  (0,0,0).  See [a
+00010ca0: 6e63 686f 725d 2861 7474 6163 686d 656e  nchor](attachmen
+00010cb0: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
+00010cc0: 6f6e 2d61 6e63 686f 7229 2e20 2044 6566  on-anchor).  Def
+00010cd0: 6175 6c74 3a20 6043 454e 5445 5260 0a2f  ault: `CENTER`./
+00010ce0: 2f20 2020 7370 696e 203d 2052 6f74 6174  /   spin = Rotat
+00010cf0: 6520 7468 6973 206d 616e 7920 6465 6772  e this many degr
+00010d00: 6565 7320 6172 6f75 6e64 2074 6865 205a  ees around the Z
+00010d10: 2061 7869 7320 6166 7465 7220 616e 6368   axis after anch
+00010d20: 6f72 2e20 2053 6565 205b 7370 696e 5d28  or.  See [spin](
+00010d30: 6174 7461 6368 6d65 6e74 732e 7363 6164  attachments.scad
+00010d40: 2373 7562 7365 6374 696f 6e2d 7370 696e  #subsection-spin
+00010d50: 292e 2020 4465 6661 756c 743a 2060 3060  ).  Default: `0`
+00010d60: 0a2f 2f20 2020 6f72 6965 6e74 203d 2056  .//   orient = V
+00010d70: 6563 746f 7220 746f 2072 6f74 6174 6520  ector to rotate 
+00010d80: 746f 7020 746f 7761 7264 732c 2061 6674  top towards, aft
+00010d90: 6572 2073 7069 6e2e 2020 5365 6520 5b6f  er spin.  See [o
+00010da0: 7269 656e 745d 2861 7474 6163 686d 656e  rient](attachmen
+00010db0: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
+00010dc0: 6f6e 2d6f 7269 656e 7429 2e20 2044 6566  on-orient).  Def
+00010dd0: 6175 6c74 3a20 6055 5060 0a2f 2f0a 2f2f  ault: `UP`.//.//
+00010de0: 0a2f 2f20 4578 616d 706c 653a 2042 7920  .// Example: By 
+00010df0: 5261 6469 7573 0a2f 2f20 2020 7864 6973  Radius.//   xdis
+00010e00: 7472 6962 7574 6528 3330 2920 7b0a 2f2f  tribute(30) {.//
+00010e10: 2020 2020 2020 2063 796c 286c 3d34 302c         cyl(l=40,
+00010e20: 2072 3d31 3029 3b0a 2f2f 2020 2020 2020   r=10);.//      
+00010e30: 2063 796c 286c 3d34 302c 2072 313d 3130   cyl(l=40, r1=10
+00010e40: 2c20 7232 3d35 293b 0a2f 2f20 2020 7d0a  , r2=5);.//   }.
+00010e50: 2f2f 0a2f 2f20 4578 616d 706c 653a 2042  //.// Example: B
+00010e60: 7920 4469 616d 6574 6572 0a2f 2f20 2020  y Diameter.//   
+00010e70: 7864 6973 7472 6962 7574 6528 3330 2920  xdistribute(30) 
+00010e80: 7b0a 2f2f 2020 2020 2020 2063 796c 286c  {.//       cyl(l
+00010e90: 3d34 302c 2064 3d32 3529 3b0a 2f2f 2020  =40, d=25);.//  
+00010ea0: 2020 2020 2063 796c 286c 3d34 302c 2064       cyl(l=40, d
+00010eb0: 313d 3235 2c20 6432 3d31 3029 3b0a 2f2f  1=25, d2=10);.//
+00010ec0: 2020 207d 0a2f 2f0a 2f2f 2045 7861 6d70     }.//.// Examp
+00010ed0: 6c65 3a20 4368 616d 6665 7272 696e 670a  le: Chamferring.
+00010ee0: 2f2f 2020 2078 6469 7374 7269 6275 7465  //   xdistribute
+00010ef0: 2836 3029 207b 0a2f 2f20 2020 2020 2020  (60) {.//       
+00010f00: 2f2f 2053 686f 776e 204c 6566 7420 746f  // Shown Left to
+00010f10: 2072 6967 6874 2e0a 2f2f 2020 2020 2020   right..//      
+00010f20: 2063 796c 286c 3d34 302c 2064 3d34 302c   cyl(l=40, d=40,
+00010f30: 2063 6861 6d66 6572 3d37 293b 2020 2f2f   chamfer=7);  //
+00010f40: 2044 6566 6175 6c74 2063 6861 6d66 616e   Default chamfan
+00010f50: 673d 3435 0a2f 2f20 2020 2020 2020 6379  g=45.//       cy
+00010f60: 6c28 6c3d 3430 2c20 643d 3430 2c20 6368  l(l=40, d=40, ch
+00010f70: 616d 6665 723d 372c 2063 6861 6d66 616e  amfer=7, chamfan
+00010f80: 673d 3330 2c20 6672 6f6d 5f65 6e64 3d66  g=30, from_end=f
+00010f90: 616c 7365 293b 0a2f 2f20 2020 2020 2020  alse);.//       
+00010fa0: 6379 6c28 6c3d 3430 2c20 643d 3430 2c20  cyl(l=40, d=40, 
+00010fb0: 6368 616d 6665 723d 372c 2063 6861 6d66  chamfer=7, chamf
+00010fc0: 616e 673d 3330 2c20 6672 6f6d 5f65 6e64  ang=30, from_end
+00010fd0: 3d74 7275 6529 3b0a 2f2f 2020 207d 0a2f  =true);.//   }./
+00010fe0: 2f0a 2f2f 2045 7861 6d70 6c65 3a20 526f  /.// Example: Ro
+00010ff0: 756e 6469 6e67 0a2f 2f20 2020 6379 6c28  unding.//   cyl(
+00011000: 6c3d 3430 2c20 643d 3430 2c20 726f 756e  l=40, d=40, roun
+00011010: 6469 6e67 3d31 3029 3b0a 2f2f 0a2f 2f20  ding=10);.//.// 
+00011020: 4578 616d 706c 653a 2048 6574 6572 6f67  Example: Heterog
+00011030: 656e 6f75 7320 4368 616d 6665 7273 2061  enous Chamfers a
+00011040: 6e64 2052 6f75 6e64 696e 670a 2f2f 2020  nd Rounding.//  
+00011050: 2079 6469 7374 7269 6275 7465 2838 3029   ydistribute(80)
+00011060: 207b 0a2f 2f20 2020 2020 2020 2f2f 2053   {.//       // S
+00011070: 686f 776e 2046 726f 6e74 2074 6f20 4261  hown Front to Ba
+00011080: 636b 2e0a 2f2f 2020 2020 2020 2063 796c  ck..//       cyl
+00011090: 286c 3d34 302c 2064 3d34 302c 2072 6f75  (l=40, d=40, rou
+000110a0: 6e64 696e 6731 3d31 352c 206f 7269 656e  nding1=15, orien
+000110b0: 743d 5550 293b 0a2f 2f20 2020 2020 2020  t=UP);.//       
+000110c0: 6379 6c28 6c3d 3430 2c20 643d 3430 2c20  cyl(l=40, d=40, 
+000110d0: 6368 616d 6665 7232 3d35 2c20 6f72 6965  chamfer2=5, orie
+000110e0: 6e74 3d55 5029 3b0a 2f2f 2020 2020 2020  nt=UP);.//      
+000110f0: 2063 796c 286c 3d34 302c 2064 3d34 302c   cyl(l=40, d=40,
+00011100: 2063 6861 6d66 6572 313d 3132 2c20 726f   chamfer1=12, ro
+00011110: 756e 6469 6e67 323d 3130 2c20 6f72 6965  unding2=10, orie
+00011120: 6e74 3d55 5029 3b0a 2f2f 2020 207d 0a2f  nt=UP);.//   }./
+00011130: 2f0a 2f2f 2045 7861 6d70 6c65 3a20 5075  /.// Example: Pu
+00011140: 7474 696e 6720 6974 2061 6c6c 2074 6f67  tting it all tog
+00011150: 6574 6865 720a 2f2f 2020 2063 796c 280a  ether.//   cyl(.
+00011160: 2f2f 2020 2020 2020 206c 3d32 302c 2064  //       l=20, d
+00011170: 313d 3235 2c20 6432 3d31 352c 0a2f 2f20  1=25, d2=15,.// 
+00011180: 2020 2020 2020 6368 616d 6665 7231 3d35        chamfer1=5
+00011190: 2c20 6368 616d 6661 6e67 313d 3630 2c0a  , chamfang1=60,.
+000111a0: 2f2f 2020 2020 2020 2066 726f 6d5f 656e  //       from_en
+000111b0: 643d 7472 7565 2c20 726f 756e 6469 6e67  d=true, rounding
+000111c0: 323d 350a 2f2f 2020 2029 3b0a 2f2f 0a2f  2=5.//   );.//./
+000111d0: 2f20 4578 616d 706c 653a 2045 7874 6572  / Example: Exter
+000111e0: 6e61 6c20 4368 616d 6665 7273 0a2f 2f20  nal Chamfers.// 
+000111f0: 2020 6379 6c28 6c3d 3530 2c20 723d 3330    cyl(l=50, r=30
+00011200: 2c20 6368 616d 6665 723d 2d35 2c20 6368  , chamfer=-5, ch
+00011210: 616d 6661 6e67 3d33 302c 2024 6661 3d31  amfang=30, $fa=1
+00011220: 2c20 2466 733d 3129 3b0a 2f2f 0a2f 2f20  , $fs=1);.//.// 
+00011230: 4578 616d 706c 653a 2045 7874 6572 6e61  Example: Externa
+00011240: 6c20 526f 756e 6469 6e67 730a 2f2f 2020  l Roundings.//  
+00011250: 2063 796c 286c 3d35 302c 2072 3d33 302c   cyl(l=50, r=30,
+00011260: 2072 6f75 6e64 696e 6731 3d2d 352c 2072   rounding1=-5, r
+00011270: 6f75 6e64 696e 6732 3d35 2c20 2466 613d  ounding2=5, $fa=
+00011280: 312c 2024 6673 3d31 293b 0a2f 2f0a 2f2f  1, $fs=1);.//.//
+00011290: 2045 7861 6d70 6c65 284d 6564 293a 2053   Example(Med): S
+000112a0: 7461 6e64 6172 6420 436f 6e6e 6563 746f  tandard Connecto
+000112b0: 7273 0a2f 2f20 2020 7864 6973 7472 6962  rs.//   xdistrib
+000112c0: 7574 6528 3430 2920 7b0a 2f2f 2020 2020  ute(40) {.//    
+000112d0: 2020 2063 796c 286c 3d33 302c 2064 3d32     cyl(l=30, d=2
+000112e0: 3529 2073 686f 775f 616e 6368 6f72 7328  5) show_anchors(
+000112f0: 293b 0a2f 2f20 2020 2020 2020 6379 6c28  );.//       cyl(
+00011300: 6c3d 3330 2c20 6431 3d32 352c 2064 323d  l=30, d1=25, d2=
+00011310: 3130 2920 7368 6f77 5f61 6e63 686f 7273  10) show_anchors
+00011320: 2829 3b0a 2f2f 2020 207d 0a2f 2f0a 2f2f  ();.//   }.//.//
+00011330: 2045 7861 6d70 6c65 3a20 5465 7874 7572   Example: Textur
+00011340: 696e 6720 7769 7468 2068 6569 6768 7466  ing with heightf
+00011350: 6965 6c64 2064 6961 6d6f 6e64 730a 2f2f  ield diamonds.//
+00011360: 2020 2063 796c 2868 3d34 302c 2072 3d32     cyl(h=40, r=2
+00011370: 302c 2074 6578 7475 7265 3d22 6469 616d  0, texture="diam
+00011380: 6f6e 6473 222c 2074 6578 5f73 697a 653d  onds", tex_size=
+00011390: 5b35 2c35 5d29 3b0a 2f2f 0a2f 2f20 4578  [5,5]);.//.// Ex
+000113a0: 616d 706c 653a 2054 6578 7475 7269 6e67  ample: Texturing
+000113b0: 2077 6974 6820 6865 6967 6874 6669 656c   with heightfiel
+000113c0: 6420 7079 7261 6d69 6473 0a2f 2f20 2020  d pyramids.//   
+000113d0: 6379 6c28 683d 3430 2c20 7231 3d32 302c  cyl(h=40, r1=20,
+000113e0: 2072 323d 3135 2c0a 2f2f 2020 2020 2020   r2=15,.//      
+000113f0: 2074 6578 7475 7265 3d22 7079 7261 6d69   texture="pyrami
+00011400: 6473 222c 2074 6578 5f73 697a 653d 5b35  ds", tex_size=[5
+00011410: 2c35 5d2c 0a2f 2f20 2020 2020 2020 7465  ,5],.//       te
+00011420: 785f 7374 796c 653d 2263 6f6e 7665 7822  x_style="convex"
+00011430: 293b 0a2f 2f0a 2f2f 2045 7861 6d70 6c65  );.//.// Example
+00011440: 3a20 5465 7874 7572 696e 6720 7769 7468  : Texturing with
+00011450: 2068 6569 6768 7466 6965 6c64 2074 7275   heightfield tru
+00011460: 6e63 6174 6564 2070 7972 616d 6964 730a  ncated pyramids.
+00011470: 2f2f 2020 2063 796c 2868 3d34 302c 2072  //   cyl(h=40, r
+00011480: 313d 3230 2c20 7232 3d31 352c 2063 6861  1=20, r2=15, cha
+00011490: 6d66 6572 3d35 2c0a 2f2f 2020 2020 2020  mfer=5,.//      
+000114a0: 2074 6578 7475 7265 3d22 7472 756e 635f   texture="trunc_
+000114b0: 7079 7261 6d69 6473 222c 0a2f 2f20 2020  pyramids",.//   
+000114c0: 2020 2020 7465 785f 7369 7a65 3d5b 352c      tex_size=[5,
+000114d0: 355d 2c20 7465 785f 7374 796c 653d 2263  5], tex_style="c
+000114e0: 6f6e 7665 7822 293b 0a2f 2f0a 2f2f 2045  onvex");.//.// E
+000114f0: 7861 6d70 6c65 3a20 5465 7874 7572 696e  xample: Texturin
+00011500: 6720 7769 7468 2056 4e46 2074 696c 6520  g with VNF tile 
+00011510: 2264 6f74 7322 0a2f 2f20 2020 6379 6c28  "dots".//   cyl(
+00011520: 683d 3430 2c20 7231 3d32 302c 2072 323d  h=40, r1=20, r2=
+00011530: 3135 2c20 726f 756e 6469 6e67 3d39 2c0a  15, rounding=9,.
+00011540: 2f2f 2020 2020 2020 2074 6578 7475 7265  //       texture
+00011550: 3d22 646f 7473 222c 2074 6578 5f73 697a  ="dots", tex_siz
+00011560: 653d 5b35 2c35 5d2c 0a2f 2f20 2020 2020  e=[5,5],.//     
+00011570: 2020 7465 785f 7361 6d70 6c65 733d 3629    tex_samples=6)
+00011580: 3b0a 2f2f 0a2f 2f20 4578 616d 706c 653a  ;.//.// Example:
+00011590: 2054 6578 7475 7269 6e67 2077 6974 6820   Texturing with 
+000115a0: 564e 4620 7469 6c65 2022 6272 6963 6b73  VNF tile "bricks
+000115b0: 5f76 6e66 220a 2f2f 2020 2063 796c 2868  _vnf".//   cyl(h
+000115c0: 3d35 302c 2072 313d 3235 2c20 7232 3d32  =50, r1=25, r2=2
+000115d0: 302c 2073 6869 6674 3d5b 302c 3130 5d2c  0, shift=[0,10],
+000115e0: 2072 6f75 6e64 696e 6731 3d2d 3130 2c0a   rounding1=-10,.
+000115f0: 2f2f 2020 2020 2020 2074 6578 7475 7265  //       texture
+00011600: 3d22 6272 6963 6b73 5f76 6e66 222c 2074  ="bricks_vnf", t
+00011610: 6578 5f73 697a 653d 5b31 302c 3130 5d2c  ex_size=[10,10],
+00011620: 0a2f 2f20 2020 2020 2020 7465 785f 7363  .//       tex_sc
+00011630: 616c 653d 302e 352c 2074 6578 5f73 7479  ale=0.5, tex_sty
+00011640: 6c65 3d22 636f 6e63 6176 6522 293b 0a2f  le="concave");./
+00011650: 2f0a 2f2f 2045 7861 6d70 6c65 3a20 4e6f  /.// Example: No
+00011660: 2054 6578 7475 7265 2054 6170 6572 0a2f   Texture Taper./
+00011670: 2f20 2020 6379 6c28 6431 3d32 352c 2064  /   cyl(d1=25, d
+00011680: 323d 3230 2c20 683d 3330 2c20 726f 756e  2=20, h=30, roun
+00011690: 6469 6e67 3d35 2c0a 2f2f 2020 2020 2020  ding=5,.//      
+000116a0: 2074 6578 7475 7265 3d22 7472 756e 635f   texture="trunc_
+000116b0: 7269 6273 222c 2074 6578 5f73 697a 653d  ribs", tex_size=
+000116c0: 5b35 2c31 5d29 3b0a 2f2f 0a2f 2f20 4578  [5,1]);.//.// Ex
+000116d0: 616d 706c 653a 2054 6170 6572 2054 6578  ample: Taper Tex
+000116e0: 7572 6520 6174 2045 7874 7265 6d65 2045  ure at Extreme E
+000116f0: 6e64 730a 2f2f 2020 2063 796c 2864 313d  nds.//   cyl(d1=
+00011700: 3235 2c20 6432 3d32 302c 2068 3d33 302c  25, d2=20, h=30,
+00011710: 2072 6f75 6e64 696e 673d 352c 0a2f 2f20   rounding=5,.// 
+00011720: 2020 2020 2020 7465 7874 7572 653d 2274        texture="t
+00011730: 7275 6e63 5f72 6962 7322 2c20 7465 785f  runc_ribs", tex_
+00011740: 7461 7065 723d 302c 0a2f 2f20 2020 2020  taper=0,.//     
+00011750: 2020 7465 785f 7369 7a65 3d5b 352c 315d    tex_size=[5,1]
+00011760: 293b 0a2f 2f0a 2f2f 2045 7861 6d70 6c65  );.//.// Example
+00011770: 3a20 5461 7065 7220 5465 7874 7572 6520  : Taper Texture 
+00011780: 6f76 6572 2046 6972 7374 2061 6e64 204c  over First and L
+00011790: 6173 7420 3130 250a 2f2f 2020 2063 796c  ast 10%.//   cyl
+000117a0: 2864 313d 3235 2c20 6432 3d32 302c 2068  (d1=25, d2=20, h
+000117b0: 3d33 302c 2072 6f75 6e64 696e 673d 352c  =30, rounding=5,
+000117c0: 0a2f 2f20 2020 2020 2020 7465 7874 7572  .//       textur
+000117d0: 653d 2274 7275 6e63 5f72 6962 7322 2c20  e="trunc_ribs", 
+000117e0: 7465 785f 7461 7065 723d 3130 2c0a 2f2f  tex_taper=10,.//
+000117f0: 2020 2020 2020 2074 6578 5f73 697a 653d         tex_size=
+00011800: 5b35 2c31 5d29 3b0a 2f2f 0a2f 2f20 4578  [5,1]);.//.// Ex
+00011810: 616d 706c 653a 204d 616b 696e 6720 6120  ample: Making a 
+00011820: 436c 6179 2050 6174 7465 726e 2052 6f6c  Clay Pattern Rol
+00011830: 6c65 720a 2f2f 2020 2074 6578 203d 205b  ler.//   tex = [
+00011840: 0a2f 2f20 2020 2020 2020 5b30 2c30 2c30  .//       [0,0,0
+00011850: 2c30 2c30 2c30 2c30 2c30 2c30 2c30 2c30  ,0,0,0,0,0,0,0,0
+00011860: 2c30 2c30 2c30 2c30 2c30 2c5d 2c0a 2f2f  ,0,0,0,0,0,],.//
+00011870: 2020 2020 2020 205b 302c 302c 302c 302c         [0,0,0,0,
+00011880: 302c 302c 302c 302c 302c 302c 302c 302c  0,0,0,0,0,0,0,0,
+00011890: 302c 302c 302c 302c 5d2c 0a2f 2f20 2020  0,0,0,0,],.//   
+000118a0: 2020 2020 5b31 2c31 2c31 2c30 2c30 2c31      [1,1,1,0,0,1
+000118b0: 2c31 2c31 2c31 2c31 2c31 2c31 2c31 2c31  ,1,1,1,1,1,1,1,1
+000118c0: 2c31 2c31 2c5d 2c0a 2f2f 2020 2020 2020  ,1,1,],.//      
+000118d0: 205b 312c 312c 312c 302c 302c 312c 312c   [1,1,1,0,0,1,1,
+000118e0: 312c 312c 312c 312c 312c 312c 312c 312c  1,1,1,1,1,1,1,1,
+000118f0: 312c 5d2c 0a2f 2f20 2020 2020 2020 5b30  1,],.//       [0
+00011900: 2c31 2c31 2c30 2c30 2c31 2c31 2c30 2c30  ,1,1,0,0,1,1,0,0
+00011910: 2c30 2c30 2c30 2c30 2c30 2c30 2c30 2c5d  ,0,0,0,0,0,0,0,]
+00011920: 2c0a 2f2f 2020 2020 2020 205b 302c 312c  ,.//       [0,1,
+00011930: 312c 302c 302c 312c 312c 302c 302c 302c  1,0,0,1,1,0,0,0,
+00011940: 302c 302c 302c 302c 302c 302c 5d2c 0a2f  0,0,0,0,0,0,],./
+00011950: 2f20 2020 2020 2020 5b30 2c31 2c31 2c30  /       [0,1,1,0
+00011960: 2c30 2c31 2c31 2c30 2c30 2c31 2c31 2c31  ,0,1,1,0,0,1,1,1
+00011970: 2c31 2c31 2c31 2c30 2c5d 2c0a 2f2f 2020  ,1,1,1,0,],.//  
+00011980: 2020 2020 205b 302c 312c 312c 302c 302c       [0,1,1,0,0,
+00011990: 312c 312c 302c 302c 312c 312c 312c 312c  1,1,0,0,1,1,1,1,
+000119a0: 312c 312c 302c 5d2c 0a2f 2f20 2020 2020  1,1,0,],.//     
+000119b0: 2020 5b30 2c31 2c31 2c30 2c30 2c31 2c31    [0,1,1,0,0,1,1
+000119c0: 2c30 2c30 2c31 2c31 2c30 2c30 2c31 2c31  ,0,0,1,1,0,0,1,1
+000119d0: 2c30 2c5d 2c0a 2f2f 2020 2020 2020 205b  ,0,],.//       [
+000119e0: 302c 312c 312c 302c 302c 312c 312c 302c  0,1,1,0,0,1,1,0,
+000119f0: 302c 312c 312c 302c 302c 312c 312c 302c  0,1,1,0,0,1,1,0,
+00011a00: 5d2c 0a2f 2f20 2020 2020 2020 5b30 2c31  ],.//       [0,1
+00011a10: 2c31 2c30 2c30 2c31 2c31 2c31 2c31 2c31  ,1,0,0,1,1,1,1,1
+00011a20: 2c31 2c30 2c30 2c31 2c31 2c30 2c5d 2c0a  ,1,0,0,1,1,0,],.
+00011a30: 2f2f 2020 2020 2020 205b 302c 312c 312c  //       [0,1,1,
+00011a40: 302c 302c 312c 312c 312c 312c 312c 312c  0,0,1,1,1,1,1,1,
+00011a50: 302c 302c 312c 312c 302c 5d2c 0a2f 2f20  0,0,1,1,0,],.// 
+00011a60: 2020 2020 2020 5b30 2c31 2c31 2c30 2c30        [0,1,1,0,0
+00011a70: 2c30 2c30 2c30 2c30 2c30 2c30 2c30 2c30  ,0,0,0,0,0,0,0,0
+00011a80: 2c31 2c31 2c30 2c5d 2c0a 2f2f 2020 2020  ,1,1,0,],.//    
+00011a90: 2020 205b 302c 312c 312c 302c 302c 302c     [0,1,1,0,0,0,
+00011aa0: 302c 302c 302c 302c 302c 302c 302c 312c  0,0,0,0,0,0,0,1,
+00011ab0: 312c 302c 5d2c 0a2f 2f20 2020 2020 2020  1,0,],.//       
+00011ac0: 5b30 2c31 2c31 2c31 2c31 2c31 2c31 2c31  [0,1,1,1,1,1,1,1
+00011ad0: 2c31 2c31 2c31 2c31 2c31 2c31 2c31 2c30  ,1,1,1,1,1,1,1,0
+00011ae0: 2c5d 2c0a 2f2f 2020 2020 2020 205b 302c  ,],.//       [0,
+00011af0: 312c 312c 312c 312c 312c 312c 312c 312c  1,1,1,1,1,1,1,1,
+00011b00: 312c 312c 312c 312c 312c 312c 302c 5d2c  1,1,1,1,1,1,0,],
+00011b10: 0a2f 2f20 2020 2020 2020 5b30 2c30 2c30  .//       [0,0,0
+00011b20: 2c30 2c30 2c30 2c30 2c30 2c30 2c30 2c30  ,0,0,0,0,0,0,0,0
+00011b30: 2c30 2c30 2c30 2c30 2c30 2c5d 2c0a 2f2f  ,0,0,0,0,0,],.//
+00011b40: 2020 205d 3b0a 2f2f 2020 2064 6966 6628     ];.//   diff(
+00011b50: 290a 2f2f 2020 2063 796c 2864 3d32 302a  ).//   cyl(d=20*
+00011b60: 3130 2f50 492c 2068 3d31 302c 2063 6861  10/PI, h=10, cha
+00011b70: 6d66 6572 3d30 2c0a 2f2f 2020 2020 2020  mfer=0,.//      
+00011b80: 2074 6578 7475 7265 3d74 6578 2c20 7465   texture=tex, te
+00011b90: 785f 636f 756e 7473 3d5b 3230 2c31 5d2c  x_counts=[20,1],
+00011ba0: 2074 6578 5f73 6361 6c65 3d2d 312c 0a2f   tex_scale=-1,./
+00011bb0: 2f20 2020 2020 2020 7465 785f 7461 7065  /       tex_tape
+00011bc0: 723d 756e 6465 662c 2074 6578 5f73 7479  r=undef, tex_sty
+00011bd0: 6c65 3d22 636f 6e63 6176 6522 2920 7b0a  le="concave") {.
+00011be0: 2f2f 2020 2020 2020 2020 2020 2061 7474  //           att
+00011bf0: 6163 6828 5b54 4f50 2c42 4f54 5d29 207b  ach([TOP,BOT]) {
+00011c00: 0a2f 2f20 2020 2020 2020 2020 2020 2020  .//             
+00011c10: 2020 6379 6c28 6431 3d32 302a 3130 2f50    cyl(d1=20*10/P
+00011c20: 492c 2064 323d 3330 2c20 683d 352c 2061  I, d2=30, h=5, a
+00011c30: 6e63 686f 723d 424f 5429 0a2f 2f20 2020  nchor=BOT).//   
+00011c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c50: 6174 7461 6368 2854 4f50 2920 7b0a 2f2f  attach(TOP) {.//
+00011c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c70: 2020 2020 2020 2074 6167 2822 7265 6d6f         tag("remo
+00011c80: 7665 2229 207a 7363 616c 6528 302e 3529  ve") zscale(0.5)
+00011c90: 2075 7028 3329 2073 7068 6572 6528 643d   up(3) sphere(d=
+00011ca0: 3135 293b 0a2f 2f20 2020 2020 2020 2020  15);.//         
+00011cb0: 2020 2020 2020 2020 2020 7d0a 2f2f 2020            }.//  
+00011cc0: 2020 2020 2020 2020 207d 0a2f 2f20 2020           }.//   
+00011cd0: 7d0a 0a66 756e 6374 696f 6e20 6379 6c28  }..function cyl(
+00011ce0: 0a20 2020 2068 2c20 722c 2063 656e 7465  .    h, r, cente
+00011cf0: 722c 0a20 2020 206c 2c20 7231 2c20 7232  r,.    l, r1, r2
+00011d00: 2c0a 2020 2020 642c 2064 312c 2064 322c  ,.    d, d1, d2,
+00011d10: 0a20 2020 206c 656e 6774 682c 2068 6569  .    length, hei
+00011d20: 6768 742c 0a20 2020 2063 6861 6d66 6572  ght,.    chamfer
+00011d30: 2c20 6368 616d 6665 7231 2c20 6368 616d  , chamfer1, cham
+00011d40: 6665 7232 2c0a 2020 2020 6368 616d 6661  fer2,.    chamfa
+00011d50: 6e67 2c20 6368 616d 6661 6e67 312c 2063  ng, chamfang1, c
+00011d60: 6861 6d66 616e 6732 2c0a 2020 2020 726f  hamfang2,.    ro
+00011d70: 756e 6469 6e67 2c20 726f 756e 6469 6e67  unding, rounding
+00011d80: 312c 2072 6f75 6e64 696e 6732 2c0a 2020  1, rounding2,.  
+00011d90: 2020 6369 7263 756d 3d66 616c 7365 2c20    circum=false, 
+00011da0: 7265 616c 6967 6e3d 6661 6c73 652c 2073  realign=false, s
+00011db0: 6869 6674 3d5b 302c 305d 2c0a 2020 2020  hift=[0,0],.    
+00011dc0: 6672 6f6d 5f65 6e64 2c20 6672 6f6d 5f65  from_end, from_e
+00011dd0: 6e64 312c 2066 726f 6d5f 656e 6432 2c0a  nd1, from_end2,.
+00011de0: 2020 2020 7465 7874 7572 652c 2074 6578      texture, tex
+00011df0: 5f73 697a 653d 5b35 2c35 5d2c 2074 6578  _size=[5,5], tex
+00011e00: 5f63 6f75 6e74 732c 0a20 2020 2074 6578  _counts,.    tex
+00011e10: 5f69 6e73 6574 3d66 616c 7365 2c20 7465  _inset=false, te
+00011e20: 785f 726f 743d 6661 6c73 652c 0a20 2020  x_rot=false,.   
+00011e30: 2074 6578 5f73 6361 6c65 3d31 2c20 7465   tex_scale=1, te
+00011e40: 785f 7361 6d70 6c65 732c 206c 656e 6774  x_samples, lengt
+00011e50: 682c 2068 6569 6768 742c 200a 2020 2020  h, height, .    
+00011e60: 7465 785f 7461 7065 722c 2074 6578 5f73  tex_taper, tex_s
+00011e70: 7479 6c65 3d22 6d69 6e5f 6564 6765 222c  tyle="min_edge",
+00011e80: 200a 2020 2020 616e 6368 6f72 2c20 7370   .    anchor, sp
+00011e90: 696e 3d30 2c20 6f72 6965 6e74 3d55 500a  in=0, orient=UP.
+00011ea0: 2920 3d0a 2020 2020 6c65 7428 0a20 2020  ) =.    let(.   
+00011eb0: 2020 2020 206c 203d 206f 6e65 5f64 6566       l = one_def
+00011ec0: 696e 6564 285b 6c2c 2068 2c20 6c65 6e67  ined([l, h, leng
+00011ed0: 7468 2c20 6865 6967 6874 5d2c 226c 2c68  th, height],"l,h
+00011ee0: 2c6c 656e 6774 682c 6865 6967 6874 222c  ,length,height",
+00011ef0: 6466 6c74 3d31 292c 0a20 2020 2020 2020  dflt=1),.       
+00011f00: 205f 7231 203d 2067 6574 5f72 6164 6975   _r1 = get_radiu
+00011f10: 7328 7231 3d72 312c 2072 3d72 2c20 6431  s(r1=r1, r=r, d1
+00011f20: 3d64 312c 2064 3d64 2c20 6466 6c74 3d31  =d1, d=d, dflt=1
+00011f30: 292c 0a20 2020 2020 2020 205f 7232 203d  ),.        _r2 =
+00011f40: 2067 6574 5f72 6164 6975 7328 7231 3d72   get_radius(r1=r
+00011f50: 322c 2072 3d72 2c20 6431 3d64 322c 2064  2, r=r, d1=d2, d
+00011f60: 3d64 2c20 6466 6c74 3d31 292c 0a20 2020  =d, dflt=1),.   
+00011f70: 2020 2020 2073 6964 6573 203d 2073 6567       sides = seg
+00011f80: 7328 6d61 7828 5f72 312c 5f72 3229 292c  s(max(_r1,_r2)),
+00011f90: 0a20 2020 2020 2020 2073 6320 3d20 6369  .        sc = ci
+00011fa0: 7263 756d 3f20 312f 636f 7328 3138 302f  rcum? 1/cos(180/
+00011fb0: 7369 6465 7329 203a 2031 2c0a 2020 2020  sides) : 1,.    
+00011fc0: 2020 2020 7231 203d 205f 7231 202a 2073      r1 = _r1 * s
+00011fd0: 632c 0a20 2020 2020 2020 2072 3220 3d20  c,.        r2 = 
+00011fe0: 5f72 3220 2a20 7363 2c0a 2020 2020 2020  _r2 * sc,.      
+00011ff0: 2020 7068 6920 3d20 6174 616e 3228 6c2c    phi = atan2(l,
+00012000: 2072 322d 7231 292c 0a20 2020 2020 2020   r2-r1),.       
+00012010: 2061 6e63 686f 7220 3d20 6765 745f 616e   anchor = get_an
+00012020: 6368 6f72 2861 6e63 686f 722c 6365 6e74  chor(anchor,cent
+00012030: 6572 2c42 4f54 2c43 454e 5445 5229 0a20  er,BOT,CENTER). 
+00012040: 2020 2029 0a20 2020 2061 7373 6572 7428     ).    assert(
+00012050: 6973 5f66 696e 6974 6528 6c29 2c20 226c  is_finite(l), "l
+00012060: 2f68 2f6c 656e 6774 682f 6865 6967 6874  /h/length/height
+00012070: 206d 7573 7420 6265 2061 2066 696e 6974   must be a finit
+00012080: 6520 6e75 6d62 6572 2e22 290a 2020 2020  e number.").    
+00012090: 6173 7365 7274 2869 735f 6669 6e69 7465  assert(is_finite
+000120a0: 2872 3129 2c20 2272 2f72 312f 642f 6431  (r1), "r/r1/d/d1
+000120b0: 206d 7573 7420 6265 2061 2066 696e 6974   must be a finit
+000120c0: 6520 6e75 6d62 6572 2e22 290a 2020 2020  e number.").    
+000120d0: 6173 7365 7274 2869 735f 6669 6e69 7465  assert(is_finite
+000120e0: 2872 3229 2c20 2272 3220 6f72 2064 3220  (r2), "r2 or d2 
+000120f0: 6d75 7374 2062 6520 6120 6669 6e69 7465  must be a finite
+00012100: 206e 756d 6265 722e 2229 0a20 2020 2061   number.").    a
+00012110: 7373 6572 7428 6973 5f76 6563 746f 7228  ssert(is_vector(
+00012120: 7368 6966 742c 3229 2c20 2273 6869 6674  shift,2), "shift
+00012130: 206d 7573 7420 6265 2061 2032 4420 7665   must be a 2D ve
+00012140: 6374 6f72 2e22 290a 2020 2020 6c65 7428  ctor.").    let(
+00012150: 0a20 2020 2020 2020 2076 6e66 203d 2021  .        vnf = !
+00012160: 616e 795f 6465 6669 6e65 6428 5b63 6861  any_defined([cha
+00012170: 6d66 6572 2c20 6368 616d 6665 7231 2c20  mfer, chamfer1, 
+00012180: 6368 616d 6665 7232 2c20 726f 756e 6469  chamfer2, roundi
+00012190: 6e67 2c20 726f 756e 6469 6e67 312c 2072  ng, rounding1, r
+000121a0: 6f75 6e64 696e 6732 2c20 7465 7874 7572  ounding2, textur
+000121b0: 655d 290a 2020 2020 2020 2020 2020 3f20  e]).          ? 
+000121c0: 6379 6c69 6e64 6572 2868 3d6c 2c20 7231  cylinder(h=l, r1
+000121d0: 3d72 312c 2072 323d 7232 2c20 6365 6e74  =r1, r2=r2, cent
+000121e0: 6572 3d74 7275 652c 2024 666e 3d73 6964  er=true, $fn=sid
+000121f0: 6573 290a 2020 2020 2020 2020 2020 3a20  es).          : 
+00012200: 6c65 7428 0a20 2020 2020 2020 2020 2020  let(.           
+00012210: 2020 2020 2076 616e 6720 3d20 6174 616e       vang = atan
+00012220: 3228 7231 2d72 322c 6c29 2c0a 2020 2020  2(r1-r2,l),.    
+00012230: 2020 2020 2020 2020 2020 2020 5f63 6861              _cha
+00012240: 6d66 3120 3d20 6669 7273 745f 6465 6669  mf1 = first_defi
+00012250: 6e65 6428 5b63 6861 6d66 6572 312c 2069  ned([chamfer1, i
+00012260: 6620 2869 735f 756e 6465 6628 726f 756e  f (is_undef(roun
+00012270: 6469 6e67 3129 2920 6368 616d 6665 722c  ding1)) chamfer,
+00012280: 2030 5d29 2c0a 2020 2020 2020 2020 2020   0]),.          
+00012290: 2020 2020 2020 5f63 6861 6d66 3220 3d20        _chamf2 = 
+000122a0: 6669 7273 745f 6465 6669 6e65 6428 5b63  first_defined([c
+000122b0: 6861 6d66 6572 322c 2069 6620 2869 735f  hamfer2, if (is_
+000122c0: 756e 6465 6628 726f 756e 6469 6e67 3229  undef(rounding2)
+000122d0: 2920 6368 616d 6665 722c 2030 5d29 2c0a  ) chamfer, 0]),.
+000122e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000122f0: 5f66 726f 6d65 6e64 3120 3d20 6669 7273  _fromend1 = firs
+00012300: 745f 6465 6669 6e65 6428 5b66 726f 6d5f  t_defined([from_
+00012310: 656e 6431 2c20 6672 6f6d 5f65 6e64 2c20  end1, from_end, 
+00012320: 6661 6c73 655d 292c 0a20 2020 2020 2020  false]),.       
+00012330: 2020 2020 2020 2020 205f 6672 6f6d 656e           _fromen
+00012340: 6432 203d 2066 6972 7374 5f64 6566 696e  d2 = first_defin
+00012350: 6564 285b 6672 6f6d 5f65 6e64 322c 2066  ed([from_end2, f
+00012360: 726f 6d5f 656e 642c 2066 616c 7365 5d29  rom_end, false])
+00012370: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00012380: 2020 6368 616e 6731 203d 2066 6972 7374    chang1 = first
+00012390: 5f64 6566 696e 6564 285b 6368 616d 6661  _defined([chamfa
+000123a0: 6e67 312c 2063 6861 6d66 616e 672c 2034  ng1, chamfang, 4
+000123b0: 352b 7369 676e 285f 6368 616d 6631 292a  5+sign(_chamf1)*
+000123c0: 7661 6e67 2f32 5d29 2c0a 2020 2020 2020  vang/2]),.      
+000123d0: 2020 2020 2020 2020 2020 6368 616e 6732            chang2
+000123e0: 203d 2066 6972 7374 5f64 6566 696e 6564   = first_defined
+000123f0: 285b 6368 616d 6661 6e67 322c 2063 6861  ([chamfang2, cha
+00012400: 6d66 616e 672c 2034 352d 7369 676e 285f  mfang, 45-sign(_
+00012410: 6368 616d 6632 292a 7661 6e67 2f32 5d29  chamf2)*vang/2])
+00012420: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00012430: 2020 726f 756e 6431 203d 2066 6972 7374    round1 = first
+00012440: 5f64 6566 696e 6564 285b 726f 756e 6469  _defined([roundi
+00012450: 6e67 312c 2069 6620 2869 735f 756e 6465  ng1, if (is_unde
+00012460: 6628 6368 616d 6665 7231 2929 2072 6f75  f(chamfer1)) rou
+00012470: 6e64 696e 672c 2030 5d29 2c0a 2020 2020  nding, 0]),.    
+00012480: 2020 2020 2020 2020 2020 2020 726f 756e              roun
+00012490: 6432 203d 2066 6972 7374 5f64 6566 696e  d2 = first_defin
+000124a0: 6564 285b 726f 756e 6469 6e67 322c 2069  ed([rounding2, i
+000124b0: 6620 2869 735f 756e 6465 6628 6368 616d  f (is_undef(cham
+000124c0: 6665 7232 2929 2072 6f75 6e64 696e 672c  fer2)) rounding,
+000124d0: 2030 5d29 2c0a 2020 2020 2020 2020 2020   0]),.          
+000124e0: 2020 2020 2020 6368 6563 6b73 3120 3d0a        checks1 =.
+000124f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012500: 2020 2020 6173 7365 7274 2869 735f 6669      assert(is_fi
+00012510: 6e69 7465 285f 6368 616d 6631 292c 2022  nite(_chamf1), "
+00012520: 6368 616d 6665 7231 206d 7573 7420 6265  chamfer1 must be
+00012530: 2061 2066 696e 6974 6520 6e75 6d62 6572   a finite number
+00012540: 2069 6620 6769 7665 6e2e 2229 0a20 2020   if given.").   
+00012550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012560: 2061 7373 6572 7428 6973 5f66 696e 6974   assert(is_finit
+00012570: 6528 5f63 6861 6d66 3229 2c20 2263 6861  e(_chamf2), "cha
+00012580: 6d66 6572 3220 6d75 7374 2062 6520 6120  mfer2 must be a 
+00012590: 6669 6e69 7465 206e 756d 6265 7220 6966  finite number if
+000125a0: 2067 6976 656e 2e22 290a 2020 2020 2020   given.").      
+000125b0: 2020 2020 2020 2020 2020 2020 2020 6173                as
+000125c0: 7365 7274 2869 735f 6669 6e69 7465 2863  sert(is_finite(c
+000125d0: 6861 6e67 3129 2026 2620 6368 616e 6731  hang1) && chang1
+000125e0: 3e30 2c20 2263 6861 6d66 616e 6731 206d  >0, "chamfang1 m
+000125f0: 7573 7420 6265 2061 2070 6f73 6974 6976  ust be a positiv
+00012600: 6520 6e75 6d62 6572 2069 6620 6769 7665  e number if give
+00012610: 6e2e 2229 0a20 2020 2020 2020 2020 2020  n.").           
+00012620: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
+00012630: 6973 5f66 696e 6974 6528 6368 616e 6732  is_finite(chang2
+00012640: 2920 2626 2063 6861 6e67 323e 302c 2022  ) && chang2>0, "
+00012650: 6368 616d 6661 6e67 3220 6d75 7374 2062  chamfang2 must b
+00012660: 6520 6120 706f 7369 7469 7665 206e 756d  e a positive num
+00012670: 6265 7220 6966 2067 6976 656e 2e22 290a  ber if given.").
+00012680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012690: 2020 2020 6173 7365 7274 2863 6861 6e67      assert(chang
+000126a0: 313c 3930 2b73 6967 6e28 5f63 6861 6d66  1<90+sign(_chamf
+000126b0: 3129 2a76 616e 672c 2022 6368 616d 6661  1)*vang, "chamfa
+000126c0: 6e67 3120 6d75 7374 2062 6520 736d 616c  ng1 must be smal
+000126d0: 6c65 7220 7468 616e 2074 6865 2063 6f6e  ler than the con
+000126e0: 6520 6661 6365 2061 6e67 6c65 2229 0a20  e face angle"). 
+000126f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012700: 2020 2061 7373 6572 7428 6368 616e 6732     assert(chang2
+00012710: 3c39 302d 7369 676e 285f 6368 616d 6632  <90-sign(_chamf2
+00012720: 292a 7661 6e67 2c20 2263 6861 6d66 616e  )*vang, "chamfan
+00012730: 6732 206d 7573 7420 6265 2073 6d61 6c6c  g2 must be small
+00012740: 6572 2074 6861 6e20 7468 6520 636f 6e65  er than the cone
+00012750: 2066 6163 6520 616e 676c 6522 290a 2020   face angle").  
+00012760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012770: 2020 6173 7365 7274 286e 756d 5f64 6566    assert(num_def
+00012780: 696e 6564 285b 6368 616d 6665 7231 2c72  ined([chamfer1,r
+00012790: 6f75 6e64 696e 6731 5d29 3c32 2c20 2263  ounding1])<2, "c
+000127a0: 616e 6e6f 7420 6465 6669 6e65 2062 6f74  annot define bot
+000127b0: 6820 6368 616d 6665 7231 2061 6e64 2072  h chamfer1 and r
+000127c0: 6f75 6e64 696e 6731 2229 0a20 2020 2020  ounding1").     
+000127d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000127e0: 7373 6572 7428 6e75 6d5f 6465 6669 6e65  ssert(num_define
+000127f0: 6428 5b63 6861 6d66 6572 322c 726f 756e  d([chamfer2,roun
+00012800: 6469 6e67 325d 293c 322c 2022 6361 6e6e  ding2])<2, "cann
+00012810: 6f74 2064 6566 696e 6520 626f 7468 2063  ot define both c
+00012820: 6861 6d66 6572 3220 616e 6420 726f 756e  hamfer2 and roun
+00012830: 6469 6e67 3222 290a 2020 2020 2020 2020  ding2").        
+00012840: 2020 2020 2020 2020 2020 2020 6173 7365              asse
+00012850: 7274 286e 756d 5f64 6566 696e 6564 285b  rt(num_defined([
+00012860: 6368 616d 6665 722c 726f 756e 6469 6e67  chamfer,rounding
+00012870: 5d29 3c32 2c20 2263 616e 6e6f 7420 6465  ])<2, "cannot de
+00012880: 6669 6e65 2062 6f74 6820 6368 616d 6665  fine both chamfe
+00012890: 7220 616e 6420 726f 756e 6469 6e67 2229  r and rounding")
+000128a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000128d0: 2020 2020 2075 6e64 6566 2c0a 2020 2020       undef,.    
+000128e0: 2020 2020 2020 2020 2020 2020 6368 616d              cham
+000128f0: 6631 7220 3d20 215f 6368 616d 6631 3f20  f1r = !_chamf1? 
+00012900: 300a 2020 2020 2020 2020 2020 2020 2020  0.              
+00012910: 2020 2020 2020 2020 2020 3a20 215f 6672            : !_fr
+00012920: 6f6d 656e 6431 3f20 5f63 6861 6d66 310a  omend1? _chamf1.
+00012930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012940: 2020 2020 2020 2020 3a20 6c61 775f 6f66          : law_of
+00012950: 5f73 696e 6573 2861 3d5f 6368 616d 6631  _sines(a=_chamf1
+00012960: 2c20 413d 6368 616e 6731 2c20 423d 3138  , A=chang1, B=18
+00012970: 302d 6368 616e 6731 2d28 3930 2d73 6967  0-chang1-(90-sig
+00012980: 6e28 5f63 6861 6d66 3229 2a76 616e 6729  n(_chamf2)*vang)
+00012990: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+000129a0: 2020 2063 6861 6d66 3272 203d 2021 5f63     chamf2r = !_c
+000129b0: 6861 6d66 323f 2030 0a20 2020 2020 2020  hamf2? 0.       
+000129c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000129d0: 203a 2021 5f66 726f 6d65 6e64 323f 205f   : !_fromend2? _
+000129e0: 6368 616d 6632 0a20 2020 2020 2020 2020  chamf2.         
+000129f0: 2020 2020 2020 2020 2020 2020 2020 203a                 :
+00012a00: 206c 6177 5f6f 665f 7369 6e65 7328 613d   law_of_sines(a=
+00012a10: 5f63 6861 6d66 322c 2041 3d63 6861 6e67  _chamf2, A=chang
+00012a20: 322c 2042 3d31 3830 2d63 6861 6e67 322d  2, B=180-chang2-
+00012a30: 2839 302b 7369 676e 285f 6368 616d 6632  (90+sign(_chamf2
+00012a40: 292a 7661 6e67 2929 2c0a 2020 2020 2020  )*vang)),.      
+00012a50: 2020 2020 2020 2020 2020 6368 616d 6631            chamf1
+00012a60: 6c20 3d20 215f 6368 616d 6631 3f20 300a  l = !_chamf1? 0.
+00012a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012a80: 2020 2020 2020 2020 3a20 5f66 726f 6d65          : _frome
+00012a90: 6e64 313f 2061 6273 285f 6368 616d 6631  nd1? abs(_chamf1
+00012aa0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012ab0: 2020 2020 2020 2020 2020 3a20 6162 7328            : abs(
+00012ac0: 6c61 775f 6f66 5f73 696e 6573 2861 3d5f  law_of_sines(a=_
+00012ad0: 6368 616d 6631 2c20 413d 3138 302d 6368  chamf1, A=180-ch
+00012ae0: 616e 6731 2d28 3930 2d73 6967 6e28 5f63  ang1-(90-sign(_c
+00012af0: 6861 6d66 3129 2a76 616e 6729 2c20 423d  hamf1)*vang), B=
+00012b00: 6368 616e 6731 2929 2c0a 2020 2020 2020  chang1)),.      
+00012b10: 2020 2020 2020 2020 2020 6368 616d 6632            chamf2
+00012b20: 6c20 3d20 215f 6368 616d 6632 3f20 300a  l = !_chamf2? 0.
+00012b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012b40: 2020 2020 2020 2020 3a20 5f66 726f 6d65          : _frome
+00012b50: 6e64 323f 2061 6273 285f 6368 616d 6632  nd2? abs(_chamf2
+00012b60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012b70: 2020 2020 2020 2020 2020 3a20 6162 7328            : abs(
+00012b80: 6c61 775f 6f66 5f73 696e 6573 2861 3d5f  law_of_sines(a=_
+00012b90: 6368 616d 6632 2c20 413d 3138 302d 6368  chamf2, A=180-ch
+00012ba0: 616e 6732 2d28 3930 2b73 6967 6e28 5f63  ang2-(90+sign(_c
+00012bb0: 6861 6d66 3229 2a76 616e 6729 2c20 423d  hamf2)*vang), B=
+00012bc0: 6368 616e 6732 2929 2c0a 2020 2020 2020  chang2)),.      
+00012bd0: 2020 2020 2020 2020 2020 6661 6365 6c65            facele
+00012be0: 6e20 3d20 6164 6a5f 616e 675f 746f 5f68  n = adj_ang_to_h
+00012bf0: 7970 286c 2c20 6162 7328 7661 6e67 2929  yp(l, abs(vang))
+00012c00: 2c0a 0a20 2020 2020 2020 2020 2020 2020  ,..             
+00012c10: 2020 2063 7031 203d 205b 7231 2c2d 6c2f     cp1 = [r1,-l/
+00012c20: 325d 2c0a 2020 2020 2020 2020 2020 2020  2],.            
+00012c30: 2020 2020 6370 3220 3d20 5b72 322c 2b6c      cp2 = [r2,+l
+00012c40: 2f32 5d2c 0a20 2020 2020 2020 2020 2020  /2],.           
+00012c50: 2020 2020 2072 6f75 6e64 6c65 6e31 203d       roundlen1 =
+00012c60: 2072 6f75 6e64 3120 3e3d 2030 203f 2072   round1 >= 0 ? r
+00012c70: 6f75 6e64 312f 7461 6e28 3435 2d76 616e  ound1/tan(45-van
+00012c80: 672f 3229 0a20 2020 2020 2020 2020 2020  g/2).           
+00012c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012ca0: 2020 2020 2020 2020 2020 2020 203a 2072               : r
+00012cb0: 6f75 6e64 312f 7461 6e28 3435 2b76 616e  ound1/tan(45+van
+00012cc0: 672f 3229 2c0a 2020 2020 2020 2020 2020  g/2),.          
+00012cd0: 2020 2020 2020 726f 756e 646c 656e 3220        roundlen2 
+00012ce0: 3d20 726f 756e 6432 203e 3d30 203f 2072  = round2 >=0 ? r
+00012cf0: 6f75 6e64 322f 7461 6e28 3435 2b76 616e  ound2/tan(45+van
+00012d00: 672f 3229 0a20 2020 2020 2020 2020 2020  g/2).           
+00012d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012d20: 2020 2020 2020 2020 2020 2020 3a20 726f              : ro
+00012d30: 756e 6432 2f74 616e 2834 352d 7661 6e67  und2/tan(45-vang
+00012d40: 2f32 292c 0a20 2020 2020 2020 2020 2020  /2),.           
+00012d50: 2020 2020 2064 7931 203d 2061 6273 285f       dy1 = abs(_
+00012d60: 6368 616d 6631 203f 2063 6861 6d66 316c  chamf1 ? chamf1l
+00012d70: 203a 2072 6f75 6e64 3120 3f20 726f 756e   : round1 ? roun
+00012d80: 646c 656e 3120 3a20 3029 2c20 0a20 2020  dlen1 : 0), .   
+00012d90: 2020 2020 2020 2020 2020 2020 2064 7932               dy2
+00012da0: 203d 2061 6273 285f 6368 616d 6632 203f   = abs(_chamf2 ?
+00012db0: 2063 6861 6d66 326c 203a 2072 6f75 6e64   chamf2l : round
+00012dc0: 3220 3f20 726f 756e 646c 656e 3220 3a20  2 ? roundlen2 : 
+00012dd0: 3029 2c0a 0a20 2020 2020 2020 2020 2020  0),..           
+00012de0: 2020 2020 2063 6865 636b 7332 203d 0a20       checks2 =. 
+00012df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e00: 2020 2061 7373 6572 7428 6973 5f66 696e     assert(is_fin
+00012e10: 6974 6528 726f 756e 6431 292c 2022 726f  ite(round1), "ro
+00012e20: 756e 6469 6e67 3120 6d75 7374 2062 6520  unding1 must be 
+00012e30: 6120 6e75 6d62 6572 2069 6620 6769 7665  a number if give
+00012e40: 6e2e 2229 0a20 2020 2020 2020 2020 2020  n.").           
+00012e50: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
+00012e60: 6973 5f66 696e 6974 6528 726f 756e 6432  is_finite(round2
+00012e70: 292c 2022 726f 756e 6469 6e67 3220 6d75  ), "rounding2 mu
+00012e80: 7374 2062 6520 6120 6e75 6d62 6572 2069  st be a number i
+00012e90: 6620 6769 7665 6e2e 2229 0a20 2020 2020  f given.").     
+00012ea0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00012eb0: 7373 6572 7428 6368 616d 6631 7220 3c3d  ssert(chamf1r <=
+00012ec0: 2072 312c 2022 6368 616d 6665 7231 2069   r1, "chamfer1 i
+00012ed0: 7320 6c61 7267 6572 2074 6861 6e20 7468  s larger than th
+00012ee0: 6520 7231 2072 6164 6975 7320 6f66 2074  e r1 radius of t
+00012ef0: 6865 2063 796c 696e 6465 722e 2229 0a20  he cylinder."). 
+00012f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012f10: 2020 2061 7373 6572 7428 6368 616d 6632     assert(chamf2
+00012f20: 7220 3c3d 2072 322c 2022 6368 616d 6665  r <= r2, "chamfe
+00012f30: 7232 2069 7320 6c61 7267 6572 2074 6861  r2 is larger tha
+00012f40: 6e20 7468 6520 7232 2072 6164 6975 7320  n the r2 radius 
+00012f50: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00012f60: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+00012f70: 2020 2020 2020 2061 7373 6572 7428 726f         assert(ro
+00012f80: 756e 646c 656e 3120 3c3d 2072 312c 2022  undlen1 <= r1, "
+00012f90: 7369 7a65 206f 6620 726f 756e 6469 6e67  size of rounding
+00012fa0: 3120 6973 206c 6172 6765 7220 7468 616e  1 is larger than
+00012fb0: 2074 6865 2072 3120 7261 6469 7573 206f   the r1 radius o
+00012fc0: 6620 7468 6520 6379 6c69 6e64 6572 2e22  f the cylinder."
+00012fd0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012fe0: 2020 2020 2020 6173 7365 7274 2872 6f75        assert(rou
+00012ff0: 6e64 6c65 6e32 203c 3d20 7232 2c20 2273  ndlen2 <= r2, "s
+00013000: 697a 6520 6f66 2072 6f75 6e64 696e 6732  ize of rounding2
+00013010: 2069 7320 6c61 7267 6572 2074 6861 6e20   is larger than 
+00013020: 7468 6520 7232 2072 6164 6975 7320 6f66  the r2 radius of
+00013030: 2074 6865 2063 796c 696e 6465 722e 2229   the cylinder.")
+00013040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013050: 2020 2020 2061 7373 6572 7428 6479 312b       assert(dy1+
+00013060: 6479 3220 3c3d 2066 6163 656c 656e 2c20  dy2 <= facelen, 
+00013070: 2243 6861 6d66 6572 732f 726f 756e 6469  "Chamfers/roundi
+00013080: 6e67 7320 646f 6e27 7420 6669 7420 6f6e  ngs don't fit on
+00013090: 2074 6865 2063 796c 696e 6465 722f 636f   the cylinder/co
+000130a0: 6e65 2e20 2054 6865 7920 6578 6365 6564  ne.  They exceed
+000130b0: 2074 6865 206c 656e 6774 6820 6f66 2074   the length of t
+000130c0: 6865 2063 796c 696e 6465 722f 636f 6e65  he cylinder/cone
+000130d0: 2066 6163 652e 2229 0a20 2020 2020 2020   face.").       
+000130e0: 2020 2020 2020 2020 2020 2020 2075 6e64               und
+000130f0: 6566 2c0a 2020 2020 2020 2020 2020 2020  ef,.            
+00013100: 2020 2020 7061 7468 203d 205b 0a20 2020      path = [.   
+00013110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013120: 2069 6620 2874 6578 7475 7265 3d3d 756e   if (texture==un
+00013130: 6465 6629 205b 302c 2d6c 2f32 5d2c 0a20  def) [0,-l/2],. 
+00013140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013150: 2020 2069 6620 2821 6170 7072 6f78 2863     if (!approx(c
+00013160: 6861 6d66 3172 2c30 2929 0a20 2020 2020  hamf1r,0)).     
+00013170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013180: 2020 2065 6163 6820 5b0a 2020 2020 2020     each [.      
+00013190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000131a0: 2020 2020 2020 5b72 312c 202d 6c2f 325d        [r1, -l/2]
+000131b0: 202b 2070 6f6c 6172 5f74 6f5f 7879 2863   + polar_to_xy(c
+000131c0: 6861 6d66 3172 2c31 3830 292c 0a20 2020  hamf1r,180),.   
+000131d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000131e0: 2020 2020 2020 2020 205b 7231 2c20 2d6c           [r1, -l
+000131f0: 2f32 5d20 2b20 706f 6c61 725f 746f 5f78  /2] + polar_to_x
+00013200: 7928 6368 616d 6631 6c2c 3930 2b76 616e  y(chamf1l,90+van
+00013210: 6729 2c0a 2020 2020 2020 2020 2020 2020  g),.            
+00013220: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+00013230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013240: 2020 656c 7365 2069 6620 2821 6170 7072    else if (!appr
+00013250: 6f78 2872 6f75 6e64 312c 3029 290a 2020  ox(round1,0)).  
+00013260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013270: 2020 2020 2020 6561 6368 2061 7263 2872        each arc(r
+00013280: 3d61 6273 2872 6f75 6e64 3129 2c20 636f  =abs(round1), co
+00013290: 726e 6572 3d5b 5b6d 6178 2830 2c72 312d  rner=[[max(0,r1-
+000132a0: 322a 726f 756e 646c 656e 3129 2c2d 6c2f  2*roundlen1),-l/
+000132b0: 325d 2c5b 7231 2c2d 6c2f 325d 2c5b 7232  2],[r1,-l/2],[r2
+000132c0: 2c6c 2f32 5d5d 290a 2020 2020 2020 2020  ,l/2]]).        
+000132d0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+000132e0: 205b 7231 2c2d 6c2f 325d 2c0a 2020 2020   [r1,-l/2],.    
+000132f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013300: 6966 2028 6973 5f66 696e 6974 6528 6368  if (is_finite(ch
+00013310: 616d 6632 7229 2026 2620 2161 7070 726f  amf2r) && !appro
+00013320: 7828 6368 616d 6632 722c 3029 290a 2020  x(chamf2r,0)).  
+00013330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013340: 2020 2020 2020 6561 6368 205b 0a20 2020        each [.   
+00013350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013360: 2020 2020 2020 2020 205b 7232 2c20 6c2f           [r2, l/
+00013370: 325d 202b 2070 6f6c 6172 5f74 6f5f 7879  2] + polar_to_xy
+00013380: 2863 6861 6d66 326c 2c32 3730 2b76 616e  (chamf2l,270+van
+00013390: 6729 2c0a 2020 2020 2020 2020 2020 2020  g),.            
+000133a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000133b0: 5b72 322c 206c 2f32 5d20 2b20 706f 6c61  [r2, l/2] + pola
+000133c0: 725f 746f 5f78 7928 6368 616d 6632 722c  r_to_xy(chamf2r,
+000133d0: 3138 3029 2c0a 2020 2020 2020 2020 2020  180),.          
+000133e0: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
+000133f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013400: 2020 2020 656c 7365 2069 6620 2869 735f      else if (is_
+00013410: 6669 6e69 7465 2872 6f75 6e64 3229 2026  finite(round2) &
+00013420: 2620 2161 7070 726f 7828 726f 756e 6432  & !approx(round2
+00013430: 2c30 2929 0a20 2020 2020 2020 2020 2020  ,0)).           
+00013440: 2020 2020 2020 2020 2020 2020 2065 6163               eac
+00013450: 6820 6172 6328 723d 6162 7328 726f 756e  h arc(r=abs(roun
+00013460: 6432 292c 2063 6f72 6e65 723d 5b5b 7231  d2), corner=[[r1
+00013470: 2c2d 6c2f 325d 2c5b 7232 2c6c 2f32 5d2c  ,-l/2],[r2,l/2],
+00013480: 5b6d 6178 2830 2c72 322d 322a 726f 756e  [max(0,r2-2*roun
+00013490: 646c 656e 3229 2c6c 2f32 5d5d 290a 2020  dlen2),l/2]]).  
+000134a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000134b0: 2020 656c 7365 205b 7232 2c6c 2f32 5d2c    else [r2,l/2],
+000134c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000134d0: 2020 2020 2069 6620 2874 6578 7475 7265       if (texture
+000134e0: 3d3d 756e 6465 6629 205b 302c 6c2f 325d  ==undef) [0,l/2]
+000134f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013500: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
+00013510: 2920 726f 7461 7465 5f73 7765 6570 2870  ) rotate_sweep(p
+00013520: 6174 682c 0a20 2020 2020 2020 2020 2020  ath,.           
+00013530: 2020 2020 2074 6578 7475 7265 3d74 6578       texture=tex
+00013540: 7475 7265 2c20 7465 785f 636f 756e 7473  ture, tex_counts
+00013550: 3d74 6578 5f63 6f75 6e74 732c 2074 6578  =tex_counts, tex
+00013560: 5f73 697a 653d 7465 785f 7369 7a65 2c0a  _size=tex_size,.
+00013570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013580: 7465 785f 696e 7365 743d 7465 785f 696e  tex_inset=tex_in
+00013590: 7365 742c 2074 6578 5f72 6f74 3d74 6578  set, tex_rot=tex
+000135a0: 5f72 6f74 2c0a 2020 2020 2020 2020 2020  _rot,.          
+000135b0: 2020 2020 2020 7465 785f 7363 616c 653d        tex_scale=
+000135c0: 7465 785f 7363 616c 652c 2074 6578 5f73  tex_scale, tex_s
+000135d0: 616d 706c 6573 3d74 6578 5f73 616d 706c  amples=tex_sampl
+000135e0: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
+000135f0: 2020 2020 7465 785f 7461 7065 723d 7465      tex_taper=te
+00013600: 785f 7461 7065 722c 2073 7479 6c65 3d74  x_taper, style=t
+00013610: 6578 5f73 7479 6c65 2c20 636c 6f73 6564  ex_style, closed
+00013620: 3d66 616c 7365 0a20 2020 2020 2020 2020  =false.         
+00013630: 2020 2029 2c0a 2020 2020 2020 2020 736b     ),.        sk
+00013640: 6d61 7420 3d20 646f 776e 286c 2f32 2920  mat = down(l/2) 
+00013650: 2a0a 2020 2020 2020 2020 2020 2020 736b  *.            sk
+00013660: 6577 2873 787a 3d73 6869 6674 2e78 2f6c  ew(sxz=shift.x/l
+00013670: 2c20 7379 7a3d 7368 6966 742e 792f 6c29  , syz=shift.y/l)
+00013680: 202a 0a20 2020 2020 2020 2020 2020 2075   *.            u
+00013690: 7028 6c2f 3229 202a 0a20 2020 2020 2020  p(l/2) *.       
+000136a0: 2020 2020 207a 726f 7428 7265 616c 6967       zrot(realig
+000136b0: 6e3f 2031 3830 2f73 6964 6573 203a 2030  n? 180/sides : 0
+000136c0: 292c 0a20 2020 2020 2020 206f 766e 6620  ),.        ovnf 
+000136d0: 3d20 6170 706c 7928 736b 6d61 742c 2076  = apply(skmat, v
+000136e0: 6e66 290a 2020 2020 290a 2020 2020 7265  nf).    ).    re
+000136f0: 6f72 6965 6e74 2861 6e63 686f 722c 7370  orient(anchor,sp
+00013700: 696e 2c6f 7269 656e 742c 2072 313d 7231  in,orient, r1=r1
+00013710: 2c20 7232 3d72 322c 206c 3d6c 2c20 7368  , r2=r2, l=l, sh
+00013720: 6966 743d 7368 6966 742c 2070 3d6f 766e  ift=shift, p=ovn
+00013730: 6629 3b0a 0a0a 6d6f 6475 6c65 2063 796c  f);...module cyl
+00013740: 280a 2020 2020 682c 2072 2c20 6365 6e74  (.    h, r, cent
+00013750: 6572 2c0a 2020 2020 6c2c 2072 312c 2072  er,.    l, r1, r
+00013760: 322c 0a20 2020 2064 2c20 6431 2c20 6432  2,.    d, d1, d2
+00013770: 2c0a 2020 2020 6368 616d 6665 722c 2063  ,.    chamfer, c
+00013780: 6861 6d66 6572 312c 2063 6861 6d66 6572  hamfer1, chamfer
+00013790: 322c 0a20 2020 2063 6861 6d66 616e 672c  2,.    chamfang,
+000137a0: 2063 6861 6d66 616e 6731 2c20 6368 616d   chamfang1, cham
+000137b0: 6661 6e67 322c 0a20 2020 2072 6f75 6e64  fang2,.    round
+000137c0: 696e 672c 2072 6f75 6e64 696e 6731 2c20  ing, rounding1, 
+000137d0: 726f 756e 6469 6e67 322c 0a20 2020 2063  rounding2,.    c
+000137e0: 6972 6375 6d3d 6661 6c73 652c 2072 6561  ircum=false, rea
+000137f0: 6c69 676e 3d66 616c 7365 2c20 7368 6966  lign=false, shif
+00013800: 743d 5b30 2c30 5d2c 0a20 2020 2066 726f  t=[0,0],.    fro
+00013810: 6d5f 656e 642c 2066 726f 6d5f 656e 6431  m_end, from_end1
+00013820: 2c20 6672 6f6d 5f65 6e64 322c 0a20 2020  , from_end2,.   
+00013830: 2074 6578 7475 7265 2c20 7465 785f 7369   texture, tex_si
+00013840: 7a65 3d5b 352c 355d 2c20 7465 785f 636f  ze=[5,5], tex_co
+00013850: 756e 7473 2c0a 2020 2020 7465 785f 696e  unts,.    tex_in
+00013860: 7365 743d 6661 6c73 652c 2074 6578 5f72  set=false, tex_r
+00013870: 6f74 3d66 616c 7365 2c0a 2020 2020 7465  ot=false,.    te
+00013880: 785f 7363 616c 653d 312c 2074 6578 5f73  x_scale=1, tex_s
+00013890: 616d 706c 6573 2c20 6c65 6e67 7468 2c20  amples, length, 
+000138a0: 6865 6967 6874 2c20 0a20 2020 2074 6578  height, .    tex
+000138b0: 5f74 6170 6572 2c20 7465 785f 7374 796c  _taper, tex_styl
+000138c0: 653d 226d 696e 5f65 6467 6522 2c0a 2020  e="min_edge",.  
+000138d0: 2020 616e 6368 6f72 2c20 7370 696e 3d30    anchor, spin=0
+000138e0: 2c20 6f72 6965 6e74 3d55 500a 2920 7b0a  , orient=UP.) {.
+000138f0: 2020 2020 6c20 3d20 6f6e 655f 6465 6669      l = one_defi
+00013900: 6e65 6428 5b6c 2c20 682c 206c 656e 6774  ned([l, h, lengt
+00013910: 682c 2068 6569 6768 745d 2c22 6c2c 682c  h, height],"l,h,
+00013920: 6c65 6e67 7468 2c68 6569 6768 7422 2c64  length,height",d
+00013930: 666c 743d 3129 3b0a 2020 2020 5f72 3120  flt=1);.    _r1 
+00013940: 3d20 6765 745f 7261 6469 7573 2872 313d  = get_radius(r1=
+00013950: 7231 2c20 723d 722c 2064 313d 6431 2c20  r1, r=r, d1=d1, 
+00013960: 643d 642c 2064 666c 743d 3129 3b0a 2020  d=d, dflt=1);.  
+00013970: 2020 5f72 3220 3d20 6765 745f 7261 6469    _r2 = get_radi
+00013980: 7573 2872 313d 7232 2c20 723d 722c 2064  us(r1=r2, r=r, d
+00013990: 313d 6432 2c20 643d 642c 2064 666c 743d  1=d2, d=d, dflt=
+000139a0: 3129 3b0a 2020 2020 7369 6465 7320 3d20  1);.    sides = 
+000139b0: 7365 6773 286d 6178 285f 7231 2c5f 7232  segs(max(_r1,_r2
+000139c0: 2929 3b0a 2020 2020 7363 203d 2063 6972  ));.    sc = cir
+000139d0: 6375 6d3f 2031 2f63 6f73 2831 3830 2f73  cum? 1/cos(180/s
+000139e0: 6964 6573 2920 3a20 313b 0a20 2020 2072  ides) : 1;.    r
+000139f0: 3120 3d20 5f72 3120 2a20 7363 3b0a 2020  1 = _r1 * sc;.  
+00013a00: 2020 7232 203d 205f 7232 202a 2073 633b    r2 = _r2 * sc;
+00013a10: 0a20 2020 2070 6869 203d 2061 7461 6e32  .    phi = atan2
+00013a20: 286c 2c20 7232 2d72 3129 3b0a 2020 2020  (l, r2-r1);.    
+00013a30: 616e 6368 6f72 203d 2067 6574 5f61 6e63  anchor = get_anc
+00013a40: 686f 7228 616e 6368 6f72 2c63 656e 7465  hor(anchor,cente
+00013a50: 722c 424f 542c 4345 4e54 4552 293b 0a20  r,BOT,CENTER);. 
+00013a60: 2020 2073 6b6d 6174 203d 2064 6f77 6e28     skmat = down(
+00013a70: 6c2f 3229 202a 2073 6b65 7728 7378 7a3d  l/2) * skew(sxz=
+00013a80: 7368 6966 742e 782f 6c2c 2073 797a 3d73  shift.x/l, syz=s
+00013a90: 6869 6674 2e79 2f6c 2920 2a20 7570 286c  hift.y/l) * up(l
+00013aa0: 2f32 293b 0a20 2020 2061 7474 6163 6861  /2);.    attacha
+00013ab0: 626c 6528 616e 6368 6f72 2c73 7069 6e2c  ble(anchor,spin,
+00013ac0: 6f72 6965 6e74 2c20 7231 3d72 312c 2072  orient, r1=r1, r
+00013ad0: 323d 7232 2c20 6c3d 6c2c 2073 6869 6674  2=r2, l=l, shift
+00013ae0: 3d73 6869 6674 2920 7b0a 2020 2020 2020  =shift) {.      
+00013af0: 2020 6d75 6c74 6d61 7472 6978 2873 6b6d    multmatrix(skm
+00013b00: 6174 290a 2020 2020 2020 2020 7a72 6f74  at).        zrot
+00013b10: 2872 6561 6c69 676e 3f20 3138 302f 7369  (realign? 180/si
+00013b20: 6465 7320 3a20 3029 207b 0a20 2020 2020  des : 0) {.     
+00013b30: 2020 2020 2020 2069 6620 2821 616e 795f         if (!any_
+00013b40: 6465 6669 6e65 6428 5b63 6861 6d66 6572  defined([chamfer
+00013b50: 2c20 6368 616d 6665 7231 2c20 6368 616d  , chamfer1, cham
+00013b60: 6665 7232 2c20 726f 756e 6469 6e67 2c20  fer2, rounding, 
+00013b70: 726f 756e 6469 6e67 312c 2072 6f75 6e64  rounding1, round
+00013b80: 696e 6732 2c20 7465 7874 7572 655d 2929  ing2, texture]))
+00013b90: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+00013ba0: 2020 2063 796c 696e 6465 7228 683d 6c2c     cylinder(h=l,
+00013bb0: 2072 313d 7231 2c20 7232 3d72 322c 2063   r1=r1, r2=r2, c
+00013bc0: 656e 7465 723d 7472 7565 2c20 2466 6e3d  enter=true, $fn=
+00013bd0: 7369 6465 7329 3b0a 2020 2020 2020 2020  sides);.        
+00013be0: 2020 2020 7d20 656c 7365 207b 0a20 2020      } else {.   
+00013bf0: 2020 2020 2020 2020 2020 2020 2076 6e66               vnf
+00013c00: 203d 2063 796c 280a 2020 2020 2020 2020   = cyl(.        
+00013c10: 2020 2020 2020 2020 2020 2020 6c3d 6c2c              l=l,
+00013c20: 2072 313d 7231 2c20 7232 3d72 322c 2063   r1=r1, r2=r2, c
+00013c30: 656e 7465 723d 7472 7565 2c20 2466 6e3d  enter=true, $fn=
+00013c40: 7369 6465 732c 0a20 2020 2020 2020 2020  sides,.         
+00013c50: 2020 2020 2020 2020 2020 2063 6861 6d66             chamf
+00013c60: 6572 3d63 6861 6d66 6572 2c20 6368 616d  er=chamfer, cham
+00013c70: 6665 7231 3d63 6861 6d66 6572 312c 2063  fer1=chamfer1, c
+00013c80: 6861 6d66 6572 323d 6368 616d 6665 7232  hamfer2=chamfer2
+00013c90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013ca0: 2020 2020 2020 6368 616d 6661 6e67 3d63        chamfang=c
+00013cb0: 6861 6d66 616e 672c 2063 6861 6d66 616e  hamfang, chamfan
+00013cc0: 6731 3d63 6861 6d66 616e 6731 2c20 6368  g1=chamfang1, ch
+00013cd0: 616d 6661 6e67 323d 6368 616d 6661 6e67  amfang2=chamfang
+00013ce0: 322c 0a20 2020 2020 2020 2020 2020 2020  2,.             
+00013cf0: 2020 2020 2020 2072 6f75 6e64 696e 673d         rounding=
+00013d00: 726f 756e 6469 6e67 2c20 726f 756e 6469  rounding, roundi
+00013d10: 6e67 313d 726f 756e 6469 6e67 312c 2072  ng1=rounding1, r
+00013d20: 6f75 6e64 696e 6732 3d72 6f75 6e64 696e  ounding2=roundin
+00013d30: 6732 2c0a 2020 2020 2020 2020 2020 2020  g2,.            
+00013d40: 2020 2020 2020 2020 6672 6f6d 5f65 6e64          from_end
+00013d50: 3d66 726f 6d5f 656e 642c 2066 726f 6d5f  =from_end, from_
+00013d60: 656e 6431 3d66 726f 6d5f 656e 6431 2c20  end1=from_end1, 
+00013d70: 6672 6f6d 5f65 6e64 323d 6672 6f6d 5f65  from_end2=from_e
+00013d80: 6e64 322c 0a20 2020 2020 2020 2020 2020  nd2,.           
+00013d90: 2020 2020 2020 2020 2074 6578 7475 7265           texture
+00013da0: 3d74 6578 7475 7265 2c20 7465 785f 7369  =texture, tex_si
+00013db0: 7a65 3d74 6578 5f73 697a 652c 0a20 2020  ze=tex_size,.   
+00013dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013dd0: 2074 6578 5f63 6f75 6e74 733d 7465 785f   tex_counts=tex_
+00013de0: 636f 756e 7473 2c20 7465 785f 7363 616c  counts, tex_scal
+00013df0: 653d 7465 785f 7363 616c 652c 0a20 2020  e=tex_scale,.   
+00013e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013e10: 2074 6578 5f69 6e73 6574 3d74 6578 5f69   tex_inset=tex_i
+00013e20: 6e73 6574 2c20 7465 785f 726f 743d 7465  nset, tex_rot=te
+00013e30: 785f 726f 742c 0a20 2020 2020 2020 2020  x_rot,.         
+00013e40: 2020 2020 2020 2020 2020 2074 6578 5f73             tex_s
+00013e50: 7479 6c65 3d74 6578 5f73 7479 6c65 2c20  tyle=tex_style, 
+00013e60: 7465 785f 7461 7065 723d 7465 785f 7461  tex_taper=tex_ta
+00013e70: 7065 722c 0a20 2020 2020 2020 2020 2020  per,.           
+00013e80: 2020 2020 2020 2020 2074 6578 5f73 616d           tex_sam
+00013e90: 706c 6573 3d74 6578 5f73 616d 706c 6573  ples=tex_samples
+00013ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013eb0: 2029 3b0a 2020 2020 2020 2020 2020 2020   );.            
+00013ec0: 2020 2020 766e 665f 706f 6c79 6865 6472      vnf_polyhedr
+00013ed0: 6f6e 2876 6e66 2c20 636f 6e76 6578 6974  on(vnf, convexit
+00013ee0: 793d 7465 7874 7572 6521 3d75 6e64 6566  y=texture!=undef
+00013ef0: 3f20 3220 3a20 3130 293b 0a20 2020 2020  ? 2 : 10);.     
+00013f00: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00013f10: 207d 0a20 2020 2020 2020 2063 6869 6c64   }.        child
+00013f20: 7265 6e28 293b 0a20 2020 207d 0a7d 0a0a  ren();.    }.}..
+00013f30: 0a0a 2f2f 204d 6f64 756c 653a 2078 6379  ..// Module: xcy
+00013f40: 6c28 290a 2f2f 2053 796e 6f70 7369 733a  l().// Synopsis:
+00013f50: 2063 7265 6174 6573 2061 2063 796c 696e   creates a cylin
+00013f60: 6465 7220 6f72 6965 6e74 6564 2061 6c6f  der oriented alo
+00013f70: 6e67 2074 6865 2058 2061 7869 732c 206f  ng the X axis, o
+00013f80: 7220 7265 7475 726e 7320 6120 766e 662e  r returns a vnf.
+00013f90: 0a2f 2f20 546f 7069 6373 3a20 4379 6c69  .// Topics: Cyli
+00013fa0: 6e64 6572 732c 2054 6578 7475 7265 732c  nders, Textures,
+00013fb0: 2052 6f75 6e64 696e 672c 2043 6861 6d66   Rounding, Chamf
+00013fc0: 6572 730a 2f2f 2053 6565 2041 6c73 6f3a  ers.// See Also:
+00013fd0: 2074 6578 7475 7265 2829 2c20 726f 7461   texture(), rota
+00013fe0: 7465 5f73 7765 6570 2829 2c20 6379 6c28  te_sweep(), cyl(
+00013ff0: 290a 2f2f 2044 6573 6372 6970 7469 6f6e  ).// Description
+00014000: 3a0a 2f2f 2020 2043 7265 6174 6573 2061  :.//   Creates a
+00014010: 6e20 6174 7461 6368 6162 6c65 2063 796c  n attachable cyl
+00014020: 696e 6465 7220 7769 7468 2072 6f75 6e64  inder with round
+00014030: 6f76 6572 7320 616e 6420 6368 616d 6665  overs and chamfe
+00014040: 7269 6e67 206f 7269 656e 7465 6420 616c  ring oriented al
+00014050: 6f6e 6720 7468 6520 5820 6178 6973 2e0a  ong the X axis..
+00014060: 2f2f 0a2f 2f20 5573 6167 653a 2054 7970  //.// Usage: Typ
+00014070: 6963 616c 0a2f 2f20 2020 7863 796c 286c  ical.//   xcyl(l
+00014080: 7c68 7c6c 656e 6774 687c 6865 6967 6874  |h|length|height
+00014090: 2c20 727c 643d 2c20 5b61 6e63 686f 723d  , r|d=, [anchor=
+000140a0: 5d2c 202e 2e2e 2920 5b41 5454 4143 484d  ], ...) [ATTACHM
+000140b0: 454e 5453 5d3b 0a2f 2f20 2020 7863 796c  ENTS];.//   xcyl
+000140c0: 286c 7c68 7c6c 656e 6774 687c 6865 6967  (l|h|length|heig
+000140d0: 6874 2c20 7231 3d7c 6431 3d2c 2072 323d  ht, r1=|d1=, r2=
+000140e0: 7c64 323d 2c20 5b61 6e63 686f 723d 5d2c  |d2=, [anchor=],
+000140f0: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
+00014100: 5453 5d3b 0a2f 2f0a 2f2f 2041 7267 756d  TS];.//.// Argum
+00014110: 656e 7473 3a0a 2f2f 2020 206c 202f 2068  ents:.//   l / h
+00014120: 202f 206c 656e 6774 6820 2f20 6865 6967   / length / heig
+00014130: 6874 203d 204c 656e 6774 6820 6f66 2063  ht = Length of c
+00014140: 796c 696e 6465 7220 616c 6f6e 6720 6f72  ylinder along or
+00014150: 6965 6e74 6564 2061 7869 732e 2044 6566  iented axis. Def
+00014160: 6175 6c74 3a20 310a 2f2f 2020 2072 203d  ault: 1.//   r =
+00014170: 2052 6164 6975 7320 6f66 2063 796c 696e   Radius of cylin
+00014180: 6465 722e 2020 4465 6661 756c 743a 2031  der.  Default: 1
+00014190: 0a2f 2f20 2020 2d2d 2d0a 2f2f 2020 2072  .//   ---.//   r
+000141a0: 3120 3d20 4f70 7469 6f6e 616c 2072 6164  1 = Optional rad
+000141b0: 6975 7320 6f66 206c 6566 7420 2858 2d29  ius of left (X-)
+000141c0: 2065 6e64 206f 6620 6379 6c69 6e64 6572   end of cylinder
+000141d0: 2e0a 2f2f 2020 2072 3220 3d20 4f70 7469  ..//   r2 = Opti
+000141e0: 6f6e 616c 2072 6164 6975 7320 6f66 2072  onal radius of r
+000141f0: 6967 6874 2028 582b 2920 656e 6420 6f66  ight (X+) end of
+00014200: 2063 796c 696e 6465 722e 0a2f 2f20 2020   cylinder..//   
+00014210: 6420 3d20 4f70 7469 6f6e 616c 2064 6961  d = Optional dia
+00014220: 6d65 7465 7220 6f66 2063 796c 696e 6465  meter of cylinde
+00014230: 722e 2028 7573 6520 696e 7374 6561 6420  r. (use instead 
+00014240: 6f66 2060 7260 290a 2f2f 2020 2064 3120  of `r`).//   d1 
+00014250: 3d20 4f70 7469 6f6e 616c 2064 6961 6d65  = Optional diame
+00014260: 7465 7220 6f66 206c 6566 7420 2858 2d29  ter of left (X-)
+00014270: 2065 6e64 206f 6620 6379 6c69 6e64 6572   end of cylinder
+00014280: 2e0a 2f2f 2020 2064 3220 3d20 4f70 7469  ..//   d2 = Opti
+00014290: 6f6e 616c 2064 6961 6d65 7465 7220 6f66  onal diameter of
+000142a0: 2072 6967 6874 2028 582b 2920 656e 6420   right (X+) end 
+000142b0: 6f66 2063 796c 696e 6465 722e 0a2f 2f20  of cylinder..// 
+000142c0: 2020 6369 7263 756d 203d 2049 6620 7472    circum = If tr
+000142d0: 7565 2c20 6379 6c69 6e64 6572 2073 686f  ue, cylinder sho
+000142e0: 756c 6420 6369 7263 756d 7363 7269 6265  uld circumscribe
+000142f0: 2074 6865 2063 6972 636c 6520 6f66 2074   the circle of t
+00014300: 6865 2067 6976 656e 2073 697a 652e 2020  he given size.  
+00014310: 4f74 6865 7277 6973 6520 696e 7363 7269  Otherwise inscri
+00014320: 6265 732e 2020 4465 6661 756c 743a 2060  bes.  Default: `
+00014330: 6661 6c73 6560 0a2f 2f20 2020 6368 616d  false`.//   cham
+00014340: 6665 7220 3d20 5468 6520 7369 7a65 206f  fer = The size o
+00014350: 6620 7468 6520 6368 616d 6665 7273 206f  f the chamfers o
+00014360: 6e20 7468 6520 656e 6473 206f 6620 7468  n the ends of th
+00014370: 6520 6379 6c69 6e64 6572 2e20 2044 6566  e cylinder.  Def
+00014380: 6175 6c74 3a20 6e6f 6e65 2e0a 2f2f 2020  ault: none..//  
+00014390: 2063 6861 6d66 6572 3120 3d20 5468 6520   chamfer1 = The 
+000143a0: 7369 7a65 206f 6620 7468 6520 6368 616d  size of the cham
+000143b0: 6665 7220 6f6e 2074 6865 206c 6566 7420  fer on the left 
+000143c0: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
+000143d0: 6465 722e 2020 4465 6661 756c 743a 206e  der.  Default: n
+000143e0: 6f6e 652e 0a2f 2f20 2020 6368 616d 6665  one..//   chamfe
+000143f0: 7232 203d 2054 6865 2073 697a 6520 6f66  r2 = The size of
+00014400: 2074 6865 2063 6861 6d66 6572 206f 6e20   the chamfer on 
+00014410: 7468 6520 7269 6768 7420 656e 6420 6f66  the right end of
+00014420: 2074 6865 2063 796c 696e 6465 722e 2020   the cylinder.  
+00014430: 4465 6661 756c 743a 206e 6f6e 652e 0a2f  Default: none../
+00014440: 2f20 2020 6368 616d 6661 6e67 203d 2054  /   chamfang = T
+00014450: 6865 2061 6e67 6c65 2069 6e20 6465 6772  he angle in degr
+00014460: 6565 7320 6f66 2074 6865 2063 6861 6d66  ees of the chamf
+00014470: 6572 7320 6f6e 2074 6865 2065 6e64 7320  ers on the ends 
+00014480: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00014490: 0a2f 2f20 2020 6368 616d 6661 6e67 3120  .//   chamfang1 
+000144a0: 3d20 5468 6520 616e 676c 6520 696e 2064  = The angle in d
+000144b0: 6567 7265 6573 206f 6620 7468 6520 6368  egrees of the ch
+000144c0: 616d 6665 7220 6f6e 2074 6865 206c 6566  amfer on the lef
+000144d0: 7420 656e 6420 6f66 2074 6865 2063 796c  t end of the cyl
+000144e0: 696e 6465 722e 0a2f 2f20 2020 6368 616d  inder..//   cham
+000144f0: 6661 6e67 3220 3d20 5468 6520 616e 676c  fang2 = The angl
+00014500: 6520 696e 2064 6567 7265 6573 206f 6620  e in degrees of 
+00014510: 7468 6520 6368 616d 6665 7220 6f6e 2074  the chamfer on t
+00014520: 6865 2072 6967 6874 2065 6e64 206f 6620  he right end of 
+00014530: 7468 6520 6379 6c69 6e64 6572 2e0a 2f2f  the cylinder..//
+00014540: 2020 2066 726f 6d5f 656e 6420 3d20 4966     from_end = If
+00014550: 2074 7275 652c 2063 6861 6d66 6572 2069   true, chamfer i
+00014560: 7320 6d65 6173 7572 6564 2066 726f 6d20  s measured from 
+00014570: 7468 6520 656e 6420 6f66 2074 6865 2063  the end of the c
+00014580: 796c 696e 6465 722c 2069 6e73 7465 6164  ylinder, instead
+00014590: 206f 6620 696e 7365 7420 6672 6f6d 2074   of inset from t
+000145a0: 6865 2065 6467 652e 2020 4465 6661 756c  he edge.  Defaul
+000145b0: 743a 2060 6661 6c73 6560 2e0a 2f2f 2020  t: `false`..//  
+000145c0: 2072 6f75 6e64 696e 6720 3d20 5468 6520   rounding = The 
+000145d0: 7261 6469 7573 206f 6620 7468 6520 726f  radius of the ro
+000145e0: 756e 6469 6e67 206f 6e20 7468 6520 656e  unding on the en
+000145f0: 6473 206f 6620 7468 6520 6379 6c69 6e64  ds of the cylind
+00014600: 6572 2e20 2044 6566 6175 6c74 3a20 6e6f  er.  Default: no
+00014610: 6e65 2e0a 2f2f 2020 2072 6f75 6e64 696e  ne..//   roundin
+00014620: 6731 203d 2054 6865 2072 6164 6975 7320  g1 = The radius 
+00014630: 6f66 2074 6865 2072 6f75 6e64 696e 6720  of the rounding 
+00014640: 6f6e 2074 6865 206c 6566 7420 656e 6420  on the left end 
+00014650: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00014660: 0a2f 2f20 2020 726f 756e 6469 6e67 3220  .//   rounding2 
+00014670: 3d20 5468 6520 7261 6469 7573 206f 6620  = The radius of 
+00014680: 7468 6520 726f 756e 6469 6e67 206f 6e20  the rounding on 
+00014690: 7468 6520 7269 6768 7420 656e 6420 6f66  the right end of
+000146a0: 2074 6865 2063 796c 696e 6465 722e 0a2f   the cylinder../
+000146b0: 2f20 2020 7265 616c 6967 6e20 3d20 4966  /   realign = If
+000146c0: 2074 7275 652c 2072 6f74 6174 6520 7468   true, rotate th
+000146d0: 6520 6379 6c69 6e64 6572 2062 7920 6861  e cylinder by ha
+000146e0: 6c66 2074 6865 2061 6e67 6c65 206f 6620  lf the angle of 
+000146f0: 6f6e 6520 6661 6365 2e0a 2f2f 2020 2061  one face..//   a
+00014700: 6e63 686f 7220 3d20 5472 616e 736c 6174  nchor = Translat
+00014710: 6520 736f 2061 6e63 686f 7220 706f 696e  e so anchor poin
+00014720: 7420 6973 2061 7420 6f72 6967 696e 2028  t is at origin (
+00014730: 302c 302c 3029 2e20 2053 6565 205b 616e  0,0,0).  See [an
+00014740: 6368 6f72 5d28 6174 7461 6368 6d65 6e74  chor](attachment
+00014750: 732e 7363 6164 2373 7562 7365 6374 696f  s.scad#subsectio
+00014760: 6e2d 616e 6368 6f72 292e 2020 4465 6661  n-anchor).  Defa
+00014770: 756c 743a 2060 4345 4e54 4552 600a 2f2f  ult: `CENTER`.//
+00014780: 2020 2073 7069 6e20 3d20 526f 7461 7465     spin = Rotate
+00014790: 2074 6869 7320 6d61 6e79 2064 6567 7265   this many degre
+000147a0: 6573 2061 726f 756e 6420 7468 6520 5a20  es around the Z 
+000147b0: 6178 6973 2061 6674 6572 2061 6e63 686f  axis after ancho
+000147c0: 722e 2020 5365 6520 5b73 7069 6e5d 2861  r.  See [spin](a
+000147d0: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
+000147e0: 7375 6273 6563 7469 6f6e 2d73 7069 6e29  subsection-spin)
+000147f0: 2e20 2044 6566 6175 6c74 3a20 6030 600a  .  Default: `0`.
+00014800: 2f2f 2020 206f 7269 656e 7420 3d20 5665  //   orient = Ve
+00014810: 6374 6f72 2074 6f20 726f 7461 7465 2074  ctor to rotate t
+00014820: 6f70 2074 6f77 6172 6473 2c20 6166 7465  op towards, afte
+00014830: 7220 7370 696e 2e20 2053 6565 205b 6f72  r spin.  See [or
+00014840: 6965 6e74 5d28 6174 7461 6368 6d65 6e74  ient](attachment
+00014850: 732e 7363 6164 2373 7562 7365 6374 696f  s.scad#subsectio
+00014860: 6e2d 6f72 6965 6e74 292e 2020 4465 6661  n-orient).  Defa
+00014870: 756c 743a 2060 5550 600a 2f2f 0a2f 2f20  ult: `UP`.//.// 
+00014880: 4578 616d 706c 653a 2042 7920 5261 6469  Example: By Radi
+00014890: 7573 0a2f 2f20 2020 7964 6973 7472 6962  us.//   ydistrib
+000148a0: 7574 6528 3530 2920 7b0a 2f2f 2020 2020  ute(50) {.//    
+000148b0: 2020 2078 6379 6c28 6c3d 3335 2c20 723d     xcyl(l=35, r=
+000148c0: 3130 293b 0a2f 2f20 2020 2020 2020 7863  10);.//       xc
+000148d0: 796c 286c 3d33 352c 2072 313d 3135 2c20  yl(l=35, r1=15, 
+000148e0: 7232 3d35 293b 0a2f 2f20 2020 7d0a 2f2f  r2=5);.//   }.//
+000148f0: 0a2f 2f20 4578 616d 706c 653a 2042 7920  .// Example: By 
+00014900: 4469 616d 6574 6572 0a2f 2f20 2020 7964  Diameter.//   yd
+00014910: 6973 7472 6962 7574 6528 3530 2920 7b0a  istribute(50) {.
+00014920: 2f2f 2020 2020 2020 2078 6379 6c28 6c3d  //       xcyl(l=
+00014930: 3335 2c20 643d 3230 293b 0a2f 2f20 2020  35, d=20);.//   
+00014940: 2020 2020 7863 796c 286c 3d33 352c 2064      xcyl(l=35, d
+00014950: 313d 3330 2c20 6432 3d31 3029 3b0a 2f2f  1=30, d2=10);.//
+00014960: 2020 207d 0a0a 6675 6e63 7469 6f6e 2078     }..function x
+00014970: 6379 6c28 0a20 2020 2068 2c20 722c 2064  cyl(.    h, r, d
+00014980: 2c20 7231 2c20 7232 2c20 6431 2c20 6432  , r1, r2, d1, d2
+00014990: 2c20 6c2c 200a 2020 2020 6368 616d 6665  , l, .    chamfe
+000149a0: 722c 2063 6861 6d66 6572 312c 2063 6861  r, chamfer1, cha
+000149b0: 6d66 6572 322c 0a20 2020 2063 6861 6d66  mfer2,.    chamf
+000149c0: 616e 672c 2063 6861 6d66 616e 6731 2c20  ang, chamfang1, 
+000149d0: 6368 616d 6661 6e67 322c 0a20 2020 2072  chamfang2,.    r
+000149e0: 6f75 6e64 696e 672c 2072 6f75 6e64 696e  ounding, roundin
+000149f0: 6731 2c20 726f 756e 6469 6e67 322c 0a20  g1, rounding2,. 
+00014a00: 2020 2063 6972 6375 6d3d 6661 6c73 652c     circum=false,
+00014a10: 2072 6561 6c69 676e 3d66 616c 7365 2c20   realign=false, 
+00014a20: 6672 6f6d 5f65 6e64 3d66 616c 7365 2c20  from_end=false, 
+00014a30: 6c65 6e67 7468 2c20 6865 6967 6874 2c0a  length, height,.
+00014a40: 2020 2020 616e 6368 6f72 3d43 454e 5445      anchor=CENTE
+00014a50: 522c 2073 7069 6e3d 302c 206f 7269 656e  R, spin=0, orien
+00014a60: 743d 5550 0a29 203d 206e 6f5f 6675 6e63  t=UP.) = no_func
+00014a70: 7469 6f6e 2822 7863 796c 2229 3b0a 0a6d  tion("xcyl");..m
+00014a80: 6f64 756c 6520 7863 796c 280a 2020 2020  odule xcyl(.    
+00014a90: 682c 2072 2c20 642c 2072 312c 2072 322c  h, r, d, r1, r2,
+00014aa0: 2064 312c 2064 322c 206c 2c20 0a20 2020   d1, d2, l, .   
+00014ab0: 2063 6861 6d66 6572 2c20 6368 616d 6665   chamfer, chamfe
+00014ac0: 7231 2c20 6368 616d 6665 7232 2c0a 2020  r1, chamfer2,.  
+00014ad0: 2020 6368 616d 6661 6e67 2c20 6368 616d    chamfang, cham
+00014ae0: 6661 6e67 312c 2063 6861 6d66 616e 6732  fang1, chamfang2
+00014af0: 2c0a 2020 2020 726f 756e 6469 6e67 2c20  ,.    rounding, 
+00014b00: 726f 756e 6469 6e67 312c 2072 6f75 6e64  rounding1, round
+00014b10: 696e 6732 2c0a 2020 2020 6369 7263 756d  ing2,.    circum
+00014b20: 3d66 616c 7365 2c20 7265 616c 6967 6e3d  =false, realign=
+00014b30: 6661 6c73 652c 2066 726f 6d5f 656e 643d  false, from_end=
+00014b40: 6661 6c73 652c 206c 656e 6774 682c 2068  false, length, h
+00014b50: 6569 6768 742c 0a20 2020 2061 6e63 686f  eight,.    ancho
+00014b60: 723d 4345 4e54 4552 2c20 7370 696e 3d30  r=CENTER, spin=0
+00014b70: 2c20 6f72 6965 6e74 3d55 500a 2920 7b0a  , orient=UP.) {.
+00014b80: 2020 2020 7231 203d 2067 6574 5f72 6164      r1 = get_rad
+00014b90: 6975 7328 7231 3d72 312c 2072 3d72 2c20  ius(r1=r1, r=r, 
+00014ba0: 6431 3d64 312c 2064 3d64 2c20 6466 6c74  d1=d1, d=d, dflt
+00014bb0: 3d31 293b 0a20 2020 2072 3220 3d20 6765  =1);.    r2 = ge
+00014bc0: 745f 7261 6469 7573 2872 313d 7232 2c20  t_radius(r1=r2, 
+00014bd0: 723d 722c 2064 313d 6432 2c20 643d 642c  r=r, d1=d2, d=d,
+00014be0: 2064 666c 743d 3129 3b0a 2020 2020 6c20   dflt=1);.    l 
+00014bf0: 3d20 6f6e 655f 6465 6669 6e65 6428 5b6c  = one_defined([l
+00014c00: 2c68 2c6c 656e 6774 682c 6865 6967 6874  ,h,length,height
+00014c10: 5d2c 226c 2c68 2c6c 656e 6774 682c 6865  ],"l,h,length,he
+00014c20: 6967 6874 222c 3129 3b0a 2020 2020 6174  ight",1);.    at
+00014c30: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
+00014c40: 7370 696e 2c6f 7269 656e 742c 2072 313d  spin,orient, r1=
+00014c50: 7231 2c20 7232 3d72 322c 206c 3d6c 2c20  r1, r2=r2, l=l, 
+00014c60: 6178 6973 3d52 4947 4854 2920 7b0a 2020  axis=RIGHT) {.  
+00014c70: 2020 2020 2020 6379 6c28 0a20 2020 2020        cyl(.     
+00014c80: 2020 2020 2020 206c 3d6c 2c20 7231 3d72         l=l, r1=r
+00014c90: 312c 2072 323d 7232 2c0a 2020 2020 2020  1, r2=r2,.      
+00014ca0: 2020 2020 2020 6368 616d 6665 723d 6368        chamfer=ch
+00014cb0: 616d 6665 722c 2063 6861 6d66 6572 313d  amfer, chamfer1=
+00014cc0: 6368 616d 6665 7231 2c20 6368 616d 6665  chamfer1, chamfe
+00014cd0: 7232 3d63 6861 6d66 6572 322c 0a20 2020  r2=chamfer2,.   
+00014ce0: 2020 2020 2020 2020 2063 6861 6d66 616e           chamfan
+00014cf0: 673d 6368 616d 6661 6e67 2c20 6368 616d  g=chamfang, cham
+00014d00: 6661 6e67 313d 6368 616d 6661 6e67 312c  fang1=chamfang1,
+00014d10: 2063 6861 6d66 616e 6732 3d63 6861 6d66   chamfang2=chamf
+00014d20: 616e 6732 2c0a 2020 2020 2020 2020 2020  ang2,.          
+00014d30: 2020 726f 756e 6469 6e67 3d72 6f75 6e64    rounding=round
+00014d40: 696e 672c 2072 6f75 6e64 696e 6731 3d72  ing, rounding1=r
+00014d50: 6f75 6e64 696e 6731 2c20 726f 756e 6469  ounding1, roundi
+00014d60: 6e67 323d 726f 756e 6469 6e67 322c 0a20  ng2=rounding2,. 
+00014d70: 2020 2020 2020 2020 2020 2063 6972 6375             circu
+00014d80: 6d3d 6369 7263 756d 2c20 7265 616c 6967  m=circum, realig
+00014d90: 6e3d 7265 616c 6967 6e2c 2066 726f 6d5f  n=realign, from_
+00014da0: 656e 643d 6672 6f6d 5f65 6e64 2c0a 2020  end=from_end,.  
+00014db0: 2020 2020 2020 2020 2020 616e 6368 6f72            anchor
+00014dc0: 3d43 454e 5445 522c 206f 7269 656e 743d  =CENTER, orient=
+00014dd0: 5249 4748 540a 2020 2020 2020 2020 293b  RIGHT.        );
+00014de0: 0a20 2020 2020 2020 2063 6869 6c64 7265  .        childre
+00014df0: 6e28 293b 0a20 2020 207d 0a7d 0a0a 0a2f  n();.    }.}.../
+00014e00: 2f20 4d6f 6475 6c65 3a20 7963 796c 2829  / Module: ycyl()
+00014e10: 0a2f 2f20 5379 6e6f 7073 6973 3a20 6372  .// Synopsis: cr
+00014e20: 6561 7465 7320 6120 6379 6c69 6e64 6572  eates a cylinder
+00014e30: 206f 7269 656e 7465 6420 616c 6f6e 6720   oriented along 
+00014e40: 7468 6520 7920 6178 6973 2c20 6f72 2072  the y axis, or r
+00014e50: 6574 7572 6e73 2061 2076 6e66 2e0a 2f2f  eturns a vnf..//
+00014e60: 2054 6f70 6963 733a 2043 796c 696e 6465   Topics: Cylinde
+00014e70: 7273 2c20 5465 7874 7572 6573 2c20 526f  rs, Textures, Ro
+00014e80: 756e 6469 6e67 2c20 4368 616d 6665 7273  unding, Chamfers
+00014e90: 0a2f 2f20 5365 6520 416c 736f 3a20 7465  .// See Also: te
+00014ea0: 7874 7572 6528 292c 2072 6f74 6174 655f  xture(), rotate_
+00014eb0: 7377 6565 7028 292c 2063 796c 2829 0a2f  sweep(), cyl()./
+00014ec0: 2f20 4465 7363 7269 7074 696f 6e3a 0a2f  / Description:./
+00014ed0: 2f20 2020 4372 6561 7465 7320 616e 2061  /   Creates an a
+00014ee0: 7474 6163 6861 626c 6520 6379 6c69 6e64  ttachable cylind
+00014ef0: 6572 2077 6974 6820 726f 756e 646f 7665  er with roundove
+00014f00: 7273 2061 6e64 2063 6861 6d66 6572 696e  rs and chamferin
+00014f10: 6720 6f72 6965 6e74 6564 2061 6c6f 6e67  g oriented along
+00014f20: 2074 6865 2079 2061 7869 732e 0a2f 2f0a   the y axis..//.
+00014f30: 2f2f 2055 7361 6765 3a20 5479 7069 6361  // Usage: Typica
+00014f40: 6c0a 2f2f 2020 2079 6379 6c28 6c7c 687c  l.//   ycyl(l|h|
+00014f50: 6c65 6e67 7468 7c68 6569 6768 742c 2072  length|height, r
+00014f60: 7c64 3d2c 205b 616e 6368 6f72 3d5d 2c20  |d=, [anchor=], 
+00014f70: 2e2e 2e29 205b 4154 5441 4348 4d45 4e54  ...) [ATTACHMENT
+00014f80: 535d 3b0a 2f2f 2020 2079 6379 6c28 6c7c  S];.//   ycyl(l|
+00014f90: 687c 6c65 6e67 7468 7c68 6569 6768 742c  h|length|height,
+00014fa0: 2072 313d 7c64 313d 2c20 7232 3d7c 6432   r1=|d1=, r2=|d2
+00014fb0: 3d2c 205b 616e 6368 6f72 3d5d 2c20 2e2e  =, [anchor=], ..
+00014fc0: 2e29 205b 4154 5441 4348 4d45 4e54 535d  .) [ATTACHMENTS]
+00014fd0: 3b0a 2f2f 0a2f 2f20 4172 6775 6d65 6e74  ;.//.// Argument
+00014fe0: 733a 0a2f 2f20 2020 6c20 2f20 6820 2f20  s:.//   l / h / 
+00014ff0: 6c65 6e67 7468 202f 2068 6569 6768 7420  length / height 
+00015000: 3d20 4c65 6e67 7468 206f 6620 6379 6c69  = Length of cyli
+00015010: 6e64 6572 2061 6c6f 6e67 206f 7269 656e  nder along orien
+00015020: 7465 6420 6178 6973 2e20 2844 6566 6175  ted axis. (Defau
+00015030: 6c74 3a20 6031 2e30 6029 0a2f 2f20 2020  lt: `1.0`).//   
+00015040: 7220 3d20 5261 6469 7573 206f 6620 6379  r = Radius of cy
+00015050: 6c69 6e64 6572 2e0a 2f2f 2020 202d 2d2d  linder..//   ---
+00015060: 0a2f 2f20 2020 7231 203d 2052 6164 6975  .//   r1 = Radiu
+00015070: 7320 6f66 2066 726f 6e74 2028 592d 2920  s of front (Y-) 
+00015080: 656e 6420 6f66 2063 6f6e 652e 0a2f 2f20  end of cone..// 
+00015090: 2020 7232 203d 2052 6164 6975 7320 6f66    r2 = Radius of
+000150a0: 2062 6163 6b20 2859 2b29 2065 6e64 206f   back (Y+) end o
+000150b0: 6620 6f6e 652e 0a2f 2f20 2020 6420 3d20  f one..//   d = 
+000150c0: 4469 616d 6574 6572 206f 6620 6379 6c69  Diameter of cyli
+000150d0: 6e64 6572 2e0a 2f2f 2020 2064 3120 3d20  nder..//   d1 = 
+000150e0: 4469 616d 6574 6572 206f 6620 6672 6f6e  Diameter of fron
+000150f0: 7420 2859 2d29 2065 6e64 206f 6620 6f6e  t (Y-) end of on
+00015100: 652e 0a2f 2f20 2020 6432 203d 2044 6961  e..//   d2 = Dia
+00015110: 6d65 7465 7220 6f66 2062 6163 6b20 2859  meter of back (Y
+00015120: 2b29 2065 6e64 206f 6620 6f6e 652e 0a2f  +) end of one../
+00015130: 2f20 2020 6369 7263 756d 203d 2049 6620  /   circum = If 
+00015140: 7472 7565 2c20 6379 6c69 6e64 6572 2073  true, cylinder s
+00015150: 686f 756c 6420 6369 7263 756d 7363 7269  hould circumscri
+00015160: 6265 2074 6865 2063 6972 636c 6520 6f66  be the circle of
+00015170: 2074 6865 2067 6976 656e 2073 697a 652e   the given size.
+00015180: 2020 4f74 6865 7277 6973 6520 696e 7363    Otherwise insc
+00015190: 7269 6265 732e 2020 4465 6661 756c 743a  ribes.  Default:
+000151a0: 2060 6661 6c73 6560 0a2f 2f20 2020 6368   `false`.//   ch
+000151b0: 616d 6665 7220 3d20 5468 6520 7369 7a65  amfer = The size
+000151c0: 206f 6620 7468 6520 6368 616d 6665 7273   of the chamfers
+000151d0: 206f 6e20 7468 6520 656e 6473 206f 6620   on the ends of 
+000151e0: 7468 6520 6379 6c69 6e64 6572 2e20 2044  the cylinder.  D
+000151f0: 6566 6175 6c74 3a20 6e6f 6e65 2e0a 2f2f  efault: none..//
+00015200: 2020 2063 6861 6d66 6572 3120 3d20 5468     chamfer1 = Th
+00015210: 6520 7369 7a65 206f 6620 7468 6520 6368  e size of the ch
+00015220: 616d 6665 7220 6f6e 2074 6865 2066 726f  amfer on the fro
+00015230: 6e74 2065 6e64 206f 6620 7468 6520 6379  nt end of the cy
+00015240: 6c69 6e64 6572 2e20 2044 6566 6175 6c74  linder.  Default
+00015250: 3a20 6e6f 6e65 2e0a 2f2f 2020 2063 6861  : none..//   cha
+00015260: 6d66 6572 3220 3d20 5468 6520 7369 7a65  mfer2 = The size
+00015270: 206f 6620 7468 6520 6368 616d 6665 7220   of the chamfer 
+00015280: 6f6e 2074 6865 2062 6163 6b20 656e 6420  on the back end 
+00015290: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+000152a0: 2020 4465 6661 756c 743a 206e 6f6e 652e    Default: none.
+000152b0: 0a2f 2f20 2020 6368 616d 6661 6e67 203d  .//   chamfang =
+000152c0: 2054 6865 2061 6e67 6c65 2069 6e20 6465   The angle in de
+000152d0: 6772 6565 7320 6f66 2074 6865 2063 6861  grees of the cha
+000152e0: 6d66 6572 7320 6f6e 2074 6865 2065 6e64  mfers on the end
+000152f0: 7320 6f66 2074 6865 2063 796c 696e 6465  s of the cylinde
+00015300: 722e 0a2f 2f20 2020 6368 616d 6661 6e67  r..//   chamfang
+00015310: 3120 3d20 5468 6520 616e 676c 6520 696e  1 = The angle in
+00015320: 2064 6567 7265 6573 206f 6620 7468 6520   degrees of the 
+00015330: 6368 616d 6665 7220 6f6e 2074 6865 2066  chamfer on the f
+00015340: 726f 6e74 2065 6e64 206f 6620 7468 6520  ront end of the 
+00015350: 6379 6c69 6e64 6572 2e0a 2f2f 2020 2063  cylinder..//   c
+00015360: 6861 6d66 616e 6732 203d 2054 6865 2061  hamfang2 = The a
+00015370: 6e67 6c65 2069 6e20 6465 6772 6565 7320  ngle in degrees 
+00015380: 6f66 2074 6865 2063 6861 6d66 6572 206f  of the chamfer o
+00015390: 6e20 7468 6520 6261 636b 2065 6e64 206f  n the back end o
+000153a0: 6620 7468 6520 6379 6c69 6e64 6572 2e0a  f the cylinder..
+000153b0: 2f2f 2020 2066 726f 6d5f 656e 6420 3d20  //   from_end = 
+000153c0: 4966 2074 7275 652c 2063 6861 6d66 6572  If true, chamfer
+000153d0: 2069 7320 6d65 6173 7572 6564 2066 726f   is measured fro
+000153e0: 6d20 7468 6520 656e 6420 6f66 2074 6865  m the end of the
+000153f0: 2063 796c 696e 6465 722c 2069 6e73 7465   cylinder, inste
+00015400: 6164 206f 6620 696e 7365 7420 6672 6f6d  ad of inset from
+00015410: 2074 6865 2065 6467 652e 2020 4465 6661   the edge.  Defa
+00015420: 756c 743a 2060 6661 6c73 6560 2e0a 2f2f  ult: `false`..//
+00015430: 2020 2072 6f75 6e64 696e 6720 3d20 5468     rounding = Th
+00015440: 6520 7261 6469 7573 206f 6620 7468 6520  e radius of the 
+00015450: 726f 756e 6469 6e67 206f 6e20 7468 6520  rounding on the 
+00015460: 656e 6473 206f 6620 7468 6520 6379 6c69  ends of the cyli
+00015470: 6e64 6572 2e20 2044 6566 6175 6c74 3a20  nder.  Default: 
+00015480: 6e6f 6e65 2e0a 2f2f 2020 2072 6f75 6e64  none..//   round
+00015490: 696e 6731 203d 2054 6865 2072 6164 6975  ing1 = The radiu
+000154a0: 7320 6f66 2074 6865 2072 6f75 6e64 696e  s of the roundin
+000154b0: 6720 6f6e 2074 6865 2066 726f 6e74 2065  g on the front e
+000154c0: 6e64 206f 6620 7468 6520 6379 6c69 6e64  nd of the cylind
+000154d0: 6572 2e0a 2f2f 2020 2072 6f75 6e64 696e  er..//   roundin
+000154e0: 6732 203d 2054 6865 2072 6164 6975 7320  g2 = The radius 
+000154f0: 6f66 2074 6865 2072 6f75 6e64 696e 6720  of the rounding 
+00015500: 6f6e 2074 6865 2062 6163 6b20 656e 6420  on the back end 
+00015510: 6f66 2074 6865 2063 796c 696e 6465 722e  of the cylinder.
+00015520: 0a2f 2f20 2020 7265 616c 6967 6e20 3d20  .//   realign = 
+00015530: 4966 2074 7275 652c 2072 6f74 6174 6520  If true, rotate 
+00015540: 7468 6520 6379 6c69 6e64 6572 2062 7920  the cylinder by 
+00015550: 6861 6c66 2074 6865 2061 6e67 6c65 206f  half the angle o
+00015560: 6620 6f6e 6520 6661 6365 2e0a 2f2f 2020  f one face..//  
+00015570: 2061 6e63 686f 7220 3d20 5472 616e 736c   anchor = Transl
+00015580: 6174 6520 736f 2061 6e63 686f 7220 706f  ate so anchor po
+00015590: 696e 7420 6973 2061 7420 6f72 6967 696e  int is at origin
+000155a0: 2028 302c 302c 3029 2e20 2053 6565 205b   (0,0,0).  See [
+000155b0: 616e 6368 6f72 5d28 6174 7461 6368 6d65  anchor](attachme
+000155c0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+000155d0: 696f 6e2d 616e 6368 6f72 292e 2020 4465  ion-anchor).  De
+000155e0: 6661 756c 743a 2060 4345 4e54 4552 600a  fault: `CENTER`.
+000155f0: 2f2f 2020 2073 7069 6e20 3d20 526f 7461  //   spin = Rota
+00015600: 7465 2074 6869 7320 6d61 6e79 2064 6567  te this many deg
+00015610: 7265 6573 2061 726f 756e 6420 7468 6520  rees around the 
+00015620: 5a20 6178 6973 2061 6674 6572 2061 6e63  Z axis after anc
+00015630: 686f 722e 2020 5365 6520 5b73 7069 6e5d  hor.  See [spin]
+00015640: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00015650: 6423 7375 6273 6563 7469 6f6e 2d73 7069  d#subsection-spi
+00015660: 6e29 2e20 2044 6566 6175 6c74 3a20 6030  n).  Default: `0
+00015670: 600a 2f2f 2020 206f 7269 656e 7420 3d20  `.//   orient = 
+00015680: 5665 6374 6f72 2074 6f20 726f 7461 7465  Vector to rotate
+00015690: 2074 6f70 2074 6f77 6172 6473 2c20 6166   top towards, af
+000156a0: 7465 7220 7370 696e 2e20 2053 6565 205b  ter spin.  See [
+000156b0: 6f72 6965 6e74 5d28 6174 7461 6368 6d65  orient](attachme
+000156c0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+000156d0: 696f 6e2d 6f72 6965 6e74 292e 2020 4465  ion-orient).  De
+000156e0: 6661 756c 743a 2060 5550 600a 2f2f 0a2f  fault: `UP`.//./
+000156f0: 2f20 4578 616d 706c 653a 2042 7920 5261  / Example: By Ra
+00015700: 6469 7573 0a2f 2f20 2020 7864 6973 7472  dius.//   xdistr
+00015710: 6962 7574 6528 3530 2920 7b0a 2f2f 2020  ibute(50) {.//  
+00015720: 2020 2020 2079 6379 6c28 6c3d 3335 2c20       ycyl(l=35, 
+00015730: 723d 3130 293b 0a2f 2f20 2020 2020 2020  r=10);.//       
+00015740: 7963 796c 286c 3d33 352c 2072 313d 3135  ycyl(l=35, r1=15
+00015750: 2c20 7232 3d35 293b 0a2f 2f20 2020 7d0a  , r2=5);.//   }.
+00015760: 2f2f 0a2f 2f20 4578 616d 706c 653a 2042  //.// Example: B
+00015770: 7920 4469 616d 6574 6572 0a2f 2f20 2020  y Diameter.//   
+00015780: 7864 6973 7472 6962 7574 6528 3530 2920  xdistribute(50) 
+00015790: 7b0a 2f2f 2020 2020 2020 2079 6379 6c28  {.//       ycyl(
+000157a0: 6c3d 3335 2c20 643d 3230 293b 0a2f 2f20  l=35, d=20);.// 
+000157b0: 2020 2020 2020 7963 796c 286c 3d33 352c        ycyl(l=35,
+000157c0: 2064 313d 3330 2c20 6432 3d31 3029 3b0a   d1=30, d2=10);.
+000157d0: 2f2f 2020 207d 0a0a 6675 6e63 7469 6f6e  //   }..function
+000157e0: 2079 6379 6c28 0a20 2020 2068 2c20 722c   ycyl(.    h, r,
+000157f0: 2064 2c20 7231 2c20 7232 2c20 6431 2c20   d, r1, r2, d1, 
+00015800: 6432 2c20 6c2c 0a20 2020 2063 6861 6d66  d2, l,.    chamf
+00015810: 6572 2c20 6368 616d 6665 7231 2c20 6368  er, chamfer1, ch
+00015820: 616d 6665 7232 2c0a 2020 2020 6368 616d  amfer2,.    cham
+00015830: 6661 6e67 2c20 6368 616d 6661 6e67 312c  fang, chamfang1,
+00015840: 2063 6861 6d66 616e 6732 2c0a 2020 2020   chamfang2,.    
+00015850: 726f 756e 6469 6e67 2c20 726f 756e 6469  rounding, roundi
+00015860: 6e67 312c 2072 6f75 6e64 696e 6732 2c0a  ng1, rounding2,.
+00015870: 2020 2020 6369 7263 756d 3d66 616c 7365      circum=false
+00015880: 2c20 7265 616c 6967 6e3d 6661 6c73 652c  , realign=false,
+00015890: 2066 726f 6d5f 656e 643d 6661 6c73 652c   from_end=false,
+000158a0: 6865 6967 6874 2c6c 656e 6774 682c 0a20  height,length,. 
+000158b0: 2020 2061 6e63 686f 723d 4345 4e54 4552     anchor=CENTER
+000158c0: 2c20 7370 696e 3d30 2c20 6f72 6965 6e74  , spin=0, orient
+000158d0: 3d55 500a 2920 3d20 6e6f 5f66 756e 6374  =UP.) = no_funct
+000158e0: 696f 6e28 2279 6379 6c22 293b 0a0a 0a6d  ion("ycyl");...m
+000158f0: 6f64 756c 6520 7963 796c 280a 2020 2020  odule ycyl(.    
+00015900: 682c 2072 2c20 642c 2072 312c 2072 322c  h, r, d, r1, r2,
+00015910: 2064 312c 2064 322c 206c 2c0a 2020 2020   d1, d2, l,.    
+00015920: 6368 616d 6665 722c 2063 6861 6d66 6572  chamfer, chamfer
+00015930: 312c 2063 6861 6d66 6572 322c 0a20 2020  1, chamfer2,.   
+00015940: 2063 6861 6d66 616e 672c 2063 6861 6d66   chamfang, chamf
+00015950: 616e 6731 2c20 6368 616d 6661 6e67 322c  ang1, chamfang2,
+00015960: 0a20 2020 2072 6f75 6e64 696e 672c 2072  .    rounding, r
+00015970: 6f75 6e64 696e 6731 2c20 726f 756e 6469  ounding1, roundi
+00015980: 6e67 322c 0a20 2020 2063 6972 6375 6d3d  ng2,.    circum=
+00015990: 6661 6c73 652c 2072 6561 6c69 676e 3d66  false, realign=f
+000159a0: 616c 7365 2c20 6672 6f6d 5f65 6e64 3d66  alse, from_end=f
+000159b0: 616c 7365 2c68 6569 6768 742c 6c65 6e67  alse,height,leng
+000159c0: 7468 2c0a 2020 2020 616e 6368 6f72 3d43  th,.    anchor=C
+000159d0: 454e 5445 522c 2073 7069 6e3d 302c 206f  ENTER, spin=0, o
+000159e0: 7269 656e 743d 5550 0a29 207b 0a20 2020  rient=UP.) {.   
+000159f0: 2072 3120 3d20 6765 745f 7261 6469 7573   r1 = get_radius
+00015a00: 2872 313d 7231 2c20 723d 722c 2064 313d  (r1=r1, r=r, d1=
+00015a10: 6431 2c20 643d 642c 2064 666c 743d 3129  d1, d=d, dflt=1)
+00015a20: 3b0a 2020 2020 7232 203d 2067 6574 5f72  ;.    r2 = get_r
+00015a30: 6164 6975 7328 7231 3d72 322c 2072 3d72  adius(r1=r2, r=r
+00015a40: 2c20 6431 3d64 322c 2064 3d64 2c20 6466  , d1=d2, d=d, df
+00015a50: 6c74 3d31 293b 0a20 2020 206c 203d 206f  lt=1);.    l = o
+00015a60: 6e65 5f64 6566 696e 6564 285b 6c2c 682c  ne_defined([l,h,
+00015a70: 6c65 6e67 7468 2c68 6569 6768 745d 2c22  length,height],"
+00015a80: 6c2c 682c 6c65 6e67 7468 2c68 6569 6768  l,h,length,heigh
+00015a90: 7422 2c31 293b 0a20 2020 2061 7474 6163  t",1);.    attac
+00015aa0: 6861 626c 6528 616e 6368 6f72 2c73 7069  hable(anchor,spi
+00015ab0: 6e2c 6f72 6965 6e74 2c20 7231 3d72 312c  n,orient, r1=r1,
+00015ac0: 2072 323d 7232 2c20 6c3d 6c2c 2061 7869   r2=r2, l=l, axi
+00015ad0: 733d 4241 434b 2920 7b0a 2020 2020 2020  s=BACK) {.      
+00015ae0: 2020 6379 6c28 0a20 2020 2020 2020 2020    cyl(.         
+00015af0: 2020 206c 3d6c 2c20 7231 3d72 312c 2072     l=l, r1=r1, r
+00015b00: 323d 7232 2c0a 2020 2020 2020 2020 2020  2=r2,.          
+00015b10: 2020 6368 616d 6665 723d 6368 616d 6665    chamfer=chamfe
+00015b20: 722c 2063 6861 6d66 6572 313d 6368 616d  r, chamfer1=cham
+00015b30: 6665 7231 2c20 6368 616d 6665 7232 3d63  fer1, chamfer2=c
+00015b40: 6861 6d66 6572 322c 0a20 2020 2020 2020  hamfer2,.       
+00015b50: 2020 2020 2063 6861 6d66 616e 673d 6368       chamfang=ch
+00015b60: 616d 6661 6e67 2c20 6368 616d 6661 6e67  amfang, chamfang
+00015b70: 313d 6368 616d 6661 6e67 312c 2063 6861  1=chamfang1, cha
+00015b80: 6d66 616e 6732 3d63 6861 6d66 616e 6732  mfang2=chamfang2
+00015b90: 2c0a 2020 2020 2020 2020 2020 2020 726f  ,.            ro
+00015ba0: 756e 6469 6e67 3d72 6f75 6e64 696e 672c  unding=rounding,
+00015bb0: 2072 6f75 6e64 696e 6731 3d72 6f75 6e64   rounding1=round
+00015bc0: 696e 6731 2c20 726f 756e 6469 6e67 323d  ing1, rounding2=
+00015bd0: 726f 756e 6469 6e67 322c 0a20 2020 2020  rounding2,.     
+00015be0: 2020 2020 2020 2063 6972 6375 6d3d 6369         circum=ci
+00015bf0: 7263 756d 2c20 7265 616c 6967 6e3d 7265  rcum, realign=re
+00015c00: 616c 6967 6e2c 2066 726f 6d5f 656e 643d  align, from_end=
+00015c10: 6672 6f6d 5f65 6e64 2c0a 2020 2020 2020  from_end,.      
+00015c20: 2020 2020 2020 616e 6368 6f72 3d43 454e        anchor=CEN
+00015c30: 5445 522c 206f 7269 656e 743d 4241 434b  TER, orient=BACK
+00015c40: 0a20 2020 2020 2020 2029 3b0a 2020 2020  .        );.    
+00015c50: 2020 2020 6368 696c 6472 656e 2829 3b0a      children();.
+00015c60: 2020 2020 7d0a 7d0a 0a0a 0a2f 2f20 4d6f      }.}....// Mo
+00015c70: 6475 6c65 3a20 7a63 796c 2829 0a2f 2f20  dule: zcyl().// 
+00015c80: 5379 6e6f 7073 6973 3a20 6372 6561 7465  Synopsis: create
+00015c90: 7320 6120 6379 6c69 6e64 6572 206f 7269  s a cylinder ori
+00015ca0: 656e 7465 6420 616c 6f6e 6720 7468 6520  ented along the 
+00015cb0: 5a20 6178 6973 2c20 6f72 2072 6574 7572  Z axis, or retur
+00015cc0: 6e73 2061 2076 6e66 2e0a 2f2f 2054 6f70  ns a vnf..// Top
+00015cd0: 6963 733a 2043 796c 696e 6465 7273 2c20  ics: Cylinders, 
+00015ce0: 5465 7874 7572 6573 2c20 526f 756e 6469  Textures, Roundi
+00015cf0: 6e67 2c20 4368 616d 6665 7273 0a2f 2f20  ng, Chamfers.// 
+00015d00: 5365 6520 416c 736f 3a20 7465 7874 7572  See Also: textur
+00015d10: 6528 292c 2072 6f74 6174 655f 7377 6565  e(), rotate_swee
+00015d20: 7028 292c 2063 796c 2829 0a2f 2f20 4465  p(), cyl().// De
+00015d30: 7363 7269 7074 696f 6e3a 0a2f 2f20 2020  scription:.//   
+00015d40: 4372 6561 7465 7320 616e 2061 7474 6163  Creates an attac
+00015d50: 6861 626c 6520 6379 6c69 6e64 6572 2077  hable cylinder w
+00015d60: 6974 6820 726f 756e 646f 7665 7273 2061  ith roundovers a
+00015d70: 6e64 2063 6861 6d66 6572 696e 6720 6f72  nd chamfering or
+00015d80: 6965 6e74 6564 2061 6c6f 6e67 2074 6865  iented along the
+00015d90: 205a 2061 7869 732e 0a2f 2f0a 2f2f 2055   Z axis..//.// U
+00015da0: 7361 6765 3a20 5479 7069 6361 6c0a 2f2f  sage: Typical.//
+00015db0: 2020 207a 6379 6c28 6c7c 687c 6c65 6e67     zcyl(l|h|leng
+00015dc0: 7468 7c68 6569 6768 742c 2072 7c64 3d2c  th|height, r|d=,
+00015dd0: 205b 616e 6368 6f72 3d5d 2c2e 2e2e 2920   [anchor=],...) 
+00015de0: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
+00015df0: 2f20 2020 7a63 796c 286c 7c68 7c6c 656e  /   zcyl(l|h|len
+00015e00: 6774 687c 6865 6967 6874 2c20 7231 3d7c  gth|height, r1=|
+00015e10: 6431 3d2c 2072 323d 7c64 323d 2c20 5b61  d1=, r2=|d2=, [a
+00015e20: 6e63 686f 723d 5d2c 2e2e 2e29 3b0a 2f2f  nchor=],...);.//
+00015e30: 0a2f 2f20 4172 6775 6d65 6e74 733a 0a2f  .// Arguments:./
+00015e40: 2f20 2020 6c20 2f20 6820 2f20 6c65 6e67  /   l / h / leng
+00015e50: 7468 202f 2068 6569 6768 7420 3d20 4c65  th / height = Le
+00015e60: 6e67 7468 206f 6620 6379 6c69 6e64 6572  ngth of cylinder
+00015e70: 2061 6c6f 6e67 206f 7269 656e 7465 6420   along oriented 
+00015e80: 6178 6973 2e20 2844 6566 6175 6c74 3a20  axis. (Default: 
+00015e90: 312e 3029 0a2f 2f20 2020 7220 3d20 5261  1.0).//   r = Ra
+00015ea0: 6469 7573 206f 6620 6379 6c69 6e64 6572  dius of cylinder
+00015eb0: 2e0a 2f2f 2020 202d 2d2d 0a2f 2f20 2020  ..//   ---.//   
+00015ec0: 7231 203d 2052 6164 6975 7320 6f66 2066  r1 = Radius of f
+00015ed0: 726f 6e74 2028 592d 2920 656e 6420 6f66  ront (Y-) end of
+00015ee0: 2063 6f6e 652e 0a2f 2f20 2020 7232 203d   cone..//   r2 =
+00015ef0: 2052 6164 6975 7320 6f66 2062 6163 6b20   Radius of back 
+00015f00: 2859 2b29 2065 6e64 206f 6620 6f6e 652e  (Y+) end of one.
+00015f10: 0a2f 2f20 2020 6420 3d20 4469 616d 6574  .//   d = Diamet
+00015f20: 6572 206f 6620 6379 6c69 6e64 6572 2e0a  er of cylinder..
+00015f30: 2f2f 2020 2064 3120 3d20 4469 616d 6574  //   d1 = Diamet
+00015f40: 6572 206f 6620 6672 6f6e 7420 2859 2d29  er of front (Y-)
+00015f50: 2065 6e64 206f 6620 6f6e 652e 0a2f 2f20   end of one..// 
+00015f60: 2020 6432 203d 2044 6961 6d65 7465 7220    d2 = Diameter 
+00015f70: 6f66 2062 6163 6b20 2859 2b29 2065 6e64  of back (Y+) end
+00015f80: 206f 6620 6f6e 652e 0a2f 2f20 2020 6369   of one..//   ci
+00015f90: 7263 756d 203d 2049 6620 7472 7565 2c20  rcum = If true, 
+00015fa0: 6379 6c69 6e64 6572 2073 686f 756c 6420  cylinder should 
+00015fb0: 6369 7263 756d 7363 7269 6265 2074 6865  circumscribe the
+00015fc0: 2063 6972 636c 6520 6f66 2074 6865 2067   circle of the g
+00015fd0: 6976 656e 2073 697a 652e 2020 4f74 6865  iven size.  Othe
+00015fe0: 7277 6973 6520 696e 7363 7269 6265 732e  rwise inscribes.
+00015ff0: 2020 4465 6661 756c 743a 2060 6661 6c73    Default: `fals
+00016000: 6560 0a2f 2f20 2020 6368 616d 6665 7220  e`.//   chamfer 
+00016010: 3d20 5468 6520 7369 7a65 206f 6620 7468  = The size of th
+00016020: 6520 6368 616d 6665 7273 206f 6e20 7468  e chamfers on th
+00016030: 6520 656e 6473 206f 6620 7468 6520 6379  e ends of the cy
+00016040: 6c69 6e64 6572 2e20 2044 6566 6175 6c74  linder.  Default
+00016050: 3a20 6e6f 6e65 2e0a 2f2f 2020 2063 6861  : none..//   cha
+00016060: 6d66 6572 3120 3d20 5468 6520 7369 7a65  mfer1 = The size
+00016070: 206f 6620 7468 6520 6368 616d 6665 7220   of the chamfer 
+00016080: 6f6e 2074 6865 2062 6f74 746f 6d20 656e  on the bottom en
+00016090: 6420 6f66 2074 6865 2063 796c 696e 6465  d of the cylinde
+000160a0: 722e 2020 4465 6661 756c 743a 206e 6f6e  r.  Default: non
+000160b0: 652e 0a2f 2f20 2020 6368 616d 6665 7232  e..//   chamfer2
+000160c0: 203d 2054 6865 2073 697a 6520 6f66 2074   = The size of t
+000160d0: 6865 2063 6861 6d66 6572 206f 6e20 7468  he chamfer on th
+000160e0: 6520 746f 7020 656e 6420 6f66 2074 6865  e top end of the
+000160f0: 2063 796c 696e 6465 722e 2020 4465 6661   cylinder.  Defa
+00016100: 756c 743a 206e 6f6e 652e 0a2f 2f20 2020  ult: none..//   
+00016110: 6368 616d 6661 6e67 203d 2054 6865 2061  chamfang = The a
+00016120: 6e67 6c65 2069 6e20 6465 6772 6565 7320  ngle in degrees 
+00016130: 6f66 2074 6865 2063 6861 6d66 6572 7320  of the chamfers 
+00016140: 6f6e 2074 6865 2065 6e64 7320 6f66 2074  on the ends of t
+00016150: 6865 2063 796c 696e 6465 722e 0a2f 2f20  he cylinder..// 
+00016160: 2020 6368 616d 6661 6e67 3120 3d20 5468    chamfang1 = Th
+00016170: 6520 616e 676c 6520 696e 2064 6567 7265  e angle in degre
+00016180: 6573 206f 6620 7468 6520 6368 616d 6665  es of the chamfe
+00016190: 7220 6f6e 2074 6865 2062 6f74 746f 6d20  r on the bottom 
+000161a0: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
+000161b0: 6465 722e 0a2f 2f20 2020 6368 616d 6661  der..//   chamfa
+000161c0: 6e67 3220 3d20 5468 6520 616e 676c 6520  ng2 = The angle 
+000161d0: 696e 2064 6567 7265 6573 206f 6620 7468  in degrees of th
+000161e0: 6520 6368 616d 6665 7220 6f6e 2074 6865  e chamfer on the
+000161f0: 2074 6f70 2065 6e64 206f 6620 7468 6520   top end of the 
+00016200: 6379 6c69 6e64 6572 2e0a 2f2f 2020 2066  cylinder..//   f
+00016210: 726f 6d5f 656e 6420 3d20 4966 2074 7275  rom_end = If tru
+00016220: 652c 2063 6861 6d66 6572 2069 7320 6d65  e, chamfer is me
+00016230: 6173 7572 6564 2066 726f 6d20 7468 6520  asured from the 
+00016240: 656e 6420 6f66 2074 6865 2063 796c 696e  end of the cylin
+00016250: 6465 722c 2069 6e73 7465 6164 206f 6620  der, instead of 
+00016260: 696e 7365 7420 6672 6f6d 2074 6865 2065  inset from the e
+00016270: 6467 652e 2020 4465 6661 756c 743a 2060  dge.  Default: `
+00016280: 6661 6c73 6560 2e0a 2f2f 2020 2072 6f75  false`..//   rou
+00016290: 6e64 696e 6720 3d20 5468 6520 7261 6469  nding = The radi
+000162a0: 7573 206f 6620 7468 6520 726f 756e 6469  us of the roundi
+000162b0: 6e67 206f 6e20 7468 6520 656e 6473 206f  ng on the ends o
+000162c0: 6620 7468 6520 6379 6c69 6e64 6572 2e20  f the cylinder. 
+000162d0: 2044 6566 6175 6c74 3a20 6e6f 6e65 2e0a   Default: none..
+000162e0: 2f2f 2020 2072 6f75 6e64 696e 6731 203d  //   rounding1 =
+000162f0: 2054 6865 2072 6164 6975 7320 6f66 2074   The radius of t
+00016300: 6865 2072 6f75 6e64 696e 6720 6f6e 2074  he rounding on t
+00016310: 6865 2062 6f74 746f 6d20 656e 6420 6f66  he bottom end of
+00016320: 2074 6865 2063 796c 696e 6465 722e 0a2f   the cylinder../
+00016330: 2f20 2020 726f 756e 6469 6e67 3220 3d20  /   rounding2 = 
+00016340: 5468 6520 7261 6469 7573 206f 6620 7468  The radius of th
+00016350: 6520 726f 756e 6469 6e67 206f 6e20 7468  e rounding on th
+00016360: 6520 746f 7020 656e 6420 6f66 2074 6865  e top end of the
+00016370: 2063 796c 696e 6465 722e 0a2f 2f20 2020   cylinder..//   
+00016380: 7265 616c 6967 6e20 3d20 4966 2074 7275  realign = If tru
+00016390: 652c 2072 6f74 6174 6520 7468 6520 6379  e, rotate the cy
+000163a0: 6c69 6e64 6572 2062 7920 6861 6c66 2074  linder by half t
+000163b0: 6865 2061 6e67 6c65 206f 6620 6f6e 6520  he angle of one 
+000163c0: 6661 6365 2e0a 2f2f 2020 2061 6e63 686f  face..//   ancho
+000163d0: 7220 3d20 5472 616e 736c 6174 6520 736f  r = Translate so
+000163e0: 2061 6e63 686f 7220 706f 696e 7420 6973   anchor point is
+000163f0: 2061 7420 6f72 6967 696e 2028 302c 302c   at origin (0,0,
+00016400: 3029 2e20 2053 6565 205b 616e 6368 6f72  0).  See [anchor
+00016410: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
+00016420: 6164 2373 7562 7365 6374 696f 6e2d 616e  ad#subsection-an
+00016430: 6368 6f72 292e 2020 4465 6661 756c 743a  chor).  Default:
+00016440: 2060 4345 4e54 4552 600a 2f2f 2020 2073   `CENTER`.//   s
+00016450: 7069 6e20 3d20 526f 7461 7465 2074 6869  pin = Rotate thi
+00016460: 7320 6d61 6e79 2064 6567 7265 6573 2061  s many degrees a
+00016470: 726f 756e 6420 7468 6520 5a20 6178 6973  round the Z axis
+00016480: 2061 6674 6572 2061 6e63 686f 722e 2020   after anchor.  
+00016490: 5365 6520 5b73 7069 6e5d 2861 7474 6163  See [spin](attac
+000164a0: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+000164b0: 6563 7469 6f6e 2d73 7069 6e29 2e20 2044  ection-spin).  D
+000164c0: 6566 6175 6c74 3a20 6030 600a 2f2f 2020  efault: `0`.//  
+000164d0: 206f 7269 656e 7420 3d20 5665 6374 6f72   orient = Vector
+000164e0: 2074 6f20 726f 7461 7465 2074 6f70 2074   to rotate top t
+000164f0: 6f77 6172 6473 2c20 6166 7465 7220 7370  owards, after sp
+00016500: 696e 2e20 2053 6565 205b 6f72 6965 6e74  in.  See [orient
+00016510: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
+00016520: 6164 2373 7562 7365 6374 696f 6e2d 6f72  ad#subsection-or
+00016530: 6965 6e74 292e 2020 4465 6661 756c 743a  ient).  Default:
+00016540: 2060 5550 600a 2f2f 0a2f 2f20 4578 616d   `UP`.//.// Exam
+00016550: 706c 653a 2042 7920 5261 6469 7573 0a2f  ple: By Radius./
+00016560: 2f20 2020 7864 6973 7472 6962 7574 6528  /   xdistribute(
+00016570: 3530 2920 7b0a 2f2f 2020 2020 2020 207a  50) {.//       z
+00016580: 6379 6c28 6c3d 3335 2c20 723d 3130 293b  cyl(l=35, r=10);
+00016590: 0a2f 2f20 2020 2020 2020 7a63 796c 286c  .//       zcyl(l
+000165a0: 3d33 352c 2072 313d 3135 2c20 7232 3d35  =35, r1=15, r2=5
+000165b0: 293b 0a2f 2f20 2020 7d0a 2f2f 0a2f 2f20  );.//   }.//.// 
+000165c0: 4578 616d 706c 653a 2042 7920 4469 616d  Example: By Diam
+000165d0: 6574 6572 0a2f 2f20 2020 7864 6973 7472  eter.//   xdistr
+000165e0: 6962 7574 6528 3530 2920 7b0a 2f2f 2020  ibute(50) {.//  
+000165f0: 2020 2020 207a 6379 6c28 6c3d 3335 2c20       zcyl(l=35, 
+00016600: 643d 3230 293b 0a2f 2f20 2020 2020 2020  d=20);.//       
+00016610: 7a63 796c 286c 3d33 352c 2064 313d 3330  zcyl(l=35, d1=30
+00016620: 2c20 6432 3d31 3029 3b0a 2f2f 2020 207d  , d2=10);.//   }
+00016630: 0a0a 6675 6e63 7469 6f6e 207a 6379 6c28  ..function zcyl(
+00016640: 0a20 2020 2068 2c20 722c 2064 2c20 7231  .    h, r, d, r1
+00016650: 2c20 7232 2c20 6431 2c20 6432 2c20 6c2c  , r2, d1, d2, l,
+00016660: 0a20 2020 2063 6861 6d66 6572 2c20 6368  .    chamfer, ch
+00016670: 616d 6665 7231 2c20 6368 616d 6665 7232  amfer1, chamfer2
+00016680: 2c0a 2020 2020 6368 616d 6661 6e67 2c20  ,.    chamfang, 
+00016690: 6368 616d 6661 6e67 312c 2063 6861 6d66  chamfang1, chamf
+000166a0: 616e 6732 2c0a 2020 2020 726f 756e 6469  ang2,.    roundi
+000166b0: 6e67 2c20 726f 756e 6469 6e67 312c 2072  ng, rounding1, r
+000166c0: 6f75 6e64 696e 6732 2c0a 2020 2020 6369  ounding2,.    ci
+000166d0: 7263 756d 3d66 616c 7365 2c20 7265 616c  rcum=false, real
+000166e0: 6967 6e3d 6661 6c73 652c 2066 726f 6d5f  ign=false, from_
+000166f0: 656e 643d 6661 6c73 652c 206c 656e 6774  end=false, lengt
+00016700: 682c 2068 6569 6768 742c 0a20 2020 2061  h, height,.    a
+00016710: 6e63 686f 723d 4345 4e54 4552 2c20 7370  nchor=CENTER, sp
+00016720: 696e 3d30 2c20 6f72 6965 6e74 3d55 500a  in=0, orient=UP.
+00016730: 2920 3d20 6e6f 5f66 756e 6374 696f 6e28  ) = no_function(
+00016740: 227a 6379 6c22 293b 0a0a 6d6f 6475 6c65  "zcyl");..module
+00016750: 207a 6379 6c28 0a20 2020 2068 2c20 722c   zcyl(.    h, r,
+00016760: 2064 2c20 7231 2c20 7232 2c20 6431 2c20   d, r1, r2, d1, 
+00016770: 6432 2c20 6c2c 0a20 2020 2063 6861 6d66  d2, l,.    chamf
+00016780: 6572 2c20 6368 616d 6665 7231 2c20 6368  er, chamfer1, ch
+00016790: 616d 6665 7232 2c0a 2020 2020 6368 616d  amfer2,.    cham
+000167a0: 6661 6e67 2c20 6368 616d 6661 6e67 312c  fang, chamfang1,
+000167b0: 2063 6861 6d66 616e 6732 2c0a 2020 2020   chamfang2,.    
+000167c0: 726f 756e 6469 6e67 2c20 726f 756e 6469  rounding, roundi
+000167d0: 6e67 312c 2072 6f75 6e64 696e 6732 2c0a  ng1, rounding2,.
+000167e0: 2020 2020 6369 7263 756d 3d66 616c 7365      circum=false
+000167f0: 2c20 7265 616c 6967 6e3d 6661 6c73 652c  , realign=false,
+00016800: 2066 726f 6d5f 656e 643d 6661 6c73 652c   from_end=false,
+00016810: 206c 656e 6774 682c 2068 6569 6768 742c   length, height,
+00016820: 0a20 2020 2061 6e63 686f 723d 4345 4e54  .    anchor=CENT
+00016830: 4552 2c20 7370 696e 3d30 2c20 6f72 6965  ER, spin=0, orie
+00016840: 6e74 3d55 500a 2920 7b0a 2020 2020 7231  nt=UP.) {.    r1
+00016850: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
+00016860: 3d72 312c 2072 3d72 2c20 6431 3d64 312c  =r1, r=r, d1=d1,
+00016870: 2064 3d64 2c20 6466 6c74 3d31 293b 0a20   d=d, dflt=1);. 
+00016880: 2020 2072 3220 3d20 6765 745f 7261 6469     r2 = get_radi
+00016890: 7573 2872 313d 7232 2c20 723d 722c 2064  us(r1=r2, r=r, d
+000168a0: 313d 6432 2c20 643d 642c 2064 666c 743d  1=d2, d=d, dflt=
+000168b0: 3129 3b0a 2020 2020 6c20 3d20 6f6e 655f  1);.    l = one_
+000168c0: 6465 6669 6e65 6428 5b6c 2c68 2c6c 656e  defined([l,h,len
+000168d0: 6774 682c 6865 6967 6874 5d2c 226c 2c68  gth,height],"l,h
+000168e0: 2c6c 656e 6774 682c 6865 6967 6874 222c  ,length,height",
+000168f0: 3129 3b0a 2020 2020 6174 7461 6368 6162  1);.    attachab
+00016900: 6c65 2861 6e63 686f 722c 7370 696e 2c6f  le(anchor,spin,o
+00016910: 7269 656e 742c 2072 313d 7231 2c20 7232  rient, r1=r1, r2
+00016920: 3d72 322c 206c 3d6c 2920 7b0a 2020 2020  =r2, l=l) {.    
+00016930: 2020 2020 6379 6c28 0a20 2020 2020 2020      cyl(.       
+00016940: 2020 2020 206c 3d6c 2c20 7231 3d72 312c       l=l, r1=r1,
+00016950: 2072 323d 7232 2c0a 2020 2020 2020 2020   r2=r2,.        
+00016960: 2020 2020 6368 616d 6665 723d 6368 616d      chamfer=cham
+00016970: 6665 722c 2063 6861 6d66 6572 313d 6368  fer, chamfer1=ch
+00016980: 616d 6665 7231 2c20 6368 616d 6665 7232  amfer1, chamfer2
+00016990: 3d63 6861 6d66 6572 322c 0a20 2020 2020  =chamfer2,.     
+000169a0: 2020 2020 2020 2063 6861 6d66 616e 673d         chamfang=
+000169b0: 6368 616d 6661 6e67 2c20 6368 616d 6661  chamfang, chamfa
+000169c0: 6e67 313d 6368 616d 6661 6e67 312c 2063  ng1=chamfang1, c
+000169d0: 6861 6d66 616e 6732 3d63 6861 6d66 616e  hamfang2=chamfan
+000169e0: 6732 2c0a 2020 2020 2020 2020 2020 2020  g2,.            
+000169f0: 726f 756e 6469 6e67 3d72 6f75 6e64 696e  rounding=roundin
+00016a00: 672c 2072 6f75 6e64 696e 6731 3d72 6f75  g, rounding1=rou
+00016a10: 6e64 696e 6731 2c20 726f 756e 6469 6e67  nding1, rounding
+00016a20: 323d 726f 756e 6469 6e67 322c 0a20 2020  2=rounding2,.   
+00016a30: 2020 2020 2020 2020 2063 6972 6375 6d3d           circum=
+00016a40: 6369 7263 756d 2c20 7265 616c 6967 6e3d  circum, realign=
+00016a50: 7265 616c 6967 6e2c 2066 726f 6d5f 656e  realign, from_en
+00016a60: 643d 6672 6f6d 5f65 6e64 2c0a 2020 2020  d=from_end,.    
+00016a70: 2020 2020 2020 2020 616e 6368 6f72 3d43          anchor=C
+00016a80: 454e 5445 520a 2020 2020 2020 2020 293b  ENTER.        );
+00016a90: 0a20 2020 2020 2020 2063 6869 6c64 7265  .        childre
+00016aa0: 6e28 293b 0a20 2020 207d 0a7d 0a0a 0a0a  n();.    }.}....
+00016ab0: 2f2f 204d 6f64 756c 653a 2074 7562 6528  // Module: tube(
+00016ac0: 290a 2f2f 2053 796e 6f70 7369 733a 2043  ).// Synopsis: C
+00016ad0: 7265 6174 6573 2061 2063 796c 696e 6472  reates a cylindr
+00016ae0: 6963 616c 206f 7220 636f 6e69 6361 6c20  ical or conical 
+00016af0: 7475 6265 2c20 6f72 2072 6574 7572 6e73  tube, or returns
+00016b00: 2061 2076 6e66 2e0a 2f2f 2054 6f70 6963   a vnf..// Topic
+00016b10: 733a 2053 6861 7065 7320 2833 4429 2c20  s: Shapes (3D), 
+00016b20: 4174 7461 6368 6162 6c65 2c20 564e 4620  Attachable, VNF 
+00016b30: 4765 6e65 7261 746f 7273 0a2f 2f20 5365  Generators.// Se
+00016b40: 6520 416c 736f 3a20 7265 6374 5f74 7562  e Also: rect_tub
+00016b50: 6528 290a 2f2f 2044 6573 6372 6970 7469  e().// Descripti
+00016b60: 6f6e 3a0a 2f2f 2020 204d 616b 6573 2061  on:.//   Makes a
+00016b70: 2068 6f6c 6c6f 7720 7475 6265 2074 6861   hollow tube tha
+00016b80: 7420 6361 6e20 6265 2063 796c 696e 6472  t can be cylindr
+00016b90: 6963 616c 206f 7220 636f 6e69 6361 6c20  ical or conical 
+00016ba0: 6279 2073 7065 6369 6679 696e 6720 696e  by specifying in
+00016bb0: 6e65 7220 616e 6420 6f75 7465 7220 6469  ner and outer di
+00016bc0: 6d65 6e73 696f 6e73 206f 7220 6279 2067  mensions or by g
+00016bd0: 6976 696e 6720 6f6e 6520 6469 6d65 6e73  iving one dimens
+00016be0: 696f 6e20 616e 640a 2f2f 2020 2077 616c  ion and.//   wal
+00016bf0: 6c20 7468 6963 6b6e 6573 732e 200a 2f2f  l thickness. .//
+00016c00: 2055 7361 6765 3a20 4261 7369 6320 6379   Usage: Basic cy
+00016c10: 6c69 6e64 7269 6361 6c20 7475 6265 2c20  lindrical tube, 
+00016c20: 7370 6563 6966 7969 6e67 2069 6e6e 6572  specifying inner
+00016c30: 2061 6e64 206f 7574 6572 2072 6164 6975   and outer radiu
+00016c40: 7320 6f72 2064 6961 6d65 7465 720a 2f2f  s or diameter.//
+00016c50: 2020 2074 7562 6528 687c 6c2c 206f 722c     tube(h|l, or,
+00016c60: 2069 722c 205b 6365 6e74 6572 5d2c 205b   ir, [center], [
+00016c70: 7265 616c 6967 6e3d 5d2c 205b 616e 6368  realign=], [anch
+00016c80: 6f72 3d5d 2c20 5b73 7069 6e3d 5d2c 5b6f  or=], [spin=],[o
+00016c90: 7269 656e 743d 5d29 205b 4154 5441 4348  rient=]) [ATTACH
+00016ca0: 4d45 4e54 535d 3b0a 2f2f 2020 2074 7562  MENTS];.//   tub
+00016cb0: 6528 687c 6c2c 206f 643d 2c20 6964 3d2c  e(h|l, od=, id=,
+00016cc0: 202e 2e2e 2920 205b 4154 5441 4348 4d45   ...)  [ATTACHME
+00016cd0: 4e54 535d 3b0a 2f2f 2055 7361 6765 3a20  NTS];.// Usage: 
+00016ce0: 5370 6563 6966 7920 7761 6c6c 2074 6869  Specify wall thi
+00016cf0: 636b 6e65 7373 0a2f 2f20 2020 7475 6265  ckness.//   tube
+00016d00: 2868 7c6c 2c20 6f72 7c6f 643d 7c69 723d  (h|l, or|od=|ir=
+00016d10: 7c69 643d 2c20 7761 6c6c 3d2c 202e 2e2e  |id=, wall=, ...
+00016d20: 2920 5b41 5454 4143 484d 454e 5453 5d3b  ) [ATTACHMENTS];
+00016d30: 0a2f 2f20 5573 6167 653a 2043 6f6e 6963  .// Usage: Conic
+00016d40: 616c 2074 7562 6573 0a2f 2f20 2020 7475  al tubes.//   tu
+00016d50: 6265 2868 7c6c 2c20 6972 313d 7c69 6431  be(h|l, ir1=|id1
+00016d60: 3d2c 2069 7232 3d7c 6964 323d 2c20 6f72  =, ir2=|id2=, or
+00016d70: 313d 7c6f 6431 3d2c 206f 7232 3d7c 6f64  1=|od1=, or2=|od
+00016d80: 323d 2c20 2e2e 2e29 205b 4154 5441 4348  2=, ...) [ATTACH
+00016d90: 4d45 4e54 535d 3b0a 2f2f 2020 2074 7562  MENTS];.//   tub
+00016da0: 6528 687c 6c2c 206f 7231 3d7c 6f64 313d  e(h|l, or1=|od1=
+00016db0: 2c20 6f72 323d 7c6f 6432 3d2c 2077 616c  , or2=|od2=, wal
+00016dc0: 6c3d 2c20 2e2e 2e29 205b 4154 5441 4348  l=, ...) [ATTACH
+00016dd0: 4d45 4e54 535d 3b0a 2f2f 2041 7267 756d  MENTS];.// Argum
+00016de0: 656e 7473 3a0a 2f2f 2020 2068 202f 206c  ents:.//   h / l
+00016df0: 203d 2068 6569 6768 7420 6f66 2074 7562   = height of tub
+00016e00: 652e 2044 6566 6175 6c74 3a20 310a 2f2f  e. Default: 1.//
+00016e10: 2020 206f 7220 3d20 4f75 7465 7220 7261     or = Outer ra
+00016e20: 6469 7573 206f 6620 7475 6265 2e20 4465  dius of tube. De
+00016e30: 6661 756c 743a 2031 0a2f 2f20 2020 6972  fault: 1.//   ir
+00016e40: 203d 2049 6e6e 6572 2072 6164 6975 7320   = Inner radius 
+00016e50: 6f66 2074 7562 652e 0a2f 2f20 2020 6365  of tube..//   ce
+00016e60: 6e74 6572 203d 2049 6620 6769 7665 6e2c  nter = If given,
+00016e70: 206f 7665 7272 6964 6573 2060 616e 6368   overrides `anch
+00016e80: 6f72 602e 2020 4120 7472 7565 2076 616c  or`.  A true val
+00016e90: 7565 2073 6574 7320 6061 6e63 686f 723d  ue sets `anchor=
+00016ea0: 4345 4e54 4552 602c 2066 616c 7365 2073  CENTER`, false s
+00016eb0: 6574 7320 6061 6e63 686f 723d 444f 574e  ets `anchor=DOWN
+00016ec0: 602e 0a2f 2f20 2020 2d2d 2d0a 2f2f 2020  `..//   ---.//  
+00016ed0: 206f 6420 3d20 4f75 7465 7220 6469 616d   od = Outer diam
+00016ee0: 6574 6572 206f 6620 7475 6265 2e0a 2f2f  eter of tube..//
+00016ef0: 2020 2069 6420 3d20 496e 6e65 7220 6469     id = Inner di
+00016f00: 616d 6574 6572 206f 6620 7475 6265 2e0a  ameter of tube..
+00016f10: 2f2f 2020 2077 616c 6c20 3d20 686f 7269  //   wall = hori
+00016f20: 7a6f 6e74 616c 2074 6869 636b 6e65 7373  zontal thickness
+00016f30: 206f 6620 7475 6265 2077 616c 6c2e 2044   of tube wall. D
+00016f40: 6566 6175 6c74 2031 0a2f 2f20 2020 6f72  efault 1.//   or
+00016f50: 3120 3d20 4f75 7465 7220 7261 6469 7573  1 = Outer radius
+00016f60: 206f 6620 626f 7474 6f6d 206f 6620 7475   of bottom of tu
+00016f70: 6265 2e20 2044 6566 6175 6c74 3a20 7661  be.  Default: va
+00016f80: 6c75 6520 6f66 2072 290a 2f2f 2020 206f  lue of r).//   o
+00016f90: 7232 203d 204f 7574 6572 2072 6164 6975  r2 = Outer radiu
+00016fa0: 7320 6f66 2074 6f70 206f 6620 7475 6265  s of top of tube
+00016fb0: 2e20 2044 6566 6175 6c74 3a20 7661 6c75  .  Default: valu
+00016fc0: 6520 6f66 2072 290a 2f2f 2020 206f 6431  e of r).//   od1
+00016fd0: 203d 204f 7574 6572 2064 6961 6d65 7465   = Outer diamete
+00016fe0: 7220 6f66 2062 6f74 746f 6d20 6f66 2074  r of bottom of t
+00016ff0: 7562 652e 0a2f 2f20 2020 6f64 3220 3d20  ube..//   od2 = 
+00017000: 4f75 7465 7220 6469 616d 6574 6572 206f  Outer diameter o
+00017010: 6620 746f 7020 6f66 2074 7562 652e 0a2f  f top of tube../
+00017020: 2f20 2020 6972 3120 3d20 496e 6e65 7220  /   ir1 = Inner 
+00017030: 7261 6469 7573 206f 6620 626f 7474 6f6d  radius of bottom
+00017040: 206f 6620 7475 6265 2e0a 2f2f 2020 2069   of tube..//   i
+00017050: 7232 203d 2049 6e6e 6572 2072 6164 6975  r2 = Inner radiu
+00017060: 7320 6f66 2074 6f70 206f 6620 7475 6265  s of top of tube
+00017070: 2e0a 2f2f 2020 2069 6431 203d 2049 6e6e  ..//   id1 = Inn
+00017080: 6572 2064 6961 6d65 7465 7220 6f66 2062  er diameter of b
+00017090: 6f74 746f 6d20 6f66 2074 7562 652e 0a2f  ottom of tube../
+000170a0: 2f20 2020 6964 3220 3d20 496e 6e65 7220  /   id2 = Inner 
+000170b0: 6469 616d 6574 6572 206f 6620 746f 7020  diameter of top 
+000170c0: 6f66 2074 7562 652e 0a2f 2f20 2020 7265  of tube..//   re
+000170d0: 616c 6967 6e20 3d20 4966 2074 7275 652c  align = If true,
+000170e0: 2072 6f74 6174 6520 7468 6520 7475 6265   rotate the tube
+000170f0: 2062 7920 6861 6c66 2074 6865 2061 6e67   by half the ang
+00017100: 6c65 206f 6620 6f6e 6520 6661 6365 2e0a  le of one face..
+00017110: 2f2f 2020 2061 6e63 686f 7220 3d20 5472  //   anchor = Tr
+00017120: 616e 736c 6174 6520 736f 2061 6e63 686f  anslate so ancho
+00017130: 7220 706f 696e 7420 6973 2061 7420 6f72  r point is at or
+00017140: 6967 696e 2028 302c 302c 3029 2e20 2053  igin (0,0,0).  S
+00017150: 6565 205b 616e 6368 6f72 5d28 6174 7461  ee [anchor](atta
+00017160: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00017170: 7365 6374 696f 6e2d 616e 6368 6f72 292e  section-anchor).
+00017180: 2020 4465 6661 756c 743a 2060 4345 4e54    Default: `CENT
+00017190: 4552 600a 2f2f 2020 2073 7069 6e20 3d20  ER`.//   spin = 
+000171a0: 526f 7461 7465 2074 6869 7320 6d61 6e79  Rotate this many
+000171b0: 2064 6567 7265 6573 2061 726f 756e 6420   degrees around 
+000171c0: 7468 6520 5a20 6178 6973 2061 6674 6572  the Z axis after
+000171d0: 2061 6e63 686f 722e 2020 5365 6520 5b73   anchor.  See [s
+000171e0: 7069 6e5d 2861 7474 6163 686d 656e 7473  pin](attachments
+000171f0: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
+00017200: 2d73 7069 6e29 2e20 2044 6566 6175 6c74  -spin).  Default
+00017210: 3a20 6030 600a 2f2f 2020 206f 7269 656e  : `0`.//   orien
+00017220: 7420 3d20 5665 6374 6f72 2074 6f20 726f  t = Vector to ro
+00017230: 7461 7465 2074 6f70 2074 6f77 6172 6473  tate top towards
+00017240: 2c20 6166 7465 7220 7370 696e 2e20 2053  , after spin.  S
+00017250: 6565 205b 6f72 6965 6e74 5d28 6174 7461  ee [orient](atta
+00017260: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00017270: 7365 6374 696f 6e2d 6f72 6965 6e74 292e  section-orient).
+00017280: 2020 4465 6661 756c 743a 2060 5550 600a    Default: `UP`.
+00017290: 2f2f 0a2f 2f20 4578 616d 706c 653a 2054  //.// Example: T
+000172a0: 6865 7365 2061 6c6c 2050 726f 6475 6365  hese all Produce
+000172b0: 2074 6865 2053 616d 6520 5475 6265 0a2f   the Same Tube./
+000172c0: 2f20 2020 7475 6265 2868 3d33 302c 206f  /   tube(h=30, o
+000172d0: 723d 3430 2c20 7761 6c6c 3d35 293b 0a2f  r=40, wall=5);./
+000172e0: 2f20 2020 7475 6265 2868 3d33 302c 2069  /   tube(h=30, i
+000172f0: 723d 3335 2c20 7761 6c6c 3d35 293b 0a2f  r=35, wall=5);./
+00017300: 2f20 2020 7475 6265 2868 3d33 302c 206f  /   tube(h=30, o
+00017310: 723d 3430 2c20 6972 3d33 3529 3b0a 2f2f  r=40, ir=35);.//
+00017320: 2020 2074 7562 6528 683d 3330 2c20 6f64     tube(h=30, od
+00017330: 3d38 302c 2069 643d 3730 293b 0a2f 2f20  =80, id=70);.// 
+00017340: 4578 616d 706c 653a 2054 6865 7365 2061  Example: These a
+00017350: 6c6c 2050 726f 6475 6365 2074 6865 2053  ll Produce the S
+00017360: 616d 6520 436f 6e69 6361 6c20 5475 6265  ame Conical Tube
+00017370: 0a2f 2f20 2020 7475 6265 2868 3d33 302c  .//   tube(h=30,
+00017380: 206f 7231 3d34 302c 206f 7232 3d32 352c   or1=40, or2=25,
+00017390: 2077 616c 6c3d 3529 3b0a 2f2f 2020 2074   wall=5);.//   t
+000173a0: 7562 6528 683d 3330 2c20 6972 313d 3335  ube(h=30, ir1=35
+000173b0: 2c20 6f72 323d 3230 2c20 7761 6c6c 3d35  , or2=20, wall=5
+000173c0: 293b 0a2f 2f20 2020 7475 6265 2868 3d33  );.//   tube(h=3
+000173d0: 302c 206f 7231 3d34 302c 206f 7232 3d32  0, or1=40, or2=2
+000173e0: 352c 2069 7231 3d33 352c 2069 7232 3d32  5, ir1=35, ir2=2
+000173f0: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
+00017400: 4369 7263 756c 6172 2057 6564 6765 0a2f  Circular Wedge./
+00017410: 2f20 2020 7475 6265 2868 3d33 302c 206f  /   tube(h=30, o
+00017420: 7231 3d34 302c 206f 7232 3d33 302c 2069  r1=40, or2=30, i
+00017430: 7231 3d32 302c 2069 7232 3d33 3029 3b0a  r1=20, ir2=30);.
+00017440: 2f2f 2045 7861 6d70 6c65 3a20 5374 616e  // Example: Stan
+00017450: 6461 7264 2043 6f6e 6e65 6374 6f72 730a  dard Connectors.
+00017460: 2f2f 2020 2074 7562 6528 683d 3330 2c20  //   tube(h=30, 
+00017470: 6f72 3d34 302c 2077 616c 6c3d 3529 2073  or=40, wall=5) s
+00017480: 686f 775f 616e 6368 6f72 7328 293b 0a0a  how_anchors();..
+00017490: 6675 6e63 7469 6f6e 2074 7562 6528 0a20  function tube(. 
+000174a0: 2020 2020 682c 206f 722c 2069 722c 2063      h, or, ir, c
+000174b0: 656e 7465 722c 0a20 2020 206f 642c 2069  enter,.    od, i
+000174c0: 642c 2077 616c 6c2c 0a20 2020 206f 7231  d, wall,.    or1
+000174d0: 2c20 6f72 322c 206f 6431 2c20 6f64 322c  , or2, od1, od2,
+000174e0: 0a20 2020 2069 7231 2c20 6972 322c 2069  .    ir1, ir2, i
+000174f0: 6431 2c20 6964 322c 0a20 2020 2072 6561  d1, id2,.    rea
+00017500: 6c69 676e 3d66 616c 7365 2c20 6c2c 206c  lign=false, l, l
+00017510: 656e 6774 682c 2068 6569 6768 742c 0a20  ength, height,. 
+00017520: 2020 2061 6e63 686f 722c 2073 7069 6e3d     anchor, spin=
+00017530: 302c 206f 7269 656e 743d 5550 0a29 203d  0, orient=UP.) =
+00017540: 206e 6f5f 6675 6e63 7469 6f6e 2822 7475   no_function("tu
+00017550: 6265 2229 3b0a 0a6d 6f64 756c 6520 7475  be");..module tu
+00017560: 6265 280a 2020 2020 682c 206f 722c 2069  be(.    h, or, i
+00017570: 722c 2063 656e 7465 722c 0a20 2020 206f  r, center,.    o
+00017580: 642c 2069 642c 2077 616c 6c2c 0a20 2020  d, id, wall,.   
+00017590: 206f 7231 2c20 6f72 322c 206f 6431 2c20   or1, or2, od1, 
+000175a0: 6f64 322c 0a20 2020 2069 7231 2c20 6972  od2,.    ir1, ir
+000175b0: 322c 2069 6431 2c20 6964 322c 0a20 2020  2, id1, id2,.   
+000175c0: 2072 6561 6c69 676e 3d66 616c 7365 2c20   realign=false, 
+000175d0: 6c2c 206c 656e 6774 682c 2068 6569 6768  l, length, heigh
+000175e0: 742c 0a20 2020 2061 6e63 686f 722c 2073  t,.    anchor, s
+000175f0: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
+00017600: 0a29 207b 0a20 2020 2068 203d 206f 6e65  .) {.    h = one
+00017610: 5f64 6566 696e 6564 285b 682c 6c2c 6865  _defined([h,l,he
+00017620: 6967 6874 2c6c 656e 6774 685d 2c22 682c  ight,length],"h,
+00017630: 6c2c 6865 6967 6874 2c6c 656e 6774 6822  l,height,length"
+00017640: 2c64 666c 743d 3129 3b0a 2020 2020 6f72  ,dflt=1);.    or
+00017650: 7231 203d 2067 6574 5f72 6164 6975 7328  r1 = get_radius(
+00017660: 7231 3d6f 7231 2c20 723d 6f72 2c20 6431  r1=or1, r=or, d1
+00017670: 3d6f 6431 2c20 643d 6f64 2c20 6466 6c74  =od1, d=od, dflt
+00017680: 3d75 6e64 6566 293b 0a20 2020 206f 7272  =undef);.    orr
+00017690: 3220 3d20 6765 745f 7261 6469 7573 2872  2 = get_radius(r
+000176a0: 313d 6f72 322c 2072 3d6f 722c 2064 313d  1=or2, r=or, d1=
+000176b0: 6f64 322c 2064 3d6f 642c 2064 666c 743d  od2, d=od, dflt=
+000176c0: 756e 6465 6629 3b0a 2020 2020 6972 7231  undef);.    irr1
+000176d0: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
+000176e0: 3d69 7231 2c20 723d 6972 2c20 6431 3d69  =ir1, r=ir, d1=i
+000176f0: 6431 2c20 643d 6964 2c20 6466 6c74 3d75  d1, d=id, dflt=u
+00017700: 6e64 6566 293b 0a20 2020 2069 7272 3220  ndef);.    irr2 
+00017710: 3d20 6765 745f 7261 6469 7573 2872 313d  = get_radius(r1=
+00017720: 6972 322c 2072 3d69 722c 2064 313d 6964  ir2, r=ir, d1=id
+00017730: 322c 2064 3d69 642c 2064 666c 743d 756e  2, d=id, dflt=un
+00017740: 6465 6629 3b0a 2020 2020 7761 6c6c 203d  def);.    wall =
+00017750: 2064 6566 6175 6c74 2877 616c 6c2c 2031   default(wall, 1
+00017760: 293b 0a20 2020 2072 3120 3d20 6465 6661  );.    r1 = defa
+00017770: 756c 7428 6f72 7231 2c20 755f 6164 6428  ult(orr1, u_add(
+00017780: 6972 7231 2c77 616c 6c29 293b 0a20 2020  irr1,wall));.   
+00017790: 2072 3220 3d20 6465 6661 756c 7428 6f72   r2 = default(or
+000177a0: 7232 2c20 755f 6164 6428 6972 7232 2c77  r2, u_add(irr2,w
+000177b0: 616c 6c29 293b 0a20 2020 2069 7231 203d  all));.    ir1 =
+000177c0: 2064 6566 6175 6c74 2869 7272 312c 2075   default(irr1, u
+000177d0: 5f73 7562 286f 7272 312c 7761 6c6c 2929  _sub(orr1,wall))
+000177e0: 3b0a 2020 2020 6972 3220 3d20 6465 6661  ;.    ir2 = defa
+000177f0: 756c 7428 6972 7232 2c20 755f 7375 6228  ult(irr2, u_sub(
+00017800: 6f72 7232 2c77 616c 6c29 293b 0a20 2020  orr2,wall));.   
+00017810: 2063 6865 636b 7320 3d0a 2020 2020 2020   checks =.      
+00017820: 2020 6173 7365 7274 2861 6c6c 5f64 6566    assert(all_def
+00017830: 696e 6564 285b 7231 2c20 7232 2c20 6972  ined([r1, r2, ir
+00017840: 312c 2069 7232 5d29 2c20 224d 7573 7420  1, ir2]), "Must 
+00017850: 7370 6563 6966 7920 7477 6f20 6f66 2069  specify two of i
+00017860: 6e6e 6572 2072 6164 6975 732f 6469 616d  nner radius/diam
+00017870: 2c20 6f75 7465 7220 7261 6469 7573 2f64  , outer radius/d
+00017880: 6961 6d2c 2061 6e64 2077 616c 6c20 7769  iam, and wall wi
+00017890: 6474 682e 2229 0a20 2020 2020 2020 2061  dth.").        a
+000178a0: 7373 6572 7428 6972 3120 3c3d 2072 312c  ssert(ir1 <= r1,
+000178b0: 2022 496e 6e65 7220 7261 6469 7573 2069   "Inner radius i
+000178c0: 7320 6c61 7267 6572 2074 6861 6e20 6f75  s larger than ou
+000178d0: 7465 7220 7261 6469 7573 2e22 290a 2020  ter radius.").  
+000178e0: 2020 2020 2020 6173 7365 7274 2869 7232        assert(ir2
+000178f0: 203c 3d20 7232 2c20 2249 6e6e 6572 2072   <= r2, "Inner r
+00017900: 6164 6975 7320 6973 206c 6172 6765 7220  adius is larger 
+00017910: 7468 616e 206f 7574 6572 2072 6164 6975  than outer radiu
+00017920: 732e 2229 3b0a 2020 2020 7369 6465 7320  s.");.    sides 
+00017930: 3d20 7365 6773 286d 6178 2872 312c 7232  = segs(max(r1,r2
+00017940: 2929 3b0a 2020 2020 616e 6368 6f72 203d  ));.    anchor =
+00017950: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
+00017960: 6f72 2c20 6365 6e74 6572 2c20 424f 542c  or, center, BOT,
+00017970: 2043 454e 5445 5229 3b0a 2020 2020 6174   CENTER);.    at
+00017980: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
+00017990: 7370 696e 2c6f 7269 656e 742c 2072 313d  spin,orient, r1=
+000179a0: 7231 2c20 7232 3d72 322c 206c 3d68 2920  r1, r2=r2, l=h) 
+000179b0: 7b0a 2020 2020 2020 2020 7a72 6f74 2872  {.        zrot(r
+000179c0: 6561 6c69 676e 3f20 3138 302f 7369 6465  ealign? 180/side
+000179d0: 7320 3a20 3029 207b 0a20 2020 2020 2020  s : 0) {.       
+000179e0: 2020 2020 2064 6966 6665 7265 6e63 6528       difference(
+000179f0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00017a00: 2020 2020 6379 6c28 683d 682c 2072 313d      cyl(h=h, r1=
+00017a10: 7231 2c20 7232 3d72 322c 2024 666e 3d73  r1, r2=r2, $fn=s
+00017a20: 6964 6573 2920 6368 696c 6472 656e 2829  ides) children()
+00017a30: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00017a40: 2020 6379 6c28 683d 682b 302e 3035 2c20    cyl(h=h+0.05, 
+00017a50: 7231 3d69 7231 2c20 7232 3d69 7232 293b  r1=ir1, r2=ir2);
+00017a60: 0a20 2020 2020 2020 2020 2020 207d 0a20  .            }. 
+00017a70: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00017a80: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
+00017a90: 207d 0a7d 0a0a 0a0a 2f2f 2046 756e 6374   }.}....// Funct
+00017aa0: 696f 6e26 4d6f 6475 6c65 3a20 7069 655f  ion&Module: pie_
+00017ab0: 736c 6963 6528 290a 2f2f 2053 796e 6f70  slice().// Synop
+00017ac0: 7369 733a 2043 7265 6174 6573 2061 2070  sis: Creates a p
+00017ad0: 6965 2073 6c69 6365 2073 6861 7065 2c20  ie slice shape, 
+00017ae0: 6f72 2072 6574 7572 6e73 2061 2076 6e66  or returns a vnf
+00017af0: 2e0a 2f2f 2054 6f70 6963 733a 2053 6861  ..// Topics: Sha
+00017b00: 7065 7320 2833 4429 2c20 4174 7461 6368  pes (3D), Attach
+00017b10: 6162 6c65 2c20 564e 4620 4765 6e65 7261  able, VNF Genera
+00017b20: 746f 7273 0a2f 2f20 5365 6520 416c 736f  tors.// See Also
+00017b30: 3a20 7765 6467 6528 290a 2f2f 2044 6573  : wedge().// Des
+00017b40: 6372 6970 7469 6f6e 3a0a 2f2f 2020 2043  cription:.//   C
+00017b50: 7265 6174 6573 2061 2070 6965 2073 6c69  reates a pie sli
+00017b60: 6365 2073 6861 7065 2e0a 2f2f 0a2f 2f20  ce shape..//.// 
+00017b70: 5573 6167 653a 2041 7320 4d6f 6475 6c65  Usage: As Module
+00017b80: 0a2f 2f20 2020 7069 655f 736c 6963 6528  .//   pie_slice(
+00017b90: 6c7c 683d 7c68 6569 6768 743d 7c6c 656e  l|h=|height=|len
+00017ba0: 6774 683d 2c20 722c 2061 6e67 2c20 5b63  gth=, r, ang, [c
+00017bb0: 656e 7465 725d 293b 0a2f 2f20 2020 7069  enter]);.//   pi
+00017bc0: 655f 736c 6963 6528 6c7c 683d 7c68 6569  e_slice(l|h=|hei
+00017bd0: 6768 743d 7c6c 656e 6774 683d 2c20 643d  ght=|length=, d=
+00017be0: 2c20 616e 673d 2c20 2e2e 2e29 3b0a 2f2f  , ang=, ...);.//
+00017bf0: 2020 2070 6965 5f73 6c69 6365 286c 7c68     pie_slice(l|h
+00017c00: 3d7c 6865 6967 6874 3d7c 6c65 6e67 7468  =|height=|length
+00017c10: 3d2c 2072 313d 7c64 313d 2c20 7232 3d7c  =, r1=|d1=, r2=|
+00017c20: 6432 3d2c 2061 6e67 3d2c 202e 2e2e 293b  d2=, ang=, ...);
+00017c30: 0a2f 2f20 5573 6167 653a 2041 7320 4675  .// Usage: As Fu
+00017c40: 6e63 7469 6f6e 0a2f 2f20 2020 766e 6620  nction.//   vnf 
+00017c50: 3d20 7069 655f 736c 6963 6528 6c7c 683d  = pie_slice(l|h=
+00017c60: 7c68 6569 6768 743d 7c6c 656e 6774 683d  |height=|length=
+00017c70: 2c20 722c 2061 6e67 2c20 5b63 656e 7465  , r, ang, [cente
+00017c80: 725d 293b 0a2f 2f20 2020 766e 6620 3d20  r]);.//   vnf = 
+00017c90: 7069 655f 736c 6963 6528 6c7c 683d 7c68  pie_slice(l|h=|h
+00017ca0: 6569 6768 743d 7c6c 656e 6774 683d 2c20  eight=|length=, 
+00017cb0: 643d 2c20 616e 673d 2c20 2e2e 2e29 3b0a  d=, ang=, ...);.
+00017cc0: 2f2f 2020 2076 6e66 203d 2070 6965 5f73  //   vnf = pie_s
+00017cd0: 6c69 6365 286c 7c68 3d7c 6865 6967 6874  lice(l|h=|height
+00017ce0: 3d7c 6c65 6e67 7468 3d2c 2072 313d 7c64  =|length=, r1=|d
+00017cf0: 313d 2c20 7232 3d7c 6432 3d2c 2061 6e67  1=, r2=|d2=, ang
+00017d00: 3d2c 202e 2e2e 293b 0a2f 2f20 5573 6167  =, ...);.// Usag
+00017d10: 653a 2041 7474 6163 6869 6e67 2043 6869  e: Attaching Chi
+00017d20: 6c64 7265 6e0a 2f2f 2020 2070 6965 5f73  ldren.//   pie_s
+00017d30: 6c69 6365 286c 7c68 2c20 722c 2061 6e67  lice(l|h, r, ang
+00017d40: 2c20 2e2e 2e29 2041 5454 4143 484d 454e  , ...) ATTACHMEN
+00017d50: 5453 3b0a 2f2f 0a2f 2f20 4172 6775 6d65  TS;.//.// Argume
+00017d60: 6e74 733a 0a2f 2f20 2020 6820 2f20 6c20  nts:.//   h / l 
+00017d70: 2f20 6865 6967 6874 202f 206c 656e 6774  / height / lengt
+00017d80: 6820 3d20 6865 6967 6874 206f 6620 7069  h = height of pi
+00017d90: 6520 736c 6963 652e 0a2f 2f20 2020 7220  e slice..//   r 
+00017da0: 3d20 7261 6469 7573 206f 6620 7069 6520  = radius of pie 
+00017db0: 736c 6963 652e 0a2f 2f20 2020 616e 6720  slice..//   ang 
+00017dc0: 3d20 7069 6520 736c 6963 6520 616e 676c  = pie slice angl
+00017dd0: 6520 696e 2064 6567 7265 6573 2e0a 2f2f  e in degrees..//
+00017de0: 2020 2063 656e 7465 7220 3d20 4966 2067     center = If g
+00017df0: 6976 656e 2c20 6f76 6572 7269 6465 7320  iven, overrides 
+00017e00: 6061 6e63 686f 7260 2e20 2041 2074 7275  `anchor`.  A tru
+00017e10: 6520 7661 6c75 6520 7365 7473 2060 616e  e value sets `an
+00017e20: 6368 6f72 3d43 454e 5445 5260 2c20 6661  chor=CENTER`, fa
+00017e30: 6c73 6520 7365 7473 2060 616e 6368 6f72  lse sets `anchor
+00017e40: 3d55 5060 2e0a 2f2f 2020 202d 2d2d 0a2f  =UP`..//   ---./
+00017e50: 2f20 2020 7231 203d 2062 6f74 746f 6d20  /   r1 = bottom 
+00017e60: 7261 6469 7573 206f 6620 7069 6520 736c  radius of pie sl
+00017e70: 6963 652e 0a2f 2f20 2020 7232 203d 2074  ice..//   r2 = t
+00017e80: 6f70 2072 6164 6975 7320 6f66 2070 6965  op radius of pie
+00017e90: 2073 6c69 6365 2e0a 2f2f 2020 2064 203d   slice..//   d =
+00017ea0: 2064 6961 6d65 7465 7220 6f66 2070 6965   diameter of pie
+00017eb0: 2073 6c69 6365 2e0a 2f2f 2020 2064 3120   slice..//   d1 
+00017ec0: 3d20 626f 7474 6f6d 2064 6961 6d65 7465  = bottom diamete
+00017ed0: 7220 6f66 2070 6965 2073 6c69 6365 2e0a  r of pie slice..
+00017ee0: 2f2f 2020 2064 3220 3d20 746f 7020 6469  //   d2 = top di
+00017ef0: 616d 6574 6572 206f 6620 7069 6520 736c  ameter of pie sl
+00017f00: 6963 652e 0a2f 2f20 2020 616e 6368 6f72  ice..//   anchor
+00017f10: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
+00017f20: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
+00017f30: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
+00017f40: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
+00017f50: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00017f60: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
+00017f70: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
+00017f80: 6043 454e 5445 5260 0a2f 2f20 2020 7370  `CENTER`.//   sp
+00017f90: 696e 203d 2052 6f74 6174 6520 7468 6973  in = Rotate this
+00017fa0: 206d 616e 7920 6465 6772 6565 7320 6172   many degrees ar
+00017fb0: 6f75 6e64 2074 6865 205a 2061 7869 7320  ound the Z axis 
+00017fc0: 6166 7465 7220 616e 6368 6f72 2e20 2053  after anchor.  S
+00017fd0: 6565 205b 7370 696e 5d28 6174 7461 6368  ee [spin](attach
+00017fe0: 6d65 6e74 732e 7363 6164 2373 7562 7365  ments.scad#subse
+00017ff0: 6374 696f 6e2d 7370 696e 292e 2020 4465  ction-spin).  De
+00018000: 6661 756c 743a 2060 3060 0a2f 2f20 2020  fault: `0`.//   
+00018010: 6f72 6965 6e74 203d 2056 6563 746f 7220  orient = Vector 
+00018020: 746f 2072 6f74 6174 6520 746f 7020 746f  to rotate top to
+00018030: 7761 7264 732c 2061 6674 6572 2073 7069  wards, after spi
+00018040: 6e2e 2020 5365 6520 5b6f 7269 656e 745d  n.  See [orient]
+00018050: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00018060: 6423 7375 6273 6563 7469 6f6e 2d6f 7269  d#subsection-ori
+00018070: 656e 7429 2e20 2044 6566 6175 6c74 3a20  ent).  Default: 
+00018080: 6055 5060 0a2f 2f0a 2f2f 2045 7861 6d70  `UP`.//.// Examp
+00018090: 6c65 3a20 4379 6c69 6e64 7269 6361 6c20  le: Cylindrical 
+000180a0: 5069 6520 536c 6963 650a 2f2f 2020 2070  Pie Slice.//   p
+000180b0: 6965 5f73 6c69 6365 2861 6e67 3d34 352c  ie_slice(ang=45,
+000180c0: 206c 3d32 302c 2072 3d33 3029 3b0a 2f2f   l=20, r=30);.//
+000180d0: 2045 7861 6d70 6c65 3a20 436f 6e69 6361   Example: Conica
+000180e0: 6c20 5069 6520 536c 6963 650a 2f2f 2020  l Pie Slice.//  
+000180f0: 2070 6965 5f73 6c69 6365 2861 6e67 3d36   pie_slice(ang=6
+00018100: 302c 206c 3d32 302c 2064 313d 3530 2c20  0, l=20, d1=50, 
+00018110: 6432 3d37 3029 3b0a 2f2f 2045 7861 6d70  d2=70);.// Examp
+00018120: 6c65 3a20 4269 6720 536c 6963 650a 2f2f  le: Big Slice.//
+00018130: 2020 2070 6965 5f73 6c69 6365 2861 6e67     pie_slice(ang
+00018140: 3d33 3030 2c20 6c3d 3230 2c20 6431 3d35  =300, l=20, d1=5
+00018150: 302c 2064 323d 3730 293b 0a2f 2f20 4578  0, d2=70);.// Ex
+00018160: 616d 706c 653a 2047 656e 6572 6174 696e  ample: Generatin
+00018170: 6720 6120 564e 460a 2f2f 2020 2076 6e66  g a VNF.//   vnf
+00018180: 203d 2070 6965 5f73 6c69 6365 2861 6e67   = pie_slice(ang
+00018190: 3d31 3530 2c20 6c3d 3230 2c20 7231 3d33  =150, l=20, r1=3
+000181a0: 302c 2072 323d 3530 293b 0a2f 2f20 2020  0, r2=50);.//   
+000181b0: 766e 665f 706f 6c79 6865 6472 6f6e 2876  vnf_polyhedron(v
+000181c0: 6e66 293b 0a0a 6d6f 6475 6c65 2070 6965  nf);..module pie
+000181d0: 5f73 6c69 6365 280a 2020 2020 682c 2072  _slice(.    h, r
+000181e0: 2c20 616e 673d 3330 2c20 6365 6e74 6572  , ang=30, center
+000181f0: 2c0a 2020 2020 7231 2c20 7232 2c20 642c  ,.    r1, r2, d,
+00018200: 2064 312c 2064 322c 206c 2c20 6c65 6e67   d1, d2, l, leng
+00018210: 7468 2c20 6865 6967 6874 2c0a 2020 2020  th, height,.    
+00018220: 616e 6368 6f72 2c20 7370 696e 3d30 2c20  anchor, spin=0, 
+00018230: 6f72 6965 6e74 3d55 500a 2920 7b0a 2020  orient=UP.) {.  
+00018240: 2020 6c20 3d20 6f6e 655f 6465 6669 6e65    l = one_define
+00018250: 6428 5b6c 2c20 682c 6865 6967 6874 2c6c  d([l, h,height,l
+00018260: 656e 6774 685d 2c22 6c2c 682c 6865 6967  ength],"l,h,heig
+00018270: 6874 2c6c 656e 6774 6822 2c64 666c 743d  ht,length",dflt=
+00018280: 3129 3b0a 2020 2020 7231 203d 2067 6574  1);.    r1 = get
+00018290: 5f72 6164 6975 7328 7231 3d72 312c 2072  _radius(r1=r1, r
+000182a0: 3d72 2c20 6431 3d64 312c 2064 3d64 2c20  =r, d1=d1, d=d, 
+000182b0: 6466 6c74 3d31 3029 3b0a 2020 2020 7232  dflt=10);.    r2
+000182c0: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
+000182d0: 3d72 322c 2072 3d72 2c20 6431 3d64 322c  =r2, r=r, d1=d2,
+000182e0: 2064 3d64 2c20 6466 6c74 3d31 3029 3b0a   d=d, dflt=10);.
+000182f0: 2020 2020 6d61 7864 203d 206d 6178 2872      maxd = max(r
+00018300: 312c 7232 292b 302e 313b 0a20 2020 2061  1,r2)+0.1;.    a
+00018310: 6e63 686f 7220 3d20 6765 745f 616e 6368  nchor = get_anch
+00018320: 6f72 2861 6e63 686f 722c 2063 656e 7465  or(anchor, cente
+00018330: 722c 2042 4f54 2c20 424f 5429 3b0a 2020  r, BOT, BOT);.  
+00018340: 2020 6174 7461 6368 6162 6c65 2861 6e63    attachable(anc
+00018350: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
+00018360: 2072 313d 7231 2c20 7232 3d72 322c 206c   r1=r1, r2=r2, l
+00018370: 3d6c 2920 7b0a 2020 2020 2020 2020 6469  =l) {.        di
+00018380: 6666 6572 656e 6365 2829 207b 0a20 2020  fference() {.   
+00018390: 2020 2020 2020 2020 2063 796c 2872 313d           cyl(r1=
+000183a0: 7231 2c20 7232 3d72 322c 2068 3d6c 293b  r1, r2=r2, h=l);
+000183b0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000183c0: 2861 6e67 3c31 3830 2920 726f 7461 7465  (ang<180) rotate
+000183d0: 2861 6e67 2920 6261 636b 286d 6178 642f  (ang) back(maxd/
+000183e0: 3229 2063 7562 6528 5b32 2a6d 6178 642c  2) cube([2*maxd,
+000183f0: 206d 6178 642c 206c 2b30 2e31 5d2c 2063   maxd, l+0.1], c
+00018400: 656e 7465 723d 7472 7565 293b 0a20 2020  enter=true);.   
+00018410: 2020 2020 2020 2020 2064 6966 6665 7265           differe
+00018420: 6e63 6528 2920 7b0a 2020 2020 2020 2020  nce() {.        
+00018430: 2020 2020 2020 2020 6677 6428 6d61 7864          fwd(maxd
+00018440: 2f32 2920 6375 6265 285b 322a 6d61 7864  /2) cube([2*maxd
+00018450: 2c20 6d61 7864 2c20 6c2b 302e 325d 2c20  , maxd, l+0.2], 
+00018460: 6365 6e74 6572 3d74 7275 6529 3b0a 2020  center=true);.  
+00018470: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00018480: 2028 616e 673e 3138 3029 2072 6f74 6174   (ang>180) rotat
+00018490: 6528 616e 672d 3138 3029 2062 6163 6b28  e(ang-180) back(
+000184a0: 6d61 7864 2f32 2920 6375 6265 285b 322a  maxd/2) cube([2*
+000184b0: 6d61 7864 2c20 6d61 7864 2c20 6c2b 302e  maxd, maxd, l+0.
+000184c0: 315d 2c20 6365 6e74 6572 3d74 7275 6529  1], center=true)
+000184d0: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
+000184e0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+000184f0: 2020 6368 696c 6472 656e 2829 3b0a 2020    children();.  
+00018500: 2020 7d0a 7d0a 0a66 756e 6374 696f 6e20    }.}..function 
+00018510: 7069 655f 736c 6963 6528 0a20 2020 2068  pie_slice(.    h
+00018520: 2c20 722c 2061 6e67 3d33 302c 2063 656e  , r, ang=30, cen
+00018530: 7465 722c 0a20 2020 2072 312c 2072 322c  ter,.    r1, r2,
+00018540: 2064 2c20 6431 2c20 6432 2c20 6c2c 206c   d, d1, d2, l, l
+00018550: 656e 6774 682c 2068 6569 6768 742c 0a20  ength, height,. 
+00018560: 2020 2061 6e63 686f 722c 2073 7069 6e3d     anchor, spin=
+00018570: 302c 206f 7269 656e 743d 5550 0a29 203d  0, orient=UP.) =
+00018580: 206c 6574 280a 2020 2020 2020 2020 616e   let(.        an
+00018590: 6368 6f72 203d 2067 6574 5f61 6e63 686f  chor = get_ancho
+000185a0: 7228 616e 6368 6f72 2c20 6365 6e74 6572  r(anchor, center
+000185b0: 2c20 424f 542c 2042 4f54 292c 0a20 2020  , BOT, BOT),.   
+000185c0: 2020 2020 206c 203d 206f 6e65 5f64 6566       l = one_def
+000185d0: 696e 6564 285b 6c2c 2068 2c68 6569 6768  ined([l, h,heigh
+000185e0: 742c 6c65 6e67 7468 5d2c 226c 2c68 2c68  t,length],"l,h,h
+000185f0: 6569 6768 742c 6c65 6e67 7468 222c 6466  eight,length",df
+00018600: 6c74 3d31 292c 0a20 2020 2020 2020 2072  lt=1),.        r
+00018610: 3120 3d20 6765 745f 7261 6469 7573 2872  1 = get_radius(r
+00018620: 313d 7231 2c20 723d 722c 2064 313d 6431  1=r1, r=r, d1=d1
+00018630: 2c20 643d 642c 2064 666c 743d 3130 292c  , d=d, dflt=10),
+00018640: 0a20 2020 2020 2020 2072 3220 3d20 6765  .        r2 = ge
+00018650: 745f 7261 6469 7573 2872 313d 7232 2c20  t_radius(r1=r2, 
+00018660: 723d 722c 2064 313d 6432 2c20 643d 642c  r=r, d1=d2, d=d,
+00018670: 2064 666c 743d 3130 292c 0a20 2020 2020   dflt=10),.     
+00018680: 2020 206d 6178 6420 3d20 6d61 7828 7231     maxd = max(r1
+00018690: 2c72 3229 2b30 2e31 2c0a 2020 2020 2020  ,r2)+0.1,.      
+000186a0: 2020 7369 6465 7320 3d20 6365 696c 2873    sides = ceil(s
+000186b0: 6567 7328 6d61 7828 7231 2c72 3229 292a  egs(max(r1,r2))*
+000186c0: 616e 672f 3336 3029 2c0a 2020 2020 2020  ang/360),.      
+000186d0: 2020 7374 6570 203d 2061 6e67 2f73 6964    step = ang/sid
+000186e0: 6573 2c0a 2020 2020 2020 2020 766e 6620  es,.        vnf 
+000186f0: 3d20 766e 665f 7665 7274 6578 5f61 7272  = vnf_vertex_arr
+00018700: 6179 280a 2020 2020 2020 2020 2020 2020  ay(.            
+00018710: 706f 696e 7473 3d5b 0a20 2020 2020 2020  points=[.       
+00018720: 2020 2020 2020 2020 2066 6f72 2028 7520           for (u 
+00018730: 3d20 5b30 2c31 5d29 206c 6574 280a 2020  = [0,1]) let(.  
+00018740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018750: 2020 6820 3d20 6c65 7270 282d 6c2f 322c    h = lerp(-l/2,
+00018760: 6c2f 322c 7529 2c0a 2020 2020 2020 2020  l/2,u),.        
+00018770: 2020 2020 2020 2020 2020 2020 7220 3d20              r = 
+00018780: 6c65 7270 2872 312c 7232 2c75 290a 2020  lerp(r1,r2,u).  
+00018790: 2020 2020 2020 2020 2020 2020 2020 2920                ) 
+000187a0: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+000187b0: 2020 2020 2020 666f 7220 2874 6865 7461        for (theta
+000187c0: 203d 205b 303a 7374 6570 3a61 6e67 2b45   = [0:step:ang+E
+000187d0: 5053 494c 4f4e 5d29 0a20 2020 2020 2020  PSILON]).       
+000187e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000187f0: 2063 796c 696e 6472 6963 616c 5f74 6f5f   cylindrical_to_
+00018800: 7879 7a28 722c 7468 6574 612c 6829 2c0a  xyz(r,theta,h),.
+00018810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018820: 2020 2020 5b30 2c30 2c68 5d0a 2020 2020      [0,0,h].    
+00018830: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+00018840: 2020 2020 2020 2020 2020 5d2c 0a20 2020            ],.   
+00018850: 2020 2020 2020 2020 2063 6f6c 5f77 7261           col_wra
+00018860: 703d 7472 7565 2c20 6361 7073 3d74 7275  p=true, caps=tru
+00018870: 652c 2072 6576 6572 7365 3d74 7275 650a  e, reverse=true.
+00018880: 2020 2020 2020 2020 290a 2020 2020 2920          ).    ) 
+00018890: 7265 6f72 6965 6e74 2861 6e63 686f 722c  reorient(anchor,
+000188a0: 7370 696e 2c6f 7269 656e 742c 2072 313d  spin,orient, r1=
+000188b0: 7231 2c20 7232 3d72 322c 206c 3d6c 2c20  r1, r2=r2, l=l, 
+000188c0: 703d 766e 6629 3b0a 0a0a 0a2f 2f20 5365  p=vnf);....// Se
+000188d0: 6374 696f 6e3a 204f 7468 6572 2052 6f75  ction: Other Rou
+000188e0: 6e64 204f 626a 6563 7473 0a0a 0a2f 2f20  nd Objects...// 
+000188f0: 4675 6e63 7469 6f6e 264d 6f64 756c 653a  Function&Module:
+00018900: 2073 7068 6572 6528 290a 2f2f 2053 796e   sphere().// Syn
+00018910: 6f70 7369 733a 2043 7265 6174 6573 2061  opsis: Creates a
+00018920: 6e20 6174 7461 6368 6162 6c65 2073 7068  n attachable sph
+00018930: 6572 6963 616c 206f 626a 6563 742c 206f  erical object, o
+00018940: 7220 7265 7475 726e 7320 6120 766e 662e  r returns a vnf.
+00018950: 0a2f 2f20 546f 7069 6373 3a20 5368 6170  .// Topics: Shap
+00018960: 6573 2028 3344 292c 2041 7474 6163 6861  es (3D), Attacha
+00018970: 626c 652c 2056 4e46 2047 656e 6572 6174  ble, VNF Generat
+00018980: 6f72 730a 2f2f 2053 6565 2041 6c73 6f3a  ors.// See Also:
+00018990: 2073 7068 6572 6f69 6428 290a 2f2f 2055   spheroid().// U
+000189a0: 7361 6765 3a20 4173 204d 6f64 756c 6520  sage: As Module 
+000189b0: 286e 6174 6976 6520 4f70 656e 5343 4144  (native OpenSCAD
+000189c0: 290a 2f2f 2020 2073 7068 6572 6528 727c  ).//   sphere(r|
+000189d0: 643d 293b 0a2f 2f20 5573 6167 653a 2055  d=);.// Usage: U
+000189e0: 7369 6e67 2042 4f53 4c32 2061 7474 6163  sing BOSL2 attac
+000189f0: 686d 656e 7473 2065 7874 656e 7369 6f6e  hments extension
+00018a00: 730a 2f2f 2020 2073 7068 6572 6528 727c  s.//   sphere(r|
+00018a10: 643d 2c20 5b61 6e63 686f 723d 5d2c 205b  d=, [anchor=], [
+00018a20: 7370 696e 3d5d 2c20 5b6f 7269 656e 743d  spin=], [orient=
+00018a30: 5d29 205b 4154 5441 4348 4d45 4e54 535d  ]) [ATTACHMENTS]
+00018a40: 3b0a 2f2f 2055 7361 6765 3a20 4173 2046  ;.// Usage: As F
+00018a50: 756e 6374 696f 6e20 2842 4f53 4c32 2065  unction (BOSL2 e
+00018a60: 7874 656e 7369 6f6e 290a 2f2f 2020 2076  xtension).//   v
+00018a70: 6e66 203d 2073 7068 6572 6528 727c 643d  nf = sphere(r|d=
+00018a80: 2c20 5b61 6e63 686f 723d 5d2c 205b 7370  , [anchor=], [sp
+00018a90: 696e 3d5d 2c20 5b6f 7269 656e 743d 5d29  in=], [orient=])
+00018aa0: 205b 4154 5441 4348 4d45 4e54 535d 3b0a   [ATTACHMENTS];.
+00018ab0: 2f2f 2044 6573 6372 6970 7469 6f6e 3a0a  // Description:.
+00018ac0: 2f2f 2020 2043 7265 6174 6573 2061 2073  //   Creates a s
+00018ad0: 7068 6572 6520 6f62 6a65 6374 2e0a 2f2f  phere object..//
+00018ae0: 2020 2054 6869 7320 6d6f 6475 6c65 2065     This module e
+00018af0: 7874 656e 6473 2074 6865 2062 7569 6c74  xtends the built
+00018b00: 2d69 6e20 6073 7068 6572 6528 2960 206d  -in `sphere()` m
+00018b10: 6f64 756c 6520 6279 2070 726f 7669 6469  odule by providi
+00018b20: 6e67 2073 7570 706f 7274 2066 6f72 2042  ng support for B
+00018b30: 4f53 4c32 2061 6e63 686f 7269 6e67 2061  OSL2 anchoring a
+00018b40: 6e64 2061 7474 6163 686d 656e 7473 2c20  nd attachments, 
+00018b50: 616e 6420 6120 6675 6e63 7469 6f6e 2066  and a function f
+00018b60: 6f72 6d2e 200a 2f2f 2020 2057 6865 6e20  orm. .//   When 
+00018b70: 6361 6c6c 6564 2061 7320 6120 6675 6e63  called as a func
+00018b80: 7469 6f6e 2c20 7265 7475 726e 7320 6120  tion, returns a 
+00018b90: 5b56 4e46 5d28 766e 662e 7363 6164 2920  [VNF](vnf.scad) 
+00018ba0: 666f 7220 6120 7370 6865 7265 2e0a 2f2f  for a sphere..//
+00018bb0: 2041 7267 756d 656e 7473 3a0a 2f2f 2020   Arguments:.//  
+00018bc0: 2072 203d 2052 6164 6975 7320 6f66 2074   r = Radius of t
+00018bd0: 6865 2073 7068 6572 652e 0a2f 2f20 2020  he sphere..//   
+00018be0: 2d2d 2d0a 2f2f 2020 2064 203d 2044 6961  ---.//   d = Dia
+00018bf0: 6d65 7465 7220 6f66 2074 6865 2073 7068  meter of the sph
+00018c00: 6572 652e 0a2f 2f20 2020 616e 6368 6f72  ere..//   anchor
+00018c10: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
+00018c20: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
+00018c30: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
+00018c40: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
+00018c50: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00018c60: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
+00018c70: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
+00018c80: 6043 454e 5445 5260 0a2f 2f20 2020 7370  `CENTER`.//   sp
+00018c90: 696e 203d 2052 6f74 6174 6520 7468 6973  in = Rotate this
+00018ca0: 206d 616e 7920 6465 6772 6565 7320 6172   many degrees ar
+00018cb0: 6f75 6e64 2074 6865 205a 2061 7869 7320  ound the Z axis 
+00018cc0: 6166 7465 7220 616e 6368 6f72 2e20 2053  after anchor.  S
+00018cd0: 6565 205b 7370 696e 5d28 6174 7461 6368  ee [spin](attach
+00018ce0: 6d65 6e74 732e 7363 6164 2373 7562 7365  ments.scad#subse
+00018cf0: 6374 696f 6e2d 7370 696e 292e 2020 4465  ction-spin).  De
+00018d00: 6661 756c 743a 2060 3060 0a2f 2f20 2020  fault: `0`.//   
+00018d10: 6f72 6965 6e74 203d 2056 6563 746f 7220  orient = Vector 
+00018d20: 746f 2072 6f74 6174 6520 746f 7020 746f  to rotate top to
+00018d30: 7761 7264 732c 2061 6674 6572 2073 7069  wards, after spi
+00018d40: 6e2e 2020 5365 6520 5b6f 7269 656e 745d  n.  See [orient]
+00018d50: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00018d60: 6423 7375 6273 6563 7469 6f6e 2d6f 7269  d#subsection-ori
+00018d70: 656e 7429 2e20 2044 6566 6175 6c74 3a20  ent).  Default: 
+00018d80: 6055 5060 0a2f 2f20 4578 616d 706c 653a  `UP`.// Example:
+00018d90: 2042 7920 5261 6469 7573 0a2f 2f20 2020   By Radius.//   
+00018da0: 7370 6865 7265 2872 3d35 3029 3b0a 2f2f  sphere(r=50);.//
+00018db0: 2045 7861 6d70 6c65 3a20 4279 2044 6961   Example: By Dia
+00018dc0: 6d65 7465 720a 2f2f 2020 2073 7068 6572  meter.//   spher
+00018dd0: 6528 643d 3130 3029 3b0a 2f2f 2045 7861  e(d=100);.// Exa
+00018de0: 6d70 6c65 3a20 416e 6368 6f72 696e 670a  mple: Anchoring.
+00018df0: 2f2f 2020 2073 7068 6572 6528 643d 3130  //   sphere(d=10
+00018e00: 302c 2061 6e63 686f 723d 4652 4f4e 5429  0, anchor=FRONT)
+00018e10: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 5370  ;.// Example: Sp
+00018e20: 696e 0a2f 2f20 2020 7370 6865 7265 2864  in.//   sphere(d
+00018e30: 3d31 3030 2c20 616e 6368 6f72 3d46 524f  =100, anchor=FRO
+00018e40: 4e54 2c20 7370 696e 3d34 3529 3b0a 2f2f  NT, spin=45);.//
+00018e50: 2045 7861 6d70 6c65 3a20 4f72 6965 6e74   Example: Orient
+00018e60: 6174 696f 6e0a 2f2f 2020 2073 7068 6572  ation.//   spher
+00018e70: 6528 643d 3130 302c 2061 6e63 686f 723d  e(d=100, anchor=
+00018e80: 4652 4f4e 542c 2073 7069 6e3d 3435 2c20  FRONT, spin=45, 
+00018e90: 6f72 6965 6e74 3d46 5744 293b 0a2f 2f20  orient=FWD);.// 
+00018ea0: 4578 616d 706c 653a 2053 7461 6e64 6172  Example: Standar
+00018eb0: 6420 436f 6e6e 6563 746f 7273 0a2f 2f20  d Connectors.// 
+00018ec0: 2020 7370 6865 7265 2864 3d35 3029 2073    sphere(d=50) s
+00018ed0: 686f 775f 616e 6368 6f72 7328 293b 0a0a  how_anchors();..
+00018ee0: 6d6f 6475 6c65 2073 7068 6572 6528 722c  module sphere(r,
+00018ef0: 2064 2c20 616e 6368 6f72 3d43 454e 5445   d, anchor=CENTE
+00018f00: 522c 2073 7069 6e3d 302c 206f 7269 656e  R, spin=0, orien
+00018f10: 743d 5550 2920 7b0a 2020 2020 7220 3d20  t=UP) {.    r = 
+00018f20: 6765 745f 7261 6469 7573 2872 3d72 2c20  get_radius(r=r, 
+00018f30: 643d 642c 2064 666c 743d 3129 3b0a 2020  d=d, dflt=1);.  
+00018f40: 2020 6174 7461 6368 6162 6c65 2861 6e63    attachable(anc
+00018f50: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
+00018f60: 2072 3d72 2920 7b0a 2020 2020 2020 2020   r=r) {.        
+00018f70: 2020 2020 5f73 7068 6572 6528 723d 7229      _sphere(r=r)
+00018f80: 3b0a 2020 2020 2020 2020 2020 2020 6368  ;.            ch
+00018f90: 696c 6472 656e 2829 3b0a 2020 2020 7d0a  ildren();.    }.
+00018fa0: 7d0a 0a66 756e 6374 696f 6e20 7370 6865  }..function sphe
+00018fb0: 7265 2872 2c20 642c 2061 6e63 686f 723d  re(r, d, anchor=
+00018fc0: 4345 4e54 4552 2c20 7370 696e 3d30 2c20  CENTER, spin=0, 
+00018fd0: 6f72 6965 6e74 3d55 5029 203d 0a20 2020  orient=UP) =.   
+00018fe0: 2073 7068 6572 6f69 6428 723d 722c 2064   spheroid(r=r, d
+00018ff0: 3d64 2c20 7374 796c 653d 226f 7269 6722  =d, style="orig"
+00019000: 2c20 616e 6368 6f72 3d61 6e63 686f 722c  , anchor=anchor,
+00019010: 2073 7069 6e3d 7370 696e 2c20 6f72 6965   spin=spin, orie
+00019020: 6e74 3d6f 7269 656e 7429 3b0a 0a0a 2f2f  nt=orient);...//
+00019030: 2046 756e 6374 696f 6e26 4d6f 6475 6c65   Function&Module
+00019040: 3a20 7370 6865 726f 6964 2829 0a2f 2f20  : spheroid().// 
+00019050: 5379 6e6f 7073 6973 3a20 4372 6561 7465  Synopsis: Create
+00019060: 7320 616e 2061 7474 6163 6861 626c 6520  s an attachable 
+00019070: 7370 6865 7269 6361 6c20 6f62 6a65 6374  spherical object
+00019080: 2077 6974 6820 636f 6e74 726f 6c6c 6162   with controllab
+00019090: 6c65 2074 7269 616e 6775 6c61 7469 6f6e  le triangulation
+000190a0: 2c20 6f72 2072 6574 7572 6e73 2061 2076  , or returns a v
+000190b0: 6e66 2e0a 2f2f 2054 6f70 6963 733a 2053  nf..// Topics: S
+000190c0: 6861 7065 7320 2833 4429 2c20 4174 7461  hapes (3D), Atta
+000190d0: 6368 6162 6c65 2c20 564e 4620 4765 6e65  chable, VNF Gene
+000190e0: 7261 746f 7273 0a2f 2f20 5365 6520 416c  rators.// See Al
+000190f0: 736f 3a20 7370 6865 7265 2829 0a2f 2f20  so: sphere().// 
+00019100: 5573 6167 653a 2054 7970 6963 616c 0a2f  Usage: Typical./
+00019110: 2f20 2020 7370 6865 726f 6964 2872 7c64  /   spheroid(r|d
+00019120: 2c20 5b63 6972 6375 6d5d 2c20 5b73 7479  , [circum], [sty
+00019130: 6c65 5d29 205b 4154 5441 4348 4d45 4e54  le]) [ATTACHMENT
+00019140: 535d 3b0a 2f2f 2055 7361 6765 3a20 4173  S];.// Usage: As
+00019150: 2046 756e 6374 696f 6e0a 2f2f 2020 2076   Function.//   v
+00019160: 6e66 203d 2073 7068 6572 6f69 6428 727c  nf = spheroid(r|
+00019170: 642c 205b 6369 7263 756d 5d2c 205b 7374  d, [circum], [st
+00019180: 796c 655d 293b 0a2f 2f20 4465 7363 7269  yle]);.// Descri
+00019190: 7074 696f 6e3a 0a2f 2f20 2020 4372 6561  ption:.//   Crea
+000191a0: 7465 7320 6120 7370 6865 726f 6964 206f  tes a spheroid o
+000191b0: 626a 6563 742c 2077 6974 6820 7375 7070  bject, with supp
+000191c0: 6f72 7420 666f 7220 616e 6368 6f72 696e  ort for anchorin
+000191d0: 6720 616e 6420 6174 7461 6368 6d65 6e74  g and attachment
+000191e0: 732e 0a2f 2f20 2020 5468 6973 2069 7320  s..//   This is 
+000191f0: 6120 6472 6f70 2d69 6e20 7265 706c 6163  a drop-in replac
+00019200: 656d 656e 7420 666f 7220 7468 6520 6275  ement for the bu
+00019210: 696c 742d 696e 2060 7370 6865 7265 2829  ilt-in `sphere()
+00019220: 6020 6d6f 6475 6c65 2e0a 2f2f 2020 2057  ` module..//   W
+00019230: 6865 6e20 6361 6c6c 6564 2061 7320 6120  hen called as a 
+00019240: 6675 6e63 7469 6f6e 2c20 7265 7475 726e  function, return
+00019250: 7320 6120 5b56 4e46 5d28 766e 662e 7363  s a [VNF](vnf.sc
+00019260: 6164 2920 666f 7220 6120 7370 6865 726f  ad) for a sphero
+00019270: 6964 2e0a 2f2f 2020 2054 6865 2065 7861  id..//   The exa
+00019280: 6374 2074 7269 616e 6775 6c61 7469 6f6e  ct triangulation
+00019290: 206f 6620 7468 6973 2073 7068 6572 6f69   of this spheroi
+000192a0: 6420 6361 6e20 6265 2063 6f6e 7472 6f6c  d can be control
+000192b0: 6c65 6420 7669 6120 7468 6520 6073 7479  led via the `sty
+000192c0: 6c65 3d60 0a2f 2f20 2020 6172 6775 6d65  le=`.//   argume
+000192d0: 6e74 2c20 7768 6572 6520 7468 6520 7661  nt, where the va
+000192e0: 6c75 6520 6361 6e20 6265 206f 6e65 206f  lue can be one o
+000192f0: 6620 6022 6f72 6967 2260 2c20 6022 616c  f `"orig"`, `"al
+00019300: 6967 6e65 6422 602c 2060 2273 7461 6767  igned"`, `"stagg
+00019310: 6572 2260 2c0a 2f2f 2020 2060 226f 6374  er"`,.//   `"oct
+00019320: 6122 602c 206f 7220 6022 6963 6f73 6122  a"`, or `"icosa"
+00019330: 602e 0a2f 2f20 2020 2d20 6073 7479 6c65  `..//   - `style
+00019340: 3d22 6f72 6967 2260 2063 6f6e 7374 7275  ="orig"` constru
+00019350: 6374 7320 6120 7370 6865 7265 2074 6865  cts a sphere the
+00019360: 2073 616d 6520 7761 7920 7468 6174 2074   same way that t
+00019370: 6865 204f 7065 6e53 4341 4420 6073 7068  he OpenSCAD `sph
+00019380: 6572 6528 2960 2062 7569 6c74 2d69 6e20  ere()` built-in 
+00019390: 646f 6573 2e0a 2f2f 2020 202d 2060 7374  does..//   - `st
+000193a0: 796c 653d 2261 6c69 676e 6564 2260 2063  yle="aligned"` c
+000193b0: 6f6e 7374 7275 6374 7320 6120 7370 6865  onstructs a sphe
+000193c0: 7265 2077 6865 7265 2c20 6966 2060 2466  re where, if `$f
+000193d0: 6e60 2069 7320 6120 6d75 6c74 6970 6c65  n` is a multiple
+000193e0: 206f 6620 342c 2069 7420 6861 7320 7665   of 4, it has ve
+000193f0: 7274 6963 6573 2061 7420 616c 6c20 6178  rtices at all ax
+00019400: 6973 206d 6178 696d 6120 616e 6420 6d69  is maxima and mi
+00019410: 6e69 6d61 2e20 2069 653a 2069 7473 2062  nima.  ie: its b
+00019420: 6f75 6e64 696e 6720 626f 7820 6973 2065  ounding box is e
+00019430: 7861 6374 6c79 2074 6865 2073 7068 6572  xactly the spher
+00019440: 6520 6469 616d 6574 6572 2069 6e20 6c65  e diameter in le
+00019450: 6e67 7468 206f 6e20 616c 6c20 7468 7265  ngth on all thre
+00019460: 6520 6178 6573 2e20 2054 6869 7320 6973  e axes.  This is
+00019470: 2074 6865 2064 6566 6175 6c74 2e0a 2f2f   the default..//
+00019480: 2020 202d 2060 7374 796c 653d 2273 7461     - `style="sta
+00019490: 6767 6572 2260 2066 6f72 6d73 2061 2073  gger"` forms a s
+000194a0: 7068 6572 6520 7768 6572 6520 616c 6c20  phere where all 
+000194b0: 6661 6365 7320 6172 6520 7472 6961 6e67  faces are triang
+000194c0: 756c 6172 2c20 6275 7420 7468 6520 746f  ular, but the to
+000194d0: 7020 616e 6420 626f 7474 6f6d 2070 6f6c  p and bottom pol
+000194e0: 6573 2068 6176 6520 7468 696e 6e65 7220  es have thinner 
+000194f0: 7472 6961 6e67 6c65 732e 0a2f 2f20 2020  triangles..//   
+00019500: 2d20 6073 7479 6c65 3d22 6f63 7461 2260  - `style="octa"`
+00019510: 2066 6f72 6d73 2061 2073 7068 6572 6520   forms a sphere 
+00019520: 6279 2073 7562 6469 7669 6469 6e67 2061  by subdividing a
+00019530: 6e20 6f63 7461 6865 6472 6f6e 2e20 2054  n octahedron.  T
+00019540: 6869 7320 6d61 6b65 7320 6d6f 7265 2075  his makes more u
+00019550: 6e69 666f 726d 2066 6163 6573 206f 7665  niform faces ove
+00019560: 7220 7468 6520 656e 7469 7265 7479 206f  r the entirety o
+00019570: 6620 7468 6520 7370 6865 7265 2c20 616e  f the sphere, an
+00019580: 6420 6775 6172 616e 7465 6573 2074 6865  d guarantees the
+00019590: 2062 6f75 6e64 696e 6720 626f 7820 6973   bounding box is
+000195a0: 2074 6865 2073 7068 6572 6520 6469 616d   the sphere diam
+000195b0: 6574 6572 2069 6e20 7369 7a65 206f 6e20  eter in size on 
+000195c0: 616c 6c20 6178 6573 2e20 2054 6865 2065  all axes.  The e
+000195d0: 6666 6563 7469 7665 2060 2466 6e60 2076  ffective `$fn` v
+000195e0: 616c 7565 2069 7320 7175 616e 7469 7a65  alue is quantize
+000195f0: 6420 746f 2061 206d 756c 7469 706c 6520  d to a multiple 
+00019600: 6f66 2034 2e20 2054 6869 7320 6973 2075  of 4.  This is u
+00019610: 7365 6420 696e 2063 6f6e 7374 7275 6374  sed in construct
+00019620: 696e 6720 726f 756e 6465 6420 636f 726e  ing rounded corn
+00019630: 6572 7320 666f 7220 7661 7269 6f75 7320  ers for various 
+00019640: 6f74 6865 7220 7368 6170 6573 2e0a 2f2f  other shapes..//
+00019650: 2020 202d 2060 7374 796c 653d 2269 636f     - `style="ico
+00019660: 7361 2260 2066 6f72 6d73 2061 2073 7068  sa"` forms a sph
+00019670: 6572 6520 6279 2073 7562 6469 7669 6469  ere by subdividi
+00019680: 6e67 2061 6e20 6963 6f73 6168 6564 726f  ng an icosahedro
+00019690: 6e2e 2020 5468 6973 206d 616b 6573 2065  n.  This makes e
+000196a0: 7665 6e20 6d6f 7265 2075 6e69 666f 726d  ven more uniform
+000196b0: 2066 6163 6573 206f 7665 7220 7468 6520   faces over the 
+000196c0: 7768 6f6c 6520 7370 6865 7265 2e20 2054  whole sphere.  T
+000196d0: 6865 2065 6666 6563 7469 7665 2060 2466  he effective `$f
+000196e0: 6e60 2076 616c 7565 2069 7320 7175 616e  n` value is quan
+000196f0: 7469 7a65 6420 746f 2061 206d 756c 7469  tized to a multi
+00019700: 706c 6520 6f66 2035 2e20 2054 6869 7320  ple of 5.  This 
+00019710: 7370 6865 7265 2068 6173 2061 2067 7561  sphere has a gua
+00019720: 7261 6e74 6565 6420 626f 756e 6469 6e67  ranteed bounding
+00019730: 2062 6f78 2077 6865 6e20 6024 666e 6020   box when `$fn` 
+00019740: 6973 2061 206d 756c 7469 706c 6520 6f66  is a multiple of
+00019750: 2031 302e 0a2f 2f20 2020 2e0a 2f2f 2020   10..//   ..//  
+00019760: 2042 7920 6465 6661 756c 7420 7468 6520   By default the 
+00019770: 6f62 6a65 6374 2073 7068 6572 6f69 6428  object spheroid(
+00019780: 2920 7072 6f64 7563 6573 2069 7320 6120  ) produces is a 
+00019790: 706f 6c79 6865 6472 6f6e 2077 686f 7365  polyhedron whose
+000197a0: 2076 6572 7469 6365 7320 616c 6c20 6c69   vertices all li
+000197b0: 6520 6f6e 2074 6865 2072 6571 7565 7374  e on the request
+000197c0: 6564 2073 7068 6572 652e 2020 5468 6973  ed sphere.  This
+000197d0: 206d 6561 6e73 0a2f 2f20 2020 7468 6520   means.//   the 
+000197e0: 6170 7072 6f78 696d 6174 696e 6720 706f  approximating po
+000197f0: 6c79 6865 6472 6f6e 2069 7320 696e 7363  lyhedron is insc
+00019800: 7269 6265 6420 696e 2074 6865 2073 7068  ribed in the sph
+00019810: 6572 652e 0a2f 2f20 2020 5468 6520 6063  ere..//   The `c
+00019820: 6972 6375 6d60 2061 7267 756d 656e 7420  ircum` argument 
+00019830: 7265 7175 6573 7473 2061 2063 6972 6375  requests a circu
+00019840: 6d73 6372 6962 696e 6720 7370 6865 7265  mscribing sphere
+00019850: 2c20 7768 6572 6520 7468 6520 7472 7565  , where the true
+00019860: 2073 7068 6572 6520 6973 0a2f 2f20 2020   sphere is.//   
+00019870: 696e 7369 6465 2061 6e64 2074 616e 6765  inside and tange
+00019880: 6e74 2074 6f20 616c 6c20 7468 6520 6661  nt to all the fa
+00019890: 6365 7320 6f66 2074 6865 2061 7070 726f  ces of the appro
+000198a0: 7869 6d61 7469 6e67 2070 6f6c 7968 6564  ximating polyhed
+000198b0: 726f 6e2e 2020 546f 2070 726f 6475 6365  ron.  To produce
+000198c0: 0a2f 2f20 2020 6120 6369 7263 756d 7363  .//   a circumsc
+000198d0: 7269 6269 6e67 2070 6f6c 7968 6564 726f  ribing polyhedro
+000198e0: 6e2c 2077 6520 7573 6520 7468 6520 6475  n, we use the du
+000198f0: 616c 2070 6f6c 7968 6564 726f 6e20 6f66  al polyhedron of
+00019900: 2074 6865 2062 6173 6963 2066 6f72 6d2e   the basic form.
+00019910: 2020 5468 6520 6475 616c 206f 6620 6120    The dual of a 
+00019920: 706f 6c79 6865 6472 6f6e 2069 730a 2f2f  polyhedron is.//
+00019930: 2020 2061 206e 6577 2070 6f6c 7968 6564     a new polyhed
+00019940: 726f 6e20 7768 6f73 6520 7665 7274 6963  ron whose vertic
+00019950: 6573 2061 7265 206f 6274 6169 6e65 6420  es are obtained 
+00019960: 6672 6f6d 2074 6865 2066 6163 6573 206f  from the faces o
+00019970: 6620 7468 6520 7061 7265 6e74 2070 6f6c  f the parent pol
+00019980: 7968 6564 726f 6e2e 0a2f 2f20 2020 5468  yhedron..//   Th
+00019990: 6520 226f 7269 6722 2061 6e64 2022 616c  e "orig" and "al
+000199a0: 6967 6e22 2066 6f72 6d73 2061 7265 2064  ign" forms are d
+000199b0: 7561 6c73 206f 6620 6561 6368 206f 7468  uals of each oth
+000199c0: 6572 2e20 2049 6620 796f 7520 7265 7175  er.  If you requ
+000199d0: 6573 7420 6120 6369 7263 756d 7363 7269  est a circumscri
+000199e0: 6269 6e67 2070 6f6c 7968 6564 726f 6e20  bing polyhedron 
+000199f0: 696e 0a2f 2f20 2020 7468 6573 6520 7374  in.//   these st
+00019a00: 796c 6573 2074 6865 6e20 7468 6520 706f  yles then the po
+00019a10: 6c79 6865 6472 6f6e 2077 696c 6c20 6c6f  lyhedron will lo
+00019a20: 6f6b 2074 6865 2073 616d 6520 6173 2074  ok the same as t
+00019a30: 6865 2064 6566 6175 6c74 2069 6e73 6372  he default inscr
+00019a40: 6962 696e 6720 666f 726d 2e20 2042 7574  ibing form.  But
+00019a50: 2066 6f72 2074 6865 206f 7468 6572 0a2f   for the other./
+00019a60: 2f20 2020 7374 796c 6573 2c20 7468 6520  /   styles, the 
+00019a70: 6475 616c 7320 6172 6520 636f 6d70 6c65  duals are comple
+00019a80: 7465 6c79 2064 6966 6665 7265 6e74 2066  tely different f
+00019a90: 726f 6d20 7468 6569 7220 7061 7265 6e74  rom their parent
+00019aa0: 732c 2061 6e64 2066 726f 6d20 6561 6368  s, and from each
+00019ab0: 206f 7468 6572 2e20 2047 656e 6572 6174   other.  Generat
+00019ac0: 696f 6e20 6f66 2074 6865 2063 6972 6375  ion of the circu
+00019ad0: 6d73 6372 6962 6564 2076 6572 7369 6f6e  mscribed version
+00019ae0: 7320 2864 7561 6c73 290a 2f2f 2020 2066  s (duals).//   f
+00019af0: 6f72 2022 6f63 7461 2220 616e 6420 2269  or "octa" and "i
+00019b00: 636f 7361 2220 6973 2066 6173 7420 6966  cosa" is fast if
+00019b10: 2079 6f75 2075 7365 2074 6865 206d 6f64   you use the mod
+00019b20: 756c 6520 666f 726d 2062 7574 2063 616e  ule form but can
+00019b30: 2062 6520 7665 7279 2073 6c6f 7720 2873   be very slow (s
+00019b40: 6576 6572 616c 206d 696e 7574 6573 2920  everal minutes) 
+00019b50: 6966 2079 6f75 2075 7365 2074 6865 2066  if you use the f
+00019b60: 756e 6374 696f 6e61 6c0a 2f2f 2020 2066  unctional.//   f
+00019b70: 6f72 6d20 616e 6420 6368 6f6f 7365 2061  orm and choose a
+00019b80: 206c 6172 6765 2024 666e 2076 616c 7565   large $fn value
+00019b90: 2e0a 2f2f 2020 202e 0a2f 2f20 2020 5769  ..//   ..//   Wi
+00019ba0: 7468 2073 7479 6c65 3d22 616c 6967 6e22  th style="align"
+00019bb0: 2c20 7468 6520 6369 7263 756d 7363 7269  , the circumscri
+00019bc0: 6265 6420 7370 6865 7265 2068 6173 2069  bed sphere has i
+00019bd0: 7473 206d 6178 696d 756d 2072 6164 6975  ts maximum radiu
+00019be0: 7320 6f6e 2074 6865 2058 2061 6e64 2059  s on the X and Y
+00019bf0: 2061 7865 730a 2f2f 2020 2062 7574 2069   axes.//   but i
+00019c00: 7320 756e 6465 7273 697a 6564 206f 6e20  s undersized on 
+00019c10: 7468 6520 5a20 6178 6973 2e20 2057 6974  the Z axis.  Wit
+00019c20: 6820 7374 796c 653d 226f 6374 6122 2074  h style="octa" t
+00019c30: 6865 2063 6972 6375 6d73 6372 6962 6564  he circumscribed
+00019c40: 2073 7068 6572 6520 6861 7320 6661 6365   sphere has face
+00019c50: 7320 6174 2065 6163 6820 6178 6973 2c20  s at each axis, 
+00019c60: 736f 0a2f 2f20 2020 7468 6520 7261 6469  so.//   the radi
+00019c70: 7573 206f 6e20 7468 6520 6178 6573 2069  us on the axes i
+00019c80: 7320 6571 7561 6c20 746f 2074 6865 2073  s equal to the s
+00019c90: 7065 6369 6669 6564 2072 6164 6975 732c  pecified radius,
+00019ca0: 2077 6869 6368 2069 7320 7468 6520 2a6d   which is the *m
+00019cb0: 696e 696d 756d 2a20 7261 6469 7573 206f  inimum* radius o
+00019cc0: 6620 7468 6520 6369 7263 756d 7363 7269  f the circumscri
+00019cd0: 6265 6420 7370 6865 7265 2e0a 2f2f 2020  bed sphere..//  
+00019ce0: 2054 6865 2073 616d 6520 7468 696e 6720   The same thing 
+00019cf0: 6973 2074 7275 6520 666f 7220 7374 796c  is true for styl
+00019d00: 653d 2269 636f 7361 2220 7768 656e 2024  e="icosa" when $
+00019d10: 666e 2069 7320 6120 6d75 6c74 6970 6c65  fn is a multiple
+00019d20: 206f 6620 3130 2e20 2054 6869 7320 776f   of 10.  This wo
+00019d30: 756c 6420 656e 6162 6c65 2079 6f75 2074  uld enable you t
+00019d40: 6f20 6372 6561 7465 2073 7068 6572 6963  o create spheric
+00019d50: 616c 0a2f 2f20 2020 686f 6c65 7320 7769  al.//   holes wi
+00019d60: 7468 2067 7561 7261 6e74 6565 6420 6f6e  th guaranteed on
+00019d70: 2d61 7869 7320 6469 6d65 6e73 696f 6e73  -axis dimensions
+00019d80: 2e0a 2f2f 2041 7267 756d 656e 7473 3a0a  ..// Arguments:.
+00019d90: 2f2f 2020 2072 203d 2052 6164 6975 7320  //   r = Radius 
+00019da0: 6f66 2074 6865 2073 7068 6572 6f69 642e  of the spheroid.
+00019db0: 0a2f 2f20 2020 7374 796c 6520 3d20 5468  .//   style = Th
+00019dc0: 6520 7374 796c 6520 6f66 2074 6865 2073  e style of the s
+00019dd0: 7068 6572 6f69 6427 7320 636f 6e73 7472  pheroid's constr
+00019de0: 7563 7469 6f6e 2e20 4f6e 6520 6f66 2022  uction. One of "
+00019df0: 6f72 6967 222c 2022 616c 6967 6e65 6422  orig", "aligned"
+00019e00: 2c20 2273 7461 6767 6572 222c 2022 6f63  , "stagger", "oc
+00019e10: 7461 222c 206f 7220 2269 636f 7361 222e  ta", or "icosa".
+00019e20: 2020 4465 6661 756c 743a 2022 616c 6967    Default: "alig
+00019e30: 6e65 6422 0a2f 2f20 2020 2d2d 2d0a 2f2f  ned".//   ---.//
+00019e40: 2020 2064 203d 2044 6961 6d65 7465 7220     d = Diameter 
+00019e50: 6f66 2074 6865 2073 7068 6572 6f69 642e  of the spheroid.
+00019e60: 0a2f 2f20 2020 6369 7263 756d 203d 2049  .//   circum = I
+00019e70: 6620 7472 7565 2c20 7468 6520 6170 7072  f true, the appr
+00019e80: 6f78 696d 6174 6520 7370 6865 7265 2063  oximate sphere c
+00019e90: 6972 6375 6d73 6372 6962 6573 2074 6865  ircumscribes the
+00019ea0: 2074 7275 6520 7370 6865 7265 206f 6620   true sphere of 
+00019eb0: 7468 6520 7265 7175 6573 7465 6420 7369  the requested si
+00019ec0: 7a65 2e20 204f 7468 6572 7769 7365 2069  ze.  Otherwise i
+00019ed0: 6e73 6372 6962 6573 2e20 204e 6f74 6520  nscribes.  Note 
+00019ee0: 7468 6174 2066 6f72 2073 6f6d 6520 7374  that for some st
+00019ef0: 796c 6573 2c20 7468 6520 6369 7263 756d  yles, the circum
+00019f00: 7363 7269 6265 6420 7370 6865 7265 206c  scribed sphere l
+00019f10: 6f6f 6b73 2064 6966 6665 7265 6e74 2074  ooks different t
+00019f20: 6861 6e20 7468 6520 696e 7363 7269 6265  han the inscribe
+00019f30: 6420 7370 6865 7265 2e20 2044 6566 6175  d sphere.  Defau
+00019f40: 6c74 3a20 6661 6c73 6520 2869 6e73 6372  lt: false (inscr
+00019f50: 6962 6573 290a 2f2f 2020 2061 6e63 686f  ibes).//   ancho
+00019f60: 7220 3d20 5472 616e 736c 6174 6520 736f  r = Translate so
+00019f70: 2061 6e63 686f 7220 706f 696e 7420 6973   anchor point is
+00019f80: 2061 7420 6f72 6967 696e 2028 302c 302c   at origin (0,0,
+00019f90: 3029 2e20 2053 6565 205b 616e 6368 6f72  0).  See [anchor
+00019fa0: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
+00019fb0: 6164 2373 7562 7365 6374 696f 6e2d 616e  ad#subsection-an
+00019fc0: 6368 6f72 292e 2020 4465 6661 756c 743a  chor).  Default:
+00019fd0: 2060 4345 4e54 4552 600a 2f2f 2020 2073   `CENTER`.//   s
+00019fe0: 7069 6e20 3d20 526f 7461 7465 2074 6869  pin = Rotate thi
+00019ff0: 7320 6d61 6e79 2064 6567 7265 6573 2061  s many degrees a
+0001a000: 726f 756e 6420 7468 6520 5a20 6178 6973  round the Z axis
+0001a010: 2061 6674 6572 2061 6e63 686f 722e 2020   after anchor.  
+0001a020: 5365 6520 5b73 7069 6e5d 2861 7474 6163  See [spin](attac
+0001a030: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+0001a040: 6563 7469 6f6e 2d73 7069 6e29 2e20 2044  ection-spin).  D
+0001a050: 6566 6175 6c74 3a20 6030 600a 2f2f 2020  efault: `0`.//  
+0001a060: 206f 7269 656e 7420 3d20 5665 6374 6f72   orient = Vector
+0001a070: 2074 6f20 726f 7461 7465 2074 6f70 2074   to rotate top t
+0001a080: 6f77 6172 6473 2c20 6166 7465 7220 7370  owards, after sp
+0001a090: 696e 2e20 2053 6565 205b 6f72 6965 6e74  in.  See [orient
+0001a0a0: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
+0001a0b0: 6164 2373 7562 7365 6374 696f 6e2d 6f72  ad#subsection-or
+0001a0c0: 6965 6e74 292e 2020 4465 6661 756c 743a  ient).  Default:
+0001a0d0: 2060 5550 600a 2f2f 2045 7861 6d70 6c65   `UP`.// Example
+0001a0e0: 3a20 4279 2052 6164 6975 730a 2f2f 2020  : By Radius.//  
+0001a0f0: 2073 7068 6572 6f69 6428 723d 3530 293b   spheroid(r=50);
+0001a100: 0a2f 2f20 4578 616d 706c 653a 2042 7920  .// Example: By 
+0001a110: 4469 616d 6574 6572 0a2f 2f20 2020 7370  Diameter.//   sp
+0001a120: 6865 726f 6964 2864 3d31 3030 293b 0a2f  heroid(d=100);./
+0001a130: 2f20 4578 616d 706c 653a 2073 7479 6c65  / Example: style
+0001a140: 3d22 6f72 6967 220a 2f2f 2020 2073 7068  ="orig".//   sph
+0001a150: 6572 6f69 6428 643d 3130 302c 2073 7479  eroid(d=100, sty
+0001a160: 6c65 3d22 6f72 6967 222c 2024 666e 3d31  le="orig", $fn=1
+0001a170: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
+0001a180: 7374 796c 653d 2261 6c69 676e 6564 220a  style="aligned".
+0001a190: 2f2f 2020 2073 7068 6572 6f69 6428 643d  //   spheroid(d=
+0001a1a0: 3130 302c 2073 7479 6c65 3d22 616c 6967  100, style="alig
+0001a1b0: 6e65 6422 2c20 2466 6e3d 3130 293b 0a2f  ned", $fn=10);./
+0001a1c0: 2f20 4578 616d 706c 653a 2073 7479 6c65  / Example: style
+0001a1d0: 3d22 7374 6167 6765 7222 0a2f 2f20 2020  ="stagger".//   
+0001a1e0: 7370 6865 726f 6964 2864 3d31 3030 2c20  spheroid(d=100, 
+0001a1f0: 7374 796c 653d 2273 7461 6767 6572 222c  style="stagger",
+0001a200: 2024 666e 3d31 3029 3b0a 2f2f 2045 7861   $fn=10);.// Exa
+0001a210: 6d70 6c65 3a20 7374 796c 653d 2273 7461  mple: style="sta
+0001a220: 6767 6572 2220 7769 7468 2063 6972 6375  gger" with circu
+0001a230: 6d3d 7472 7565 0a2f 2f20 2020 7370 6865  m=true.//   sphe
+0001a240: 726f 6964 2864 3d31 3030 2c20 7374 796c  roid(d=100, styl
+0001a250: 653d 2273 7461 6767 6572 222c 2063 6972  e="stagger", cir
+0001a260: 6375 6d3d 7472 7565 2c20 2466 6e3d 3130  cum=true, $fn=10
+0001a270: 293b 0a2f 2f20 4578 616d 706c 653a 2073  );.// Example: s
+0001a280: 7479 6c65 3d22 6f63 7461 222c 206f 6374  tyle="octa", oct
+0001a290: 6168 6564 7261 6c20 6261 7365 6420 7465  ahedral based te
+0001a2a0: 7373 656c 6174 696f 6e2e 2020 496e 2074  sselation.  In t
+0001a2b0: 6869 7320 7374 796c 652c 2024 666e 2069  his style, $fn i
+0001a2c0: 7320 7175 616e 7469 7a65 6420 746f 2061  s quantized to a
+0001a2d0: 206d 756c 7469 706c 6520 6f66 2034 2e0a   multiple of 4..
+0001a2e0: 2f2f 2020 2073 7068 6572 6f69 6428 643d  //   spheroid(d=
+0001a2f0: 3130 302c 2073 7479 6c65 3d22 6f63 7461  100, style="octa
+0001a300: 222c 2024 666e 3d31 3029 3b0a 2f2f 2045  ", $fn=10);.// E
+0001a310: 7861 6d70 6c65 3a20 7374 796c 653d 226f  xample: style="o
+0001a320: 6374 6122 2c20 7769 7468 2063 6972 6375  cta", with circu
+0001a330: 6d3d 7472 7565 2c20 7072 6f64 7563 6573  m=true, produces
+0001a340: 206d 6f73 746c 7920 7665 7279 2069 7272   mostly very irr
+0001a350: 6567 756c 6172 2068 6578 6167 6f6e 616c  egular hexagonal
+0001a360: 2066 6163 6573 0a2f 2f20 2020 7370 6865   faces.//   sphe
+0001a370: 726f 6964 2864 3d31 3030 2c20 7374 796c  roid(d=100, styl
+0001a380: 653d 226f 6374 6122 2c20 6369 7263 756d  e="octa", circum
+0001a390: 3d74 7275 652c 2024 666e 3d31 3629 3b0a  =true, $fn=16);.
+0001a3a0: 2f2f 2045 7861 6d70 6c65 3a20 7374 796c  // Example: styl
+0001a3b0: 653d 2269 636f 7361 222c 2069 636f 7361  e="icosa", icosa
+0001a3c0: 6865 6472 616c 2062 6173 6564 2074 6573  hedral based tes
+0001a3d0: 7365 6c61 7469 6f6e 2e20 2049 6e20 7468  selation.  In th
+0001a3e0: 6973 2073 7479 6c65 2c20 2466 6e20 6973  is style, $fn is
+0001a3f0: 2071 7561 6e74 697a 6564 2074 6f20 6120   quantized to a 
+0001a400: 6d75 6c74 6970 6c65 206f 6620 352e 0a2f  multiple of 5../
+0001a410: 2f20 2020 7370 6865 726f 6964 2864 3d31  /   spheroid(d=1
+0001a420: 3030 2c20 7374 796c 653d 2269 636f 7361  00, style="icosa
+0001a430: 222c 2024 666e 3d31 3029 3b0a 2f2f 2045  ", $fn=10);.// E
+0001a440: 7861 6d70 6c65 3a20 7374 796c 653d 2269  xample: style="i
+0001a450: 636f 7361 222c 2063 6972 6375 6d3d 7472  cosa", circum=tr
+0001a460: 7565 2e20 2054 6869 7320 7374 796c 6520  ue.  This style 
+0001a470: 6861 7320 6865 7861 676f 6e73 2061 6e64  has hexagons and
+0001a480: 2031 3220 7065 6e74 6167 6f6e 732c 2073   12 pentagons, s
+0001a490: 696d 696c 6172 2074 6f20 2862 7574 206e  imilar to (but n
+0001a4a0: 6f74 2074 6865 2073 616d 6520 6173 2920  ot the same as) 
+0001a4b0: 6120 736f 6363 6572 2062 616c 6c2e 0a2f  a soccer ball../
+0001a4c0: 2f20 2020 7370 6865 726f 6964 2864 3d31  /   spheroid(d=1
+0001a4d0: 3030 2c20 7374 796c 653d 2269 636f 7361  00, style="icosa
+0001a4e0: 222c 2063 6972 6375 6d3d 7472 7565 2c20  ", circum=true, 
+0001a4f0: 2466 6e3d 3130 293b 0a2f 2f20 4578 616d  $fn=10);.// Exam
+0001a500: 706c 653a 2041 6e63 686f 7269 6e67 0a2f  ple: Anchoring./
+0001a510: 2f20 2020 7370 6865 726f 6964 2864 3d31  /   spheroid(d=1
+0001a520: 3030 2c20 616e 6368 6f72 3d46 524f 4e54  00, anchor=FRONT
+0001a530: 293b 0a2f 2f20 4578 616d 706c 653a 2053  );.// Example: S
+0001a540: 7069 6e0a 2f2f 2020 2073 7068 6572 6f69  pin.//   spheroi
+0001a550: 6428 643d 3130 302c 2061 6e63 686f 723d  d(d=100, anchor=
+0001a560: 4652 4f4e 542c 2073 7069 6e3d 3435 293b  FRONT, spin=45);
+0001a570: 0a2f 2f20 4578 616d 706c 653a 204f 7269  .// Example: Ori
+0001a580: 656e 7461 7469 6f6e 0a2f 2f20 2020 7370  entation.//   sp
+0001a590: 6865 726f 6964 2864 3d31 3030 2c20 616e  heroid(d=100, an
+0001a5a0: 6368 6f72 3d46 524f 4e54 2c20 7370 696e  chor=FRONT, spin
+0001a5b0: 3d34 352c 206f 7269 656e 743d 4657 4429  =45, orient=FWD)
+0001a5c0: 3b0a 2f2f 2045 7861 6d70 6c65 3a20 5374  ;.// Example: St
+0001a5d0: 616e 6461 7264 2043 6f6e 6e65 6374 6f72  andard Connector
+0001a5e0: 730a 2f2f 2020 2073 7068 6572 6f69 6428  s.//   spheroid(
+0001a5f0: 643d 3530 2920 7368 6f77 5f61 6e63 686f  d=50) show_ancho
+0001a600: 7273 2829 3b0a 2f2f 2045 7861 6d70 6c65  rs();.// Example
+0001a610: 3a20 4361 6c6c 6564 2061 7320 4675 6e63  : Called as Func
+0001a620: 7469 6f6e 0a2f 2f20 2020 766e 6620 3d20  tion.//   vnf = 
+0001a630: 7370 6865 726f 6964 2864 3d31 3030 2c20  spheroid(d=100, 
+0001a640: 7374 796c 653d 2269 636f 7361 2229 3b0a  style="icosa");.
+0001a650: 2f2f 2020 2076 6e66 5f70 6f6c 7968 6564  //   vnf_polyhed
+0001a660: 726f 6e28 766e 6629 3b0a 2f2f 2045 7861  ron(vnf);.// Exa
+0001a670: 6d70 6c65 3a20 5769 7468 2022 6f72 6967  mple: With "orig
+0001a680: 2220 7468 6520 6369 7263 756d 7363 7269  " the circumscri
+0001a690: 6269 6e67 2073 7068 6572 6520 6861 7320  bing sphere has 
+0001a6a0: 7468 6520 7361 6d65 2066 6f72 6d2e 2020  the same form.  
+0001a6b0: 5468 6520 6772 6565 6e20 7370 6865 7265  The green sphere
+0001a6c0: 2069 7320 6120 7469 6e79 2062 6974 206f   is a tiny bit o
+0001a6d0: 7665 7273 697a 6564 2073 6f20 6974 2070  versized so it p
+0001a6e0: 6f6b 6573 2074 6872 6f75 6768 2074 6865  okes through the
+0001a6f0: 206c 6f77 2070 6f69 6e74 7320 696e 2074   low points in t
+0001a700: 6865 2063 6972 6375 6d73 6372 6962 6564  he circumscribed
+0001a710: 2073 7068 6572 6520 7769 7468 206c 6f77   sphere with low
+0001a720: 2024 666e 2e20 2054 6869 7320 6465 6d6f   $fn.  This demo
+0001a730: 6e73 7472 6174 6573 2074 6861 7420 7468  nstrates that th
+0001a740: 6573 6520 7370 6865 7265 7320 6172 6520  ese spheres are 
+0001a750: 696e 2066 6163 7420 6369 7263 756d 7363  in fact circumsc
+0001a760: 7269 6269 6e67 2e0a 2f2f 2020 2063 6f6c  ribing..//   col
+0001a770: 6f72 2822 6772 6565 6e22 2973 7068 6572  or("green")spher
+0001a780: 6f69 6428 723d 3130 2e30 312c 2024 666e  oid(r=10.01, $fn
+0001a790: 3d32 3536 293b 0a2f 2f20 2020 7370 6865  =256);.//   sphe
+0001a7a0: 726f 6964 2872 3d31 302c 2073 7479 6c65  roid(r=10, style
+0001a7b0: 3d22 6f72 6967 222c 2063 6972 6375 6d3d  ="orig", circum=
+0001a7c0: 7472 7565 2c20 2466 6e3d 3136 293b 0a2f  true, $fn=16);./
+0001a7d0: 2f20 4578 616d 706c 653a 2057 6974 6820  / Example: With 
+0001a7e0: 2261 6c69 676e 6564 2220 7468 6520 7361  "aligned" the sa
+0001a7f0: 6d65 2069 7320 7472 7565 3a20 7468 6520  me is true: the 
+0001a800: 6369 7263 756d 7363 7269 6269 6e67 2073  circumscribing s
+0001a810: 7068 6572 6520 6973 2061 6c73 6f20 616c  phere is also al
+0001a820: 6967 6e65 642c 2069 6620 2466 6e20 6973  igned, if $fn is
+0001a830: 2064 6976 6973 6962 6c65 2062 7920 342e   divisible by 4.
+0001a840: 0a2f 2f20 2020 636f 6c6f 7228 2267 7265  .//   color("gre
+0001a850: 656e 2229 7370 6865 726f 6964 2872 3d31  en")spheroid(r=1
+0001a860: 302e 3031 2c20 2466 6e3d 3235 3629 3b0a  0.01, $fn=256);.
+0001a870: 2f2f 2020 2073 7068 6572 6f69 6428 723d  //   spheroid(r=
+0001a880: 3130 2c20 7374 796c 653d 2261 6c69 676e  10, style="align
+0001a890: 6564 222c 2063 6972 6375 6d3d 7472 7565  ed", circum=true
+0001a8a0: 2c20 2466 6e3d 3136 293b 0a2f 2f20 4578  , $fn=16);.// Ex
+0001a8b0: 616d 706c 653a 2046 6f72 2074 6865 206f  ample: For the o
+0001a8c0: 7468 6572 2073 7479 6c65 732c 2074 6865  ther styles, the
+0001a8d0: 2063 6972 6375 6d73 6372 6962 696e 6720   circumscribing 
+0001a8e0: 7370 6865 7265 2069 7320 6469 6666 6572  sphere is differ
+0001a8f0: 656e 742c 2061 7320 7368 6f77 6e20 6865  ent, as shown he
+0001a900: 7265 2077 6974 6820 2273 7461 6767 6572  re with "stagger
+0001a910: 220a 2f2f 2020 2063 6f6c 6f72 2822 6772  ".//   color("gr
+0001a920: 6565 6e22 2973 7068 6572 6f69 6428 723d  een")spheroid(r=
+0001a930: 3130 2e30 312c 2024 666e 3d32 3536 293b  10.01, $fn=256);
+0001a940: 0a2f 2f20 2020 7370 6865 726f 6964 2872  .//   spheroid(r
+0001a950: 3d31 302c 2073 7479 6c65 3d22 7374 6167  =10, style="stag
+0001a960: 6765 7222 2c20 6369 7263 756d 3d74 7275  ger", circum=tru
+0001a970: 652c 2024 666e 3d31 3629 3b0a 2f2f 2045  e, $fn=16);.// E
+0001a980: 7861 6d70 6c65 3a20 5468 6520 6475 616c  xample: The dual
+0001a990: 206f 6620 226f 6374 6122 2074 6861 7420   of "octa" that 
+0001a9a0: 7072 6f76 6964 6573 2074 6865 2063 6972  provides the cir
+0001a9b0: 6375 6d73 6372 6962 696e 6720 7370 6865  cumscribing sphe
+0001a9c0: 7265 2068 6173 2077 6569 7264 2061 7379  re has weird asy
+0001a9d0: 6d6d 6574 7269 6320 6865 7861 676f 6e61  mmetric hexagona
+0001a9e0: 6c20 6661 6365 733a 0a2f 2f20 2020 636f  l faces:.//   co
+0001a9f0: 6c6f 7228 2267 7265 656e 2229 7370 6865  lor("green")sphe
+0001aa00: 726f 6964 2872 3d31 302e 3031 2c20 2466  roid(r=10.01, $f
+0001aa10: 6e3d 3235 3629 3b0a 2f2f 2020 2073 7068  n=256);.//   sph
+0001aa20: 6572 6f69 6428 723d 3130 2c20 7374 796c  eroid(r=10, styl
+0001aa30: 653d 226f 6374 6122 2c20 6369 7263 756d  e="octa", circum
+0001aa40: 3d74 7275 652c 2024 666e 3d31 3629 3b0a  =true, $fn=16);.
+0001aa50: 2f2f 2045 7861 6d70 6c65 3a20 5468 6520  // Example: The 
+0001aa60: 6475 616c 206f 6620 2269 636f 7361 2220  dual of "icosa" 
+0001aa70: 6665 6174 7572 6573 2068 6578 6167 6f6e  features hexagon
+0001aa80: 7320 616e 6420 616c 7761 7973 2031 3220  s and always 12 
+0001aa90: 7065 6e74 6167 6f6e 733a 0a2f 2f20 2020  pentagons:.//   
+0001aaa0: 636f 6c6f 7228 2267 7265 656e 2229 7370  color("green")sp
+0001aab0: 6865 726f 6964 2872 3d31 302e 3031 2c20  heroid(r=10.01, 
+0001aac0: 2466 6e3d 3235 3629 3b0a 2f2f 2020 2073  $fn=256);.//   s
+0001aad0: 7068 6572 6f69 6428 723d 3130 2c20 7374  pheroid(r=10, st
+0001aae0: 796c 653d 2269 636f 7361 222c 2063 6972  yle="icosa", cir
+0001aaf0: 6375 6d3d 7472 7565 2c20 2466 6e3d 3136  cum=true, $fn=16
+0001ab00: 293b 0a0a 6d6f 6475 6c65 2073 7068 6572  );..module spher
+0001ab10: 6f69 6428 722c 2073 7479 6c65 3d22 616c  oid(r, style="al
+0001ab20: 6967 6e65 6422 2c20 642c 2063 6972 6375  igned", d, circu
+0001ab30: 6d3d 6661 6c73 652c 2064 7561 6c3d 6661  m=false, dual=fa
+0001ab40: 6c73 652c 2061 6e63 686f 723d 4345 4e54  lse, anchor=CENT
+0001ab50: 4552 2c20 7370 696e 3d30 2c20 6f72 6965  ER, spin=0, orie
+0001ab60: 6e74 3d55 5029 0a7b 0a20 2020 2072 203d  nt=UP).{.    r =
+0001ab70: 2067 6574 5f72 6164 6975 7328 723d 722c   get_radius(r=r,
+0001ab80: 2064 3d64 2c20 6466 6c74 3d31 293b 0a20   d=d, dflt=1);. 
+0001ab90: 2020 2073 6964 6573 203d 2073 6567 7328     sides = segs(
+0001aba0: 7229 3b0a 2020 2020 7673 6964 6573 203d  r);.    vsides =
+0001abb0: 2063 6569 6c28 7369 6465 732f 3229 3b0a   ceil(sides/2);.
+0001abc0: 2020 2020 6174 7461 6368 6162 6c65 2861      attachable(a
+0001abd0: 6e63 686f 722c 7370 696e 2c6f 7269 656e  nchor,spin,orien
+0001abe0: 742c 2072 3d72 2920 7b0a 2020 2020 2020  t, r=r) {.      
+0001abf0: 2020 6966 2028 7374 796c 653d 3d22 6f72    if (style=="or
+0001ac00: 6967 2220 2626 2021 6369 7263 756d 2920  ig" && !circum) 
+0001ac10: 7b0a 2020 2020 2020 2020 2020 2020 6d65  {.            me
+0001ac20: 7269 6473 203d 205b 2066 6f72 2028 693d  rids = [ for (i=
+0001ac30: 5b30 3a31 3a76 7369 6465 732d 315d 2920  [0:1:vsides-1]) 
+0001ac40: 3930 2d28 692b 302e 3529 2a31 3830 2f76  90-(i+0.5)*180/v
+0001ac50: 7369 6465 7320 5d3b 0a20 2020 2020 2020  sides ];.       
+0001ac60: 2020 2020 2070 6174 6820 3d20 5b0a 2020       path = [.  
+0001ac70: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+0001ac80: 7428 6120 3d20 6d65 7269 6473 5b30 5d29  t(a = merids[0])
+0001ac90: 205b 302c 2073 696e 2861 295d 2c0a 2020   [0, sin(a)],.  
+0001aca0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+0001acb0: 7220 2861 3d6d 6572 6964 7329 205b 636f  r (a=merids) [co
+0001acc0: 7328 6129 2c20 7369 6e28 6129 5d2c 0a20  s(a), sin(a)],. 
+0001acd0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0001ace0: 6574 2861 203d 206c 6173 7428 6d65 7269  et(a = last(meri
+0001acf0: 6473 2929 205b 302c 2073 696e 2861 295d  ds)) [0, sin(a)]
+0001ad00: 0a20 2020 2020 2020 2020 2020 205d 3b0a  .            ];.
+0001ad10: 2020 2020 2020 2020 2020 2020 7363 616c              scal
+0001ad20: 6528 7229 2072 6f74 6174 6528 3138 3029  e(r) rotate(180)
+0001ad30: 2072 6f74 6174 655f 6578 7472 7564 6528   rotate_extrude(
+0001ad40: 636f 6e76 6578 6974 793d 322c 2466 6e3d  convexity=2,$fn=
+0001ad50: 7369 6465 7329 2070 6f6c 7967 6f6e 2870  sides) polygon(p
+0001ad60: 6174 6829 3b0a 2020 2020 2020 2020 7d0a  ath);.        }.
+0001ad70: 2020 2020 2020 2020 2f2f 2044 6f6e 2774          // Don't
+0001ad80: 206e 6f77 2068 6f77 2074 6f20 636f 6e73   now how to cons
+0001ad90: 7472 7563 7420 6661 6365 7320 666f 7220  truct faces for 
+0001ada0: 7468 6573 6520 6566 6669 6369 656e 746c  these efficientl
+0001adb0: 792c 2073 6f20 7573 6520 6875 6c6c 5f70  y, so use hull_p
+0001adc0: 6f69 6e74 732c 2077 6869 6368 0a20 2020  oints, which.   
+0001add0: 2020 2020 202f 2f20 6973 2076 6572 7920       // is very 
+0001ade0: 6d75 6368 2066 6173 7465 7220 7468 616e  much faster than
+0001adf0: 2075 7369 6e67 2068 756c 6c28 2920 6173   using hull() as
+0001ae00: 2068 6170 7065 6e73 2069 6e20 7468 6520   happens in the 
+0001ae10: 7370 6865 726f 6964 2829 2066 756e 6374  spheroid() funct
+0001ae20: 696f 6e0a 2020 2020 2020 2020 656c 7365  ion.        else
+0001ae30: 2069 6620 2863 6972 6375 6d20 2626 2028   if (circum && (
+0001ae40: 7374 796c 653d 3d22 6f63 7461 2220 7c7c  style=="octa" ||
+0001ae50: 2073 7479 6c65 3d3d 2269 636f 7361 2229   style=="icosa")
+0001ae60: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+0001ae70: 6f72 6967 5f73 7068 6572 6520 3d20 7370  orig_sphere = sp
+0001ae80: 6865 726f 6964 2872 2c73 7479 6c65 2c63  heroid(r,style,c
+0001ae90: 6972 6375 6d3d 6661 6c73 6529 3b0a 2020  ircum=false);.  
+0001aea0: 2020 2020 2020 2020 2020 6475 616c 7665            dualve
+0001aeb0: 7274 203d 205f 6475 616c 5f76 6572 7469  rt = _dual_verti
+0001aec0: 6365 7328 6f72 6967 5f73 7068 6572 6529  ces(orig_sphere)
+0001aed0: 3b0a 2020 2020 2020 2020 2020 2020 6875  ;.            hu
+0001aee0: 6c6c 5f70 6f69 6e74 7328 6475 616c 7665  ll_points(dualve
+0001aef0: 7274 2c66 6173 743d 7472 7565 293b 0a20  rt,fast=true);. 
+0001af00: 2020 2020 2020 207d 2065 6c73 6520 7b0a         } else {.
+0001af10: 2020 2020 2020 2020 2020 2020 766e 6620              vnf 
+0001af20: 3d20 7370 6865 726f 6964 2872 3d72 2c20  = spheroid(r=r, 
+0001af30: 6369 7263 756d 3d63 6972 6375 6d2c 2073  circum=circum, s
+0001af40: 7479 6c65 3d73 7479 6c65 293b 0a20 2020  tyle=style);.   
+0001af50: 2020 2020 2020 2020 2076 6e66 5f70 6f6c           vnf_pol
+0001af60: 7968 6564 726f 6e28 766e 662c 2063 6f6e  yhedron(vnf, con
+0001af70: 7665 7869 7479 3d32 293b 0a20 2020 2020  vexity=2);.     
+0001af80: 2020 207d 0a20 2020 2020 2020 2063 6869     }.        chi
+0001af90: 6c64 7265 6e28 293b 0a20 2020 207d 0a7d  ldren();.    }.}
+0001afa0: 0a0a 0a2f 2f20 7020 6973 2061 206c 6973  ...// p is a lis
+0001afb0: 7420 6f66 2033 2070 6f69 6e74 7320 6465  t of 3 points de
+0001afc0: 6669 6e69 6e67 2061 2074 7269 616e 676c  fining a triangl
+0001afd0: 6520 696e 2061 6e79 2064 696d 656e 7369  e in any dimensi
+0001afe0: 6f6e 2e20 204e 2069 7320 7468 6520 6e75  on.  N is the nu
+0001aff0: 6d62 6572 206f 6620 6578 7472 6120 706f  mber of extra po
+0001b000: 696e 7473 0a2f 2f20 746f 2061 6464 2c20  ints.// to add, 
+0001b010: 736f 206f 7574 7075 7420 7472 6961 6e67  so output triang
+0001b020: 6c65 2068 6173 204e 2b32 2070 6f69 6e74  le has N+2 point
+0001b030: 7320 6f6e 2065 6163 6820 7369 6465 2e0a  s on each side..
+0001b040: 6675 6e63 7469 6f6e 205f 7375 6273 616d  function _subsam
+0001b050: 706c 655f 7472 6961 6e67 6c65 2870 2c4e  ple_triangle(p,N
+0001b060: 2920 3d0a 2020 2020 5b66 6f72 2869 3d5b  ) =.    [for(i=[
+0001b070: 303a 4e2b 315d 2920 5b66 6f72 2028 6a3d  0:N+1]) [for (j=
+0001b080: 5b30 3a4e 2b31 2d69 5d29 2075 6e69 7428  [0:N+1-i]) unit(
+0001b090: 6c65 7270 2870 5b30 5d2c 705b 315d 2c69  lerp(p[0],p[1],i
+0001b0a0: 2f28 4e2b 3129 2920 2b20 2870 5b32 5d2d  /(N+1)) + (p[2]-
+0001b0b0: 705b 305d 292a 6a2f 284e 2b31 2929 5d5d  p[0])*j/(N+1))]]
+0001b0c0: 3b0a 0a0a 2f2f 2049 6e70 7574 2073 686f  ;...// Input sho
+0001b0d0: 756c 6420 6861 7665 206f 6e6c 7920 7472  uld have only tr
+0001b0e0: 6961 6e67 756c 6172 2066 6163 6573 0a66  iangular faces.f
+0001b0f0: 756e 6374 696f 6e20 5f64 7561 6c5f 7665  unction _dual_ve
+0001b100: 7274 6963 6573 2876 6e66 2920 3d0a 2020  rtices(vnf) =.  
+0001b110: 6c65 7428 7665 7274 3d76 6e66 5b30 5d29  let(vert=vnf[0])
+0001b120: 0a20 205b 666f 7228 6661 6365 3d76 6e66  .  [for(face=vnf
+0001b130: 5b31 5d29 0a20 2020 2020 206c 6574 2870  [1]).      let(p
+0001b140: 6c61 6e65 7320 3d20 7365 6c65 6374 2876  lanes = select(v
+0001b150: 6572 742c 6661 6365 2929 0a20 2020 2020  ert,face)).     
+0001b160: 202f 2f6c 696e 6561 725f 736f 6c76 6533   //linear_solve3
+0001b170: 2870 6c61 6e65 732c 205b 666f 7228 703d  (planes, [for(p=
+0001b180: 706c 616e 6573 2920 702a 705d 290a 2020  planes) p*p]).  
+0001b190: 2020 2020 6c69 6e65 6172 5f73 6f6c 7665      linear_solve
+0001b1a0: 3328 7365 6c65 6374 2870 6c61 6e65 732c  3(select(planes,
+0001b1b0: 302c 3229 2c20 5b66 6f72 2869 3d5b 303a  0,2), [for(i=[0:
+0001b1c0: 325d 2920 706c 616e 6573 5b69 5d2a 706c  2]) planes[i]*pl
+0001b1d0: 616e 6573 5b69 5d5d 2920 2f2f 2048 616e  anes[i]]) // Han
+0001b1e0: 646c 6520 6c61 7267 6572 2066 6163 6573  dle larger faces
+0001b1f0: 2c20 6d61 7962 653f 0a20 205d 3b0a 0a0a  , maybe?.  ];...
+0001b200: 6675 6e63 7469 6f6e 2073 7068 6572 6f69  function spheroi
+0001b210: 6428 722c 2073 7479 6c65 3d22 616c 6967  d(r, style="alig
+0001b220: 6e65 6422 2c20 642c 2063 6972 6375 6d3d  ned", d, circum=
+0001b230: 6661 6c73 652c 2061 6e63 686f 723d 4345  false, anchor=CE
+0001b240: 4e54 4552 2c20 7370 696e 3d30 2c20 6f72  NTER, spin=0, or
+0001b250: 6965 6e74 3d55 5029 203d 0a20 2020 206c  ient=UP) =.    l
+0001b260: 6574 280a 2020 2020 2020 2020 7220 3d20  et(.        r = 
+0001b270: 6765 745f 7261 6469 7573 2872 3d72 2c20  get_radius(r=r, 
+0001b280: 643d 642c 2064 666c 743d 3129 2c0a 2020  d=d, dflt=1),.  
+0001b290: 2020 2020 2020 6873 6964 6573 203d 2073        hsides = s
+0001b2a0: 6567 7328 7229 2c0a 2020 2020 2020 2020  egs(r),.        
+0001b2b0: 7673 6964 6573 203d 206d 6178 2832 2c63  vsides = max(2,c
+0001b2c0: 6569 6c28 6873 6964 6573 2f32 2929 2c0a  eil(hsides/2)),.
+0001b2d0: 2020 2020 2020 2020 6f63 7461 5f73 7465          octa_ste
+0001b2e0: 7073 203d 2072 6f75 6e64 286d 6178 2834  ps = round(max(4
+0001b2f0: 2c68 7369 6465 7329 2f34 292c 0a20 2020  ,hsides)/4),.   
+0001b300: 2020 2020 2069 636f 7361 5f73 7465 7073       icosa_steps
+0001b310: 203d 2072 6f75 6e64 286d 6178 2835 2c68   = round(max(5,h
+0001b320: 7369 6465 7329 2f35 292c 0a20 2020 2020  sides)/5),.     
+0001b330: 2020 2073 7461 6767 6572 203d 2073 7479     stagger = sty
+0001b340: 6c65 3d3d 2273 7461 6767 6572 220a 2020  le=="stagger".  
+0001b350: 2020 2029 0a20 2020 2020 6369 7263 756d     ).     circum
+0001b360: 2026 2620 7374 796c 653d 3d22 6f72 6967   && style=="orig
+0001b370: 2220 3f0a 2020 2020 2020 2020 206c 6574  " ?.         let
+0001b380: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001b390: 6f72 6967 5f73 7068 6572 6520 3d20 7370  orig_sphere = sp
+0001b3a0: 6865 726f 6964 2872 2c22 616c 6967 6e65  heroid(r,"aligne
+0001b3b0: 6422 2c63 6972 6375 6d3d 6661 6c73 6529  d",circum=false)
+0001b3c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001b3d0: 6475 616c 7665 7274 203d 207a 726f 7428  dualvert = zrot(
+0001b3e0: 3336 302f 6873 6964 6573 2f32 2c5f 6475  360/hsides/2,_du
+0001b3f0: 616c 5f76 6572 7469 6365 7328 6f72 6967  al_vertices(orig
+0001b400: 5f73 7068 6572 6529 292c 0a20 2020 2020  _sphere)),.     
+0001b410: 2020 2020 2020 2020 2063 756c 6c65 6476           culledv
+0001b420: 6572 7420 3d20 5b0a 2020 2020 2020 2020  ert = [.        
+0001b430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b440: 2020 2020 2020 5b66 6f72 2869 3d5b 303a        [for(i=[0:
+0001b450: 323a 322a 6873 6964 6573 2d31 5d29 2064  2:2*hsides-1]) d
+0001b460: 7561 6c76 6572 745b 695d 5d2c 0a20 2020  ualvert[i]],.   
+0001b470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b480: 2020 2020 2020 2020 2020 2066 6f72 286a             for(j
+0001b490: 3d5b 313a 7673 6964 6573 2d32 5d29 0a20  =[1:vsides-2]). 
+0001b4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b4c0: 5b66 6f72 2869 3d5b 303a 323a 322a 6873  [for(i=[0:2:2*hs
+0001b4d0: 6964 6573 2d31 5d29 2064 7561 6c76 6572  ides-1]) dualver
+0001b4e0: 745b 6a2a 322a 6873 6964 6573 2b69 5d5d  t[j*2*hsides+i]]
+0001b4f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001b500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b510: 5b66 6f72 2869 3d5b 313a 323a 322a 6873  [for(i=[1:2:2*hs
+0001b520: 6964 6573 2d31 5d29 2064 7561 6c76 6572  ides-1]) dualver
+0001b530: 745b 695d 5d0a 2020 2020 2020 2020 2020  t[i]].          
+0001b540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b550: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
+0001b560: 2020 766e 6620 3d20 766e 665f 7665 7274    vnf = vnf_vert
+0001b570: 6578 5f61 7272 6179 2863 756c 6c65 6476  ex_array(culledv
+0001b580: 6572 742c 636f 6c5f 7772 6170 3d74 7275  ert,col_wrap=tru
+0001b590: 652c 6361 7073 3d74 7275 6529 0a20 2020  e,caps=true).   
+0001b5a0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001b5b0: 2020 205b 7265 6f72 6965 6e74 2861 6e63     [reorient(anc
+0001b5c0: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
+0001b5d0: 2072 3d72 2c20 703d 766e 665b 305d 292c   r=r, p=vnf[0]),
+0001b5e0: 2076 6e66 5b31 5d5d 0a20 2020 2020 3a0a   vnf[1]].     :.
+0001b5f0: 2020 2020 2063 6972 6375 6d20 2626 2028       circum && (
+0001b600: 7374 796c 653d 3d22 6f63 7461 2220 7c7c  style=="octa" ||
+0001b610: 2073 7479 6c65 3d3d 2269 636f 7361 2229   style=="icosa")
+0001b620: 203f 0a20 2020 2020 2020 2020 6c65 7428   ?.         let(
+0001b630: 0a20 2020 2020 2020 2020 2020 2020 206f  .              o
+0001b640: 7269 675f 7370 6865 7265 203d 2073 7068  rig_sphere = sph
+0001b650: 6572 6f69 6428 722c 7374 796c 652c 6369  eroid(r,style,ci
+0001b660: 7263 756d 3d66 616c 7365 292c 0a20 2020  rcum=false),.   
+0001b670: 2020 2020 2020 2020 2020 2064 7561 6c76             dualv
+0001b680: 6572 7420 3d20 5f64 7561 6c5f 7665 7274  ert = _dual_vert
+0001b690: 6963 6573 286f 7269 675f 7370 6865 7265  ices(orig_sphere
+0001b6a0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001b6b0: 2066 6163 6573 203d 2068 756c 6c28 6475   faces = hull(du
+0001b6c0: 616c 7665 7274 290a 2020 2020 2020 2020  alvert).        
+0001b6d0: 2029 0a20 2020 2020 2020 2020 5b72 656f   ).         [reo
+0001b6e0: 7269 656e 7428 616e 6368 6f72 2c73 7069  rient(anchor,spi
+0001b6f0: 6e2c 6f72 6965 6e74 2c20 723d 722c 2070  n,orient, r=r, p
+0001b700: 3d64 7561 6c76 6572 7429 2c20 6661 6365  =dualvert), face
+0001b710: 735d 0a20 2020 2020 3a0a 2020 2020 2073  s].     :.     s
+0001b720: 7479 6c65 3d3d 2269 636f 7361 2220 3f20  tyle=="icosa" ? 
+0001b730: 2020 202f 2f20 7375 6264 6976 6964 6520     // subdivide 
+0001b740: 6661 6365 7320 6f66 2061 6e20 6963 6f73  faces of an icos
+0001b750: 6168 6564 726f 6e20 616e 6420 7072 6f6a  ahedron and proj
+0001b760: 6563 7420 7468 656d 206f 6e74 6f20 6120  ect them onto a 
+0001b770: 7370 6865 7265 0a20 2020 2020 2020 2020  sphere.         
+0001b780: 6c65 7428 0a20 2020 2020 2020 2020 2020  let(.           
+0001b790: 2020 4e20 3d20 6963 6f73 615f 7374 6570    N = icosa_step
+0001b7a0: 732d 312c 0a20 2020 2020 2020 2020 2020  s-1,.           
+0001b7b0: 2020 2f2f 2063 6f6e 7374 7275 6374 2061    // construct a
+0001b7c0: 6e20 6963 6f73 6168 6564 726f 6e0a 2020  n icosahedron.  
+0001b7d0: 2020 2020 2020 2020 2020 2069 636f 7665             icove
+0001b7e0: 7274 3d5b 2066 6f72 2869 3d5b 2d31 2c31  rt=[ for(i=[-1,1
+0001b7f0: 5d2c 206a 3d5b 2d31 2c31 5d29 2065 6163  ], j=[-1,1]) eac
+0001b800: 6820 5b5b 302c 692c 6a2a 5048 495d 2c20  h [[0,i,j*PHI], 
+0001b810: 5b69 2c6a 2a50 4849 2c30 5d2c 205b 6a2a  [i,j*PHI,0], [j*
+0001b820: 5048 492c 302c 695d 5d5d 2c0a 2020 2020  PHI,0,i]]],.    
+0001b830: 2020 2020 2020 2020 2069 636f 6661 6365           icoface
+0001b840: 203d 2068 756c 6c28 6963 6f76 6572 7429   = hull(icovert)
+0001b850: 2c0a 2020 2020 2020 2020 2020 2020 202f  ,.             /
+0001b860: 2f20 5375 6273 616d 706c 6520 6661 6365  / Subsample face
+0001b870: 2030 206f 6620 7468 6520 6963 6f73 6168   0 of the icosah
+0001b880: 6564 726f 6e0a 2020 2020 2020 2020 2020  edron.          
+0001b890: 2020 2066 6163 6530 203d 2073 656c 6563     face0 = selec
+0001b8a0: 7428 6963 6f76 6572 742c 6963 6f66 6163  t(icovert,icofac
+0001b8b0: 655b 305d 292c 0a20 2020 2020 2020 2020  e[0]),.         
+0001b8c0: 2020 2020 7361 6d70 6c65 6420 3d20 7220      sampled = r 
+0001b8d0: 2a20 5f73 7562 7361 6d70 6c65 5f74 7269  * _subsample_tri
+0001b8e0: 616e 676c 6528 6661 6365 302c 4e29 2c0a  angle(face0,N),.
+0001b8f0: 2020 2020 2020 2020 2020 2020 2064 6972               dir
+0001b900: 3020 3d20 6d65 616e 2866 6163 6530 292c  0 = mean(face0),
+0001b910: 0a20 2020 2020 2020 2020 2020 2020 706f  .             po
+0001b920: 696e 7430 203d 2066 6163 6530 5b30 5d2d  int0 = face0[0]-
+0001b930: 6469 7230 2c0a 2020 2020 2020 2020 2020  dir0,.          
+0001b940: 2020 202f 2f20 4d61 6b65 2061 2072 6f74     // Make a rot
+0001b950: 6174 6564 2063 6f70 7920 6f66 2074 6865  ated copy of the
+0001b960: 2073 7562 7361 6d70 6c65 6420 7472 6961   subsampled tria
+0001b970: 6e67 6c65 206f 6e20 6561 6368 2069 636f  ngle on each ico
+0001b980: 7361 6865 6472 616c 2066 6163 650a 2020  sahedral face.  
+0001b990: 2020 2020 2020 2020 2020 2074 7269 5f6c             tri_l
+0001b9a0: 6973 7420 3d20 5b73 616d 706c 6564 2c0a  ist = [sampled,.
+0001b9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b9c0: 2020 2020 2020 2020 2066 6f72 2869 3d5b           for(i=[
+0001b9d0: 313a 313a 6c65 6e28 6963 6f66 6163 6529  1:1:len(icoface)
+0001b9e0: 2d31 5d29 0a20 2020 2020 2020 2020 2020  -1]).           
+0001b9f0: 2020 2020 2020 6c65 7428 6661 6365 203d        let(face =
+0001ba00: 2073 656c 6563 7428 6963 6f76 6572 742c   select(icovert,
+0001ba10: 6963 6f66 6163 655b 695d 2929 0a20 2020  icoface[i])).   
+0001ba20: 2020 2020 2020 2020 2020 2020 2020 6170                ap
+0001ba30: 706c 7928 6672 616d 655f 6d61 7028 7a3d  ply(frame_map(z=
+0001ba40: 6d65 616e 2866 6163 6529 2c78 3d66 6163  mean(face),x=fac
+0001ba50: 655b 305d 2d6d 6561 6e28 6661 6365 2929  e[0]-mean(face))
+0001ba60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ba70: 2020 2020 2020 2020 202a 6672 616d 655f           *frame_
+0001ba80: 6d61 7028 7a3d 6469 7230 2c78 3d70 6f69  map(z=dir0,x=poi
+0001ba90: 6e74 302c 7265 7665 7273 653d 7472 7565  nt0,reverse=true
+0001baa0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001bab0: 2020 2020 2020 2020 2020 7361 6d70 6c65            sample
+0001bac0: 6429 5d2c 0a20 2020 2020 2020 2020 2020  d)],.           
+0001bad0: 2020 2f2f 2066 6163 6573 2066 6f72 2074    // faces for t
+0001bae0: 6865 2066 6972 7374 2074 7269 616e 676c  he first triangl
+0001baf0: 6520 6772 6f75 700a 2020 2020 2020 2020  e group.        
+0001bb00: 2020 2020 2066 6163 6573 203d 2076 6e66       faces = vnf
+0001bb10: 5f74 7269 5f61 7272 6179 2874 7269 5f6c  _tri_array(tri_l
+0001bb20: 6973 745b 305d 2c72 6576 6572 7365 3d74  ist[0],reverse=t
+0001bb30: 7275 6529 5b31 5d2c 0a20 2020 2020 2020  rue)[1],.       
+0001bb40: 2020 2020 2020 7369 7a65 203d 2072 6570        size = rep
+0001bb50: 6561 7428 284e 2b32 292a 284e 2b33 292f  eat((N+2)*(N+3)/
+0001bb60: 322c 3329 2c0a 2020 2020 2020 2020 2020  2,3),.          
+0001bb70: 2020 202f 2f20 4578 7061 6e64 2074 6f20     // Expand to 
+0001bb80: 6675 6c6c 2066 6163 6520 6c69 7374 0a20  full face list. 
+0001bb90: 2020 2020 2020 2020 2020 2020 6675 6c6c              full
+0001bba0: 6661 6365 7320 3d20 5b66 6f72 2869 3d69  faces = [for(i=i
+0001bbb0: 6478 2874 7269 5f6c 6973 7429 2920 6561  dx(tri_list)) ea
+0001bbc0: 6368 205b 666f 7228 663d 6661 6365 7329  ch [for(f=faces)
+0001bbd0: 2066 2b69 2a73 697a 655d 5d2c 0a20 2020   f+i*size]],.   
+0001bbe0: 2020 2020 2020 2020 2020 6675 6c6c 7665            fullve
+0001bbf0: 7274 203d 2066 6c61 7474 656e 2866 6c61  rt = flatten(fla
+0001bc00: 7474 656e 2874 7269 5f6c 6973 7429 2920  tten(tri_list)) 
+0001bc10: 2020 202f 2f20 656c 696d 696e 6174 6520     // eliminate 
+0001bc20: 7472 6961 6e67 6c65 2073 7472 7563 7475  triangle structu
+0001bc30: 7265 0a20 2020 2020 2020 2020 290a 2020  re.         ).  
+0001bc40: 2020 2020 2020 205b 7265 6f72 6965 6e74         [reorient
+0001bc50: 2861 6e63 686f 722c 7370 696e 2c6f 7269  (anchor,spin,ori
+0001bc60: 656e 742c 2072 3d72 2c20 703d 6675 6c6c  ent, r=r, p=full
+0001bc70: 7665 7274 292c 2066 756c 6c66 6163 6573  vert), fullfaces
+0001bc80: 5d0a 2020 2020 203a 0a20 2020 2020 6c65  ].     :.     le
+0001bc90: 7428 0a20 2020 2020 2020 2076 6572 7473  t(.        verts
+0001bca0: 203d 2063 6972 6375 6d20 2626 2073 7479   = circum && sty
+0001bcb0: 6c65 3d3d 2273 7461 6767 6572 2220 3f20  le=="stagger" ? 
+0001bcc0: 5f64 7561 6c5f 7665 7274 6963 6573 2873  _dual_vertices(s
+0001bcd0: 7068 6572 6f69 6428 722c 7374 796c 652c  pheroid(r,style,
+0001bce0: 6369 7263 756d 3d66 616c 7365 2929 0a20  circum=false)). 
+0001bcf0: 2020 2020 2020 2020 2020 2020 203a 2063               : c
+0001bd00: 6972 6375 6d20 2626 2073 7479 6c65 3d3d  ircum && style==
+0001bd10: 2261 6c69 676e 6564 2220 3f0a 2020 2020  "aligned" ?.    
+0001bd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bd30: 206c 6574 280a 2020 2020 2020 2020 2020   let(.          
+0001bd40: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+0001bd50: 7269 675f 7370 6865 7265 203d 2073 7068  rig_sphere = sph
+0001bd60: 6572 6f69 6428 722c 226f 7269 6722 2c63  eroid(r,"orig",c
+0001bd70: 6972 6375 6d3d 6661 6c73 6529 2c0a 2020  ircum=false),.  
+0001bd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bd90: 2020 2020 2020 2064 7561 6c76 6572 7420         dualvert 
+0001bda0: 3d20 5f64 7561 6c5f 7665 7274 6963 6573  = _dual_vertices
+0001bdb0: 286f 7269 675f 7370 6865 7265 292c 0a20  (orig_sphere),. 
+0001bdc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bdd0: 2020 2020 2020 2020 6375 6c6c 6564 7665          culledve
+0001bde0: 7274 203d 207a 726f 7428 3336 302f 6873  rt = zrot(360/hs
+0001bdf0: 6964 6573 2f32 2c0a 2020 2020 2020 2020  ides/2,.        
+0001be00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001be10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001be20: 2020 205b 6475 616c 7665 7274 5b30 5d2c     [dualvert[0],
+0001be30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001be40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001be50: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0001be60: 2869 3d5b 323a 323a 6c65 6e28 6475 616c  (i=[2:2:len(dual
+0001be70: 7665 7274 292d 315d 2920 6475 616c 7665  vert)-1]) dualve
+0001be80: 7274 5b69 5d2c 0a20 2020 2020 2020 2020  rt[i],.         
+0001be90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001beb0: 2020 2064 7561 6c76 6572 745b 315d 5d29     dualvert[1]])
+0001bec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001bed0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001bee0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0001bef0: 756c 6c65 6476 6572 740a 2020 2020 2020  ulledvert.      
+0001bf00: 2020 2020 2020 2020 3a20 7374 796c 653d          : style=
+0001bf10: 3d22 6f72 6967 223f 205b 0a20 2020 2020  ="orig"? [.     
+0001bf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bf30: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0001bf40: 2869 3d5b 303a 313a 7673 6964 6573 2d31  (i=[0:1:vsides-1
+0001bf50: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0001bf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bf70: 2020 2020 2020 2020 6c65 7428 7068 6920          let(phi 
+0001bf80: 3d20 2869 2b30 2e35 292a 3138 302f 2876  = (i+0.5)*180/(v
+0001bf90: 7369 6465 7329 290a 2020 2020 2020 2020  sides)).        
+0001bfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bfb0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0001bfc0: 2028 6a3d 5b30 3a31 3a68 7369 6465 732d   (j=[0:1:hsides-
+0001bfd0: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
+0001bfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bff0: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0001c000: 2874 6865 7461 203d 206a 2a33 3630 2f68  (theta = j*360/h
+0001c010: 7369 6465 7329 0a20 2020 2020 2020 2020  sides).         
+0001c020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c040: 7370 6865 7269 6361 6c5f 746f 5f78 797a  spherical_to_xyz
+0001c050: 2872 2c20 7468 6574 612c 2070 6869 292c  (r, theta, phi),
+0001c060: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c080: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0001c090: 3a20 7374 796c 653d 3d22 616c 6967 6e65  : style=="aligne
+0001c0a0: 6422 207c 7c20 7374 796c 653d 3d22 7374  d" || style=="st
+0001c0b0: 6167 6765 7222 3f0a 2020 2020 2020 2020  agger"?.        
+0001c0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c0d0: 205b 2073 7068 6572 6963 616c 5f74 6f5f   [ spherical_to_
+0001c0e0: 7879 7a28 722c 2030 2c20 3029 2c0a 2020  xyz(r, 0, 0),.  
+0001c0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c100: 2020 2020 2020 2020 2066 6f72 2028 693d           for (i=
+0001c110: 5b31 3a31 3a76 7369 6465 732d 315d 290a  [1:1:vsides-1]).
+0001c120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c130: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0001c140: 6574 2870 6869 203d 2069 2a31 3830 2f76  et(phi = i*180/v
+0001c150: 7369 6465 7329 0a20 2020 2020 2020 2020  sides).         
 0001c160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c170: 2020 2068 616c 6967 6e3d 6861 2c20 7661     halign=ha, va
-0001c180: 6c69 676e 3d76 612c 2073 7061 6369 6e67  lign=va, spacing
-0001c190: 3d73 7061 6369 6e67 2c0a 2020 2020 2020  =spacing,.      
+0001c170: 2020 2020 2020 666f 7220 286a 3d5b 303a        for (j=[0:
+0001c180: 313a 6873 6964 6573 2d31 5d29 0a20 2020  1:hsides-1]).   
+0001c190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0001c1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c1b0: 2020 6469 7265 6374 696f 6e3d 6469 7265    direction=dire
-0001c1c0: 6374 696f 6e2c 206c 616e 6775 6167 653d  ction, language=
-0001c1d0: 6c61 6e67 7561 6765 2c0a 2020 2020 2020  language,.      
-0001c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c1f0: 2020 7363 7269 7074 3d73 6372 6970 740a    script=script.
-0001c200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c210: 2020 2020 293b 0a20 2020 2020 2020 2020      );.         
-0001c220: 2020 207d 0a20 2020 2020 2020 207d 0a20     }.        }. 
-0001c230: 2020 207d 0a7d 0a0a 0a2f 2f20 5468 6973     }.}...// This
-0001c240: 2063 6f75 6c64 2062 6520 7265 706c 6163   could be replac
-0001c250: 6564 2077 6974 6820 5f63 7574 5f74 6f5f  ed with _cut_to_
-0001c260: 7365 675f 755f 666f 726d 0a66 756e 6374  seg_u_form.funct
-0001c270: 696f 6e20 5f63 7574 5f69 6e74 6572 7028  ion _cut_interp(
-0001c280: 7061 7468 6375 742c 2070 6174 682c 2064  pathcut, path, d
-0001c290: 6174 6129 203d 0a20 205b 666f 7228 656e  ata) =.  [for(en
-0001c2a0: 7472 793d 7061 7468 6375 7429 0a20 2020  try=pathcut).   
-0001c2b0: 206c 6574 280a 2020 2020 2020 2061 203d   let(.       a =
-0001c2c0: 2070 6174 685b 656e 7472 795b 315d 2d31   path[entry[1]-1
-0001c2d0: 5d2c 0a20 2020 2020 2020 2062 203d 2070  ],.        b = p
-0001c2e0: 6174 685b 656e 7472 795b 315d 5d2c 0a20  ath[entry[1]],. 
-0001c2f0: 2020 2020 2020 2063 203d 2065 6e74 7279         c = entry
-0001c300: 5b30 5d2c 0a20 2020 2020 2020 2069 203d  [0],.        i =
-0001c310: 206d 6178 5f69 6e64 6578 2876 5f61 6273   max_index(v_abs
-0001c320: 2862 2d61 2929 2c0a 2020 2020 2020 2020  (b-a)),.        
-0001c330: 6661 6374 6f72 203d 2028 635b 695d 2d61  factor = (c[i]-a
-0001c340: 5b69 5d29 2f28 625b 695d 2d61 5b69 5d29  [i])/(b[i]-a[i])
-0001c350: 0a20 2020 2029 0a20 2020 2028 312d 6661  .    ).    (1-fa
-0001c360: 6374 6f72 292a 6461 7461 5b65 6e74 7279  ctor)*data[entry
-0001c370: 5b31 5d2d 315d 2b20 6661 6374 6f72 202a  [1]-1]+ factor *
-0001c380: 2064 6174 615b 656e 7472 795b 315d 5d0a   data[entry[1]].
-0001c390: 2020 5d3b 0a0a 0a2f 2f20 4d6f 6475 6c65    ];...// Module
-0001c3a0: 3a20 7061 7468 5f74 6578 7428 290a 2f2f  : path_text().//
-0001c3b0: 2055 7361 6765 3a0a 2f2f 2020 2070 6174   Usage:.//   pat
-0001c3c0: 685f 7465 7874 2870 6174 682c 2074 6578  h_text(path, tex
-0001c3d0: 742c 205b 7369 7a65 5d2c 205b 7468 6963  t, [size], [thic
-0001c3e0: 6b6e 6573 735d 2c20 5b66 6f6e 745d 2c20  kness], [font], 
-0001c3f0: 5b6c 6574 7465 7273 697a 655d 2c20 5b6f  [lettersize], [o
-0001c400: 6666 7365 745d 2c20 5b72 6576 6572 7365  ffset], [reverse
-0001c410: 5d2c 205b 6e6f 726d 616c 5d2c 205b 746f  ], [normal], [to
-0001c420: 705d 2c20 5b74 6578 746d 6574 7269 6373  p], [textmetrics
-0001c430: 5d2c 205b 6b65 726e 5d29 0a2f 2f20 4465  ], [kern]).// De
-0001c440: 7363 7269 7074 696f 6e3a 0a2f 2f20 2020  scription:.//   
-0001c450: 506c 6163 6520 7468 6520 7465 7874 206c  Place the text l
-0001c460: 6574 7465 7220 6279 206c 6574 7465 7220  etter by letter 
-0001c470: 6f6e 746f 2074 6865 2073 7065 6369 6669  onto the specifi
-0001c480: 6564 2070 6174 6820 7573 696e 6720 7465  ed path using te
-0001c490: 7874 6d65 7472 6963 7320 2869 6620 6176  xtmetrics (if av
-0001c4a0: 6169 6c61 626c 6520 616e 6420 7265 7175  ailable and requ
-0001c4b0: 6573 7465 6429 0a2f 2f20 2020 6f72 2075  ested).//   or u
-0001c4c0: 7365 7220 7370 6563 6966 6965 6420 6c65  ser specified le
-0001c4d0: 7474 6572 2073 7061 6369 6e67 2e20 2054  tter spacing.  T
-0001c4e0: 6865 2070 6174 6820 6361 6e20 6265 2032  he path can be 2
-0001c4f0: 4420 6f72 2033 442e 2020 496e 2032 4420  D or 3D.  In 2D 
-0001c500: 7468 6520 7465 7874 2061 7070 6561 7273  the text appears
-0001c510: 2061 6c6f 6e67 2074 6865 2070 6174 6820   along the path 
-0001c520: 7769 7468 206c 6574 7465 7273 2075 7072  with letters upr
-0001c530: 6967 6874 0a2f 2f20 2020 6173 2064 6574  ight.//   as det
-0001c540: 6572 6d69 6e65 6420 6279 2074 6865 2070  ermined by the p
-0001c550: 6174 6820 6469 7265 6374 696f 6e2e 2020  ath direction.  
-0001c560: 496e 2033 4420 6279 2064 6566 6175 6c74  In 3D by default
-0001c570: 206c 6574 7465 7273 2061 7265 2070 6f73   letters are pos
-0001c580: 6974 696f 6e65 6420 6f6e 2074 6865 2074  itioned on the t
-0001c590: 616e 6765 6e74 206c 696e 6520 746f 2074  angent line to t
-0001c5a0: 6865 2070 6174 6820 7769 7468 2074 6865  he path with the
-0001c5b0: 2070 6174 6820 6e6f 726d 616c 0a2f 2f20   path normal.// 
-0001c5c0: 2020 706f 696e 7469 6e67 2074 6f77 6172    pointing towar
-0001c5d0: 6420 7468 6520 7265 6164 6572 2e20 2054  d the reader.  T
-0001c5e0: 6865 2070 6174 6820 6e6f 726d 616c 2070  he path normal p
-0001c5f0: 6f69 6e74 7320 6177 6179 2066 726f 6d20  oints away from 
-0001c600: 7468 6520 6365 6e74 6572 206f 6620 6375  the center of cu
-0001c610: 7276 6174 7572 6520 2874 6865 206f 7070  rvature (the opp
-0001c620: 6f73 6974 6520 6f66 2074 6865 206e 6f72  osite of the nor
-0001c630: 6d61 6c20 7072 6f64 7563 6564 0a2f 2f20  mal produced.// 
-0001c640: 2020 6279 2070 6174 685f 6e6f 726d 616c    by path_normal
-0001c650: 7328 2929 2e20 204e 6f74 6520 7468 6174  s()).  Note that
-0001c660: 2074 6869 7320 6d65 616e 7320 7468 6174   this means that
-0001c670: 2069 6620 7468 6520 6365 6e74 6572 206f   if the center o
-0001c680: 6620 6375 7276 6174 7572 6520 7377 6974  f curvature swit
-0001c690: 6368 6573 2073 6964 6573 2074 6865 2074  ches sides the t
-0001c6a0: 6578 7420 7769 6c6c 2066 6c69 7020 7570  ext will flip up
-0001c6b0: 7369 6465 2064 6f77 6e2e 0a2f 2f20 2020  side down..//   
-0001c6c0: 4966 2079 6f75 2077 616e 7420 7465 7874  If you want text
-0001c6d0: 206f 6e20 7375 6368 2061 2070 6174 6820   on such a path 
-0001c6e0: 796f 7520 6d75 7374 2073 7570 706c 7920  you must supply 
-0001c6f0: 796f 7572 206f 776e 206e 6f72 6d61 6c20  your own normal 
-0001c700: 6f72 2074 6f70 2076 6563 746f 722e 200a  or top vector. .
-0001c710: 2f2f 2020 202e 200a 2f2f 2020 2054 6578  //   . .//   Tex
-0001c720: 7420 6170 7065 6172 7320 7374 6172 7469  t appears starti
-0001c730: 6e67 2061 7420 7468 6520 6265 6769 6e6e  ng at the beginn
-0001c740: 696e 6720 6f66 2074 6865 2070 6174 682c  ing of the path,
-0001c750: 2073 6f20 6966 2074 6865 2033 4420 7061   so if the 3D pa
-0001c760: 7468 206d 6f76 6573 2072 6967 6874 2074  th moves right t
-0001c770: 6f20 6c65 6674 0a2f 2f20 2020 7468 656e  o left.//   then
-0001c780: 2061 206c 6566 742d 746f 2d72 6967 6874   a left-to-right
-0001c790: 2072 6561 6469 6e67 206c 616e 6775 6167   reading languag
-0001c7a0: 6520 7769 6c6c 2064 6973 706c 6179 2069  e will display i
-0001c7b0: 6e20 7468 6520 7772 6f6e 6720 6f72 6465  n the wrong orde
-0001c7c0: 722e 2028 466f 7220 6120 3244 2070 6174  r. (For a 2D pat
-0001c7d0: 6820 7465 7874 2077 696c 6c20 6170 7065  h text will appe
-0001c7e0: 6172 2075 7073 6964 6520 646f 776e 2e29  ar upside down.)
-0001c7f0: 0a2f 2f20 2020 5468 6520 7465 7874 2066  .//   The text f
-0001c800: 6f72 2061 2033 4420 7061 7468 2061 7070  or a 3D path app
-0001c810: 6561 7273 2070 6f73 6974 696f 6e65 6420  ears positioned 
-0001c820: 746f 2062 6520 7265 6164 2066 726f 6d20  to be read from 
-0001c830: 226f 7574 7369 6465 2220 6f66 2074 6865  "outside" of the
-0001c840: 2063 7572 7665 2028 6672 6f6d 2061 2070   curve (from a p
-0001c850: 6f69 6e74 206f 6e20 7468 6520 6f74 6865  oint on the othe
-0001c860: 7220 7369 6465 206f 6620 7468 650a 2f2f  r side of the.//
-0001c870: 2020 2063 7572 7665 2066 726f 6d20 7468     curve from th
-0001c880: 6520 6365 6e74 6572 206f 6620 6375 7276  e center of curv
-0001c890: 6174 7572 6529 2e20 2049 6620 796f 7520  ature).  If you 
-0001c8a0: 6e65 6564 2074 6865 2074 6578 7420 746f  need the text to
-0001c8b0: 2072 6561 6420 7072 6f70 6572 6c79 2066   read properly f
-0001c8c0: 726f 6d20 7468 6520 696e 7369 6465 2c20  rom the inside, 
-0001c8d0: 796f 7520 6361 6e20 7365 7420 7265 7665  you can set reve
-0001c8e0: 7273 6520 746f 0a2f 2f20 2020 7472 7565  rse to.//   true
-0001c8f0: 2074 6f20 666c 6970 2074 6865 2074 6578   to flip the tex
-0001c900: 742c 206f 7220 7375 7070 6c79 2079 6f75  t, or supply you
-0001c910: 7220 6f77 6e20 6e6f 726d 616c 2e20 200a  r own normal.  .
-0001c920: 2f2f 2020 202e 0a2f 2f20 2020 4966 2079  //   ..//   If y
-0001c930: 6f75 2064 6f20 6e6f 7420 6861 7665 2074  ou do not have t
-0001c940: 6865 2065 7870 6572 696d 656e 7461 6c20  he experimental 
-0001c950: 7465 7874 6d65 7472 6963 7320 6665 6174  textmetrics feat
-0001c960: 7572 6520 656e 6162 6c65 6420 7468 656e  ure enabled then
-0001c970: 2079 6f75 206d 7573 7420 7370 6563 6966   you must specif
-0001c980: 7920 7468 6520 7370 6163 6520 666f 7220  y the space for 
-0001c990: 7468 6520 6c65 7474 6572 730a 2f2f 2020  the letters.//  
-0001c9a0: 2075 7369 6e67 206c 6574 7465 7273 697a   using lettersiz
-0001c9b0: 652c 2077 6869 6368 2063 616e 2062 6520  e, which can be 
-0001c9c0: 6120 7363 616c 6172 206f 7220 6172 7261  a scalar or arra
-0001c9d0: 792e 2020 596f 7520 7769 6c6c 2068 6176  y.  You will hav
-0001c9e0: 6520 7468 6520 6561 7369 6573 7420 7469  e the easiest ti
-0001c9f0: 6d65 2067 6574 7469 6e67 2067 6f6f 6420  me getting good 
-0001ca00: 7265 7375 6c74 7320 6279 2075 7369 6e67  results by using
-0001ca10: 0a2f 2f20 2020 6120 6d6f 6e6f 7370 6163  .//   a monospac
-0001ca20: 6520 666f 6e74 2073 7563 6820 6173 2043  e font such as C
-0001ca30: 6f75 7269 6572 2e20 204e 6f74 6520 7468  ourier.  Note th
-0001ca40: 6174 2065 7665 6e20 7769 7468 2074 6578  at even with tex
-0001ca50: 7420 6d65 7472 6963 732c 2073 7061 6369  t metrics, spaci
-0001ca60: 6e67 206d 6179 2062 6520 6469 6666 6572  ng may be differ
-0001ca70: 656e 7420 6265 6361 7573 6520 7061 7468  ent because path
-0001ca80: 5f74 6578 7428 290a 2f2f 2020 2064 6f65  _text().//   doe
-0001ca90: 736e 2774 2064 6f20 6b65 726e 696e 6720  sn't do kerning 
-0001caa0: 746f 2061 646a 7573 7420 706f 7369 7469  to adjust positi
-0001cab0: 6f6e 7320 6f66 2069 6e64 6976 6964 7561  ons of individua
-0001cac0: 6c20 676c 7970 6873 2e20 2041 6c73 6f20  l glyphs.  Also 
-0001cad0: 6966 2079 6f75 7220 666f 6e74 2068 6173  if your font has
-0001cae0: 206c 6967 6174 7572 6573 2074 6865 7920   ligatures they 
-0001caf0: 776f 6e27 7420 6265 2075 7365 642e 2020  won't be used.  
-0001cb00: 0a2f 2f20 2020 2e0a 2f2f 2020 2042 7920  .//   ..//   By 
-0001cb10: 6465 6661 756c 7420 6c65 7474 6572 7320  default letters 
-0001cb20: 6170 7065 6172 2063 656e 7465 7265 6420  appear centered 
-0001cb30: 6f6e 2074 6865 2070 6174 682e 2020 5468  on the path.  Th
-0001cb40: 6520 6f66 6673 6574 2063 616e 2062 6520  e offset can be 
-0001cb50: 7370 6563 6966 6965 6420 746f 2073 6869  specified to shi
-0001cb60: 6674 206c 6574 7465 7273 2074 6f77 6172  ft letters towar
-0001cb70: 6420 7468 6520 7265 6164 6572 2028 696e  d the reader (in
-0001cb80: 0a2f 2f20 2020 7468 6520 6469 7265 6374  .//   the direct
-0001cb90: 696f 6e20 6f66 2074 6865 206e 6f72 6d61  ion of the norma
-0001cba0: 6c29 2e20 200a 2f2f 2020 202e 0a2f 2f20  l).  .//   ..// 
-0001cbb0: 2020 596f 7520 6361 6e20 7370 6563 6966    You can specif
-0001cbc0: 7920 796f 7572 206f 776e 206e 6f72 6d61  y your own norma
-0001cbd0: 6c20 6279 2073 6574 7469 6e67 2060 6e6f  l by setting `no
-0001cbe0: 726d 616c 6020 746f 2061 2064 6972 6563  rmal` to a direc
-0001cbf0: 7469 6f6e 206f 7220 6120 6c69 7374 206f  tion or a list o
-0001cc00: 6620 6469 7265 6374 696f 6e73 2e20 2059  f directions.  Y
-0001cc10: 6f75 7220 6e6f 726d 616c 2076 6563 746f  our normal vecto
-0001cc20: 7220 7368 6f75 6c64 0a2f 2f20 2020 706f  r should.//   po
-0001cc30: 696e 7420 746f 7761 7264 2074 6865 2072  int toward the r
-0001cc40: 6561 6465 722e 2020 596f 7520 6361 6e20  eader.  You can 
-0001cc50: 616c 736f 2073 7065 6369 6679 0a2f 2f20  also specify.// 
-0001cc60: 2020 746f 702c 2077 6869 6368 2064 6972    top, which dir
-0001cc70: 6563 7473 2074 6865 2074 6f70 206f 6620  ects the top of 
-0001cc80: 7468 6520 6c65 7474 6572 7320 696e 2061  the letters in a
-0001cc90: 2064 6573 6972 6564 2064 6972 6563 7469   desired directi
-0001cca0: 6f6e 2e20 2049 6620 796f 7520 7370 6563  on.  If you spec
-0001ccb0: 6966 7920 796f 7572 206f 776e 2064 6972  ify your own dir
-0001ccc0: 6563 7469 6f6e 7320 616e 6420 7468 6579  ections and they
-0001ccd0: 0a2f 2f20 2020 6172 6520 6e6f 7420 7065  .//   are not pe
-0001cce0: 7270 656e 6469 6375 6c61 7220 746f 2074  rpendicular to t
-0001ccf0: 6865 2070 6174 6820 7468 656e 2074 6865  he path then the
-0001cd00: 2064 6972 6563 7469 6f6e 2079 6f75 2073   direction you s
-0001cd10: 7065 6369 6679 2077 696c 6c20 7461 6b65  pecify will take
-0001cd20: 2070 7269 6f72 6974 7920 616e 6420 7468   priority and th
-0001cd30: 650a 2f2f 2020 206c 6574 7465 7273 2077  e.//   letters w
-0001cd40: 696c 6c20 6e6f 7420 7265 7374 206f 6e20  ill not rest on 
-0001cd50: 7468 6520 7461 6e67 656e 7420 6c69 6e65  the tangent line
-0001cd60: 206f 6620 7468 6520 7061 7468 2e20 204e   of the path.  N
-0001cd70: 6f74 6520 7468 6174 2074 6865 206e 6f72  ote that the nor
-0001cd80: 6d61 6c20 6f72 2074 6f70 2064 6972 6563  mal or top direc
-0001cd90: 7469 6f6e 7320 7468 6174 2079 6f75 0a2f  tions that you./
-0001cda0: 2f20 2020 7370 6563 6966 7920 6d75 7374  /   specify must
-0001cdb0: 206e 6f74 2062 6520 7061 7261 6c6c 656c   not be parallel
-0001cdc0: 2074 6f20 7468 6520 7061 7468 2e20 200a   to the path.  .
-0001cdd0: 2f2f 2041 7267 756d 656e 7473 3a0a 2f2f  // Arguments:.//
-0001cde0: 2020 2070 6174 6820 3d20 7061 7468 2074     path = path t
-0001cdf0: 6f20 706c 6163 6520 7468 6520 7465 7874  o place the text
-0001ce00: 206f 6e0a 2f2f 2020 2074 6578 7420 3d20   on.//   text = 
-0001ce10: 7465 7874 2074 6f20 6372 6561 7465 0a2f  text to create./
-0001ce20: 2f20 2020 7369 7a65 203d 2066 6f6e 7420  /   size = font 
-0001ce30: 7369 7a65 0a2f 2f20 2020 7468 6963 6b6e  size.//   thickn
-0001ce40: 6573 7320 3d20 7468 6963 6b6e 6573 7320  ess = thickness 
-0001ce50: 6f66 206c 6574 7465 7273 2028 6e6f 7420  of letters (not 
-0001ce60: 616c 6c6f 7765 6420 666f 7220 3244 2070  allowed for 2D p
-0001ce70: 6174 6829 0a2f 2f20 2020 666f 6e74 203d  ath).//   font =
-0001ce80: 2066 6f6e 7420 746f 2075 7365 0a2f 2f20   font to use.// 
-0001ce90: 2020 2d2d 2d0a 2f2f 2020 206c 6574 7465    ---.//   lette
-0001cea0: 7273 697a 6520 3d20 7363 616c 6172 206f  rsize = scalar o
-0001ceb0: 7220 6172 7261 7920 6769 7669 6e67 2073  r array giving s
-0001cec0: 697a 6520 6f66 206c 6574 7465 7273 0a2f  ize of letters./
-0001ced0: 2f20 2020 6365 6e74 6572 203d 2063 656e  /   center = cen
-0001cee0: 7465 7220 7465 7874 206f 6e20 7468 6520  ter text on the 
-0001cef0: 7061 7468 2069 6e73 7465 6164 206f 6620  path instead of 
-0001cf00: 7374 6172 7469 6e67 2061 7420 7468 6520  starting at the 
-0001cf10: 6669 7273 7420 706f 696e 742e 2020 4465  first point.  De
-0001cf20: 6661 756c 743a 2066 616c 7365 0a2f 2f20  fault: false.// 
-0001cf30: 2020 6f66 6673 6574 203d 2064 6973 7461    offset = dista
-0001cf40: 6e63 6520 746f 2073 6869 6674 206c 6574  nce to shift let
-0001cf50: 7465 7273 2022 7570 2220 2874 6f77 6172  ters "up" (towar
-0001cf60: 6473 2074 6865 2072 6561 6465 7229 2e20  ds the reader). 
-0001cf70: 204e 6f74 2061 6c6c 6f77 6564 2066 6f72   Not allowed for
-0001cf80: 2032 4420 7061 7468 2e20 2044 6566 6175   2D path.  Defau
-0001cf90: 6c74 3a20 300a 2f2f 2020 206e 6f72 6d61  lt: 0.//   norma
-0001cfa0: 6c20 3d20 6469 7265 6374 696f 6e20 6f72  l = direction or
-0001cfb0: 206c 6973 7420 6f66 2064 6972 6563 7469   list of directi
-0001cfc0: 6f6e 7320 706f 696e 7469 6e67 2074 6f77  ons pointing tow
-0001cfd0: 6172 6473 2074 6865 2072 6561 6465 7220  ards the reader 
-0001cfe0: 6f66 2074 6865 2074 6578 742e 2020 4e6f  of the text.  No
-0001cff0: 7420 616c 6c6f 7765 6420 666f 7220 3244  t allowed for 2D
-0001d000: 2070 6174 682e 0a2f 2f20 2020 746f 7020   path..//   top 
-0001d010: 3d20 6469 7265 6374 696f 6e20 6f72 206c  = direction or l
-0001d020: 6973 7420 6f66 2064 6972 6563 7469 6f6e  ist of direction
-0001d030: 7320 706f 696e 7469 6e67 2074 6f77 6172  s pointing towar
-0001d040: 6420 7468 6520 746f 7020 6f66 2074 6865  d the top of the
-0001d050: 2074 6578 740a 2f2f 2020 2072 6576 6572   text.//   rever
-0001d060: 7365 203d 2072 6576 6572 7365 2074 6865  se = reverse the
-0001d070: 206c 6574 7465 7273 2069 6620 7472 7565   letters if true
-0001d080: 2e20 204e 6f74 2061 6c6c 6f77 6564 2066  .  Not allowed f
-0001d090: 6f72 2032 4420 7061 7468 2e20 2044 6566  or 2D path.  Def
-0001d0a0: 6175 6c74 3a20 6661 6c73 650a 2f2f 2020  ault: false.//  
-0001d0b0: 2074 6578 746d 6574 7269 6373 203d 2069   textmetrics = i
-0001d0c0: 6620 7365 7420 746f 2074 7275 6520 616e  f set to true an
-0001d0d0: 6420 6c65 7474 6572 7369 7a65 2069 7320  d lettersize is 
-0001d0e0: 6e6f 7420 6769 7665 6e20 7468 656e 2075  not given then u
-0001d0f0: 7365 2074 6865 2065 7870 6572 696d 656e  se the experimen
-0001d100: 7461 6c20 7465 7874 6d65 7472 6963 7320  tal textmetrics 
-0001d110: 6665 6174 7572 652e 2020 596f 7520 6d75  feature.  You mu
-0001d120: 7374 2062 6520 7275 6e6e 696e 6720 6120  st be running a 
-0001d130: 6465 7620 736e 6170 7368 6f74 2074 6861  dev snapshot tha
-0001d140: 7420 696e 636c 7564 6573 2074 6869 7320  t includes this 
-0001d150: 6665 6174 7572 6520 616e 6420 6861 7665  feature and have
-0001d160: 2074 6865 2066 6561 7475 7265 2074 7572   the feature tur
-0001d170: 6e65 6420 6f6e 2069 6e20 796f 7572 2070  ned on in your p
-0001d180: 7265 6665 7265 6e63 6573 2e20 2044 6566  references.  Def
-0001d190: 6175 6c74 3a20 6661 6c73 650a 2f2f 2020  ault: false.//  
-0001d1a0: 206b 6572 6e20 3d20 7363 616c 6172 206f   kern = scalar o
-0001d1b0: 7220 6172 7261 7920 6769 7669 6e67 2073  r array giving s
-0001d1c0: 697a 6520 6164 6a75 7374 6d65 6e74 7320  ize adjustments 
-0001d1d0: 666f 7220 6561 6368 206c 6574 7465 722e  for each letter.
-0001d1e0: 2020 4465 6661 756c 743a 2030 0a2f 2f20    Default: 0.// 
-0001d1f0: 4578 616d 706c 6528 3344 2c4e 6f53 6361  Example(3D,NoSca
-0001d200: 6c65 7329 3a20 2054 6865 2065 7861 6d70  les):  The examp
-0001d210: 6c65 7320 7573 6520 436f 7572 6965 722c  les use Courier,
-0001d220: 2061 206d 6f6e 6f73 7061 6365 6420 666f   a monospaced fo
-0001d230: 6e74 2e20 2054 6865 2077 6964 7468 2069  nt.  The width i
-0001d240: 7320 312f 312e 3220 7469 6d65 7320 7468  s 1/1.2 times th
-0001d250: 6520 7370 6563 6966 6965 6420 7369 7a65  e specified size
-0001d260: 2066 6f72 2074 6869 7320 666f 6e74 2e20   for this font. 
-0001d270: 2054 6869 7320 7465 7874 2063 6f75 6c64   This text could
-0001d280: 2077 7261 7020 6172 6f75 6e64 2061 2063   wrap around a c
-0001d290: 796c 696e 6465 722e 200a 2f2f 2020 2070  ylinder. .//   p
-0001d2a0: 6174 6820 3d20 7061 7468 3364 2861 7263  ath = path3d(arc
-0001d2b0: 2831 3030 2c20 723d 3235 2c20 616e 676c  (100, r=25, angl
-0001d2c0: 653d 5b32 3435 2c20 3337 305d 2929 3b0a  e=[245, 370]));.
-0001d2d0: 2f2f 2020 2063 6f6c 6f72 2822 7265 6422  //   color("red"
-0001d2e0: 2973 7472 6f6b 6528 7061 7468 2c20 7769  )stroke(path, wi
-0001d2f0: 6474 683d 2e33 293b 0a2f 2f20 2020 7061  dth=.3);.//   pa
-0001d300: 7468 5f74 6578 7428 7061 7468 2c20 2245  th_text(path, "E
-0001d310: 7861 6d70 6c65 2074 6578 7422 2c20 666f  xample text", fo
-0001d320: 6e74 3d22 436f 7572 6965 7222 2c20 7369  nt="Courier", si
-0001d330: 7a65 3d35 2c20 6c65 7474 6572 7369 7a65  ze=5, lettersize
-0001d340: 203d 2035 2f31 2e32 293b 0a2f 2f20 4578   = 5/1.2);.// Ex
-0001d350: 616d 706c 6528 3344 2c4e 6f53 6361 6c65  ample(3D,NoScale
-0001d360: 7329 3a20 4279 2073 6574 7469 6e67 2074  s): By setting t
-0001d370: 6865 206e 6f72 6d61 6c20 746f 2055 5020  he normal to UP 
-0001d380: 7765 2063 616e 2067 6574 2074 6578 7420  we can get text 
-0001d390: 7468 6174 206c 6965 7320 666c 6174 2c20  that lies flat, 
-0001d3a0: 666f 7220 7772 6974 696e 6720 6172 6f75  for writing arou
-0001d3b0: 6e64 2074 6865 2065 6467 6520 6f66 2061  nd the edge of a
-0001d3c0: 2064 6973 6b3a 0a2f 2f20 2020 7061 7468   disk:.//   path
-0001d3d0: 203d 2070 6174 6833 6428 6172 6328 3130   = path3d(arc(10
-0001d3e0: 302c 2072 3d32 352c 2061 6e67 6c65 3d5b  0, r=25, angle=[
-0001d3f0: 3234 352c 2033 3730 5d29 293b 0a2f 2f20  245, 370]));.// 
-0001d400: 2020 636f 6c6f 7228 2272 6564 2229 7374    color("red")st
-0001d410: 726f 6b65 2870 6174 682c 2077 6964 7468  roke(path, width
-0001d420: 3d2e 3329 3b0a 2f2f 2020 2070 6174 685f  =.3);.//   path_
-0001d430: 7465 7874 2870 6174 682c 2022 4578 616d  text(path, "Exam
-0001d440: 706c 6520 7465 7874 222c 2066 6f6e 743d  ple text", font=
-0001d450: 2243 6f75 7269 6572 222c 2073 697a 653d  "Courier", size=
-0001d460: 352c 206c 6574 7465 7273 697a 6520 3d20  5, lettersize = 
-0001d470: 352f 312e 322c 206e 6f72 6d61 6c3d 5550  5/1.2, normal=UP
-0001d480: 293b 0a2f 2f20 4578 616d 706c 6528 3344  );.// Example(3D
-0001d490: 2c4e 6f53 6361 6c65 7329 3a20 2049 6620  ,NoScales):  If 
-0001d4a0: 7765 2077 616e 7420 7465 7874 2074 6861  we want text tha
-0001d4b0: 7420 7265 6164 7320 6672 6f6d 2074 6865  t reads from the
-0001d4c0: 206f 7468 6572 2073 6964 6520 7765 2063   other side we c
-0001d4d0: 616e 2075 7365 2072 6576 6572 7365 2e20  an use reverse. 
-0001d4e0: 204e 6f74 6520 7765 2068 6176 6520 746f   Note we have to
-0001d4f0: 2072 6576 6572 7365 2074 6865 2064 6972   reverse the dir
-0001d500: 6563 7469 6f6e 206f 6620 7468 6520 7061  ection of the pa
-0001d510: 7468 2061 6e64 2061 6c73 6f20 7365 7420  th and also set 
-0001d520: 7468 6520 7265 7665 7273 6520 6f70 7469  the reverse opti
-0001d530: 6f6e 2e20 200a 2f2f 2020 2070 6174 6820  on.  .//   path 
-0001d540: 3d20 7265 7665 7273 6528 7061 7468 3364  = reverse(path3d
-0001d550: 2861 7263 2831 3030 2c20 723d 3235 2c20  (arc(100, r=25, 
-0001d560: 616e 676c 653d 5b36 352c 2031 3930 5d29  angle=[65, 190])
-0001d570: 2929 3b0a 2f2f 2020 2063 6f6c 6f72 2822  ));.//   color("
-0001d580: 7265 6422 2973 7472 6f6b 6528 7061 7468  red")stroke(path
-0001d590: 2c20 7769 6474 683d 2e33 293b 0a2f 2f20  , width=.3);.// 
-0001d5a0: 2020 7061 7468 5f74 6578 7428 7061 7468    path_text(path
-0001d5b0: 2c20 2245 7861 6d70 6c65 2074 6578 7422  , "Example text"
-0001d5c0: 2c20 666f 6e74 3d22 436f 7572 6965 7222  , font="Courier"
-0001d5d0: 2c20 7369 7a65 3d35 2c20 6c65 7474 6572  , size=5, letter
-0001d5e0: 7369 7a65 203d 2035 2f31 2e32 2c20 7265  size = 5/1.2, re
-0001d5f0: 7665 7273 653d 7472 7565 293b 0a2f 2f20  verse=true);.// 
-0001d600: 4578 616d 706c 6528 3344 2c4d 6564 2c4e  Example(3D,Med,N
-0001d610: 6f53 6361 6c65 7329 3a20 7465 7874 2064  oScales): text d
-0001d620: 6562 6f73 7365 6420 6f6e 746f 2061 2063  ebossed onto a c
-0001d630: 796c 696e 6465 7220 696e 2061 2073 7069  ylinder in a spi
-0001d640: 7261 6c2e 2020 5468 6520 7465 7874 2069  ral.  The text i
-0001d650: 7320 3120 756e 6974 2064 6565 7020 6265  s 1 unit deep be
-0001d660: 6361 7573 6520 6974 2069 7320 6861 6c66  cause it is half
-0001d670: 2069 6e2c 2068 616c 6620 6f75 742e 200a   in, half out. .
-0001d680: 2f2f 2020 2074 6578 7420 3d20 2822 4120  //   text = ("A 
-0001d690: 6c6f 6e67 2074 6578 7420 6578 616d 706c  long text exampl
-0001d6a0: 6520 746f 2077 7261 7020 6172 6f75 6e64  e to wrap around
-0001d6b0: 2061 2063 796c 696e 6465 722c 2070 6f73   a cylinder, pos
-0001d6c0: 7369 626c 7920 666f 7220 6120 6665 7720  sibly for a few 
-0001d6d0: 7469 6d65 732e 2229 3b0a 2f2f 2020 204c  times.");.//   L
-0001d6e0: 203d 2035 2a6c 656e 2874 6578 7429 3b0a   = 5*len(text);.
-0001d6f0: 2f2f 2020 206d 6178 616e 6720 3d20 3336  //   maxang = 36
-0001d700: 302a 4c2f 2850 492a 3530 293b 0a2f 2f20  0*L/(PI*50);.// 
-0001d710: 2020 7370 6972 616c 203d 205b 666f 7228    spiral = [for(
-0001d720: 613d 5b30 3a31 3a6d 6178 616e 675d 2920  a=[0:1:maxang]) 
-0001d730: 5b32 352a 636f 7328 6129 2c20 3235 2a73  [25*cos(a), 25*s
-0001d740: 696e 2861 292c 2031 302d 3330 2f6d 6178  in(a), 10-30/max
-0001d750: 616e 672a 615d 5d3b 0a2f 2f20 2020 6469  ang*a]];.//   di
-0001d760: 6666 6572 656e 6365 2829 7b0a 2f2f 2020  fference(){.//  
-0001d770: 2020 2063 796c 2864 3d35 302c 206c 3d35     cyl(d=50, l=5
-0001d780: 302c 2024 666e 3d31 3230 293b 0a2f 2f20  0, $fn=120);.// 
-0001d790: 2020 2020 7061 7468 5f74 6578 7428 7370      path_text(sp
-0001d7a0: 6972 616c 2c20 7465 7874 2c20 7369 7a65  iral, text, size
-0001d7b0: 3d35 2c20 6c65 7474 6572 7369 7a65 3d35  =5, lettersize=5
-0001d7c0: 2f31 2e32 2c20 666f 6e74 3d22 436f 7572  /1.2, font="Cour
-0001d7d0: 6965 7222 2c20 7468 6963 6b6e 6573 733d  ier", thickness=
-0001d7e0: 3229 3b0a 2f2f 2020 207d 0a2f 2f20 4578  2);.//   }.// Ex
-0001d7f0: 616d 706c 6528 3344 2c4d 6564 2c4e 6f53  ample(3D,Med,NoS
-0001d800: 6361 6c65 7329 3a20 5361 6d65 2065 7861  cales): Same exa
-0001d810: 6d70 6c65 2062 7574 2074 6578 7420 656d  mple but text em
-0001d820: 626f 7373 6564 2e20 204d 616b 6520 7375  bossed.  Make su
-0001d830: 7265 2079 6f75 2068 6176 6520 656e 6f75  re you have enou
-0001d840: 6768 2064 6570 7468 2066 6f72 2074 6865  gh depth for the
-0001d850: 206c 6574 7465 7273 2074 6f20 6675 6c6c   letters to full
-0001d860: 7920 6f76 6572 6c61 7020 7468 6520 6f62  y overlap the ob
-0001d870: 6a65 6374 2e20 0a2f 2f20 2020 7465 7874  ject. .//   text
-0001d880: 203d 2028 2241 206c 6f6e 6720 7465 7874   = ("A long text
-0001d890: 2065 7861 6d70 6c65 2074 6f20 7772 6170   example to wrap
-0001d8a0: 2061 726f 756e 6420 6120 6379 6c69 6e64   around a cylind
-0001d8b0: 6572 2c20 706f 7373 6962 6c79 2066 6f72  er, possibly for
-0001d8c0: 2061 2066 6577 2074 696d 6573 2e22 293b   a few times.");
-0001d8d0: 0a2f 2f20 2020 4c20 3d20 352a 6c65 6e28  .//   L = 5*len(
-0001d8e0: 7465 7874 293b 0a2f 2f20 2020 6d61 7861  text);.//   maxa
-0001d8f0: 6e67 203d 2033 3630 2a4c 2f28 5049 2a35  ng = 360*L/(PI*5
-0001d900: 3029 3b0a 2f2f 2020 2073 7069 7261 6c20  0);.//   spiral 
-0001d910: 3d20 5b66 6f72 2861 3d5b 303a 313a 6d61  = [for(a=[0:1:ma
-0001d920: 7861 6e67 5d29 205b 3235 2a63 6f73 2861  xang]) [25*cos(a
-0001d930: 292c 2032 352a 7369 6e28 6129 2c20 3130  ), 25*sin(a), 10
-0001d940: 2d33 302f 6d61 7861 6e67 2a61 5d5d 3b0a  -30/maxang*a]];.
-0001d950: 2f2f 2020 2063 796c 2864 3d35 302c 206c  //   cyl(d=50, l
-0001d960: 3d35 302c 2024 666e 3d31 3230 293b 0a2f  =50, $fn=120);./
-0001d970: 2f20 2020 7061 7468 5f74 6578 7428 7370  /   path_text(sp
-0001d980: 6972 616c 2c20 7465 7874 2c20 7369 7a65  iral, text, size
-0001d990: 3d35 2c20 6c65 7474 6572 7369 7a65 3d35  =5, lettersize=5
-0001d9a0: 2f31 2e32 2c20 666f 6e74 3d22 436f 7572  /1.2, font="Cour
-0001d9b0: 6965 7222 2c20 7468 6963 6b6e 6573 733d  ier", thickness=
-0001d9c0: 3229 3b0a 2f2f 2045 7861 6d70 6c65 2833  2);.// Example(3
-0001d9d0: 442c 4e6f 5363 616c 6573 293a 2048 6572  D,NoScales): Her
-0001d9e0: 6520 7468 6520 7465 7874 2062 6173 656c  e the text basel
-0001d9f0: 696e 6520 7369 7473 206f 6e20 7468 6520  ine sits on the 
-0001da00: 7061 7468 2e20 2028 4e6f 7465 2074 6865  path.  (Note the
-0001da10: 2064 6566 6175 6c74 206f 7269 656e 7461   default orienta
-0001da20: 7469 6f6e 206d 616b 6573 2074 6578 7420  tion makes text 
-0001da30: 7265 6164 6162 6c65 2066 726f 6d20 6265  readable from be
-0001da40: 6c6f 772c 2073 6f20 7765 2073 7065 6369  low, so we speci
-0001da50: 6679 2074 6865 206e 6f72 6d61 6c2e 290a  fy the normal.).
-0001da60: 2f2f 2020 2070 6174 6820 3d20 6172 6328  //   path = arc(
-0001da70: 3130 302c 2070 6f69 6e74 7320 3d20 5b5b  100, points = [[
-0001da80: 2d32 302c 2030 2c20 3230 5d2c 205b 302c  -20, 0, 20], [0,
-0001da90: 302c 355d 2c20 5b32 302c 302c 3230 5d5d  0,5], [20,0,20]]
-0001daa0: 293b 0a2f 2f20 2020 636f 6c6f 7228 2272  );.//   color("r
-0001dab0: 6564 2229 7374 726f 6b65 2870 6174 682c  ed")stroke(path,
-0001dac0: 7769 6474 683d 2e32 293b 0a2f 2f20 2020  width=.2);.//   
-0001dad0: 7061 7468 5f74 6578 7428 7061 7468 2c20  path_text(path, 
-0001dae0: 2245 7861 6d70 6c65 2054 6578 7422 2c20  "Example Text", 
-0001daf0: 7369 7a65 3d35 2c20 6c65 7474 6572 7369  size=5, lettersi
-0001db00: 7a65 3d35 2f31 2e32 2c20 666f 6e74 3d22  ze=5/1.2, font="
-0001db10: 436f 7572 6965 7222 2c20 6e6f 726d 616c  Courier", normal
-0001db20: 3d46 524f 4e54 293b 0a2f 2f20 4578 616d  =FRONT);.// Exam
-0001db30: 706c 6528 3344 2c4e 6f53 6361 6c65 7329  ple(3D,NoScales)
-0001db40: 3a20 4966 2077 6520 7573 6520 746f 7020  : If we use top 
-0001db50: 746f 206f 7269 656e 7420 7468 6520 7465  to orient the te
-0001db60: 7874 2075 7077 6172 642c 2074 6865 2074  xt upward, the t
-0001db70: 6578 7420 6261 7365 6c69 6e65 2069 7320  ext baseline is 
-0001db80: 6e6f 206c 6f6e 6765 7220 616c 6967 6e65  no longer aligne
-0001db90: 6420 7769 7468 2074 6865 2070 6174 682e  d with the path.
-0001dba0: 200a 2f2f 2020 2070 6174 6820 3d20 6172   .//   path = ar
-0001dbb0: 6328 3130 302c 2070 6f69 6e74 7320 3d20  c(100, points = 
-0001dbc0: 5b5b 2d32 302c 2030 2c20 3230 5d2c 205b  [[-20, 0, 20], [
-0001dbd0: 302c 302c 355d 2c20 5b32 302c 302c 3230  0,0,5], [20,0,20
-0001dbe0: 5d5d 293b 0a2f 2f20 2020 636f 6c6f 7228  ]]);.//   color(
-0001dbf0: 2272 6564 2229 7374 726f 6b65 2870 6174  "red")stroke(pat
-0001dc00: 682c 7769 6474 683d 2e32 293b 0a2f 2f20  h,width=.2);.// 
-0001dc10: 2020 7061 7468 5f74 6578 7428 7061 7468    path_text(path
-0001dc20: 2c20 2245 7861 6d70 6c65 2054 6578 7422  , "Example Text"
-0001dc30: 2c20 7369 7a65 3d35 2c20 6c65 7474 6572  , size=5, letter
-0001dc40: 7369 7a65 3d35 2f31 2e32 2c20 666f 6e74  size=5/1.2, font
-0001dc50: 3d22 436f 7572 6965 7222 2c20 746f 703d  ="Courier", top=
-0001dc60: 5550 293b 0a2f 2f20 4578 616d 706c 6528  UP);.// Example(
-0001dc70: 3344 2c4d 6564 2c4e 6f53 6361 6c65 7329  3D,Med,NoScales)
-0001dc80: 3a20 5468 6973 2073 696e 6520 7761 7665  : This sine wave
-0001dc90: 2077 7261 7070 6564 2061 726f 756e 6420   wrapped around 
-0001dca0: 7468 6520 6379 6c69 6e64 6572 2068 6173  the cylinder has
-0001dcb0: 2061 2074 7769 7374 696e 6720 6e6f 726d   a twisting norm
-0001dcc0: 616c 2074 6861 7420 7072 6f64 7563 6573  al that produces
-0001dcd0: 2077 696c 6420 6c65 7474 6572 206c 6179   wild letter lay
-0001dce0: 6f75 742e 2020 5765 2066 6978 2069 7420  out.  We fix it 
-0001dcf0: 7769 7468 2061 2063 7573 746f 6d20 6e6f  with a custom no
-0001dd00: 726d 616c 2077 6869 6368 2069 7320 6469  rmal which is di
-0001dd10: 6666 6572 656e 7420 6174 2065 7665 7279  fferent at every
-0001dd20: 2070 6174 6820 706f 696e 742e 200a 2f2f   path point. .//
-0001dd30: 2020 2070 6174 6820 3d20 5b66 6f72 2874     path = [for(t
-0001dd40: 6865 7461 203d 205b 303a 3336 305d 2920  heta = [0:360]) 
-0001dd50: 5b32 352a 636f 7328 7468 6574 6129 2c20  [25*cos(theta), 
-0001dd60: 3235 2a73 696e 2874 6865 7461 292c 2034  25*sin(theta), 4
-0001dd70: 2a63 6f73 2874 6865 7461 2a34 295d 5d3b  *cos(theta*4)]];
-0001dd80: 0a2f 2f20 2020 6e6f 726d 616c 203d 205b  .//   normal = [
-0001dd90: 666f 7228 7468 6574 6120 3d20 5b30 3a33  for(theta = [0:3
-0001dda0: 3630 5d29 205b 636f 7328 7468 6574 6129  60]) [cos(theta)
-0001ddb0: 2c20 7369 6e28 7468 6574 6129 2c30 5d5d  , sin(theta),0]]
-0001ddc0: 3b0a 2f2f 2020 207a 726f 7428 2d31 3230  ;.//   zrot(-120
-0001ddd0: 290a 2f2f 2020 2064 6966 6665 7265 6e63  ).//   differenc
-0001dde0: 6528 297b 0a2f 2f20 2020 2020 6379 6c28  e(){.//     cyl(
-0001ddf0: 723d 3235 2c20 683d 3230 2c20 2466 6e3d  r=25, h=20, $fn=
-0001de00: 3132 3029 3b0a 2f2f 2020 2020 2070 6174  120);.//     pat
-0001de10: 685f 7465 7874 2870 6174 682c 2022 4120  h_text(path, "A 
-0001de20: 7369 6e65 2077 6176 6520 7769 6767 6c65  sine wave wiggle
-0001de30: 7322 2c20 666f 6e74 3d22 436f 7572 6965  s", font="Courie
-0001de40: 7222 2c20 6c65 7474 6572 7369 7a65 3d35  r", lettersize=5
-0001de50: 2f31 2e32 2c20 7369 7a65 3d35 2c20 6e6f  /1.2, size=5, no
-0001de60: 726d 616c 3d6e 6f72 6d61 6c29 3b0a 2f2f  rmal=normal);.//
-0001de70: 2020 207d 0a2f 2f20 4578 616d 706c 6528     }.// Example(
-0001de80: 3344 2c4d 6564 2c4e 6f53 6361 6c65 7329  3D,Med,NoScales)
-0001de90: 3a20 5468 6520 7061 7468 2063 656e 7465  : The path cente
-0001dea0: 7220 6f66 2063 7572 7661 7475 7265 2063  r of curvature c
-0001deb0: 6861 6e67 6573 2c20 616e 6420 7468 6520  hanges, and the 
-0001dec0: 7465 7874 2066 6c69 7073 2e20 200a 2f2f  text flips.  .//
-0001ded0: 2020 2070 6174 6820 3d20 207a 726f 7428     path =  zrot(
-0001dee0: 2d31 3230 2c70 3d70 6174 6833 6428 2063  -120,p=path3d( c
-0001def0: 6f6e 6361 7428 6172 6328 3130 302c 2072  oncat(arc(100, r
-0001df00: 3d32 352c 2061 6e67 6c65 3d5b 302c 3930  =25, angle=[0,90
-0001df10: 5d29 2c20 6261 636b 2835 302c 703d 6172  ]), back(50,p=ar
-0001df20: 6328 3130 302c 2072 3d32 352c 2061 6e67  c(100, r=25, ang
-0001df30: 6c65 3d5b 3236 382c 2031 3830 5d29 2929  le=[268, 180])))
-0001df40: 2929 3b0a 2f2f 2020 2063 6f6c 6f72 2822  ));.//   color("
-0001df50: 7265 6422 2973 7472 6f6b 6528 7061 7468  red")stroke(path
-0001df60: 2c77 6964 7468 3d2e 3229 3b0a 2f2f 2020  ,width=.2);.//  
-0001df70: 2070 6174 685f 7465 7874 2870 6174 682c   path_text(path,
-0001df80: 2022 4120 7368 6f72 7465 7220 6578 616d   "A shorter exam
-0001df90: 706c 6522 2c20 2073 697a 653d 352c 206c  ple",  size=5, l
-0001dfa0: 6574 7465 7273 697a 653d 352f 312e 322c  ettersize=5/1.2,
-0001dfb0: 2066 6f6e 743d 2243 6f75 7269 6572 222c   font="Courier",
-0001dfc0: 2074 6869 636b 6e65 7373 3d32 293b 0a2f   thickness=2);./
-0001dfd0: 2f20 4578 616d 706c 6528 3344 2c4d 6564  / Example(3D,Med
-0001dfe0: 2c4e 6f53 6361 6c65 7329 3a20 5765 2063  ,NoScales): We c
-0001dff0: 616e 2066 6978 2069 7420 7769 7468 2074  an fix it with t
-0001e000: 6f70 3a0a 2f2f 2020 2070 6174 6820 3d20  op:.//   path = 
-0001e010: 207a 726f 7428 2d31 3230 2c70 3d70 6174   zrot(-120,p=pat
-0001e020: 6833 6428 2063 6f6e 6361 7428 6172 6328  h3d( concat(arc(
-0001e030: 3130 302c 2072 3d32 352c 2061 6e67 6c65  100, r=25, angle
-0001e040: 3d5b 302c 3930 5d29 2c20 6261 636b 2835  =[0,90]), back(5
-0001e050: 302c 703d 6172 6328 3130 302c 2072 3d32  0,p=arc(100, r=2
-0001e060: 352c 2061 6e67 6c65 3d5b 3236 382c 2031  5, angle=[268, 1
-0001e070: 3830 5d29 2929 2929 3b0a 2f2f 2020 2063  80])))));.//   c
-0001e080: 6f6c 6f72 2822 7265 6422 2973 7472 6f6b  olor("red")strok
-0001e090: 6528 7061 7468 2c77 6964 7468 3d2e 3229  e(path,width=.2)
-0001e0a0: 3b0a 2f2f 2020 2070 6174 685f 7465 7874  ;.//   path_text
-0001e0b0: 2870 6174 682c 2022 4120 7368 6f72 7465  (path, "A shorte
-0001e0c0: 7220 6578 616d 706c 6522 2c20 2073 697a  r example",  siz
-0001e0d0: 653d 352c 206c 6574 7465 7273 697a 653d  e=5, lettersize=
-0001e0e0: 352f 312e 322c 2066 6f6e 743d 2243 6f75  5/1.2, font="Cou
-0001e0f0: 7269 6572 222c 2074 6869 636b 6e65 7373  rier", thickness
-0001e100: 3d32 2c20 746f 703d 5550 293b 0a2f 2f20  =2, top=UP);.// 
-0001e110: 4578 616d 706c 6528 3244 2c4e 6f53 6361  Example(2D,NoSca
-0001e120: 6c65 7329 3a20 5769 7468 2061 2032 4420  les): With a 2D 
-0001e130: 7061 7468 2069 6e73 7465 6164 206f 6620  path instead of 
-0001e140: 3344 2074 6865 7265 2773 206e 6f20 616d  3D there's no am
-0001e150: 6269 6775 6974 7920 6162 6f75 7420 6469  biguity about di
-0001e160: 7265 6374 696f 6e20 616e 6420 6974 2077  rection and it w
-0001e170: 6f72 6b73 2062 7920 6465 6661 756c 743a  orks by default:
-0001e180: 0a2f 2f20 2020 7061 7468 203d 2020 7a72  .//   path =  zr
-0001e190: 6f74 282d 3132 302c 703d 636f 6e63 6174  ot(-120,p=concat
-0001e1a0: 2861 7263 2831 3030 2c20 723d 3235 2c20  (arc(100, r=25, 
-0001e1b0: 616e 676c 653d 5b30 2c39 305d 292c 2062  angle=[0,90]), b
-0001e1c0: 6163 6b28 3530 2c70 3d61 7263 2831 3030  ack(50,p=arc(100
-0001e1d0: 2c20 723d 3235 2c20 616e 676c 653d 5b32  , r=25, angle=[2
-0001e1e0: 3638 2c20 3138 305d 2929 2929 3b0a 2f2f  68, 180]))));.//
-0001e1f0: 2020 2063 6f6c 6f72 2822 7265 6422 2973     color("red")s
-0001e200: 7472 6f6b 6528 7061 7468 2c77 6964 7468  troke(path,width
-0001e210: 3d2e 3229 3b0a 2f2f 2020 2070 6174 685f  =.2);.//   path_
-0001e220: 7465 7874 2870 6174 682c 2022 4120 7368  text(path, "A sh
-0001e230: 6f72 7465 7220 6578 616d 706c 6522 2c20  orter example", 
-0001e240: 2073 697a 653d 352c 206c 6574 7465 7273   size=5, letters
-0001e250: 697a 653d 352f 312e 322c 2066 6f6e 743d  ize=5/1.2, font=
-0001e260: 2243 6f75 7269 6572 2229 3b0a 2f2f 2045  "Courier");.// E
-0001e270: 7861 6d70 6c65 2833 442c 4e6f 5363 616c  xample(3D,NoScal
-0001e280: 6573 293a 2054 6865 206b 6572 6e20 7061  es): The kern pa
-0001e290: 7261 6d65 7465 7220 6c65 7473 2079 6f75  rameter lets you
-0001e2a0: 2061 646a 7573 7420 7468 6520 6c65 7474   adjust the lett
-0001e2b0: 6572 2073 7061 6369 6e67 2065 6974 6865  er spacing eithe
-0001e2c0: 7220 7769 7468 2061 2075 6e69 666f 726d  r with a uniform
-0001e2d0: 2076 616c 7565 2066 6f72 2065 6163 6820   value for each 
-0001e2e0: 6c65 7474 6572 2c20 6f72 2077 6974 6820  letter, or with 
-0001e2f0: 616e 2061 7272 6179 2074 6f20 6d61 6b65  an array to make
-0001e300: 2061 646a 7573 746d 656e 7473 2074 6872   adjustments thr
-0001e310: 6f75 6768 6f75 7420 7468 6520 7465 7874  oughout the text
-0001e320: 2e20 2048 6572 6520 7765 2073 686f 7720  .  Here we show 
-0001e330: 6120 6361 7365 2077 6865 7265 2061 6464  a case where add
-0001e340: 696e 6720 736f 6d65 2065 7874 7261 2073  ing some extra s
-0001e350: 7061 6365 2067 6976 6573 2061 2062 6574  pace gives a bet
-0001e360: 7465 7220 6c6f 6f6b 2069 6e20 6120 7469  ter look in a ti
-0001e370: 6768 7420 6369 7263 6c65 2e20 2057 6865  ght circle.  Whe
-0001e380: 6e20 7465 7874 6d65 7472 6963 7320 6172  n textmetrics ar
-0001e390: 6520 6f66 662c 2060 6c65 7474 6572 7369  e off, `lettersi
-0001e3a0: 7a65 6020 6361 6e20 646f 2074 6869 7320  ze` can do this 
-0001e3b0: 6a6f 622c 2062 7574 2077 6974 6820 7465  job, but with te
-0001e3c0: 7874 6d65 7472 6963 732c 2079 6f75 276c  xtmetrics, you'l
-0001e3d0: 6c20 6e65 6564 2074 6f20 7573 6520 606b  l need to use `k
-0001e3e0: 6572 6e60 2074 6f20 6d61 6b65 2061 646a  ern` to make adj
-0001e3f0: 7573 746d 656e 7473 2072 656c 6174 6976  ustments relativ
-0001e400: 6520 746f 2074 6865 2074 6578 7420 6d65  e to the text me
-0001e410: 7472 6963 2073 697a 6573 2e0a 2f2f 2020  tric sizes..//  
-0001e420: 2070 6174 6820 3d20 7061 7468 3364 2861   path = path3d(a
-0001e430: 7263 2831 3030 2c20 723d 3132 2c20 616e  rc(100, r=12, an
-0001e440: 676c 653d 5b31 3530 2c20 3435 305d 2929  gle=[150, 450]))
-0001e450: 3b0a 2f2f 2020 2063 6f6c 6f72 2822 7265  ;.//   color("re
-0001e460: 6422 2973 7472 6f6b 6528 7061 7468 2c20  d")stroke(path, 
-0001e470: 7769 6474 683d 2e33 293b 0a2f 2f20 2020  width=.3);.//   
-0001e480: 6b65 726e 203d 205b 312c 312e 322c 312c  kern = [1,1.2,1,
-0001e490: 312c 2e33 2c2d 2e32 2c31 2c30 2c2e 382c  1,.3,-.2,1,0,.8,
-0001e4a0: 312c 312e 312c 315d 3b0a 2f2f 2020 2070  1,1.1,1];.//   p
-0001e4b0: 6174 685f 7465 7874 2870 6174 682c 2022  ath_text(path, "
-0001e4c0: 4578 616d 706c 6520 7465 7874 222c 2066  Example text", f
-0001e4d0: 6f6e 743d 2243 6f75 7269 6572 222c 2073  ont="Courier", s
-0001e4e0: 697a 653d 352c 206c 6574 7465 7273 697a  ize=5, lettersiz
-0001e4f0: 6520 3d20 352f 312e 322c 206b 6572 6e3d  e = 5/1.2, kern=
-0001e500: 6b65 726e 2c20 6e6f 726d 616c 3d55 5029  kern, normal=UP)
-0001e510: 3b0a 6d6f 6475 6c65 2070 6174 685f 7465  ;.module path_te
-0001e520: 7874 2870 6174 682c 2074 6578 742c 2066  xt(path, text, f
-0001e530: 6f6e 742c 2073 697a 652c 2074 6869 636b  ont, size, thick
-0001e540: 6e65 7373 2c20 6c65 7474 6572 7369 7a65  ness, lettersize
-0001e550: 2c20 6f66 6673 6574 3d30 2c20 7265 7665  , offset=0, reve
-0001e560: 7273 653d 6661 6c73 652c 206e 6f72 6d61  rse=false, norma
-0001e570: 6c2c 2074 6f70 2c20 6365 6e74 6572 3d66  l, top, center=f
-0001e580: 616c 7365 2c20 7465 7874 6d65 7472 6963  alse, textmetric
-0001e590: 733d 6661 6c73 652c 206b 6572 6e3d 3029  s=false, kern=0)
-0001e5a0: 0a7b 0a20 206e 6f5f 6368 696c 6472 656e  .{.  no_children
-0001e5b0: 2824 6368 696c 6472 656e 293b 0a20 2064  ($children);.  d
-0001e5c0: 756d 6d79 323d 6173 7365 7274 2869 735f  ummy2=assert(is_
-0001e5d0: 7061 7468 2870 6174 682c 5b32 2c33 5d29  path(path,[2,3])
-0001e5e0: 2c22 4d75 7374 2073 7570 706c 7920 6120  ,"Must supply a 
-0001e5f0: 3264 206f 7220 3364 2070 6174 6822 290a  2d or 3d path").
-0001e600: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
-0001e610: 6e75 6d5f 6465 6669 6e65 6428 5b6e 6f72  num_defined([nor
-0001e620: 6d61 6c2c 746f 705d 293c 3d31 2c20 2243  mal,top])<=1, "C
-0001e630: 616e 6e6f 7420 6465 6669 6e65 2062 6f74  annot define bot
-0001e640: 6820 5c22 6e6f 726d 616c 5c22 2061 6e64  h \"normal\" and
-0001e650: 205c 2274 6f70 5c22 2229 3b0a 2020 6469   \"top\"");.  di
-0001e660: 6d20 3d20 6c65 6e28 7061 7468 5b30 5d29  m = len(path[0])
-0001e670: 3b0a 2020 6e6f 726d 616c 6f6b 203d 2069  ;.  normalok = i
-0001e680: 735f 756e 6465 6628 6e6f 726d 616c 2920  s_undef(normal) 
-0001e690: 7c7c 2069 735f 7665 6374 6f72 286e 6f72  || is_vector(nor
-0001e6a0: 6d61 6c2c 3329 207c 7c20 2869 735f 7061  mal,3) || (is_pa
-0001e6b0: 7468 286e 6f72 6d61 6c2c 3329 2026 2620  th(normal,3) && 
-0001e6c0: 6c65 6e28 6e6f 726d 616c 293d 3d6c 656e  len(normal)==len
-0001e6d0: 2870 6174 6829 293b 0a20 2074 6f70 6f6b  (path));.  topok
-0001e6e0: 203d 2069 735f 756e 6465 6628 746f 7029   = is_undef(top)
-0001e6f0: 207c 7c20 6973 5f76 6563 746f 7228 746f   || is_vector(to
-0001e700: 702c 6469 6d29 207c 7c20 2864 696d 3d3d  p,dim) || (dim==
-0001e710: 3220 2626 2069 735f 7665 6374 6f72 2874  2 && is_vector(t
-0001e720: 6f70 2c33 2920 2626 2074 6f70 5b32 5d3d  op,3) && top[2]=
-0001e730: 3d30 290a 2020 2020 2020 2020 2020 2020  =0).            
-0001e740: 2020 2020 2020 2020 2020 2020 7c7c 2028              || (
-0001e750: 6973 5f70 6174 6828 746f 702c 6469 6d29  is_path(top,dim)
-0001e760: 2026 2620 6c65 6e28 746f 7029 3d3d 6c65   && len(top)==le
-0001e770: 6e28 7061 7468 2929 3b0a 2020 6475 6d6d  n(path));.  dumm
-0001e780: 7934 203d 2061 7373 6572 7428 6469 6d3d  y4 = assert(dim=
-0001e790: 3d33 207c 7c20 6973 5f75 6e64 6566 2874  =3 || is_undef(t
-0001e7a0: 6869 636b 6e65 7373 292c 2022 4361 6e6e  hickness), "Cann
-0001e7b0: 6f74 2067 6976 6520 6120 7468 6963 6b6e  ot give a thickn
-0001e7c0: 6573 7320 7769 7468 2032 6420 7061 7468  ess with 2d path
-0001e7d0: 2229 0a20 2020 2020 2020 2020 2020 6173  ").           as
-0001e7e0: 7365 7274 2864 696d 3d3d 3320 7c7c 2021  sert(dim==3 || !
-0001e7f0: 7265 7665 7273 652c 2022 5265 7665 7273  reverse, "Revers
-0001e800: 6520 6e6f 7420 616c 6c6f 7765 6420 7769  e not allowed wi
-0001e810: 7468 2032 6420 7061 7468 2229 0a20 2020  th 2d path").   
-0001e820: 2020 2020 2020 2020 6173 7365 7274 2864          assert(d
-0001e830: 696d 3d3d 3320 7c7c 206f 6666 7365 743d  im==3 || offset=
-0001e840: 3d30 2c20 2243 616e 6e6f 7420 6769 7665  =0, "Cannot give
-0001e850: 206f 6666 7365 7420 7769 7468 2032 6420   offset with 2d 
-0001e860: 7061 7468 2229 0a20 2020 2020 2020 2020  path").         
-0001e870: 2020 6173 7365 7274 2864 696d 3d3d 3320    assert(dim==3 
-0001e880: 7c7c 2069 735f 756e 6465 6628 6e6f 726d  || is_undef(norm
-0001e890: 616c 292c 2022 4361 6e6e 6f74 2064 6566  al), "Cannot def
-0001e8a0: 696e 6520 5c22 6e6f 726d 616c 5c22 2066  ine \"normal\" f
-0001e8b0: 6f72 2061 2032 6420 7061 7468 2c20 6f6e  or a 2d path, on
-0001e8c0: 6c79 205c 2274 6f70 5c22 2229 0a20 2020  ly \"top\"").   
-0001e8d0: 2020 2020 2020 2020 6173 7365 7274 286e          assert(n
-0001e8e0: 6f72 6d61 6c6f 6b2c 225c 226e 6f72 6d61  ormalok,"\"norma
-0001e8f0: 6c5c 2220 6d75 7374 2062 6520 6120 7665  l\" must be a ve
-0001e900: 6374 6f72 206f 7220 7061 7468 2063 6f6d  ctor or path com
-0001e910: 7061 7469 626c 6520 7769 7468 2074 6865  patible with the
-0001e920: 2067 6976 656e 2070 6174 6822 290a 2020   given path").  
-0001e930: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
-0001e940: 746f 706f 6b2c 225c 2274 6f70 5c22 206d  topok,"\"top\" m
-0001e950: 7573 7420 6265 2061 2076 6563 746f 7220  ust be a vector 
-0001e960: 6f72 2070 6174 6820 636f 6d70 6174 6962  or path compatib
-0001e970: 6c65 2077 6974 6820 7468 6520 6769 7665  le with the give
-0001e980: 6e20 7061 7468 2229 3b0a 2020 7468 6963  n path");.  thic
-0001e990: 6b6e 6573 7320 3d20 6669 7273 745f 6465  kness = first_de
-0001e9a0: 6669 6e65 6428 5b74 6869 636b 6e65 7373  fined([thickness
-0001e9b0: 2c31 5d29 3b0a 2020 6e6f 726d 616c 203d  ,1]);.  normal =
-0001e9c0: 2069 735f 7665 6374 6f72 286e 6f72 6d61   is_vector(norma
-0001e9d0: 6c29 203f 2072 6570 6561 7428 6e6f 726d  l) ? repeat(norm
-0001e9e0: 616c 2c20 6c65 6e28 7061 7468 2929 0a20  al, len(path)). 
-0001e9f0: 2020 2020 2020 2020 3a20 6973 5f64 6566          : is_def
-0001ea00: 286e 6f72 6d61 6c29 203f 206e 6f72 6d61  (normal) ? norma
-0001ea10: 6c0a 2020 2020 2020 2020 203a 2075 6e64  l.         : und
-0001ea20: 6566 3b0a 0a20 2074 6f70 203d 2069 735f  ef;..  top = is_
-0001ea30: 7665 6374 6f72 2874 6f70 2920 3f20 7265  vector(top) ? re
-0001ea40: 7065 6174 2864 696d 3d3d 323f 706f 696e  peat(dim==2?poin
-0001ea50: 7432 6428 746f 7029 3a74 6f70 2c20 6c65  t2d(top):top, le
-0001ea60: 6e28 7061 7468 2929 0a20 2020 2020 2020  n(path)).       
-0001ea70: 2020 3a20 6973 5f64 6566 2874 6f70 2920    : is_def(top) 
-0001ea80: 3f20 746f 700a 2020 2020 2020 2020 203a  ? top.         :
-0001ea90: 2075 6e64 6566 3b0a 0a20 206b 6572 6e20   undef;..  kern 
-0001eaa0: 3d20 666f 7263 655f 6c69 7374 286b 6572  = force_list(ker
-0001eab0: 6e2c 206c 656e 2874 6578 7429 293b 0a20  n, len(text));. 
-0001eac0: 2064 756d 6d79 3320 3d20 6173 7365 7274   dummy3 = assert
-0001ead0: 2869 735f 6c69 7374 286b 6572 6e29 2026  (is_list(kern) &
-0001eae0: 2620 6c65 6e28 6b65 726e 293d 3d6c 656e  & len(kern)==len
-0001eaf0: 2874 6578 7429 2c20 226b 6572 6e20 6d75  (text), "kern mu
-0001eb00: 7374 2062 6520 6120 7363 616c 6172 206f  st be a scalar o
-0001eb10: 7220 6c69 7374 2077 686f 7365 206c 656e  r list whose len
-0001eb20: 6774 6820 6973 206c 656e 2874 6578 7429  gth is len(text)
-0001eb30: 2229 3b0a 2020 0a20 206c 7369 7a65 203d  ");.  .  lsize =
-0001eb40: 206b 6572 6e20 2b20 280a 2020 2020 2020   kern + (.      
-0001eb50: 2020 2020 6973 5f64 6566 286c 6574 7465      is_def(lette
-0001eb60: 7273 697a 6529 203f 2066 6f72 6365 5f6c  rsize) ? force_l
-0001eb70: 6973 7428 6c65 7474 6572 7369 7a65 2c20  ist(lettersize, 
-0001eb80: 6c65 6e28 7465 7874 2929 0a20 2020 2020  len(text)).     
-0001eb90: 2020 203a 2074 6578 746d 6574 7269 6373     : textmetrics
-0001eba0: 203f 205b 666f 7228 6c65 7474 6572 3d74   ? [for(letter=t
-0001ebb0: 6578 7429 206c 6574 2874 3d74 6578 746d  ext) let(t=textm
-0001ebc0: 6574 7269 6373 286c 6574 7465 722c 2066  etrics(letter, f
-0001ebd0: 6f6e 743d 666f 6e74 2c20 7369 7a65 3d73  ont=font, size=s
-0001ebe0: 697a 6529 2920 742e 6164 7661 6e63 655b  ize)) t.advance[
-0001ebf0: 305d 5d0a 2020 2020 2020 2020 3a20 6173  0]].        : as
-0001ec00: 7365 7274 2866 616c 7365 2c20 2274 6578  sert(false, "tex
-0001ec10: 746d 6574 7269 6373 2064 6973 6162 6c65  tmetrics disable
-0001ec20: 643a 204d 7573 7420 7370 6563 6966 7920  d: Must specify 
-0001ec30: 6c65 7474 6572 2073 697a 6522 290a 2020  letter size").  
-0001ec40: 293b 0a20 2074 6578 746c 656e 6774 6820  );.  textlength 
-0001ec50: 3d20 7375 6d28 6c73 697a 6529 3b0a 2020  = sum(lsize);.  
-0001ec60: 6475 6d6d 7931 203d 2061 7373 6572 7428  dummy1 = assert(
-0001ec70: 7465 7874 6c65 6e67 7468 3c3d 7061 7468  textlength<=path
-0001ec80: 5f6c 656e 6774 6828 7061 7468 292c 2250  _length(path),"P
-0001ec90: 6174 6820 6973 2074 6f6f 2073 686f 7274  ath is too short
-0001eca0: 2066 6f72 2074 6865 2074 6578 7422 293b   for the text");
-0001ecb0: 0a0a 2020 7374 6172 7420 3d20 6365 6e74  ..  start = cent
-0001ecc0: 6572 203f 2028 7061 7468 5f6c 656e 6774  er ? (path_lengt
-0001ecd0: 6828 7061 7468 2920 2d20 7465 7874 6c65  h(path) - textle
-0001ece0: 6e67 7468 292f 3220 3a20 303b 0a20 2020  ngth)/2 : 0;.   
-0001ecf0: 0a20 2070 7473 203d 205f 7061 7468 5f63  .  pts = _path_c
-0001ed00: 7574 5f70 6f69 6e74 7328 7061 7468 2c20  ut_points(path, 
-0001ed10: 6164 645f 7363 616c 6172 285b 302c 2065  add_scalar([0, e
-0001ed20: 6163 6820 6375 6d73 756d 286c 7369 7a65  ach cumsum(lsize
-0001ed30: 295d 2c73 7461 7274 2b6c 7369 7a65 5b30  )],start+lsize[0
-0001ed40: 5d2f 3229 2c20 6469 7265 6374 696f 6e3d  ]/2), direction=
-0001ed50: 7472 7565 293b 0a0a 2020 7573 6572 6e6f  true);..  userno
-0001ed60: 726d 203d 2069 735f 6465 6628 6e6f 726d  rm = is_def(norm
-0001ed70: 616c 293b 0a20 2075 7365 746f 7020 3d20  al);.  usetop = 
-0001ed80: 6973 5f64 6566 2874 6f70 293b 0a20 200a  is_def(top);.  .
-0001ed90: 2020 6e6f 726d 7074 7320 3d20 6973 5f75    normpts = is_u
-0001eda0: 6e64 6566 286e 6f72 6d61 6c29 203f 2028  ndef(normal) ? (
-0001edb0: 7265 7665 7273 653f 313a 2d31 292a 636f  reverse?1:-1)*co
-0001edc0: 6c75 6d6e 2870 7473 2c33 2920 3a20 5f63  lumn(pts,3) : _c
-0001edd0: 7574 5f69 6e74 6572 7028 7074 732c 7061  ut_interp(pts,pa
-0001ede0: 7468 2c20 6e6f 726d 616c 293b 0a20 2074  th, normal);.  t
-0001edf0: 6f70 7074 7320 3d20 6973 5f75 6e64 6566  oppts = is_undef
-0001ee00: 2874 6f70 2920 3f20 756e 6465 6620 3a20  (top) ? undef : 
-0001ee10: 5f63 7574 5f69 6e74 6572 7028 7074 732c  _cut_interp(pts,
-0001ee20: 7061 7468 2c74 6f70 293b 0a20 2066 6f72  path,top);.  for
-0001ee30: 2028 6920 3d20 6964 7828 7465 7874 2929   (i = idx(text))
-0001ee40: 207b 0a20 2020 2074 616e 6765 6e74 203d   {.    tangent =
-0001ee50: 2070 7473 5b69 5d5b 325d 3b0a 2020 2020   pts[i][2];.    
-0001ee60: 6368 6563 6b73 203d 0a20 2020 2020 2020  checks =.       
-0001ee70: 2061 7373 6572 7428 2175 7365 746f 7020   assert(!usetop 
-0001ee80: 7c7c 2021 6170 7072 6f78 2874 616e 6765  || !approx(tange
-0001ee90: 6e74 2a74 6f70 7074 735b 695d 2c6e 6f72  nt*toppts[i],nor
-0001eea0: 6d28 746f 705b 695d 292a 6e6f 726d 2874  m(top[i])*norm(t
-0001eeb0: 616e 6765 6e74 2929 2c0a 2020 2020 2020  angent)),.      
-0001eec0: 2020 2020 2020 2020 2073 7472 2822 5370           str("Sp
-0001eed0: 6563 6966 6965 6420 746f 7020 6469 7265  ecified top dire
-0001eee0: 6374 696f 6e20 7061 7261 6c6c 656c 2074  ction parallel t
-0001eef0: 6f20 7061 7468 2061 7420 6368 6172 6163  o path at charac
-0001ef00: 7465 7220 222c 6929 290a 2020 2020 2020  ter ",i)).      
-0001ef10: 2020 6173 7365 7274 2875 7365 746f 7020    assert(usetop 
-0001ef20: 7c7c 2021 6170 7072 6f78 2874 616e 6765  || !approx(tange
-0001ef30: 6e74 2a6e 6f72 6d70 7473 5b69 5d2c 6e6f  nt*normpts[i],no
-0001ef40: 726d 286e 6f72 6d70 7473 5b69 5d29 2a6e  rm(normpts[i])*n
-0001ef50: 6f72 6d28 7461 6e67 656e 7429 292c 0a20  orm(tangent)),. 
-0001ef60: 2020 2020 2020 2020 2020 2020 2020 7374                st
-0001ef70: 7228 2253 7065 6369 6669 6564 206e 6f72  r("Specified nor
-0001ef80: 6d61 6c20 6469 7265 6374 696f 6e20 7061  mal direction pa
-0001ef90: 7261 6c6c 656c 2074 6f20 7061 7468 2061  rallel to path a
-0001efa0: 7420 6368 6172 6163 7465 7220 222c 6929  t character ",i)
-0001efb0: 293b 0a20 2020 2061 646a 7573 746d 656e  );.    adjustmen
-0001efc0: 7420 3d20 7573 6574 6f70 203f 2020 2874  t = usetop ?  (t
-0001efd0: 616e 6765 6e74 2a74 6f70 7074 735b 695d  angent*toppts[i]
-0001efe0: 292a 746f 7070 7473 5b69 5d2f 2874 6f70  )*toppts[i]/(top
-0001eff0: 7074 735b 695d 2a74 6f70 7074 735b 695d  pts[i]*toppts[i]
-0001f000: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0001f010: 203a 2075 7365 726e 6f72 6d20 3f20 2028   : usernorm ?  (
-0001f020: 7461 6e67 656e 742a 6e6f 726d 7074 735b  tangent*normpts[
-0001f030: 695d 292a 6e6f 726d 7074 735b 695d 2f28  i])*normpts[i]/(
-0001f040: 6e6f 726d 7074 735b 695d 2a6e 6f72 6d70  normpts[i]*normp
-0001f050: 7473 5b69 5d29 0a20 2020 2020 2020 2020  ts[i]).         
-0001f060: 2020 2020 2020 3a20 5b30 2c30 2c30 5d3b        : [0,0,0];
-0001f070: 0a20 2020 206d 6f76 6528 7074 735b 695d  .    move(pts[i]
-0001f080: 5b30 5d29 207b 0a20 2020 2020 2069 6620  [0]) {.      if 
-0001f090: 2864 696d 3d3d 3329 207b 0a20 2020 2020  (dim==3) {.     
-0001f0a0: 2020 2066 7261 6d65 5f6d 6170 280a 2020     frame_map(.  
-0001f0b0: 2020 2020 2020 2020 783d 7461 6e67 656e          x=tangen
-0001f0c0: 742d 6164 6a75 7374 6d65 6e74 2c0a 2020  t-adjustment,.  
-0001f0d0: 2020 2020 2020 2020 7a3d 7573 6574 6f70          z=usetop
-0001f0e0: 203f 2075 6e64 6566 203a 206e 6f72 6d70   ? undef : normp
-0001f0f0: 7473 5b69 5d2c 0a20 2020 2020 2020 2020  ts[i],.         
-0001f100: 2079 3d75 7365 746f 7020 3f20 746f 7070   y=usetop ? topp
-0001f110: 7473 5b69 5d20 3a20 756e 6465 660a 2020  ts[i] : undef.  
-0001f120: 2020 2020 2020 2920 7570 286f 6666 7365        ) up(offse
-0001f130: 742d 7468 6963 6b6e 6573 732f 3229 207b  t-thickness/2) {
-0001f140: 0a20 2020 2020 2020 2020 206c 696e 6561  .          linea
-0001f150: 725f 6578 7472 7564 6528 6865 6967 6874  r_extrude(height
-0001f160: 3d74 6869 636b 6e65 7373 290a 2020 2020  =thickness).    
-0001f170: 2020 2020 2020 2020 6c65 6674 286c 7369          left(lsi
-0001f180: 7a65 5b30 5d2f 3229 0a20 2020 2020 2020  ze[0]/2).       
-0001f190: 2020 2020 2020 2074 6578 7428 7465 7874         text(text
-0001f1a0: 5b69 5d2c 2066 6f6e 743d 666f 6e74 2c20  [i], font=font, 
-0001f1b0: 7369 7a65 3d73 697a 6529 3b0a 2020 2020  size=size);.    
-0001f1c0: 2020 2020 7d0a 2020 2020 2020 7d20 656c      }.      } el
-0001f1d0: 7365 207b 0a20 2020 2020 2020 2020 2066  se {.          f
-0001f1e0: 7261 6d65 5f6d 6170 280a 2020 2020 2020  rame_map(.      
-0001f1f0: 2020 2020 2020 783d 706f 696e 7433 6428        x=point3d(
-0001f200: 7461 6e67 656e 742d 6164 6a75 7374 6d65  tangent-adjustme
-0001f210: 6e74 292c 0a20 2020 2020 2020 2020 2020  nt),.           
-0001f220: 2079 3d70 6f69 6e74 3364 2875 7365 746f   y=point3d(useto
-0001f230: 7020 3f20 746f 7070 7473 5b69 5d20 3a20  p ? toppts[i] : 
-0001f240: 2d6e 6f72 6d70 7473 5b69 5d29 0a20 2020  -normpts[i]).   
-0001f250: 2020 2020 2020 2029 206c 6566 7428 6c73         ) left(ls
-0001f260: 697a 655b 305d 2f32 2920 7b0a 2020 2020  ize[0]/2) {.    
-0001f270: 2020 2020 2020 2020 2020 7465 7874 2874            text(t
-0001f280: 6578 745b 695d 2c20 666f 6e74 3d66 6f6e  ext[i], font=fon
-0001f290: 742c 2073 697a 653d 7369 7a65 293b 0a20  t, size=size);. 
-0001f2a0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-0001f2b0: 207d 0a20 2020 207d 0a20 207d 0a7d 0a0a   }.    }.  }.}..
-0001f2c0: 0a0a 2f2f 2053 6563 7469 6f6e 3a20 4d69  ..// Section: Mi
-0001f2d0: 7363 656c 6c61 6e65 6f75 730a 0a0a 2f2f  scellaneous...//
-0001f2e0: 204d 6f64 756c 653a 2069 6e74 6572 696f   Module: interio
-0001f2f0: 725f 6669 6c6c 6574 2829 0a2f 2f0a 2f2f  r_fillet().//.//
-0001f300: 2044 6573 6372 6970 7469 6f6e 3a0a 2f2f   Description:.//
-0001f310: 2020 2043 7265 6174 6573 2061 2073 6861     Creates a sha
-0001f320: 7065 2074 6861 7420 6361 6e20 6265 2075  pe that can be u
-0001f330: 6e69 6f6e 6564 2069 6e74 6f20 6120 636f  nioned into a co
-0001f340: 6e63 6176 6520 6a6f 696e 7420 6265 7477  ncave joint betw
-0001f350: 6565 6e20 7477 6f20 6661 6365 732c 2074  een two faces, t
-0001f360: 6f20 6669 6c6c 6574 2074 6865 6d2e 0a2f  o fillet them../
-0001f370: 2f20 2020 4365 6e74 6572 2074 6869 7320  /   Center this 
-0001f380: 7061 7274 2061 6c6f 6e67 2074 6865 2063  part along the c
-0001f390: 6f6e 6361 7665 2065 6467 6520 746f 2062  oncave edge to b
-0001f3a0: 6520 6368 616d 6665 7265 6420 616e 6420  e chamfered and 
-0001f3b0: 756e 696f 6e20 6974 2069 6e2e 0a2f 2f0a  union it in..//.
-0001f3c0: 2f2f 2055 7361 6765 3a20 5479 7069 6361  // Usage: Typica
-0001f3d0: 6c0a 2f2f 2020 2069 6e74 6572 696f 725f  l.//   interior_
-0001f3e0: 6669 6c6c 6574 286c 2c20 722c 205b 616e  fillet(l, r, [an
-0001f3f0: 675d 2c20 5b6f 7665 726c 6170 5d2c 202e  g], [overlap], .
-0001f400: 2e2e 2920 5b41 5454 4143 484d 454e 5453  ..) [ATTACHMENTS
-0001f410: 5d3b 0a2f 2f20 2020 696e 7465 7269 6f72  ];.//   interior
-0001f420: 5f66 696c 6c65 7428 6c2c 2064 3d2c 205b  _fillet(l, d=, [
-0001f430: 616e 673d 5d2c 205b 6f76 6572 6c61 703d  ang=], [overlap=
-0001f440: 5d2c 202e 2e2e 2920 5b41 5454 4143 484d  ], ...) [ATTACHM
-0001f450: 454e 5453 5d3b 0a2f 2f0a 2f2f 2041 7267  ENTS];.//.// Arg
-0001f460: 756d 656e 7473 3a0a 2f2f 2020 206c 203d  uments:.//   l =
-0001f470: 204c 656e 6774 6820 6f66 2065 6467 6520   Length of edge 
-0001f480: 746f 2066 696c 6c65 742e 0a2f 2f20 2020  to fillet..//   
-0001f490: 7220 3d20 5261 6469 7573 206f 6620 6669  r = Radius of fi
-0001f4a0: 6c6c 6574 2e0a 2f2f 2020 2061 6e67 203d  llet..//   ang =
-0001f4b0: 2041 6e67 6c65 2062 6574 7765 656e 2066   Angle between f
-0001f4c0: 6163 6573 2074 6f20 6669 6c6c 6574 2e0a  aces to fillet..
-0001f4d0: 2f2f 2020 206f 7665 726c 6170 203d 204f  //   overlap = O
-0001f4e0: 7665 726c 6170 2073 697a 6520 666f 7220  verlap size for 
-0001f4f0: 756e 696f 6e69 6e67 2077 6974 6820 6661  unioning with fa
-0001f500: 6365 732e 0a2f 2f20 2020 2d2d 2d0a 2f2f  ces..//   ---.//
-0001f510: 2020 2064 203d 2044 6961 6d65 7465 7220     d = Diameter 
-0001f520: 6f66 2066 696c 6c65 742e 0a2f 2f20 2020  of fillet..//   
-0001f530: 616e 6368 6f72 203d 2054 7261 6e73 6c61  anchor = Transla
-0001f540: 7465 2073 6f20 616e 6368 6f72 2070 6f69  te so anchor poi
-0001f550: 6e74 2069 7320 6174 206f 7269 6769 6e20  nt is at origin 
-0001f560: 2830 2c30 2c30 292e 2020 5365 6520 5b61  (0,0,0).  See [a
-0001f570: 6e63 686f 725d 2861 7474 6163 686d 656e  nchor](attachmen
-0001f580: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
-0001f590: 6f6e 2d61 6e63 686f 7229 2e20 2044 6566  on-anchor).  Def
-0001f5a0: 6175 6c74 3a20 6046 524f 4e54 2b4c 4546  ault: `FRONT+LEF
-0001f5b0: 5460 0a2f 2f20 2020 7370 696e 203d 2052  T`.//   spin = R
-0001f5c0: 6f74 6174 6520 7468 6973 206d 616e 7920  otate this many 
-0001f5d0: 6465 6772 6565 7320 6172 6f75 6e64 2074  degrees around t
-0001f5e0: 6865 205a 2061 7869 7320 6166 7465 7220  he Z axis after 
-0001f5f0: 616e 6368 6f72 2e20 2053 6565 205b 7370  anchor.  See [sp
-0001f600: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
-0001f610: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-0001f620: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
-0001f630: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
-0001f640: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
-0001f650: 6174 6520 746f 7020 746f 7761 7264 732c  ate top towards,
-0001f660: 2061 6674 6572 2073 7069 6e2e 2020 5365   after spin.  Se
-0001f670: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
-0001f680: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
-0001f690: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
-0001f6a0: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
-0001f6b0: 2f0a 2f2f 2045 7861 6d70 6c65 3a0a 2f2f  /.// Example:.//
-0001f6c0: 2020 2075 6e69 6f6e 2829 207b 0a2f 2f20     union() {.// 
-0001f6d0: 2020 2020 7472 616e 736c 6174 6528 5b30      translate([0
-0001f6e0: 2c32 2c2d 345d 290a 2f2f 2020 2020 2020  ,2,-4]).//      
-0001f6f0: 2063 7562 6528 5b32 302c 2034 2c20 3234   cube([20, 4, 24
-0001f700: 5d2c 2061 6e63 686f 723d 424f 5454 4f4d  ], anchor=BOTTOM
-0001f710: 293b 0a2f 2f20 2020 2020 7472 616e 736c  );.//     transl
-0001f720: 6174 6528 5b30 2c2d 3130 2c2d 345d 290a  ate([0,-10,-4]).
-0001f730: 2f2f 2020 2020 2020 2063 7562 6528 5b32  //       cube([2
-0001f740: 302c 2032 302c 2034 5d2c 2061 6e63 686f  0, 20, 4], ancho
-0001f750: 723d 424f 5454 4f4d 293b 0a2f 2f20 2020  r=BOTTOM);.//   
-0001f760: 2020 636f 6c6f 7228 2267 7265 656e 2229    color("green")
-0001f770: 0a2f 2f20 2020 2020 2020 696e 7465 7269  .//       interi
-0001f780: 6f72 5f66 696c 6c65 7428 0a2f 2f20 2020  or_fillet(.//   
-0001f790: 2020 2020 2020 6c3d 3230 2c20 723d 3130        l=20, r=10
-0001f7a0: 2c0a 2f2f 2020 2020 2020 2020 2073 7069  ,.//         spi
-0001f7b0: 6e3d 3138 302c 206f 7269 656e 743d 5249  n=180, orient=RI
-0001f7c0: 4748 540a 2f2f 2020 2020 2020 2029 3b0a  GHT.//       );.
-0001f7d0: 2f2f 2020 207d 0a2f 2f0a 2f2f 2045 7861  //   }.//.// Exa
-0001f7e0: 6d70 6c65 733a 0a2f 2f20 2020 696e 7465  mples:.//   inte
-0001f7f0: 7269 6f72 5f66 696c 6c65 7428 6c3d 3130  rior_fillet(l=10
-0001f800: 2c20 723d 3230 2c20 616e 673d 3630 293b  , r=20, ang=60);
-0001f810: 0a2f 2f20 2020 696e 7465 7269 6f72 5f66  .//   interior_f
-0001f820: 696c 6c65 7428 6c3d 3130 2c20 723d 3230  illet(l=10, r=20
-0001f830: 2c20 616e 673d 3930 293b 0a2f 2f20 2020  , ang=90);.//   
-0001f840: 696e 7465 7269 6f72 5f66 696c 6c65 7428  interior_fillet(
-0001f850: 6c3d 3130 2c20 723d 3230 2c20 616e 673d  l=10, r=20, ang=
-0001f860: 3132 3029 3b0a 2f2f 0a2f 2f20 4578 616d  120);.//.// Exam
-0001f870: 706c 653a 2055 7369 6e67 2077 6974 6820  ple: Using with 
-0001f880: 4174 7461 6368 6d65 6e74 730a 2f2f 2020  Attachments.//  
-0001f890: 2063 7562 6528 3530 2c63 656e 7465 723d   cube(50,center=
-0001f8a0: 7472 7565 2920 7b0a 2f2f 2020 2020 2070  true) {.//     p
-0001f8b0: 6f73 6974 696f 6e28 4652 4f4e 542b 4c45  osition(FRONT+LE
-0001f8c0: 4654 290a 2f2f 2020 2020 2020 2069 6e74  FT).//       int
-0001f8d0: 6572 696f 725f 6669 6c6c 6574 286c 3d35  erior_fillet(l=5
-0001f8e0: 302c 2072 3d31 302c 2073 7069 6e3d 2d39  0, r=10, spin=-9
-0001f8f0: 3029 3b0a 2f2f 2020 2020 2070 6f73 6974  0);.//     posit
-0001f900: 696f 6e28 424f 542b 4652 4f4e 5429 0a2f  ion(BOT+FRONT)./
-0001f910: 2f20 2020 2020 2020 696e 7465 7269 6f72  /       interior
-0001f920: 5f66 696c 6c65 7428 6c3d 3530 2c20 723d  _fillet(l=50, r=
-0001f930: 3130 2c20 7370 696e 3d31 3830 2c20 6f72  10, spin=180, or
-0001f940: 6965 6e74 3d52 4947 4854 293b 0a2f 2f20  ient=RIGHT);.// 
-0001f950: 2020 7d0a 6d6f 6475 6c65 2069 6e74 6572    }.module inter
-0001f960: 696f 725f 6669 6c6c 6574 286c 3d31 2e30  ior_fillet(l=1.0
-0001f970: 2c20 722c 2061 6e67 3d39 302c 206f 7665  , r, ang=90, ove
-0001f980: 726c 6170 3d30 2e30 312c 2064 2c20 616e  rlap=0.01, d, an
-0001f990: 6368 6f72 3d43 454e 5445 522c 2073 7069  chor=CENTER, spi
-0001f9a0: 6e3d 302c 206f 7269 656e 743d 5550 2920  n=0, orient=UP) 
-0001f9b0: 7b0a 2020 2020 7220 3d20 6765 745f 7261  {.    r = get_ra
-0001f9c0: 6469 7573 2872 3d72 2c20 643d 642c 2064  dius(r=r, d=d, d
-0001f9d0: 666c 743d 3129 3b0a 2020 2020 7374 6570  flt=1);.    step
-0001f9e0: 7320 3d20 6365 696c 2873 6567 7328 7229  s = ceil(segs(r)
-0001f9f0: 2a28 3138 302d 616e 6729 2f33 3630 293b  *(180-ang)/360);
-0001fa00: 0a20 2020 2061 7263 203d 2061 7263 286e  .    arc = arc(n
-0001fa10: 3d73 7465 7073 2b31 2c20 723d 722c 2063  =steps+1, r=r, c
-0001fa20: 6f72 6e65 723d 5b70 6f6c 6172 5f74 6f5f  orner=[polar_to_
-0001fa30: 7879 2872 2c61 6e67 292c 5b30 2c30 5d2c  xy(r,ang),[0,0],
-0001fa40: 5b72 2c30 5d5d 293b 0a20 2020 206d 6178  [r,0]]);.    max
-0001fa50: 7820 3d20 6c61 7374 2861 7263 292e 783b  x = last(arc).x;
-0001fa60: 0a20 2020 206d 6178 7920 3d20 6172 635b  .    maxy = arc[
-0001fa70: 305d 2e79 3b0a 2020 2020 7061 7468 203d  0].y;.    path =
-0001fa80: 205b 0a20 2020 2020 2020 205b 6d61 7878   [.        [maxx
-0001fa90: 2c20 2d6f 7665 726c 6170 5d2c 0a20 2020  , -overlap],.   
-0001faa0: 2020 2020 2070 6f6c 6172 5f74 6f5f 7879       polar_to_xy
-0001fab0: 286f 7665 726c 6170 2c20 3138 302b 616e  (overlap, 180+an
-0001fac0: 672f 3229 2c0a 2020 2020 2020 2020 6172  g/2),.        ar
-0001fad0: 635b 305d 202b 2070 6f6c 6172 5f74 6f5f  c[0] + polar_to_
-0001fae0: 7879 286f 7665 726c 6170 2c20 3930 2b61  xy(overlap, 90+a
-0001faf0: 6e67 292c 0a20 2020 2020 2020 2065 6163  ng),.        eac
-0001fb00: 6820 6172 630a 2020 2020 5d3b 0a20 2020  h arc.    ];.   
-0001fb10: 2061 7474 6163 6861 626c 6528 616e 6368   attachable(anch
-0001fb20: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
-0001fb30: 7369 7a65 3d5b 322a 6d61 7878 2c32 2a6d  size=[2*maxx,2*m
-0001fb40: 6178 792c 6c5d 2920 7b0a 2020 2020 2020  axy,l]) {.      
-0001fb50: 2020 6966 2028 6c20 3e20 3029 207b 0a20    if (l > 0) {. 
-0001fb60: 2020 2020 2020 2020 2020 206c 696e 6561             linea
-0001fb70: 725f 6578 7472 7564 6528 6865 6967 6874  r_extrude(height
-0001fb80: 3d6c 2c20 636f 6e76 6578 6974 793d 342c  =l, convexity=4,
-0001fb90: 2063 656e 7465 723d 7472 7565 2920 7b0a   center=true) {.
-0001fba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fbb0: 706f 6c79 676f 6e28 7061 7468 293b 0a20  polygon(path);. 
-0001fbc0: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-0001fbd0: 2020 2020 207d 0a20 2020 2020 2020 2063       }.        c
-0001fbe0: 6869 6c64 7265 6e28 293b 0a20 2020 207d  hildren();.    }
-0001fbf0: 0a7d 0a0a 0a2f 2f20 4675 6e63 7469 6f6e  .}...// Function
-0001fc00: 264d 6f64 756c 653a 2068 6569 6768 7466  &Module: heightf
-0001fc10: 6965 6c64 2829 0a2f 2f20 5573 6167 653a  ield().// Usage:
-0001fc20: 2041 7320 4d6f 6475 6c65 0a2f 2f20 2020   As Module.//   
-0001fc30: 6865 6967 6874 6669 656c 6428 6461 7461  heightfield(data
-0001fc40: 2c20 5b73 697a 655d 2c20 5b62 6f74 746f  , [size], [botto
-0001fc50: 6d5d 2c20 5b6d 6178 7a5d 2c20 5b78 7261  m], [maxz], [xra
-0001fc60: 6e67 655d 2c20 5b79 7261 6e67 655d 2c20  nge], [yrange], 
-0001fc70: 5b73 7479 6c65 5d2c 205b 636f 6e76 6578  [style], [convex
-0001fc80: 6974 795d 2c20 2e2e 2e29 205b 4154 5441  ity], ...) [ATTA
-0001fc90: 4348 4d45 4e54 535d 3b0a 2f2f 2055 7361  CHMENTS];.// Usa
-0001fca0: 6765 3a20 4173 2046 756e 6374 696f 6e0a  ge: As Function.
-0001fcb0: 2f2f 2020 2076 6e66 203d 2068 6569 6768  //   vnf = heigh
-0001fcc0: 7466 6965 6c64 2864 6174 612c 205b 7369  tfield(data, [si
-0001fcd0: 7a65 5d2c 205b 626f 7474 6f6d 5d2c 205b  ze], [bottom], [
-0001fce0: 6d61 787a 5d2c 205b 7872 616e 6765 5d2c  maxz], [xrange],
-0001fcf0: 205b 7972 616e 6765 5d2c 205b 7374 796c   [yrange], [styl
-0001fd00: 655d 2c20 2e2e 2e29 3b0a 2f2f 2054 6f70  e], ...);.// Top
-0001fd10: 6963 733a 2054 6578 7475 7265 732c 2048  ics: Textures, H
-0001fd20: 6569 6768 7466 6965 6c64 0a2f 2f20 4465  eightfield.// De
-0001fd30: 7363 7269 7074 696f 6e3a 0a2f 2f20 2020  scription:.//   
-0001fd40: 4769 7665 6e20 6120 7265 6775 6c61 7220  Given a regular 
-0001fd50: 7265 6374 616e 6775 6c61 7220 3244 2067  rectangular 2D g
-0001fd60: 7269 6420 6f66 2073 6361 6c61 7220 7661  rid of scalar va
-0001fd70: 6c75 6573 2c20 6f72 2061 2066 756e 6374  lues, or a funct
-0001fd80: 696f 6e20 6c69 7465 7261 6c2c 2067 656e  ion literal, gen
-0001fd90: 6572 6174 6573 2061 2033 440a 2f2f 2020  erates a 3D.//  
-0001fda0: 2073 7572 6661 6365 2077 6865 7265 2074   surface where t
-0001fdb0: 6865 2068 6569 6768 7420 6174 2061 6e79  he height at any
-0001fdc0: 2067 6976 656e 2070 6f69 6e74 2069 7320   given point is 
-0001fdd0: 7468 6520 7363 616c 6172 2076 616c 7565  the scalar value
-0001fde0: 2066 6f72 2074 6861 7420 706f 7369 7469   for that positi
-0001fdf0: 6f6e 2e0a 2f2f 2020 204f 6e65 2073 6372  on..//   One scr
-0001fe00: 6970 7420 746f 2063 6f6e 7665 7274 2061  ipt to convert a
-0001fe10: 2067 7261 7973 6361 6c65 2069 6d61 6765   grayscale image
-0001fe20: 2074 6f20 6120 6865 6967 6874 6669 656c   to a heightfiel
-0001fe30: 6420 6172 7261 7920 696e 2061 202e 7363  d array in a .sc
-0001fe40: 6164 2066 696c 6520 6361 6e20 6265 2066  ad file can be f
-0001fe50: 6f75 6e64 2061 743a 0a2f 2f20 2020 6874  ound at:.//   ht
-0001fe60: 7470 733a 2f2f 7261 772e 6769 7468 7562  tps://raw.github
-0001fe70: 7573 6572 636f 6e74 656e 742e 636f 6d2f  usercontent.com/
-0001fe80: 7265 7661 7262 6174 2f42 4f53 4c32 2f6d  revarbat/BOSL2/m
-0001fe90: 6173 7465 722f 7363 7269 7074 732f 696d  aster/scripts/im
-0001fea0: 6732 7363 6164 2e70 790a 2f2f 2041 7267  g2scad.py.// Arg
-0001feb0: 756d 656e 7473 3a0a 2f2f 2020 2064 6174  uments:.//   dat
-0001fec0: 6120 3d20 5468 6973 2069 7320 6569 7468  a = This is eith
-0001fed0: 6572 2074 6865 2032 4420 7265 6374 616e  er the 2D rectan
-0001fee0: 6775 6c61 7220 6172 7261 7920 6f66 2068  gular array of h
-0001fef0: 6569 6768 7473 2c20 6f72 2061 2066 756e  eights, or a fun
-0001ff00: 6374 696f 6e20 6c69 7465 7261 6c20 7468  ction literal th
-0001ff10: 6174 2074 616b 6573 2058 2061 6e64 2059  at takes X and Y
-0001ff20: 2061 7267 756d 656e 7473 2e0a 2f2f 2020   arguments..//  
-0001ff30: 2073 697a 6520 3d20 5468 6520 5b58 2c59   size = The [X,Y
-0001ff40: 5d20 7369 7a65 206f 6620 7468 6520 7375  ] size of the su
-0001ff50: 7266 6163 6520 746f 2063 7265 6174 652e  rface to create.
-0001ff60: 2020 4966 2067 6976 656e 2061 7320 6120    If given as a 
-0001ff70: 7363 616c 6172 2c20 7573 6520 6974 2066  scalar, use it f
-0001ff80: 6f72 2062 6f74 6820 5820 616e 6420 5920  or both X and Y 
-0001ff90: 7369 7a65 732e 2044 6566 6175 6c74 3a20  sizes. Default: 
-0001ffa0: 605b 3130 302c 3130 305d 600a 2f2f 2020  `[100,100]`.//  
-0001ffb0: 2062 6f74 746f 6d20 3d20 5468 6520 5a20   bottom = The Z 
-0001ffc0: 636f 6f72 6469 6e61 7465 2066 6f72 2074  coordinate for t
-0001ffd0: 6865 2062 6f74 746f 6d20 6f66 2074 6865  he bottom of the
-0001ffe0: 2068 6569 6768 7466 6965 6c64 206f 626a   heightfield obj
-0001fff0: 6563 7420 746f 2063 7265 6174 652e 2020  ect to create.  
-00020000: 416e 7920 6865 6967 6874 7320 6c6f 7765  Any heights lowe
-00020010: 7220 7468 616e 2074 6869 7320 7769 6c6c  r than this will
-00020020: 2062 6520 7472 756e 6361 7465 6420 746f   be truncated to
-00020030: 2076 6572 7920 736c 6967 6874 6c79 2061   very slightly a
-00020040: 626f 7665 2074 6869 7320 6865 6967 6874  bove this height
-00020050: 2e20 2044 6566 6175 6c74 3a20 2d32 300a  .  Default: -20.
-00020060: 2f2f 2020 206d 6178 7a20 3d20 5468 6520  //   maxz = The 
-00020070: 6d61 7869 6d75 6d20 6865 6967 6874 2074  maximum height t
-00020080: 6f20 6d6f 6465 6c2e 2020 5472 756e 6361  o model.  Trunca
-00020090: 7465 7320 616e 7974 6869 6e67 2074 616c  tes anything tal
-000200a0: 6c65 7220 746f 2074 6869 7320 6865 6967  ler to this heig
-000200b0: 6874 2e20 2044 6566 6175 6c74 3a20 3939  ht.  Default: 99
-000200c0: 0a2f 2f20 2020 7872 616e 6765 203d 2041  .//   xrange = A
-000200d0: 2072 616e 6765 206f 6620 7661 6c75 6573   range of values
-000200e0: 2074 6f20 6974 6572 6174 6520 5820 6f76   to iterate X ov
-000200f0: 6572 2077 6865 6e20 6361 6c63 756c 6174  er when calculat
-00020100: 696e 6720 6120 7375 7266 6163 6520 6672  ing a surface fr
-00020110: 6f6d 2061 2066 756e 6374 696f 6e20 6c69  om a function li
-00020120: 7465 7261 6c2e 2020 4465 6661 756c 743a  teral.  Default:
-00020130: 205b 2d31 203a 2030 2e30 3120 3a20 315d   [-1 : 0.01 : 1]
-00020140: 0a2f 2f20 2020 7972 616e 6765 203d 2041  .//   yrange = A
-00020150: 2072 616e 6765 206f 6620 7661 6c75 6573   range of values
-00020160: 2074 6f20 6974 6572 6174 6520 5920 6f76   to iterate Y ov
-00020170: 6572 2077 6865 6e20 6361 6c63 756c 6174  er when calculat
-00020180: 696e 6720 6120 7375 7266 6163 6520 6672  ing a surface fr
-00020190: 6f6d 2061 2066 756e 6374 696f 6e20 6c69  om a function li
-000201a0: 7465 7261 6c2e 2020 4465 6661 756c 743a  teral.  Default:
-000201b0: 205b 2d31 203a 2030 2e30 3120 3a20 315d   [-1 : 0.01 : 1]
-000201c0: 0a2f 2f20 2020 7374 796c 6520 3d20 5468  .//   style = Th
-000201d0: 6520 7374 796c 6520 6f66 2073 7562 6469  e style of subdi
-000201e0: 7669 6469 6e67 2074 6865 2071 7561 6473  viding the quads
-000201f0: 2069 6e74 6f20 6661 6365 732e 2020 5661   into faces.  Va
-00020200: 6c69 6420 6f70 7469 6f6e 7320 6172 6520  lid options are 
-00020210: 2264 6566 6175 6c74 222c 2022 616c 7422  "default", "alt"
-00020220: 2c20 616e 6420 2271 7569 6e63 756e 7822  , and "quincunx"
-00020230: 2e20 2044 6566 6175 6c74 3a20 2264 6566  .  Default: "def
-00020240: 6175 6c74 220a 2f2f 2020 202d 2d2d 0a2f  ault".//   ---./
-00020250: 2f20 2020 636f 6e76 6578 6974 7920 3d20  /   convexity = 
-00020260: 4d61 7820 6e75 6d62 6572 206f 6620 7469  Max number of ti
-00020270: 6d65 7320 6120 6c69 6e65 2063 6f75 6c64  mes a line could
-00020280: 2069 6e74 6572 7365 6374 2061 2077 616c   intersect a wal
-00020290: 6c20 6f66 2074 6865 2073 7572 6661 6365  l of the surface
-000202a0: 2062 6569 6e67 2066 6f72 6d65 642e 204d   being formed. M
-000202b0: 6f64 756c 6520 6f6e 6c79 2e20 2044 6566  odule only.  Def
-000202c0: 6175 6c74 3a20 3130 0a2f 2f20 2020 616e  ault: 10.//   an
-000202d0: 6368 6f72 203d 2054 7261 6e73 6c61 7465  chor = Translate
-000202e0: 2073 6f20 616e 6368 6f72 2070 6f69 6e74   so anchor point
-000202f0: 2069 7320 6174 206f 7269 6769 6e20 2830   is at origin (0
-00020300: 2c30 2c30 292e 2020 5365 6520 5b61 6e63  ,0,0).  See [anc
-00020310: 686f 725d 2861 7474 6163 686d 656e 7473  hor](attachments
-00020320: 2e73 6361 6423 7375 6273 6563 7469 6f6e  .scad#subsection
-00020330: 2d61 6e63 686f 7229 2e20 2044 6566 6175  -anchor).  Defau
-00020340: 6c74 3a20 6043 454e 5445 5260 0a2f 2f20  lt: `CENTER`.// 
-00020350: 2020 7370 696e 203d 2052 6f74 6174 6520    spin = Rotate 
-00020360: 7468 6973 206d 616e 7920 6465 6772 6565  this many degree
-00020370: 7320 6172 6f75 6e64 2074 6865 205a 2061  s around the Z a
-00020380: 7869 732e 2020 5365 6520 5b73 7069 6e5d  xis.  See [spin]
-00020390: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-000203a0: 6423 7375 6273 6563 7469 6f6e 2d73 7069  d#subsection-spi
-000203b0: 6e29 2e20 2044 6566 6175 6c74 3a20 6030  n).  Default: `0
-000203c0: 600a 2f2f 2020 206f 7269 656e 7420 3d20  `.//   orient = 
-000203d0: 5665 6374 6f72 2074 6f20 726f 7461 7465  Vector to rotate
-000203e0: 2074 6f70 2074 6f77 6172 6473 2e20 2053   top towards.  S
-000203f0: 6565 205b 6f72 6965 6e74 5d28 6174 7461  ee [orient](atta
-00020400: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
-00020410: 7365 6374 696f 6e2d 6f72 6965 6e74 292e  section-orient).
-00020420: 2020 4465 6661 756c 743a 2060 5550 600a    Default: `UP`.
-00020430: 2f2f 2053 6565 2041 6c73 6f3a 2068 6569  // See Also: hei
-00020440: 6768 7466 6965 6c64 2829 2c20 6379 6c69  ghtfield(), cyli
-00020450: 6e64 7269 6361 6c5f 6865 6967 6874 6669  ndrical_heightfi
-00020460: 656c 6428 292c 2074 6578 7475 7265 645f  eld(), textured_
-00020470: 7265 766f 6c75 7469 6f6e 2829 2c20 7465  revolution(), te
-00020480: 7874 7572 6564 5f63 796c 696e 6465 7228  xtured_cylinder(
-00020490: 292c 2074 6578 7475 7265 645f 6c69 6e65  ), textured_line
-000204a0: 6172 5f73 7765 6570 2829 0a2f 2f20 4578  ar_sweep().// Ex
-000204b0: 616d 706c 653a 0a2f 2f20 2020 6865 6967  ample:.//   heig
-000204c0: 6874 6669 656c 6428 7369 7a65 3d5b 3130  htfield(size=[10
-000204d0: 302c 3130 305d 2c20 626f 7474 6f6d 3d2d  0,100], bottom=-
-000204e0: 3230 2c20 6461 7461 3d5b 0a2f 2f20 2020  20, data=[.//   
-000204f0: 2020 2020 666f 7220 2879 3d5b 2d31 3830      for (y=[-180
-00020500: 3a34 3a31 3830 5d29 205b 0a2f 2f20 2020  :4:180]) [.//   
-00020510: 2020 2020 2020 2020 666f 7228 783d 5b2d          for(x=[-
-00020520: 3138 303a 343a 3138 305d 290a 2f2f 2020  180:4:180]).//  
-00020530: 2020 2020 2020 2020 2031 302a 636f 7328           10*cos(
-00020540: 332a 6e6f 726d 285b 782c 795d 2929 0a2f  3*norm([x,y]))./
-00020550: 2f20 2020 2020 2020 5d0a 2f2f 2020 205d  /       ].//   ]
-00020560: 293b 0a2f 2f20 4578 616d 706c 653a 0a2f  );.// Example:./
-00020570: 2f20 2020 696e 7465 7273 6563 7469 6f6e  /   intersection
-00020580: 2829 207b 0a2f 2f20 2020 2020 2020 6865  () {.//       he
-00020590: 6967 6874 6669 656c 6428 7369 7a65 3d5b  ightfield(size=[
-000205a0: 3130 302c 3130 305d 2c20 6461 7461 3d5b  100,100], data=[
-000205b0: 0a2f 2f20 2020 2020 2020 2020 2020 666f  .//           fo
-000205c0: 7220 2879 3d5b 2d31 3830 3a35 3a31 3830  r (y=[-180:5:180
-000205d0: 5d29 205b 0a2f 2f20 2020 2020 2020 2020  ]) [.//         
-000205e0: 2020 2020 2020 666f 7228 783d 5b2d 3138        for(x=[-18
-000205f0: 303a 353a 3138 305d 290a 2f2f 2020 2020  0:5:180]).//    
-00020600: 2020 2020 2020 2020 2020 2031 302b 352a             10+5*
-00020610: 636f 7328 332a 7829 2a73 696e 2833 2a79  cos(3*x)*sin(3*y
-00020620: 290a 2f2f 2020 2020 2020 2020 2020 205d  ).//           ]
-00020630: 0a2f 2f20 2020 2020 2020 5d29 3b0a 2f2f  .//       ]);.//
-00020640: 2020 2020 2020 2063 796c 696e 6465 7228         cylinder(
-00020650: 683d 3530 2c64 3d31 3030 293b 0a2f 2f20  h=50,d=100);.// 
-00020660: 2020 7d0a 2f2f 2045 7861 6d70 6c65 3a20    }.// Example: 
-00020670: 4865 6967 6874 6669 656c 6420 6279 2046  Heightfield by F
-00020680: 756e 6374 696f 6e0a 2f2f 2020 2066 6e20  unction.//   fn 
-00020690: 3d20 6675 6e63 7469 6f6e 2028 782c 7929  = function (x,y)
-000206a0: 2031 302a 7369 6e28 782a 3336 3029 2a63   10*sin(x*360)*c
-000206b0: 6f73 2879 2a33 3630 293b 0a2f 2f20 2020  os(y*360);.//   
-000206c0: 6865 6967 6874 6669 656c 6428 7369 7a65  heightfield(size
-000206d0: 3d5b 3130 302c 3130 305d 2c20 6461 7461  =[100,100], data
-000206e0: 3d66 6e29 3b0a 2f2f 2045 7861 6d70 6c65  =fn);.// Example
-000206f0: 3a20 4865 6967 6874 6669 656c 6420 6279  : Heightfield by
-00020700: 2046 756e 6374 696f 6e2c 2077 6974 6820   Function, with 
-00020710: 5370 6563 6966 6963 2052 616e 6765 730a  Specific Ranges.
-00020720: 2f2f 2020 2066 6e20 3d20 6675 6e63 7469  //   fn = functi
-00020730: 6f6e 2028 782c 7929 2032 2a63 6f73 2835  on (x,y) 2*cos(5
-00020740: 2a6e 6f72 6d28 5b78 2c79 5d29 293b 0a2f  *norm([x,y]));./
-00020750: 2f20 2020 6865 6967 6874 6669 656c 6428  /   heightfield(
-00020760: 0a2f 2f20 2020 2020 2020 7369 7a65 3d5b  .//       size=[
-00020770: 3130 302c 3130 305d 2c20 626f 7474 6f6d  100,100], bottom
-00020780: 3d2d 3230 2c20 6461 7461 3d66 6e2c 0a2f  =-20, data=fn,./
-00020790: 2f20 2020 2020 2020 7872 616e 6765 3d5b  /       xrange=[
-000207a0: 2d31 3830 3a32 3a31 3830 5d2c 2079 7261  -180:2:180], yra
-000207b0: 6e67 653d 5b2d 3138 303a 323a 3138 305d  nge=[-180:2:180]
-000207c0: 0a2f 2f20 2020 293b 0a6d 6f64 756c 6520  .//   );.module 
-000207d0: 6865 6967 6874 6669 656c 6428 6461 7461  heightfield(data
-000207e0: 2c20 7369 7a65 3d5b 3130 302c 3130 305d  , size=[100,100]
-000207f0: 2c20 626f 7474 6f6d 3d2d 3230 2c20 6d61  , bottom=-20, ma
-00020800: 787a 3d31 3030 2c20 7872 616e 6765 3d5b  xz=100, xrange=[
-00020810: 2d31 3a30 2e30 343a 315d 2c20 7972 616e  -1:0.04:1], yran
-00020820: 6765 3d5b 2d31 3a30 2e30 343a 315d 2c20  ge=[-1:0.04:1], 
-00020830: 7374 796c 653d 2264 6566 6175 6c74 222c  style="default",
-00020840: 2063 6f6e 7665 7869 7479 3d31 302c 2061   convexity=10, a
-00020850: 6e63 686f 723d 4345 4e54 4552 2c20 7370  nchor=CENTER, sp
-00020860: 696e 3d30 2c20 6f72 6965 6e74 3d55 5029  in=0, orient=UP)
-00020870: 0a7b 0a20 2020 2073 697a 6520 3d20 6973  .{.    size = is
-00020880: 5f6e 756d 2873 697a 6529 3f20 5b73 697a  _num(size)? [siz
-00020890: 652c 7369 7a65 5d20 3a20 706f 696e 7432  e,size] : point2
-000208a0: 6428 7369 7a65 293b 0a20 2020 2076 6e66  d(size);.    vnf
-000208b0: 203d 2068 6569 6768 7466 6965 6c64 2864   = heightfield(d
-000208c0: 6174 613d 6461 7461 2c20 7369 7a65 3d73  ata=data, size=s
-000208d0: 697a 652c 2078 7261 6e67 653d 7872 616e  ize, xrange=xran
-000208e0: 6765 2c20 7972 616e 6765 3d79 7261 6e67  ge, yrange=yrang
-000208f0: 652c 2062 6f74 746f 6d3d 626f 7474 6f6d  e, bottom=bottom
-00020900: 2c20 6d61 787a 3d6d 6178 7a2c 2073 7479  , maxz=maxz, sty
-00020910: 6c65 3d73 7479 6c65 293b 0a20 2020 2061  le=style);.    a
-00020920: 7474 6163 6861 626c 6528 616e 6368 6f72  ttachable(anchor
-00020930: 2c73 7069 6e2c 6f72 6965 6e74 2c20 766e  ,spin,orient, vn
-00020940: 663d 766e 6629 207b 0a20 2020 2020 2020  f=vnf) {.       
-00020950: 2076 6e66 5f70 6f6c 7968 6564 726f 6e28   vnf_polyhedron(
-00020960: 766e 662c 2063 6f6e 7665 7869 7479 3d63  vnf, convexity=c
-00020970: 6f6e 7665 7869 7479 293b 0a20 2020 2020  onvexity);.     
-00020980: 2020 2063 6869 6c64 7265 6e28 293b 0a20     children();. 
-00020990: 2020 207d 0a7d 0a0a 0a66 756e 6374 696f     }.}...functio
-000209a0: 6e20 6865 6967 6874 6669 656c 6428 6461  n heightfield(da
-000209b0: 7461 2c20 7369 7a65 3d5b 3130 302c 3130  ta, size=[100,10
-000209c0: 305d 2c20 626f 7474 6f6d 3d2d 3230 2c20  0], bottom=-20, 
-000209d0: 6d61 787a 3d31 3030 2c20 7872 616e 6765  maxz=100, xrange
-000209e0: 3d5b 2d31 3a30 2e30 343a 315d 2c20 7972  =[-1:0.04:1], yr
-000209f0: 616e 6765 3d5b 2d31 3a30 2e30 343a 315d  ange=[-1:0.04:1]
-00020a00: 2c20 7374 796c 653d 2264 6566 6175 6c74  , style="default
-00020a10: 222c 2061 6e63 686f 723d 4345 4e54 4552  ", anchor=CENTER
-00020a20: 2c20 7370 696e 3d30 2c20 6f72 6965 6e74  , spin=0, orient
-00020a30: 3d55 5029 203d 0a20 2020 2061 7373 6572  =UP) =.    asser
-00020a40: 7428 6973 5f6c 6973 7428 6461 7461 2920  t(is_list(data) 
-00020a50: 7c7c 2069 735f 6675 6e63 7469 6f6e 2864  || is_function(d
-00020a60: 6174 6129 290a 2020 2020 6c65 7428 0a20  ata)).    let(. 
-00020a70: 2020 2020 2020 2073 697a 6520 3d20 6973         size = is
-00020a80: 5f6e 756d 2873 697a 6529 3f20 5b73 697a  _num(size)? [siz
-00020a90: 652c 7369 7a65 5d20 3a20 706f 696e 7432  e,size] : point2
-00020aa0: 6428 7369 7a65 292c 0a20 2020 2020 2020  d(size),.       
-00020ab0: 2078 7661 6c73 203d 2069 735f 6c69 7374   xvals = is_list
-00020ac0: 2864 6174 6129 0a20 2020 2020 2020 2020  (data).         
-00020ad0: 203f 205b 666f 7220 2869 3d69 6478 2864   ? [for (i=idx(d
-00020ae0: 6174 615b 305d 2929 2069 5d0a 2020 2020  ata[0])) i].    
-00020af0: 2020 2020 2020 3a20 6173 7365 7274 2869        : assert(i
-00020b00: 735f 6c69 7374 2878 7261 6e67 6529 7c7c  s_list(xrange)||
-00020b10: 6973 5f72 616e 6765 2878 7261 6e67 6529  is_range(xrange)
-00020b20: 2920 5b66 6f72 2028 783d 7872 616e 6765  ) [for (x=xrange
-00020b30: 2920 785d 2c0a 2020 2020 2020 2020 7976  ) x],.        yv
-00020b40: 616c 7320 3d20 6973 5f6c 6973 7428 6461  als = is_list(da
-00020b50: 7461 290a 2020 2020 2020 2020 2020 3f20  ta).          ? 
-00020b60: 5b66 6f72 2028 693d 6964 7828 6461 7461  [for (i=idx(data
-00020b70: 2929 2069 5d0a 2020 2020 2020 2020 2020  )) i].          
-00020b80: 3a20 6173 7365 7274 2869 735f 6c69 7374  : assert(is_list
-00020b90: 2879 7261 6e67 6529 7c7c 6973 5f72 616e  (yrange)||is_ran
-00020ba0: 6765 2879 7261 6e67 6529 2920 5b66 6f72  ge(yrange)) [for
-00020bb0: 2028 793d 7972 616e 6765 2920 795d 2c0a   (y=yrange) y],.
-00020bc0: 2020 2020 2020 2020 7863 6e74 203d 206c          xcnt = l
-00020bd0: 656e 2878 7661 6c73 292c 0a20 2020 2020  en(xvals),.     
-00020be0: 2020 206d 696e 7820 3d20 6d69 6e28 7876     minx = min(xv
-00020bf0: 616c 7329 2c0a 2020 2020 2020 2020 6d61  als),.        ma
-00020c00: 7878 203d 206d 6178 2878 7661 6c73 292c  xx = max(xvals),
-00020c10: 0a20 2020 2020 2020 2079 636e 7420 3d20  .        ycnt = 
-00020c20: 6c65 6e28 7976 616c 7329 2c0a 2020 2020  len(yvals),.    
-00020c30: 2020 2020 6d69 6e79 203d 206d 696e 2879      miny = min(y
-00020c40: 7661 6c73 292c 0a20 2020 2020 2020 206d  vals),.        m
-00020c50: 6178 7920 3d20 6d61 7828 7976 616c 7329  axy = max(yvals)
-00020c60: 2c0a 2020 2020 2020 2020 7665 7274 7320  ,.        verts 
-00020c70: 3d20 6973 5f6c 6973 7428 6461 7461 2920  = is_list(data) 
-00020c80: 3f20 5b0a 2020 2020 2020 2020 2020 2020  ? [.            
-00020c90: 2020 2020 666f 7220 2879 203d 205b 303a      for (y = [0:
-00020ca0: 313a 7963 6e74 2d31 5d29 205b 0a20 2020  1:ycnt-1]) [.   
-00020cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020cc0: 2066 6f72 2028 7820 3d20 5b30 3a31 3a78   for (x = [0:1:x
-00020cd0: 636e 742d 315d 2920 5b0a 2020 2020 2020  cnt-1]) [.      
-00020ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020cf0: 2020 7369 7a65 2e78 202a 2028 782f 2878    size.x * (x/(x
-00020d00: 636e 742d 3129 2d30 2e35 292c 0a20 2020  cnt-1)-0.5),.   
-00020d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020d20: 2020 2020 2073 697a 652e 7920 2a20 2879       size.y * (y
-00020d30: 2f28 7963 6e74 2d31 292d 302e 3529 2c0a  /(ycnt-1)-0.5),.
-00020d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020d50: 2020 2020 2020 2020 6461 7461 5b79 5d5b          data[y][
-00020d60: 785d 0a20 2020 2020 2020 2020 2020 2020  x].             
-00020d70: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
-00020d80: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
-00020d90: 2020 2020 2020 205d 203a 205b 0a20 2020         ] : [.   
-00020da0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00020db0: 2028 7920 3d20 7972 616e 6765 2920 5b0a   (y = yrange) [.
-00020dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020dd0: 2020 2020 666f 7220 2878 203d 2078 7261      for (x = xra
-00020de0: 6e67 6529 206c 6574 280a 2020 2020 2020  nge) let(.      
-00020df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020e00: 2020 7a20 3d20 6461 7461 2878 2c79 290a    z = data(x,y).
-00020e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020e20: 2020 2020 2920 5b0a 2020 2020 2020 2020      ) [.        
-00020e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020e40: 7369 7a65 2e78 202a 2028 2878 2d6d 696e  size.x * ((x-min
-00020e50: 7829 2f28 6d61 7878 2d6d 696e 7829 2d30  x)/(maxx-minx)-0
-00020e60: 2e35 292c 0a20 2020 2020 2020 2020 2020  .5),.           
-00020e70: 2020 2020 2020 2020 2020 2020 2073 697a               siz
-00020e80: 652e 7920 2a20 2828 792d 6d69 6e79 292f  e.y * ((y-miny)/
-00020e90: 286d 6178 792d 6d69 6e79 292d 302e 3529  (maxy-miny)-0.5)
-00020ea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00020eb0: 2020 2020 2020 2020 2020 6d69 6e28 6d61            min(ma
-00020ec0: 787a 2c20 6d61 7828 626f 7474 6f6d 2b30  xz, max(bottom+0
-00020ed0: 2e31 2c20 6465 6661 756c 7428 7a2c 3029  .1, default(z,0)
-00020ee0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00020ef0: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
-00020f00: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
-00020f10: 2020 2020 2020 205d 2c0a 2020 2020 2020         ],.      
-00020f20: 2020 766e 6620 3d20 766e 665f 6a6f 696e    vnf = vnf_join
-00020f30: 285b 0a20 2020 2020 2020 2020 2020 2076  ([.            v
-00020f40: 6e66 5f76 6572 7465 785f 6172 7261 7928  nf_vertex_array(
-00020f50: 7665 7274 732c 2073 7479 6c65 3d73 7479  verts, style=sty
-00020f60: 6c65 2c20 7265 7665 7273 653d 7472 7565  le, reverse=true
-00020f70: 292c 0a20 2020 2020 2020 2020 2020 2076  ),.            v
-00020f80: 6e66 5f76 6572 7465 785f 6172 7261 7928  nf_vertex_array(
-00020f90: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
-00020fa0: 2020 7665 7274 735b 305d 2c0a 2020 2020    verts[0],.    
-00020fb0: 2020 2020 2020 2020 2020 2020 5b66 6f72              [for
-00020fc0: 2028 763d 7665 7274 735b 305d 2920 5b76   (v=verts[0]) [v
-00020fd0: 2e78 2c20 762e 792c 2062 6f74 746f 6d5d  .x, v.y, bottom]
-00020fe0: 5d2c 0a20 2020 2020 2020 2020 2020 205d  ],.            ]
-00020ff0: 292c 0a20 2020 2020 2020 2020 2020 2076  ),.            v
-00021000: 6e66 5f76 6572 7465 785f 6172 7261 7928  nf_vertex_array(
-00021010: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
-00021020: 2020 5b66 6f72 2028 763d 7665 7274 735b    [for (v=verts[
-00021030: 7963 6e74 2d31 5d29 205b 762e 782c 2076  ycnt-1]) [v.x, v
-00021040: 2e79 2c20 626f 7474 6f6d 5d5d 2c0a 2020  .y, bottom]],.  
-00021050: 2020 2020 2020 2020 2020 2020 2020 7665                ve
-00021060: 7274 735b 7963 6e74 2d31 5d2c 0a20 2020  rts[ycnt-1],.   
-00021070: 2020 2020 2020 2020 205d 292c 0a20 2020           ]),.   
-00021080: 2020 2020 2020 2020 2076 6e66 5f76 6572           vnf_ver
-00021090: 7465 785f 6172 7261 7928 5b0a 2020 2020  tex_array([.    
-000210a0: 2020 2020 2020 2020 2020 2020 5b66 6f72              [for
-000210b0: 2028 723d 7665 7274 7329 206c 6574 2876   (r=verts) let(v
-000210c0: 3d72 5b30 5d29 205b 762e 782c 2076 2e79  =r[0]) [v.x, v.y
-000210d0: 2c20 626f 7474 6f6d 5d5d 2c0a 2020 2020  , bottom]],.    
-000210e0: 2020 2020 2020 2020 2020 2020 5b66 6f72              [for
-000210f0: 2028 723d 7665 7274 7329 206c 6574 2876   (r=verts) let(v
-00021100: 3d72 5b30 5d29 2076 5d2c 0a20 2020 2020  =r[0]) v],.     
-00021110: 2020 2020 2020 205d 292c 0a20 2020 2020         ]),.     
-00021120: 2020 2020 2020 2076 6e66 5f76 6572 7465         vnf_verte
-00021130: 785f 6172 7261 7928 5b0a 2020 2020 2020  x_array([.      
-00021140: 2020 2020 2020 2020 2020 5b66 6f72 2028            [for (
-00021150: 723d 7665 7274 7329 206c 6574 2876 3d72  r=verts) let(v=r
-00021160: 5b78 636e 742d 315d 2920 765d 2c0a 2020  [xcnt-1]) v],.  
-00021170: 2020 2020 2020 2020 2020 2020 2020 5b66                [f
-00021180: 6f72 2028 723d 7665 7274 7329 206c 6574  or (r=verts) let
-00021190: 2876 3d72 5b78 636e 742d 315d 2920 5b76  (v=r[xcnt-1]) [v
-000211a0: 2e78 2c20 762e 792c 2062 6f74 746f 6d5d  .x, v.y, bottom]
-000211b0: 5d2c 0a20 2020 2020 2020 2020 2020 205d  ],.            ]
-000211c0: 292c 0a20 2020 2020 2020 2020 2020 2076  ),.            v
-000211d0: 6e66 5f76 6572 7465 785f 6172 7261 7928  nf_vertex_array(
-000211e0: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
-000211f0: 2020 5b0a 2020 2020 2020 2020 2020 2020    [.            
-00021200: 2020 2020 2020 2020 666f 7220 2876 3d76          for (v=v
-00021210: 6572 7473 5b30 5d29 205b 762e 782c 2076  erts[0]) [v.x, v
-00021220: 2e79 2c20 626f 7474 6f6d 5d2c 0a20 2020  .y, bottom],.   
-00021230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021240: 2066 6f72 2028 723d 7665 7274 7329 206c   for (r=verts) l
-00021250: 6574 2876 3d72 5b78 636e 742d 315d 2920  et(v=r[xcnt-1]) 
-00021260: 5b76 2e78 2c20 762e 792c 2062 6f74 746f  [v.x, v.y, botto
-00021270: 6d5d 2c0a 2020 2020 2020 2020 2020 2020  m],.            
-00021280: 2020 2020 5d2c 205b 0a20 2020 2020 2020      ], [.       
-00021290: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-000212a0: 2028 723d 7665 7274 7329 206c 6574 2876   (r=verts) let(v
-000212b0: 3d72 5b30 5d29 205b 762e 782c 2076 2e79  =r[0]) [v.x, v.y
-000212c0: 2c20 626f 7474 6f6d 5d2c 0a20 2020 2020  , bottom],.     
-000212d0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000212e0: 6f72 2028 763d 7665 7274 735b 7963 6e74  or (v=verts[ycnt
-000212f0: 2d31 5d29 205b 762e 782c 2076 2e79 2c20  -1]) [v.x, v.y, 
-00021300: 626f 7474 6f6d 5d2c 0a20 2020 2020 2020  bottom],.       
-00021310: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
-00021320: 2020 2020 2020 205d 290a 2020 2020 2020         ]).      
-00021330: 2020 5d29 0a20 2020 2029 2072 656f 7269    ]).    ) reori
-00021340: 656e 7428 616e 6368 6f72 2c73 7069 6e2c  ent(anchor,spin,
-00021350: 6f72 6965 6e74 2c20 766e 663d 766e 662c  orient, vnf=vnf,
-00021360: 2070 3d76 6e66 293b 0a0a 0a2f 2f20 4675   p=vnf);...// Fu
-00021370: 6e63 7469 6f6e 264d 6f64 756c 653a 2063  nction&Module: c
-00021380: 796c 696e 6472 6963 616c 5f68 6569 6768  ylindrical_heigh
-00021390: 7466 6965 6c64 2829 0a2f 2f20 5573 6167  tfield().// Usag
-000213a0: 653a 2041 7320 4675 6e63 7469 6f6e 0a2f  e: As Function./
-000213b0: 2f20 2020 766e 6620 3d20 6379 6c69 6e64  /   vnf = cylind
-000213c0: 7269 6361 6c5f 6865 6967 6874 6669 656c  rical_heightfiel
-000213d0: 6428 6461 7461 2c20 6c2c 2072 7c64 3d2c  d(data, l, r|d=,
-000213e0: 205b 6261 7365 3d5d 2c20 5b74 7261 6e73   [base=], [trans
-000213f0: 706f 7365 3d5d 2c20 5b61 7370 6563 743d  pose=], [aspect=
-00021400: 5d29 3b0a 2f2f 2055 7361 6765 3a20 4173  ]);.// Usage: As
-00021410: 204d 6f64 756c 650a 2f2f 2020 2063 796c   Module.//   cyl
-00021420: 696e 6472 6963 616c 5f68 6569 6768 7466  indrical_heightf
-00021430: 6965 6c64 2864 6174 612c 206c 2c20 727c  ield(data, l, r|
-00021440: 643d 2c20 5b62 6173 653d 5d2c 205b 7472  d=, [base=], [tr
-00021450: 616e 7370 6f73 653d 5d2c 205b 6173 7065  anspose=], [aspe
-00021460: 6374 3d5d 2920 5b41 5454 4143 484d 454e  ct=]) [ATTACHMEN
-00021470: 5453 5d3b 0a2f 2f20 546f 7069 6373 3a20  TS];.// Topics: 
-00021480: 4578 7472 7573 696f 6e2c 2054 6578 7475  Extrusion, Textu
-00021490: 7265 732c 204b 6e75 726c 696e 672c 2048  res, Knurling, H
-000214a0: 6569 6768 7466 6965 6c64 0a2f 2f20 4465  eightfield.// De
-000214b0: 7363 7269 7074 696f 6e3a 0a2f 2f20 2020  scription:.//   
-000214c0: 4769 7665 6e20 6120 7265 6775 6c61 7220  Given a regular 
-000214d0: 7265 6374 616e 6775 6c61 7220 3244 2067  rectangular 2D g
-000214e0: 7269 6420 6f66 2073 6361 6c61 7220 7661  rid of scalar va
-000214f0: 6c75 6573 2c20 6f72 2061 2066 756e 6374  lues, or a funct
-00021500: 696f 6e20 6c69 7465 7261 6c20 6f66 2073  ion literal of s
-00021510: 6967 6e61 7475 7265 2028 782c 7929 2c20  ignature (x,y), 
-00021520: 6765 6e65 7261 7465 730a 2f2f 2020 2061  generates.//   a
-00021530: 2063 796c 696e 6472 6963 616c 2033 4420   cylindrical 3D 
-00021540: 7375 7266 6163 6520 7768 6572 6520 7468  surface where th
-00021550: 6520 6865 6967 6874 2061 7420 616e 7920  e height at any 
-00021560: 6769 7665 6e20 706f 696e 7420 6162 6f76  given point abov
-00021570: 6520 7468 6520 7261 6469 7573 2060 723d  e the radius `r=
-00021580: 602c 2069 7320 7468 6520 7363 616c 6172  `, is the scalar
-00021590: 2076 616c 7565 0a2f 2f20 2020 666f 7220   value.//   for 
-000215a0: 7468 6174 2070 6f73 6974 696f 6e2e 0a2f  that position../
-000215b0: 2f20 2020 4f6e 6520 7363 7269 7074 2074  /   One script t
-000215c0: 6f20 636f 6e76 6572 7420 6120 6772 6179  o convert a gray
-000215d0: 7363 616c 6520 696d 6167 6520 746f 2061  scale image to a
-000215e0: 2068 6569 6768 7466 6965 6c64 2061 7272   heightfield arr
-000215f0: 6179 2069 6e20 6120 2e73 6361 6420 6669  ay in a .scad fi
-00021600: 6c65 2063 616e 2062 6520 666f 756e 6420  le can be found 
-00021610: 6174 3a0a 2f2f 2020 2068 7474 7073 3a2f  at:.//   https:/
-00021620: 2f72 6177 2e67 6974 6875 6275 7365 7263  /raw.githubuserc
-00021630: 6f6e 7465 6e74 2e63 6f6d 2f72 6576 6172  ontent.com/revar
-00021640: 6261 742f 424f 534c 322f 6d61 7374 6572  bat/BOSL2/master
-00021650: 2f73 6372 6970 7473 2f69 6d67 3273 6361  /scripts/img2sca
-00021660: 642e 7079 0a2f 2f20 4172 6775 6d65 6e74  d.py.// Argument
-00021670: 733a 0a2f 2f20 2020 6461 7461 203d 2054  s:.//   data = T
-00021680: 6869 7320 6973 2065 6974 6865 7220 7468  his is either th
-00021690: 6520 3244 2072 6563 7461 6e67 756c 6172  e 2D rectangular
-000216a0: 2061 7272 6179 206f 6620 6865 6967 6874   array of height
-000216b0: 732c 206f 7220 6120 6675 6e63 7469 6f6e  s, or a function
-000216c0: 206c 6974 6572 616c 206f 6620 7369 676e   literal of sign
-000216d0: 6174 7572 6520 6028 782c 2079 2960 2e0a  ature `(x, y)`..
-000216e0: 2f2f 2020 206c 203d 2054 6865 206c 656e  //   l = The len
-000216f0: 6774 6820 6f66 2074 6865 2063 796c 696e  gth of the cylin
-00021700: 6465 7220 746f 2077 7261 7020 6172 6f75  der to wrap arou
-00021710: 6e64 2e0a 2f2f 2020 2072 203d 2054 6865  nd..//   r = The
-00021720: 2072 6164 6975 7320 6f66 2074 6865 2063   radius of the c
-00021730: 796c 696e 6465 7220 746f 2077 7261 7020  ylinder to wrap 
-00021740: 6172 6f75 6e64 2e0a 2f2f 2020 202d 2d2d  around..//   ---
-00021750: 0a2f 2f20 2020 7231 203d 2054 6865 2072  .//   r1 = The r
-00021760: 6164 6975 7320 6f66 2074 6865 2062 6f74  adius of the bot
-00021770: 746f 6d20 6f66 2074 6865 2063 796c 696e  tom of the cylin
-00021780: 6465 7220 746f 2077 7261 7020 6172 6f75  der to wrap arou
-00021790: 6e64 2e0a 2f2f 2020 2072 3220 3d20 5468  nd..//   r2 = Th
-000217a0: 6520 7261 6469 7573 206f 6620 7468 6520  e radius of the 
-000217b0: 746f 7020 6f66 2074 6865 2063 796c 696e  top of the cylin
-000217c0: 6465 7220 746f 2077 7261 7020 6172 6f75  der to wrap arou
-000217d0: 6e64 2e0a 2f2f 2020 2064 203d 2054 6865  nd..//   d = The
-000217e0: 2064 6961 6d65 7465 7220 6f66 2074 6865   diameter of the
-000217f0: 2063 796c 696e 6465 7220 746f 2077 7261   cylinder to wra
-00021800: 7020 6172 6f75 6e64 2e0a 2f2f 2020 2064  p around..//   d
-00021810: 3120 3d20 5468 6520 6469 616d 6574 6572  1 = The diameter
-00021820: 206f 6620 7468 6520 626f 7474 6f6d 206f   of the bottom o
-00021830: 6620 7468 6520 6379 6c69 6e64 6572 2074  f the cylinder t
-00021840: 6f20 7772 6170 2061 726f 756e 642e 0a2f  o wrap around../
-00021850: 2f20 2020 6432 203d 2054 6865 2064 6961  /   d2 = The dia
-00021860: 6d65 7465 7220 6f66 2074 6865 2074 6f70  meter of the top
-00021870: 206f 6620 7468 6520 6379 6c69 6e64 6572   of the cylinder
-00021880: 2074 6f20 7772 6170 2061 726f 756e 642e   to wrap around.
-00021890: 0a2f 2f20 2020 6261 7365 203d 2054 6865  .//   base = The
-000218a0: 2072 6164 6975 7320 666f 7220 7468 6520   radius for the 
-000218b0: 626f 7474 6f6d 206f 6620 7468 6520 6865  bottom of the he
-000218c0: 6967 6874 6669 656c 6420 6f62 6a65 6374  ightfield object
-000218d0: 2074 6f20 6372 6561 7465 2e20 2041 6e79   to create.  Any
-000218e0: 2068 6569 6768 7473 2073 6d61 6c6c 6572   heights smaller
-000218f0: 2074 6861 6e20 7468 6973 2077 696c 6c20   than this will 
-00021900: 6265 2074 7275 6e63 6174 6564 2074 6f20  be truncated to 
-00021910: 7665 7279 2073 6c69 6768 746c 7920 6162  very slightly ab
-00021920: 6f76 6520 7468 6973 2068 6569 6768 742e  ove this height.
-00021930: 2020 4465 6661 756c 743a 202d 3230 0a2f    Default: -20./
-00021940: 2f20 2020 7472 616e 7370 6f73 6520 3d20  /   transpose = 
-00021950: 4966 2074 7275 652c 2073 7761 7073 2074  If true, swaps t
-00021960: 6865 2072 6164 6961 6c20 616e 6420 6c65  he radial and le
-00021970: 6e67 7468 2061 7865 7320 6f66 2074 6865  ngth axes of the
-00021980: 2064 6174 612e 2020 4465 6661 756c 743a   data.  Default:
-00021990: 2066 616c 7365 0a2f 2f20 2020 6173 7065   false.//   aspe
-000219a0: 6374 203d 2054 6865 2061 7370 6563 7420  ct = The aspect 
-000219b0: 7261 7469 6f20 6f66 2074 6865 2067 656e  ratio of the gen
-000219c0: 6572 6174 6564 2068 6569 6768 7466 6965  erated heightfie
-000219d0: 6c64 2061 7420 7468 6520 7375 7266 6163  ld at the surfac
-000219e0: 6520 6f66 2074 6865 2063 796c 696e 6465  e of the cylinde
-000219f0: 722e 2020 4465 6661 756c 743a 2031 0a2f  r.  Default: 1./
-00021a00: 2f20 2020 7872 616e 6765 203d 2041 2072  /   xrange = A r
-00021a10: 616e 6765 206f 6620 7661 6c75 6573 2074  ange of values t
-00021a20: 6f20 6974 6572 6174 6520 5820 6f76 6572  o iterate X over
-00021a30: 2077 6865 6e20 6361 6c63 756c 6174 696e   when calculatin
-00021a40: 6720 6120 7375 7266 6163 6520 6672 6f6d  g a surface from
-00021a50: 2061 2066 756e 6374 696f 6e20 6c69 7465   a function lite
-00021a60: 7261 6c2e 2020 4465 6661 756c 743a 205b  ral.  Default: [
-00021a70: 2d31 203a 2030 2e30 3120 3a20 315d 0a2f  -1 : 0.01 : 1]./
-00021a80: 2f20 2020 7972 616e 6765 203d 2041 2072  /   yrange = A r
-00021a90: 616e 6765 206f 6620 7661 6c75 6573 2074  ange of values t
-00021aa0: 6f20 6974 6572 6174 6520 5920 6f76 6572  o iterate Y over
-00021ab0: 2077 6865 6e20 6361 6c63 756c 6174 696e   when calculatin
-00021ac0: 6720 6120 7375 7266 6163 6520 6672 6f6d  g a surface from
-00021ad0: 2061 2066 756e 6374 696f 6e20 6c69 7465   a function lite
-00021ae0: 7261 6c2e 2020 4465 6661 756c 743a 205b  ral.  Default: [
-00021af0: 2d31 203a 2030 2e30 3120 3a20 315d 0a2f  -1 : 0.01 : 1]./
-00021b00: 2f20 2020 6d61 7868 203d 2054 6865 206d  /   maxh = The m
-00021b10: 6178 696d 756d 2068 6569 6768 7420 6162  aximum height ab
-00021b20: 6f76 6520 7468 6520 7261 6469 7573 2074  ove the radius t
-00021b30: 6f20 6d6f 6465 6c2e 2020 5472 756e 6361  o model.  Trunca
-00021b40: 7465 7320 616e 7974 6869 6e67 2074 616c  tes anything tal
-00021b50: 6c65 7220 746f 2074 6869 7320 6865 6967  ler to this heig
-00021b60: 6874 2e20 2044 6566 6175 6c74 3a20 3939  ht.  Default: 99
-00021b70: 0a2f 2f20 2020 7374 796c 6520 3d20 5468  .//   style = Th
-00021b80: 6520 7374 796c 6520 6f66 2073 7562 6469  e style of subdi
-00021b90: 7669 6469 6e67 2074 6865 2071 7561 6473  viding the quads
-00021ba0: 2069 6e74 6f20 6661 6365 732e 2020 5661   into faces.  Va
-00021bb0: 6c69 6420 6f70 7469 6f6e 7320 6172 6520  lid options are 
-00021bc0: 2264 6566 6175 6c74 222c 2022 616c 7422  "default", "alt"
-00021bd0: 2c20 616e 6420 2271 7569 6e63 756e 7822  , and "quincunx"
-00021be0: 2e20 2044 6566 6175 6c74 3a20 2264 6566  .  Default: "def
-00021bf0: 6175 6c74 220a 2f2f 2020 2063 6f6e 7665  ault".//   conve
-00021c00: 7869 7479 203d 204d 6178 206e 756d 6265  xity = Max numbe
-00021c10: 7220 6f66 2074 696d 6573 2061 206c 696e  r of times a lin
-00021c20: 6520 636f 756c 6420 696e 7465 7273 6563  e could intersec
-00021c30: 7420 6120 7761 6c6c 206f 6620 7468 6520  t a wall of the 
-00021c40: 7375 7266 6163 6520 6265 696e 6720 666f  surface being fo
-00021c50: 726d 6564 2e20 4d6f 6475 6c65 206f 6e6c  rmed. Module onl
-00021c60: 792e 2020 4465 6661 756c 743a 2031 300a  y.  Default: 10.
-00021c70: 2f2f 2020 2061 6e63 686f 7220 3d20 5472  //   anchor = Tr
-00021c80: 616e 736c 6174 6520 736f 2061 6e63 686f  anslate so ancho
-00021c90: 7220 706f 696e 7420 6973 2061 7420 6f72  r point is at or
-00021ca0: 6967 696e 2028 302c 302c 3029 2e20 2053  igin (0,0,0).  S
-00021cb0: 6565 205b 616e 6368 6f72 5d28 6174 7461  ee [anchor](atta
-00021cc0: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
-00021cd0: 7365 6374 696f 6e2d 616e 6368 6f72 292e  section-anchor).
-00021ce0: 2020 4465 6661 756c 743a 2060 4345 4e54    Default: `CENT
-00021cf0: 4552 600a 2f2f 2020 2073 7069 6e20 3d20  ER`.//   spin = 
-00021d00: 526f 7461 7465 2074 6869 7320 6d61 6e79  Rotate this many
-00021d10: 2064 6567 7265 6573 2061 726f 756e 6420   degrees around 
-00021d20: 7468 6520 5a20 6178 6973 2e20 2053 6565  the Z axis.  See
-00021d30: 205b 7370 696e 5d28 6174 7461 6368 6d65   [spin](attachme
-00021d40: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
-00021d50: 696f 6e2d 7370 696e 292e 2020 4465 6661  ion-spin).  Defa
-00021d60: 756c 743a 2060 3060 0a2f 2f20 2020 6f72  ult: `0`.//   or
-00021d70: 6965 6e74 203d 2056 6563 746f 7220 746f  ient = Vector to
-00021d80: 2072 6f74 6174 6520 746f 7020 746f 7761   rotate top towa
-00021d90: 7264 732e 2020 5365 6520 5b6f 7269 656e  rds.  See [orien
-00021da0: 745d 2861 7474 6163 686d 656e 7473 2e73  t](attachments.s
-00021db0: 6361 6423 7375 6273 6563 7469 6f6e 2d6f  cad#subsection-o
-00021dc0: 7269 656e 7429 2e20 2044 6566 6175 6c74  rient).  Default
-00021dd0: 3a20 6055 5060 0a2f 2f20 5365 6520 416c  : `UP`.// See Al
-00021de0: 736f 3a20 6865 6967 6874 6669 656c 6428  so: heightfield(
-00021df0: 292c 2063 796c 696e 6472 6963 616c 5f68  ), cylindrical_h
-00021e00: 6569 6768 7466 6965 6c64 2829 2c20 7465  eightfield(), te
-00021e10: 7874 7572 6564 5f72 6576 6f6c 7574 696f  xtured_revolutio
-00021e20: 6e28 292c 2074 6578 7475 7265 645f 6379  n(), textured_cy
-00021e30: 6c69 6e64 6572 2829 2c20 7465 7874 7572  linder(), textur
-00021e40: 6564 5f6c 696e 6561 725f 7377 6565 7028  ed_linear_sweep(
-00021e50: 290a 2f2f 2045 7861 6d70 6c65 2856 5044  ).// Example(VPD
-00021e60: 3d34 3030 3b56 5052 3d5b 3535 2c30 2c31  =400;VPR=[55,0,1
-00021e70: 3530 5d29 3a0a 2f2f 2020 2063 796c 696e  50]):.//   cylin
-00021e80: 6472 6963 616c 5f68 6569 6768 7466 6965  drical_heightfie
-00021e90: 6c64 286c 3d31 3030 2c20 723d 3330 2c20  ld(l=100, r=30, 
-00021ea0: 6261 7365 3d35 2c20 6461 7461 3d5b 0a2f  base=5, data=[./
-00021eb0: 2f20 2020 2020 2020 666f 7220 2879 3d5b  /       for (y=[
-00021ec0: 2d31 3830 3a34 3a31 3830 5d29 205b 0a2f  -180:4:180]) [./
-00021ed0: 2f20 2020 2020 2020 2020 2020 666f 7228  /           for(
-00021ee0: 783d 5b2d 3138 303a 343a 3138 305d 290a  x=[-180:4:180]).
-00021ef0: 2f2f 2020 2020 2020 2020 2020 2035 2a63  //           5*c
-00021f00: 6f73 2835 2a6e 6f72 6d28 5b78 2c79 5d29  os(5*norm([x,y])
-00021f10: 292b 350a 2f2f 2020 2020 2020 205d 0a2f  )+5.//       ]./
-00021f20: 2f20 2020 5d29 3b0a 2f2f 2045 7861 6d70  /   ]);.// Examp
-00021f30: 6c65 2856 5044 3d34 3030 3b56 5052 3d5b  le(VPD=400;VPR=[
-00021f40: 3535 2c30 2c31 3530 5d29 3a0a 2f2f 2020  55,0,150]):.//  
-00021f50: 2063 796c 696e 6472 6963 616c 5f68 6569   cylindrical_hei
-00021f60: 6768 7466 6965 6c64 286c 3d31 3030 2c20  ghtfield(l=100, 
-00021f70: 7231 3d36 302c 2072 323d 3330 2c20 6261  r1=60, r2=30, ba
-00021f80: 7365 3d35 2c20 6461 7461 3d5b 0a2f 2f20  se=5, data=[.// 
-00021f90: 2020 2020 2020 666f 7220 2879 3d5b 2d31        for (y=[-1
-00021fa0: 3830 3a34 3a31 3830 5d29 205b 0a2f 2f20  80:4:180]) [.// 
-00021fb0: 2020 2020 2020 2020 2020 666f 7228 783d            for(x=
-00021fc0: 5b2d 3138 303a 343a 3138 305d 290a 2f2f  [-180:4:180]).//
-00021fd0: 2020 2020 2020 2020 2020 2035 2a63 6f73             5*cos
-00021fe0: 2835 2a6e 6f72 6d28 5b78 2c79 5d29 292b  (5*norm([x,y]))+
-00021ff0: 350a 2f2f 2020 2020 2020 205d 0a2f 2f20  5.//       ].// 
-00022000: 2020 5d29 3b0a 2f2f 2045 7861 6d70 6c65    ]);.// Example
-00022010: 2856 5044 3d34 3030 3b56 5052 3d5b 3535  (VPD=400;VPR=[55
-00022020: 2c30 2c31 3530 5d29 3a20 4865 6967 6874  ,0,150]): Height
-00022030: 6669 656c 6420 6279 2046 756e 6374 696f  field by Functio
-00022040: 6e0a 2f2f 2020 2066 6e20 3d20 6675 6e63  n.//   fn = func
-00022050: 7469 6f6e 2028 782c 7929 2035 2a73 696e  tion (x,y) 5*sin
-00022060: 2878 2a33 3630 292a 636f 7328 792a 3336  (x*360)*cos(y*36
-00022070: 3029 2b35 3b0a 2f2f 2020 2063 796c 696e  0)+5;.//   cylin
-00022080: 6472 6963 616c 5f68 6569 6768 7466 6965  drical_heightfie
-00022090: 6c64 286c 3d31 3030 2c20 723d 3330 2c20  ld(l=100, r=30, 
-000220a0: 6461 7461 3d66 6e29 3b0a 2f2f 2045 7861  data=fn);.// Exa
-000220b0: 6d70 6c65 2856 5044 3d34 3030 3b56 5052  mple(VPD=400;VPR
-000220c0: 3d5b 3535 2c30 2c31 3530 5d29 3a20 4865  =[55,0,150]): He
-000220d0: 6967 6874 6669 656c 6420 6279 2046 756e  ightfield by Fun
-000220e0: 6374 696f 6e2c 2077 6974 6820 5370 6563  ction, with Spec
-000220f0: 6966 6963 2052 616e 6765 730a 2f2f 2020  ific Ranges.//  
-00022100: 2066 6e20 3d20 6675 6e63 7469 6f6e 2028   fn = function (
-00022110: 782c 7929 2032 2a63 6f73 2835 2a6e 6f72  x,y) 2*cos(5*nor
-00022120: 6d28 5b78 2c79 5d29 293b 0a2f 2f20 2020  m([x,y]));.//   
-00022130: 6379 6c69 6e64 7269 6361 6c5f 6865 6967  cylindrical_heig
-00022140: 6874 6669 656c 6428 0a2f 2f20 2020 2020  htfield(.//     
-00022150: 2020 6c3d 3130 302c 2072 3d33 302c 2062    l=100, r=30, b
-00022160: 6173 653d 352c 2064 6174 613d 666e 2c0a  ase=5, data=fn,.
-00022170: 2f2f 2020 2020 2020 2078 7261 6e67 653d  //       xrange=
-00022180: 5b2d 3138 303a 323a 3138 305d 2c20 7972  [-180:2:180], yr
-00022190: 616e 6765 3d5b 2d31 3830 3a32 3a31 3830  ange=[-180:2:180
-000221a0: 5d0a 2f2f 2020 2029 3b0a 6675 6e63 7469  ].//   );.functi
-000221b0: 6f6e 2063 796c 696e 6472 6963 616c 5f68  on cylindrical_h
-000221c0: 6569 6768 7466 6965 6c64 280a 2020 2020  eightfield(.    
-000221d0: 6461 7461 2c20 6c2c 2072 2c20 6261 7365  data, l, r, base
-000221e0: 3d31 2c0a 2020 2020 7472 616e 7370 6f73  =1,.    transpos
-000221f0: 653d 6661 6c73 652c 2061 7370 6563 743d  e=false, aspect=
-00022200: 312c 0a20 2020 2073 7479 6c65 3d22 6d69  1,.    style="mi
-00022210: 6e5f 6564 6765 222c 206d 6178 683d 3939  n_edge", maxh=99
-00022220: 2c0a 2020 2020 7872 616e 6765 3d5b 2d31  ,.    xrange=[-1
-00022230: 3a30 2e30 313a 315d 2c0a 2020 2020 7972  :0.01:1],.    yr
-00022240: 616e 6765 3d5b 2d31 3a30 2e30 313a 315d  ange=[-1:0.01:1]
-00022250: 2c0a 2020 2020 7231 2c20 7232 2c20 642c  ,.    r1, r2, d,
-00022260: 2064 312c 2064 322c 2068 2c20 6865 6967   d1, d2, h, heig
-00022270: 6874 2c0a 2020 2020 616e 6368 6f72 3d43  ht,.    anchor=C
-00022280: 5452 2c20 7370 696e 3d30 2c20 6f72 6965  TR, spin=0, orie
-00022290: 6e74 3d55 500a 2920 3d0a 2020 2020 6c65  nt=UP.) =.    le
-000222a0: 7428 0a20 2020 2020 2020 206c 203d 2066  t(.        l = f
-000222b0: 6972 7374 5f64 6566 696e 6564 285b 6c2c  irst_defined([l,
-000222c0: 2068 2c20 6865 6967 6874 5d29 2c0a 2020   h, height]),.  
-000222d0: 2020 2020 2020 7231 203d 2067 6574 5f72        r1 = get_r
-000222e0: 6164 6975 7328 7231 3d72 312c 2072 3d72  adius(r1=r1, r=r
-000222f0: 2c20 6431 3d64 312c 2064 3d64 292c 0a20  , d1=d1, d=d),. 
-00022300: 2020 2020 2020 2072 3220 3d20 6765 745f         r2 = get_
-00022310: 7261 6469 7573 2872 313d 7232 2c20 723d  radius(r1=r2, r=
-00022320: 722c 2064 313d 6432 2c20 643d 6429 0a20  r, d1=d2, d=d). 
-00022330: 2020 2029 0a20 2020 2061 7373 6572 7428     ).    assert(
-00022340: 6973 5f66 696e 6974 6528 6c29 2026 2620  is_finite(l) && 
-00022350: 6c3e 302c 2022 4d75 7374 2073 7570 706c  l>0, "Must suppl
-00022360: 7920 6f6e 6520 6f66 206c 3d2c 2068 3d2c  y one of l=, h=,
-00022370: 206f 7220 6865 6967 6874 3d20 6173 2061   or height= as a
-00022380: 2066 696e 6974 6520 706f 7369 7469 7665   finite positive
-00022390: 206e 756d 6265 722e 2229 0a20 2020 2061   number.").    a
-000223a0: 7373 6572 7428 6973 5f66 696e 6974 6528  ssert(is_finite(
-000223b0: 7231 2920 2626 2072 313e 302c 2022 4d75  r1) && r1>0, "Mu
-000223c0: 7374 2073 7570 706c 7920 6f6e 6520 6f66  st supply one of
-000223d0: 2072 3d2c 2072 313d 2c20 643d 2c20 6f72   r=, r1=, d=, or
-000223e0: 2064 313d 2061 7320 6120 6669 6e69 7465   d1= as a finite
-000223f0: 2070 6f73 6974 6976 6520 6e75 6d62 6572   positive number
-00022400: 2e22 290a 2020 2020 6173 7365 7274 2869  .").    assert(i
-00022410: 735f 6669 6e69 7465 2872 3229 2026 2620  s_finite(r2) && 
-00022420: 7232 3e30 2c20 224d 7573 7420 7375 7070  r2>0, "Must supp
-00022430: 6c79 206f 6e65 206f 6620 723d 2c20 7232  ly one of r=, r2
-00022440: 3d2c 2064 3d2c 206f 7220 6432 3d20 6173  =, d=, or d2= as
-00022450: 2061 2066 696e 6974 6520 706f 7369 7469   a finite positi
-00022460: 7665 206e 756d 6265 722e 2229 0a20 2020  ve number.").   
-00022470: 2061 7373 6572 7428 6973 5f66 696e 6974   assert(is_finit
-00022480: 6528 6261 7365 2920 2626 2062 6173 653e  e(base) && base>
-00022490: 302c 2022 4d75 7374 2073 7570 706c 7920  0, "Must supply 
-000224a0: 6261 7365 3d20 6173 2061 2066 696e 6974  base= as a finit
-000224b0: 6520 706f 7369 7469 7665 206e 756d 6265  e positive numbe
-000224c0: 722e 2229 0a20 2020 2061 7373 6572 7428  r.").    assert(
-000224d0: 6973 5f6d 6174 7269 7828 6461 7461 297c  is_matrix(data)|
-000224e0: 7c69 735f 6675 6e63 7469 6f6e 2864 6174  |is_function(dat
-000224f0: 6129 2c20 2264 6174 613d 206d 7573 7420  a), "data= must 
-00022500: 6265 2061 2066 756e 6374 696f 6e20 6c69  be a function li
-00022510: 7465 7261 6c2c 206f 7220 636f 6e74 6169  teral, or contai
-00022520: 6e20 6120 3244 2061 7272 6179 206f 6620  n a 2D array of 
-00022530: 6e75 6d62 6572 732e 2229 0a20 2020 206c  numbers.").    l
-00022540: 6574 280a 2020 2020 2020 2020 7876 616c  et(.        xval
-00022550: 7320 3d20 6973 5f6c 6973 7428 6461 7461  s = is_list(data
-00022560: 293f 205b 666f 7220 2878 203d 2069 6478  )? [for (x = idx
-00022570: 2864 6174 615b 305d 2929 2078 5d20 3a0a  (data[0])) x] :.
-00022580: 2020 2020 2020 2020 2020 2020 6973 5f72              is_r
-00022590: 616e 6765 2878 7261 6e67 6529 3f20 5b66  ange(xrange)? [f
-000225a0: 6f72 2028 7820 3d20 7872 616e 6765 2920  or (x = xrange) 
-000225b0: 785d 203a 0a20 2020 2020 2020 2020 2020  x] :.           
-000225c0: 2061 7373 6572 7428 6661 6c73 652c 2022   assert(false, "
-000225d0: 7872 616e 6765 3d20 6d75 7374 2062 6520  xrange= must be 
-000225e0: 6769 7665 6e20 6173 2061 2072 616e 6765  given as a range
-000225f0: 2069 6620 6461 7461 3d20 6973 2061 2066   if data= is a f
-00022600: 756e 6374 696f 6e20 6c69 7465 7261 6c2e  unction literal.
-00022610: 2229 2c0a 2020 2020 2020 2020 7976 616c  "),.        yval
-00022620: 7320 3d20 6973 5f6c 6973 7428 6461 7461  s = is_list(data
-00022630: 293f 205b 666f 7220 2879 203d 2069 6478  )? [for (y = idx
-00022640: 2864 6174 6129 2920 795d 203a 0a20 2020  (data)) y] :.   
-00022650: 2020 2020 2020 2020 2069 735f 7261 6e67           is_rang
-00022660: 6528 7972 616e 6765 293f 205b 666f 7220  e(yrange)? [for 
-00022670: 2879 203d 2079 7261 6e67 6529 2079 5d20  (y = yrange) y] 
-00022680: 3a0a 2020 2020 2020 2020 2020 2020 6173  :.            as
-00022690: 7365 7274 2866 616c 7365 2c20 2279 7261  sert(false, "yra
-000226a0: 6e67 653d 206d 7573 7420 6265 2067 6976  nge= must be giv
-000226b0: 656e 2061 7320 6120 7261 6e67 6520 6966  en as a range if
-000226c0: 2064 6174 613d 2069 7320 6120 6675 6e63   data= is a func
-000226d0: 7469 6f6e 206c 6974 6572 616c 2e22 292c  tion literal."),
-000226e0: 0a20 2020 2020 2020 2078 6c65 6e20 3d20  .        xlen = 
-000226f0: 6c65 6e28 7876 616c 7329 2c0a 2020 2020  len(xvals),.    
-00022700: 2020 2020 796c 656e 203d 206c 656e 2879      ylen = len(y
-00022710: 7661 6c73 292c 0a20 2020 2020 2020 2073  vals),.        s
-00022720: 7465 7079 203d 206c 202f 2028 796c 656e  tepy = l / (ylen
-00022730: 2d31 292c 0a20 2020 2020 2020 2073 7465  -1),.        ste
-00022740: 7078 203d 2073 7465 7079 202a 2061 7370  px = stepy * asp
-00022750: 6563 742c 0a20 2020 2020 2020 206d 6178  ect,.        max
-00022760: 7220 3d20 6d61 7828 7231 2c72 3229 2c0a  r = max(r1,r2),.
-00022770: 2020 2020 2020 2020 6369 7263 203d 2032          circ = 2
-00022780: 202a 2050 4920 2a20 6d61 7872 2c0a 2020   * PI * maxr,.  
-00022790: 2020 2020 2020 6173 7465 7020 3d20 3336        astep = 36
-000227a0: 3020 2f20 6369 7263 202a 2073 7465 7078  0 / circ * stepx
-000227b0: 2c0a 2020 2020 2020 2020 6172 6320 3d20  ,.        arc = 
-000227c0: 6173 7465 7020 2a20 2878 6c65 6e2d 3129  astep * (xlen-1)
-000227d0: 2c0a 2020 2020 2020 2020 6273 7465 7073  ,.        bsteps
-000227e0: 203d 2072 6f75 6e64 2873 6567 7328 6d61   = round(segs(ma
-000227f0: 7872 2d62 6173 6529 202a 2061 7263 202f  xr-base) * arc /
-00022800: 2033 3630 292c 0a20 2020 2020 2020 2062   360),.        b
-00022810: 7374 6570 203d 2061 7263 202f 2062 7374  step = arc / bst
-00022820: 6570 730a 2020 2020 290a 2020 2020 6173  eps.    ).    as
-00022830: 7365 7274 2873 7465 7078 2a78 6c65 6e20  sert(stepx*xlen 
-00022840: 3c3d 2063 6972 632c 2073 7472 2822 6865  <= circ, str("he
-00022850: 6967 6874 6669 656c 6420 2822 2c78 6c65  ightfield (",xle
-00022860: 6e2c 2220 7820 222c 796c 656e 2c22 2920  n," x ",ylen,") 
-00022870: 6e65 6564 7320 6120 7261 6469 7573 206f  needs a radius o
-00022880: 6620 6174 206c 6561 7374 2022 2c6d 6178  f at least ",max
-00022890: 722a 7374 6570 782a 786c 656e 2f63 6972  r*stepx*xlen/cir
-000228a0: 6329 290a 2020 2020 6c65 7428 0a20 2020  c)).    let(.   
-000228b0: 2020 2020 2076 6572 7473 203d 205b 0a20       verts = [. 
-000228c0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-000228d0: 7969 203d 2069 6478 2879 7661 6c73 2929  yi = idx(yvals))
-000228e0: 206c 6574 280a 2020 2020 2020 2020 2020   let(.          
-000228f0: 2020 2020 2020 7a20 3d20 7969 202a 2073        z = yi * s
-00022900: 7465 7079 202d 206c 2f32 2c0a 2020 2020  tepy - l/2,.    
-00022910: 2020 2020 2020 2020 2020 2020 7272 203d              rr =
-00022920: 206c 6572 7028 7231 2c20 7232 2c20 7969   lerp(r1, r2, yi
-00022930: 2f28 796c 656e 2d31 2929 0a20 2020 2020  /(ylen-1)).     
-00022940: 2020 2020 2020 2029 205b 0a20 2020 2020         ) [.     
-00022950: 2020 2020 2020 2020 2020 2063 796c 696e             cylin
-00022960: 6472 6963 616c 5f74 6f5f 7879 7a28 7272  drical_to_xyz(rr
-00022970: 2d62 6173 652c 202d 6172 632f 322c 207a  -base, -arc/2, z
-00022980: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00022990: 2020 2066 6f72 2028 7869 203d 2069 6478     for (xi = idx
-000229a0: 2878 7661 6c73 2929 206c 6574 2820 6120  (xvals)) let( a 
-000229b0: 3d20 7869 2a61 7374 6570 2029 0a20 2020  = xi*astep ).   
-000229c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000229d0: 206c 6574 280a 2020 2020 2020 2020 2020   let(.          
-000229e0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-000229f0: 6420 3d20 7472 616e 7370 6f73 653f 2028  d = transpose? (
-00022a00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00022a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022a20: 2069 735f 6c69 7374 2864 6174 6129 3f20   is_list(data)? 
-00022a30: 6461 7461 5b78 695d 5b79 695d 203a 2064  data[xi][yi] : d
-00022a40: 6174 6128 7976 616c 735b 7969 5d2c 7876  ata(yvals[yi],xv
-00022a50: 616c 735b 7869 5d29 0a20 2020 2020 2020  als[xi]).       
-00022a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022a70: 2020 2020 2029 203a 2028 0a20 2020 2020       ) : (.     
-00022a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022a90: 2020 2020 2020 2020 2020 2069 735f 6c69             is_li
-00022aa0: 7374 2864 6174 6129 3f20 6461 7461 5b79  st(data)? data[y
-00022ab0: 695d 5b78 695d 203a 2064 6174 6128 7876  i][xi] : data(xv
-00022ac0: 616c 735b 7869 5d2c 7976 616c 735b 7969  als[xi],yvals[yi
-00022ad0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00022ae0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00022af0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00022b00: 2020 2020 2020 2020 2020 7261 6432 203d            rad2 =
-00022b10: 2063 6f6e 7374 7261 696e 2872 6164 2c20   constrain(rad, 
-00022b20: 302e 3031 2d62 6173 652c 206d 6178 6829  0.01-base, maxh)
-00022b30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00022b40: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00022b50: 2020 2020 2020 2020 2020 2063 796c 696e             cylin
-00022b60: 6472 6963 616c 5f74 6f5f 7879 7a28 7272  drical_to_xyz(rr
-00022b70: 2b72 6164 322c 2061 2d61 7263 2f32 2c20  +rad2, a-arc/2, 
-00022b80: 7a29 2c0a 2020 2020 2020 2020 2020 2020  z),.            
-00022b90: 2020 2020 6379 6c69 6e64 7269 6361 6c5f      cylindrical_
-00022ba0: 746f 5f78 797a 2872 722d 6261 7365 2c20  to_xyz(rr-base, 
-00022bb0: 6172 632f 322c 207a 292c 0a20 2020 2020  arc/2, z),.     
-00022bc0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
-00022bd0: 6220 3d20 5b31 3a31 3a62 7374 6570 732d  b = [1:1:bsteps-
-00022be0: 315d 2920 6c65 7428 2061 203d 2061 7263  1]) let( a = arc
-00022bf0: 2f32 2d62 2a62 7374 6570 2029 0a20 2020  /2-b*bstep ).   
-00022c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022c10: 2063 796c 696e 6472 6963 616c 5f74 6f5f   cylindrical_to_
-00022c20: 7879 7a28 287a 3e30 3f72 323a 7231 292d  xyz((z>0?r2:r1)-
-00022c30: 6261 7365 2c20 612c 206c 2f32 2a28 7a3e  base, a, l/2*(z>
-00022c40: 303f 313a 2d31 2929 2c0a 2020 2020 2020  0?1:-1)),.      
-00022c50: 2020 2020 2020 5d0a 2020 2020 2020 2020        ].        
-00022c60: 5d2c 0a20 2020 2020 2020 2076 6e66 203d  ],.        vnf =
-00022c70: 2076 6e66 5f76 6572 7465 785f 6172 7261   vnf_vertex_arra
-00022c80: 7928 7665 7274 732c 2063 6170 733d 7472  y(verts, caps=tr
-00022c90: 7565 2c20 636f 6c5f 7772 6170 3d74 7275  ue, col_wrap=tru
-00022ca0: 652c 2072 6576 6572 7365 3d74 7275 652c  e, reverse=true,
-00022cb0: 2073 7479 6c65 3d73 7479 6c65 290a 2020   style=style).  
-00022cc0: 2020 2920 7265 6f72 6965 6e74 2861 6e63    ) reorient(anc
-00022cd0: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
-00022ce0: 2072 313d 7231 2c20 7232 3d72 322c 206c   r1=r1, r2=r2, l
-00022cf0: 3d6c 2c20 703d 766e 6629 3b0a 0a0a 6d6f  =l, p=vnf);...mo
-00022d00: 6475 6c65 2063 796c 696e 6472 6963 616c  dule cylindrical
-00022d10: 5f68 6569 6768 7466 6965 6c64 280a 2020  _heightfield(.  
-00022d20: 2020 6461 7461 2c20 6c2c 2072 2c20 6261    data, l, r, ba
-00022d30: 7365 3d31 2c0a 2020 2020 7472 616e 7370  se=1,.    transp
-00022d40: 6f73 653d 6661 6c73 652c 2061 7370 6563  ose=false, aspec
-00022d50: 743d 312c 0a20 2020 2073 7479 6c65 3d22  t=1,.    style="
-00022d60: 6d69 6e5f 6564 6765 222c 2063 6f6e 7665  min_edge", conve
-00022d70: 7869 7479 3d31 302c 0a20 2020 2078 7261  xity=10,.    xra
-00022d80: 6e67 653d 5b2d 313a 302e 3031 3a31 5d2c  nge=[-1:0.01:1],
-00022d90: 2079 7261 6e67 653d 5b2d 313a 302e 3031   yrange=[-1:0.01
-00022da0: 3a31 5d2c 0a20 2020 206d 6178 683d 3939  :1],.    maxh=99
-00022db0: 2c20 7231 2c20 7232 2c20 642c 2064 312c  , r1, r2, d, d1,
-00022dc0: 2064 322c 2068 2c20 6865 6967 6874 2c0a   d2, h, height,.
-00022dd0: 2020 2020 616e 6368 6f72 3d43 5452 2c20      anchor=CTR, 
-00022de0: 7370 696e 3d30 2c20 6f72 6965 6e74 3d55  spin=0, orient=U
-00022df0: 500a 2920 7b0a 2020 2020 6c20 3d20 6669  P.) {.    l = fi
-00022e00: 7273 745f 6465 6669 6e65 6428 5b6c 2c20  rst_defined([l, 
-00022e10: 682c 2068 6569 6768 745d 293b 0a20 2020  h, height]);.   
-00022e20: 2072 3120 3d20 6765 745f 7261 6469 7573   r1 = get_radius
-00022e30: 2872 313d 7231 2c20 723d 722c 2064 313d  (r1=r1, r=r, d1=
-00022e40: 6431 2c20 643d 6429 3b0a 2020 2020 7232  d1, d=d);.    r2
-00022e50: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
-00022e60: 3d72 322c 2072 3d72 2c20 6431 3d64 322c  =r2, r=r, d1=d2,
-00022e70: 2064 3d64 293b 0a20 2020 2076 6e66 203d   d=d);.    vnf =
-00022e80: 2063 796c 696e 6472 6963 616c 5f68 6569   cylindrical_hei
-00022e90: 6768 7466 6965 6c64 280a 2020 2020 2020  ghtfield(.      
-00022ea0: 2020 6461 7461 2c20 6c3d 6c2c 2072 313d    data, l=l, r1=
-00022eb0: 7231 2c20 7232 3d72 322c 2062 6173 653d  r1, r2=r2, base=
-00022ec0: 6261 7365 2c0a 2020 2020 2020 2020 7872  base,.        xr
-00022ed0: 616e 6765 3d78 7261 6e67 652c 2079 7261  ange=xrange, yra
-00022ee0: 6e67 653d 7972 616e 6765 2c0a 2020 2020  nge=yrange,.    
-00022ef0: 2020 2020 6d61 7868 3d6d 6178 682c 2074      maxh=maxh, t
-00022f00: 7261 6e73 706f 7365 3d74 7261 6e73 706f  ranspose=transpo
-00022f10: 7365 2c0a 2020 2020 2020 2020 6173 7065  se,.        aspe
-00022f20: 6374 3d61 7370 6563 742c 2073 7479 6c65  ct=aspect, style
-00022f30: 3d73 7479 6c65 0a20 2020 2029 3b0a 2020  =style.    );.  
-00022f40: 2020 6174 7461 6368 6162 6c65 2861 6e63    attachable(anc
-00022f50: 686f 722c 7370 696e 2c6f 7269 656e 742c  hor,spin,orient,
-00022f60: 2072 313d 7231 2c20 7232 3d72 322c 206c   r1=r1, r2=r2, l
-00022f70: 3d6c 2920 7b0a 2020 2020 2020 2020 766e  =l) {.        vn
-00022f80: 665f 706f 6c79 6865 6472 6f6e 2876 6e66  f_polyhedron(vnf
-00022f90: 2c20 636f 6e76 6578 6974 793d 636f 6e76  , convexity=conv
-00022fa0: 6578 6974 7929 3b0a 2020 2020 2020 2020  exity);.        
-00022fb0: 6368 696c 6472 656e 2829 3b0a 2020 2020  children();.    
-00022fc0: 7d0a 7d0a 0a0a 2f2f 204d 6f64 756c 653a  }.}...// Module:
-00022fd0: 2072 756c 6572 2829 0a2f 2f20 5573 6167   ruler().// Usag
-00022fe0: 653a 0a2f 2f20 2020 7275 6c65 7228 6c65  e:.//   ruler(le
-00022ff0: 6e67 7468 2c20 7769 6474 682c 205b 7468  ngth, width, [th
-00023000: 6963 6b6e 6573 733d 5d2c 205b 6465 7074  ickness=], [dept
-00023010: 683d 5d2c 205b 6c61 6265 6c73 3d5d 2c20  h=], [labels=], 
-00023020: 5b70 6970 7363 616c 653d 5d2c 205b 6d61  [pipscale=], [ma
-00023030: 7873 6361 6c65 3d5d 2c20 5b63 6f6c 6f72  xscale=], [color
-00023040: 733d 5d2c 205b 616c 7068 613d 5d2c 205b  s=], [alpha=], [
-00023050: 756e 6974 3d5d 2c20 5b69 6e63 683d 5d29  unit=], [inch=])
-00023060: 205b 4154 5441 4348 4d45 4e54 535d 3b0a   [ATTACHMENTS];.
-00023070: 2f2f 2044 6573 6372 6970 7469 6f6e 3a0a  // Description:.
-00023080: 2f2f 2020 2043 7265 6174 6573 2061 2072  //   Creates a r
-00023090: 756c 6572 2066 6f72 2063 6865 636b 696e  uler for checkin
-000230a0: 6720 6469 6d65 6e73 696f 6e73 206f 6620  g dimensions of 
-000230b0: 7468 6520 6d6f 6465 6c0a 2f2f 2041 7267  the model.// Arg
-000230c0: 756d 656e 7473 3a0a 2f2f 2020 206c 656e  uments:.//   len
-000230d0: 6774 6820 3d20 6c65 6e67 7468 206f 6620  gth = length of 
-000230e0: 7468 6520 7275 6c65 722e 2020 4465 6661  the ruler.  Defa
-000230f0: 756c 7420 3130 300a 2f2f 2020 2077 6964  ult 100.//   wid
-00023100: 7468 203d 2077 6964 7468 206f 6620 7468  th = width of th
-00023110: 6520 7275 6c65 722e 2020 4465 6661 756c  e ruler.  Defaul
-00023120: 743a 2073 697a 6520 6f66 2074 6865 206c  t: size of the l
-00023130: 6172 6765 7374 2075 6e69 7420 6469 7669  argest unit divi
-00023140: 7369 6f6e 0a2f 2f20 2020 2d2d 2d0a 2f2f  sion.//   ---.//
-00023150: 2020 2074 6869 636b 6e65 7373 203d 2074     thickness = t
-00023160: 6869 636b 6e65 7373 206f 6620 7468 6520  hickness of the 
-00023170: 7275 6c65 722e 2044 6566 6175 6c74 3a20  ruler. Default: 
-00023180: 310a 2f2f 2020 2064 6570 7468 203d 2074  1.//   depth = t
-00023190: 6865 2064 6570 7468 206f 6620 6d61 726b  he depth of mark
-000231a0: 2073 7562 6469 7669 7369 6f6e 732e 2044   subdivisions. D
-000231b0: 6566 6175 6c74 3a20 330a 2f2f 2020 206c  efault: 3.//   l
-000231c0: 6162 656c 7320 3d20 6472 6177 206e 756d  abels = draw num
-000231d0: 6572 6963 206c 6162 656c 7320 666f 7220  eric labels for 
-000231e0: 6465 7074 6873 2077 6865 7265 206c 6162  depths where lab
-000231f0: 656c 7320 6172 6520 6c61 7267 6572 2074  els are larger t
-00023200: 6861 6e20 312e 2020 4465 6661 756c 743a  han 1.  Default:
-00023210: 2066 616c 7365 0a2f 2f20 2020 7069 7073   false.//   pips
-00023220: 6361 6c65 203d 2077 6964 7468 2073 6361  cale = width sca
-00023230: 6c65 206f 6620 7468 6520 7069 7073 2072  le of the pips r
-00023240: 656c 6174 6976 6520 746f 2074 6865 206e  elative to the n
-00023250: 6578 7420 7369 7a65 2075 702e 2020 4465  ext size up.  De
-00023260: 6661 756c 743a 2031 2f33 0a2f 2f20 2020  fault: 1/3.//   
-00023270: 6d61 7873 6361 6c65 203d 206c 6f67 3130  maxscale = log10
-00023280: 206f 6620 7468 6520 6d61 7869 6d75 6d20   of the maximum 
-00023290: 7769 6474 6820 6469 7669 7369 6f6e 7320  width divisions 
-000232a0: 746f 2064 6973 706c 6179 2e20 2044 6566  to display.  Def
-000232b0: 6175 6c74 3a20 6261 7365 6420 6f6e 2069  ault: based on i
-000232c0: 6e70 7574 206c 656e 6774 680a 2f2f 2020  nput length.//  
-000232d0: 2063 6f6c 6f72 7320 3d20 636f 6c6f 7273   colors = colors
-000232e0: 2074 6f20 7573 6520 666f 7220 7468 6520   to use for the 
-000232f0: 7275 6c65 722c 2061 206c 6973 7420 6f66  ruler, a list of
-00023300: 2074 776f 2076 616c 7565 732e 2020 4465   two values.  De
-00023310: 6661 756c 743a 2060 5b22 626c 6163 6b22  fault: `["black"
-00023320: 2c22 7768 6974 6522 5d60 0a2f 2f20 2020  ,"white"]`.//   
-00023330: 616c 7068 6120 3d20 7472 616e 7370 6172  alpha = transpar
-00023340: 656e 6379 2076 616c 7565 2e20 2044 6566  ency value.  Def
-00023350: 6175 6c74 3a20 312e 300a 2f2f 2020 2075  ault: 1.0.//   u
-00023360: 6e69 7420 3d20 756e 6974 2074 6f20 6d61  nit = unit to ma
-00023370: 726b 2e20 2053 6361 6c65 7320 7468 6520  rk.  Scales the 
-00023380: 7275 6c65 7220 6d61 726b 7320 746f 2061  ruler marks to a
-00023390: 2064 6966 6665 7265 6e74 206c 656e 6774   different lengt
-000233a0: 682e 2020 4465 6661 756c 743a 2031 0a2f  h.  Default: 1./
-000233b0: 2f20 2020 696e 6368 203d 2073 6574 2074  /   inch = set t
-000233c0: 6f20 7472 7565 2066 6f72 2061 2072 756c  o true for a rul
-000233d0: 6572 2073 6361 6c65 6420 746f 2069 6e63  er scaled to inc
-000233e0: 6865 7320 2861 7373 756d 696e 6720 6261  hes (assuming ba
-000233f0: 7365 2064 696d 656e 7369 6f6e 2069 7320  se dimension is 
-00023400: 6d6d 292e 2020 4465 6661 756c 743a 2066  mm).  Default: f
-00023410: 616c 7365 0a2f 2f20 2020 616e 6368 6f72  alse.//   anchor
-00023420: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
-00023430: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
-00023440: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
-00023450: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
-00023460: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
-00023470: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
-00023480: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
-00023490: 604c 4546 542b 4241 434b 2b54 4f50 600a  `LEFT+BACK+TOP`.
-000234a0: 2f2f 2020 2073 7069 6e20 3d20 526f 7461  //   spin = Rota
-000234b0: 7465 2074 6869 7320 6d61 6e79 2064 6567  te this many deg
-000234c0: 7265 6573 2061 726f 756e 6420 7468 6520  rees around the 
-000234d0: 5a20 6178 6973 2e20 2053 6565 205b 7370  Z axis.  See [sp
-000234e0: 696e 5d28 6174 7461 6368 6d65 6e74 732e  in](attachments.
-000234f0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
-00023500: 7370 696e 292e 2020 4465 6661 756c 743a  spin).  Default:
-00023510: 2060 3060 0a2f 2f20 2020 6f72 6965 6e74   `0`.//   orient
-00023520: 203d 2056 6563 746f 7220 746f 2072 6f74   = Vector to rot
-00023530: 6174 6520 746f 7020 746f 7761 7264 732e  ate top towards.
-00023540: 2020 5365 6520 5b6f 7269 656e 745d 2861    See [orient](a
-00023550: 7474 6163 686d 656e 7473 2e73 6361 6423  ttachments.scad#
-00023560: 7375 6273 6563 7469 6f6e 2d6f 7269 656e  subsection-orien
-00023570: 7429 2e20 2044 6566 6175 6c74 3a20 6055  t).  Default: `U
-00023580: 5060 0a2f 2f20 4578 616d 706c 6573 2832  P`.// Examples(2
-00023590: 442c 4269 6729 3a0a 2f2f 2020 2072 756c  D,Big):.//   rul
-000235a0: 6572 2831 3030 2c64 6570 7468 3d33 293b  er(100,depth=3);
-000235b0: 0a2f 2f20 2020 7275 6c65 7228 3130 302c  .//   ruler(100,
-000235c0: 6465 7074 683d 332c 6c61 6265 6c73 3d74  depth=3,labels=t
-000235d0: 7275 6529 3b0a 2f2f 2020 2072 756c 6572  rue);.//   ruler
-000235e0: 2832 3729 3b0a 2f2f 2020 2072 756c 6572  (27);.//   ruler
-000235f0: 2832 372c 6d61 7873 6361 6c65 3d30 293b  (27,maxscale=0);
-00023600: 0a2f 2f20 2020 7275 6c65 7228 3130 302c  .//   ruler(100,
-00023610: 7069 7073 6361 6c65 3d33 2f34 2c64 6570  pipscale=3/4,dep
-00023620: 7468 3d32 293b 0a2f 2f20 2020 7275 6c65  th=2);.//   rule
-00023630: 7228 3130 302c 7769 6474 683d 322c 6465  r(100,width=2,de
-00023640: 7074 683d 3229 3b0a 2f2f 2045 7861 6d70  pth=2);.// Examp
-00023650: 6c65 2832 442c 4269 6729 3a20 204d 6574  le(2D,Big):  Met
-00023660: 7269 6320 7673 2049 6d70 6572 6961 6c0a  ric vs Imperial.
-00023670: 2f2f 2020 2072 756c 6572 2831 322c 7769  //   ruler(12,wi
-00023680: 6474 683d 3530 2c69 6e63 683d 7472 7565  dth=50,inch=true
-00023690: 2c6c 6162 656c 733d 7472 7565 2c6d 6178  ,labels=true,max
-000236a0: 7363 616c 653d 3029 3b0a 2f2f 2020 2066  scale=0);.//   f
-000236b0: 7764 2835 3029 7275 6c65 7228 3330 302c  wd(50)ruler(300,
-000236c0: 7769 6474 683d 3530 2c6c 6162 656c 733d  width=50,labels=
-000236d0: 7472 7565 293b 0a6d 6f64 756c 6520 7275  true);.module ru
-000236e0: 6c65 7228 6c65 6e67 7468 3d31 3030 2c20  ler(length=100, 
-000236f0: 7769 6474 682c 2074 6869 636b 6e65 7373  width, thickness
-00023700: 3d31 2c20 6465 7074 683d 332c 206c 6162  =1, depth=3, lab
-00023710: 656c 733d 6661 6c73 652c 2070 6970 7363  els=false, pipsc
-00023720: 616c 653d 312f 332c 206d 6178 7363 616c  ale=1/3, maxscal
-00023730: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00023740: 636f 6c6f 7273 3d5b 2262 6c61 636b 222c  colors=["black",
-00023750: 2277 6869 7465 225d 2c20 616c 7068 613d  "white"], alpha=
-00023760: 312e 302c 2075 6e69 743d 312c 2069 6e63  1.0, unit=1, inc
-00023770: 683d 6661 6c73 652c 2061 6e63 686f 723d  h=false, anchor=
-00023780: 4c45 4654 2b42 4143 4b2b 544f 502c 2073  LEFT+BACK+TOP, s
-00023790: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
-000237a0: 290a 7b0a 2020 2020 696e 6368 6661 6374  ).{.    inchfact
-000237b0: 6f72 203d 2032 352e 343b 0a20 2020 2063  or = 25.4;.    c
-000237c0: 6865 636b 7320 3d0a 2020 2020 2020 2020  hecks =.        
-000237d0: 6173 7365 7274 2864 6570 7468 3c3d 352c  assert(depth<=5,
-000237e0: 2022 4361 6e6e 6f74 2072 656e 6465 7220   "Cannot render 
-000237f0: 7363 616c 6573 2073 6d61 6c6c 6572 2074  scales smaller t
-00023800: 6861 6e20 6465 7074 683d 3522 290a 2020  han depth=5").  
-00023810: 2020 2020 2020 6173 7365 7274 286c 656e        assert(len
-00023820: 2863 6f6c 6f72 7329 3d3d 322c 2022 636f  (colors)==2, "co
-00023830: 6c6f 7273 206d 7573 7420 636f 6e74 6169  lors must contai
-00023840: 6e20 6120 6c69 7374 206f 6620 6578 6163  n a list of exac
-00023850: 746c 7920 7477 6f20 636f 6c6f 7273 2e22  tly two colors."
-00023860: 293b 0a20 2020 206c 656e 6774 6820 3d20  );.    length = 
-00023870: 696e 6368 203f 2069 6e63 6866 6163 746f  inch ? inchfacto
-00023880: 7220 2a20 6c65 6e67 7468 203a 206c 656e  r * length : len
-00023890: 6774 683b 0a20 2020 2075 6e69 7420 3d20  gth;.    unit = 
-000238a0: 696e 6368 203f 2069 6e63 6866 6163 746f  inch ? inchfacto
-000238b0: 722a 756e 6974 203a 2075 6e69 743b 0a20  r*unit : unit;. 
-000238c0: 2020 206d 6178 7363 616c 6520 3d20 6973     maxscale = is
-000238d0: 5f64 6566 286d 6178 7363 616c 6529 3f20  _def(maxscale)? 
-000238e0: 6d61 7873 6361 6c65 203a 2066 6c6f 6f72  maxscale : floor
-000238f0: 286c 6f67 286c 656e 6774 682f 756e 6974  (log(length/unit
-00023900: 2d45 5053 494c 4f4e 2929 3b0a 2020 2020  -EPSILON));.    
-00023910: 7363 616c 6573 203d 2075 6e69 7420 2a20  scales = unit * 
-00023920: 5b66 6f72 286c 6f67 7369 7a65 203d 205b  [for(logsize = [
-00023930: 6d61 7873 6361 6c65 3a2d 313a 6d61 7873  maxscale:-1:maxs
-00023940: 6361 6c65 2d64 6570 7468 2b31 5d29 2070  cale-depth+1]) p
-00023950: 6f77 2831 302c 6c6f 6773 697a 6529 5d3b  ow(10,logsize)];
-00023960: 0a20 2020 2077 6964 7468 6661 6374 6f72  .    widthfactor
-00023970: 203d 2028 312d 7069 7073 6361 6c65 2920   = (1-pipscale) 
-00023980: 2f20 2831 2d70 6f77 2870 6970 7363 616c  / (1-pow(pipscal
-00023990: 652c 6465 7074 6829 293b 0a20 2020 2077  e,depth));.    w
-000239a0: 6964 7468 203d 2064 6566 6175 6c74 2877  idth = default(w
-000239b0: 6964 7468 2c20 7363 616c 6573 5b30 5d29  idth, scales[0])
-000239c0: 3b0a 2020 2020 7769 6474 6873 203d 2077  ;.    widths = w
-000239d0: 6964 7468 202a 2077 6964 7468 6661 6374  idth * widthfact
-000239e0: 6f72 202a 205b 666f 7228 6c6f 6773 697a  or * [for(logsiz
-000239f0: 6520 3d20 5b30 3a2d 313a 2d64 6570 7468  e = [0:-1:-depth
-00023a00: 2b31 5d29 2070 6f77 2870 6970 7363 616c  +1]) pow(pipscal
-00023a10: 652c 2d6c 6f67 7369 7a65 295d 3b0a 2020  e,-logsize)];.  
-00023a20: 2020 6f66 6673 6574 7320 3d20 636f 6e63    offsets = conc
-00023a30: 6174 285b 305d 2c63 756d 7375 6d28 7769  at([0],cumsum(wi
-00023a40: 6474 6873 2929 3b0a 2020 2020 6174 7461  dths));.    atta
-00023a50: 6368 6162 6c65 2861 6e63 686f 722c 7370  chable(anchor,sp
-00023a60: 696e 2c6f 7269 656e 742c 2073 697a 653d  in,orient, size=
-00023a70: 5b6c 656e 6774 682c 7769 6474 682c 7468  [length,width,th
-00023a80: 6963 6b6e 6573 735d 2920 7b0a 2020 2020  ickness]) {.    
-00023a90: 2020 2020 7472 616e 736c 6174 6528 5b2d      translate([-
-00023aa0: 6c65 6e67 7468 2f32 2c20 2d77 6964 7468  length/2, -width
-00023ab0: 2f32 2c20 305d 2920 0a20 2020 2020 2020  /2, 0]) .       
-00023ac0: 2066 6f72 2869 3d5b 303a 313a 6c65 6e28   for(i=[0:1:len(
-00023ad0: 7363 616c 6573 292d 315d 2920 7b0a 2020  scales)-1]) {.  
-00023ae0: 2020 2020 2020 2020 2020 636f 756e 7420            count 
-00023af0: 3d20 6365 696c 286c 656e 6774 682f 7363  = ceil(length/sc
-00023b00: 616c 6573 5b69 5d29 3b0a 2020 2020 2020  ales[i]);.      
-00023b10: 2020 2020 2020 666f 6e74 7369 7a65 203d        fontsize =
-00023b20: 2030 2e35 2a6d 696e 2877 6964 7468 735b   0.5*min(widths[
-00023b30: 695d 2c20 7363 616c 6573 5b69 5d2f 6365  i], scales[i]/ce
-00023b40: 696c 286c 6f67 2863 6f75 6e74 2a73 6361  il(log(count*sca
-00023b50: 6c65 735b 695d 2f75 6e69 7429 2929 3b0a  les[i]/unit)));.
-00023b60: 2020 2020 2020 2020 2020 2020 6261 636b              back
-00023b70: 286f 6666 7365 7473 5b69 5d29 207b 0a20  (offsets[i]) {. 
-00023b80: 2020 2020 2020 2020 2020 2020 2020 2078                 x
-00023b90: 636f 7069 6573 2873 6361 6c65 735b 695d  copies(scales[i]
-00023ba0: 2c20 6e3d 636f 756e 742c 2073 703d 5b30  , n=count, sp=[0
-00023bb0: 2c30 2c30 5d29 2075 6e69 6f6e 2829 207b  ,0,0]) union() {
-00023bc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00023bd0: 2020 2020 2061 6374 6c65 6e20 3d20 2824       actlen = ($
-00023be0: 6964 783c 636f 756e 742d 3129 207c 7c20  idx<count-1) || 
-00023bf0: 6170 7072 6f78 286c 656e 6774 6825 7363  approx(length%sc
-00023c00: 616c 6573 5b69 5d2c 3029 203f 2073 6361  ales[i],0) ? sca
-00023c10: 6c65 735b 695d 203a 206c 656e 6774 6820  les[i] : length 
-00023c20: 2520 7363 616c 6573 5b69 5d3b 0a20 2020  % scales[i];.   
-00023c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023c40: 2063 6f6c 6f72 2863 6f6c 6f72 735b 2469   color(colors[$i
-00023c50: 6478 2532 5d2c 2061 6c70 6861 3d61 6c70  dx%2], alpha=alp
-00023c60: 6861 2920 7b0a 2020 2020 2020 2020 2020  ha) {.          
-00023c70: 2020 2020 2020 2020 2020 2020 2020 7720                w 
-00023c80: 3d20 693e 3020 3f20 7175 616e 7475 7028  = i>0 ? quantup(
-00023c90: 7769 6474 6873 5b69 5d2c 312f 3130 3234  widths[i],1/1024
-00023ca0: 2920 3a20 7769 6474 6873 5b69 5d3b 2020  ) : widths[i];  
-00023cb0: 2020 2f2f 2057 6861 7420 6973 2074 6865    // What is the
-00023cc0: 2069 3e30 2074 6573 7420 7375 7070 6f73   i>0 test suppos
-00023cd0: 6564 2074 6f20 646f 2068 6572 653f 200a  ed to do here? .
-00023ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023cf0: 2020 2020 2020 2020 6375 6265 285b 7175          cube([qu
-00023d00: 616e 7475 7028 6163 746c 656e 2c31 2f31  antup(actlen,1/1
-00023d10: 3032 3429 2c71 7561 6e74 7570 2877 2c31  024),quantup(w,1
-00023d20: 2f31 3032 3429 2c74 6869 636b 6e65 7373  /1024),thickness
-00023d30: 5d2c 2061 6e63 686f 723d 4652 4f4e 542b  ], anchor=FRONT+
-00023d40: 4c45 4654 293b 0a20 2020 2020 2020 2020  LEFT);.         
-00023d50: 2020 2020 2020 2020 2020 207d 0a20 2020             }.   
-00023d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d70: 206d 6172 6b20 3d0a 2020 2020 2020 2020   mark =.        
-00023d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023d90: 6920 3d3d 2030 2026 2620 2469 6478 2025  i == 0 && $idx %
-00023da0: 2031 3020 3d3d 2030 2026 2620 2469 6478   10 == 0 && $idx
-00023db0: 2021 3d20 3020 3f20 3020 3a0a 2020 2020   != 0 ? 0 :.    
-00023dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023dd0: 2020 2020 6920 3d3d 2030 2026 2620 2469      i == 0 && $i
-00023de0: 6478 2025 2031 3020 3d3d 2039 2026 2620  dx % 10 == 9 && 
-00023df0: 2469 6478 2021 3d20 636f 756e 742d 3120  $idx != count-1 
-00023e00: 3f20 3120 3a0a 2020 2020 2020 2020 2020  ? 1 :.          
-00023e10: 2020 2020 2020 2020 2020 2020 2020 2469                $i
-00023e20: 6478 2025 2031 3020 3d3d 2034 203f 2031  dx % 10 == 4 ? 1
-00023e30: 203a 0a20 2020 2020 2020 2020 2020 2020   :.             
-00023e40: 2020 2020 2020 2020 2020 2024 6964 7820             $idx 
-00023e50: 2520 3130 203d 3d20 3520 3f20 3020 3a20  % 10 == 5 ? 0 : 
-00023e60: 2d31 3b0a 2020 2020 2020 2020 2020 2020  -1;.            
-00023e70: 2020 2020 2020 2020 666c 6970 203d 2031          flip = 1
-00023e80: 2d6d 6172 6b2a 323b 0a20 2020 2020 2020  -mark*2;.       
-00023e90: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00023ea0: 286d 6172 6b20 3e3d 2030 2920 7b0a 2020  (mark >= 0) {.  
-00023eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023ec0: 2020 2020 2020 6d61 726b 6c65 6e67 7468        marklength
-00023ed0: 203d 206d 696e 2877 6964 7468 735b 695d   = min(widths[i]
-00023ee0: 2f32 2c20 7363 616c 6573 5b69 5d2a 3229  /2, scales[i]*2)
-00023ef0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-00023f00: 2020 2020 2020 2020 2020 6d61 726b 7769            markwi
-00023f10: 6474 6820 3d20 6d61 726b 6c65 6e67 7468  dth = marklength
-00023f20: 2a30 2e34 3b0a 2020 2020 2020 2020 2020  *0.4;.          
-00023f30: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00023f40: 616e 736c 6174 6528 5b6d 6172 6b2a 7363  anslate([mark*sc
-00023f50: 616c 6573 5b69 5d2c 2077 6964 7468 735b  ales[i], widths[
-00023f60: 695d 2c20 305d 2920 7b0a 2020 2020 2020  i], 0]) {.      
-00023f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023f80: 2020 2020 2020 636f 6c6f 7228 636f 6c6f        color(colo
-00023f90: 7273 5b31 2d24 6964 7825 325d 2c20 616c  rs[1-$idx%2], al
-00023fa0: 7068 613d 616c 7068 6129 207b 0a20 2020  pha=alpha) {.   
-00023fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00023fc0: 2020 2020 2020 2020 2020 2020 206c 696e               lin
-00023fd0: 6561 725f 6578 7472 7564 6528 6865 6967  ear_extrude(heig
-00023fe0: 6874 3d74 6869 636b 6e65 7373 2b73 6361  ht=thickness+sca
-00023ff0: 6c65 735b 695d 2f31 3030 2c20 636f 6e76  les[i]/100, conv
-00024000: 6578 6974 793d 322c 2063 656e 7465 723d  exity=2, center=
-00024010: 7472 7565 2920 7b0a 2020 2020 2020 2020  true) {.        
-00024020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024030: 2020 2020 2020 2020 2020 2020 706f 6c79              poly
-00024040: 676f 6e28 7363 616c 6528 5b66 6c69 702a  gon(scale([flip*
-00024050: 6d61 726b 7769 6474 682c 206d 6172 6b6c  markwidth, markl
-00024060: 656e 6774 685d 2c70 3d5b 5b30 2c30 5d2c  ength],p=[[0,0],
-00024070: 205b 312c 202d 315d 2c20 5b30 2c2d 302e   [1, -1], [0,-0.
-00024080: 395d 5d29 293b 0a20 2020 2020 2020 2020  9]]));.         
-00024090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000240a0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-000240b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000240c0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-000240d0: 2020 2020 2020 2020 2020 2020 2020 207d                 }
-000240e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000240f0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-00024100: 2020 2020 2020 2020 2020 2069 6620 286c             if (l
-00024110: 6162 656c 7320 2626 2073 6361 6c65 735b  abels && scales[
-00024120: 695d 2f75 6e69 742b 4550 5349 4c4f 4e20  i]/unit+EPSILON 
-00024130: 3e3d 2031 2920 7b0a 2020 2020 2020 2020  >= 1) {.        
-00024140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024150: 636f 6c6f 7228 636f 6c6f 7273 5b28 2469  color(colors[($i
-00024160: 6478 2b31 2925 325d 2c20 616c 7068 613d  dx+1)%2], alpha=
-00024170: 616c 7068 6129 207b 0a20 2020 2020 2020  alpha) {.       
-00024180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024190: 2020 2020 206c 696e 6561 725f 6578 7472       linear_extr
-000241a0: 7564 6528 6865 6967 6874 3d74 6869 636b  ude(height=thick
-000241b0: 6e65 7373 2b73 6361 6c65 735b 695d 2f31  ness+scales[i]/1
-000241c0: 3030 2c20 636f 6e76 6578 6974 793d 322c  00, convexity=2,
-000241d0: 2063 656e 7465 723d 7472 7565 2920 7b0a   center=true) {.
-000241e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000241f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024200: 6261 636b 2873 6361 6c65 735b 695d 2a2e  back(scales[i]*.
-00024210: 3032 2920 7b0a 2020 2020 2020 2020 2020  02) {.          
-00024220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024230: 2020 2020 2020 2020 2020 7465 7874 2874            text(t
-00024240: 6578 743d 7374 7228 2024 6964 7820 2a20  ext=str( $idx * 
-00024250: 7363 616c 6573 5b69 5d20 2f20 756e 6974  scales[i] / unit
-00024260: 292c 2073 697a 653d 666f 6e74 7369 7a65  ), size=fontsize
-00024270: 2c20 6861 6c69 676e 3d22 6c65 6674 222c  , halign="left",
-00024280: 2076 616c 6967 6e3d 2262 6173 656c 696e   valign="baselin
-00024290: 6522 293b 0a20 2020 2020 2020 2020 2020  e");.           
-000242a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000242b0: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-000242c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000242d0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
-000242e0: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
-000242f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024300: 2020 207d 0a0a 2020 2020 2020 2020 2020     }..          
-00024310: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-00024320: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-00024330: 2020 2020 2020 2020 6368 696c 6472 656e          children
-00024340: 2829 3b0a 2020 2020 7d0a 7d0a 0a0a 0a0a  ();.    }.}.....
-00024350: 0a2f 2f20 7669 6d3a 2065 7870 616e 6474  .// vim: expandt
-00024360: 6162 2074 6162 7374 6f70 3d34 2073 6869  ab tabstop=4 shi
-00024370: 6674 7769 6474 683d 3420 736f 6674 7461  ftwidth=4 softta
-00024380: 6273 746f 703d 3420 6e6f 7772 6170 0a    bstop=4 nowrap.
+0001c1b0: 6c65 7428 7468 6574 6120 3d20 286a 2b28  let(theta = (j+(
+0001c1c0: 2873 7461 6767 6572 2026 2620 6925 3221  (stagger && i%2!
+0001c1d0: 3d30 293f 302e 353a 3029 292a 3336 302f  =0)?0.5:0))*360/
+0001c1e0: 6873 6964 6573 290a 2020 2020 2020 2020  hsides).        
+0001c1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c200: 2020 2020 2020 2020 2020 2073 7068 6572             spher
+0001c210: 6963 616c 5f74 6f5f 7879 7a28 722c 2074  ical_to_xyz(r, t
+0001c220: 6865 7461 2c20 7068 6929 2c0a 2020 2020  heta, phi),.    
+0001c230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c240: 2020 2020 2020 2073 7068 6572 6963 616c         spherical
+0001c250: 5f74 6f5f 7879 7a28 722c 2030 2c20 3138  _to_xyz(r, 0, 18
+0001c260: 3029 0a20 2020 2020 2020 2020 2020 2020  0).             
+0001c270: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+0001c280: 2020 2020 2020 2020 2020 2020 3a20 7374              : st
+0001c290: 796c 653d 3d22 6f63 7461 223f 0a20 2020  yle=="octa"?.   
+0001c2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c2b0: 2020 206c 6574 280a 2020 2020 2020 2020     let(.        
+0001c2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c2d0: 2020 206d 6572 6964 6961 6e73 203d 205b     meridians = [
+0001c2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c300: 2020 2020 2020 2020 2031 2c0a 2020 2020           1,.    
+0001c310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c330: 2020 2020 666f 7220 2869 203d 205b 313a      for (i = [1:
+0001c340: 313a 6f63 7461 5f73 7465 7073 5d29 2069  1:octa_steps]) i
+0001c350: 2a34 2c0a 2020 2020 2020 2020 2020 2020  *4,.            
+0001c360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c370: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+0001c380: 2869 203d 205b 6f63 7461 5f73 7465 7073  (i = [octa_steps
+0001c390: 2d31 3a2d 313a 315d 2920 692a 342c 0a20  -1:-1:1]) i*4,. 
+0001c3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c3c0: 2020 2020 2020 2031 2c0a 2020 2020 2020         1,.      
+0001c3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c3f0: 205d 0a20 2020 2020 2020 2020 2020 2020   ].             
+0001c400: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+0001c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c420: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+0001c430: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
+0001c440: 3d69 6478 286d 6572 6964 6961 6e73 292c  =idx(meridians),
+0001c450: 206a 3d5b 303a 313a 6d65 7269 6469 616e   j=[0:1:meridian
+0001c460: 735b 695d 2d31 5d29 0a20 2020 2020 2020  s[i]-1]).       
+0001c470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c480: 2020 2020 7370 6865 7269 6361 6c5f 746f      spherical_to
+0001c490: 5f78 797a 2872 2c20 6a2a 3336 302f 6d65  _xyz(r, j*360/me
+0001c4a0: 7269 6469 616e 735b 695d 2c20 692a 3138  ridians[i], i*18
+0001c4b0: 302f 286c 656e 286d 6572 6964 6961 6e73  0/(len(meridians
+0001c4c0: 292d 3129 290a 2020 2020 2020 2020 2020  )-1)).          
+0001c4d0: 2020 2020 2020 2020 2020 2020 5d0a 2020              ].  
+0001c4e0: 2020 2020 2020 2020 2020 2020 3a20 6173              : as
+0001c4f0: 7365 7274 2869 6e5f 6c69 7374 2873 7479  sert(in_list(sty
+0001c500: 6c65 2c5b 226f 7269 6722 2c22 616c 6967  le,["orig","alig
+0001c510: 6e65 6422 2c22 7374 6167 6765 7222 2c22  ned","stagger","
+0001c520: 6f63 7461 222c 2269 636f 7361 225d 2929  octa","icosa"]))
+0001c530: 2c0a 2020 2020 2020 2020 6c76 203d 206c  ,.        lv = l
+0001c540: 656e 2876 6572 7473 292c 0a20 2020 2020  en(verts),.     
+0001c550: 2020 2066 6163 6573 203d 2063 6972 6375     faces = circu
+0001c560: 6d20 2626 2073 7479 6c65 3d3d 2273 7461  m && style=="sta
+0001c570: 6767 6572 2220 3f0a 2020 2020 2020 2020  gger" ?.        
+0001c580: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0001c590: 2870 7463 6f75 6e74 3d32 2a68 7369 6465  (ptcount=2*hside
+0001c5a0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+0001c5b0: 2020 2020 2020 2020 5b0a 2020 2020 2020          [.      
+0001c5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c5d0: 205b 666f 7228 693d 5b70 7463 6f75 6e74   [for(i=[ptcount
+0001c5e0: 2d32 3a2d 323a 305d 2920 695d 2c0a 2020  -2:-2:0]) i],.  
+0001c5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c600: 2020 2020 2066 6f72 286a 3d5b 303a 6873       for(j=[0:hs
+0001c610: 6964 6573 2d31 5d29 0a20 2020 2020 2020  ides-1]).       
+0001c620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c630: 2020 2020 5b6a 2a32 2c20 286a 2a32 2b32      [j*2, (j*2+2
+0001c640: 2925 7074 636f 756e 742c 7074 636f 756e  )%ptcount,ptcoun
+0001c650: 742b 286a 2a32 2b32 2925 7074 636f 756e  t+(j*2+2)%ptcoun
+0001c660: 742c 7074 636f 756e 742b 286a 2a32 2b33  t,ptcount+(j*2+3
+0001c670: 2925 7074 636f 756e 742c 7074 636f 756e  )%ptcount,ptcoun
+0001c680: 742b 6a2a 325d 2c0a 2020 2020 2020 2020  t+j*2],.        
+0001c690: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0001c6a0: 6f72 2869 3d5b 313a 7673 6964 6573 2d33  or(i=[1:vsides-3
+0001c6b0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0001c6c0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+0001c6d0: 7428 6261 7365 3d70 7463 6f75 6e74 2a69  t(base=ptcount*i
+0001c6e0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001c6f0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0001c700: 286a 3d5b 303a 6873 6964 6573 2d31 5d29  (j=[0:hsides-1])
+0001c710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c730: 6925 323d 3d30 203f 205b 6261 7365 2b32  i%2==0 ? [base+2
+0001c740: 2a6a 2c20 6261 7365 2b28 322a 6a2b 3129  *j, base+(2*j+1)
+0001c750: 2570 7463 6f75 6e74 2c20 6261 7365 2b28  %ptcount, base+(
+0001c760: 322a 6a2b 3229 2570 7463 6f75 6e74 2c0a  2*j+2)%ptcount,.
+0001c770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c790: 2020 2020 2020 2020 6261 7365 2b70 7463          base+ptc
+0001c7a0: 6f75 6e74 2b28 322a 6a29 2570 7463 6f75  ount+(2*j)%ptcou
+0001c7b0: 6e74 2c20 6261 7365 2b70 7463 6f75 6e74  nt, base+ptcount
+0001c7c0: 2b28 322a 6a2b 3129 2570 7463 6f75 6e74  +(2*j+1)%ptcount
+0001c7d0: 2c20 6261 7365 2b70 7463 6f75 6e74 2b28  , base+ptcount+(
+0001c7e0: 322a 6a2d 322b 7074 636f 756e 7429 2570  2*j-2+ptcount)%p
+0001c7f0: 7463 6f75 6e74 5d0a 2020 2020 2020 2020  tcount].        
+0001c800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c810: 2020 2020 2020 2020 2020 2020 2020 3a20                : 
+0001c820: 5b62 6173 652b 2831 2b32 2a6a 2925 7074  [base+(1+2*j)%pt
+0001c830: 636f 756e 742c 2062 6173 652b 2832 2a6a  count, base+(2*j
+0001c840: 2925 7074 636f 756e 742c 2062 6173 652b  )%ptcount, base+
+0001c850: 2832 2a6a 2b33 2925 7074 636f 756e 742c  (2*j+3)%ptcount,
+0001c860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c880: 2020 2020 2020 2020 2020 6261 7365 2b70            base+p
+0001c890: 7463 6f75 6e74 2b28 332b 322a 6a29 2570  tcount+(3+2*j)%p
+0001c8a0: 7463 6f75 6e74 2c20 6261 7365 2b70 7463  tcount, base+ptc
+0001c8b0: 6f75 6e74 2b28 322a 6a2b 3229 2570 7463  ount+(2*j+2)%ptc
+0001c8c0: 6f75 6e74 2c62 6173 652b 7074 636f 756e  ount,base+ptcoun
+0001c8d0: 742b 2832 2a6a 2b31 2925 7074 636f 756e  t+(2*j+1)%ptcoun
+0001c8e0: 745d 2c0a 2020 2020 2020 2020 2020 2020  t],.            
+0001c8f0: 2020 2020 2020 2020 2020 2066 6f72 286a             for(j
+0001c900: 3d5b 303a 6873 6964 6573 2d31 5d29 0a20  =[0:hsides-1]). 
+0001c910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c920: 2020 2020 2020 2020 2076 7369 6465 7325           vsides%
+0001c930: 323d 3d30 0a20 2020 2020 2020 2020 2020  2==0.           
+0001c940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c950: 203f 205b 286a 2a32 2b33 2925 7074 636f   ? [(j*2+3)%ptco
+0001c960: 756e 742c 206a 2a32 2b31 2c20 6c76 2d70  unt, j*2+1, lv-p
+0001c970: 7463 6f75 6e74 2b28 322b 6a2a 3229 2570  tcount+(2+j*2)%p
+0001c980: 7463 6f75 6e74 2c20 6c76 2d70 7463 6f75  tcount, lv-ptcou
+0001c990: 6e74 2b28 332b 6a2a 3229 2570 7463 6f75  nt+(3+j*2)%ptcou
+0001c9a0: 6e74 2c20 6c76 2d70 7463 6f75 6e74 2b28  nt, lv-ptcount+(
+0001c9b0: 342b 6a2a 3229 2570 7463 6f75 6e74 5d0a  4+j*2)%ptcount].
+0001c9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c9d0: 2020 2020 2020 2020 2020 2020 3a20 5b28              : [(
+0001c9e0: 6a2a 322b 3329 2570 7463 6f75 6e74 2c20  j*2+3)%ptcount, 
+0001c9f0: 6a2a 322b 312c 206c 762d 7074 636f 756e  j*2+1, lv-ptcoun
+0001ca00: 742b 2831 2b6a 2a32 2925 7074 636f 756e  t+(1+j*2)%ptcoun
+0001ca10: 742c 206c 762d 7074 636f 756e 742b 286a  t, lv-ptcount+(j
+0001ca20: 2a32 2925 7074 636f 756e 742c 206c 762d  *2)%ptcount, lv-
+0001ca30: 7074 636f 756e 742b 2833 2b6a 2a32 2925  ptcount+(3+j*2)%
+0001ca40: 7074 636f 756e 745d 2c0a 2020 2020 2020  ptcount],.      
+0001ca50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ca60: 205b 666f 7228 693d 5b31 3a32 3a70 7463   [for(i=[1:2:ptc
+0001ca70: 6f75 6e74 2d31 5d29 2069 5d2c 0a20 2020  ount-1]) i],.   
+0001ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ca90: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
+0001caa0: 2020 3a20 7374 796c 653d 3d22 616c 6967    : style=="alig
+0001cab0: 6e65 6422 207c 7c20 7374 796c 653d 3d22  ned" || style=="
+0001cac0: 7374 6167 6765 7222 203f 2020 2f2f 2069  stagger" ?  // i
+0001cad0: 6e63 6c75 6465 7320 6361 7365 206f 6620  ncludes case of 
+0001cae0: 616c 6967 6e65 6420 7769 7468 2063 6972  aligned with cir
+0001caf0: 6375 6d20 3d3d 2074 7275 650a 2020 2020  cum == true.    
+0001cb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cb10: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
+0001cb20: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
+0001cb30: 3d5b 303a 313a 6873 6964 6573 2d31 5d29  =[0:1:hsides-1])
+0001cb40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001cb50: 2020 2020 2020 2020 2020 2020 6c65 7428              let(
+0001cb60: 6232 203d 206c 762d 322d 6873 6964 6573  b2 = lv-2-hsides
+0001cb70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001cb80: 2020 2020 2020 2020 2020 2020 2065 6163               eac
+0001cb90: 6820 5b0a 2020 2020 2020 2020 2020 2020  h [.            
+0001cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cbb0: 2020 2020 205b 692b 312c 2030 2c20 2828       [i+1, 0, ((
+0001cbc0: 692b 3129 2568 7369 6465 7329 2b31 5d2c  i+1)%hsides)+1],
+0001cbd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001cbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cbf0: 2020 5b6c 762d 312c 2062 322b 692b 312c    [lv-1, b2+i+1,
+0001cc00: 2062 322b 2828 692b 3129 2568 7369 6465   b2+((i+1)%hside
+0001cc10: 7329 2b31 5d2c 0a20 2020 2020 2020 2020  s)+1],.         
+0001cc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cc30: 2020 2020 2020 205d 2c0a 2020 2020 2020         ],.      
+0001cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cc50: 2066 6f72 2028 693d 5b30 3a31 3a76 7369   for (i=[0:1:vsi
+0001cc60: 6465 732d 335d 2c20 6a3d 5b30 3a31 3a68  des-3], j=[0:1:h
+0001cc70: 7369 6465 732d 315d 290a 2020 2020 2020  sides-1]).      
+0001cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cc90: 2020 2020 206c 6574 2862 6173 6520 3d20       let(base = 
+0001cca0: 3120 2b20 6873 6964 6573 2a69 290a 2020  1 + hsides*i).  
+0001ccb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ccc0: 2020 2020 2020 2020 2065 6163 6820 280a           each (.
+0001ccd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ccf0: 2028 7374 6167 6765 7220 2626 2069 2532   (stagger && i%2
+0001cd00: 213d 3029 3f20 5b0a 2020 2020 2020 2020  !=0)? [.        
+0001cd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cd20: 2020 2020 2020 2020 2020 2020 205b 6261               [ba
+0001cd30: 7365 2b6a 2c20 6261 7365 2b68 7369 6465  se+j, base+hside
+0001cd40: 732b 6a25 6873 6964 6573 2c20 6261 7365  s+j%hsides, base
+0001cd50: 2b68 7369 6465 732b 286a 2b68 7369 6465  +hsides+(j+hside
+0001cd60: 732d 3129 2568 7369 6465 735d 2c0a 2020  s-1)%hsides],.  
+0001cd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cd90: 2020 205b 6261 7365 2b6a 2c20 6261 7365     [base+j, base
+0001cda0: 2b28 6a2b 3129 2568 7369 6465 732c 2062  +(j+1)%hsides, b
+0001cdb0: 6173 652b 6873 6964 6573 2b6a 5d2c 0a20  ase+hsides+j],. 
+0001cdc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cdd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cde0: 5d20 3a20 5b0a 2020 2020 2020 2020 2020  ] : [.          
+0001cdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce00: 2020 2020 2020 2020 2020 205b 6261 7365             [base
+0001ce10: 2b6a 2c20 6261 7365 2b28 6a2b 3129 2568  +j, base+(j+1)%h
+0001ce20: 7369 6465 732c 2062 6173 652b 6873 6964  sides, base+hsid
+0001ce30: 6573 2b28 6a2b 3129 2568 7369 6465 735d  es+(j+1)%hsides]
+0001ce40: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001ce50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ce60: 2020 2020 2020 205b 6261 7365 2b6a 2c20         [base+j, 
+0001ce70: 6261 7365 2b68 7369 6465 732b 286a 2b31  base+hsides+(j+1
+0001ce80: 2925 6873 6964 6573 2c20 6261 7365 2b68  )%hsides, base+h
+0001ce90: 7369 6465 732b 6a5d 2c0a 2020 2020 2020  sides+j],.      
+0001cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ceb0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+0001cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ced0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0001cee0: 2020 2020 2020 2020 2020 2020 2020 205d                 ]
+0001cef0: 0a20 2020 2020 2020 2020 2020 2020 203a  .              :
+0001cf00: 2073 7479 6c65 3d3d 226f 7269 6722 3f20   style=="orig"? 
+0001cf10: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+0001cf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cf30: 2020 5b66 6f72 2028 693d 5b30 3a31 3a68    [for (i=[0:1:h
+0001cf40: 7369 6465 732d 315d 2920 6873 6964 6573  sides-1]) hsides
+0001cf50: 2d69 2d31 5d2c 0a20 2020 2020 2020 2020  -i-1],.         
+0001cf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cf70: 2020 2020 2020 205b 666f 7220 2869 3d5b         [for (i=[
+0001cf80: 303a 313a 6873 6964 6573 2d31 5d29 206c  0:1:hsides-1]) l
+0001cf90: 762d 6873 6964 6573 2b69 5d2c 0a20 2020  v-hsides+i],.   
+0001cfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cfb0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0001cfc0: 2028 693d 5b30 3a31 3a76 7369 6465 732d   (i=[0:1:vsides-
+0001cfd0: 325d 2c20 6a3d 5b30 3a31 3a68 7369 6465  2], j=[0:1:hside
+0001cfe0: 732d 315d 290a 2020 2020 2020 2020 2020  s-1]).          
+0001cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d000: 2020 2020 2020 2020 2020 6561 6368 205b            each [
+0001d010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d030: 2020 2020 2020 2020 2020 205b 2869 2b31             [(i+1
+0001d040: 292a 6873 6964 6573 2b6a 2c20 692a 6873  )*hsides+j, i*hs
+0001d050: 6964 6573 2b6a 2c20 692a 6873 6964 6573  ides+j, i*hsides
+0001d060: 2b28 6a2b 3129 2568 7369 6465 735d 2c0a  +(j+1)%hsides],.
+0001d070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d090: 2020 2020 2020 2020 2020 5b28 692b 3129            [(i+1)
+0001d0a0: 2a68 7369 6465 732b 6a2c 2069 2a68 7369  *hsides+j, i*hsi
+0001d0b0: 6465 732b 286a 2b31 2925 6873 6964 6573  des+(j+1)%hsides
+0001d0c0: 2c20 2869 2b31 292a 6873 6964 6573 2b28  , (i+1)*hsides+(
+0001d0d0: 6a2b 3129 2568 7369 6465 735d 2c0a 2020  j+1)%hsides],.  
+0001d0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d100: 2020 5d0a 2020 2020 2020 2020 2020 2020    ].            
+0001d110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d120: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
+0001d130: 2020 203a 202f 2a73 7479 6c65 3d3d 226f     : /*style=="o
+0001d140: 6374 6122 3f2a 2f0a 2020 2020 2020 2020  cta"?*/.        
+0001d150: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0001d160: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001d170: 2020 2020 2020 2020 2020 206d 6572 6964             merid
+0001d180: 6961 6e73 203d 205b 0a20 2020 2020 2020  ians = [.       
+0001d190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d1a0: 2020 2020 2020 2020 2020 2020 2020 2030                 0
+0001d1b0: 2c20 312c 0a20 2020 2020 2020 2020 2020  , 1,.           
+0001d1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d1d0: 2020 2020 2020 2020 2020 2066 6f72 2028             for (
+0001d1e0: 6920 3d20 5b31 3a31 3a6f 6374 615f 7374  i = [1:1:octa_st
+0001d1f0: 6570 735d 2920 692a 342c 0a20 2020 2020  eps]) i*4,.     
+0001d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d220: 2066 6f72 2028 6920 3d20 5b6f 6374 615f   for (i = [octa_
+0001d230: 7374 6570 732d 313a 2d31 3a31 5d29 2069  steps-1:-1:1]) i
+0001d240: 2a34 2c0a 2020 2020 2020 2020 2020 2020  *4,.            
+0001d250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d260: 2020 2020 2020 2020 2020 312c 0a20 2020            1,.   
+0001d270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d290: 2020 5d2c 0a20 2020 2020 2020 2020 2020    ],.           
+0001d2a0: 2020 2020 2020 2020 2020 2020 2020 6f66                of
+0001d2b0: 6673 203d 2063 756d 7375 6d28 6d65 7269  fs = cumsum(meri
+0001d2c0: 6469 616e 7329 2c0a 2020 2020 2020 2020  dians),.        
+0001d2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d2e0: 2070 6320 3d20 6c61 7374 286f 6666 7329   pc = last(offs)
+0001d2f0: 2d31 2c0a 2020 2020 2020 2020 2020 2020  -1,.            
+0001d300: 2020 2020 2020 2020 2020 2020 206f 7320               os 
+0001d310: 3d20 6f63 7461 5f73 7465 7073 202a 2032  = octa_steps * 2
+0001d320: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d330: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001d340: 2020 2020 2020 2020 2020 2020 205b 0a20               [. 
+0001d350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d360: 2020 2020 2066 6f72 2028 693d 5b30 3a31       for (i=[0:1
+0001d370: 3a33 5d29 205b 302c 2031 2b28 692b 3129  :3]) [0, 1+(i+1)
+0001d380: 2534 2c20 312b 695d 2c0a 2020 2020 2020  %4, 1+i],.      
+0001d390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d3a0: 666f 7220 2869 3d5b 303a 313a 335d 2920  for (i=[0:1:3]) 
+0001d3b0: 5b70 632d 302c 2070 632d 2831 2b28 692b  [pc-0, pc-(1+(i+
+0001d3c0: 3129 2534 292c 2070 632d 2831 2b69 295d  1)%4), pc-(1+i)]
+0001d3d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001d3e0: 2020 2020 2020 2020 666f 7220 2869 3d5b          for (i=[
+0001d3f0: 313a 313a 6f63 7461 5f73 7465 7073 2d31  1:1:octa_steps-1
+0001d400: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0001d410: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0001d420: 286d 203d 206d 6572 6964 6961 6e73 5b69  (m = meridians[i
+0001d430: 2b32 5d2f 3429 0a20 2020 2020 2020 2020  +2]/4).         
+0001d440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d450: 2066 6f72 2028 6a3d 5b30 3a31 3a33 5d2c   for (j=[0:1:3],
+0001d460: 206b 3d5b 303a 313a 6d2d 315d 290a 2020   k=[0:1:m-1]).  
+0001d470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d480: 2020 2020 2020 2020 2020 2020 6c65 7428              let(
+0001d490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d4b0: 2020 206d 3120 3d20 6d65 7269 6469 616e     m1 = meridian
+0001d4c0: 735b 692b 315d 2c0a 2020 2020 2020 2020  s[i+1],.        
+0001d4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d4e0: 2020 2020 2020 2020 2020 6d32 203d 206d            m2 = m
+0001d4f0: 6572 6964 6961 6e73 5b69 2b32 5d2c 0a20  eridians[i+2],. 
+0001d500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d520: 2070 3120 3d20 6f66 6673 5b69 2b30 5d20   p1 = offs[i+0] 
+0001d530: 2b20 286a 2a6d 312f 3420 2b20 6b2b 3029  + (j*m1/4 + k+0)
+0001d540: 2025 206d 312c 0a20 2020 2020 2020 2020   % m1,.         
+0001d550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d560: 2020 2020 2020 2020 2070 3220 3d20 6f66           p2 = of
+0001d570: 6673 5b69 2b30 5d20 2b20 286a 2a6d 312f  fs[i+0] + (j*m1/
+0001d580: 3420 2b20 6b2b 3129 2025 206d 312c 0a20  4 + k+1) % m1,. 
+0001d590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d5b0: 2070 3320 3d20 6f66 6673 5b69 2b31 5d20   p3 = offs[i+1] 
+0001d5c0: 2b20 286a 2a6d 322f 3420 2b20 6b2b 3029  + (j*m2/4 + k+0)
+0001d5d0: 2025 206d 322c 0a20 2020 2020 2020 2020   % m2,.         
+0001d5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d5f0: 2020 2020 2020 2020 2070 3420 3d20 6f66           p4 = of
+0001d600: 6673 5b69 2b31 5d20 2b20 286a 2a6d 322f  fs[i+1] + (j*m2/
+0001d610: 3420 2b20 6b2b 3129 2025 206d 322c 0a20  4 + k+1) % m2,. 
+0001d620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d640: 2070 3520 3d20 6f66 6673 5b6f 732d 692b   p5 = offs[os-i+
+0001d650: 305d 202b 2028 6a2a 6d31 2f34 202b 206b  0] + (j*m1/4 + k
+0001d660: 2b30 2920 2520 6d31 2c0a 2020 2020 2020  +0) % m1,.      
+0001d670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d680: 2020 2020 2020 2020 2020 2020 7036 203d              p6 =
+0001d690: 206f 6666 735b 6f73 2d69 2b30 5d20 2b20   offs[os-i+0] + 
+0001d6a0: 286a 2a6d 312f 3420 2b20 6b2b 3129 2025  (j*m1/4 + k+1) %
+0001d6b0: 206d 312c 0a20 2020 2020 2020 2020 2020   m1,.           
+0001d6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d6d0: 2020 2020 2020 2070 3720 3d20 6f66 6673         p7 = offs
+0001d6e0: 5b6f 732d 692d 315d 202b 2028 6a2a 6d32  [os-i-1] + (j*m2
+0001d6f0: 2f34 202b 206b 2b30 2920 2520 6d32 2c0a  /4 + k+0) % m2,.
+0001d700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d720: 2020 7038 203d 206f 6666 735b 6f73 2d69    p8 = offs[os-i
+0001d730: 2d31 5d20 2b20 286a 2a6d 322f 3420 2b20  -1] + (j*m2/4 + 
+0001d740: 6b2b 3129 2025 206d 320a 2020 2020 2020  k+1) % m2.      
+0001d750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d760: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0001d770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d780: 2020 2020 2020 2020 6561 6368 205b 0a20          each [. 
+0001d790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d7b0: 2020 205b 7031 2c20 7034 2c20 7033 5d2c     [p1, p4, p3],
+0001d7c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d7e0: 2020 2020 2069 6620 286b 3c6d 2d31 2920       if (k<m-1) 
+0001d7f0: 5b70 312c 2070 322c 2070 345d 2c0a 2020  [p1, p2, p4],.  
+0001d800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d820: 2020 5b70 352c 2070 372c 2070 385d 2c0a    [p5, p7, p8],.
+0001d830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d850: 2020 2020 6966 2028 6b3c 6d2d 3129 205b      if (k<m-1) [
+0001d860: 7035 2c20 7038 2c20 7036 5d2c 0a20 2020  p5, p8, p6],.   
+0001d870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d890: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0001d8a0: 2020 2020 2020 2020 5d0a 2020 2020 2920          ].    ) 
+0001d8b0: 5b72 656f 7269 656e 7428 616e 6368 6f72  [reorient(anchor
+0001d8c0: 2c73 7069 6e2c 6f72 6965 6e74 2c20 723d  ,spin,orient, r=
+0001d8d0: 722c 2070 3d76 6572 7473 292c 2066 6163  r, p=verts), fac
+0001d8e0: 6573 5d3b 0a0a 0a0a 2f2f 2046 756e 6374  es];....// Funct
+0001d8f0: 696f 6e26 4d6f 6475 6c65 3a20 746f 7275  ion&Module: toru
+0001d900: 7328 290a 2f2f 2053 796e 6f70 7369 733a  s().// Synopsis:
+0001d910: 2043 7265 6174 6573 2061 6e20 6174 7461   Creates an atta
+0001d920: 6368 6162 6c65 2074 6f72 7573 2c20 6f72  chable torus, or
+0001d930: 2072 6574 7572 6e73 2061 2076 6e66 2e0a   returns a vnf..
+0001d940: 2f2f 2054 6f70 6963 733a 2053 6861 7065  // Topics: Shape
+0001d950: 7320 2833 4429 2c20 4174 7461 6368 6162  s (3D), Attachab
+0001d960: 6c65 2c20 564e 4620 4765 6e65 7261 746f  le, VNF Generato
+0001d970: 7273 0a2f 2f20 5365 6520 416c 736f 3a20  rs.// See Also: 
+0001d980: 7370 6865 726f 6964 2829 2c20 6379 6c28  spheroid(), cyl(
+0001d990: 290a 2f2f 0a2f 2f20 5573 6167 653a 2041  ).//.// Usage: A
+0001d9a0: 7320 4d6f 6475 6c65 0a2f 2f20 2020 746f  s Module.//   to
+0001d9b0: 7275 7328 725f 6d61 6a7c 645f 6d61 6a2c  rus(r_maj|d_maj,
+0001d9c0: 2072 5f6d 696e 7c64 5f6d 696e 2c20 5b63   r_min|d_min, [c
+0001d9d0: 656e 7465 725d 2c20 2e2e 2e29 205b 4154  enter], ...) [AT
+0001d9e0: 5441 4348 4d45 4e54 535d 3b0a 2f2f 2020  TACHMENTS];.//  
+0001d9f0: 2074 6f72 7573 286f 727c 6f64 2c20 6972   torus(or|od, ir
+0001da00: 7c69 642c 202e 2e2e 2920 5b41 5454 4143  |id, ...) [ATTAC
+0001da10: 484d 454e 5453 5d3b 0a2f 2f20 2020 746f  HMENTS];.//   to
+0001da20: 7275 7328 725f 6d61 6a7c 645f 6d61 6a2c  rus(r_maj|d_maj,
+0001da30: 206f 727c 6f64 2c20 2e2e 2e29 205b 4154   or|od, ...) [AT
+0001da40: 5441 4348 4d45 4e54 535d 3b0a 2f2f 2020  TACHMENTS];.//  
+0001da50: 2074 6f72 7573 2872 5f6d 616a 7c64 5f6d   torus(r_maj|d_m
+0001da60: 616a 2c20 6972 7c69 642c 202e 2e2e 2920  aj, ir|id, ...) 
+0001da70: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
+0001da80: 2f20 2020 746f 7275 7328 725f 6d69 6e7c  /   torus(r_min|
+0001da90: 645f 6d69 6e2c 206f 727c 6f64 2c20 2e2e  d_min, or|od, ..
+0001daa0: 2e29 205b 4154 5441 4348 4d45 4e54 535d  .) [ATTACHMENTS]
+0001dab0: 3b0a 2f2f 2020 2074 6f72 7573 2872 5f6d  ;.//   torus(r_m
+0001dac0: 696e 7c64 5f6d 696e 2c20 6972 7c69 642c  in|d_min, ir|id,
+0001dad0: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
+0001dae0: 5453 5d3b 0a2f 2f20 5573 6167 653a 2041  TS];.// Usage: A
+0001daf0: 7320 4675 6e63 7469 6f6e 0a2f 2f20 2020  s Function.//   
+0001db00: 766e 6620 3d20 746f 7275 7328 725f 6d61  vnf = torus(r_ma
+0001db10: 6a7c 645f 6d61 6a2c 2072 5f6d 696e 7c64  j|d_maj, r_min|d
+0001db20: 5f6d 696e 2c20 5b63 656e 7465 725d 2c20  _min, [center], 
+0001db30: 2e2e 2e29 3b0a 2f2f 2020 2076 6e66 203d  ...);.//   vnf =
+0001db40: 2074 6f72 7573 286f 727c 6f64 2c20 6972   torus(or|od, ir
+0001db50: 7c69 642c 202e 2e2e 293b 0a2f 2f20 2020  |id, ...);.//   
+0001db60: 766e 6620 3d20 746f 7275 7328 725f 6d61  vnf = torus(r_ma
+0001db70: 6a7c 645f 6d61 6a2c 206f 727c 6f64 2c20  j|d_maj, or|od, 
+0001db80: 2e2e 2e29 3b0a 2f2f 2020 2076 6e66 203d  ...);.//   vnf =
+0001db90: 2074 6f72 7573 2872 5f6d 616a 7c64 5f6d   torus(r_maj|d_m
+0001dba0: 616a 2c20 6972 7c69 642c 202e 2e2e 293b  aj, ir|id, ...);
+0001dbb0: 0a2f 2f20 2020 766e 6620 3d20 746f 7275  .//   vnf = toru
+0001dbc0: 7328 725f 6d69 6e7c 645f 6d69 6e2c 206f  s(r_min|d_min, o
+0001dbd0: 727c 6f64 2c20 2e2e 2e29 3b0a 2f2f 2020  r|od, ...);.//  
+0001dbe0: 2076 6e66 203d 2074 6f72 7573 2872 5f6d   vnf = torus(r_m
+0001dbf0: 696e 7c64 5f6d 696e 2c20 6972 7c69 642c  in|d_min, ir|id,
+0001dc00: 202e 2e2e 293b 0a2f 2f0a 2f2f 2044 6573   ...);.//.// Des
+0001dc10: 6372 6970 7469 6f6e 3a0a 2f2f 2020 2043  cription:.//   C
+0001dc20: 7265 6174 6573 2061 6e20 6174 7461 6368  reates an attach
+0001dc30: 6162 6c65 2074 6f72 6f69 6461 6c20 7368  able toroidal sh
+0001dc40: 6170 652e 0a2f 2f0a 2f2f 2046 6967 7572  ape..//.// Figur
+0001dc50: 6528 3244 2c4d 6564 293a 0a2f 2f20 2020  e(2D,Med):.//   
+0001dc60: 6d6f 6475 6c65 2064 6173 6863 6972 6328  module dashcirc(
+0001dc70: 722c 7374 6172 743d 302c 616e 676c 653d  r,start=0,angle=
+0001dc80: 3335 392e 392c 6461 7368 6c65 6e3d 3529  359.9,dashlen=5)
+0001dc90: 206c 6574 2873 7465 703d 3336 302a 6461   let(step=360*da
+0001dca0: 7368 6c65 6e2f 2832 2a72 2a50 4929 2920  shlen/(2*r*PI)) 
+0001dcb0: 666f 7228 613d 5b73 7461 7274 3a73 7465  for(a=[start:ste
+0001dcc0: 703a 7374 6172 742b 616e 676c 655d 2920  p:start+angle]) 
+0001dcd0: 7374 726f 6b65 2861 7263 2872 3d72 2c73  stroke(arc(r=r,s
+0001dce0: 7461 7274 3d61 2c61 6e67 6c65 3d73 7465  tart=a,angle=ste
+0001dcf0: 702f 3229 293b 0a2f 2f20 2020 7220 3d20  p/2));.//   r = 
+0001dd00: 3735 3b20 7232 203d 2033 303b 0a2f 2f20  75; r2 = 30;.// 
+0001dd10: 2020 646f 776e 2872 322b 302e 3129 2023    down(r2+0.1) #
+0001dd20: 746f 7275 7328 725f 6d61 6a3d 722c 2072  torus(r_maj=r, r
+0001dd30: 5f6d 696e 3d72 322c 2024 666e 3d37 3229  _min=r2, $fn=72)
+0001dd40: 3b0a 2f2f 2020 2063 6f6c 6f72 2822 626c  ;.//   color("bl
+0001dd50: 7565 2229 206c 696e 6561 725f 6578 7472  ue") linear_extr
+0001dd60: 7564 6528 6865 6967 6874 3d30 2e30 3129  ude(height=0.01)
+0001dd70: 207b 0a2f 2f20 2020 2020 2020 6461 7368   {.//       dash
+0001dd80: 6369 7263 2872 3d72 2c73 7461 7274 3d31  circ(r=r,start=1
+0001dd90: 352c 616e 676c 653d 3435 293b 0a2f 2f20  5,angle=45);.// 
+0001dda0: 2020 2020 2020 6461 7368 6369 7263 2872        dashcirc(r
+0001ddb0: 3d72 2d72 322c 2073 7461 7274 3d39 302b  =r-r2, start=90+
+0001ddc0: 3135 2c20 616e 676c 653d 3630 293b 0a2f  15, angle=60);./
+0001ddd0: 2f20 2020 2020 2020 6461 7368 6369 7263  /       dashcirc
+0001dde0: 2872 3d72 2b72 322c 2073 7461 7274 3d31  (r=r+r2, start=1
+0001ddf0: 3830 2b34 352c 2061 6e67 6c65 3d33 3029  80+45, angle=30)
+0001de00: 3b0a 2f2f 2020 2020 2020 2064 6173 6863  ;.//       dashc
+0001de10: 6972 6328 723d 722b 7232 2c20 7374 6172  irc(r=r+r2, star
+0001de20: 743d 3135 2c20 616e 676c 653d 3330 293b  t=15, angle=30);
+0001de30: 0a2f 2f20 2020 7d0a 2f2f 2020 2072 6f74  .//   }.//   rot
+0001de40: 2832 3430 2920 636f 6c6f 7228 2262 6c75  (240) color("blu
+0001de50: 6522 2920 6c69 6e65 6172 5f65 7874 7275  e") linear_extru
+0001de60: 6465 2868 6569 6768 743d 302e 3031 2920  de(height=0.01) 
+0001de70: 7b0a 2f2f 2020 2020 2020 2073 7472 6f6b  {.//       strok
+0001de80: 6528 5b5b 302c 305d 2c5b 722b 7232 2c30  e([[0,0],[r+r2,0
+0001de90: 5d5d 2c20 656e 6463 6170 733d 2261 7272  ]], endcaps="arr
+0001dea0: 6f77 3222 2c77 6964 7468 3d32 293b 0a2f  ow2",width=2);./
+0001deb0: 2f20 2020 2020 2020 7269 6768 7428 7229  /       right(r)
+0001dec0: 2066 7764 2839 2920 726f 7428 2d32 3430   fwd(9) rot(-240
+0001ded0: 2920 7465 7874 2822 6f72 222c 7369 7a65  ) text("or",size
+0001dee0: 3d31 302c 616e 6368 6f72 3d43 454e 5445  =10,anchor=CENTE
+0001def0: 5229 3b0a 2f2f 2020 207d 0a2f 2f20 2020  R);.//   }.//   
+0001df00: 726f 7428 3133 3529 2063 6f6c 6f72 2822  rot(135) color("
+0001df10: 626c 7565 2229 206c 696e 6561 725f 6578  blue") linear_ex
+0001df20: 7472 7564 6528 6865 6967 6874 3d30 2e30  trude(height=0.0
+0001df30: 3129 207b 0a2f 2f20 2020 2020 2020 7374  1) {.//       st
+0001df40: 726f 6b65 285b 5b30 2c30 5d2c 5b72 2d72  roke([[0,0],[r-r
+0001df50: 322c 305d 5d2c 2065 6e64 6361 7073 3d22  2,0]], endcaps="
+0001df60: 6172 726f 7732 222c 7769 6474 683d 3229  arrow2",width=2)
+0001df70: 3b0a 2f2f 2020 2020 2020 2072 6967 6874  ;.//       right
+0001df80: 2828 722d 7232 292f 3229 2062 6163 6b28  ((r-r2)/2) back(
+0001df90: 3829 2072 6f74 282d 3133 3529 2074 6578  8) rot(-135) tex
+0001dfa0: 7428 2269 7222 2c73 697a 653d 3130 2c61  t("ir",size=10,a
+0001dfb0: 6e63 686f 723d 4345 4e54 4552 293b 0a2f  nchor=CENTER);./
+0001dfc0: 2f20 2020 7d0a 2f2f 2020 2072 6f74 2834  /   }.//   rot(4
+0001dfd0: 3529 2063 6f6c 6f72 2822 626c 7565 2229  5) color("blue")
+0001dfe0: 206c 696e 6561 725f 6578 7472 7564 6528   linear_extrude(
+0001dff0: 6865 6967 6874 3d30 2e30 3129 207b 0a2f  height=0.01) {./
+0001e000: 2f20 2020 2020 2020 7374 726f 6b65 285b  /       stroke([
+0001e010: 5b30 2c30 5d2c 5b72 2c30 5d5d 2c20 656e  [0,0],[r,0]], en
+0001e020: 6463 6170 733d 2261 7272 6f77 3222 2c77  dcaps="arrow2",w
+0001e030: 6964 7468 3d32 293b 0a2f 2f20 2020 2020  idth=2);.//     
+0001e040: 2020 7269 6768 7428 722f 3229 2062 6163    right(r/2) bac
+0001e050: 6b28 3829 2074 6578 7428 2272 5f6d 616a  k(8) text("r_maj
+0001e060: 222c 7369 7a65 3d39 2c61 6e63 686f 723d  ",size=9,anchor=
+0001e070: 4345 4e54 4552 293b 0a2f 2f20 2020 7d0a  CENTER);.//   }.
+0001e080: 2f2f 2020 2072 6f74 2833 3029 2063 6f6c  //   rot(30) col
+0001e090: 6f72 2822 626c 7565 2229 206c 696e 6561  or("blue") linea
+0001e0a0: 725f 6578 7472 7564 6528 6865 6967 6874  r_extrude(height
+0001e0b0: 3d30 2e30 3129 207b 0a2f 2f20 2020 2020  =0.01) {.//     
+0001e0c0: 2020 7374 726f 6b65 285b 5b72 2c30 5d2c    stroke([[r,0],
+0001e0d0: 5b72 2b72 322c 305d 5d2c 2065 6e64 6361  [r+r2,0]], endca
+0001e0e0: 7073 3d22 6172 726f 7732 222c 7769 6474  ps="arrow2",widt
+0001e0f0: 683d 3229 3b0a 2f2f 2020 2020 2020 2072  h=2);.//       r
+0001e100: 6967 6874 2872 2b72 322f 3229 2066 7764  ight(r+r2/2) fwd
+0001e110: 2838 2920 7465 7874 2822 725f 6d69 6e22  (8) text("r_min"
+0001e120: 2c73 697a 653d 372c 616e 6368 6f72 3d43  ,size=7,anchor=C
+0001e130: 454e 5445 5229 3b0a 2f2f 2020 207d 0a2f  ENTER);.//   }./
+0001e140: 2f0a 2f2f 2041 7267 756d 656e 7473 3a0a  /.// Arguments:.
+0001e150: 2f2f 2020 2072 5f6d 616a 203d 206d 616a  //   r_maj = maj
+0001e160: 6f72 2072 6164 6975 7320 6f66 2074 6f72  or radius of tor
+0001e170: 7573 2072 696e 672e 2028 7573 6520 7769  us ring. (use wi
+0001e180: 7468 2027 725f 6d69 6e27 2c20 6f72 2027  th 'r_min', or '
+0001e190: 645f 6d69 6e27 290a 2f2f 2020 2072 5f6d  d_min').//   r_m
+0001e1a0: 696e 203d 206d 696e 6f72 2072 6164 6975  in = minor radiu
+0001e1b0: 7320 6f66 2074 6f72 7573 2072 696e 672e  s of torus ring.
+0001e1c0: 2028 7573 6520 7769 7468 2027 725f 6d61   (use with 'r_ma
+0001e1d0: 6a27 2c20 6f72 2027 645f 6d61 6a27 290a  j', or 'd_maj').
+0001e1e0: 2f2f 2020 2063 656e 7465 7220 3d20 4966  //   center = If
+0001e1f0: 2067 6976 656e 2c20 6f76 6572 7269 6465   given, override
+0001e200: 7320 6061 6e63 686f 7260 2e20 2041 2074  s `anchor`.  A t
+0001e210: 7275 6520 7661 6c75 6520 7365 7473 2060  rue value sets `
+0001e220: 616e 6368 6f72 3d43 454e 5445 5260 2c20  anchor=CENTER`, 
+0001e230: 6661 6c73 6520 7365 7473 2060 616e 6368  false sets `anch
+0001e240: 6f72 3d44 4f57 4e60 2e0a 2f2f 2020 202d  or=DOWN`..//   -
+0001e250: 2d2d 0a2f 2f20 2020 645f 6d61 6a20 203d  --.//   d_maj  =
+0001e260: 206d 616a 6f72 2064 6961 6d65 7465 7220   major diameter 
+0001e270: 6f66 2074 6f72 7573 2072 696e 672e 2028  of torus ring. (
+0001e280: 7573 6520 7769 7468 2027 725f 6d69 6e27  use with 'r_min'
+0001e290: 2c20 6f72 2027 645f 6d69 6e27 290a 2f2f  , or 'd_min').//
+0001e2a0: 2020 2064 5f6d 696e 203d 206d 696e 6f72     d_min = minor
+0001e2b0: 2064 6961 6d65 7465 7220 6f66 2074 6f72   diameter of tor
+0001e2c0: 7573 2072 696e 672e 2028 7573 6520 7769  us ring. (use wi
+0001e2d0: 7468 2027 725f 6d61 6a27 2c20 6f72 2027  th 'r_maj', or '
+0001e2e0: 645f 6d61 6a27 290a 2f2f 2020 206f 7220  d_maj').//   or 
+0001e2f0: 3d20 6f75 7465 7220 7261 6469 7573 206f  = outer radius o
+0001e300: 6620 7468 6520 746f 7275 732e 2028 7573  f the torus. (us
+0001e310: 6520 7769 7468 2027 6972 272c 206f 7220  e with 'ir', or 
+0001e320: 2769 6427 290a 2f2f 2020 2069 7220 3d20  'id').//   ir = 
+0001e330: 696e 7369 6465 2072 6164 6975 7320 6f66  inside radius of
+0001e340: 2074 6865 2074 6f72 7573 2e20 2875 7365   the torus. (use
+0001e350: 2077 6974 6820 276f 7227 2c20 6f72 2027   with 'or', or '
+0001e360: 6f64 2729 0a2f 2f20 2020 6f64 203d 206f  od').//   od = o
+0001e370: 7574 6572 2064 6961 6d65 7465 7220 6f66  uter diameter of
+0001e380: 2074 6865 2074 6f72 7573 2e20 2875 7365   the torus. (use
+0001e390: 2077 6974 6820 2769 7227 206f 7220 2769   with 'ir' or 'i
+0001e3a0: 6427 290a 2f2f 2020 2069 6420 3d20 696e  d').//   id = in
+0001e3b0: 7369 6465 2064 6961 6d65 7465 7220 6f66  side diameter of
+0001e3c0: 2074 6865 2074 6f72 7573 2e20 2875 7365   the torus. (use
+0001e3d0: 2077 6974 6820 276f 7227 206f 7220 276f   with 'or' or 'o
+0001e3e0: 6427 290a 2f2f 2020 2061 6e63 686f 7220  d').//   anchor 
+0001e3f0: 3d20 5472 616e 736c 6174 6520 736f 2061  = Translate so a
+0001e400: 6e63 686f 7220 706f 696e 7420 6973 2061  nchor point is a
+0001e410: 7420 6f72 6967 696e 2028 302c 302c 3029  t origin (0,0,0)
+0001e420: 2e20 2053 6565 205b 616e 6368 6f72 5d28  .  See [anchor](
+0001e430: 6174 7461 6368 6d65 6e74 732e 7363 6164  attachments.scad
+0001e440: 2373 7562 7365 6374 696f 6e2d 616e 6368  #subsection-anch
+0001e450: 6f72 292e 2020 4465 6661 756c 743a 2060  or).  Default: `
+0001e460: 4345 4e54 4552 600a 2f2f 2020 206f 7269  CENTER`.//   ori
+0001e470: 656e 7420 3d20 5665 6374 6f72 2074 6f20  ent = Vector to 
+0001e480: 726f 7461 7465 2074 6f70 2074 6f77 6172  rotate top towar
+0001e490: 6473 2c20 6166 7465 7220 7370 696e 2e20  ds, after spin. 
+0001e4a0: 2053 6565 205b 6f72 6965 6e74 5d28 6174   See [orient](at
+0001e4b0: 7461 6368 6d65 6e74 732e 7363 6164 2373  tachments.scad#s
+0001e4c0: 7562 7365 6374 696f 6e2d 6f72 6965 6e74  ubsection-orient
+0001e4d0: 292e 2020 4465 6661 756c 743a 2060 5550  ).  Default: `UP
+0001e4e0: 600a 2f2f 0a2f 2f20 4578 616d 706c 653a  `.//.// Example:
+0001e4f0: 0a2f 2f20 2020 2f2f 2054 6865 7365 2061  .//   // These a
+0001e500: 6c6c 2070 726f 6475 6365 2074 6865 2073  ll produce the s
+0001e510: 616d 6520 746f 7275 732e 0a2f 2f20 2020  ame torus..//   
+0001e520: 746f 7275 7328 725f 6d61 6a3d 3232 2e35  torus(r_maj=22.5
+0001e530: 2c20 725f 6d69 6e3d 372e 3529 3b0a 2f2f  , r_min=7.5);.//
+0001e540: 2020 2074 6f72 7573 2864 5f6d 616a 3d34     torus(d_maj=4
+0001e550: 352c 2064 5f6d 696e 3d31 3529 3b0a 2f2f  5, d_min=15);.//
+0001e560: 2020 2074 6f72 7573 286f 723d 3330 2c20     torus(or=30, 
+0001e570: 6972 3d31 3529 3b0a 2f2f 2020 2074 6f72  ir=15);.//   tor
+0001e580: 7573 286f 643d 3630 2c20 6964 3d33 3029  us(od=60, id=30)
+0001e590: 3b0a 2f2f 2020 2074 6f72 7573 2864 5f6d  ;.//   torus(d_m
+0001e5a0: 616a 3d34 352c 2069 643d 3330 293b 0a2f  aj=45, id=30);./
+0001e5b0: 2f20 2020 746f 7275 7328 645f 6d61 6a3d  /   torus(d_maj=
+0001e5c0: 3435 2c20 6f64 3d36 3029 3b0a 2f2f 2020  45, od=60);.//  
+0001e5d0: 2074 6f72 7573 2864 5f6d 696e 3d31 352c   torus(d_min=15,
+0001e5e0: 2069 643d 3330 293b 0a2f 2f20 2020 746f   id=30);.//   to
+0001e5f0: 7275 7328 645f 6d69 6e3d 3135 2c20 6f64  rus(d_min=15, od
+0001e600: 3d36 3029 3b0a 2f2f 2020 2076 6e66 5f70  =60);.//   vnf_p
+0001e610: 6f6c 7968 6564 726f 6e28 746f 7275 7328  olyhedron(torus(
+0001e620: 645f 6d69 6e3d 3135 2c20 6f64 3d36 3029  d_min=15, od=60)
+0001e630: 2c20 636f 6e76 6578 6974 793d 3429 3b0a  , convexity=4);.
+0001e640: 2f2f 2045 7861 6d70 6c65 3a20 5374 616e  // Example: Stan
+0001e650: 6461 7264 2043 6f6e 6e65 6374 6f72 730a  dard Connectors.
+0001e660: 2f2f 2020 2074 6f72 7573 286f 643d 3630  //   torus(od=60
+0001e670: 2c20 6964 3d33 3029 2073 686f 775f 616e  , id=30) show_an
+0001e680: 6368 6f72 7328 293b 0a0a 6d6f 6475 6c65  chors();..module
+0001e690: 2074 6f72 7573 280a 2020 2020 725f 6d61   torus(.    r_ma
+0001e6a0: 6a2c 2072 5f6d 696e 2c20 6365 6e74 6572  j, r_min, center
+0001e6b0: 2c0a 2020 2020 645f 6d61 6a2c 2064 5f6d  ,.    d_maj, d_m
+0001e6c0: 696e 2c0a 2020 2020 6f72 2c20 6f64 2c20  in,.    or, od, 
+0001e6d0: 6972 2c20 6964 2c0a 2020 2020 616e 6368  ir, id,.    anch
+0001e6e0: 6f72 2c20 7370 696e 3d30 2c20 6f72 6965  or, spin=0, orie
+0001e6f0: 6e74 3d55 500a 2920 7b0a 2020 2020 5f6f  nt=UP.) {.    _o
+0001e700: 7220 3d20 6765 745f 7261 6469 7573 2872  r = get_radius(r
+0001e710: 3d6f 722c 2064 3d6f 642c 2064 666c 743d  =or, d=od, dflt=
+0001e720: 756e 6465 6629 3b0a 2020 2020 5f69 7220  undef);.    _ir 
+0001e730: 3d20 6765 745f 7261 6469 7573 2872 3d69  = get_radius(r=i
+0001e740: 722c 2064 3d69 642c 2064 666c 743d 756e  r, d=id, dflt=un
+0001e750: 6465 6629 3b0a 2020 2020 5f72 5f6d 616a  def);.    _r_maj
+0001e760: 203d 2067 6574 5f72 6164 6975 7328 723d   = get_radius(r=
+0001e770: 725f 6d61 6a2c 2064 3d64 5f6d 616a 2c20  r_maj, d=d_maj, 
+0001e780: 6466 6c74 3d75 6e64 6566 293b 0a20 2020  dflt=undef);.   
+0001e790: 205f 725f 6d69 6e20 3d20 6765 745f 7261   _r_min = get_ra
+0001e7a0: 6469 7573 2872 3d72 5f6d 696e 2c20 643d  dius(r=r_min, d=
+0001e7b0: 645f 6d69 6e2c 2064 666c 743d 756e 6465  d_min, dflt=unde
+0001e7c0: 6629 3b0a 2020 2020 6d61 6a5f 7261 6420  f);.    maj_rad 
+0001e7d0: 3d20 6973 5f66 696e 6974 6528 5f72 5f6d  = is_finite(_r_m
+0001e7e0: 616a 293f 205f 725f 6d61 6a20 3a0a 2020  aj)? _r_maj :.  
+0001e7f0: 2020 2020 2020 6973 5f66 696e 6974 6528        is_finite(
+0001e800: 5f69 7229 2026 2620 6973 5f66 696e 6974  _ir) && is_finit
+0001e810: 6528 5f6f 7229 3f20 285f 6f72 202b 205f  e(_or)? (_or + _
+0001e820: 6972 292f 3220 3a0a 2020 2020 2020 2020  ir)/2 :.        
+0001e830: 6973 5f66 696e 6974 6528 5f69 7229 2026  is_finite(_ir) &
+0001e840: 2620 6973 5f66 696e 6974 6528 5f72 5f6d  & is_finite(_r_m
+0001e850: 696e 293f 2028 5f69 7220 2b20 5f72 5f6d  in)? (_ir + _r_m
+0001e860: 696e 2920 3a0a 2020 2020 2020 2020 6973  in) :.        is
+0001e870: 5f66 696e 6974 6528 5f6f 7229 2026 2620  _finite(_or) && 
+0001e880: 6973 5f66 696e 6974 6528 5f72 5f6d 696e  is_finite(_r_min
+0001e890: 293f 2028 5f6f 7220 2d20 5f72 5f6d 696e  )? (_or - _r_min
+0001e8a0: 2920 3a0a 2020 2020 2020 2020 6173 7365  ) :.        asse
+0001e8b0: 7274 2866 616c 7365 2c20 2242 6164 2050  rt(false, "Bad P
+0001e8c0: 6172 616d 6574 6572 7322 293b 0a20 2020  arameters");.   
+0001e8d0: 206d 696e 5f72 6164 203d 2069 735f 6669   min_rad = is_fi
+0001e8e0: 6e69 7465 285f 725f 6d69 6e29 3f20 5f72  nite(_r_min)? _r
+0001e8f0: 5f6d 696e 203a 0a20 2020 2020 2020 2069  _min :.        i
+0001e900: 735f 6669 6e69 7465 285f 6972 293f 2028  s_finite(_ir)? (
+0001e910: 6d61 6a5f 7261 6420 2d20 5f69 7229 203a  maj_rad - _ir) :
+0001e920: 0a20 2020 2020 2020 2069 735f 6669 6e69  .        is_fini
+0001e930: 7465 285f 6f72 293f 2028 5f6f 7220 2d20  te(_or)? (_or - 
+0001e940: 6d61 6a5f 7261 6429 203a 0a20 2020 2020  maj_rad) :.     
+0001e950: 2020 2061 7373 6572 7428 6661 6c73 652c     assert(false,
+0001e960: 2022 4261 6420 5061 7261 6d65 7465 7273   "Bad Parameters
+0001e970: 2229 3b0a 2020 2020 616e 6368 6f72 203d  ");.    anchor =
+0001e980: 2067 6574 5f61 6e63 686f 7228 616e 6368   get_anchor(anch
+0001e990: 6f72 2c20 6365 6e74 6572 2c20 424f 542c  or, center, BOT,
+0001e9a0: 2043 454e 5445 5229 3b0a 2020 2020 6174   CENTER);.    at
+0001e9b0: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
+0001e9c0: 7370 696e 2c6f 7269 656e 742c 2072 3d28  spin,orient, r=(
+0001e9d0: 6d61 6a5f 7261 642b 6d69 6e5f 7261 6429  maj_rad+min_rad)
+0001e9e0: 2c20 6c3d 6d69 6e5f 7261 642a 3229 207b  , l=min_rad*2) {
+0001e9f0: 0a20 2020 2020 2020 2072 6f74 6174 655f  .        rotate_
+0001ea00: 6578 7472 7564 6528 636f 6e76 6578 6974  extrude(convexit
+0001ea10: 793d 3429 207b 0a20 2020 2020 2020 2020  y=4) {.         
+0001ea20: 2020 2072 6967 6874 5f68 616c 6628 733d     right_half(s=
+0001ea30: 6d69 6e5f 7261 642a 322c 2070 6c61 6e61  min_rad*2, plana
+0001ea40: 723d 7472 7565 290a 2020 2020 2020 2020  r=true).        
+0001ea50: 2020 2020 2020 2020 7269 6768 7428 6d61          right(ma
+0001ea60: 6a5f 7261 6429 0a20 2020 2020 2020 2020  j_rad).         
+0001ea70: 2020 2020 2020 2020 2020 2063 6972 636c             circl
+0001ea80: 6528 723d 6d69 6e5f 7261 6429 3b0a 2020  e(r=min_rad);.  
+0001ea90: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+0001eaa0: 6368 696c 6472 656e 2829 3b0a 2020 2020  children();.    
+0001eab0: 7d0a 7d0a 0a0a 6675 6e63 7469 6f6e 2074  }.}...function t
+0001eac0: 6f72 7573 280a 2020 2020 725f 6d61 6a2c  orus(.    r_maj,
+0001ead0: 2072 5f6d 696e 2c20 6365 6e74 6572 2c0a   r_min, center,.
+0001eae0: 2020 2020 645f 6d61 6a2c 2064 5f6d 696e      d_maj, d_min
+0001eaf0: 2c0a 2020 2020 6f72 2c20 6f64 2c20 6972  ,.    or, od, ir
+0001eb00: 2c20 6964 2c0a 2020 2020 616e 6368 6f72  , id,.    anchor
+0001eb10: 2c20 7370 696e 3d30 2c20 6f72 6965 6e74  , spin=0, orient
+0001eb20: 3d55 500a 2920 3d20 6c65 7428 0a20 2020  =UP.) = let(.   
+0001eb30: 205f 6f72 203d 2067 6574 5f72 6164 6975   _or = get_radiu
+0001eb40: 7328 723d 6f72 2c20 643d 6f64 2c20 6466  s(r=or, d=od, df
+0001eb50: 6c74 3d75 6e64 6566 292c 0a20 2020 205f  lt=undef),.    _
+0001eb60: 6972 203d 2067 6574 5f72 6164 6975 7328  ir = get_radius(
+0001eb70: 723d 6972 2c20 643d 6964 2c20 6466 6c74  r=ir, d=id, dflt
+0001eb80: 3d75 6e64 6566 292c 0a20 2020 205f 725f  =undef),.    _r_
+0001eb90: 6d61 6a20 3d20 6765 745f 7261 6469 7573  maj = get_radius
+0001eba0: 2872 3d72 5f6d 616a 2c20 643d 645f 6d61  (r=r_maj, d=d_ma
+0001ebb0: 6a2c 2064 666c 743d 756e 6465 6629 2c0a  j, dflt=undef),.
+0001ebc0: 2020 2020 5f72 5f6d 696e 203d 2067 6574      _r_min = get
+0001ebd0: 5f72 6164 6975 7328 723d 725f 6d69 6e2c  _radius(r=r_min,
+0001ebe0: 2064 3d64 5f6d 696e 2c20 6466 6c74 3d75   d=d_min, dflt=u
+0001ebf0: 6e64 6566 292c 0a20 2020 206d 616a 5f72  ndef),.    maj_r
+0001ec00: 6164 203d 2069 735f 6669 6e69 7465 285f  ad = is_finite(_
+0001ec10: 725f 6d61 6a29 3f20 5f72 5f6d 616a 203a  r_maj)? _r_maj :
+0001ec20: 0a20 2020 2020 2020 2069 735f 6669 6e69  .        is_fini
+0001ec30: 7465 285f 6972 2920 2626 2069 735f 6669  te(_ir) && is_fi
+0001ec40: 6e69 7465 285f 6f72 293f 2028 5f6f 7220  nite(_or)? (_or 
+0001ec50: 2b20 5f69 7229 2f32 203a 0a20 2020 2020  + _ir)/2 :.     
+0001ec60: 2020 2069 735f 6669 6e69 7465 285f 6972     is_finite(_ir
+0001ec70: 2920 2626 2069 735f 6669 6e69 7465 285f  ) && is_finite(_
+0001ec80: 725f 6d69 6e29 3f20 285f 6972 202b 205f  r_min)? (_ir + _
+0001ec90: 725f 6d69 6e29 203a 0a20 2020 2020 2020  r_min) :.       
+0001eca0: 2069 735f 6669 6e69 7465 285f 6f72 2920   is_finite(_or) 
+0001ecb0: 2626 2069 735f 6669 6e69 7465 285f 725f  && is_finite(_r_
+0001ecc0: 6d69 6e29 3f20 285f 6f72 202d 205f 725f  min)? (_or - _r_
+0001ecd0: 6d69 6e29 203a 0a20 2020 2020 2020 2061  min) :.        a
+0001ece0: 7373 6572 7428 6661 6c73 652c 2022 4261  ssert(false, "Ba
+0001ecf0: 6420 5061 7261 6d65 7465 7273 2229 2c0a  d Parameters"),.
+0001ed00: 2020 2020 6d69 6e5f 7261 6420 3d20 6973      min_rad = is
+0001ed10: 5f66 696e 6974 6528 5f72 5f6d 696e 293f  _finite(_r_min)?
+0001ed20: 205f 725f 6d69 6e20 3a0a 2020 2020 2020   _r_min :.      
+0001ed30: 2020 6973 5f66 696e 6974 6528 5f69 7229    is_finite(_ir)
+0001ed40: 3f20 286d 616a 5f72 6164 202d 205f 6972  ? (maj_rad - _ir
+0001ed50: 2920 3a0a 2020 2020 2020 2020 6973 5f66  ) :.        is_f
+0001ed60: 696e 6974 6528 5f6f 7229 3f20 285f 6f72  inite(_or)? (_or
+0001ed70: 202d 206d 616a 5f72 6164 2920 3a0a 2020   - maj_rad) :.  
+0001ed80: 2020 2020 2020 6173 7365 7274 2866 616c        assert(fal
+0001ed90: 7365 2c20 2242 6164 2050 6172 616d 6574  se, "Bad Paramet
+0001eda0: 6572 7322 292c 0a20 2020 2061 6e63 686f  ers"),.    ancho
+0001edb0: 7220 3d20 6765 745f 616e 6368 6f72 2861  r = get_anchor(a
+0001edc0: 6e63 686f 722c 2063 656e 7465 722c 2042  nchor, center, B
+0001edd0: 4f54 2c20 4345 4e54 4552 292c 0a20 2020  OT, CENTER),.   
+0001ede0: 206d 616a 5f73 6964 6573 203d 2073 6567   maj_sides = seg
+0001edf0: 7328 6d61 6a5f 7261 642b 6d69 6e5f 7261  s(maj_rad+min_ra
+0001ee00: 6429 2c0a 2020 2020 6d61 6a5f 7374 6570  d),.    maj_step
+0001ee10: 203d 2033 3630 202f 206d 616a 5f73 6964   = 360 / maj_sid
+0001ee20: 6573 2c0a 2020 2020 6d69 6e5f 7369 6465  es,.    min_side
+0001ee30: 7320 3d20 7365 6773 286d 696e 5f72 6164  s = segs(min_rad
+0001ee40: 292c 0a20 2020 206d 696e 5f73 7465 7020  ),.    min_step 
+0001ee50: 3d20 3336 3020 2f20 6d69 6e5f 7369 6465  = 360 / min_side
+0001ee60: 732c 0a20 2020 2078 7970 726f 6669 6c65  s,.    xyprofile
+0001ee70: 203d 206d 696e 5f72 6164 203c 3d20 6d61   = min_rad <= ma
+0001ee80: 6a5f 7261 643f 2072 6967 6874 286d 616a  j_rad? right(maj
+0001ee90: 5f72 6164 2c20 703d 6369 7263 6c65 2872  _rad, p=circle(r
+0001eea0: 3d6d 696e 5f72 6164 2929 203a 0a20 2020  =min_rad)) :.   
+0001eeb0: 2020 2020 2072 6967 6874 5f68 616c 6628       right_half(
+0001eec0: 703d 7269 6768 7428 6d61 6a5f 7261 642c  p=right(maj_rad,
+0001eed0: 2070 3d63 6972 636c 6528 723d 6d69 6e5f   p=circle(r=min_
+0001eee0: 7261 6429 2929 5b30 5d2c 0a20 2020 2070  rad)))[0],.    p
+0001eef0: 726f 6669 6c65 203d 2078 726f 7428 3930  rofile = xrot(90
+0001ef00: 2c20 703d 7061 7468 3364 2878 7970 726f  , p=path3d(xypro
+0001ef10: 6669 6c65 2929 2c0a 2020 2020 766e 6620  file)),.    vnf 
+0001ef20: 3d20 766e 665f 7665 7274 6578 5f61 7272  = vnf_vertex_arr
+0001ef30: 6179 280a 2020 2020 2020 2020 706f 696e  ay(.        poin
+0001ef40: 7473 3d5b 666f 7220 2861 3d5b 303a 6d61  ts=[for (a=[0:ma
+0001ef50: 6a5f 7374 6570 3a33 3630 2d45 5053 494c  j_step:360-EPSIL
+0001ef60: 4f4e 5d29 207a 726f 7428 612c 2070 3d70  ON]) zrot(a, p=p
+0001ef70: 726f 6669 6c65 295d 2c0a 2020 2020 2020  rofile)],.      
+0001ef80: 2020 6361 7073 3d66 616c 7365 2c20 636f    caps=false, co
+0001ef90: 6c5f 7772 6170 3d74 7275 652c 2072 6f77  l_wrap=true, row
+0001efa0: 5f77 7261 703d 7472 7565 2c20 7265 7665  _wrap=true, reve
+0001efb0: 7273 653d 7472 7565 0a20 2020 2029 0a29  rse=true.    ).)
+0001efc0: 2072 656f 7269 656e 7428 616e 6368 6f72   reorient(anchor
+0001efd0: 2c73 7069 6e2c 6f72 6965 6e74 2c20 723d  ,spin,orient, r=
+0001efe0: 286d 616a 5f72 6164 2b6d 696e 5f72 6164  (maj_rad+min_rad
+0001eff0: 292c 206c 3d6d 696e 5f72 6164 2a32 2c20  ), l=min_rad*2, 
+0001f000: 703d 766e 6629 3b0a 0a0a 2f2f 2046 756e  p=vnf);...// Fun
+0001f010: 6374 696f 6e26 4d6f 6475 6c65 3a20 7465  ction&Module: te
+0001f020: 6172 6472 6f70 2829 0a2f 2f20 5379 6e6f  ardrop().// Syno
+0001f030: 7073 6973 3a20 4372 6561 7465 7320 6120  psis: Creates a 
+0001f040: 7465 6172 6472 6f70 2073 6861 7065 2c20  teardrop shape, 
+0001f050: 6f72 2072 6574 7572 6e73 2061 2076 6e66  or returns a vnf
+0001f060: 2e0a 2f2f 2054 6f70 6963 733a 2053 6861  ..// Topics: Sha
+0001f070: 7065 7320 2833 4429 2c20 4174 7461 6368  pes (3D), Attach
+0001f080: 6162 6c65 2c20 564e 4620 4765 6e65 7261  able, VNF Genera
+0001f090: 746f 7273 2c20 4644 4d20 4f70 7469 6d69  tors, FDM Optimi
+0001f0a0: 7a65 640a 2f2f 2053 6565 2041 6c73 6f3a  zed.// See Also:
+0001f0b0: 206f 6e69 6f6e 2829 2c20 7465 6172 6472   onion(), teardr
+0001f0c0: 6f70 3264 2829 0a2f 2f20 4465 7363 7269  op2d().// Descri
+0001f0d0: 7074 696f 6e3a 0a2f 2f20 2020 4d61 6b65  ption:.//   Make
+0001f0e0: 7320 6120 7465 6172 6472 6f70 2073 6861  s a teardrop sha
+0001f0f0: 7065 2069 6e20 7468 6520 585a 2070 6c61  pe in the XZ pla
+0001f100: 6e65 2e20 5573 6566 756c 2066 6f72 2033  ne. Useful for 3
+0001f110: 4420 7072 696e 7461 626c 6520 686f 6c65  D printable hole
+0001f120: 732e 0a2f 2f20 2020 4f70 7469 6f6e 616c  s..//   Optional
+0001f130: 2063 6861 6d66 6572 7320 6361 6e20 6265   chamfers can be
+0001f140: 2061 6464 6564 2077 6974 6820 706f 7369   added with posi
+0001f150: 7469 7665 206f 7220 6e65 6761 7469 7665  tive or negative
+0001f160: 2064 6973 7461 6e63 6573 2e20 2041 2070   distances.  A p
+0001f170: 6f73 6974 6976 6520 6469 7374 616e 6365  ositive distance
+0001f180: 0a2f 2f20 2020 7370 6563 6966 6965 7320  .//   specifies 
+0001f190: 7468 6520 616d 6f75 6e74 2074 6f20 696e  the amount to in
+0001f1a0: 7365 7420 7468 6520 6368 616d 6665 7220  set the chamfer 
+0001f1b0: 616c 6f6e 6720 7468 6520 6672 6f6e 742f  along the front/
+0001f1c0: 6261 636b 2066 6163 6573 206f 6620 7468  back faces of th
+0001f1d0: 6520 7368 6170 652e 0a2f 2f20 2020 5468  e shape..//   Th
+0001f1e0: 6520 6368 616d 6665 7220 7769 6c6c 2065  e chamfer will e
+0001f1f0: 7874 656e 6420 7468 6520 7361 6d65 2079  xtend the same y
+0001f200: 2064 6973 7461 6e63 6520 696e 746f 2074   distance into t
+0001f210: 6865 2073 6861 7065 2e20 2049 6620 7468  he shape.  If th
+0001f220: 6520 7261 6469 6920 6172 6520 7468 6520  e radii are the 
+0001f230: 7361 6d65 0a2f 2f20 2020 7468 656e 2074  same.//   then t
+0001f240: 6865 2063 6861 6d66 6572 2077 696c 6c20  he chamfer will 
+0001f250: 6265 2061 2034 3520 6465 6772 6565 2063  be a 45 degree c
+0001f260: 6861 6d66 6572 2c20 6275 7420 696e 206f  hamfer, but in o
+0001f270: 7468 6572 2063 6173 6573 2069 7420 7769  ther cases it wi
+0001f280: 6c6c 206e 6f74 2e0a 2f2f 2020 204e 6f74  ll not..//   Not
+0001f290: 6520 7468 6174 2077 6974 6820 6361 7073  e that with caps
+0001f2a0: 2c20 7468 6520 6368 616d 6665 7220 6d75  , the chamfer mu
+0001f2b0: 7374 206e 6f74 2062 6520 736f 2062 6967  st not be so big
+0001f2c0: 2074 6861 7420 6974 206d 616b 6573 2074   that it makes t
+0001f2d0: 6865 2063 6170 2068 6569 6768 7420 696c  he cap height il
+0001f2e0: 6c65 6761 6c2e 2020 0a2f 2f0a 2f2f 2055  legal.  .//.// U
+0001f2f0: 7361 6765 3a20 5479 7069 6361 6c0a 2f2f  sage: Typical.//
+0001f300: 2020 2074 6561 7264 726f 7028 687c 6c3d     teardrop(h|l=
+0001f310: 7c6c 656e 6774 683d 7c68 6569 6768 743d  |length=|height=
+0001f320: 2c20 722c 205b 616e 675d 2c20 5b63 6170  , r, [ang], [cap
+0001f330: 5f68 5d2c 205b 6368 616d 6665 723d 5d2c  _h], [chamfer=],
+0001f340: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
+0001f350: 5453 5d3b 0a2f 2f20 2020 7465 6172 6472  TS];.//   teardr
+0001f360: 6f70 2868 7c6c 3d7c 6c65 6e67 7468 3d7c  op(h|l=|length=|
+0001f370: 6865 6967 6874 3d2c 2064 3d2c 205b 616e  height=, d=, [an
+0001f380: 673d 5d2c 205b 6361 705f 683d 5d2c 205b  g=], [cap_h=], [
+0001f390: 6368 616d 6665 723d 5d2c 202e 2e2e 2920  chamfer=], ...) 
+0001f3a0: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
+0001f3b0: 2f20 5573 6167 653a 2050 7375 6564 6f2d  / Usage: Psuedo-
+0001f3c0: 436f 6e69 6361 6c0a 2f2f 2020 2074 6561  Conical.//   tea
+0001f3d0: 7264 726f 7028 687c 6c3d 7c68 6569 6768  rdrop(h|l=|heigh
+0001f3e0: 743d 7c6c 656e 6774 683d 2c20 7231 3d2c  t=|length=, r1=,
+0001f3f0: 2072 323d 2c20 5b61 6e67 3d5d 2c20 5b63   r2=, [ang=], [c
+0001f400: 6170 5f68 313d 5d2c 205b 6361 705f 6832  ap_h1=], [cap_h2
+0001f410: 3d5d 2c20 2e2e 2e29 2020 5b41 5454 4143  =], ...)  [ATTAC
+0001f420: 484d 454e 5453 5d3b 0a2f 2f20 2020 7465  HMENTS];.//   te
+0001f430: 6172 6472 6f70 2868 7c6c 3d7c 6865 6967  ardrop(h|l=|heig
+0001f440: 6874 3d7c 6c65 6e67 7468 3d2c 2064 313d  ht=|length=, d1=
+0001f450: 2c20 6432 3d2c 205b 616e 673d 5d2c 205b  , d2=, [ang=], [
+0001f460: 6361 705f 6831 3d5d 2c20 5b63 6170 5f68  cap_h1=], [cap_h
+0001f470: 323d 5d2c 202e 2e2e 2920 205b 4154 5441  2=], ...)  [ATTA
+0001f480: 4348 4d45 4e54 535d 3b0a 2f2f 2055 7361  CHMENTS];.// Usa
+0001f490: 6765 3a20 4173 2046 756e 6374 696f 6e0a  ge: As Function.
+0001f4a0: 2f2f 2020 2076 6e66 203d 2074 6561 7264  //   vnf = teard
+0001f4b0: 726f 7028 687c 6c3d 7c68 6569 6768 743d  rop(h|l=|height=
+0001f4c0: 7c6c 656e 6774 683d 2c20 727c 643d 2c20  |length=, r|d=, 
+0001f4d0: 5b61 6e67 3d5d 2c20 5b63 6170 5f68 3d5d  [ang=], [cap_h=]
+0001f4e0: 2c20 2e2e 2e29 3b0a 2f2f 2020 2076 6e66  , ...);.//   vnf
+0001f4f0: 203d 2074 6561 7264 726f 7028 687c 6c3d   = teardrop(h|l=
+0001f500: 7c68 6569 6768 743d 7c6c 656e 6774 683d  |height=|length=
+0001f510: 2c20 7231 3d7c 6431 3d2c 2072 323d 7c64  , r1=|d1=, r2=|d
+0001f520: 323d 2c20 5b61 6e67 3d5d 2c20 5b63 6170  2=, [ang=], [cap
+0001f530: 5f68 3d5d 2c20 2e2e 2e29 3b0a 2f2f 2020  _h=], ...);.//  
+0001f540: 2076 6e66 203d 2074 6561 7264 726f 7028   vnf = teardrop(
+0001f550: 687c 6c3d 7c68 6569 6768 743d 7c6c 656e  h|l=|height=|len
+0001f560: 6774 683d 2c20 7231 3d7c 6431 3d2c 2072  gth=, r1=|d1=, r
+0001f570: 323d 7c64 323d 2c20 5b61 6e67 3d5d 2c20  2=|d2=, [ang=], 
+0001f580: 5b63 6170 5f68 313d 5d2c 205b 6361 705f  [cap_h1=], [cap_
+0001f590: 6832 3d5d 2c20 2e2e 2e29 3b0a 2f2f 0a2f  h2=], ...);.//./
+0001f5a0: 2f20 4172 6775 6d65 6e74 733a 0a2f 2f20  / Arguments:.// 
+0001f5b0: 2020 6820 2f20 6c20 2f20 6865 6967 6874    h / l / height
+0001f5c0: 202f 206c 656e 6774 6820 3d20 5468 6963   / length = Thic
+0001f5d0: 6b6e 6573 7320 6f66 2074 6561 7264 726f  kness of teardro
+0001f5e0: 702e 2044 6566 6175 6c74 3a20 310a 2f2f  p. Default: 1.//
+0001f5f0: 2020 2072 203d 2052 6164 6975 7320 6f66     r = Radius of
+0001f600: 2063 6972 6375 6c61 7220 7061 7274 206f   circular part o
+0001f610: 6620 7465 6172 6472 6f70 2e20 2044 6566  f teardrop.  Def
+0001f620: 6175 6c74 3a20 310a 2f2f 2020 2061 6e67  ault: 1.//   ang
+0001f630: 203d 2041 6e67 6c65 206f 6620 6861 7420   = Angle of hat 
+0001f640: 7761 6c6c 7320 6672 6f6d 2074 6865 205a  walls from the Z
+0001f650: 2061 7869 732e 2020 4465 6661 756c 743a   axis.  Default:
+0001f660: 2034 3520 6465 6772 6565 730a 2f2f 2020   45 degrees.//  
+0001f670: 2063 6170 5f68 203d 2049 6620 6769 7665   cap_h = If give
+0001f680: 6e2c 2068 6569 6768 7420 6162 6f76 6520  n, height above 
+0001f690: 6365 6e74 6572 2077 6865 7265 2074 6865  center where the
+0001f6a0: 2073 6861 7065 2077 696c 6c20 6265 2074   shape will be t
+0001f6b0: 7275 6e63 6174 6564 2e20 4465 6661 756c  runcated. Defaul
+0001f6c0: 743a 2060 756e 6465 6660 2028 6e6f 2074  t: `undef` (no t
+0001f6d0: 7275 6e63 6174 696f 6e29 0a2f 2f20 2020  runcation).//   
+0001f6e0: 2d2d 2d0a 2f2f 2020 2063 6972 6375 6d20  ---.//   circum 
+0001f6f0: 3d20 7072 6f64 7563 6520 6120 6369 7263  = produce a circ
+0001f700: 756d 7363 7269 6269 6e67 2074 6561 7264  umscribing teard
+0001f710: 726f 7020 7368 6170 652e 2020 4465 6661  rop shape.  Defa
+0001f720: 756c 743a 2066 616c 7365 0a2f 2f20 2020  ult: false.//   
+0001f730: 7231 203d 2052 6164 6975 7320 6f66 2063  r1 = Radius of c
+0001f740: 6972 6375 6c61 7220 706f 7274 696f 6e20  ircular portion 
+0001f750: 6f66 2074 6865 2066 726f 6e74 2065 6e64  of the front end
+0001f760: 206f 6620 7468 6520 7465 6172 6472 6f70   of the teardrop
+0001f770: 2073 6861 7065 2e0a 2f2f 2020 2072 3220   shape..//   r2 
+0001f780: 3d20 5261 6469 7573 206f 6620 6369 7263  = Radius of circ
+0001f790: 756c 6172 2070 6f72 7469 6f6e 206f 6620  ular portion of 
+0001f7a0: 7468 6520 6261 636b 2065 6e64 206f 6620  the back end of 
+0001f7b0: 7468 6520 7465 6172 6472 6f70 2073 6861  the teardrop sha
+0001f7c0: 7065 2e0a 2f2f 2020 2064 203d 2044 6961  pe..//   d = Dia
+0001f7d0: 6d65 7465 7220 6f66 2063 6972 6375 6c61  meter of circula
+0001f7e0: 7220 706f 7274 696f 6e20 6f66 2074 6865  r portion of the
+0001f7f0: 2074 6561 7264 726f 7020 7368 6170 652e   teardrop shape.
+0001f800: 0a2f 2f20 2020 6431 203d 2044 6961 6d65  .//   d1 = Diame
+0001f810: 7465 7220 6f66 2063 6972 6375 6c61 7220  ter of circular 
+0001f820: 706f 7274 696f 6e20 6f66 2074 6865 2066  portion of the f
+0001f830: 726f 6e74 2065 6e64 206f 6620 7468 6520  ront end of the 
+0001f840: 7465 6172 6472 6f70 2073 6861 7065 2e0a  teardrop shape..
+0001f850: 2f2f 2020 2064 3220 3d20 4469 616d 6574  //   d2 = Diamet
+0001f860: 6572 206f 6620 6369 7263 756c 6172 2070  er of circular p
+0001f870: 6f72 7469 6f6e 206f 6620 7468 6520 6261  ortion of the ba
+0001f880: 636b 2065 6e64 206f 6620 7468 6520 7465  ck end of the te
+0001f890: 6172 6472 6f70 2073 6861 7065 2e0a 2f2f  ardrop shape..//
+0001f8a0: 2020 2063 6170 5f68 3120 3d20 4966 2067     cap_h1 = If g
+0001f8b0: 6976 656e 2c20 6865 6967 6874 2061 626f  iven, height abo
+0001f8c0: 7665 2063 656e 7465 7220 7768 6572 6520  ve center where 
+0001f8d0: 7468 6520 7368 6170 6520 7769 6c6c 2062  the shape will b
+0001f8e0: 6520 7472 756e 6361 7465 642c 206f 6e20  e truncated, on 
+0001f8f0: 7468 6520 6672 6f6e 7420 7369 6465 2e20  the front side. 
+0001f900: 4465 6661 756c 743a 2060 756e 6465 6660  Default: `undef`
+0001f910: 2028 6e6f 2074 7275 6e63 6174 696f 6e29   (no truncation)
+0001f920: 0a2f 2f20 2020 6361 705f 6832 203d 2049  .//   cap_h2 = I
+0001f930: 6620 6769 7665 6e2c 2068 6569 6768 7420  f given, height 
+0001f940: 6162 6f76 6520 6365 6e74 6572 2077 6865  above center whe
+0001f950: 7265 2074 6865 2073 6861 7065 2077 696c  re the shape wil
+0001f960: 6c20 6265 2074 7275 6e63 6174 6564 2c20  l be truncated, 
+0001f970: 6f6e 2074 6865 2062 6163 6b20 7369 6465  on the back side
+0001f980: 2e20 4465 6661 756c 743a 2060 756e 6465  . Default: `unde
+0001f990: 6660 2028 6e6f 2074 7275 6e63 6174 696f  f` (no truncatio
+0001f9a0: 6e29 0a2f 2f20 2020 6368 616d 6665 7220  n).//   chamfer 
+0001f9b0: 3d20 5370 6563 6966 6965 7320 7369 7a65  = Specifies size
+0001f9c0: 206f 6620 6368 616d 6665 7220 6173 2064   of chamfer as d
+0001f9d0: 6973 7461 6e63 6520 616c 6f6e 6720 7468  istance along th
+0001f9e0: 6520 626f 7474 6f6d 2061 6e64 2074 6f70  e bottom and top
+0001f9f0: 2066 6163 6573 2e20 2044 6566 6175 6c74   faces.  Default
+0001fa00: 3a20 300a 2f2f 2020 2063 6861 6d66 6572  : 0.//   chamfer
+0001fa10: 3120 3d20 5370 6563 6966 6965 7320 7369  1 = Specifies si
+0001fa20: 7a65 206f 6620 6368 616d 6665 7220 6f6e  ze of chamfer on
+0001fa30: 2062 6f74 746f 6d20 6173 2064 6973 7461   bottom as dista
+0001fa40: 6e63 6520 616c 6f6e 6720 626f 7474 6f6d  nce along bottom
+0001fa50: 2066 6163 652e 2020 4465 6661 756c 743a   face.  Default:
+0001fa60: 2030 0a2f 2f20 2020 6368 616d 6665 7232   0.//   chamfer2
+0001fa70: 203d 2053 7065 6369 6669 6573 2073 697a   = Specifies siz
+0001fa80: 6520 6f66 2063 6861 6d66 6572 206f 6e20  e of chamfer on 
+0001fa90: 746f 7020 6173 2064 6973 7461 6e63 6520  top as distance 
+0001faa0: 616c 6f6e 6720 746f 7020 6661 6365 2e20  along top face. 
+0001fab0: 2044 6566 6175 6c74 3a20 300a 2f2f 2020   Default: 0.//  
+0001fac0: 2072 6561 6c69 676e 203d 2050 6173 7365   realign = Passe
+0001fad0: 7320 7265 616c 6967 6e20 6f70 7469 6f6e  s realign option
+0001fae0: 2074 6f20 7465 6172 6472 6f70 3264 2c20   to teardrop2d, 
+0001faf0: 7768 6963 6820 7368 6966 7473 2066 6163  which shifts fac
+0001fb00: 6520 616c 6967 6e6d 656e 742e 2020 4465  e alignment.  De
+0001fb10: 6661 756c 743a 2066 616c 7365 0a2f 2f20  fault: false.// 
+0001fb20: 2020 616e 6368 6f72 203d 2054 7261 6e73    anchor = Trans
+0001fb30: 6c61 7465 2073 6f20 616e 6368 6f72 2070  late so anchor p
+0001fb40: 6f69 6e74 2069 7320 6174 206f 7269 6769  oint is at origi
+0001fb50: 6e20 2830 2c30 2c30 292e 2020 5365 6520  n (0,0,0).  See 
+0001fb60: 5b61 6e63 686f 725d 2861 7474 6163 686d  [anchor](attachm
+0001fb70: 656e 7473 2e73 6361 6423 7375 6273 6563  ents.scad#subsec
+0001fb80: 7469 6f6e 2d61 6e63 686f 7229 2e20 2044  tion-anchor).  D
+0001fb90: 6566 6175 6c74 3a20 6043 454e 5445 5260  efault: `CENTER`
+0001fba0: 0a2f 2f20 2020 7370 696e 203d 2052 6f74  .//   spin = Rot
+0001fbb0: 6174 6520 7468 6973 206d 616e 7920 6465  ate this many de
+0001fbc0: 6772 6565 7320 6172 6f75 6e64 2074 6865  grees around the
+0001fbd0: 205a 2061 7869 7320 6166 7465 7220 616e   Z axis after an
+0001fbe0: 6368 6f72 2e20 2053 6565 205b 7370 696e  chor.  See [spin
+0001fbf0: 5d28 6174 7461 6368 6d65 6e74 732e 7363  ](attachments.sc
+0001fc00: 6164 2373 7562 7365 6374 696f 6e2d 7370  ad#subsection-sp
+0001fc10: 696e 292e 2020 4465 6661 756c 743a 2060  in).  Default: `
+0001fc20: 3060 0a2f 2f20 2020 6f72 6965 6e74 203d  0`.//   orient =
+0001fc30: 2056 6563 746f 7220 746f 2072 6f74 6174   Vector to rotat
+0001fc40: 6520 746f 7020 746f 7761 7264 732c 2061  e top towards, a
+0001fc50: 6674 6572 2073 7069 6e2e 2020 5365 6520  fter spin.  See 
+0001fc60: 5b6f 7269 656e 745d 2861 7474 6163 686d  [orient](attachm
+0001fc70: 656e 7473 2e73 6361 6423 7375 6273 6563  ents.scad#subsec
+0001fc80: 7469 6f6e 2d6f 7269 656e 7429 2e20 2044  tion-orient).  D
+0001fc90: 6566 6175 6c74 3a20 6055 5060 0a2f 2f0a  efault: `UP`.//.
+0001fca0: 2f2f 2045 7874 7261 2041 6e63 686f 7273  // Extra Anchors
+0001fcb0: 3a0a 2f2f 2020 2063 6170 203d 2054 6865  :.//   cap = The
+0001fcc0: 2063 656e 7465 7220 6f66 2074 6865 2074   center of the t
+0001fcd0: 6f70 206f 6620 7468 6520 6361 702c 206f  op of the cap, o
+0001fce0: 7269 656e 7465 6420 7769 7468 2074 6865  riented with the
+0001fcf0: 2063 6170 2066 6163 6520 6e6f 726d 616c   cap face normal
+0001fd00: 2e0a 2f2f 2020 2063 6170 5f66 7764 203d  ..//   cap_fwd =
+0001fd10: 2054 6865 2066 726f 6e74 2065 6467 6520   The front edge 
+0001fd20: 6f66 2074 6865 2063 6170 2e0a 2f2f 2020  of the cap..//  
+0001fd30: 2063 6170 5f62 6163 6b20 3d20 5468 6520   cap_back = The 
+0001fd40: 6261 636b 2065 6467 6520 6f66 2074 6865  back edge of the
+0001fd50: 2063 6170 2e0a 2f2f 0a2f 2f20 4578 616d   cap..//.// Exam
+0001fd60: 706c 653a 2054 7970 6963 616c 2053 6861  ple: Typical Sha
+0001fd70: 7065 0a2f 2f20 2020 7465 6172 6472 6f70  pe.//   teardrop
+0001fd80: 2872 3d33 302c 2068 3d31 302c 2061 6e67  (r=30, h=10, ang
+0001fd90: 3d33 3029 3b0a 2f2f 2045 7861 6d70 6c65  =30);.// Example
+0001fda0: 3a20 4372 6f70 2043 6170 0a2f 2f20 2020  : Crop Cap.//   
+0001fdb0: 7465 6172 6472 6f70 2872 3d33 302c 2068  teardrop(r=30, h
+0001fdc0: 3d31 302c 2061 6e67 3d33 302c 2063 6170  =10, ang=30, cap
+0001fdd0: 5f68 3d34 3029 3b0a 2f2f 2045 7861 6d70  _h=40);.// Examp
+0001fde0: 6c65 3a20 436c 6f73 6520 4372 6f70 0a2f  le: Close Crop./
+0001fdf0: 2f20 2020 7465 6172 6472 6f70 2872 3d33  /   teardrop(r=3
+0001fe00: 302c 2068 3d31 302c 2061 6e67 3d33 302c  0, h=10, ang=30,
+0001fe10: 2063 6170 5f68 3d32 3029 3b0a 2f2f 2045   cap_h=20);.// E
+0001fe20: 7861 6d70 6c65 3a20 5073 7565 646f 2d43  xample: Psuedo-C
+0001fe30: 6f6e 6963 616c 0a2f 2f20 2020 7465 6172  onical.//   tear
+0001fe40: 6472 6f70 2872 313d 3230 2c20 7232 3d33  drop(r1=20, r2=3
+0001fe50: 302c 2068 3d34 302c 2063 6170 5f68 313d  0, h=40, cap_h1=
+0001fe60: 3235 2c20 6361 705f 6832 3d33 3529 3b0a  25, cap_h2=35);.
+0001fe70: 2f2f 2045 7861 6d70 6c65 3a20 4164 6469  // Example: Addi
+0001fe80: 6e67 2063 6861 6d66 6572 7320 6361 6e20  ng chamfers can 
+0001fe90: 6265 2075 7365 6675 6c20 666f 7220 6120  be useful for a 
+0001fea0: 7465 6172 6472 6f70 2068 6f6c 6520 6d61  teardrop hole ma
+0001feb0: 736b 0a2f 2f20 2020 7465 6172 6472 6f70  sk.//   teardrop
+0001fec0: 2872 3d31 302c 206c 3d35 302c 2063 6861  (r=10, l=50, cha
+0001fed0: 6d66 6572 313d 322c 2063 6861 6d66 6572  mfer1=2, chamfer
+0001fee0: 323d 2d31 2e35 293b 0a2f 2f20 4578 616d  2=-1.5);.// Exam
+0001fef0: 706c 653a 2047 6574 7469 6e67 2061 2056  ple: Getting a V
+0001ff00: 4e46 0a2f 2f20 2020 766e 6620 3d20 7465  NF.//   vnf = te
+0001ff10: 6172 6472 6f70 2872 313d 3235 2c20 7232  ardrop(r1=25, r2
+0001ff20: 3d33 302c 206c 3d32 302c 2063 6170 5f68  =30, l=20, cap_h
+0001ff30: 313d 3235 2c20 6361 705f 6832 3d33 3529  1=25, cap_h2=35)
+0001ff40: 3b0a 2f2f 2020 2076 6e66 5f70 6f6c 7968  ;.//   vnf_polyh
+0001ff50: 6564 726f 6e28 766e 6629 3b0a 2f2f 2045  edron(vnf);.// E
+0001ff60: 7861 6d70 6c65 3a20 5374 616e 6461 7264  xample: Standard
+0001ff70: 2043 6f6e 6963 616c 2043 6f6e 6e65 6374   Conical Connect
+0001ff80: 6f72 730a 2f2f 2020 2074 6561 7264 726f  ors.//   teardro
+0001ff90: 7028 6431 3d32 302c 2064 323d 3330 2c20  p(d1=20, d2=30, 
+0001ffa0: 683d 3230 2c20 6361 705f 6831 3d31 312c  h=20, cap_h1=11,
+0001ffb0: 2063 6170 5f68 323d 3136 290a 2f2f 2020   cap_h2=16).//  
+0001ffc0: 2020 2020 2073 686f 775f 616e 6368 6f72       show_anchor
+0001ffd0: 7328 6375 7374 6f6d 3d66 616c 7365 293b  s(custom=false);
+0001ffe0: 0a2f 2f20 4578 616d 706c 6528 5370 696e  .// Example(Spin
+0001fff0: 2c56 5044 3d31 3530 2c4d 6564 293a 204e  ,VPD=150,Med): N
+00020000: 616d 6564 2043 6f6e 6963 616c 2043 6f6e  amed Conical Con
+00020010: 6e65 6374 6f72 730a 2f2f 2020 2074 6561  nectors.//   tea
+00020020: 7264 726f 7028 6431 3d32 302c 2064 323d  rdrop(d1=20, d2=
+00020030: 3330 2c20 683d 3230 2c20 6361 705f 6831  30, h=20, cap_h1
+00020040: 3d31 312c 2063 6170 5f68 323d 3136 290a  =11, cap_h2=16).
+00020050: 2f2f 2020 2020 2020 2073 686f 775f 616e  //       show_an
+00020060: 6368 6f72 7328 7374 643d 6661 6c73 6529  chors(std=false)
+00020070: 3b0a 0a6d 6f64 756c 6520 7465 6172 6472  ;..module teardr
+00020080: 6f70 2868 2c20 722c 2061 6e67 3d34 352c  op(h, r, ang=45,
+00020090: 2063 6170 5f68 2c20 7231 2c20 7232 2c20   cap_h, r1, r2, 
+000200a0: 642c 2064 312c 2064 322c 2063 6170 5f68  d, d1, d2, cap_h
+000200b0: 312c 2063 6170 5f68 322c 206c 2c20 6c65  1, cap_h2, l, le
+000200c0: 6e67 7468 2c20 6865 6967 6874 2c20 6369  ngth, height, ci
+000200d0: 7263 756d 3d66 616c 7365 2c20 7265 616c  rcum=false, real
+000200e0: 6967 6e3d 6661 6c73 652c 0a20 2020 2020  ign=false,.     
+000200f0: 2020 2020 2020 2020 2020 2063 6861 6d66             chamf
+00020100: 6572 2c20 6368 616d 6665 7231 2c20 6368  er, chamfer1, ch
+00020110: 616d 6665 7232 2c61 6e63 686f 723d 4345  amfer2,anchor=CE
+00020120: 4e54 4552 2c20 7370 696e 3d30 2c20 6f72  NTER, spin=0, or
+00020130: 6965 6e74 3d55 5029 0a7b 0a20 2020 206c  ient=UP).{.    l
+00020140: 656e 6774 6820 3d20 6f6e 655f 6465 6669  ength = one_defi
+00020150: 6e65 6428 5b6c 2c20 682c 206c 656e 6774  ned([l, h, lengt
+00020160: 682c 2068 6569 6768 745d 2c22 6c2c 682c  h, height],"l,h,
+00020170: 6c65 6e67 7468 2c68 6569 6768 7422 293b  length,height");
+00020180: 0a20 2020 2064 756d 6d79 3d61 7373 6572  .    dummy=asser
+00020190: 7428 6973 5f66 696e 6974 6528 6c65 6e67  t(is_finite(leng
+000201a0: 7468 2920 2626 206c 656e 6774 683e 302c  th) && length>0,
+000201b0: 2022 6c65 6e67 7468 206d 7573 7420 6265   "length must be
+000201c0: 2070 6f73 6974 6976 6522 293b 0a20 2020   positive");.   
+000201d0: 2072 3120 3d20 6765 745f 7261 6469 7573   r1 = get_radius
+000201e0: 2872 3d72 2c20 7231 3d72 312c 2064 3d64  (r=r, r1=r1, d=d
+000201f0: 2c20 6431 3d64 3129 3b0a 2020 2020 7232  , d1=d1);.    r2
+00020200: 203d 2067 6574 5f72 6164 6975 7328 723d   = get_radius(r=
+00020210: 722c 2072 313d 7232 2c20 643d 642c 2064  r, r1=r2, d=d, d
+00020220: 313d 6432 293b 0a20 2020 2074 6970 5f79  1=d2);.    tip_y
+00020230: 3120 3d20 7231 2f63 6f73 2839 302d 616e  1 = r1/cos(90-an
+00020240: 6729 3b0a 2020 2020 7469 705f 7932 203d  g);.    tip_y2 =
+00020250: 2072 322f 636f 7328 3930 2d61 6e67 293b   r2/cos(90-ang);
+00020260: 0a20 2020 205f 6361 705f 6831 203d 206d  .    _cap_h1 = m
+00020270: 696e 2864 6566 6175 6c74 2863 6170 5f68  in(default(cap_h
+00020280: 312c 2074 6970 5f79 3129 2c20 7469 705f  1, tip_y1), tip_
+00020290: 7931 293b 0a20 2020 205f 6361 705f 6832  y1);.    _cap_h2
+000202a0: 203d 206d 696e 2864 6566 6175 6c74 2863   = min(default(c
+000202b0: 6170 5f68 322c 2074 6970 5f79 3229 2c20  ap_h2, tip_y2), 
+000202c0: 7469 705f 7932 293b 0a20 2020 2063 6170  tip_y2);.    cap
+000202d0: 7665 6320 3d20 756e 6974 285b 302c 205f  vec = unit([0, _
+000202e0: 6361 705f 6831 2d5f 6361 705f 6832 2c20  cap_h1-_cap_h2, 
+000202f0: 6c65 6e67 7468 5d29 3b0a 2020 2020 616e  length]);.    an
+00020300: 6368 6f72 7320 3d20 5b0a 2020 2020 2020  chors = [.      
+00020310: 2020 6e61 6d65 645f 616e 6368 6f72 2822    named_anchor("
+00020320: 6361 7022 2c20 2020 2020 205b 302c 302c  cap",      [0,0,
+00020330: 285f 6361 705f 6831 2b5f 6361 705f 6832  (_cap_h1+_cap_h2
+00020340: 292f 325d 2c20 6361 7076 6563 292c 0a20  )/2], capvec),. 
+00020350: 2020 2020 2020 206e 616d 6564 5f61 6e63         named_anc
+00020360: 686f 7228 2263 6170 5f66 7764 222c 2020  hor("cap_fwd",  
+00020370: 5b30 2c2d 6c65 6e67 7468 2f32 2c5f 6361  [0,-length/2,_ca
+00020380: 705f 6831 5d2c 2020 2020 2020 2020 2075  p_h1],         u
+00020390: 6e69 7428 2863 6170 7665 632b 4657 4429  nit((capvec+FWD)
+000203a0: 2f32 2929 2c0a 2020 2020 2020 2020 6e61  /2)),.        na
+000203b0: 6d65 645f 616e 6368 6f72 2822 6361 705f  med_anchor("cap_
+000203c0: 6261 636b 222c 205b 302c 2b6c 656e 6774  back", [0,+lengt
+000203d0: 682f 322c 5f63 6170 5f68 325d 2c20 2020  h/2,_cap_h2],   
+000203e0: 2020 2020 2020 756e 6974 2828 6361 7076        unit((capv
+000203f0: 6563 2b42 4143 4b29 2f32 292c 2031 3830  ec+BACK)/2), 180
+00020400: 292c 0a20 2020 205d 3b0a 2020 2020 6174  ),.    ];.    at
+00020410: 7461 6368 6162 6c65 2861 6e63 686f 722c  tachable(anchor,
+00020420: 7370 696e 2c6f 7269 656e 742c 2072 313d  spin,orient, r1=
+00020430: 7231 2c20 7232 3d72 322c 206c 3d6c 656e  r1, r2=r2, l=len
+00020440: 6774 682c 2061 7869 733d 4241 434b 2c20  gth, axis=BACK, 
+00020450: 616e 6368 6f72 733d 616e 6368 6f72 7329  anchors=anchors)
+00020460: 0a20 2020 207b 0a20 2020 2020 2020 2076  .    {.        v
+00020470: 6e66 5f70 6f6c 7968 6564 726f 6e28 7465  nf_polyhedron(te
+00020480: 6172 6472 6f70 2861 6e67 3d61 6e67 2c63  ardrop(ang=ang,c
+00020490: 6170 5f68 3d63 6170 5f68 2c72 313d 7231  ap_h=cap_h,r1=r1
+000204a0: 2c72 323d 7232 2c63 6170 5f68 313d 6361  ,r2=r2,cap_h1=ca
+000204b0: 705f 6831 2c63 6170 5f68 323d 6361 705f  p_h1,cap_h2=cap_
+000204c0: 6832 2c63 6972 6375 6d3d 6369 7263 756d  h2,circum=circum
+000204d0: 2c72 6561 6c69 676e 3d72 6561 6c69 676e  ,realign=realign
+000204e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000204f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020500: 2020 6c65 6e67 7468 3d6c 656e 6774 682c    length=length,
+00020510: 2063 6861 6d66 6572 313d 6368 616d 6665   chamfer1=chamfe
+00020520: 7231 2c63 6861 6d66 6572 323d 6368 616d  r1,chamfer2=cham
+00020530: 6665 7232 2c63 6861 6d66 6572 3d63 6861  fer2,chamfer=cha
+00020540: 6d66 6572 2929 3b0a 2020 2020 2020 2020  mfer));.        
+00020550: 6368 696c 6472 656e 2829 3b0a 2020 2020  children();.    
+00020560: 7d0a 7d0a 0a0a 6675 6e63 7469 6f6e 2074  }.}...function t
+00020570: 6561 7264 726f 7028 682c 2072 2c20 616e  eardrop(h, r, an
+00020580: 673d 3435 2c20 6361 705f 682c 2072 312c  g=45, cap_h, r1,
+00020590: 2072 322c 2064 2c20 6431 2c20 6432 2c20   r2, d, d1, d2, 
+000205a0: 6361 705f 6831 2c20 6361 705f 6832 2c20  cap_h1, cap_h2, 
+000205b0: 2063 6861 6d66 6572 2c20 6368 616d 6665   chamfer, chamfe
+000205c0: 7231 2c20 6368 616d 6665 7232 2c20 6369  r1, chamfer2, ci
+000205d0: 7263 756d 3d66 616c 7365 2c20 7265 616c  rcum=false, real
+000205e0: 6967 6e3d 6661 6c73 652c 0a20 2020 2020  ign=false,.     
+000205f0: 2020 2020 2020 2020 2020 2020 206c 2c20               l, 
+00020600: 6c65 6e67 7468 2c20 6865 6967 6874 2c20  length, height, 
+00020610: 616e 6368 6f72 3d43 454e 5445 522c 2073  anchor=CENTER, s
+00020620: 7069 6e3d 302c 206f 7269 656e 743d 5550  pin=0, orient=UP
+00020630: 2920 3d0a 2020 2020 6c65 7428 0a20 2020  ) =.    let(.   
+00020640: 2020 2020 2072 3120 3d20 6765 745f 7261       r1 = get_ra
+00020650: 6469 7573 2872 3d72 2c20 7231 3d72 312c  dius(r=r, r1=r1,
+00020660: 2064 3d64 2c20 6431 3d64 312c 2064 666c   d=d, d1=d1, dfl
+00020670: 743d 3129 2c0a 2020 2020 2020 2020 7232  t=1),.        r2
+00020680: 203d 2067 6574 5f72 6164 6975 7328 723d   = get_radius(r=
+00020690: 722c 2072 313d 7232 2c20 643d 642c 2064  r, r1=r2, d=d, d
+000206a0: 313d 6432 2c20 6466 6c74 3d31 292c 0a20  1=d2, dflt=1),. 
+000206b0: 2020 2020 2020 206c 656e 6774 6820 3d20         length = 
+000206c0: 6f6e 655f 6465 6669 6e65 6428 5b6c 2c20  one_defined([l, 
+000206d0: 682c 206c 656e 6774 682c 2068 6569 6768  h, length, heigh
+000206e0: 745d 2c22 6c2c 682c 6c65 6e67 7468 2c68  t],"l,h,length,h
+000206f0: 6569 6768 7422 292c 0a20 2020 2020 2020  eight"),.       
+00020700: 2064 756d 6d79 303d 6173 7365 7274 2869   dummy0=assert(i
+00020710: 735f 6669 6e69 7465 286c 656e 6774 6829  s_finite(length)
+00020720: 2026 2620 6c65 6e67 7468 3e30 2c20 226c   && length>0, "l
+00020730: 656e 6774 6820 6d75 7374 2062 6520 706f  ength must be po
+00020740: 7369 7469 7665 2229 2c0a 2020 2020 2020  sitive"),.      
+00020750: 2020 6361 705f 6831 203d 2066 6972 7374    cap_h1 = first
+00020760: 5f64 6566 696e 6564 285b 6361 705f 6831  _defined([cap_h1
+00020770: 2c20 6361 705f 685d 292c 0a20 2020 2020  , cap_h]),.     
+00020780: 2020 2063 6170 5f68 3220 3d20 6669 7273     cap_h2 = firs
+00020790: 745f 6465 6669 6e65 6428 5b63 6170 5f68  t_defined([cap_h
+000207a0: 322c 2063 6170 5f68 5d29 2c0a 2020 2020  2, cap_h]),.    
+000207b0: 2020 2020 6368 616d 6665 7231 203d 2066      chamfer1 = f
+000207c0: 6972 7374 5f64 6566 696e 6564 285b 6368  irst_defined([ch
+000207d0: 616d 6665 7231 2c63 6861 6d66 6572 2c30  amfer1,chamfer,0
+000207e0: 5d29 2c0a 2020 2020 2020 2020 6368 616d  ]),.        cham
+000207f0: 6665 7232 203d 2066 6972 7374 5f64 6566  fer2 = first_def
+00020800: 696e 6564 285b 6368 616d 6665 7232 2c63  ined([chamfer2,c
+00020810: 6861 6d66 6572 2c30 5d29 2c20 2020 200a  hamfer,0]),    .
+00020820: 2020 2020 2020 2020 7369 6465 7320 3d20          sides = 
+00020830: 7365 6773 286d 6178 2872 312c 7232 2929  segs(max(r1,r2))
+00020840: 2c0a 2020 2020 2020 2020 7072 6f66 696c  ,.        profil
+00020850: 6531 203d 2074 6561 7264 726f 7032 6428  e1 = teardrop2d(
+00020860: 723d 7231 2c20 616e 673d 616e 672c 2063  r=r1, ang=ang, c
+00020870: 6170 5f68 3d63 6170 5f68 312c 2024 666e  ap_h=cap_h1, $fn
+00020880: 3d73 6964 6573 2c20 6369 7263 756d 3d63  =sides, circum=c
+00020890: 6972 6375 6d2c 2072 6561 6c69 676e 3d72  ircum, realign=r
+000208a0: 6561 6c69 676e 2c5f 6578 7472 6170 743d  ealign,_extrapt=
+000208b0: 7472 7565 292c 0a20 2020 2020 2020 2070  true),.        p
+000208c0: 726f 6669 6c65 3220 3d20 7465 6172 6472  rofile2 = teardr
+000208d0: 6f70 3264 2872 3d72 322c 2061 6e67 3d61  op2d(r=r2, ang=a
+000208e0: 6e67 2c20 6361 705f 683d 6361 705f 6832  ng, cap_h=cap_h2
+000208f0: 2c20 2466 6e3d 7369 6465 732c 2063 6972  , $fn=sides, cir
+00020900: 6375 6d3d 6369 7263 756d 2c20 7265 616c  cum=circum, real
+00020910: 6967 6e3d 7265 616c 6967 6e2c 5f65 7874  ign=realign,_ext
+00020920: 7261 7074 3d74 7275 6529 2c0a 2020 2020  rapt=true),.    
+00020930: 2020 2020 7469 705f 7931 203d 2072 312f      tip_y1 = r1/
+00020940: 636f 7328 3930 2d61 6e67 292c 0a20 2020  cos(90-ang),.   
+00020950: 2020 2020 2074 6970 5f79 3220 3d20 7232       tip_y2 = r2
+00020960: 2f63 6f73 2839 302d 616e 6729 2c0a 2020  /cos(90-ang),.  
+00020970: 2020 2020 2020 5f63 6170 5f68 3120 3d20        _cap_h1 = 
+00020980: 6d69 6e28 6465 6661 756c 7428 6361 705f  min(default(cap_
+00020990: 6831 2c20 7469 705f 7931 292c 2074 6970  h1, tip_y1), tip
+000209a0: 5f79 3129 2c0a 2020 2020 2020 2020 5f63  _y1),.        _c
+000209b0: 6170 5f68 3220 3d20 6d69 6e28 6465 6661  ap_h2 = min(defa
+000209c0: 756c 7428 6361 705f 6832 2c20 7469 705f  ult(cap_h2, tip_
+000209d0: 7932 292c 2074 6970 5f79 3229 2c0a 2020  y2), tip_y2),.  
+000209e0: 2020 2020 2020 6361 7076 6563 203d 2075        capvec = u
+000209f0: 6e69 7428 5b30 2c20 5f63 6170 5f68 312d  nit([0, _cap_h1-
+00020a00: 5f63 6170 5f68 322c 206c 656e 6774 685d  _cap_h2, length]
+00020a10: 292c 0a20 2020 2020 2020 2064 756d 6d79  ),.        dummy
+00020a20: 3d0a 2020 2020 2020 2020 2020 6173 7365  =.          asse
+00020a30: 7274 2861 6273 2863 6861 6d66 6572 3129  rt(abs(chamfer1)
+00020a40: 2b61 6273 2863 6861 6d66 6572 3229 203c  +abs(chamfer2) <
+00020a50: 3d20 6c65 6e67 7468 2c22 6368 616d 6665  = length,"chamfe
+00020a60: 7273 2061 7265 2074 6f6f 2062 6967 2074  rs are too big t
+00020a70: 6f20 6669 7420 696e 2074 6865 206c 656e  o fit in the len
+00020a80: 6774 6822 290a 2020 2020 2020 2020 2020  gth").          
+00020a90: 6173 7365 7274 2863 6861 6d66 6572 313c  assert(chamfer1<
+00020aa0: 3d72 3120 2626 2063 6861 6d66 6572 323c  =r1 && chamfer2<
+00020ab0: 3d72 322c 2022 4368 616d 6665 7273 2063  =r2, "Chamfers c
+00020ac0: 616e 6e6f 7420 6265 206c 6172 6765 7220  annot be larger 
+00020ad0: 7468 616e 2072 6164 7569 7322 290a 2020  than raduis").  
+00020ae0: 2020 2020 2020 2020 6173 7365 7274 2869          assert(i
+00020af0: 735f 756e 6465 6628 6361 705f 6831 2920  s_undef(cap_h1) 
+00020b00: 7c7c 2063 6170 5f68 312d 6368 616d 6665  || cap_h1-chamfe
+00020b10: 7231 203e 2072 312a 7369 6e28 616e 6729  r1 > r1*sin(ang)
+00020b20: 2c20 2263 6861 6d66 6572 3120 6973 2074  , "chamfer1 is t
+00020b30: 6f6f 2062 6967 2074 6f20 776f 726b 2077  oo big to work w
+00020b40: 6974 6820 7468 6520 7370 6563 6966 6965  ith the specifie
+00020b50: 6420 6361 705f 6831 2229 0a20 2020 2020  d cap_h1").     
+00020b60: 2020 2020 2061 7373 6572 7428 6973 5f75       assert(is_u
+00020b70: 6e64 6566 2863 6170 5f68 3229 207c 7c20  ndef(cap_h2) || 
+00020b80: 6361 705f 6832 2d63 6861 6d66 6572 3220  cap_h2-chamfer2 
+00020b90: 3e20 7232 2a73 696e 2861 6e67 292c 2022  > r2*sin(ang), "
+00020ba0: 6368 616d 6665 7232 2069 7320 746f 6f20  chamfer2 is too 
+00020bb0: 6269 6720 746f 2077 6f72 6b20 7769 7468  big to work with
+00020bc0: 2074 6865 2073 7065 6369 6669 6564 2063   the specified c
+00020bd0: 6170 5f68 3222 292c 0a20 2020 2020 2020  ap_h2"),.       
+00020be0: 2063 7072 6f66 3120 3d20 7231 3d3d 6368   cprof1 = r1==ch
+00020bf0: 616d 6665 7231 203f 2072 6570 6561 7428  amfer1 ? repeat(
+00020c00: 5b30 2c30 5d2c 6c65 6e28 7072 6f66 696c  [0,0],len(profil
+00020c10: 6531 2929 0a20 2020 2020 2020 2020 2020  e1)).           
+00020c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020c30: 2020 203a 2074 6561 7264 726f 7032 6428     : teardrop2d(
+00020c40: 723d 7231 2d63 6861 6d66 6572 312c 2061  r=r1-chamfer1, a
+00020c50: 6e67 3d61 6e67 2c20 6361 705f 683d 755f  ng=ang, cap_h=u_
+00020c60: 6164 6428 6361 705f 6831 2c2d 6368 616d  add(cap_h1,-cham
+00020c70: 6665 7231 292c 2024 666e 3d73 6964 6573  fer1), $fn=sides
+00020c80: 2c20 6369 7263 756d 3d63 6972 6375 6d2c  , circum=circum,
+00020c90: 2072 6561 6c69 676e 3d72 6561 6c69 676e   realign=realign
+00020ca0: 2c5f 6578 7472 6170 743d 7472 7565 292c  ,_extrapt=true),
+00020cb0: 0a20 2020 2020 2020 2063 7072 6f66 3220  .        cprof2 
+00020cc0: 3d20 7232 3d3d 6368 616d 6665 7232 203f  = r2==chamfer2 ?
+00020cd0: 2072 6570 6561 7428 5b30 2c30 5d2c 6c65   repeat([0,0],le
+00020ce0: 6e28 7072 6f66 696c 6532 2929 0a20 2020  n(profile2)).   
+00020cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020d00: 2020 2020 2020 2020 2020 203a 2074 6561             : tea
+00020d10: 7264 726f 7032 6428 723d 7232 2d63 6861  rdrop2d(r=r2-cha
+00020d20: 6d66 6572 322c 2061 6e67 3d61 6e67 2c20  mfer2, ang=ang, 
+00020d30: 6361 705f 683d 755f 6164 6428 6361 705f  cap_h=u_add(cap_
+00020d40: 6832 2c2d 6368 616d 6665 7232 292c 2024  h2,-chamfer2), $
+00020d50: 666e 3d73 6964 6573 2c20 6369 7263 756d  fn=sides, circum
+00020d60: 3d63 6972 6375 6d2c 2072 6561 6c69 676e  =circum, realign
+00020d70: 3d72 6561 6c69 676e 2c5f 6578 7472 6170  =realign,_extrap
+00020d80: 743d 7472 7565 292c 0a20 2020 2020 2020  t=true),.       
+00020d90: 2061 6e63 686f 7273 203d 205b 0a20 2020   anchors = [.   
+00020da0: 2020 2020 2020 2020 206e 616d 6564 5f61           named_a
+00020db0: 6e63 686f 7228 2263 6170 222c 2020 2020  nchor("cap",    
+00020dc0: 2020 5b30 2c30 2c28 5f63 6170 5f68 312b    [0,0,(_cap_h1+
+00020dd0: 5f63 6170 5f68 3229 2f32 5d2c 2063 6170  _cap_h2)/2], cap
+00020de0: 7665 6329 2c0a 2020 2020 2020 2020 2020  vec),.          
+00020df0: 2020 6e61 6d65 645f 616e 6368 6f72 2822    named_anchor("
+00020e00: 6361 705f 6677 6422 2c20 205b 302c 2d6c  cap_fwd",  [0,-l
+00020e10: 656e 6774 682f 322c 5f63 6170 5f68 315d  ength/2,_cap_h1]
+00020e20: 2c20 2020 2020 2020 2020 756e 6974 2828  ,         unit((
+00020e30: 6361 7076 6563 2b46 5744 292f 3229 292c  capvec+FWD)/2)),
+00020e40: 0a20 2020 2020 2020 2020 2020 206e 616d  .            nam
+00020e50: 6564 5f61 6e63 686f 7228 2263 6170 5f62  ed_anchor("cap_b
+00020e60: 6163 6b22 2c20 5b30 2c2b 6c65 6e67 7468  ack", [0,+length
+00020e70: 2f32 2c5f 6361 705f 6832 5d2c 2020 2020  /2,_cap_h2],    
+00020e80: 2020 2020 2075 6e69 7428 2863 6170 7665       unit((capve
+00020e90: 632b 4241 434b 292f 3229 2c20 3138 3029  c+BACK)/2), 180)
+00020ea0: 2c0a 2020 2020 2020 2020 5d2c 0a20 2020  ,.        ],.   
+00020eb0: 2020 2020 2076 6e66 203d 2076 6e66 5f76       vnf = vnf_v
+00020ec0: 6572 7465 785f 6172 7261 7928 0a20 2020  ertex_array(.   
+00020ed0: 2020 2020 2020 2020 2070 6f69 6e74 7320           points 
+00020ee0: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+00020ef0: 2020 2020 6966 2028 6368 616d 6665 7231      if (chamfer1
+00020f00: 213d 3029 2066 7764 286c 656e 6774 682f  !=0) fwd(length/
+00020f10: 322c 2078 726f 7428 3930 2c20 7061 7468  2, xrot(90, path
+00020f20: 3364 2863 7072 6f66 3129 2929 2c0a 2020  3d(cprof1))),.  
+00020f30: 2020 2020 2020 2020 2020 2020 2020 6677                fw
+00020f40: 6428 6c65 6e67 7468 2f32 2d61 6273 2863  d(length/2-abs(c
+00020f50: 6861 6d66 6572 3129 2c20 7872 6f74 2839  hamfer1), xrot(9
+00020f60: 302c 2070 6174 6833 6428 7072 6f66 696c  0, path3d(profil
+00020f70: 6531 2929 292c 0a20 2020 2020 2020 2020  e1))),.         
+00020f80: 2020 2020 2020 2062 6163 6b28 6c65 6e67         back(leng
+00020f90: 7468 2f32 2d61 6273 2863 6861 6d66 6572  th/2-abs(chamfer
+00020fa0: 3229 2c20 7872 6f74 2839 302c 2070 6174  2), xrot(90, pat
+00020fb0: 6833 6428 7072 6f66 696c 6532 2929 292c  h3d(profile2))),
+00020fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020fd0: 2069 6620 2863 6861 6d66 6572 3221 3d30   if (chamfer2!=0
+00020fe0: 2920 6261 636b 286c 656e 6774 682f 322c  ) back(length/2,
+00020ff0: 2078 726f 7428 3930 2c20 7061 7468 3364   xrot(90, path3d
+00021000: 2863 7072 6f66 3229 2929 2c0a 2020 2020  (cprof2))),.    
+00021010: 2020 2020 2020 2020 5d2c 0a20 2020 2020          ],.     
+00021020: 2020 2020 2020 2063 6170 733d 7472 7565         caps=true
+00021030: 2c20 636f 6c5f 7772 6170 3d74 7275 652c  , col_wrap=true,
+00021040: 2072 6576 6572 7365 3d74 7275 650a 2020   reverse=true.  
+00021050: 2020 2020 2020 290a 2020 2020 2920 7265        ).    ) re
+00021060: 6f72 6965 6e74 2861 6e63 686f 722c 7370  orient(anchor,sp
+00021070: 696e 2c6f 7269 656e 742c 2072 313d 7231  in,orient, r1=r1
+00021080: 2c20 7232 3d72 322c 206c 3d6c 2c20 6178  , r2=r2, l=l, ax
+00021090: 6973 3d42 4143 4b2c 2061 6e63 686f 7273  is=BACK, anchors
+000210a0: 3d61 6e63 686f 7273 2c20 703d 766e 6629  =anchors, p=vnf)
+000210b0: 3b0a 0a0a 2f2f 2046 756e 6374 696f 6e26  ;...// Function&
+000210c0: 4d6f 6475 6c65 3a20 6f6e 696f 6e28 290a  Module: onion().
+000210d0: 2f2f 2053 796e 6f70 7369 733a 2043 7265  // Synopsis: Cre
+000210e0: 6174 6573 2061 6e20 6174 7461 6368 6162  ates an attachab
+000210f0: 6c65 206f 6e69 6f6e 2d6c 696b 6520 7368  le onion-like sh
+00021100: 6170 652c 206f 7220 7265 7475 726e 7320  ape, or returns 
+00021110: 6120 766e 662e 0a2f 2f20 546f 7069 6373  a vnf..// Topics
+00021120: 3a20 5368 6170 6573 2028 3344 292c 2041  : Shapes (3D), A
+00021130: 7474 6163 6861 626c 652c 2056 4e46 2047  ttachable, VNF G
+00021140: 656e 6572 6174 6f72 732c 2046 444d 204f  enerators, FDM O
+00021150: 7074 696d 697a 6564 0a2f 2f20 5365 6520  ptimized.// See 
+00021160: 416c 736f 3a20 7465 6172 6472 6f70 2829  Also: teardrop()
+00021170: 2c20 7465 6172 6472 6f70 3264 2829 0a2f  , teardrop2d()./
+00021180: 2f20 4465 7363 7269 7074 696f 6e3a 0a2f  / Description:./
+00021190: 2f20 2020 4372 6561 7465 7320 6120 7370  /   Creates a sp
+000211a0: 6865 7265 2077 6974 6820 6120 636f 6e69  here with a coni
+000211b0: 6361 6c20 6861 742c 2074 6f20 6d61 6b65  cal hat, to make
+000211c0: 2061 2033 4420 7465 6172 6472 6f70 2e0a   a 3D teardrop..
+000211d0: 2f2f 0a2f 2f20 5573 6167 653a 2041 7320  //.// Usage: As 
+000211e0: 4d6f 6475 6c65 0a2f 2f20 2020 6f6e 696f  Module.//   onio
+000211f0: 6e28 727c 643d 2c20 5b61 6e67 3d5d 2c20  n(r|d=, [ang=], 
+00021200: 5b63 6170 5f68 3d5d 2c20 5b63 6972 6375  [cap_h=], [circu
+00021210: 6d3d 5d2c 205b 7265 616c 6967 6e3d 5d2c  m=], [realign=],
+00021220: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
+00021230: 5453 5d3b 0a2f 2f20 5573 6167 653a 2041  TS];.// Usage: A
+00021240: 7320 4675 6e63 7469 6f6e 0a2f 2f20 2020  s Function.//   
+00021250: 766e 6620 3d20 6f6e 696f 6e28 727c 643d  vnf = onion(r|d=
+00021260: 2c20 5b61 6e67 3d5d 2c20 5b63 6170 5f68  , [ang=], [cap_h
+00021270: 3d5d 2c20 5b63 6972 6375 6d3d 5d2c 205b  =], [circum=], [
+00021280: 7265 616c 6967 6e3d 5d2c 202e 2e2e 293b  realign=], ...);
+00021290: 0a2f 2f0a 2f2f 2041 7267 756d 656e 7473  .//.// Arguments
+000212a0: 3a0a 2f2f 2020 2072 203d 2072 6164 6975  :.//   r = radiu
+000212b0: 7320 6f66 2073 7068 6572 6963 616c 2070  s of spherical p
+000212c0: 6f72 7469 6f6e 206f 6620 7468 6520 626f  ortion of the bo
+000212d0: 7474 6f6d 2e20 4465 6661 756c 743a 2031  ttom. Default: 1
+000212e0: 0a2f 2f20 2020 616e 6720 3d20 416e 676c  .//   ang = Angl
+000212f0: 6520 6f66 2063 6f6e 6520 6f6e 2074 6f70  e of cone on top
+00021300: 2066 726f 6d20 7665 7274 6963 616c 2e20   from vertical. 
+00021310: 4465 6661 756c 743a 2034 3520 6465 6772  Default: 45 degr
+00021320: 6565 730a 2f2f 2020 2063 6170 5f68 203d  ees.//   cap_h =
+00021330: 2049 6620 6769 7665 6e2c 2068 6569 6768   If given, heigh
+00021340: 7420 6162 6f76 6520 7370 6865 7265 2063  t above sphere c
+00021350: 656e 7465 7220 746f 2074 7275 6e63 6174  enter to truncat
+00021360: 6520 7465 6172 6472 6f70 2073 6861 7065  e teardrop shape
+00021370: 2e20 2044 6566 6175 6c74 3a20 6075 6e64  .  Default: `und
+00021380: 6566 6020 286e 6f20 7472 756e 6361 7469  ef` (no truncati
+00021390: 6f6e 290a 2f2f 2020 202d 2d2d 0a2f 2f20  on).//   ---.// 
+000213a0: 2020 6369 7263 756d 203d 2073 6574 2074    circum = set t
+000213b0: 6f20 7472 7565 2074 6f20 6369 7263 756d  o true to circum
+000213c0: 7363 7269 6265 2074 6865 2073 7065 6369  scribe the speci
+000213d0: 6669 6564 2072 6164 6975 732f 6469 616d  fied radius/diam
+000213e0: 6574 6572 2e20 2044 6566 6175 6c74 3a20  eter.  Default: 
+000213f0: 4661 6c73 650a 2f2f 2020 2072 6561 6c69  False.//   reali
+00021400: 676e 203d 2061 646a 7573 7420 706f 696e  gn = adjust poin
+00021410: 7420 616c 6967 6e6d 656e 7420 746f 2064  t alignment to d
+00021420: 6574 6572 6d69 6e65 2069 6620 626f 7474  etermine if bott
+00021430: 6f6d 2069 7320 666c 6174 206f 7220 706f  om is flat or po
+00021440: 696e 7479 2e20 2044 6566 6175 6c74 3a20  inty.  Default: 
+00021450: 4661 6c73 650a 2f2f 2020 2064 203d 2064  False.//   d = d
+00021460: 6961 6d65 7465 7220 6f66 2073 7068 6572  iameter of spher
+00021470: 6963 616c 2070 6f72 7469 6f6e 206f 6620  ical portion of 
+00021480: 626f 7474 6f6d 2e0a 2f2f 2020 2061 6e63  bottom..//   anc
+00021490: 686f 7220 3d20 5472 616e 736c 6174 6520  hor = Translate 
+000214a0: 736f 2061 6e63 686f 7220 706f 696e 7420  so anchor point 
+000214b0: 6973 2061 7420 6f72 6967 696e 2028 302c  is at origin (0,
+000214c0: 302c 3029 2e20 2053 6565 205b 616e 6368  0,0).  See [anch
+000214d0: 6f72 5d28 6174 7461 6368 6d65 6e74 732e  or](attachments.
+000214e0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
+000214f0: 616e 6368 6f72 292e 2020 4465 6661 756c  anchor).  Defaul
+00021500: 743a 2060 4345 4e54 4552 600a 2f2f 2020  t: `CENTER`.//  
+00021510: 2073 7069 6e20 3d20 526f 7461 7465 2074   spin = Rotate t
+00021520: 6869 7320 6d61 6e79 2064 6567 7265 6573  his many degrees
+00021530: 2061 726f 756e 6420 7468 6520 5a20 6178   around the Z ax
+00021540: 6973 2061 6674 6572 2061 6e63 686f 722e  is after anchor.
+00021550: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
+00021560: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+00021570: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
+00021580: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
+00021590: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
+000215a0: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
+000215b0: 2074 6f77 6172 6473 2c20 6166 7465 7220   towards, after 
+000215c0: 7370 696e 2e20 2053 6565 205b 6f72 6965  spin.  See [orie
+000215d0: 6e74 5d28 6174 7461 6368 6d65 6e74 732e  nt](attachments.
+000215e0: 7363 6164 2373 7562 7365 6374 696f 6e2d  scad#subsection-
+000215f0: 6f72 6965 6e74 292e 2020 4465 6661 756c  orient).  Defaul
+00021600: 743a 2060 5550 600a 2f2f 0a2f 2f20 4578  t: `UP`.//.// Ex
+00021610: 7472 6120 416e 6368 6f72 733a 0a2f 2f20  tra Anchors:.// 
+00021620: 2020 6361 7020 3d20 5468 6520 6365 6e74    cap = The cent
+00021630: 6572 206f 6620 7468 6520 746f 7020 6f66  er of the top of
+00021640: 2074 6865 2063 6170 2c20 6f72 6965 6e74   the cap, orient
+00021650: 6564 2077 6974 6820 7468 6520 6361 7020  ed with the cap 
+00021660: 6661 6365 206e 6f72 6d61 6c2e 0a2f 2f20  face normal..// 
+00021670: 2020 7469 7020 3d20 5468 6520 706f 7369    tip = The posi
+00021680: 7469 6f6e 2077 6865 7265 2061 6e20 756e  tion where an un
+00021690: 2d63 6170 7065 6420 6f6e 696f 6e20 776f  -capped onion wo
+000216a0: 756c 6420 636f 6d65 2074 6f20 6120 706f  uld come to a po
+000216b0: 696e 742c 206f 7269 656e 7465 6420 696e  int, oriented in
+000216c0: 2074 6865 2064 6972 6563 7469 6f6e 2074   the direction t
+000216d0: 6865 2070 6f69 6e74 2069 7320 6672 6f6d  he point is from
+000216e0: 2074 6865 2063 656e 7465 722e 0a2f 2f0a   the center..//.
+000216f0: 2f2f 2045 7861 6d70 6c65 3a20 5479 7069  // Example: Typi
+00021700: 6361 6c20 5368 6170 650a 2f2f 2020 206f  cal Shape.//   o
+00021710: 6e69 6f6e 2872 3d33 302c 2061 6e67 3d33  nion(r=30, ang=3
+00021720: 3029 3b0a 2f2f 2045 7861 6d70 6c65 3a20  0);.// Example: 
+00021730: 4372 6f70 2043 6170 0a2f 2f20 2020 6f6e  Crop Cap.//   on
+00021740: 696f 6e28 723d 3330 2c20 616e 673d 3330  ion(r=30, ang=30
+00021750: 2c20 6361 705f 683d 3430 293b 0a2f 2f20  , cap_h=40);.// 
+00021760: 4578 616d 706c 653a 2043 6c6f 7365 2043  Example: Close C
+00021770: 726f 700a 2f2f 2020 206f 6e69 6f6e 2872  rop.//   onion(r
+00021780: 3d33 302c 2061 6e67 3d33 302c 2063 6170  =30, ang=30, cap
+00021790: 5f68 3d32 3029 3b0a 2f2f 2045 7861 6d70  _h=20);.// Examp
+000217a0: 6c65 3a20 4f6e 696f 6e73 2061 7265 2075  le: Onions are u
+000217b0: 7365 6675 6c20 666f 7220 6d61 6b69 6e67  seful for making
+000217c0: 2074 6865 2074 6f70 7320 6f66 206c 6172   the tops of lar
+000217d0: 6765 2063 796c 696e 6472 6963 616c 2076  ge cylindrical v
+000217e0: 6f69 6473 2e0a 2f2f 2020 2064 6966 6665  oids..//   diffe
+000217f0: 7265 6e63 6528 2920 7b0a 2f2f 2020 2020  rence() {.//    
+00021800: 2020 2063 7562 6f69 6428 5b31 3030 2c35     cuboid([100,5
+00021810: 302c 3130 305d 2c20 616e 6368 6f72 3d46  0,100], anchor=F
+00021820: 5744 2b42 4f54 293b 0a2f 2f20 2020 2020  WD+BOT);.//     
+00021830: 2020 646f 776e 2830 2e31 290a 2f2f 2020    down(0.1).//  
+00021840: 2020 2020 2020 2020 2063 796c 696e 6465           cylinde
+00021850: 7228 683d 3530 2c64 3d35 302c 616e 6368  r(h=50,d=50,anch
+00021860: 6f72 3d42 4f54 290a 2f2f 2020 2020 2020  or=BOT).//      
+00021870: 2020 2020 2020 2020 2061 7474 6163 6828           attach(
+00021880: 544f 5029 0a2f 2f20 2020 2020 2020 2020  TOP).//         
+00021890: 2020 2020 2020 2020 2020 6f6e 696f 6e28            onion(
+000218a0: 643d 3530 2c20 6361 705f 683d 3330 293b  d=50, cap_h=30);
+000218b0: 0a2f 2f20 2020 7d0a 2f2f 2045 7861 6d70  .//   }.// Examp
+000218c0: 6c65 3a20 5374 616e 6461 7264 2043 6f6e  le: Standard Con
+000218d0: 6e65 6374 6f72 730a 2f2f 2020 206f 6e69  nectors.//   oni
+000218e0: 6f6e 2864 3d33 302c 2061 6e67 3d33 302c  on(d=30, ang=30,
+000218f0: 2063 6170 5f68 3d32 3029 2073 686f 775f   cap_h=20) show_
+00021900: 616e 6368 6f72 7328 293b 0a0a 6d6f 6475  anchors();..modu
+00021910: 6c65 206f 6e69 6f6e 2872 2c20 616e 673d  le onion(r, ang=
+00021920: 3435 2c20 6361 705f 682c 2064 2c20 6369  45, cap_h, d, ci
+00021930: 7263 756d 3d66 616c 7365 2c20 7265 616c  rcum=false, real
+00021940: 6967 6e3d 6661 6c73 652c 2061 6e63 686f  ign=false, ancho
+00021950: 723d 4345 4e54 4552 2c20 7370 696e 3d30  r=CENTER, spin=0
+00021960: 2c20 6f72 6965 6e74 3d55 5029 0a7b 0a20  , orient=UP).{. 
+00021970: 2020 2072 203d 2067 6574 5f72 6164 6975     r = get_radiu
+00021980: 7328 723d 722c 2064 3d64 2c20 6466 6c74  s(r=r, d=d, dflt
+00021990: 3d31 293b 0a20 2020 2078 7970 726f 6669  =1);.    xyprofi
+000219a0: 6c65 203d 2074 6561 7264 726f 7032 6428  le = teardrop2d(
+000219b0: 723d 722c 2061 6e67 3d61 6e67 2c20 6361  r=r, ang=ang, ca
+000219c0: 705f 683d 6361 705f 682c 2063 6972 6375  p_h=cap_h, circu
+000219d0: 6d3d 6369 7263 756d 2c20 7265 616c 6967  m=circum, realig
+000219e0: 6e3d 7265 616c 6967 6e29 3b0a 2020 2020  n=realign);.    
+000219f0: 7469 705f 6820 3d20 6d61 7828 636f 6c75  tip_h = max(colu
+00021a00: 6d6e 2878 7970 726f 6669 6c65 2c31 2929  mn(xyprofile,1))
+00021a10: 3b0a 2020 2020 5f63 6170 5f68 203d 206d  ;.    _cap_h = m
+00021a20: 696e 2864 6566 6175 6c74 2863 6170 5f68  in(default(cap_h
+00021a30: 2c74 6970 5f68 292c 2074 6970 5f68 293b  ,tip_h), tip_h);
+00021a40: 0a20 2020 2061 6e63 686f 7273 203d 205b  .    anchors = [
+00021a50: 0a20 2020 2020 2020 205b 2263 6170 222c  .        ["cap",
+00021a60: 205b 302c 302c 5f63 6170 5f68 5d2c 2055   [0,0,_cap_h], U
+00021a70: 502c 2030 5d2c 0a20 2020 2020 2020 205b  P, 0],.        [
+00021a80: 2274 6970 222c 205b 302c 302c 7469 705f  "tip", [0,0,tip_
+00021a90: 685d 2c20 5550 2c20 305d 0a20 2020 205d  h], UP, 0].    ]
+00021aa0: 3b0a 2020 2020 6174 7461 6368 6162 6c65  ;.    attachable
+00021ab0: 2861 6e63 686f 722c 7370 696e 2c6f 7269  (anchor,spin,ori
+00021ac0: 656e 742c 2072 3d72 2c20 616e 6368 6f72  ent, r=r, anchor
+00021ad0: 733d 616e 6368 6f72 7329 207b 0a20 2020  s=anchors) {.   
+00021ae0: 2020 2020 2072 6f74 6174 655f 6578 7472       rotate_extr
+00021af0: 7564 6528 636f 6e76 6578 6974 793d 3229  ude(convexity=2)
+00021b00: 207b 0a20 2020 2020 2020 2020 2020 2064   {.            d
+00021b10: 6966 6665 7265 6e63 6528 2920 7b0a 2020  ifference() {.  
+00021b20: 2020 2020 2020 2020 2020 2020 2020 706f                po
+00021b30: 6c79 676f 6e28 7879 7072 6f66 696c 6529  lygon(xyprofile)
+00021b40: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00021b50: 2020 7371 7561 7265 285b 322a 722c 322a    square([2*r,2*
+00021b60: 6d61 7828 5f63 6170 5f68 2c72 292b 315d  max(_cap_h,r)+1]
+00021b70: 2c20 616e 6368 6f72 3d52 4947 4854 293b  , anchor=RIGHT);
+00021b80: 0a20 2020 2020 2020 2020 2020 207d 0a20  .            }. 
+00021b90: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00021ba0: 2063 6869 6c64 7265 6e28 293b 0a20 2020   children();.   
+00021bb0: 207d 0a7d 0a0a 0a66 756e 6374 696f 6e20   }.}...function 
+00021bc0: 6f6e 696f 6e28 722c 2061 6e67 3d34 352c  onion(r, ang=45,
+00021bd0: 2063 6170 5f68 2c20 642c 2061 6e63 686f   cap_h, d, ancho
+00021be0: 723d 4345 4e54 4552 2c20 7370 696e 3d30  r=CENTER, spin=0
+00021bf0: 2c20 6f72 6965 6e74 3d55 5029 203d 0a20  , orient=UP) =. 
+00021c00: 2020 206c 6574 280a 2020 2020 2020 2020     let(.        
+00021c10: 7220 3d20 6765 745f 7261 6469 7573 2872  r = get_radius(r
+00021c20: 3d72 2c20 643d 642c 2064 666c 743d 3129  =r, d=d, dflt=1)
+00021c30: 2c0a 2020 2020 2020 2020 7879 7072 6f66  ,.        xyprof
+00021c40: 696c 6520 3d20 7269 6768 745f 6861 6c66  ile = right_half
+00021c50: 2870 3d74 6561 7264 726f 7032 6428 723d  (p=teardrop2d(r=
+00021c60: 722c 2061 6e67 3d61 6e67 2c20 6361 705f  r, ang=ang, cap_
+00021c70: 683d 6361 705f 6829 295b 305d 2c0a 2020  h=cap_h))[0],.  
+00021c80: 2020 2020 2020 7072 6f66 696c 6520 3d20        profile = 
+00021c90: 7872 6f74 2839 302c 2070 3d70 6174 6833  xrot(90, p=path3
+00021ca0: 6428 7879 7072 6f66 696c 6529 292c 0a20  d(xyprofile)),. 
+00021cb0: 2020 2020 2020 2074 6970 5f68 203d 206d         tip_h = m
+00021cc0: 6178 2863 6f6c 756d 6e28 7879 7072 6f66  ax(column(xyprof
+00021cd0: 696c 652c 3129 292c 0a20 2020 2020 2020  ile,1)),.       
+00021ce0: 205f 6361 705f 6820 3d20 6d69 6e28 6465   _cap_h = min(de
+00021cf0: 6661 756c 7428 6361 705f 682c 7469 705f  fault(cap_h,tip_
+00021d00: 6829 2c20 7469 705f 6829 2c0a 2020 2020  h), tip_h),.    
+00021d10: 2020 2020 616e 6368 6f72 7320 3d20 5b0a      anchors = [.
+00021d20: 2020 2020 2020 2020 2020 2020 5b22 6361              ["ca
+00021d30: 7022 2c20 5b30 2c30 2c5f 6361 705f 685d  p", [0,0,_cap_h]
+00021d40: 2c20 5550 2c20 305d 2c0a 2020 2020 2020  , UP, 0],.      
+00021d50: 2020 2020 2020 5b22 7469 7022 2c20 5b30        ["tip", [0
+00021d60: 2c30 2c74 6970 5f68 5d2c 2055 502c 2030  ,0,tip_h], UP, 0
+00021d70: 5d0a 2020 2020 2020 2020 5d2c 0a20 2020  ].        ],.   
+00021d80: 2020 2020 2073 6964 6573 203d 2073 6567       sides = seg
+00021d90: 7328 7229 2c0a 2020 2020 2020 2020 7374  s(r),.        st
+00021da0: 6570 203d 2033 3630 202f 2073 6964 6573  ep = 360 / sides
+00021db0: 2c0a 2020 2020 2020 2020 766e 6620 3d20  ,.        vnf = 
+00021dc0: 766e 665f 7665 7274 6578 5f61 7272 6179  vnf_vertex_array
+00021dd0: 280a 2020 2020 2020 2020 2020 2020 706f  (.            po
+00021de0: 696e 7473 3d5b 666f 7220 2861 203d 205b  ints=[for (a = [
+00021df0: 303a 7374 6570 3a33 3630 2d45 5053 494c  0:step:360-EPSIL
+00021e00: 4f4e 5d29 207a 726f 7428 612c 2070 3d70  ON]) zrot(a, p=p
+00021e10: 726f 6669 6c65 295d 2c0a 2020 2020 2020  rofile)],.      
+00021e20: 2020 2020 2020 6361 7073 3d66 616c 7365        caps=false
+00021e30: 2c20 636f 6c5f 7772 6170 3d74 7275 652c  , col_wrap=true,
+00021e40: 2072 6f77 5f77 7261 703d 7472 7565 2c20   row_wrap=true, 
+00021e50: 7265 7665 7273 653d 7472 7565 0a20 2020  reverse=true.   
+00021e60: 2020 2020 2029 0a20 2020 2029 2072 656f       ).    ) reo
+00021e70: 7269 656e 7428 616e 6368 6f72 2c73 7069  rient(anchor,spi
+00021e80: 6e2c 6f72 6965 6e74 2c20 723d 722c 2061  n,orient, r=r, a
+00021e90: 6e63 686f 7273 3d61 6e63 686f 7273 2c20  nchors=anchors, 
+00021ea0: 703d 766e 6629 3b0a 0a0a 2f2f 2053 6563  p=vnf);...// Sec
+00021eb0: 7469 6f6e 3a20 5465 7874 0a0a 2f2f 204d  tion: Text..// M
+00021ec0: 6f64 756c 653a 2074 6578 7433 6428 290a  odule: text3d().
+00021ed0: 2f2f 2053 796e 6f70 7369 733a 2043 7265  // Synopsis: Cre
+00021ee0: 6174 6573 2061 6e20 6174 7461 6368 6162  ates an attachab
+00021ef0: 6c65 2033 6420 7465 7874 2062 6c6f 636b  le 3d text block
+00021f00: 2e0a 2f2f 2054 6f70 6963 733a 2041 7474  ..// Topics: Att
+00021f10: 6163 686d 656e 7473 2c20 5465 7874 0a2f  achments, Text./
+00021f20: 2f20 5365 6520 416c 736f 3a20 7061 7468  / See Also: path
+00021f30: 5f74 6578 7428 292c 2074 6578 7428 2920  _text(), text() 
+00021f40: 0a2f 2f20 5573 6167 653a 0a2f 2f20 2020  .// Usage:.//   
+00021f50: 7465 7874 3364 2874 6578 742c 205b 685d  text3d(text, [h]
+00021f60: 2c20 5b73 697a 655d 2c20 5b66 6f6e 745d  , [size], [font]
+00021f70: 2c20 5b6c 616e 6775 6167 653d 5d2c 205b  , [language=], [
+00021f80: 7363 7269 7074 3d5d 2c20 5b64 6972 6563  script=], [direc
+00021f90: 7469 6f6e 3d5d 2c20 5b61 7479 7065 3d5d  tion=], [atype=]
+00021fa0: 2c20 5b61 6e63 686f 723d 5d2c 205b 7370  , [anchor=], [sp
+00021fb0: 696e 3d5d 2c20 5b6f 7269 656e 743d 5d29  in=], [orient=])
+00021fc0: 3b0a 2f2f 2044 6573 6372 6970 7469 6f6e  ;.// Description
+00021fd0: 3a0a 2f2f 2020 2043 7265 6174 6573 2061  :.//   Creates a
+00021fe0: 2033 4420 7465 7874 2062 6c6f 636b 2074   3D text block t
+00021ff0: 6861 7420 7375 7070 6f72 7473 2061 6e63  hat supports anc
+00022000: 686f 7269 6e67 2061 6e64 2061 7474 6163  horing and attac
+00022010: 686d 656e 7420 746f 2061 7474 6163 6861  hment to attacha
+00022020: 626c 6520 6f62 6a65 6374 732e 2020 596f  ble objects.  Yo
+00022030: 7520 6361 6e6e 6f74 2061 7474 6163 6820  u cannot attach 
+00022040: 6368 696c 6472 656e 2074 6f20 7465 7874  children to text
+00022050: 2e0a 2f2f 2020 202e 0a2f 2f20 2020 4869  ..//   ..//   Hi
+00022060: 7374 6f72 6963 616c 6c79 2066 6f6e 7473  storically fonts
+00022070: 2077 6572 6520 7370 6563 6966 6965 6420   were specified 
+00022080: 6279 2074 6865 6972 2022 626f 6479 2073  by their "body s
+00022090: 697a 6522 2c20 7468 6520 6865 6967 6874  ize", the height
+000220a0: 206f 6620 7468 6520 6d65 7461 6c20 626f   of the metal bo
+000220b0: 6479 0a2f 2f20 2020 6f6e 2077 6869 6368  dy.//   on which
+000220c0: 2074 6865 2067 6c79 7068 7320 7765 7265   the glyphs were
+000220d0: 2063 6173 742e 2020 5468 6973 206d 6561   cast.  This mea
+000220e0: 6e73 2074 6865 2073 697a 6520 7761 7320  ns the size was 
+000220f0: 616e 2075 7070 6572 2062 6f75 6e64 206f  an upper bound o
+00022100: 6e20 7468 6520 7369 7a65 0a2f 2f20 2020  n the size.//   
+00022110: 6f66 2074 6865 2066 6f6e 7420 676c 7970  of the font glyp
+00022120: 6873 2c20 6e6f 7420 6120 6469 7265 6374  hs, not a direct
+00022130: 206d 6561 7375 7265 6d65 6e74 206f 6620   measurement of 
+00022140: 7468 6569 7220 7369 7a65 2e20 2049 6e20  their size.  In 
+00022150: 6469 6769 7461 6c20 7479 7065 7365 7474  digital typesett
+00022160: 696e 672c 0a2f 2f20 2020 7468 6520 6d65  ing,.//   the me
+00022170: 7461 6c20 626f 6479 2069 7320 7265 706c  tal body is repl
+00022180: 6163 6564 2062 7920 616e 2069 6e76 6973  aced by an invis
+00022190: 6962 6c65 2062 6f78 2c20 7468 6520 656d  ible box, the em
+000221a0: 2073 7175 6172 652c 2077 686f 7365 2073   square, whose s
+000221b0: 6964 6520 6c65 6e67 7468 2069 730a 2f2f  ide length is.//
+000221c0: 2020 2064 6566 696e 6564 2074 6f20 6265     defined to be
+000221d0: 2074 6865 2066 6f6e 7427 7320 7369 7a65   the font's size
+000221e0: 2e20 2054 6865 2067 6c79 7068 7320 6361  .  The glyphs ca
+000221f0: 6e20 6265 2063 6f6e 7461 696e 6564 2069  n be contained i
+00022200: 6e20 7468 6174 2073 7175 6172 652c 206f  n that square, o
+00022210: 7220 7468 6579 0a2f 2f20 2020 6361 6e20  r they.//   can 
+00022220: 6578 7465 6e64 2062 6579 6f6e 6420 6974  extend beyond it
+00022230: 2c20 6465 7065 6e64 696e 6720 6f6e 2074  , depending on t
+00022240: 6865 2063 686f 6963 6573 206d 6164 6520  he choices made 
+00022250: 6279 2074 6865 2066 6f6e 7420 6465 7369  by the font desi
+00022260: 676e 6572 2e20 2041 7320 610a 2f2f 2020  gner.  As a.//  
+00022270: 2072 6573 756c 742c 2074 6865 206d 6561   result, the mea
+00022280: 6e69 6e67 206f 6620 666f 6e74 2073 697a  ning of font siz
+00022290: 6520 7661 7269 6573 2062 6574 7765 656e  e varies between
+000222a0: 2066 6f6e 7473 3a20 7477 6f20 666f 6e74   fonts: two font
+000222b0: 7320 6174 2074 6865 2022 7361 6d65 2220  s at the "same" 
+000222c0: 7369 7a65 0a2f 2f20 2020 6361 6e20 6469  size.//   can di
+000222d0: 6666 6572 2073 6967 6e69 6669 6361 6e74  ffer significant
+000222e0: 6c79 2069 6e20 7468 6520 6163 7475 616c  ly in the actual
+000222f0: 2073 697a 6520 6f66 2074 6865 6972 2063   size of their c
+00022300: 6861 7261 6374 6572 732e 2020 5479 706f  haracters.  Typo
+00022310: 6772 6170 6865 7273 0a2f 2f20 2020 6375  graphers.//   cu
+00022320: 7374 6f6d 6172 696c 7920 7370 6563 6966  stomarily specif
+00022330: 7920 7468 6520 7369 7a65 2069 6e20 7468  y the size in th
+00022340: 6520 756e 6974 7320 6f66 2022 706f 696e  e units of "poin
+00022350: 7473 222e 2020 4120 706f 696e 7420 6973  ts".  A point is
+00022360: 2031 2f37 3220 696e 6368 2e20 2049 6e0a   1/72 inch.  In.
+00022370: 2f2f 2020 204f 7065 6e53 4341 442c 2079  //   OpenSCAD, y
+00022380: 6f75 2073 7065 6369 6679 2074 6865 2073  ou specify the s
+00022390: 697a 6520 696e 204f 7065 6e53 4341 4420  ize in OpenSCAD 
+000223a0: 756e 6974 7320 286f 6674 656e 2074 7265  units (often tre
+000223b0: 6174 6564 2061 7320 6d69 6c6c 696d 6574  ated as millimet
+000223c0: 6572 7320 666f 7220 3364 0a2f 2f20 2020  ers for 3d.//   
+000223d0: 7072 696e 7469 6e67 292c 2073 6f20 6966  printing), so if
+000223e0: 2079 6f75 2077 616e 7420 706f 696e 7473   you want points
+000223f0: 2079 6f75 2077 696c 6c20 6e65 6564 2074   you will need t
+00022400: 6f20 7065 7266 6f72 6d20 6120 7375 6974  o perform a suit
+00022410: 6162 6c65 2075 6e69 7420 636f 6e76 6572  able unit conver
+00022420: 7369 6f6e 2e0a 2f2f 2020 2049 6e20 6164  sion..//   In ad
+00022430: 6469 7469 6f6e 2c20 7468 6520 4f70 656e  dition, the Open
+00022440: 5343 4144 2066 6f6e 7420 7379 7374 656d  SCAD font system
+00022450: 2068 6173 2061 2062 7567 3a20 6966 2079   has a bug: if y
+00022460: 6f75 2073 7065 6369 6679 2073 697a 653d  ou specify size=
+00022470: 7320 796f 7520 7769 6c6c 0a2f 2f20 2020  s you will.//   
+00022480: 696e 7374 6561 6420 6765 7420 6120 666f  instead get a fo
+00022490: 6e74 2077 686f 7365 2073 697a 6520 6973  nt whose size is
+000224a0: 2073 2f30 2e37 322e 2020 466f 7220 6d61   s/0.72.  For ma
+000224b0: 6e79 2066 6f6e 7473 2074 6869 7320 6d65  ny fonts this me
+000224c0: 616e 7320 7468 6520 7369 7a65 206f 660a  ans the size of.
+000224d0: 2f2f 2020 2063 6170 6974 616c 206c 6574  //   capital let
+000224e0: 7465 7273 2077 696c 6c20 6265 2061 7070  ters will be app
+000224f0: 726f 7869 6d61 7465 6c79 2065 7175 616c  roximately equal
+00022500: 2074 6f20 732c 2062 6563 6175 7365 2069   to s, because i
+00022510: 7420 6973 2063 6f6d 6d6f 6e20 666f 7220  t is common for 
+00022520: 666f 6e74 7320 746f 0a2f 2f20 2020 7573  fonts to.//   us
+00022530: 6520 6162 6f75 7420 3730 2520 6f66 2074  e about 70% of t
+00022540: 6865 6972 2068 6569 6768 7420 666f 7220  heir height for 
+00022550: 7468 6520 6173 6365 6e64 6572 7320 696e  the ascenders in
+00022560: 2074 6865 2066 6f6e 742e 2020 546f 2067   the font.  To g
+00022570: 6574 2074 6865 2063 7573 746f 6d61 7279  et the customary
+00022580: 0a2f 2f20 2020 666f 6e74 2073 697a 652c  .//   font size,
+00022590: 2079 6f75 2073 686f 756c 6420 6d75 6c74   you should mult
+000225a0: 6970 6c79 2079 6f75 7220 6465 7369 7265  iply your desire
+000225b0: 6420 7369 7a65 2062 7920 302e 3732 2e0a  d size by 0.72..
+000225c0: 2f2f 2020 202e 0a2f 2f20 2020 546f 2066  //   ..//   To f
+000225d0: 696e 6420 7468 6520 666f 6e74 7320 7468  ind the fonts th
+000225e0: 6174 2079 6f75 2068 6176 6520 6176 6169  at you have avai
+000225f0: 6c61 626c 6520 696e 2079 6f75 7220 4f70  lable in your Op
+00022600: 656e 5343 4144 2069 6e73 7461 6c6c 6174  enSCAD installat
+00022610: 696f 6e2c 0a2f 2f20 2020 676f 2074 6f20  ion,.//   go to 
+00022620: 7468 6520 4865 6c70 206d 656e 7520 616e  the Help menu an
+00022630: 6420 7365 6c65 6374 2022 466f 6e74 204c  d select "Font L
+00022640: 6973 7422 2e0a 2f2f 2041 7267 756d 656e  ist"..// Argumen
+00022650: 7473 3a0a 2f2f 2020 2074 6578 7420 3d20  ts:.//   text = 
+00022660: 5465 7874 2074 6f20 6372 6561 7465 2e0a  Text to create..
+00022670: 2f2f 2020 2068 202f 2068 6569 6768 7420  //   h / height 
+00022680: 2f20 7468 6963 6b6e 6573 7320 3d20 4578  / thickness = Ex
+00022690: 7472 7573 696f 6e20 6865 6967 6874 2066  trusion height f
+000226a0: 6f72 2074 6865 2074 6578 742e 2020 4465  or the text.  De
+000226b0: 6661 756c 743a 2031 0a2f 2f20 2020 7369  fault: 1.//   si
+000226c0: 7a65 203d 2054 6865 2066 6f6e 7420 7769  ze = The font wi
+000226d0: 6c6c 2062 6520 6372 6561 7465 6420 6174  ll be created at
+000226e0: 2074 6869 7320 7369 7a65 2064 6976 6964   this size divid
+000226f0: 6564 2062 7920 302e 3732 2e20 2020 4465  ed by 0.72.   De
+00022700: 6661 756c 743a 2031 300a 2f2f 2020 2066  fault: 10.//   f
+00022710: 6f6e 7420 3d20 466f 6e74 2074 6f20 7573  ont = Font to us
+00022720: 652e 2020 4465 6661 756c 743a 2022 4c69  e.  Default: "Li
+00022730: 6265 7261 7469 6f6e 2053 616e 7322 2028  beration Sans" (
+00022740: 7374 616e 6461 7264 204f 7065 6e53 4341  standard OpenSCA
+00022750: 4420 6465 6661 756c 7429 0a2f 2f20 2020  D default).//   
+00022760: 2d2d 2d0a 2f2f 2020 2073 7061 6369 6e67  ---.//   spacing
+00022770: 203d 2054 6865 2072 656c 6174 6976 6520   = The relative 
+00022780: 7370 6163 696e 6720 6d75 6c74 6970 6c69  spacing multipli
+00022790: 6572 2062 6574 7765 656e 2063 6861 7261  er between chara
+000227a0: 6374 6572 732e 2020 4465 6661 756c 743a  cters.  Default:
+000227b0: 2060 312e 3060 0a2f 2f20 2020 6469 7265   `1.0`.//   dire
+000227c0: 6374 696f 6e20 3d20 5468 6520 7465 7874  ction = The text
+000227d0: 2064 6972 6563 7469 6f6e 2e20 2060 226c   direction.  `"l
+000227e0: 7472 2260 2066 6f72 206c 6566 7420 746f  tr"` for left to
+000227f0: 2072 6967 6874 2e20 2060 2272 746c 2260   right.  `"rtl"`
+00022800: 2066 6f72 2072 6967 6874 2074 6f20 6c65   for right to le
+00022810: 6674 2e20 6022 7474 6222 6020 666f 7220  ft. `"ttb"` for 
+00022820: 746f 7020 746f 2062 6f74 746f 6d2e 2060  top to bottom. `
+00022830: 2262 7474 2260 2066 6f72 2062 6f74 746f  "btt"` for botto
+00022840: 6d20 746f 2074 6f70 2e20 2044 6566 6175  m to top.  Defau
+00022850: 6c74 3a20 6022 6c74 7222 600a 2f2f 2020  lt: `"ltr"`.//  
+00022860: 206c 616e 6775 6167 6520 3d20 5468 6520   language = The 
+00022870: 6c61 6e67 7561 6765 2074 6865 2074 6578  language the tex
+00022880: 7420 6973 2069 6e2e 2020 4465 6661 756c  t is in.  Defaul
+00022890: 743a 2060 2265 6e22 600a 2f2f 2020 2073  t: `"en"`.//   s
+000228a0: 6372 6970 7420 3d20 5468 6520 7363 7269  cript = The scri
+000228b0: 7074 2074 6865 2074 6578 7420 6973 2069  pt the text is i
+000228c0: 6e2e 2020 4465 6661 756c 743a 2060 226c  n.  Default: `"l
+000228d0: 6174 696e 2260 0a2f 2f20 2020 6174 7970  atin"`.//   atyp
+000228e0: 6520 3d20 4368 616e 6765 2076 6572 7469  e = Change verti
+000228f0: 6361 6c20 6365 6e74 6572 2062 6574 7765  cal center betwe
+00022900: 656e 2022 6261 7365 6c69 6e65 2220 616e  en "baseline" an
+00022910: 6420 2263 656e 7465 7222 2e20 2044 6566  d "center".  Def
+00022920: 6175 6c74 3a20 2262 6173 656c 696e 6522  ault: "baseline"
+00022930: 0a2f 2f20 2020 616e 6368 6f72 203d 2054  .//   anchor = T
+00022940: 7261 6e73 6c61 7465 2073 6f20 616e 6368  ranslate so anch
+00022950: 6f72 2070 6f69 6e74 2069 7320 6174 206f  or point is at o
+00022960: 7269 6769 6e20 2830 2c30 2c30 292e 2020  rigin (0,0,0).  
+00022970: 5365 6520 5b61 6e63 686f 725d 2861 7474  See [anchor](att
+00022980: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+00022990: 6273 6563 7469 6f6e 2d61 6e63 686f 7229  bsection-anchor)
+000229a0: 2e20 2044 6566 6175 6c74 3a20 6022 6261  .  Default: `"ba
+000229b0: 7365 6c69 6e65 2260 0a2f 2f20 2020 6365  seline"`.//   ce
+000229c0: 6e74 6572 203d 2043 656e 7465 7220 7468  nter = Center th
+000229d0: 6520 7465 7874 2e20 2045 7175 6976 616c  e text.  Equival
+000229e0: 656e 7420 746f 2060 6174 7970 653d 2263  ent to `atype="c
+000229f0: 656e 7465 7222 2c20 616e 6368 6f72 3d43  enter", anchor=C
+00022a00: 454e 5445 5260 2e20 2044 6566 6175 6c74  ENTER`.  Default
+00022a10: 3a20 6661 6c73 650a 2f2f 2020 2073 7069  : false.//   spi
+00022a20: 6e20 3d20 526f 7461 7465 2074 6869 7320  n = Rotate this 
+00022a30: 6d61 6e79 2064 6567 7265 6573 2061 726f  many degrees aro
+00022a40: 756e 6420 7468 6520 5a20 6178 6973 2e20  und the Z axis. 
+00022a50: 2053 6565 205b 7370 696e 5d28 6174 7461   See [spin](atta
+00022a60: 6368 6d65 6e74 732e 7363 6164 2373 7562  chments.scad#sub
+00022a70: 7365 6374 696f 6e2d 7370 696e 292e 2020  section-spin).  
+00022a80: 4465 6661 756c 743a 2060 3060 0a2f 2f20  Default: `0`.// 
+00022a90: 2020 6f72 6965 6e74 203d 2056 6563 746f    orient = Vecto
+00022aa0: 7220 746f 2072 6f74 6174 6520 746f 7020  r to rotate top 
+00022ab0: 746f 7761 7264 732e 2020 5365 6520 5b6f  towards.  See [o
+00022ac0: 7269 656e 745d 2861 7474 6163 686d 656e  rient](attachmen
+00022ad0: 7473 2e73 6361 6423 7375 6273 6563 7469  ts.scad#subsecti
+00022ae0: 6f6e 2d6f 7269 656e 7429 2e20 2044 6566  on-orient).  Def
+00022af0: 6175 6c74 3a20 6055 5060 0a2f 2f20 416e  ault: `UP`.// An
+00022b00: 6368 6f72 2054 7970 6573 3a0a 2f2f 2020  chor Types:.//  
+00022b10: 2062 6173 656c 696e 6520 3d20 416e 6368   baseline = Anch
+00022b20: 6f72 2063 656e 7465 7220 6973 2072 656c  or center is rel
+00022b30: 6174 6976 6520 746f 2074 6578 7420 6261  ative to text ba
+00022b40: 7365 6c69 6e65 0a2f 2f20 2020 7963 656e  seline.//   ycen
+00022b50: 7465 7220 3d20 416e 6368 6f72 2063 656e  ter = Anchor cen
+00022b60: 7465 7220 6973 2072 656c 6174 6976 6520  ter is relative 
+00022b70: 746f 2074 6865 2061 6374 7561 6c79 2079  to the actualy y
+00022b80: 2064 6972 6563 7469 6f6e 2063 656e 7465   direction cente
+00022b90: 7220 6f66 2074 6865 2074 6578 740a 2f2f  r of the text.//
+00022ba0: 2045 7861 6d70 6c65 733a 0a2f 2f20 2020   Examples:.//   
+00022bb0: 7465 7874 3364 2822 466f 676d 6f62 6172  text3d("Fogmobar
+00022bc0: 222c 2068 3d33 2c20 7369 7a65 3d31 3029  ", h=3, size=10)
+00022bd0: 3b0a 2f2f 2020 2074 6578 7433 6428 2246  ;.//   text3d("F
+00022be0: 6f67 6d6f 6261 7222 2c20 683d 322c 2073  ogmobar", h=2, s
+00022bf0: 697a 653d 3132 2c20 666f 6e74 3d22 4865  ize=12, font="He
+00022c00: 6c76 6574 6963 6122 293b 0a2f 2f20 2020  lvetica");.//   
+00022c10: 7465 7874 3364 2822 466f 676d 6f62 6172  text3d("Fogmobar
+00022c20: 222c 2068 3d32 2c20 616e 6368 6f72 3d43  ", h=2, anchor=C
+00022c30: 454e 5445 5229 3b0a 2f2f 2020 2074 6578  ENTER);.//   tex
+00022c40: 7433 6428 2246 6f67 6d6f 6261 7222 2c20  t3d("Fogmobar", 
+00022c50: 683d 322c 2061 6e63 686f 723d 4345 4e54  h=2, anchor=CENT
+00022c60: 4552 2c20 6174 7970 653d 2279 6365 6e74  ER, atype="ycent
+00022c70: 6572 2229 3b0a 2f2f 2020 2074 6578 7433  er");.//   text3
+00022c80: 6428 2246 6f67 6d6f 6261 7222 2c20 683d  d("Fogmobar", h=
+00022c90: 322c 2061 6e63 686f 723d 5249 4748 5429  2, anchor=RIGHT)
+00022ca0: 3b0a 2f2f 2020 2074 6578 7433 6428 2246  ;.//   text3d("F
+00022cb0: 6f67 6d6f 6261 7222 2c20 683d 322c 2061  ogmobar", h=2, a
+00022cc0: 6e63 686f 723d 5249 4748 542b 424f 542c  nchor=RIGHT+BOT,
+00022cd0: 2061 7479 7065 3d22 7963 656e 7465 7222   atype="ycenter"
+00022ce0: 293b 0a6d 6f64 756c 6520 7465 7874 3364  );.module text3d
+00022cf0: 2874 6578 742c 2068 2c20 7369 7a65 3d31  (text, h, size=1
+00022d00: 302c 2066 6f6e 743d 2248 656c 7665 7469  0, font="Helveti
+00022d10: 6361 222c 2073 7061 6369 6e67 3d31 2e30  ca", spacing=1.0
+00022d20: 2c20 6469 7265 6374 696f 6e3d 226c 7472  , direction="ltr
+00022d30: 222c 206c 616e 6775 6167 653d 2265 6d22  ", language="em"
+00022d40: 2c20 7363 7269 7074 3d22 6c61 7469 6e22  , script="latin"
+00022d50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00022d60: 6865 6967 6874 2c20 7468 6963 6b6e 6573  height, thicknes
+00022d70: 732c 2061 7479 7065 2c20 6365 6e74 6572  s, atype, center
+00022d80: 3d66 616c 7365 2c0a 2020 2020 2020 2020  =false,.        
+00022d90: 2020 2020 2020 616e 6368 6f72 2c20 7370        anchor, sp
+00022da0: 696e 3d30 2c20 6f72 6965 6e74 3d55 5029  in=0, orient=UP)
+00022db0: 207b 0a20 2020 206e 6f5f 6368 696c 6472   {.    no_childr
+00022dc0: 656e 2824 6368 696c 6472 656e 293b 0a20  en($children);. 
+00022dd0: 2020 2068 203d 206f 6e65 5f64 6566 696e     h = one_defin
+00022de0: 6564 285b 682c 6865 6967 6874 2c74 6869  ed([h,height,thi
+00022df0: 636b 6e65 7373 5d2c 2268 2c68 6569 6768  ckness],"h,heigh
+00022e00: 742c 7468 6963 6b6e 6573 7322 2c64 666c  t,thickness",dfl
+00022e10: 743d 3129 3b0a 2020 2020 6173 7365 7274  t=1);.    assert
+00022e20: 2869 735f 756e 6465 6628 6174 7970 6529  (is_undef(atype)
+00022e30: 207c 7c20 696e 5f6c 6973 7428 6174 7970   || in_list(atyp
+00022e40: 652c 5b22 7963 656e 7465 7222 2c22 6261  e,["ycenter","ba
+00022e50: 7365 6c69 6e65 225d 292c 2022 6174 7970  seline"]), "atyp
+00022e60: 6520 6d75 7374 2062 6520 5c22 6365 6e74  e must be \"cent
+00022e70: 6572 5c22 206f 7220 5c22 6261 7365 6c69  er\" or \"baseli
+00022e80: 6e65 5c22 2229 3b0a 2020 2020 6173 7365  ne\"");.    asse
+00022e90: 7274 2869 735f 626f 6f6c 2863 656e 7465  rt(is_bool(cente
+00022ea0: 7229 293b 0a20 2020 2061 7479 7065 203d  r));.    atype =
+00022eb0: 2064 6566 6175 6c74 2861 7479 7065 2c20   default(atype, 
+00022ec0: 6365 6e74 6572 3f22 7963 656e 7465 7222  center?"ycenter"
+00022ed0: 3a22 6261 7365 6c69 6e65 2229 3b0a 2020  :"baseline");.  
+00022ee0: 2020 616e 6368 6f72 203d 2064 6566 6175    anchor = defau
+00022ef0: 6c74 2861 6e63 686f 722c 2063 656e 7465  lt(anchor, cente
+00022f00: 723f 4345 4e54 4552 3a4c 4546 5429 3b0a  r?CENTER:LEFT);.
+00022f10: 2020 2020 6765 6f6d 203d 2061 7474 6163      geom = attac
+00022f20: 685f 6765 6f6d 2873 697a 653d 5b73 697a  h_geom(size=[siz
+00022f30: 652c 7369 7a65 2c68 5d29 3b0a 2020 2020  e,size,h]);.    
+00022f40: 6861 203d 2061 6e63 686f 722e 783c 303f  ha = anchor.x<0?
+00022f50: 2022 6c65 6674 2220 0a20 2020 2020 2020   "left" .       
+00022f60: 3a20 616e 6368 6f72 2e78 3e30 3f20 2272  : anchor.x>0? "r
+00022f70: 6967 6874 2220 0a20 2020 2020 2020 3a20  ight" .       : 
+00022f80: 2263 656e 7465 7222 3b0a 2020 2020 7661  "center";.    va
+00022f90: 203d 2061 6e63 686f 722e 793c 303f 2022   = anchor.y<0? "
+00022fa0: 626f 7474 6f6d 2220 0a20 2020 2020 2020  bottom" .       
+00022fb0: 3a20 616e 6368 6f72 2e79 3e30 3f20 2274  : anchor.y>0? "t
+00022fc0: 6f70 2220 0a20 2020 2020 2020 3a20 6174  op" .       : at
+00022fd0: 7970 653d 3d22 6261 7365 6c69 6e65 223f  ype=="baseline"?
+00022fe0: 2022 6261 7365 6c69 6e65 220a 2020 2020   "baseline".    
+00022ff0: 2020 203a 2022 6365 6e74 6572 223b 0a20     : "center";. 
+00023000: 2020 206d 203d 205f 6174 7461 6368 5f74     m = _attach_t
+00023010: 7261 6e73 666f 726d 285b 302c 302c 616e  ransform([0,0,an
+00023020: 6368 6f72 2e7a 5d2c 7370 696e 2c6f 7269  chor.z],spin,ori
+00023030: 656e 742c 6765 6f6d 293b 0a20 2020 206d  ent,geom);.    m
+00023040: 756c 746d 6174 7269 7828 6d29 207b 0a20  ultmatrix(m) {. 
+00023050: 2020 2020 2020 2024 7061 7265 6e74 5f61         $parent_a
+00023060: 6e63 686f 7220 3d20 616e 6368 6f72 3b0a  nchor = anchor;.
+00023070: 2020 2020 2020 2020 2470 6172 656e 745f          $parent_
+00023080: 7370 696e 2020 203d 2073 7069 6e3b 0a20  spin   = spin;. 
+00023090: 2020 2020 2020 2024 7061 7265 6e74 5f6f         $parent_o
+000230a0: 7269 656e 7420 3d20 6f72 6965 6e74 3b0a  rient = orient;.
+000230b0: 2020 2020 2020 2020 2470 6172 656e 745f          $parent_
+000230c0: 6765 6f6d 2020 203d 2067 656f 6d3b 0a20  geom   = geom;. 
+000230d0: 2020 2020 2020 2024 7061 7265 6e74 5f73         $parent_s
+000230e0: 697a 6520 2020 3d20 5f61 7474 6163 685f  ize   = _attach_
+000230f0: 6765 6f6d 5f73 697a 6528 6765 6f6d 293b  geom_size(geom);
+00023100: 0a20 2020 2020 2020 2024 6174 7461 6368  .        $attach
+00023110: 5f74 6f20 2020 3d20 756e 6465 663b 0a20  _to   = undef;. 
+00023120: 2020 2020 2020 2069 6620 285f 6973 5f73         if (_is_s
+00023130: 686f 776e 2829 2920 7b0a 2020 2020 2020  hown()) {.      
+00023140: 2020 2020 2020 5f63 6f6c 6f72 2824 636f        _color($co
+00023150: 6c6f 7229 207b 0a20 2020 2020 2020 2020  lor) {.         
+00023160: 2020 2020 2020 206c 696e 6561 725f 6578         linear_ex
+00023170: 7472 7564 6528 6865 6967 6874 3d68 2c20  trude(height=h, 
+00023180: 6365 6e74 6572 3d74 7275 6529 0a20 2020  center=true).   
+00023190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000231a0: 205f 7465 7874 280a 2020 2020 2020 2020   _text(.        
+000231b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000231c0: 7465 7874 3d74 6578 742c 2073 697a 653d  text=text, size=
+000231d0: 7369 7a65 2c20 666f 6e74 3d66 6f6e 742c  size, font=font,
+000231e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000231f0: 2020 2020 2020 2020 2068 616c 6967 6e3d           halign=
+00023200: 6861 2c20 7661 6c69 676e 3d76 612c 2073  ha, valign=va, s
+00023210: 7061 6369 6e67 3d73 7061 6369 6e67 2c0a  pacing=spacing,.
+00023220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023230: 2020 2020 2020 2020 6469 7265 6374 696f          directio
+00023240: 6e3d 6469 7265 6374 696f 6e2c 206c 616e  n=direction, lan
+00023250: 6775 6167 653d 6c61 6e67 7561 6765 2c0a  guage=language,.
+00023260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023270: 2020 2020 2020 2020 7363 7269 7074 3d73          script=s
+00023280: 6372 6970 740a 2020 2020 2020 2020 2020  cript.          
+00023290: 2020 2020 2020 2020 2020 293b 0a20 2020            );.   
+000232a0: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+000232b0: 2020 207d 0a20 2020 207d 0a7d 0a0a 0a2f     }.    }.}.../
+000232c0: 2f20 5468 6973 2063 6f75 6c64 2062 6520  / This could be 
+000232d0: 7265 706c 6163 6564 2077 6974 6820 5f63  replaced with _c
+000232e0: 7574 5f74 6f5f 7365 675f 755f 666f 726d  ut_to_seg_u_form
+000232f0: 0a66 756e 6374 696f 6e20 5f63 7574 5f69  .function _cut_i
+00023300: 6e74 6572 7028 7061 7468 6375 742c 2070  nterp(pathcut, p
+00023310: 6174 682c 2064 6174 6129 203d 0a20 205b  ath, data) =.  [
+00023320: 666f 7228 656e 7472 793d 7061 7468 6375  for(entry=pathcu
+00023330: 7429 0a20 2020 206c 6574 280a 2020 2020  t).    let(.    
+00023340: 2020 2061 203d 2070 6174 685b 656e 7472     a = path[entr
+00023350: 795b 315d 2d31 5d2c 0a20 2020 2020 2020  y[1]-1],.       
+00023360: 2062 203d 2070 6174 685b 656e 7472 795b   b = path[entry[
+00023370: 315d 5d2c 0a20 2020 2020 2020 2063 203d  1]],.        c =
+00023380: 2065 6e74 7279 5b30 5d2c 0a20 2020 2020   entry[0],.     
+00023390: 2020 2069 203d 206d 6178 5f69 6e64 6578     i = max_index
+000233a0: 2876 5f61 6273 2862 2d61 2929 2c0a 2020  (v_abs(b-a)),.  
+000233b0: 2020 2020 2020 6661 6374 6f72 203d 2028        factor = (
+000233c0: 635b 695d 2d61 5b69 5d29 2f28 625b 695d  c[i]-a[i])/(b[i]
+000233d0: 2d61 5b69 5d29 0a20 2020 2029 0a20 2020  -a[i]).    ).   
+000233e0: 2028 312d 6661 6374 6f72 292a 6461 7461   (1-factor)*data
+000233f0: 5b65 6e74 7279 5b31 5d2d 315d 2b20 6661  [entry[1]-1]+ fa
+00023400: 6374 6f72 202a 2064 6174 615b 656e 7472  ctor * data[entr
+00023410: 795b 315d 5d0a 2020 5d3b 0a0a 0a2f 2f20  y[1]].  ];...// 
+00023420: 4d6f 6475 6c65 3a20 7061 7468 5f74 6578  Module: path_tex
+00023430: 7428 290a 2f2f 2053 796e 6f70 7369 733a  t().// Synopsis:
+00023440: 2043 7265 6174 6573 2032 6420 6f72 2033   Creates 2d or 3
+00023450: 6420 7465 7874 2070 6c61 6365 6420 616c  d text placed al
+00023460: 6f6e 6720 6120 7061 7468 2e0a 2f2f 2054  ong a path..// T
+00023470: 6f70 6963 733a 2054 6578 742c 2050 6174  opics: Text, Pat
+00023480: 6873 2c20 5061 7468 7320 2832 4429 2c20  hs, Paths (2D), 
+00023490: 5061 7468 7320 2833 4429 2c20 5061 7468  Paths (3D), Path
+000234a0: 2047 656e 6572 6174 6f72 732c 2050 6174   Generators, Pat
+000234b0: 6820 4765 6e65 7261 746f 7273 2028 3244  h Generators (2D
+000234c0: 290a 2f2f 2053 6565 2041 6c73 6f2c 2074  ).// See Also, t
+000234d0: 6578 7428 292c 2074 6578 7432 6428 290a  ext(), text2d().
+000234e0: 2f2f 2055 7361 6765 3a0a 2f2f 2020 2070  // Usage:.//   p
+000234f0: 6174 685f 7465 7874 2870 6174 682c 2074  ath_text(path, t
+00023500: 6578 742c 205b 7369 7a65 5d2c 205b 7468  ext, [size], [th
+00023510: 6963 6b6e 6573 735d 2c20 5b66 6f6e 745d  ickness], [font]
+00023520: 2c20 5b6c 6574 7465 7273 697a 653d 5d2c  , [lettersize=],
+00023530: 205b 6f66 6673 6574 3d5d 2c20 5b72 6576   [offset=], [rev
+00023540: 6572 7365 3d5d 2c20 5b6e 6f72 6d61 6c3d  erse=], [normal=
+00023550: 5d2c 205b 746f 703d 5d2c 205b 7465 7874  ], [top=], [text
+00023560: 6d65 7472 6963 733d 5d2c 205b 6b65 726e  metrics=], [kern
+00023570: 3d5d 290a 2f2f 2044 6573 6372 6970 7469  =]).// Descripti
+00023580: 6f6e 3a0a 2f2f 2020 2050 6c61 6365 2074  on:.//   Place t
+00023590: 6865 2074 6578 7420 6c65 7474 6572 2062  he text letter b
+000235a0: 7920 6c65 7474 6572 206f 6e74 6f20 7468  y letter onto th
+000235b0: 6520 7370 6563 6966 6965 6420 7061 7468  e specified path
+000235c0: 2075 7369 6e67 2074 6578 746d 6574 7269   using textmetri
+000235d0: 6373 2028 6966 2061 7661 696c 6162 6c65  cs (if available
+000235e0: 2061 6e64 2072 6571 7565 7374 6564 290a   and requested).
+000235f0: 2f2f 2020 206f 7220 7573 6572 2073 7065  //   or user spe
+00023600: 6369 6669 6564 206c 6574 7465 7220 7370  cified letter sp
+00023610: 6163 696e 672e 2020 5468 6520 7061 7468  acing.  The path
+00023620: 2063 616e 2062 6520 3244 206f 7220 3344   can be 2D or 3D
+00023630: 2e20 2049 6e20 3244 2074 6865 2074 6578  .  In 2D the tex
+00023640: 7420 6170 7065 6172 7320 616c 6f6e 6720  t appears along 
+00023650: 7468 6520 7061 7468 2077 6974 6820 6c65  the path with le
+00023660: 7474 6572 7320 7570 7269 6768 740a 2f2f  tters upright.//
+00023670: 2020 2061 7320 6465 7465 726d 696e 6564     as determined
+00023680: 2062 7920 7468 6520 7061 7468 2064 6972   by the path dir
+00023690: 6563 7469 6f6e 2e20 2049 6e20 3344 2062  ection.  In 3D b
+000236a0: 7920 6465 6661 756c 7420 6c65 7474 6572  y default letter
+000236b0: 7320 6172 6520 706f 7369 7469 6f6e 6564  s are positioned
+000236c0: 206f 6e20 7468 6520 7461 6e67 656e 7420   on the tangent 
+000236d0: 6c69 6e65 2074 6f20 7468 6520 7061 7468  line to the path
+000236e0: 2077 6974 6820 7468 6520 7061 7468 206e   with the path n
+000236f0: 6f72 6d61 6c0a 2f2f 2020 2070 6f69 6e74  ormal.//   point
+00023700: 696e 6720 746f 7761 7264 2074 6865 2072  ing toward the r
+00023710: 6561 6465 722e 2020 5468 6520 7061 7468  eader.  The path
+00023720: 206e 6f72 6d61 6c20 706f 696e 7473 2061   normal points a
+00023730: 7761 7920 6672 6f6d 2074 6865 2063 656e  way from the cen
+00023740: 7465 7220 6f66 2063 7572 7661 7475 7265  ter of curvature
+00023750: 2028 7468 6520 6f70 706f 7369 7465 206f   (the opposite o
+00023760: 6620 7468 6520 6e6f 726d 616c 2070 726f  f the normal pro
+00023770: 6475 6365 640a 2f2f 2020 2062 7920 7061  duced.//   by pa
+00023780: 7468 5f6e 6f72 6d61 6c73 2829 292e 2020  th_normals()).  
+00023790: 4e6f 7465 2074 6861 7420 7468 6973 206d  Note that this m
+000237a0: 6561 6e73 2074 6861 7420 6966 2074 6865  eans that if the
+000237b0: 2063 656e 7465 7220 6f66 2063 7572 7661   center of curva
+000237c0: 7475 7265 2073 7769 7463 6865 7320 7369  ture switches si
+000237d0: 6465 7320 7468 6520 7465 7874 2077 696c  des the text wil
+000237e0: 6c20 666c 6970 2075 7073 6964 6520 646f  l flip upside do
+000237f0: 776e 2e0a 2f2f 2020 2049 6620 796f 7520  wn..//   If you 
+00023800: 7761 6e74 2074 6578 7420 6f6e 2073 7563  want text on suc
+00023810: 6820 6120 7061 7468 2079 6f75 206d 7573  h a path you mus
+00023820: 7420 7375 7070 6c79 2079 6f75 7220 6f77  t supply your ow
+00023830: 6e20 6e6f 726d 616c 206f 7220 746f 7020  n normal or top 
+00023840: 7665 6374 6f72 2e0a 2f2f 2020 202e 0a2f  vector..//   ../
+00023850: 2f20 2020 5465 7874 2061 7070 6561 7273  /   Text appears
+00023860: 2073 7461 7274 696e 6720 6174 2074 6865   starting at the
+00023870: 2062 6567 696e 6e69 6e67 206f 6620 7468   beginning of th
+00023880: 6520 7061 7468 2c20 736f 2069 6620 7468  e path, so if th
+00023890: 6520 3344 2070 6174 6820 6d6f 7665 7320  e 3D path moves 
+000238a0: 7269 6768 7420 746f 206c 6566 740a 2f2f  right to left.//
+000238b0: 2020 2074 6865 6e20 6120 6c65 6674 2d74     then a left-t
+000238c0: 6f2d 7269 6768 7420 7265 6164 696e 6720  o-right reading 
+000238d0: 6c61 6e67 7561 6765 2077 696c 6c20 6469  language will di
+000238e0: 7370 6c61 7920 696e 2074 6865 2077 726f  splay in the wro
+000238f0: 6e67 206f 7264 6572 2e20 2846 6f72 2061  ng order. (For a
+00023900: 2032 4420 7061 7468 2074 6578 7420 7769   2D path text wi
+00023910: 6c6c 2061 7070 6561 7220 7570 7369 6465  ll appear upside
+00023920: 2064 6f77 6e2e 290a 2f2f 2020 2054 6865   down.).//   The
+00023930: 2074 6578 7420 666f 7220 6120 3344 2070   text for a 3D p
+00023940: 6174 6820 6170 7065 6172 7320 706f 7369  ath appears posi
+00023950: 7469 6f6e 6564 2074 6f20 6265 2072 6561  tioned to be rea
+00023960: 6420 6672 6f6d 2022 6f75 7473 6964 6522  d from "outside"
+00023970: 206f 6620 7468 6520 6375 7276 6520 2866   of the curve (f
+00023980: 726f 6d20 6120 706f 696e 7420 6f6e 2074  rom a point on t
+00023990: 6865 206f 7468 6572 2073 6964 6520 6f66  he other side of
+000239a0: 2074 6865 0a2f 2f20 2020 6375 7276 6520   the.//   curve 
+000239b0: 6672 6f6d 2074 6865 2063 656e 7465 7220  from the center 
+000239c0: 6f66 2063 7572 7661 7475 7265 292e 2020  of curvature).  
+000239d0: 4966 2079 6f75 206e 6565 6420 7468 6520  If you need the 
+000239e0: 7465 7874 2074 6f20 7265 6164 2070 726f  text to read pro
+000239f0: 7065 726c 7920 6672 6f6d 2074 6865 2069  perly from the i
+00023a00: 6e73 6964 652c 2079 6f75 2063 616e 2073  nside, you can s
+00023a10: 6574 2072 6576 6572 7365 2074 6f0a 2f2f  et reverse to.//
+00023a20: 2020 2074 7275 6520 746f 2066 6c69 7020     true to flip 
+00023a30: 7468 6520 7465 7874 2c20 6f72 2073 7570  the text, or sup
+00023a40: 706c 7920 796f 7572 206f 776e 206e 6f72  ply your own nor
+00023a50: 6d61 6c2e 0a2f 2f20 2020 2e0a 2f2f 2020  mal..//   ..//  
+00023a60: 2049 6620 796f 7520 646f 206e 6f74 2068   If you do not h
+00023a70: 6176 6520 7468 6520 6578 7065 7269 6d65  ave the experime
+00023a80: 6e74 616c 2074 6578 746d 6574 7269 6373  ntal textmetrics
+00023a90: 2066 6561 7475 7265 2065 6e61 626c 6564   feature enabled
+00023aa0: 2074 6865 6e20 796f 7520 6d75 7374 2073   then you must s
+00023ab0: 7065 6369 6679 2074 6865 2073 7061 6365  pecify the space
+00023ac0: 2066 6f72 2074 6865 206c 6574 7465 7273   for the letters
+00023ad0: 0a2f 2f20 2020 7573 696e 6720 6c65 7474  .//   using lett
+00023ae0: 6572 7369 7a65 2c20 7768 6963 6820 6361  ersize, which ca
+00023af0: 6e20 6265 2061 2073 6361 6c61 7220 6f72  n be a scalar or
+00023b00: 2061 7272 6179 2e20 2059 6f75 2077 696c   array.  You wil
+00023b10: 6c20 6861 7665 2074 6865 2065 6173 6965  l have the easie
+00023b20: 7374 2074 696d 6520 6765 7474 696e 6720  st time getting 
+00023b30: 676f 6f64 2072 6573 756c 7473 2062 7920  good results by 
+00023b40: 7573 696e 670a 2f2f 2020 2061 206d 6f6e  using.//   a mon
+00023b50: 6f73 7061 6365 2066 6f6e 7420 7375 6368  ospace font such
+00023b60: 2061 7320 436f 7572 6965 722e 2020 4e6f   as Courier.  No
+00023b70: 7465 2074 6861 7420 6576 656e 2077 6974  te that even wit
+00023b80: 6820 7465 7874 206d 6574 7269 6373 2c20  h text metrics, 
+00023b90: 7370 6163 696e 6720 6d61 7920 6265 2064  spacing may be d
+00023ba0: 6966 6665 7265 6e74 2062 6563 6175 7365  ifferent because
+00023bb0: 2070 6174 685f 7465 7874 2829 0a2f 2f20   path_text().// 
+00023bc0: 2020 646f 6573 6e27 7420 646f 206b 6572    doesn't do ker
+00023bd0: 6e69 6e67 2074 6f20 6164 6a75 7374 2070  ning to adjust p
+00023be0: 6f73 6974 696f 6e73 206f 6620 696e 6469  ositions of indi
+00023bf0: 7669 6475 616c 2067 6c79 7068 732e 2020  vidual glyphs.  
+00023c00: 416c 736f 2069 6620 796f 7572 2066 6f6e  Also if your fon
+00023c10: 7420 6861 7320 6c69 6761 7475 7265 7320  t has ligatures 
+00023c20: 7468 6579 2077 6f6e 2774 2062 6520 7573  they won't be us
+00023c30: 6564 2e0a 2f2f 2020 202e 0a2f 2f20 2020  ed..//   ..//   
+00023c40: 4279 2064 6566 6175 6c74 206c 6574 7465  By default lette
+00023c50: 7273 2061 7070 6561 7220 6365 6e74 6572  rs appear center
+00023c60: 6564 206f 6e20 7468 6520 7061 7468 2e20  ed on the path. 
+00023c70: 2054 6865 206f 6666 7365 7420 6361 6e20   The offset can 
+00023c80: 6265 2073 7065 6369 6669 6564 2074 6f20  be specified to 
+00023c90: 7368 6966 7420 6c65 7474 6572 7320 746f  shift letters to
+00023ca0: 7761 7264 2074 6865 2072 6561 6465 7220  ward the reader 
+00023cb0: 2869 6e0a 2f2f 2020 2074 6865 2064 6972  (in.//   the dir
+00023cc0: 6563 7469 6f6e 206f 6620 7468 6520 6e6f  ection of the no
+00023cd0: 726d 616c 292e 0a2f 2f20 2020 2e0a 2f2f  rmal)..//   ..//
+00023ce0: 2020 2059 6f75 2063 616e 2073 7065 6369     You can speci
+00023cf0: 6679 2079 6f75 7220 6f77 6e20 6e6f 726d  fy your own norm
+00023d00: 616c 2062 7920 7365 7474 696e 6720 606e  al by setting `n
+00023d10: 6f72 6d61 6c60 2074 6f20 6120 6469 7265  ormal` to a dire
+00023d20: 6374 696f 6e20 6f72 2061 206c 6973 7420  ction or a list 
+00023d30: 6f66 2064 6972 6563 7469 6f6e 732e 2020  of directions.  
+00023d40: 596f 7572 206e 6f72 6d61 6c20 7665 6374  Your normal vect
+00023d50: 6f72 2073 686f 756c 640a 2f2f 2020 2070  or should.//   p
+00023d60: 6f69 6e74 2074 6f77 6172 6420 7468 6520  oint toward the 
+00023d70: 7265 6164 6572 2e20 2059 6f75 2063 616e  reader.  You can
+00023d80: 2061 6c73 6f20 7370 6563 6966 790a 2f2f   also specify.//
+00023d90: 2020 2074 6f70 2c20 7768 6963 6820 6469     top, which di
+00023da0: 7265 6374 7320 7468 6520 746f 7020 6f66  rects the top of
+00023db0: 2074 6865 206c 6574 7465 7273 2069 6e20   the letters in 
+00023dc0: 6120 6465 7369 7265 6420 6469 7265 6374  a desired direct
+00023dd0: 696f 6e2e 2020 4966 2079 6f75 2073 7065  ion.  If you spe
+00023de0: 6369 6679 2079 6f75 7220 6f77 6e20 6469  cify your own di
+00023df0: 7265 6374 696f 6e73 2061 6e64 2074 6865  rections and the
+00023e00: 790a 2f2f 2020 2061 7265 206e 6f74 2070  y.//   are not p
+00023e10: 6572 7065 6e64 6963 756c 6172 2074 6f20  erpendicular to 
+00023e20: 7468 6520 7061 7468 2074 6865 6e20 7468  the path then th
+00023e30: 6520 6469 7265 6374 696f 6e20 796f 7520  e direction you 
+00023e40: 7370 6563 6966 7920 7769 6c6c 2074 616b  specify will tak
+00023e50: 6520 7072 696f 7269 7479 2061 6e64 2074  e priority and t
+00023e60: 6865 0a2f 2f20 2020 6c65 7474 6572 7320  he.//   letters 
+00023e70: 7769 6c6c 206e 6f74 2072 6573 7420 6f6e  will not rest on
+00023e80: 2074 6865 2074 616e 6765 6e74 206c 696e   the tangent lin
+00023e90: 6520 6f66 2074 6865 2070 6174 682e 2020  e of the path.  
+00023ea0: 4e6f 7465 2074 6861 7420 7468 6520 6e6f  Note that the no
+00023eb0: 726d 616c 206f 7220 746f 7020 6469 7265  rmal or top dire
+00023ec0: 6374 696f 6e73 2074 6861 7420 796f 750a  ctions that you.
+00023ed0: 2f2f 2020 2073 7065 6369 6679 206d 7573  //   specify mus
+00023ee0: 7420 6e6f 7420 6265 2070 6172 616c 6c65  t not be paralle
+00023ef0: 6c20 746f 2074 6865 2070 6174 682e 0a2f  l to the path../
+00023f00: 2f20 2020 2e0a 2f2f 2020 2048 6973 746f  /   ..//   Histo
+00023f10: 7269 6361 6c6c 7920 666f 6e74 7320 7765  rically fonts we
+00023f20: 7265 2073 7065 6369 6669 6564 2062 7920  re specified by 
+00023f30: 7468 6569 7220 2262 6f64 7920 7369 7a65  their "body size
+00023f40: 222c 2074 6865 2068 6569 6768 7420 6f66  ", the height of
+00023f50: 2074 6865 206d 6574 616c 2062 6f64 790a   the metal body.
+00023f60: 2f2f 2020 206f 6e20 7768 6963 6820 7468  //   on which th
+00023f70: 6520 676c 7970 6873 2077 6572 6520 6361  e glyphs were ca
+00023f80: 7374 2e20 2054 6869 7320 6d65 616e 7320  st.  This means 
+00023f90: 7468 6520 7369 7a65 2077 6173 2061 6e20  the size was an 
+00023fa0: 7570 7065 7220 626f 756e 6420 6f6e 2074  upper bound on t
+00023fb0: 6865 2073 697a 650a 2f2f 2020 206f 6620  he size.//   of 
+00023fc0: 7468 6520 666f 6e74 2067 6c79 7068 732c  the font glyphs,
+00023fd0: 206e 6f74 2061 2064 6972 6563 7420 6d65   not a direct me
+00023fe0: 6173 7572 656d 656e 7420 6f66 2074 6865  asurement of the
+00023ff0: 6972 2073 697a 652e 2020 496e 2064 6967  ir size.  In dig
+00024000: 6974 616c 2074 7970 6573 6574 7469 6e67  ital typesetting
+00024010: 2c0a 2f2f 2020 2074 6865 206d 6574 616c  ,.//   the metal
+00024020: 2062 6f64 7920 6973 2072 6570 6c61 6365   body is replace
+00024030: 6420 6279 2061 6e20 696e 7669 7369 626c  d by an invisibl
+00024040: 6520 626f 782c 2074 6865 2065 6d20 7371  e box, the em sq
+00024050: 7561 7265 2c20 7768 6f73 6520 7369 6465  uare, whose side
+00024060: 206c 656e 6774 6820 6973 0a2f 2f20 2020   length is.//   
+00024070: 6465 6669 6e65 6420 746f 2062 6520 7468  defined to be th
+00024080: 6520 666f 6e74 2773 2073 697a 652e 2020  e font's size.  
+00024090: 5468 6520 676c 7970 6873 2063 616e 2062  The glyphs can b
+000240a0: 6520 636f 6e74 6169 6e65 6420 696e 2074  e contained in t
+000240b0: 6861 7420 7371 7561 7265 2c20 6f72 2074  hat square, or t
+000240c0: 6865 790a 2f2f 2020 2063 616e 2065 7874  hey.//   can ext
+000240d0: 656e 6420 6265 796f 6e64 2069 742c 2064  end beyond it, d
+000240e0: 6570 656e 6469 6e67 206f 6e20 7468 6520  epending on the 
+000240f0: 6368 6f69 6365 7320 6d61 6465 2062 7920  choices made by 
+00024100: 7468 6520 666f 6e74 2064 6573 6967 6e65  the font designe
+00024110: 722e 2020 4173 2061 0a2f 2f20 2020 7265  r.  As a.//   re
+00024120: 7375 6c74 2c20 7468 6520 6d65 616e 696e  sult, the meanin
+00024130: 6720 6f66 2066 6f6e 7420 7369 7a65 2076  g of font size v
+00024140: 6172 6965 7320 6265 7477 6565 6e20 666f  aries between fo
+00024150: 6e74 733a 2074 776f 2066 6f6e 7473 2061  nts: two fonts a
+00024160: 7420 7468 6520 2273 616d 6522 2073 697a  t the "same" siz
+00024170: 650a 2f2f 2020 2063 616e 2064 6966 6665  e.//   can diffe
+00024180: 7220 7369 676e 6966 6963 616e 746c 7920  r significantly 
+00024190: 696e 2074 6865 2061 6374 7561 6c20 7369  in the actual si
+000241a0: 7a65 206f 6620 7468 6569 7220 6368 6172  ze of their char
+000241b0: 6163 7465 7273 2e20 2054 7970 6f67 7261  acters.  Typogra
+000241c0: 7068 6572 730a 2f2f 2020 2063 7573 746f  phers.//   custo
+000241d0: 6d61 7269 6c79 2073 7065 6369 6679 2074  marily specify t
+000241e0: 6865 2073 697a 6520 696e 2074 6865 2075  he size in the u
+000241f0: 6e69 7473 206f 6620 2270 6f69 6e74 7322  nits of "points"
+00024200: 2e20 2041 2070 6f69 6e74 2069 7320 312f  .  A point is 1/
+00024210: 3732 2069 6e63 682e 2020 496e 0a2f 2f20  72 inch.  In.// 
+00024220: 2020 4f70 656e 5343 4144 2c20 796f 7520    OpenSCAD, you 
+00024230: 7370 6563 6966 7920 7468 6520 7369 7a65  specify the size
+00024240: 2069 6e20 4f70 656e 5343 4144 2075 6e69   in OpenSCAD uni
+00024250: 7473 2028 6f66 7465 6e20 7472 6561 7465  ts (often treate
+00024260: 6420 6173 206d 696c 6c69 6d65 7465 7273  d as millimeters
+00024270: 2066 6f72 2033 640a 2f2f 2020 2070 7269   for 3d.//   pri
+00024280: 6e74 696e 6729 2c20 736f 2069 6620 796f  nting), so if yo
+00024290: 7520 7761 6e74 2070 6f69 6e74 7320 796f  u want points yo
+000242a0: 7520 7769 6c6c 206e 6565 6420 746f 2070  u will need to p
+000242b0: 6572 666f 726d 2061 2073 7569 7461 626c  erform a suitabl
+000242c0: 6520 756e 6974 2063 6f6e 7665 7273 696f  e unit conversio
+000242d0: 6e2e 0a2f 2f20 2020 496e 2061 6464 6974  n..//   In addit
+000242e0: 696f 6e2c 2074 6865 204f 7065 6e53 4341  ion, the OpenSCA
+000242f0: 4420 666f 6e74 2073 7973 7465 6d20 6861  D font system ha
+00024300: 7320 6120 6275 673a 2069 6620 796f 7520  s a bug: if you 
+00024310: 7370 6563 6966 7920 7369 7a65 3d73 2079  specify size=s y
+00024320: 6f75 2077 696c 6c0a 2f2f 2020 2069 6e73  ou will.//   ins
+00024330: 7465 6164 2067 6574 2061 2066 6f6e 7420  tead get a font 
+00024340: 7768 6f73 6520 7369 7a65 2069 7320 732f  whose size is s/
+00024350: 302e 3732 2e20 2046 6f72 206d 616e 7920  0.72.  For many 
+00024360: 666f 6e74 7320 7468 6973 206d 6561 6e73  fonts this means
+00024370: 2074 6865 2073 697a 6520 6f66 0a2f 2f20   the size of.// 
+00024380: 2020 6361 7069 7461 6c20 6c65 7474 6572    capital letter
+00024390: 7320 7769 6c6c 2062 6520 6170 7072 6f78  s will be approx
+000243a0: 696d 6174 656c 7920 6571 7561 6c20 746f  imately equal to
+000243b0: 2073 2c20 6265 6361 7573 6520 6974 2069   s, because it i
+000243c0: 7320 636f 6d6d 6f6e 2066 6f72 2066 6f6e  s common for fon
+000243d0: 7473 2074 6f0a 2f2f 2020 2075 7365 2061  ts to.//   use a
+000243e0: 626f 7574 2037 3025 206f 6620 7468 6569  bout 70% of thei
+000243f0: 7220 6865 6967 6874 2066 6f72 2074 6865  r height for the
+00024400: 2061 7363 656e 6465 7273 2069 6e20 7468   ascenders in th
+00024410: 6520 666f 6e74 2e20 2054 6f20 6765 7420  e font.  To get 
+00024420: 7468 6520 6375 7374 6f6d 6172 790a 2f2f  the customary.//
+00024430: 2020 2066 6f6e 7420 7369 7a65 2c20 796f     font size, yo
+00024440: 7520 7368 6f75 6c64 206d 756c 7469 706c  u should multipl
+00024450: 7920 796f 7572 2064 6573 6972 6564 2073  y your desired s
+00024460: 697a 6520 6279 2030 2e37 322e 0a2f 2f20  ize by 0.72..// 
+00024470: 2020 2e0a 2f2f 2020 2054 6f20 6669 6e64    ..//   To find
+00024480: 2074 6865 2066 6f6e 7473 2074 6861 7420   the fonts that 
+00024490: 796f 7520 6861 7665 2061 7661 696c 6162  you have availab
+000244a0: 6c65 2069 6e20 796f 7572 204f 7065 6e53  le in your OpenS
+000244b0: 4341 4420 696e 7374 616c 6c61 7469 6f6e  CAD installation
+000244c0: 2c0a 2f2f 2020 2067 6f20 746f 2074 6865  ,.//   go to the
+000244d0: 2048 656c 7020 6d65 6e75 2061 6e64 2073   Help menu and s
+000244e0: 656c 6563 7420 2246 6f6e 7420 4c69 7374  elect "Font List
+000244f0: 222e 0a2f 2f20 4172 6775 6d65 6e74 733a  "..// Arguments:
+00024500: 0a2f 2f20 2020 7061 7468 203d 2070 6174  .//   path = pat
+00024510: 6820 746f 2070 6c61 6365 2074 6865 2074  h to place the t
+00024520: 6578 7420 6f6e 0a2f 2f20 2020 7465 7874  ext on.//   text
+00024530: 203d 2074 6578 7420 746f 2063 7265 6174   = text to creat
+00024540: 650a 2f2f 2020 2073 697a 6520 3d20 5468  e.//   size = Th
+00024550: 6520 666f 6e74 2077 696c 6c20 6265 2063  e font will be c
+00024560: 7265 6174 6564 2061 7420 7468 6973 2073  reated at this s
+00024570: 697a 6520 6469 7669 6465 6420 6279 2030  ize divided by 0
+00024580: 2e37 322e 2020 200a 2f2f 2020 2074 6869  .72.   .//   thi
+00024590: 636b 6e65 7373 202f 2068 202f 2068 6569  ckness / h / hei
+000245a0: 6768 7420 3d20 7468 6963 6b6e 6573 7320  ght = thickness 
+000245b0: 6f66 206c 6574 7465 7273 2028 6e6f 7420  of letters (not 
+000245c0: 616c 6c6f 7765 6420 666f 7220 3244 2070  allowed for 2D p
+000245d0: 6174 6829 0a2f 2f20 2020 666f 6e74 203d  ath).//   font =
+000245e0: 2066 6f6e 7420 746f 2075 7365 2e20 2044   font to use.  D
+000245f0: 6566 6175 6c74 3a20 224c 6962 6572 6174  efault: "Liberat
+00024600: 696f 6e20 5361 6e73 220a 2f2f 2020 202d  ion Sans".//   -
+00024610: 2d2d 0a2f 2f20 2020 6c65 7474 6572 7369  --.//   lettersi
+00024620: 7a65 203d 2073 6361 6c61 7220 6f72 2061  ze = scalar or a
+00024630: 7272 6179 2067 6976 696e 6720 7369 7a65  rray giving size
+00024640: 206f 6620 6c65 7474 6572 730a 2f2f 2020   of letters.//  
+00024650: 2063 656e 7465 7220 3d20 6365 6e74 6572   center = center
+00024660: 2074 6578 7420 6f6e 2074 6865 2070 6174   text on the pat
+00024670: 6820 696e 7374 6561 6420 6f66 2073 7461  h instead of sta
+00024680: 7274 696e 6720 6174 2074 6865 2066 6972  rting at the fir
+00024690: 7374 2070 6f69 6e74 2e20 2044 6566 6175  st point.  Defau
+000246a0: 6c74 3a20 6661 6c73 650a 2f2f 2020 206f  lt: false.//   o
+000246b0: 6666 7365 7420 3d20 6469 7374 616e 6365  ffset = distance
+000246c0: 2074 6f20 7368 6966 7420 6c65 7474 6572   to shift letter
+000246d0: 7320 2275 7022 2028 746f 7761 7264 7320  s "up" (towards 
+000246e0: 7468 6520 7265 6164 6572 292e 2020 4e6f  the reader).  No
+000246f0: 7420 616c 6c6f 7765 6420 666f 7220 3244  t allowed for 2D
+00024700: 2070 6174 682e 2020 4465 6661 756c 743a   path.  Default:
+00024710: 2030 0a2f 2f20 2020 6e6f 726d 616c 203d   0.//   normal =
+00024720: 2064 6972 6563 7469 6f6e 206f 7220 6c69   direction or li
+00024730: 7374 206f 6620 6469 7265 6374 696f 6e73  st of directions
+00024740: 2070 6f69 6e74 696e 6720 746f 7761 7264   pointing toward
+00024750: 7320 7468 6520 7265 6164 6572 206f 6620  s the reader of 
+00024760: 7468 6520 7465 7874 2e20 204e 6f74 2061  the text.  Not a
+00024770: 6c6c 6f77 6564 2066 6f72 2032 4420 7061  llowed for 2D pa
+00024780: 7468 2e0a 2f2f 2020 2074 6f70 203d 2064  th..//   top = d
+00024790: 6972 6563 7469 6f6e 206f 7220 6c69 7374  irection or list
+000247a0: 206f 6620 6469 7265 6374 696f 6e73 2070   of directions p
+000247b0: 6f69 6e74 696e 6720 746f 7761 7264 2074  ointing toward t
+000247c0: 6865 2074 6f70 206f 6620 7468 6520 7465  he top of the te
+000247d0: 7874 0a2f 2f20 2020 7265 7665 7273 6520  xt.//   reverse 
+000247e0: 3d20 7265 7665 7273 6520 7468 6520 6c65  = reverse the le
+000247f0: 7474 6572 7320 6966 2074 7275 652e 2020  tters if true.  
+00024800: 4e6f 7420 616c 6c6f 7765 6420 666f 7220  Not allowed for 
+00024810: 3244 2070 6174 682e 2020 4465 6661 756c  2D path.  Defaul
+00024820: 743a 2066 616c 7365 0a2f 2f20 2020 7465  t: false.//   te
+00024830: 7874 6d65 7472 6963 7320 3d20 6966 2073  xtmetrics = if s
+00024840: 6574 2074 6f20 7472 7565 2061 6e64 206c  et to true and l
+00024850: 6574 7465 7273 697a 6520 6973 206e 6f74  ettersize is not
+00024860: 2067 6976 656e 2074 6865 6e20 7573 6520   given then use 
+00024870: 7468 6520 6578 7065 7269 6d65 6e74 616c  the experimental
+00024880: 2074 6578 746d 6574 7269 6373 2066 6561   textmetrics fea
+00024890: 7475 7265 2e20 2059 6f75 206d 7573 7420  ture.  You must 
+000248a0: 6265 2072 756e 6e69 6e67 2061 2064 6576  be running a dev
+000248b0: 2073 6e61 7073 686f 7420 7468 6174 2069   snapshot that i
+000248c0: 6e63 6c75 6465 7320 7468 6973 2066 6561  ncludes this fea
+000248d0: 7475 7265 2061 6e64 2068 6176 6520 7468  ture and have th
+000248e0: 6520 6665 6174 7572 6520 7475 726e 6564  e feature turned
+000248f0: 206f 6e20 696e 2079 6f75 7220 7072 6566   on in your pref
+00024900: 6572 656e 6365 732e 2020 4465 6661 756c  erences.  Defaul
+00024910: 743a 2066 616c 7365 0a2f 2f20 2020 7661  t: false.//   va
+00024920: 6c69 676e 203d 2061 6c69 676e 2074 6578  lign = align tex
+00024930: 7420 746f 2074 6865 2070 6174 6820 7573  t to the path us
+00024940: 696e 6720 2274 6f70 222c 2022 626f 7474  ing "top", "bott
+00024950: 6f6d 222c 2022 6365 6e74 6572 2220 6f72  om", "center" or
+00024960: 2022 6261 7365 6c69 6e65 222e 2020 596f   "baseline".  Yo
+00024970: 7520 6361 6e20 616c 736f 2061 646a 7573  u can also adjus
+00024980: 7420 706f 7369 7469 6f6e 2077 6974 6820  t position with 
+00024990: 6120 6e75 6d65 7269 6361 6c20 6f66 6673  a numerical offs
+000249a0: 6574 2061 7320 696e 2022 746f 702d 3522  et as in "top-5"
+000249b0: 206f 7220 2262 6f74 746f 6d2b 3222 2e20   or "bottom+2". 
+000249c0: 2054 6869 7320 6f6e 6c79 2077 6f72 6b73   This only works
+000249d0: 2077 6974 6820 7465 7874 6d65 7472 6963   with textmetric
+000249e0: 7320 656e 6162 6c65 642e 2020 596f 7520  s enabled.  You 
+000249f0: 6361 6e20 6769 7665 2061 2073 696d 706c  can give a simpl
+00024a00: 6520 6e75 6d65 7269 6361 6c20 6f66 6673  e numerical offs
+00024a10: 6574 2c20 7768 6963 6820 7769 6c6c 2062  et, which will b
+00024a20: 6520 7265 6c61 7469 7665 2074 6f20 7468  e relative to th
+00024a30: 6520 6261 7365 6c69 6e65 2061 6e64 2077  e baseline and w
+00024a40: 6f72 6b73 2065 7665 6e20 7769 7468 6f75  orks even withou
+00024a50: 7420 7465 7874 6d65 7472 6963 732e 2020  t textmetrics.  
+00024a60: 4465 6661 756c 743a 2022 6261 7365 6c69  Default: "baseli
+00024a70: 6e65 220a 2f2f 2020 206b 6572 6e20 3d20  ne".//   kern = 
+00024a80: 7363 616c 6172 206f 7220 6172 7261 7920  scalar or array 
+00024a90: 6769 7669 6e67 2073 7061 6369 6e67 2061  giving spacing a
+00024aa0: 646a 7573 6d65 6e74 7320 6265 7477 6565  djusments betwee
+00024ab0: 6e20 6561 6368 206c 6574 7465 722e 2020  n each letter.  
+00024ac0: 4966 2069 7427 7320 616e 2061 7272 6179  If it's an array
+00024ad0: 2069 7420 7368 6f75 6c64 2068 6176 6520   it should have 
+00024ae0: 6f6e 6520 6c65 7373 2065 6e74 7279 2074  one less entry t
+00024af0: 6861 6e20 7468 6520 7465 7874 2073 7472  han the text str
+00024b00: 696e 672e 2020 4465 6661 756c 743a 2030  ing.  Default: 0
+00024b10: 0a2f 2f20 2020 6c61 6e67 7561 6765 203d  .//   language =
+00024b20: 2074 6578 7420 6c61 6e67 7561 6765 2c20   text language, 
+00024b30: 7061 7373 6564 2074 6f20 4f70 656e 5343  passed to OpenSC
+00024b40: 4144 2060 7465 7874 2829 602e 2020 4465  AD `text()`.  De
+00024b50: 6661 756c 743a 2022 656e 220a 2f2f 2020  fault: "en".//  
+00024b60: 2073 6372 6970 7420 3d20 7465 7874 2073   script = text s
+00024b70: 6372 6970 742c 2070 6173 7365 6420 746f  cript, passed to
+00024b80: 204f 7065 6e53 4341 4420 6074 6578 7428   OpenSCAD `text(
+00024b90: 2960 2e20 2044 6566 6175 6c74 3a20 226c  )`.  Default: "l
+00024ba0: 6174 696e 2220 0a2f 2f20 4578 616d 706c  atin" .// Exampl
+00024bb0: 6528 3344 2c4e 6f53 6361 6c65 7329 3a20  e(3D,NoScales): 
+00024bc0: 2054 6865 2065 7861 6d70 6c65 7320 7573   The examples us
+00024bd0: 6520 436f 7572 6965 722c 2061 206d 6f6e  e Courier, a mon
+00024be0: 6f73 7061 6365 6420 666f 6e74 2e20 2054  ospaced font.  T
+00024bf0: 6865 2077 6964 7468 2069 7320 312f 312e  he width is 1/1.
+00024c00: 3220 7469 6d65 7320 7468 6520 7370 6563  2 times the spec
+00024c10: 6966 6965 6420 7369 7a65 2066 6f72 2074  ified size for t
+00024c20: 6869 7320 666f 6e74 2e20 2054 6869 7320  his font.  This 
+00024c30: 7465 7874 2063 6f75 6c64 2077 7261 7020  text could wrap 
+00024c40: 6172 6f75 6e64 2061 2063 796c 696e 6465  around a cylinde
+00024c50: 722e 0a2f 2f20 2020 7061 7468 203d 2070  r..//   path = p
+00024c60: 6174 6833 6428 6172 6328 3130 302c 2072  ath3d(arc(100, r
+00024c70: 3d32 352c 2061 6e67 6c65 3d5b 3234 352c  =25, angle=[245,
+00024c80: 2033 3730 5d29 293b 0a2f 2f20 2020 636f   370]));.//   co
+00024c90: 6c6f 7228 2272 6564 2229 7374 726f 6b65  lor("red")stroke
+00024ca0: 2870 6174 682c 2077 6964 7468 3d2e 3329  (path, width=.3)
+00024cb0: 3b0a 2f2f 2020 2070 6174 685f 7465 7874  ;.//   path_text
+00024cc0: 2870 6174 682c 2022 4578 616d 706c 6520  (path, "Example 
+00024cd0: 7465 7874 222c 2066 6f6e 743d 2243 6f75  text", font="Cou
+00024ce0: 7269 6572 222c 2073 697a 653d 352c 206c  rier", size=5, l
+00024cf0: 6574 7465 7273 697a 6520 3d20 352f 312e  ettersize = 5/1.
+00024d00: 3229 3b0a 2f2f 2045 7861 6d70 6c65 2833  2);.// Example(3
+00024d10: 442c 4e6f 5363 616c 6573 293a 2042 7920  D,NoScales): By 
+00024d20: 7365 7474 696e 6720 7468 6520 6e6f 726d  setting the norm
+00024d30: 616c 2074 6f20 5550 2077 6520 6361 6e20  al to UP we can 
+00024d40: 6765 7420 7465 7874 2074 6861 7420 6c69  get text that li
+00024d50: 6573 2066 6c61 742c 2066 6f72 2077 7269  es flat, for wri
+00024d60: 7469 6e67 2061 726f 756e 6420 7468 6520  ting around the 
+00024d70: 6564 6765 206f 6620 6120 6469 736b 3a0a  edge of a disk:.
+00024d80: 2f2f 2020 2070 6174 6820 3d20 7061 7468  //   path = path
+00024d90: 3364 2861 7263 2831 3030 2c20 723d 3235  3d(arc(100, r=25
+00024da0: 2c20 616e 676c 653d 5b32 3435 2c20 3337  , angle=[245, 37
+00024db0: 305d 2929 3b0a 2f2f 2020 2063 6f6c 6f72  0]));.//   color
+00024dc0: 2822 7265 6422 2973 7472 6f6b 6528 7061  ("red")stroke(pa
+00024dd0: 7468 2c20 7769 6474 683d 2e33 293b 0a2f  th, width=.3);./
+00024de0: 2f20 2020 7061 7468 5f74 6578 7428 7061  /   path_text(pa
+00024df0: 7468 2c20 2245 7861 6d70 6c65 2074 6578  th, "Example tex
+00024e00: 7422 2c20 666f 6e74 3d22 436f 7572 6965  t", font="Courie
+00024e10: 7222 2c20 7369 7a65 3d35 2c20 6c65 7474  r", size=5, lett
+00024e20: 6572 7369 7a65 203d 2035 2f31 2e32 2c20  ersize = 5/1.2, 
+00024e30: 6e6f 726d 616c 3d55 5029 3b0a 2f2f 2045  normal=UP);.// E
+00024e40: 7861 6d70 6c65 2833 442c 4e6f 5363 616c  xample(3D,NoScal
+00024e50: 6573 293a 2020 4966 2077 6520 7761 6e74  es):  If we want
+00024e60: 2074 6578 7420 7468 6174 2072 6561 6473   text that reads
+00024e70: 2066 726f 6d20 7468 6520 6f74 6865 7220   from the other 
+00024e80: 7369 6465 2077 6520 6361 6e20 7573 6520  side we can use 
+00024e90: 7265 7665 7273 652e 2020 4e6f 7465 2077  reverse.  Note w
+00024ea0: 6520 6861 7665 2074 6f20 7265 7665 7273  e have to revers
+00024eb0: 6520 7468 6520 6469 7265 6374 696f 6e20  e the direction 
+00024ec0: 6f66 2074 6865 2070 6174 6820 616e 6420  of the path and 
+00024ed0: 616c 736f 2073 6574 2074 6865 2072 6576  also set the rev
+00024ee0: 6572 7365 206f 7074 696f 6e2e 0a2f 2f20  erse option..// 
+00024ef0: 2020 7061 7468 203d 2072 6576 6572 7365    path = reverse
+00024f00: 2870 6174 6833 6428 6172 6328 3130 302c  (path3d(arc(100,
+00024f10: 2072 3d32 352c 2061 6e67 6c65 3d5b 3635   r=25, angle=[65
+00024f20: 2c20 3139 305d 2929 293b 0a2f 2f20 2020  , 190])));.//   
+00024f30: 636f 6c6f 7228 2272 6564 2229 7374 726f  color("red")stro
+00024f40: 6b65 2870 6174 682c 2077 6964 7468 3d2e  ke(path, width=.
+00024f50: 3329 3b0a 2f2f 2020 2070 6174 685f 7465  3);.//   path_te
+00024f60: 7874 2870 6174 682c 2022 4578 616d 706c  xt(path, "Exampl
+00024f70: 6520 7465 7874 222c 2066 6f6e 743d 2243  e text", font="C
+00024f80: 6f75 7269 6572 222c 2073 697a 653d 352c  ourier", size=5,
+00024f90: 206c 6574 7465 7273 697a 6520 3d20 352f   lettersize = 5/
+00024fa0: 312e 322c 2072 6576 6572 7365 3d74 7275  1.2, reverse=tru
+00024fb0: 6529 3b0a 2f2f 2045 7861 6d70 6c65 2833  e);.// Example(3
+00024fc0: 442c 4d65 642c 4e6f 5363 616c 6573 293a  D,Med,NoScales):
+00024fd0: 2074 6578 7420 6465 626f 7373 6564 206f   text debossed o
+00024fe0: 6e74 6f20 6120 6379 6c69 6e64 6572 2069  nto a cylinder i
+00024ff0: 6e20 6120 7370 6972 616c 2e20 2054 6865  n a spiral.  The
+00025000: 2074 6578 7420 6973 2031 2075 6e69 7420   text is 1 unit 
+00025010: 6465 6570 2062 6563 6175 7365 2069 7420  deep because it 
+00025020: 6973 2068 616c 6620 696e 2c20 6861 6c66  is half in, half
+00025030: 206f 7574 2e0a 2f2f 2020 2074 6578 7420   out..//   text 
+00025040: 3d20 2822 4120 6c6f 6e67 2074 6578 7420  = ("A long text 
+00025050: 6578 616d 706c 6520 746f 2077 7261 7020  example to wrap 
+00025060: 6172 6f75 6e64 2061 2063 796c 696e 6465  around a cylinde
+00025070: 722c 2070 6f73 7369 626c 7920 666f 7220  r, possibly for 
+00025080: 6120 6665 7720 7469 6d65 732e 2229 3b0a  a few times.");.
+00025090: 2f2f 2020 204c 203d 2035 2a6c 656e 2874  //   L = 5*len(t
+000250a0: 6578 7429 3b0a 2f2f 2020 206d 6178 616e  ext);.//   maxan
+000250b0: 6720 3d20 3336 302a 4c2f 2850 492a 3530  g = 360*L/(PI*50
+000250c0: 293b 0a2f 2f20 2020 7370 6972 616c 203d  );.//   spiral =
+000250d0: 205b 666f 7228 613d 5b30 3a31 3a6d 6178   [for(a=[0:1:max
+000250e0: 616e 675d 2920 5b32 352a 636f 7328 6129  ang]) [25*cos(a)
+000250f0: 2c20 3235 2a73 696e 2861 292c 2031 302d  , 25*sin(a), 10-
+00025100: 3330 2f6d 6178 616e 672a 615d 5d3b 0a2f  30/maxang*a]];./
+00025110: 2f20 2020 6469 6666 6572 656e 6365 2829  /   difference()
+00025120: 7b0a 2f2f 2020 2020 2063 796c 2864 3d35  {.//     cyl(d=5
+00025130: 302c 206c 3d35 302c 2024 666e 3d31 3230  0, l=50, $fn=120
+00025140: 293b 0a2f 2f20 2020 2020 7061 7468 5f74  );.//     path_t
+00025150: 6578 7428 7370 6972 616c 2c20 7465 7874  ext(spiral, text
+00025160: 2c20 7369 7a65 3d35 2c20 6c65 7474 6572  , size=5, letter
+00025170: 7369 7a65 3d35 2f31 2e32 2c20 666f 6e74  size=5/1.2, font
+00025180: 3d22 436f 7572 6965 7222 2c20 7468 6963  ="Courier", thic
+00025190: 6b6e 6573 733d 3229 3b0a 2f2f 2020 207d  kness=2);.//   }
+000251a0: 0a2f 2f20 4578 616d 706c 6528 3344 2c4d  .// Example(3D,M
+000251b0: 6564 2c4e 6f53 6361 6c65 7329 3a20 5361  ed,NoScales): Sa
+000251c0: 6d65 2065 7861 6d70 6c65 2062 7574 2074  me example but t
+000251d0: 6578 7420 656d 626f 7373 6564 2e20 204d  ext embossed.  M
+000251e0: 616b 6520 7375 7265 2079 6f75 2068 6176  ake sure you hav
+000251f0: 6520 656e 6f75 6768 2064 6570 7468 2066  e enough depth f
+00025200: 6f72 2074 6865 206c 6574 7465 7273 2074  or the letters t
+00025210: 6f20 6675 6c6c 7920 6f76 6572 6c61 7020  o fully overlap 
+00025220: 7468 6520 6f62 6a65 6374 2e0a 2f2f 2020  the object..//  
+00025230: 2074 6578 7420 3d20 2822 4120 6c6f 6e67   text = ("A long
+00025240: 2074 6578 7420 6578 616d 706c 6520 746f   text example to
+00025250: 2077 7261 7020 6172 6f75 6e64 2061 2063   wrap around a c
+00025260: 796c 696e 6465 722c 2070 6f73 7369 626c  ylinder, possibl
+00025270: 7920 666f 7220 6120 6665 7720 7469 6d65  y for a few time
+00025280: 732e 2229 3b0a 2f2f 2020 204c 203d 2035  s.");.//   L = 5
+00025290: 2a6c 656e 2874 6578 7429 3b0a 2f2f 2020  *len(text);.//  
+000252a0: 206d 6178 616e 6720 3d20 3336 302a 4c2f   maxang = 360*L/
+000252b0: 2850 492a 3530 293b 0a2f 2f20 2020 7370  (PI*50);.//   sp
+000252c0: 6972 616c 203d 205b 666f 7228 613d 5b30  iral = [for(a=[0
+000252d0: 3a31 3a6d 6178 616e 675d 2920 5b32 352a  :1:maxang]) [25*
+000252e0: 636f 7328 6129 2c20 3235 2a73 696e 2861  cos(a), 25*sin(a
+000252f0: 292c 2031 302d 3330 2f6d 6178 616e 672a  ), 10-30/maxang*
+00025300: 615d 5d3b 0a2f 2f20 2020 6379 6c28 643d  a]];.//   cyl(d=
+00025310: 3530 2c20 6c3d 3530 2c20 2466 6e3d 3132  50, l=50, $fn=12
+00025320: 3029 3b0a 2f2f 2020 2070 6174 685f 7465  0);.//   path_te
+00025330: 7874 2873 7069 7261 6c2c 2074 6578 742c  xt(spiral, text,
+00025340: 2073 697a 653d 352c 206c 6574 7465 7273   size=5, letters
+00025350: 697a 653d 352f 312e 322c 2066 6f6e 743d  ize=5/1.2, font=
+00025360: 2243 6f75 7269 6572 222c 2074 6869 636b  "Courier", thick
+00025370: 6e65 7373 3d32 293b 0a2f 2f20 4578 616d  ness=2);.// Exam
+00025380: 706c 6528 3344 2c4e 6f53 6361 6c65 7329  ple(3D,NoScales)
+00025390: 3a20 4865 7265 2074 6865 2074 6578 7420  : Here the text 
+000253a0: 6261 7365 6c69 6e65 2073 6974 7320 6f6e  baseline sits on
+000253b0: 2074 6865 2070 6174 682e 2020 284e 6f74   the path.  (Not
+000253c0: 6520 7468 6520 6465 6661 756c 7420 6f72  e the default or
+000253d0: 6965 6e74 6174 696f 6e20 6d61 6b65 7320  ientation makes 
+000253e0: 7465 7874 2072 6561 6461 626c 6520 6672  text readable fr
+000253f0: 6f6d 2062 656c 6f77 2c20 736f 2077 6520  om below, so we 
+00025400: 7370 6563 6966 7920 7468 6520 6e6f 726d  specify the norm
+00025410: 616c 2e29 0a2f 2f20 2020 7061 7468 203d  al.).//   path =
+00025420: 2061 7263 2831 3030 2c20 706f 696e 7473   arc(100, points
+00025430: 203d 205b 5b2d 3230 2c20 302c 2032 305d   = [[-20, 0, 20]
+00025440: 2c20 5b30 2c30 2c35 5d2c 205b 3230 2c30  , [0,0,5], [20,0
+00025450: 2c32 305d 5d29 3b0a 2f2f 2020 2063 6f6c  ,20]]);.//   col
+00025460: 6f72 2822 7265 6422 2973 7472 6f6b 6528  or("red")stroke(
+00025470: 7061 7468 2c77 6964 7468 3d2e 3229 3b0a  path,width=.2);.
+00025480: 2f2f 2020 2070 6174 685f 7465 7874 2870  //   path_text(p
+00025490: 6174 682c 2022 4578 616d 706c 6520 5465  ath, "Example Te
+000254a0: 7874 222c 2073 697a 653d 352c 206c 6574  xt", size=5, let
+000254b0: 7465 7273 697a 653d 352f 312e 322c 2066  tersize=5/1.2, f
+000254c0: 6f6e 743d 2243 6f75 7269 6572 222c 206e  ont="Courier", n
+000254d0: 6f72 6d61 6c3d 4652 4f4e 5429 3b0a 2f2f  ormal=FRONT);.//
+000254e0: 2045 7861 6d70 6c65 2833 442c 4e6f 5363   Example(3D,NoSc
+000254f0: 616c 6573 293a 2049 6620 7765 2075 7365  ales): If we use
+00025500: 2074 6f70 2074 6f20 6f72 6965 6e74 2074   top to orient t
+00025510: 6865 2074 6578 7420 7570 7761 7264 2c20  he text upward, 
+00025520: 7468 6520 7465 7874 2062 6173 656c 696e  the text baselin
+00025530: 6520 6973 206e 6f20 6c6f 6e67 6572 2061  e is no longer a
+00025540: 6c69 676e 6564 2077 6974 6820 7468 6520  ligned with the 
+00025550: 7061 7468 2e0a 2f2f 2020 2070 6174 6820  path..//   path 
+00025560: 3d20 6172 6328 3130 302c 2070 6f69 6e74  = arc(100, point
+00025570: 7320 3d20 5b5b 2d32 302c 2030 2c20 3230  s = [[-20, 0, 20
+00025580: 5d2c 205b 302c 302c 355d 2c20 5b32 302c  ], [0,0,5], [20,
+00025590: 302c 3230 5d5d 293b 0a2f 2f20 2020 636f  0,20]]);.//   co
+000255a0: 6c6f 7228 2272 6564 2229 7374 726f 6b65  lor("red")stroke
+000255b0: 2870 6174 682c 7769 6474 683d 2e32 293b  (path,width=.2);
+000255c0: 0a2f 2f20 2020 7061 7468 5f74 6578 7428  .//   path_text(
+000255d0: 7061 7468 2c20 2245 7861 6d70 6c65 2054  path, "Example T
+000255e0: 6578 7422 2c20 7369 7a65 3d35 2c20 6c65  ext", size=5, le
+000255f0: 7474 6572 7369 7a65 3d35 2f31 2e32 2c20  ttersize=5/1.2, 
+00025600: 666f 6e74 3d22 436f 7572 6965 7222 2c20  font="Courier", 
+00025610: 746f 703d 5550 293b 0a2f 2f20 4578 616d  top=UP);.// Exam
+00025620: 706c 6528 3344 2c4d 6564 2c4e 6f53 6361  ple(3D,Med,NoSca
+00025630: 6c65 7329 3a20 5468 6973 2073 696e 6520  les): This sine 
+00025640: 7761 7665 2077 7261 7070 6564 2061 726f  wave wrapped aro
+00025650: 756e 6420 7468 6520 6379 6c69 6e64 6572  und the cylinder
+00025660: 2068 6173 2061 2074 7769 7374 696e 6720   has a twisting 
+00025670: 6e6f 726d 616c 2074 6861 7420 7072 6f64  normal that prod
+00025680: 7563 6573 2077 696c 6420 6c65 7474 6572  uces wild letter
+00025690: 206c 6179 6f75 742e 2020 5765 2066 6978   layout.  We fix
+000256a0: 2069 7420 7769 7468 2061 2063 7573 746f   it with a custo
+000256b0: 6d20 6e6f 726d 616c 2077 6869 6368 2069  m normal which i
+000256c0: 7320 6469 6666 6572 656e 7420 6174 2065  s different at e
+000256d0: 7665 7279 2070 6174 6820 706f 696e 742e  very path point.
+000256e0: 0a2f 2f20 2020 7061 7468 203d 205b 666f  .//   path = [fo
+000256f0: 7228 7468 6574 6120 3d20 5b30 3a33 3630  r(theta = [0:360
+00025700: 5d29 205b 3235 2a63 6f73 2874 6865 7461  ]) [25*cos(theta
+00025710: 292c 2032 352a 7369 6e28 7468 6574 6129  ), 25*sin(theta)
+00025720: 2c20 342a 636f 7328 7468 6574 612a 3429  , 4*cos(theta*4)
+00025730: 5d5d 3b0a 2f2f 2020 206e 6f72 6d61 6c20  ]];.//   normal 
+00025740: 3d20 5b66 6f72 2874 6865 7461 203d 205b  = [for(theta = [
+00025750: 303a 3336 305d 2920 5b63 6f73 2874 6865  0:360]) [cos(the
+00025760: 7461 292c 2073 696e 2874 6865 7461 292c  ta), sin(theta),
+00025770: 305d 5d3b 0a2f 2f20 2020 7a72 6f74 282d  0]];.//   zrot(-
+00025780: 3132 3029 0a2f 2f20 2020 6469 6666 6572  120).//   differ
+00025790: 656e 6365 2829 7b0a 2f2f 2020 2020 2063  ence(){.//     c
+000257a0: 796c 2872 3d32 352c 2068 3d32 302c 2024  yl(r=25, h=20, $
+000257b0: 666e 3d31 3230 293b 0a2f 2f20 2020 2020  fn=120);.//     
+000257c0: 7061 7468 5f74 6578 7428 7061 7468 2c20  path_text(path, 
+000257d0: 2241 2073 696e 6520 7761 7665 2077 6967  "A sine wave wig
+000257e0: 676c 6573 222c 2066 6f6e 743d 2243 6f75  gles", font="Cou
+000257f0: 7269 6572 222c 206c 6574 7465 7273 697a  rier", lettersiz
+00025800: 653d 352f 312e 322c 2073 697a 653d 352c  e=5/1.2, size=5,
+00025810: 206e 6f72 6d61 6c3d 6e6f 726d 616c 293b   normal=normal);
+00025820: 0a2f 2f20 2020 7d0a 2f2f 2045 7861 6d70  .//   }.// Examp
+00025830: 6c65 2833 442c 4d65 642c 4e6f 5363 616c  le(3D,Med,NoScal
+00025840: 6573 293a 2054 6865 2070 6174 6820 6365  es): The path ce
+00025850: 6e74 6572 206f 6620 6375 7276 6174 7572  nter of curvatur
+00025860: 6520 6368 616e 6765 732c 2061 6e64 2074  e changes, and t
+00025870: 6865 2074 6578 7420 666c 6970 732e 0a2f  he text flips../
+00025880: 2f20 2020 7061 7468 203d 2020 7a72 6f74  /   path =  zrot
+00025890: 282d 3132 302c 703d 7061 7468 3364 2820  (-120,p=path3d( 
+000258a0: 636f 6e63 6174 2861 7263 2831 3030 2c20  concat(arc(100, 
+000258b0: 723d 3235 2c20 616e 676c 653d 5b30 2c39  r=25, angle=[0,9
+000258c0: 305d 292c 2062 6163 6b28 3530 2c70 3d61  0]), back(50,p=a
+000258d0: 7263 2831 3030 2c20 723d 3235 2c20 616e  rc(100, r=25, an
+000258e0: 676c 653d 5b32 3638 2c20 3138 305d 2929  gle=[268, 180]))
+000258f0: 2929 293b 0a2f 2f20 2020 636f 6c6f 7228  )));.//   color(
+00025900: 2272 6564 2229 7374 726f 6b65 2870 6174  "red")stroke(pat
+00025910: 682c 7769 6474 683d 2e32 293b 0a2f 2f20  h,width=.2);.// 
+00025920: 2020 7061 7468 5f74 6578 7428 7061 7468    path_text(path
+00025930: 2c20 2241 2073 686f 7274 6572 2065 7861  , "A shorter exa
+00025940: 6d70 6c65 222c 2020 7369 7a65 3d35 2c20  mple",  size=5, 
+00025950: 6c65 7474 6572 7369 7a65 3d35 2f31 2e32  lettersize=5/1.2
+00025960: 2c20 666f 6e74 3d22 436f 7572 6965 7222  , font="Courier"
+00025970: 2c20 7468 6963 6b6e 6573 733d 3229 3b0a  , thickness=2);.
+00025980: 2f2f 2045 7861 6d70 6c65 2833 442c 4d65  // Example(3D,Me
+00025990: 642c 4e6f 5363 616c 6573 293a 2057 6520  d,NoScales): We 
+000259a0: 6361 6e20 6669 7820 6974 2077 6974 6820  can fix it with 
+000259b0: 746f 703a 0a2f 2f20 2020 7061 7468 203d  top:.//   path =
+000259c0: 2020 7a72 6f74 282d 3132 302c 703d 7061    zrot(-120,p=pa
+000259d0: 7468 3364 2820 636f 6e63 6174 2861 7263  th3d( concat(arc
+000259e0: 2831 3030 2c20 723d 3235 2c20 616e 676c  (100, r=25, angl
+000259f0: 653d 5b30 2c39 305d 292c 2062 6163 6b28  e=[0,90]), back(
+00025a00: 3530 2c70 3d61 7263 2831 3030 2c20 723d  50,p=arc(100, r=
+00025a10: 3235 2c20 616e 676c 653d 5b32 3638 2c20  25, angle=[268, 
+00025a20: 3138 305d 2929 2929 293b 0a2f 2f20 2020  180])))));.//   
+00025a30: 636f 6c6f 7228 2272 6564 2229 7374 726f  color("red")stro
+00025a40: 6b65 2870 6174 682c 7769 6474 683d 2e32  ke(path,width=.2
+00025a50: 293b 0a2f 2f20 2020 7061 7468 5f74 6578  );.//   path_tex
+00025a60: 7428 7061 7468 2c20 2241 2073 686f 7274  t(path, "A short
+00025a70: 6572 2065 7861 6d70 6c65 222c 2020 7369  er example",  si
+00025a80: 7a65 3d35 2c20 6c65 7474 6572 7369 7a65  ze=5, lettersize
+00025a90: 3d35 2f31 2e32 2c20 666f 6e74 3d22 436f  =5/1.2, font="Co
+00025aa0: 7572 6965 7222 2c20 7468 6963 6b6e 6573  urier", thicknes
+00025ab0: 733d 322c 2074 6f70 3d55 5029 3b0a 2f2f  s=2, top=UP);.//
+00025ac0: 2045 7861 6d70 6c65 2832 442c 4e6f 5363   Example(2D,NoSc
+00025ad0: 616c 6573 293a 2057 6974 6820 6120 3244  ales): With a 2D
+00025ae0: 2070 6174 6820 696e 7374 6561 6420 6f66   path instead of
+00025af0: 2033 4420 7468 6572 6527 7320 6e6f 2061   3D there's no a
+00025b00: 6d62 6967 7569 7479 2061 626f 7574 2064  mbiguity about d
+00025b10: 6972 6563 7469 6f6e 2061 6e64 2069 7420  irection and it 
+00025b20: 776f 726b 7320 6279 2064 6566 6175 6c74  works by default
+00025b30: 3a0a 2f2f 2020 2070 6174 6820 3d20 207a  :.//   path =  z
+00025b40: 726f 7428 2d31 3230 2c70 3d63 6f6e 6361  rot(-120,p=conca
+00025b50: 7428 6172 6328 3130 302c 2072 3d32 352c  t(arc(100, r=25,
+00025b60: 2061 6e67 6c65 3d5b 302c 3930 5d29 2c20   angle=[0,90]), 
+00025b70: 6261 636b 2835 302c 703d 6172 6328 3130  back(50,p=arc(10
+00025b80: 302c 2072 3d32 352c 2061 6e67 6c65 3d5b  0, r=25, angle=[
+00025b90: 3236 382c 2031 3830 5d29 2929 293b 0a2f  268, 180]))));./
+00025ba0: 2f20 2020 636f 6c6f 7228 2272 6564 2229  /   color("red")
+00025bb0: 7374 726f 6b65 2870 6174 682c 7769 6474  stroke(path,widt
+00025bc0: 683d 2e32 293b 0a2f 2f20 2020 7061 7468  h=.2);.//   path
+00025bd0: 5f74 6578 7428 7061 7468 2c20 2241 2073  _text(path, "A s
+00025be0: 686f 7274 6572 2065 7861 6d70 6c65 222c  horter example",
+00025bf0: 2020 7369 7a65 3d35 2c20 6c65 7474 6572    size=5, letter
+00025c00: 7369 7a65 3d35 2f31 2e32 2c20 666f 6e74  size=5/1.2, font
+00025c10: 3d22 436f 7572 6965 7222 293b 0a2f 2f20  ="Courier");.// 
+00025c20: 4578 616d 706c 6528 3344 2c4e 6f53 6361  Example(3D,NoSca
+00025c30: 6c65 7329 3a20 5468 6520 6b65 726e 2070  les): The kern p
+00025c40: 6172 616d 6574 6572 206c 6574 7320 796f  arameter lets yo
+00025c50: 7520 6164 6a75 7374 2074 6865 206c 6574  u adjust the let
+00025c60: 7465 7220 7370 6163 696e 6720 6569 7468  ter spacing eith
+00025c70: 6572 2077 6974 6820 6120 756e 6966 6f72  er with a unifor
+00025c80: 6d20 7661 6c75 6520 666f 7220 6561 6368  m value for each
+00025c90: 206c 6574 7465 722c 206f 7220 7769 7468   letter, or with
+00025ca0: 2061 6e20 6172 7261 7920 746f 206d 616b   an array to mak
+00025cb0: 6520 6164 6a75 7374 6d65 6e74 7320 7468  e adjustments th
+00025cc0: 726f 7567 686f 7574 2074 6865 2074 6578  roughout the tex
+00025cd0: 742e 2020 4865 7265 2077 6520 7368 6f77  t.  Here we show
+00025ce0: 2061 2063 6173 6520 7768 6572 6520 6164   a case where ad
+00025cf0: 6469 6e67 2073 6f6d 6520 6578 7472 6120  ding some extra 
+00025d00: 7370 6163 6520 6769 7665 7320 6120 6265  space gives a be
+00025d10: 7474 6572 206c 6f6f 6b20 696e 2061 2074  tter look in a t
+00025d20: 6967 6874 2063 6972 636c 652e 2020 5768  ight circle.  Wh
+00025d30: 656e 2074 6578 746d 6574 7269 6373 2061  en textmetrics a
+00025d40: 7265 206f 6666 2c20 606c 6574 7465 7273  re off, `letters
+00025d50: 697a 6560 2063 616e 2064 6f20 7468 6973  ize` can do this
+00025d60: 206a 6f62 2c20 6275 7420 7769 7468 2074   job, but with t
+00025d70: 6578 746d 6574 7269 6373 2c20 796f 7527  extmetrics, you'
+00025d80: 6c6c 206e 6565 6420 746f 2075 7365 2060  ll need to use `
+00025d90: 6b65 726e 6020 746f 206d 616b 6520 6164  kern` to make ad
+00025da0: 6a75 7374 6d65 6e74 7320 7265 6c61 7469  justments relati
+00025db0: 7665 2074 6f20 7468 6520 7465 7874 206d  ve to the text m
+00025dc0: 6574 7269 6320 7369 7a65 732e 0a2f 2f20  etric sizes..// 
+00025dd0: 2020 7061 7468 203d 2070 6174 6833 6428    path = path3d(
+00025de0: 6172 6328 3130 302c 2072 3d31 322c 2061  arc(100, r=12, a
+00025df0: 6e67 6c65 3d5b 3135 302c 2034 3530 5d29  ngle=[150, 450])
+00025e00: 293b 0a2f 2f20 2020 636f 6c6f 7228 2272  );.//   color("r
+00025e10: 6564 2229 7374 726f 6b65 2870 6174 682c  ed")stroke(path,
+00025e20: 2077 6964 7468 3d2e 3329 3b0a 2f2f 2020   width=.3);.//  
+00025e30: 206b 6572 6e20 3d20 5b31 2c31 2e32 2c31   kern = [1,1.2,1
+00025e40: 2c31 2c2e 332c 2d2e 322c 312c 302c 2e38  ,1,.3,-.2,1,0,.8
+00025e50: 2c31 2c31 2e31 5d3b 0a2f 2f20 2020 7061  ,1,1.1];.//   pa
+00025e60: 7468 5f74 6578 7428 7061 7468 2c20 2245  th_text(path, "E
+00025e70: 7861 6d70 6c65 2074 6578 7422 2c20 666f  xample text", fo
+00025e80: 6e74 3d22 436f 7572 6965 7222 2c20 7369  nt="Courier", si
+00025e90: 7a65 3d35 2c20 6c65 7474 6572 7369 7a65  ze=5, lettersize
+00025ea0: 203d 2035 2f31 2e32 2c20 6b65 726e 3d6b   = 5/1.2, kern=k
+00025eb0: 6572 6e2c 206e 6f72 6d61 6c3d 5550 293b  ern, normal=UP);
+00025ec0: 0a0a 6d6f 6475 6c65 2070 6174 685f 7465  ..module path_te
+00025ed0: 7874 2870 6174 682c 2074 6578 742c 2066  xt(path, text, f
+00025ee0: 6f6e 742c 2073 697a 652c 2074 6869 636b  ont, size, thick
+00025ef0: 6e65 7373 2c20 6c65 7474 6572 7369 7a65  ness, lettersize
+00025f00: 2c20 6f66 6673 6574 3d30 2c20 7265 7665  , offset=0, reve
+00025f10: 7273 653d 6661 6c73 652c 206e 6f72 6d61  rse=false, norma
+00025f20: 6c2c 2074 6f70 2c20 6365 6e74 6572 3d66  l, top, center=f
+00025f30: 616c 7365 2c0a 2020 2020 2020 2020 2020  alse,.          
+00025f40: 2020 2020 2020 2074 6578 746d 6574 7269         textmetri
+00025f50: 6373 3d66 616c 7365 2c20 6b65 726e 3d30  cs=false, kern=0
+00025f60: 2c20 6865 6967 6874 2c68 2c20 7661 6c69  , height,h, vali
+00025f70: 676e 3d22 6261 7365 6c69 6e65 222c 206c  gn="baseline", l
+00025f80: 616e 6775 6167 652c 2073 6372 6970 7429  anguage, script)
+00025f90: 0a7b 0a20 206e 6f5f 6368 696c 6472 656e  .{.  no_children
+00025fa0: 2824 6368 696c 6472 656e 293b 0a20 2064  ($children);.  d
+00025fb0: 756d 6d79 323d 6173 7365 7274 2869 735f  ummy2=assert(is_
+00025fc0: 7061 7468 2870 6174 682c 5b32 2c33 5d29  path(path,[2,3])
+00025fd0: 2c22 4d75 7374 2073 7570 706c 7920 6120  ,"Must supply a 
+00025fe0: 3264 206f 7220 3364 2070 6174 6822 290a  2d or 3d path").
+00025ff0: 2020 2020 2020 2020 2061 7373 6572 7428           assert(
+00026000: 6e75 6d5f 6465 6669 6e65 6428 5b6e 6f72  num_defined([nor
+00026010: 6d61 6c2c 746f 705d 293c 3d31 2c20 2243  mal,top])<=1, "C
+00026020: 616e 6e6f 7420 6465 6669 6e65 2062 6f74  annot define bot
+00026030: 6820 5c22 6e6f 726d 616c 5c22 2061 6e64  h \"normal\" and
+00026040: 205c 2274 6f70 5c22 2229 0a20 2020 2020   \"top\"").     
+00026050: 2020 2020 6173 7365 7274 2861 6c6c 5f70      assert(all_p
+00026060: 6f73 6974 6976 6528 5b73 697a 655d 292c  ositive([size]),
+00026070: 2022 4d75 7374 2067 6976 6520 706f 7369   "Must give posi
+00026080: 7469 7665 2074 6578 7420 7369 7a65 2229  tive text size")
+00026090: 3b0a 2020 6469 6d20 3d20 6c65 6e28 7061  ;.  dim = len(pa
+000260a0: 7468 5b30 5d29 3b0a 2020 6e6f 726d 616c  th[0]);.  normal
+000260b0: 6f6b 203d 2069 735f 756e 6465 6628 6e6f  ok = is_undef(no
+000260c0: 726d 616c 2920 7c7c 2069 735f 7665 6374  rmal) || is_vect
+000260d0: 6f72 286e 6f72 6d61 6c2c 3329 207c 7c20  or(normal,3) || 
+000260e0: 2869 735f 7061 7468 286e 6f72 6d61 6c2c  (is_path(normal,
+000260f0: 3329 2026 2620 6c65 6e28 6e6f 726d 616c  3) && len(normal
+00026100: 293d 3d6c 656e 2870 6174 6829 293b 0a20  )==len(path));. 
+00026110: 2074 6f70 6f6b 203d 2069 735f 756e 6465   topok = is_unde
+00026120: 6628 746f 7029 207c 7c20 6973 5f76 6563  f(top) || is_vec
+00026130: 746f 7228 746f 702c 6469 6d29 207c 7c20  tor(top,dim) || 
+00026140: 2864 696d 3d3d 3220 2626 2069 735f 7665  (dim==2 && is_ve
+00026150: 6374 6f72 2874 6f70 2c33 2920 2626 2074  ctor(top,3) && t
+00026160: 6f70 5b32 5d3d 3d30 290a 2020 2020 2020  op[2]==0).      
+00026170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026180: 2020 7c7c 2028 6973 5f70 6174 6828 746f    || (is_path(to
+00026190: 702c 6469 6d29 2026 2620 6c65 6e28 746f  p,dim) && len(to
+000261a0: 7029 3d3d 6c65 6e28 7061 7468 2929 3b0a  p)==len(path));.
+000261b0: 2020 6475 6d6d 7934 203d 2061 7373 6572    dummy4 = asser
+000261c0: 7428 6469 6d3d 3d33 207c 7c20 2161 6e79  t(dim==3 || !any
+000261d0: 5f64 6566 696e 6564 285b 7468 6963 6b6e  _defined([thickn
+000261e0: 6573 732c 682c 6865 6967 6874 5d29 2c20  ess,h,height]), 
+000261f0: 2243 616e 6e6f 7420 6769 7665 2061 2074  "Cannot give a t
+00026200: 6869 636b 6e65 7373 206f 7220 6865 6967  hickness or heig
+00026210: 6874 2077 6974 6820 3264 2070 6174 6822  ht with 2d path"
+00026220: 290a 2020 2020 2020 2020 2020 2061 7373  ).           ass
+00026230: 6572 7428 6469 6d3d 3d33 207c 7c20 2172  ert(dim==3 || !r
+00026240: 6576 6572 7365 2c20 2252 6576 6572 7365  everse, "Reverse
+00026250: 206e 6f74 2061 6c6c 6f77 6564 2077 6974   not allowed wit
+00026260: 6820 3264 2070 6174 6822 290a 2020 2020  h 2d path").    
+00026270: 2020 2020 2020 2061 7373 6572 7428 6469         assert(di
+00026280: 6d3d 3d33 207c 7c20 6f66 6673 6574 3d3d  m==3 || offset==
+00026290: 302c 2022 4361 6e6e 6f74 2067 6976 6520  0, "Cannot give 
+000262a0: 6f66 6673 6574 2077 6974 6820 3264 2070  offset with 2d p
+000262b0: 6174 6822 290a 2020 2020 2020 2020 2020  ath").          
+000262c0: 2061 7373 6572 7428 6469 6d3d 3d33 207c   assert(dim==3 |
+000262d0: 7c20 6973 5f75 6e64 6566 286e 6f72 6d61  | is_undef(norma
+000262e0: 6c29 2c20 2243 616e 6e6f 7420 6465 6669  l), "Cannot defi
+000262f0: 6e65 205c 226e 6f72 6d61 6c5c 2220 666f  ne \"normal\" fo
+00026300: 7220 6120 3264 2070 6174 682c 206f 6e6c  r a 2d path, onl
+00026310: 7920 5c22 746f 705c 2222 290a 2020 2020  y \"top\"").    
+00026320: 2020 2020 2020 2061 7373 6572 7428 6e6f         assert(no
+00026330: 726d 616c 6f6b 2c22 5c22 6e6f 726d 616c  rmalok,"\"normal
+00026340: 5c22 206d 7573 7420 6265 2061 2076 6563  \" must be a vec
+00026350: 746f 7220 6f72 2070 6174 6820 636f 6d70  tor or path comp
+00026360: 6174 6962 6c65 2077 6974 6820 7468 6520  atible with the 
+00026370: 6769 7665 6e20 7061 7468 2229 0a20 2020  given path").   
+00026380: 2020 2020 2020 2020 6173 7365 7274 2874          assert(t
+00026390: 6f70 6f6b 2c22 5c22 746f 705c 2220 6d75  opok,"\"top\" mu
+000263a0: 7374 2062 6520 6120 7665 6374 6f72 206f  st be a vector o
+000263b0: 7220 7061 7468 2063 6f6d 7061 7469 626c  r path compatibl
+000263c0: 6520 7769 7468 2074 6865 2067 6976 656e  e with the given
+000263d0: 2070 6174 6822 293b 0a20 2074 6869 636b   path");.  thick
+000263e0: 6e65 7373 203d 206f 6e65 5f64 6566 696e  ness = one_defin
+000263f0: 6564 285b 7468 6963 6b6e 6573 732c 682c  ed([thickness,h,
+00026400: 6865 6967 6874 5d2c 2274 6869 636b 6e65  height],"thickne
+00026410: 7373 2c68 2c68 6569 6768 7422 2c64 666c  ss,h,height",dfl
+00026420: 743d 3129 3b0a 2020 6e6f 726d 616c 203d  t=1);.  normal =
+00026430: 2069 735f 7665 6374 6f72 286e 6f72 6d61   is_vector(norma
+00026440: 6c29 203f 2072 6570 6561 7428 6e6f 726d  l) ? repeat(norm
+00026450: 616c 2c20 6c65 6e28 7061 7468 2929 0a20  al, len(path)). 
+00026460: 2020 2020 2020 2020 3a20 6973 5f64 6566          : is_def
+00026470: 286e 6f72 6d61 6c29 203f 206e 6f72 6d61  (normal) ? norma
+00026480: 6c0a 2020 2020 2020 2020 203a 2075 6e64  l.         : und
+00026490: 6566 3b0a 0a20 2074 6f70 203d 2069 735f  ef;..  top = is_
+000264a0: 7665 6374 6f72 2874 6f70 2920 3f20 7265  vector(top) ? re
+000264b0: 7065 6174 2864 696d 3d3d 323f 706f 696e  peat(dim==2?poin
+000264c0: 7432 6428 746f 7029 3a74 6f70 2c20 6c65  t2d(top):top, le
+000264d0: 6e28 7061 7468 2929 0a20 2020 2020 2020  n(path)).       
+000264e0: 2020 3a20 6973 5f64 6566 2874 6f70 2920    : is_def(top) 
+000264f0: 3f20 746f 700a 2020 2020 2020 2020 203a  ? top.         :
+00026500: 2075 6e64 6566 3b0a 0a20 206b 6572 6e20   undef;..  kern 
+00026510: 3d20 666f 7263 655f 6c69 7374 286b 6572  = force_list(ker
+00026520: 6e2c 206c 656e 2874 6578 7429 2d31 293b  n, len(text)-1);
+00026530: 0a20 2064 756d 6d79 3320 3d20 6173 7365  .  dummy3 = asse
+00026540: 7274 2869 735f 6c69 7374 286b 6572 6e29  rt(is_list(kern)
+00026550: 2026 2620 6c65 6e28 6b65 726e 293d 3d6c   && len(kern)==l
+00026560: 656e 2874 6578 7429 2d31 2c20 226b 6572  en(text)-1, "ker
+00026570: 6e20 6d75 7374 2062 6520 6120 7363 616c  n must be a scal
+00026580: 6172 206f 7220 6c69 7374 2077 686f 7365  ar or list whose
+00026590: 206c 656e 6774 6820 6973 206c 656e 2874   length is len(t
+000265a0: 6578 7429 2d31 2229 3b0a 0a20 206c 7369  ext)-1");..  lsi
+000265b0: 7a65 203d 2069 735f 6465 6628 6c65 7474  ze = is_def(lett
+000265c0: 6572 7369 7a65 2920 3f20 666f 7263 655f  ersize) ? force_
+000265d0: 6c69 7374 286c 6574 7465 7273 697a 652c  list(lettersize,
+000265e0: 206c 656e 2874 6578 7429 290a 2020 2020   len(text)).    
+000265f0: 2020 2020 3a20 7465 7874 6d65 7472 6963      : textmetric
+00026600: 7320 3f20 5b66 6f72 286c 6574 7465 723d  s ? [for(letter=
+00026610: 7465 7874 2920 6c65 7428 743d 7465 7874  text) let(t=text
+00026620: 6d65 7472 6963 7328 6c65 7474 6572 2c20  metrics(letter, 
+00026630: 666f 6e74 3d66 6f6e 742c 2073 697a 653d  font=font, size=
+00026640: 7369 7a65 2929 2074 2e61 6476 616e 6365  size)) t.advance
+00026650: 5b30 5d5d 0a20 2020 2020 2020 203a 2061  [0]].        : a
+00026660: 7373 6572 7428 6661 6c73 652c 2022 7465  ssert(false, "te
+00026670: 7874 6d65 7472 6963 7320 6469 7361 626c  xtmetrics disabl
+00026680: 6564 3a20 4d75 7374 2073 7065 6369 6679  ed: Must specify
+00026690: 206c 6574 7465 7220 7369 7a65 2229 3b0a   letter size");.
+000266a0: 2020 6c63 656e 7465 7220 3d20 636f 6e76    lcenter = conv
+000266b0: 6f6c 7665 286c 7369 7a65 2c5b 312c 315d  olve(lsize,[1,1]
+000266c0: 2f32 292b 5b30 2c65 6163 6820 6b65 726e  /2)+[0,each kern
+000266d0: 2c30 5d20 3b0a 2020 7465 7874 6c65 6e67  ,0] ;.  textleng
+000266e0: 7468 203d 2073 756d 286c 7369 7a65 292b  th = sum(lsize)+
+000266f0: 7375 6d28 6b65 726e 293b 0a0a 2020 6173  sum(kern);..  as
+00026700: 6365 6e74 203d 2021 7465 7874 6d65 7472  cent = !textmetr
+00026710: 6963 7320 3f20 756e 6465 660a 2020 2020  ics ? undef.    
+00026720: 2020 2020 203a 2074 6578 746d 6574 7269       : textmetri
+00026730: 6373 2874 6578 742c 2066 6f6e 743d 666f  cs(text, font=fo
+00026740: 6e74 2c20 7369 7a65 3d73 697a 6529 2e61  nt, size=size).a
+00026750: 7363 656e 743b 0a20 2064 6573 6365 6e74  scent;.  descent
+00026760: 203d 2021 7465 7874 6d65 7472 6963 7320   = !textmetrics 
+00026770: 3f20 756e 6465 660a 2020 2020 2020 2020  ? undef.        
+00026780: 2020 3a20 7465 7874 6d65 7472 6963 7328    : textmetrics(
+00026790: 7465 7874 2c20 666f 6e74 3d66 6f6e 742c  text, font=font,
+000267a0: 2073 697a 653d 7369 7a65 292e 6465 7363   size=size).desc
+000267b0: 656e 743b 0a0a 2020 7661 646a 7573 746d  ent;..  vadjustm
+000267c0: 656e 7420 3d20 6973 5f6e 756d 2876 616c  ent = is_num(val
+000267d0: 6967 6e29 203f 202d 7661 6c69 676e 0a20  ign) ? -valign. 
+000267e0: 2020 2020 2020 2020 2020 2020 203a 2021               : !
+000267f0: 7465 7874 6d65 7472 6963 7320 3f20 6173  textmetrics ? as
+00026800: 7365 7274 2876 616c 6967 6e3d 3d22 6261  sert(valign=="ba
+00026810: 7365 6c69 6e65 222c 2276 616c 6967 6e20  seline","valign 
+00026820: 7265 7175 6972 6573 2074 6578 746d 6574  requires textmet
+00026830: 7269 6373 2073 7570 706f 7274 2229 2030  rics support") 0
+00026840: 0a20 2020 2020 2020 2020 2020 2020 203a  .              :
+00026850: 206c 6574 280a 2020 2020 2020 2020 2020   let(.          
+00026860: 2020 2020 2020 2020 2020 2074 6162 6c65             table
+00026870: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+00026880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026890: 2020 205b 2262 6173 656c 696e 6522 2c20     ["baseline", 
+000268a0: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+000268b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000268c0: 2020 5b22 746f 7022 2c20 2d61 7363 656e    ["top", -ascen
+000268d0: 745d 2c0a 2020 2020 2020 2020 2020 2020  t],.            
+000268e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000268f0: 2020 5b22 626f 7474 6f6d 222c 2064 6573    ["bottom", des
+00026900: 6365 6e74 5d2c 0a20 2020 2020 2020 2020  cent],.         
+00026910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026920: 2020 2020 205b 2263 656e 7465 7222 2c20       ["center", 
+00026930: 2864 6573 6365 6e74 2d61 7363 656e 7429  (descent-ascent)
+00026940: 2f32 5d0a 2020 2020 2020 2020 2020 2020  /2].            
+00026950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026960: 205d 2c0a 2020 2020 2020 2020 2020 2020   ],.            
+00026970: 2020 2020 2020 2020 206d 6174 6368 203d           match =
+00026980: 205b 666f 7228 693d 6964 7828 7461 626c   [for(i=idx(tabl
+00026990: 6529 2920 6966 2028 7374 6172 7473 5f77  e)) if (starts_w
+000269a0: 6974 6828 7661 6c69 676e 2c74 6162 6c65  ith(valign,table
+000269b0: 5b69 5d5b 305d 2929 2069 5d0a 2020 2020  [i][0])) i].    
+000269c0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000269d0: 2020 2020 2020 2020 2020 2020 2020 6173                as
+000269e0: 7365 7274 286c 656e 286d 6174 6368 293d  sert(len(match)=
+000269f0: 3d31 2c20 2249 6e76 616c 6964 2076 616c  =1, "Invalid val
+00026a00: 6967 6e20 7661 6c75 6522 290a 2020 2020  ign value").    
+00026a10: 2020 2020 2020 2020 2020 2020 7461 626c              tabl
+00026a20: 655b 6d61 7463 685b 305d 5d5b 315d 202d  e[match[0]][1] -
+00026a30: 2070 6172 7365 5f6e 756d 2873 7562 7374   parse_num(subst
+00026a40: 7228 7661 6c69 676e 2c6c 656e 2874 6162  r(valign,len(tab
+00026a50: 6c65 5b6d 6174 6368 5b30 5d5d 5b30 5d29  le[match[0]][0])
+00026a60: 2929 3b0a 0a20 2064 756d 6d79 3120 3d20  ));..  dummy1 = 
+00026a70: 6173 7365 7274 2874 6578 746c 656e 6774  assert(textlengt
+00026a80: 683c 3d70 6174 685f 6c65 6e67 7468 2870  h<=path_length(p
+00026a90: 6174 6829 2c22 5061 7468 2069 7320 746f  ath),"Path is to
+00026aa0: 6f20 7368 6f72 7420 666f 7220 7468 6520  o short for the 
+00026ab0: 7465 7874 2229 3b0a 0a20 2073 7461 7274  text");..  start
+00026ac0: 203d 2063 656e 7465 7220 3f20 2870 6174   = center ? (pat
+00026ad0: 685f 6c65 6e67 7468 2870 6174 6829 202d  h_length(path) -
+00026ae0: 2074 6578 746c 656e 6774 6829 2f32 203a   textlength)/2 :
+00026af0: 2030 3b0a 2020 200a 2020 7074 7320 3d20   0;.   .  pts = 
+00026b00: 7061 7468 5f63 7574 5f70 6f69 6e74 7328  path_cut_points(
+00026b10: 7061 7468 2c20 6164 645f 7363 616c 6172  path, add_scalar
+00026b20: 285b 2065 6163 6820 6375 6d73 756d 286c  ([ each cumsum(l
+00026b30: 6365 6e74 6572 295d 2c73 7461 7274 2b30  center)],start+0
+00026b40: 2a6c 7369 7a65 5b30 5d2f 3229 2c20 6469  *lsize[0]/2), di
+00026b50: 7265 6374 696f 6e3d 7472 7565 293b 0a0a  rection=true);..
+00026b60: 2020 7573 6572 6e6f 726d 203d 2069 735f    usernorm = is_
+00026b70: 6465 6628 6e6f 726d 616c 293b 0a20 2075  def(normal);.  u
+00026b80: 7365 746f 7020 3d20 6973 5f64 6566 2874  setop = is_def(t
+00026b90: 6f70 293b 0a20 206e 6f72 6d70 7473 203d  op);.  normpts =
+00026ba0: 2069 735f 756e 6465 6628 6e6f 726d 616c   is_undef(normal
+00026bb0: 2920 3f20 2872 6576 6572 7365 3f31 3a2d  ) ? (reverse?1:-
+00026bc0: 3129 2a63 6f6c 756d 6e28 7074 732c 3329  1)*column(pts,3)
+00026bd0: 203a 205f 6375 745f 696e 7465 7270 2870   : _cut_interp(p
+00026be0: 7473 2c70 6174 682c 206e 6f72 6d61 6c29  ts,path, normal)
+00026bf0: 3b0a 2020 746f 7070 7473 203d 2069 735f  ;.  toppts = is_
+00026c00: 756e 6465 6628 746f 7029 203f 2075 6e64  undef(top) ? und
+00026c10: 6566 203a 205f 6375 745f 696e 7465 7270  ef : _cut_interp
+00026c20: 2870 7473 2c70 6174 682c 746f 7029 3b0a  (pts,path,top);.
+00026c30: 2020 6174 7461 6368 6162 6c65 2829 7b0a    attachable(){.
+00026c40: 2020 2020 666f 7220 2869 203d 2069 6478      for (i = idx
+00026c50: 2874 6578 7429 2920 7b0a 2020 2020 2020  (text)) {.      
+00026c60: 7461 6e67 656e 7420 3d20 7074 735b 695d  tangent = pts[i]
+00026c70: 5b32 5d3b 0a20 2020 2020 2063 6865 636b  [2];.      check
+00026c80: 7320 3d0a 2020 2020 2020 2020 2020 6173  s =.          as
+00026c90: 7365 7274 2821 7573 6574 6f70 207c 7c20  sert(!usetop || 
+00026ca0: 2161 7070 726f 7828 7461 6e67 656e 742a  !approx(tangent*
+00026cb0: 746f 7070 7473 5b69 5d2c 6e6f 726d 2874  toppts[i],norm(t
+00026cc0: 6f70 5b69 5d29 2a6e 6f72 6d28 7461 6e67  op[i])*norm(tang
+00026cd0: 656e 7429 292c 0a20 2020 2020 2020 2020  ent)),.         
+00026ce0: 2020 2020 2020 2020 7374 7228 2253 7065          str("Spe
+00026cf0: 6369 6669 6564 2074 6f70 2064 6972 6563  cified top direc
+00026d00: 7469 6f6e 2070 6172 616c 6c65 6c20 746f  tion parallel to
+00026d10: 2070 6174 6820 6174 2063 6861 7261 6374   path at charact
+00026d20: 6572 2022 2c69 2929 0a20 2020 2020 2020  er ",i)).       
+00026d30: 2020 2061 7373 6572 7428 7573 6574 6f70     assert(usetop
+00026d40: 207c 7c20 2161 7070 726f 7828 7461 6e67   || !approx(tang
+00026d50: 656e 742a 6e6f 726d 7074 735b 695d 2c6e  ent*normpts[i],n
+00026d60: 6f72 6d28 6e6f 726d 7074 735b 695d 292a  orm(normpts[i])*
+00026d70: 6e6f 726d 2874 616e 6765 6e74 2929 2c0a  norm(tangent)),.
+00026d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00026d90: 2073 7472 2822 5370 6563 6966 6965 6420   str("Specified 
+00026da0: 6e6f 726d 616c 2064 6972 6563 7469 6f6e  normal direction
+00026db0: 2070 6172 616c 6c65 6c20 746f 2070 6174   parallel to pat
+00026dc0: 6820 6174 2063 6861 7261 6374 6572 2022  h at character "
+00026dd0: 2c69 2929 3b0a 2020 2020 2020 6164 6a75  ,i));.      adju
+00026de0: 7374 6d65 6e74 203d 2075 7365 746f 7020  stment = usetop 
+00026df0: 3f20 2028 7461 6e67 656e 742a 746f 7070  ?  (tangent*topp
+00026e00: 7473 5b69 5d29 2a74 6f70 7074 735b 695d  ts[i])*toppts[i]
+00026e10: 2f28 746f 7070 7473 5b69 5d2a 746f 7070  /(toppts[i]*topp
+00026e20: 7473 5b69 5d29 0a20 2020 2020 2020 2020  ts[i]).         
+00026e30: 2020 2020 2020 2020 3a20 7573 6572 6e6f          : userno
+00026e40: 726d 203f 2020 2874 616e 6765 6e74 2a6e  rm ?  (tangent*n
+00026e50: 6f72 6d70 7473 5b69 5d29 2a6e 6f72 6d70  ormpts[i])*normp
+00026e60: 7473 5b69 5d2f 286e 6f72 6d70 7473 5b69  ts[i]/(normpts[i
+00026e70: 5d2a 6e6f 726d 7074 735b 695d 290a 2020  ]*normpts[i]).  
+00026e80: 2020 2020 2020 2020 2020 2020 2020 203a                 :
+00026e90: 205b 302c 302c 305d 3b0a 2020 2020 2020   [0,0,0];.      
+00026ea0: 6d6f 7665 2870 7473 5b69 5d5b 305d 2920  move(pts[i][0]) 
+00026eb0: 7b0a 2020 2020 2020 2020 6966 2028 6469  {.        if (di
+00026ec0: 6d3d 3d33 2920 7b0a 2020 2020 2020 2020  m==3) {.        
+00026ed0: 2020 6672 616d 655f 6d61 7028 0a20 2020    frame_map(.   
+00026ee0: 2020 2020 2020 2020 2078 3d74 616e 6765           x=tange
+00026ef0: 6e74 2d61 646a 7573 746d 656e 742c 0a20  nt-adjustment,. 
+00026f00: 2020 2020 2020 2020 2020 207a 3d75 7365             z=use
+00026f10: 746f 7020 3f20 756e 6465 6620 3a20 6e6f  top ? undef : no
+00026f20: 726d 7074 735b 695d 2c0a 2020 2020 2020  rmpts[i],.      
+00026f30: 2020 2020 2020 793d 7573 6574 6f70 203f        y=usetop ?
+00026f40: 2074 6f70 7074 735b 695d 203a 2075 6e64   toppts[i] : und
+00026f50: 6566 0a20 2020 2020 2020 2020 2029 2075  ef.          ) u
+00026f60: 7028 6f66 6673 6574 2d74 6869 636b 6e65  p(offset-thickne
+00026f70: 7373 2f32 2920 7b0a 2020 2020 2020 2020  ss/2) {.        
+00026f80: 2020 2020 6c69 6e65 6172 5f65 7874 7275      linear_extru
+00026f90: 6465 2868 6569 6768 743d 7468 6963 6b6e  de(height=thickn
+00026fa0: 6573 7329 0a20 2020 2020 2020 2020 2020  ess).           
+00026fb0: 2020 2062 6163 6b28 7661 646a 7573 746d     back(vadjustm
+00026fc0: 656e 7429 0a20 2020 2020 2020 2020 2020  ent).           
+00026fd0: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+00026fe0: 2020 206c 6566 7428 6c73 697a 655b 695d     left(lsize[i]
+00026ff0: 2f32 290a 2020 2020 2020 2020 2020 2020  /2).            
+00027000: 2020 2020 7465 7874 2874 6578 745b 695d      text(text[i]
+00027010: 2c20 666f 6e74 3d66 6f6e 742c 2073 697a  , font=font, siz
+00027020: 653d 7369 7a65 2c20 6c61 6e67 7561 6765  e=size, language
+00027030: 3d6c 616e 6775 6167 652c 2073 6372 6970  =language, scrip
+00027040: 743d 7363 7269 7074 293b 0a20 2020 2020  t=script);.     
+00027050: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+00027060: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
+00027070: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
+00027080: 2020 2020 6672 616d 655f 6d61 7028 0a20      frame_map(. 
+00027090: 2020 2020 2020 2020 2020 2020 2078 3d70               x=p
+000270a0: 6f69 6e74 3364 2874 616e 6765 6e74 2d61  oint3d(tangent-a
+000270b0: 646a 7573 746d 656e 7429 2c0a 2020 2020  djustment),.    
+000270c0: 2020 2020 2020 2020 2020 793d 706f 696e            y=poin
+000270d0: 7433 6428 7573 6574 6f70 203f 2074 6f70  t3d(usetop ? top
+000270e0: 7074 735b 695d 203a 202d 6e6f 726d 7074  pts[i] : -normpt
+000270f0: 735b 695d 290a 2020 2020 2020 2020 2020  s[i]).          
+00027100: 2020 2920 6c65 6674 286c 7369 7a65 5b30    ) left(lsize[0
+00027110: 5d2f 3229 207b 0a20 2020 2020 2020 2020  ]/2) {.         
+00027120: 2020 2020 2020 2074 6578 7428 7465 7874         text(text
+00027130: 5b69 5d2c 2066 6f6e 743d 666f 6e74 2c20  [i], font=font, 
+00027140: 7369 7a65 3d73 697a 652c 206c 616e 6775  size=size, langu
+00027150: 6167 653d 6c61 6e67 7561 6765 2c20 7363  age=language, sc
+00027160: 7269 7074 3d73 6372 6970 7429 3b0a 2020  ript=script);.  
+00027170: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00027180: 2020 2020 7d0a 2020 2020 2020 7d0a 2020      }.      }.  
+00027190: 2020 7d0a 2020 2020 756e 696f 6e28 293b    }.    union();
+000271a0: 0a20 207d 0a7d 0a0a 0a0a 2f2f 2053 6563  .  }.}....// Sec
+000271b0: 7469 6f6e 3a20 4d69 7363 656c 6c61 6e65  tion: Miscellane
+000271c0: 6f75 730a 0a0a 0a0a 2f2f 2054 6f70 6963  ous.....// Topic
+000271d0: 733a 2053 6861 7065 7320 2833 4429 2c20  s: Shapes (3D), 
+000271e0: 4174 7461 6368 6162 6c65 0a2f 2f20 4d6f  Attachable.// Mo
+000271f0: 6475 6c65 3a20 6669 6c6c 6574 2829 0a2f  dule: fillet()./
+00027200: 2f20 5379 6e6f 7073 6973 3a20 4372 6561  / Synopsis: Crea
+00027210: 7465 7320 6120 736d 6f6f 7468 2066 696c  tes a smooth fil
+00027220: 6c65 7420 6265 7477 6565 6e20 7477 6f20  let between two 
+00027230: 6661 6365 732c 206f 7220 7265 7475 726e  faces, or return
+00027240: 7320 6120 766e 662e 0a2f 2f20 5365 6520  s a vnf..// See 
+00027250: 416c 736f 3a20 6d61 736b 3264 5f72 6f75  Also: mask2d_rou
+00027260: 6e64 6f76 6572 2829 0a2f 2f20 4465 7363  ndover().// Desc
+00027270: 7269 7074 696f 6e3a 0a2f 2f20 2020 4372  ription:.//   Cr
+00027280: 6561 7465 7320 6120 7368 6170 6520 7468  eates a shape th
+00027290: 6174 2063 616e 2062 6520 756e 696f 6e65  at can be unione
+000272a0: 6420 696e 746f 2061 2063 6f6e 6361 7665  d into a concave
+000272b0: 206a 6f69 6e74 2062 6574 7765 656e 2074   joint between t
+000272c0: 776f 2066 6163 6573 2c20 746f 2066 696c  wo faces, to fil
+000272d0: 6c65 7420 7468 656d 2e0a 2f2f 2020 2043  let them..//   C
+000272e0: 656e 7465 7220 7468 6973 2070 6172 7420  enter this part 
+000272f0: 616c 6f6e 6720 7468 6520 636f 6e63 6176  along the concav
+00027300: 6520 6564 6765 2074 6f20 6265 2063 6861  e edge to be cha
+00027310: 6d66 6572 6564 2061 6e64 2075 6e69 6f6e  mfered and union
+00027320: 2069 7420 696e 2e0a 2f2f 0a2f 2f20 5573   it in..//.// Us
+00027330: 6167 653a 2054 7970 6963 616c 0a2f 2f20  age: Typical.// 
+00027340: 2020 6669 6c6c 6574 286c 2c20 722c 205b    fillet(l, r, [
+00027350: 616e 675d 2c20 5b6f 7665 726c 6170 5d2c  ang], [overlap],
+00027360: 202e 2e2e 2920 5b41 5454 4143 484d 454e   ...) [ATTACHMEN
+00027370: 5453 5d3b 0a2f 2f20 2020 6669 6c6c 6574  TS];.//   fillet
+00027380: 286c 7c6c 656e 6774 683d 7c68 3d7c 6865  (l|length=|h=|he
+00027390: 6967 6874 3d2c 2064 3d2c 205b 616e 673d  ight=, d=, [ang=
+000273a0: 5d2c 205b 6f76 6572 6c61 703d 5d2c 202e  ], [overlap=], .
+000273b0: 2e2e 2920 5b41 5454 4143 484d 454e 5453  ..) [ATTACHMENTS
+000273c0: 5d3b 0a2f 2f0a 2f2f 2041 7267 756d 656e  ];.//.// Argumen
+000273d0: 7473 3a0a 2f2f 2020 206c 202f 206c 656e  ts:.//   l / len
+000273e0: 6774 6820 2f20 6820 2f20 6865 6967 6874  gth / h / height
+000273f0: 203d 204c 656e 6774 6820 6f66 2065 6467   = Length of edg
+00027400: 6520 746f 2066 696c 6c65 742e 0a2f 2f20  e to fillet..// 
+00027410: 2020 7220 3d20 5261 6469 7573 206f 6620    r = Radius of 
+00027420: 6669 6c6c 6574 2e0a 2f2f 2020 2061 6e67  fillet..//   ang
+00027430: 203d 2041 6e67 6c65 2062 6574 7765 656e   = Angle between
+00027440: 2066 6163 6573 2074 6f20 6669 6c6c 6574   faces to fillet
+00027450: 2e0a 2f2f 2020 206f 7665 726c 6170 203d  ..//   overlap =
+00027460: 204f 7665 726c 6170 2073 697a 6520 666f   Overlap size fo
+00027470: 7220 756e 696f 6e69 6e67 2077 6974 6820  r unioning with 
+00027480: 6661 6365 732e 0a2f 2f20 2020 2d2d 2d0a  faces..//   ---.
+00027490: 2f2f 2020 2064 203d 2044 6961 6d65 7465  //   d = Diamete
+000274a0: 7220 6f66 2066 696c 6c65 742e 0a2f 2f20  r of fillet..// 
+000274b0: 2020 616e 6368 6f72 203d 2054 7261 6e73    anchor = Trans
+000274c0: 6c61 7465 2073 6f20 616e 6368 6f72 2070  late so anchor p
+000274d0: 6f69 6e74 2069 7320 6174 206f 7269 6769  oint is at origi
+000274e0: 6e20 2830 2c30 2c30 292e 2020 5365 6520  n (0,0,0).  See 
+000274f0: 5b61 6e63 686f 725d 2861 7474 6163 686d  [anchor](attachm
+00027500: 656e 7473 2e73 6361 6423 7375 6273 6563  ents.scad#subsec
+00027510: 7469 6f6e 2d61 6e63 686f 7229 2e20 2044  tion-anchor).  D
+00027520: 6566 6175 6c74 3a20 6046 524f 4e54 2b4c  efault: `FRONT+L
+00027530: 4546 5460 0a2f 2f20 2020 7370 696e 203d  EFT`.//   spin =
+00027540: 2052 6f74 6174 6520 7468 6973 206d 616e   Rotate this man
+00027550: 7920 6465 6772 6565 7320 6172 6f75 6e64  y degrees around
+00027560: 2074 6865 205a 2061 7869 7320 6166 7465   the Z axis afte
+00027570: 7220 616e 6368 6f72 2e20 2053 6565 205b  r anchor.  See [
+00027580: 7370 696e 5d28 6174 7461 6368 6d65 6e74  spin](attachment
+00027590: 732e 7363 6164 2373 7562 7365 6374 696f  s.scad#subsectio
+000275a0: 6e2d 7370 696e 292e 2020 4465 6661 756c  n-spin).  Defaul
+000275b0: 743a 2060 3060 0a2f 2f20 2020 6f72 6965  t: `0`.//   orie
+000275c0: 6e74 203d 2056 6563 746f 7220 746f 2072  nt = Vector to r
+000275d0: 6f74 6174 6520 746f 7020 746f 7761 7264  otate top toward
+000275e0: 732c 2061 6674 6572 2073 7069 6e2e 2020  s, after spin.  
+000275f0: 5365 6520 5b6f 7269 656e 745d 2861 7474  See [orient](att
+00027600: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+00027610: 6273 6563 7469 6f6e 2d6f 7269 656e 7429  bsection-orient)
+00027620: 2e20 2044 6566 6175 6c74 3a20 6055 5060  .  Default: `UP`
+00027630: 0a2f 2f0a 2f2f 2045 7861 6d70 6c65 3a0a  .//.// Example:.
+00027640: 2f2f 2020 2075 6e69 6f6e 2829 207b 0a2f  //   union() {./
+00027650: 2f20 2020 2020 7472 616e 736c 6174 6528  /     translate(
+00027660: 5b30 2c32 2c2d 345d 290a 2f2f 2020 2020  [0,2,-4]).//    
+00027670: 2020 2063 7562 6528 5b32 302c 2034 2c20     cube([20, 4, 
+00027680: 3234 5d2c 2061 6e63 686f 723d 424f 5454  24], anchor=BOTT
+00027690: 4f4d 293b 0a2f 2f20 2020 2020 7472 616e  OM);.//     tran
+000276a0: 736c 6174 6528 5b30 2c2d 3130 2c2d 345d  slate([0,-10,-4]
+000276b0: 290a 2f2f 2020 2020 2020 2063 7562 6528  ).//       cube(
+000276c0: 5b32 302c 2032 302c 2034 5d2c 2061 6e63  [20, 20, 4], anc
+000276d0: 686f 723d 424f 5454 4f4d 293b 0a2f 2f20  hor=BOTTOM);.// 
+000276e0: 2020 2020 636f 6c6f 7228 2267 7265 656e      color("green
+000276f0: 2229 0a2f 2f20 2020 2020 2020 6669 6c6c  ").//       fill
+00027700: 6574 280a 2f2f 2020 2020 2020 2020 206c  et(.//         l
+00027710: 3d32 302c 2072 3d31 302c 0a2f 2f20 2020  =20, r=10,.//   
+00027720: 2020 2020 2020 7370 696e 3d31 3830 2c20        spin=180, 
+00027730: 6f72 6965 6e74 3d52 4947 4854 0a2f 2f20  orient=RIGHT.// 
+00027740: 2020 2020 2020 293b 0a2f 2f20 2020 7d0a        );.//   }.
+00027750: 2f2f 0a2f 2f20 4578 616d 706c 6573 3a0a  //.// Examples:.
+00027760: 2f2f 2020 2066 696c 6c65 7428 6c3d 3130  //   fillet(l=10
+00027770: 2c20 723d 3230 2c20 616e 673d 3630 293b  , r=20, ang=60);
+00027780: 0a2f 2f20 2020 6669 6c6c 6574 286c 3d31  .//   fillet(l=1
+00027790: 302c 2072 3d32 302c 2061 6e67 3d39 3029  0, r=20, ang=90)
+000277a0: 3b0a 2f2f 2020 2066 696c 6c65 7428 6c3d  ;.//   fillet(l=
+000277b0: 3130 2c20 723d 3230 2c20 616e 673d 3132  10, r=20, ang=12
+000277c0: 3029 3b0a 2f2f 0a2f 2f20 4578 616d 706c  0);.//.// Exampl
+000277d0: 653a 2055 7369 6e67 2077 6974 6820 4174  e: Using with At
+000277e0: 7461 6368 6d65 6e74 730a 2f2f 2020 2063  tachments.//   c
+000277f0: 7562 6528 3530 2c63 656e 7465 723d 7472  ube(50,center=tr
+00027800: 7565 2920 7b0a 2f2f 2020 2020 2070 6f73  ue) {.//     pos
+00027810: 6974 696f 6e28 4652 4f4e 542b 4c45 4654  ition(FRONT+LEFT
+00027820: 290a 2f2f 2020 2020 2020 2066 696c 6c65  ).//       fille
+00027830: 7428 6c3d 3530 2c20 723d 3130 2c20 7370  t(l=50, r=10, sp
+00027840: 696e 3d2d 3930 293b 0a2f 2f20 2020 2020  in=-90);.//     
+00027850: 706f 7369 7469 6f6e 2842 4f54 2b46 524f  position(BOT+FRO
+00027860: 4e54 290a 2f2f 2020 2020 2020 2066 696c  NT).//       fil
+00027870: 6c65 7428 6c3d 3530 2c20 723d 3130 2c20  let(l=50, r=10, 
+00027880: 7370 696e 3d31 3830 2c20 6f72 6965 6e74  spin=180, orient
+00027890: 3d52 4947 4854 293b 0a2f 2f20 2020 7d0a  =RIGHT);.//   }.
+000278a0: 0a6d 6f64 756c 6520 696e 7465 7269 6f72  .module interior
+000278b0: 5f66 696c 6c65 7428 6c3d 312e 302c 2072  _fillet(l=1.0, r
+000278c0: 2c20 616e 673d 3930 2c20 6f76 6572 6c61  , ang=90, overla
+000278d0: 703d 302e 3031 2c20 642c 206c 656e 6774  p=0.01, d, lengt
+000278e0: 682c 2068 2c20 6865 6967 6874 2c20 616e  h, h, height, an
+000278f0: 6368 6f72 3d43 454e 5445 522c 2073 7069  chor=CENTER, spi
+00027900: 6e3d 302c 206f 7269 656e 743d 5550 290a  n=0, orient=UP).
+00027910: 7b0a 2020 2020 6465 7072 6563 6174 6528  {.    deprecate(
+00027920: 2266 696c 6c65 7422 293b 0a20 2020 2066  "fillet");.    f
+00027930: 696c 6c65 7428 6c2c 722c 616e 672c 6f76  illet(l,r,ang,ov
+00027940: 6572 6c61 702c 642c 6c65 6e67 7468 2c68  erlap,d,length,h
+00027950: 2c68 6569 6768 742c 616e 6368 6f72 2c73  ,height,anchor,s
+00027960: 7069 6e2c 6f72 6965 6e74 293b 0a7d 0a0a  pin,orient);.}..
+00027970: 0a6d 6f64 756c 6520 6669 6c6c 6574 286c  .module fillet(l
+00027980: 3d31 2e30 2c20 722c 2061 6e67 3d39 302c  =1.0, r, ang=90,
+00027990: 206f 7665 726c 6170 3d30 2e30 312c 2064   overlap=0.01, d
+000279a0: 2c20 6c65 6e67 7468 2c20 682c 2068 6569  , length, h, hei
+000279b0: 6768 742c 2061 6e63 686f 723d 4345 4e54  ght, anchor=CENT
+000279c0: 4552 2c20 7370 696e 3d30 2c20 6f72 6965  ER, spin=0, orie
+000279d0: 6e74 3d55 5029 207b 0a20 2020 206c 203d  nt=UP) {.    l =
+000279e0: 206f 6e65 5f64 6566 696e 6564 285b 6c2c   one_defined([l,
+000279f0: 6c65 6e67 7468 2c68 2c68 6569 6768 745d  length,h,height]
+00027a00: 2c22 6c2c 6c65 6e67 7468 2c68 2c68 6569  ,"l,length,h,hei
+00027a10: 6768 7422 293b 0a20 2020 2072 203d 2067  ght");.    r = g
+00027a20: 6574 5f72 6164 6975 7328 723d 722c 2064  et_radius(r=r, d
+00027a30: 3d64 2c20 6466 6c74 3d31 293b 0a20 2020  =d, dflt=1);.   
+00027a40: 2073 7465 7073 203d 2063 6569 6c28 7365   steps = ceil(se
+00027a50: 6773 2872 292a 2831 3830 2d61 6e67 292f  gs(r)*(180-ang)/
+00027a60: 3336 3029 3b0a 2020 2020 6172 6320 3d20  360);.    arc = 
+00027a70: 6172 6328 6e3d 7374 6570 732b 312c 2072  arc(n=steps+1, r
+00027a80: 3d72 2c20 636f 726e 6572 3d5b 706f 6c61  =r, corner=[pola
+00027a90: 725f 746f 5f78 7928 722c 616e 6729 2c5b  r_to_xy(r,ang),[
+00027aa0: 302c 305d 2c5b 722c 305d 5d29 3b0a 2020  0,0],[r,0]]);.  
+00027ab0: 2020 6d61 7878 203d 206c 6173 7428 6172    maxx = last(ar
+00027ac0: 6329 2e78 3b0a 2020 2020 6d61 7879 203d  c).x;.    maxy =
+00027ad0: 2061 7263 5b30 5d2e 793b 0a20 2020 2070   arc[0].y;.    p
+00027ae0: 6174 6820 3d20 5b0a 2020 2020 2020 2020  ath = [.        
+00027af0: 5b6d 6178 782c 202d 6f76 6572 6c61 705d  [maxx, -overlap]
+00027b00: 2c0a 2020 2020 2020 2020 706f 6c61 725f  ,.        polar_
+00027b10: 746f 5f78 7928 6f76 6572 6c61 702c 2031  to_xy(overlap, 1
+00027b20: 3830 2b61 6e67 2f32 292c 0a20 2020 2020  80+ang/2),.     
+00027b30: 2020 2061 7263 5b30 5d20 2b20 706f 6c61     arc[0] + pola
+00027b40: 725f 746f 5f78 7928 6f76 6572 6c61 702c  r_to_xy(overlap,
+00027b50: 2039 302b 616e 6729 2c0a 2020 2020 2020   90+ang),.      
+00027b60: 2020 6561 6368 2061 7263 0a20 2020 205d    each arc.    ]
+00027b70: 3b0a 2020 2020 6174 7461 6368 6162 6c65  ;.    attachable
+00027b80: 2861 6e63 686f 722c 7370 696e 2c6f 7269  (anchor,spin,ori
+00027b90: 656e 742c 2073 697a 653d 5b32 2a6d 6178  ent, size=[2*max
+00027ba0: 782c 322a 6d61 7879 2c6c 5d29 207b 0a20  x,2*maxy,l]) {. 
+00027bb0: 2020 2020 2020 2069 6620 286c 203e 2030         if (l > 0
+00027bc0: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00027bd0: 6c69 6e65 6172 5f65 7874 7275 6465 2868  linear_extrude(h
+00027be0: 6569 6768 743d 6c2c 2063 6f6e 7665 7869  eight=l, convexi
+00027bf0: 7479 3d34 2c20 6365 6e74 6572 3d74 7275  ty=4, center=tru
+00027c00: 6529 207b 0a20 2020 2020 2020 2020 2020  e) {.           
+00027c10: 2020 2020 2070 6f6c 7967 6f6e 2870 6174       polygon(pat
+00027c20: 6829 3b0a 2020 2020 2020 2020 2020 2020  h);.            
+00027c30: 7d0a 2020 2020 2020 2020 7d0a 2020 2020  }.        }.    
+00027c40: 2020 2020 6368 696c 6472 656e 2829 3b0a      children();.
+00027c50: 2020 2020 7d0a 7d0a 0a0a 2f2f 2046 756e      }.}...// Fun
+00027c60: 6374 696f 6e26 4d6f 6475 6c65 3a20 6865  ction&Module: he
+00027c70: 6967 6874 6669 656c 6428 290a 2f2f 2053  ightfield().// S
+00027c80: 796e 6f70 7369 733a 2047 656e 6572 6174  ynopsis: Generat
+00027c90: 6573 2061 2033 4420 7375 7266 6163 6520  es a 3D surface 
+00027ca0: 6672 6f6d 2061 2032 4420 6772 6964 206f  from a 2D grid o
+00027cb0: 6620 7661 6c75 6573 2c20 6f72 2072 6574  f values, or ret
+00027cc0: 7572 6e73 2061 2076 6e66 2e0a 2f2f 2054  urns a vnf..// T
+00027cd0: 6f70 6963 733a 2054 6578 7475 7265 732c  opics: Textures,
+00027ce0: 2048 6569 6768 7466 6965 6c64 0a2f 2f20   Heightfield.// 
+00027cf0: 5365 6520 416c 736f 3a20 6379 6c69 6e64  See Also: cylind
+00027d00: 7269 6361 6c5f 6865 6967 6874 6669 656c  rical_heightfiel
+00027d10: 6428 290a 2f2f 2055 7361 6765 3a20 4173  d().// Usage: As
+00027d20: 204d 6f64 756c 650a 2f2f 2020 2068 6569   Module.//   hei
+00027d30: 6768 7466 6965 6c64 2864 6174 612c 205b  ghtfield(data, [
+00027d40: 7369 7a65 5d2c 205b 626f 7474 6f6d 5d2c  size], [bottom],
+00027d50: 205b 6d61 787a 5d2c 205b 7872 616e 6765   [maxz], [xrange
+00027d60: 5d2c 205b 7972 616e 6765 5d2c 205b 7374  ], [yrange], [st
+00027d70: 796c 655d 2c20 5b63 6f6e 7665 7869 7479  yle], [convexity
+00027d80: 5d2c 202e 2e2e 2920 5b41 5454 4143 484d  ], ...) [ATTACHM
+00027d90: 454e 5453 5d3b 0a2f 2f20 5573 6167 653a  ENTS];.// Usage:
+00027da0: 2041 7320 4675 6e63 7469 6f6e 0a2f 2f20   As Function.// 
+00027db0: 2020 766e 6620 3d20 6865 6967 6874 6669    vnf = heightfi
+00027dc0: 656c 6428 6461 7461 2c20 5b73 697a 655d  eld(data, [size]
+00027dd0: 2c20 5b62 6f74 746f 6d5d 2c20 5b6d 6178  , [bottom], [max
+00027de0: 7a5d 2c20 5b78 7261 6e67 655d 2c20 5b79  z], [xrange], [y
+00027df0: 7261 6e67 655d 2c20 5b73 7479 6c65 5d2c  range], [style],
+00027e00: 202e 2e2e 293b 0a2f 2f20 4465 7363 7269   ...);.// Descri
+00027e10: 7074 696f 6e3a 0a2f 2f20 2020 4769 7665  ption:.//   Give
+00027e20: 6e20 6120 7265 6775 6c61 7220 7265 6374  n a regular rect
+00027e30: 616e 6775 6c61 7220 3244 2067 7269 6420  angular 2D grid 
+00027e40: 6f66 2073 6361 6c61 7220 7661 6c75 6573  of scalar values
+00027e50: 2c20 6f72 2061 2066 756e 6374 696f 6e20  , or a function 
+00027e60: 6c69 7465 7261 6c2c 2067 656e 6572 6174  literal, generat
+00027e70: 6573 2061 2033 440a 2f2f 2020 2073 7572  es a 3D.//   sur
+00027e80: 6661 6365 2077 6865 7265 2074 6865 2068  face where the h
+00027e90: 6569 6768 7420 6174 2061 6e79 2067 6976  eight at any giv
+00027ea0: 656e 2070 6f69 6e74 2069 7320 7468 6520  en point is the 
+00027eb0: 7363 616c 6172 2076 616c 7565 2066 6f72  scalar value for
+00027ec0: 2074 6861 7420 706f 7369 7469 6f6e 2e0a   that position..
+00027ed0: 2f2f 2020 204f 6e65 2073 6372 6970 7420  //   One script 
+00027ee0: 746f 2063 6f6e 7665 7274 2061 2067 7261  to convert a gra
+00027ef0: 7973 6361 6c65 2069 6d61 6765 2074 6f20  yscale image to 
+00027f00: 6120 6865 6967 6874 6669 656c 6420 6172  a heightfield ar
+00027f10: 7261 7920 696e 2061 202e 7363 6164 2066  ray in a .scad f
+00027f20: 696c 6520 6361 6e20 6265 2066 6f75 6e64  ile can be found
+00027f30: 2061 743a 0a2f 2f20 2020 6874 7470 733a   at:.//   https:
+00027f40: 2f2f 7261 772e 6769 7468 7562 7573 6572  //raw.githubuser
+00027f50: 636f 6e74 656e 742e 636f 6d2f 7265 7661  content.com/reva
+00027f60: 7262 6174 2f42 4f53 4c32 2f6d 6173 7465  rbat/BOSL2/maste
+00027f70: 722f 7363 7269 7074 732f 696d 6732 7363  r/scripts/img2sc
+00027f80: 6164 2e70 790a 2f2f 2041 7267 756d 656e  ad.py.// Argumen
+00027f90: 7473 3a0a 2f2f 2020 2064 6174 6120 3d20  ts:.//   data = 
+00027fa0: 5468 6973 2069 7320 6569 7468 6572 2074  This is either t
+00027fb0: 6865 2032 4420 7265 6374 616e 6775 6c61  he 2D rectangula
+00027fc0: 7220 6172 7261 7920 6f66 2068 6569 6768  r array of heigh
+00027fd0: 7473 2c20 6f72 2061 2066 756e 6374 696f  ts, or a functio
+00027fe0: 6e20 6c69 7465 7261 6c20 7468 6174 2074  n literal that t
+00027ff0: 616b 6573 2058 2061 6e64 2059 2061 7267  akes X and Y arg
+00028000: 756d 656e 7473 2e0a 2f2f 2020 2073 697a  uments..//   siz
+00028010: 6520 3d20 5468 6520 5b58 2c59 5d20 7369  e = The [X,Y] si
+00028020: 7a65 206f 6620 7468 6520 7375 7266 6163  ze of the surfac
+00028030: 6520 746f 2063 7265 6174 652e 2020 4966  e to create.  If
+00028040: 2067 6976 656e 2061 7320 6120 7363 616c   given as a scal
+00028050: 6172 2c20 7573 6520 6974 2066 6f72 2062  ar, use it for b
+00028060: 6f74 6820 5820 616e 6420 5920 7369 7a65  oth X and Y size
+00028070: 732e 2044 6566 6175 6c74 3a20 605b 3130  s. Default: `[10
+00028080: 302c 3130 305d 600a 2f2f 2020 2062 6f74  0,100]`.//   bot
+00028090: 746f 6d20 3d20 5468 6520 5a20 636f 6f72  tom = The Z coor
+000280a0: 6469 6e61 7465 2066 6f72 2074 6865 2062  dinate for the b
+000280b0: 6f74 746f 6d20 6f66 2074 6865 2068 6569  ottom of the hei
+000280c0: 6768 7466 6965 6c64 206f 626a 6563 7420  ghtfield object 
+000280d0: 746f 2063 7265 6174 652e 2020 416e 7920  to create.  Any 
+000280e0: 6865 6967 6874 7320 6c6f 7765 7220 7468  heights lower th
+000280f0: 616e 2074 6869 7320 7769 6c6c 2062 6520  an this will be 
+00028100: 7472 756e 6361 7465 6420 746f 2076 6572  truncated to ver
+00028110: 7920 736c 6967 6874 6c79 2061 626f 7665  y slightly above
+00028120: 2074 6869 7320 6865 6967 6874 2e20 2044   this height.  D
+00028130: 6566 6175 6c74 3a20 2d32 300a 2f2f 2020  efault: -20.//  
+00028140: 206d 6178 7a20 3d20 5468 6520 6d61 7869   maxz = The maxi
+00028150: 6d75 6d20 6865 6967 6874 2074 6f20 6d6f  mum height to mo
+00028160: 6465 6c2e 2020 5472 756e 6361 7465 7320  del.  Truncates 
+00028170: 616e 7974 6869 6e67 2074 616c 6c65 7220  anything taller 
+00028180: 746f 2074 6869 7320 6865 6967 6874 2e20  to this height. 
+00028190: 2044 6566 6175 6c74 3a20 3939 0a2f 2f20   Default: 99.// 
+000281a0: 2020 7872 616e 6765 203d 2041 2072 616e    xrange = A ran
+000281b0: 6765 206f 6620 7661 6c75 6573 2074 6f20  ge of values to 
+000281c0: 6974 6572 6174 6520 5820 6f76 6572 2077  iterate X over w
+000281d0: 6865 6e20 6361 6c63 756c 6174 696e 6720  hen calculating 
+000281e0: 6120 7375 7266 6163 6520 6672 6f6d 2061  a surface from a
+000281f0: 2066 756e 6374 696f 6e20 6c69 7465 7261   function litera
+00028200: 6c2e 2020 4465 6661 756c 743a 205b 2d31  l.  Default: [-1
+00028210: 203a 2030 2e30 3120 3a20 315d 0a2f 2f20   : 0.01 : 1].// 
+00028220: 2020 7972 616e 6765 203d 2041 2072 616e    yrange = A ran
+00028230: 6765 206f 6620 7661 6c75 6573 2074 6f20  ge of values to 
+00028240: 6974 6572 6174 6520 5920 6f76 6572 2077  iterate Y over w
+00028250: 6865 6e20 6361 6c63 756c 6174 696e 6720  hen calculating 
+00028260: 6120 7375 7266 6163 6520 6672 6f6d 2061  a surface from a
+00028270: 2066 756e 6374 696f 6e20 6c69 7465 7261   function litera
+00028280: 6c2e 2020 4465 6661 756c 743a 205b 2d31  l.  Default: [-1
+00028290: 203a 2030 2e30 3120 3a20 315d 0a2f 2f20   : 0.01 : 1].// 
+000282a0: 2020 7374 796c 6520 3d20 5468 6520 7374    style = The st
+000282b0: 796c 6520 6f66 2073 7562 6469 7669 6469  yle of subdividi
+000282c0: 6e67 2074 6865 2071 7561 6473 2069 6e74  ng the quads int
+000282d0: 6f20 6661 6365 732e 2020 5661 6c69 6420  o faces.  Valid 
+000282e0: 6f70 7469 6f6e 7320 6172 6520 2264 6566  options are "def
+000282f0: 6175 6c74 222c 2022 616c 7422 2c20 616e  ault", "alt", an
+00028300: 6420 2271 7569 6e63 756e 7822 2e20 2044  d "quincunx".  D
+00028310: 6566 6175 6c74 3a20 2264 6566 6175 6c74  efault: "default
+00028320: 220a 2f2f 2020 202d 2d2d 0a2f 2f20 2020  ".//   ---.//   
+00028330: 636f 6e76 6578 6974 7920 3d20 4d61 7820  convexity = Max 
+00028340: 6e75 6d62 6572 206f 6620 7469 6d65 7320  number of times 
+00028350: 6120 6c69 6e65 2063 6f75 6c64 2069 6e74  a line could int
+00028360: 6572 7365 6374 2061 2077 616c 6c20 6f66  ersect a wall of
+00028370: 2074 6865 2073 7572 6661 6365 2062 6569   the surface bei
+00028380: 6e67 2066 6f72 6d65 642e 204d 6f64 756c  ng formed. Modul
+00028390: 6520 6f6e 6c79 2e20 2044 6566 6175 6c74  e only.  Default
+000283a0: 3a20 3130 0a2f 2f20 2020 616e 6368 6f72  : 10.//   anchor
+000283b0: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
+000283c0: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
+000283d0: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
+000283e0: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
+000283f0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00028400: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
+00028410: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
+00028420: 6043 454e 5445 5260 0a2f 2f20 2020 7370  `CENTER`.//   sp
+00028430: 696e 203d 2052 6f74 6174 6520 7468 6973  in = Rotate this
+00028440: 206d 616e 7920 6465 6772 6565 7320 6172   many degrees ar
+00028450: 6f75 6e64 2074 6865 205a 2061 7869 732e  ound the Z axis.
+00028460: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
+00028470: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+00028480: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
+00028490: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
+000284a0: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
+000284b0: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
+000284c0: 2074 6f77 6172 6473 2e20 2053 6565 205b   towards.  See [
+000284d0: 6f72 6965 6e74 5d28 6174 7461 6368 6d65  orient](attachme
+000284e0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+000284f0: 696f 6e2d 6f72 6965 6e74 292e 2020 4465  ion-orient).  De
+00028500: 6661 756c 743a 2060 5550 600a 2f2f 2045  fault: `UP`.// E
+00028510: 7861 6d70 6c65 3a0a 2f2f 2020 2068 6569  xample:.//   hei
+00028520: 6768 7466 6965 6c64 2873 697a 653d 5b31  ghtfield(size=[1
+00028530: 3030 2c31 3030 5d2c 2062 6f74 746f 6d3d  00,100], bottom=
+00028540: 2d32 302c 2064 6174 613d 5b0a 2f2f 2020  -20, data=[.//  
+00028550: 2020 2020 2066 6f72 2028 793d 5b2d 3138       for (y=[-18
+00028560: 303a 343a 3138 305d 2920 5b0a 2f2f 2020  0:4:180]) [.//  
+00028570: 2020 2020 2020 2020 2066 6f72 2878 3d5b           for(x=[
+00028580: 2d31 3830 3a34 3a31 3830 5d29 0a2f 2f20  -180:4:180]).// 
+00028590: 2020 2020 2020 2020 2020 3130 2a63 6f73            10*cos
+000285a0: 2833 2a6e 6f72 6d28 5b78 2c79 5d29 290a  (3*norm([x,y])).
+000285b0: 2f2f 2020 2020 2020 205d 0a2f 2f20 2020  //       ].//   
+000285c0: 5d29 3b0a 2f2f 2045 7861 6d70 6c65 3a0a  ]);.// Example:.
+000285d0: 2f2f 2020 2069 6e74 6572 7365 6374 696f  //   intersectio
+000285e0: 6e28 2920 7b0a 2f2f 2020 2020 2020 2068  n() {.//       h
+000285f0: 6569 6768 7466 6965 6c64 2873 697a 653d  eightfield(size=
+00028600: 5b31 3030 2c31 3030 5d2c 2064 6174 613d  [100,100], data=
+00028610: 5b0a 2f2f 2020 2020 2020 2020 2020 2066  [.//           f
+00028620: 6f72 2028 793d 5b2d 3138 303a 353a 3138  or (y=[-180:5:18
+00028630: 305d 2920 5b0a 2f2f 2020 2020 2020 2020  0]) [.//        
+00028640: 2020 2020 2020 2066 6f72 2878 3d5b 2d31         for(x=[-1
+00028650: 3830 3a35 3a31 3830 5d29 0a2f 2f20 2020  80:5:180]).//   
+00028660: 2020 2020 2020 2020 2020 2020 3130 2b35              10+5
+00028670: 2a63 6f73 2833 2a78 292a 7369 6e28 332a  *cos(3*x)*sin(3*
+00028680: 7929 0a2f 2f20 2020 2020 2020 2020 2020  y).//           
+00028690: 5d0a 2f2f 2020 2020 2020 205d 293b 0a2f  ].//       ]);./
+000286a0: 2f20 2020 2020 2020 6379 6c69 6e64 6572  /       cylinder
+000286b0: 2868 3d35 302c 643d 3130 3029 3b0a 2f2f  (h=50,d=100);.//
+000286c0: 2020 207d 0a2f 2f20 4578 616d 706c 653a     }.// Example:
+000286d0: 2048 6569 6768 7466 6965 6c64 2062 7920   Heightfield by 
+000286e0: 4675 6e63 7469 6f6e 0a2f 2f20 2020 666e  Function.//   fn
+000286f0: 203d 2066 756e 6374 696f 6e20 2878 2c79   = function (x,y
+00028700: 2920 3130 2a73 696e 2878 2a33 3630 292a  ) 10*sin(x*360)*
+00028710: 636f 7328 792a 3336 3029 3b0a 2f2f 2020  cos(y*360);.//  
+00028720: 2068 6569 6768 7466 6965 6c64 2873 697a   heightfield(siz
+00028730: 653d 5b31 3030 2c31 3030 5d2c 2064 6174  e=[100,100], dat
+00028740: 613d 666e 293b 0a2f 2f20 4578 616d 706c  a=fn);.// Exampl
+00028750: 653a 2048 6569 6768 7466 6965 6c64 2062  e: Heightfield b
+00028760: 7920 4675 6e63 7469 6f6e 2c20 7769 7468  y Function, with
+00028770: 2053 7065 6369 6669 6320 5261 6e67 6573   Specific Ranges
+00028780: 0a2f 2f20 2020 666e 203d 2066 756e 6374  .//   fn = funct
+00028790: 696f 6e20 2878 2c79 2920 322a 636f 7328  ion (x,y) 2*cos(
+000287a0: 352a 6e6f 726d 285b 782c 795d 2929 3b0a  5*norm([x,y]));.
+000287b0: 2f2f 2020 2068 6569 6768 7466 6965 6c64  //   heightfield
+000287c0: 280a 2f2f 2020 2020 2020 2073 697a 653d  (.//       size=
+000287d0: 5b31 3030 2c31 3030 5d2c 2062 6f74 746f  [100,100], botto
+000287e0: 6d3d 2d32 302c 2064 6174 613d 666e 2c0a  m=-20, data=fn,.
+000287f0: 2f2f 2020 2020 2020 2078 7261 6e67 653d  //       xrange=
+00028800: 5b2d 3138 303a 323a 3138 305d 2c20 7972  [-180:2:180], yr
+00028810: 616e 6765 3d5b 2d31 3830 3a32 3a31 3830  ange=[-180:2:180
+00028820: 5d0a 2f2f 2020 2029 3b0a 0a6d 6f64 756c  ].//   );..modul
+00028830: 6520 6865 6967 6874 6669 656c 6428 6461  e heightfield(da
+00028840: 7461 2c20 7369 7a65 3d5b 3130 302c 3130  ta, size=[100,10
+00028850: 305d 2c20 626f 7474 6f6d 3d2d 3230 2c20  0], bottom=-20, 
+00028860: 6d61 787a 3d31 3030 2c20 7872 616e 6765  maxz=100, xrange
+00028870: 3d5b 2d31 3a30 2e30 343a 315d 2c20 7972  =[-1:0.04:1], yr
+00028880: 616e 6765 3d5b 2d31 3a30 2e30 343a 315d  ange=[-1:0.04:1]
+00028890: 2c20 7374 796c 653d 2264 6566 6175 6c74  , style="default
+000288a0: 222c 2063 6f6e 7665 7869 7479 3d31 302c  ", convexity=10,
+000288b0: 2061 6e63 686f 723d 4345 4e54 4552 2c20   anchor=CENTER, 
+000288c0: 7370 696e 3d30 2c20 6f72 6965 6e74 3d55  spin=0, orient=U
+000288d0: 5029 0a7b 0a20 2020 2073 697a 6520 3d20  P).{.    size = 
+000288e0: 6973 5f6e 756d 2873 697a 6529 3f20 5b73  is_num(size)? [s
+000288f0: 697a 652c 7369 7a65 5d20 3a20 706f 696e  ize,size] : poin
+00028900: 7432 6428 7369 7a65 293b 0a20 2020 2076  t2d(size);.    v
+00028910: 6e66 203d 2068 6569 6768 7466 6965 6c64  nf = heightfield
+00028920: 2864 6174 613d 6461 7461 2c20 7369 7a65  (data=data, size
+00028930: 3d73 697a 652c 2078 7261 6e67 653d 7872  =size, xrange=xr
+00028940: 616e 6765 2c20 7972 616e 6765 3d79 7261  ange, yrange=yra
+00028950: 6e67 652c 2062 6f74 746f 6d3d 626f 7474  nge, bottom=bott
+00028960: 6f6d 2c20 6d61 787a 3d6d 6178 7a2c 2073  om, maxz=maxz, s
+00028970: 7479 6c65 3d73 7479 6c65 293b 0a20 2020  tyle=style);.   
+00028980: 2061 7474 6163 6861 626c 6528 616e 6368   attachable(anch
+00028990: 6f72 2c73 7069 6e2c 6f72 6965 6e74 2c20  or,spin,orient, 
+000289a0: 766e 663d 766e 6629 207b 0a20 2020 2020  vnf=vnf) {.     
+000289b0: 2020 2076 6e66 5f70 6f6c 7968 6564 726f     vnf_polyhedro
+000289c0: 6e28 766e 662c 2063 6f6e 7665 7869 7479  n(vnf, convexity
+000289d0: 3d63 6f6e 7665 7869 7479 293b 0a20 2020  =convexity);.   
+000289e0: 2020 2020 2063 6869 6c64 7265 6e28 293b       children();
+000289f0: 0a20 2020 207d 0a7d 0a0a 0a66 756e 6374  .    }.}...funct
+00028a00: 696f 6e20 6865 6967 6874 6669 656c 6428  ion heightfield(
+00028a10: 6461 7461 2c20 7369 7a65 3d5b 3130 302c  data, size=[100,
+00028a20: 3130 305d 2c20 626f 7474 6f6d 3d2d 3230  100], bottom=-20
+00028a30: 2c20 6d61 787a 3d31 3030 2c20 7872 616e  , maxz=100, xran
+00028a40: 6765 3d5b 2d31 3a30 2e30 343a 315d 2c20  ge=[-1:0.04:1], 
+00028a50: 7972 616e 6765 3d5b 2d31 3a30 2e30 343a  yrange=[-1:0.04:
+00028a60: 315d 2c20 7374 796c 653d 2264 6566 6175  1], style="defau
+00028a70: 6c74 222c 2061 6e63 686f 723d 4345 4e54  lt", anchor=CENT
+00028a80: 4552 2c20 7370 696e 3d30 2c20 6f72 6965  ER, spin=0, orie
+00028a90: 6e74 3d55 5029 203d 0a20 2020 2061 7373  nt=UP) =.    ass
+00028aa0: 6572 7428 6973 5f6c 6973 7428 6461 7461  ert(is_list(data
+00028ab0: 2920 7c7c 2069 735f 6675 6e63 7469 6f6e  ) || is_function
+00028ac0: 2864 6174 6129 290a 2020 2020 6c65 7428  (data)).    let(
+00028ad0: 0a20 2020 2020 2020 2073 697a 6520 3d20  .        size = 
+00028ae0: 6973 5f6e 756d 2873 697a 6529 3f20 5b73  is_num(size)? [s
+00028af0: 697a 652c 7369 7a65 5d20 3a20 706f 696e  ize,size] : poin
+00028b00: 7432 6428 7369 7a65 292c 0a20 2020 2020  t2d(size),.     
+00028b10: 2020 2078 7661 6c73 203d 2069 735f 6c69     xvals = is_li
+00028b20: 7374 2864 6174 6129 0a20 2020 2020 2020  st(data).       
+00028b30: 2020 203f 205b 666f 7220 2869 3d69 6478     ? [for (i=idx
+00028b40: 2864 6174 615b 305d 2929 2069 5d0a 2020  (data[0])) i].  
+00028b50: 2020 2020 2020 2020 3a20 6173 7365 7274          : assert
+00028b60: 2869 735f 6c69 7374 2878 7261 6e67 6529  (is_list(xrange)
+00028b70: 7c7c 6973 5f72 616e 6765 2878 7261 6e67  ||is_range(xrang
+00028b80: 6529 2920 5b66 6f72 2028 783d 7872 616e  e)) [for (x=xran
+00028b90: 6765 2920 785d 2c0a 2020 2020 2020 2020  ge) x],.        
+00028ba0: 7976 616c 7320 3d20 6973 5f6c 6973 7428  yvals = is_list(
+00028bb0: 6461 7461 290a 2020 2020 2020 2020 2020  data).          
+00028bc0: 3f20 5b66 6f72 2028 693d 6964 7828 6461  ? [for (i=idx(da
+00028bd0: 7461 2929 2069 5d0a 2020 2020 2020 2020  ta)) i].        
+00028be0: 2020 3a20 6173 7365 7274 2869 735f 6c69    : assert(is_li
+00028bf0: 7374 2879 7261 6e67 6529 7c7c 6973 5f72  st(yrange)||is_r
+00028c00: 616e 6765 2879 7261 6e67 6529 2920 5b66  ange(yrange)) [f
+00028c10: 6f72 2028 793d 7972 616e 6765 2920 795d  or (y=yrange) y]
+00028c20: 2c0a 2020 2020 2020 2020 7863 6e74 203d  ,.        xcnt =
+00028c30: 206c 656e 2878 7661 6c73 292c 0a20 2020   len(xvals),.   
+00028c40: 2020 2020 206d 696e 7820 3d20 6d69 6e28       minx = min(
+00028c50: 7876 616c 7329 2c0a 2020 2020 2020 2020  xvals),.        
+00028c60: 6d61 7878 203d 206d 6178 2878 7661 6c73  maxx = max(xvals
+00028c70: 292c 0a20 2020 2020 2020 2079 636e 7420  ),.        ycnt 
+00028c80: 3d20 6c65 6e28 7976 616c 7329 2c0a 2020  = len(yvals),.  
+00028c90: 2020 2020 2020 6d69 6e79 203d 206d 696e        miny = min
+00028ca0: 2879 7661 6c73 292c 0a20 2020 2020 2020  (yvals),.       
+00028cb0: 206d 6178 7920 3d20 6d61 7828 7976 616c   maxy = max(yval
+00028cc0: 7329 2c0a 2020 2020 2020 2020 7665 7274  s),.        vert
+00028cd0: 7320 3d20 6973 5f6c 6973 7428 6461 7461  s = is_list(data
+00028ce0: 2920 3f20 5b0a 2020 2020 2020 2020 2020  ) ? [.          
+00028cf0: 2020 2020 2020 666f 7220 2879 203d 205b        for (y = [
+00028d00: 303a 313a 7963 6e74 2d31 5d29 205b 0a20  0:1:ycnt-1]) [. 
+00028d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028d20: 2020 2066 6f72 2028 7820 3d20 5b30 3a31     for (x = [0:1
+00028d30: 3a78 636e 742d 315d 2920 5b0a 2020 2020  :xcnt-1]) [.    
+00028d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028d50: 2020 2020 7369 7a65 2e78 202a 2028 782f      size.x * (x/
+00028d60: 2878 636e 742d 3129 2d30 2e35 292c 0a20  (xcnt-1)-0.5),. 
+00028d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028d80: 2020 2020 2020 2073 697a 652e 7920 2a20         size.y * 
+00028d90: 2879 2f28 7963 6e74 2d31 292d 302e 3529  (y/(ycnt-1)-0.5)
+00028da0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00028db0: 2020 2020 2020 2020 2020 6461 7461 5b79            data[y
+00028dc0: 5d5b 785d 0a20 2020 2020 2020 2020 2020  ][x].           
+00028dd0: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00028de0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+00028df0: 2020 2020 2020 2020 205d 203a 205b 0a20           ] : [. 
+00028e00: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00028e10: 6f72 2028 7920 3d20 7972 616e 6765 2920  or (y = yrange) 
+00028e20: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+00028e30: 2020 2020 2020 666f 7220 2878 203d 2078        for (x = x
+00028e40: 7261 6e67 6529 206c 6574 280a 2020 2020  range) let(.    
+00028e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028e60: 2020 2020 7a20 3d20 6461 7461 2878 2c79      z = data(x,y
+00028e70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00028e80: 2020 2020 2020 2920 5b0a 2020 2020 2020        ) [.      
+00028e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00028ea0: 2020 7369 7a65 2e78 202a 2028 2878 2d6d    size.x * ((x-m
+00028eb0: 696e 7829 2f28 6d61 7878 2d6d 696e 7829  inx)/(maxx-minx)
+00028ec0: 2d30 2e35 292c 0a20 2020 2020 2020 2020  -0.5),.         
+00028ed0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00028ee0: 697a 652e 7920 2a20 2828 792d 6d69 6e79  ize.y * ((y-miny
+00028ef0: 292f 286d 6178 792d 6d69 6e79 292d 302e  )/(maxy-miny)-0.
+00028f00: 3529 2c0a 2020 2020 2020 2020 2020 2020  5),.            
+00028f10: 2020 2020 2020 2020 2020 2020 6d69 6e28              min(
+00028f20: 6d61 787a 2c20 6d61 7828 626f 7474 6f6d  maxz, max(bottom
+00028f30: 2b30 2e31 2c20 6465 6661 756c 7428 7a2c  +0.1, default(z,
+00028f40: 3029 2929 0a20 2020 2020 2020 2020 2020  0))).           
+00028f50: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+00028f60: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+00028f70: 2020 2020 2020 2020 205d 2c0a 2020 2020           ],.    
+00028f80: 2020 2020 766e 6620 3d20 766e 665f 6a6f      vnf = vnf_jo
+00028f90: 696e 285b 0a20 2020 2020 2020 2020 2020  in([.           
+00028fa0: 2076 6e66 5f76 6572 7465 785f 6172 7261   vnf_vertex_arra
+00028fb0: 7928 7665 7274 732c 2073 7479 6c65 3d73  y(verts, style=s
+00028fc0: 7479 6c65 2c20 7265 7665 7273 653d 7472  tyle, reverse=tr
+00028fd0: 7565 292c 0a20 2020 2020 2020 2020 2020  ue),.           
+00028fe0: 2076 6e66 5f76 6572 7465 785f 6172 7261   vnf_vertex_arra
+00028ff0: 7928 5b0a 2020 2020 2020 2020 2020 2020  y([.            
+00029000: 2020 2020 7665 7274 735b 305d 2c0a 2020      verts[0],.  
+00029010: 2020 2020 2020 2020 2020 2020 2020 5b66                [f
+00029020: 6f72 2028 763d 7665 7274 735b 305d 2920  or (v=verts[0]) 
+00029030: 5b76 2e78 2c20 762e 792c 2062 6f74 746f  [v.x, v.y, botto
+00029040: 6d5d 5d2c 0a20 2020 2020 2020 2020 2020  m]],.           
+00029050: 205d 292c 0a20 2020 2020 2020 2020 2020   ]),.           
+00029060: 2076 6e66 5f76 6572 7465 785f 6172 7261   vnf_vertex_arra
+00029070: 7928 5b0a 2020 2020 2020 2020 2020 2020  y([.            
+00029080: 2020 2020 5b66 6f72 2028 763d 7665 7274      [for (v=vert
+00029090: 735b 7963 6e74 2d31 5d29 205b 762e 782c  s[ycnt-1]) [v.x,
+000290a0: 2076 2e79 2c20 626f 7474 6f6d 5d5d 2c0a   v.y, bottom]],.
+000290b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000290c0: 7665 7274 735b 7963 6e74 2d31 5d2c 0a20  verts[ycnt-1],. 
+000290d0: 2020 2020 2020 2020 2020 205d 292c 0a20             ]),. 
+000290e0: 2020 2020 2020 2020 2020 2076 6e66 5f76             vnf_v
+000290f0: 6572 7465 785f 6172 7261 7928 5b0a 2020  ertex_array([.  
+00029100: 2020 2020 2020 2020 2020 2020 2020 5b66                [f
+00029110: 6f72 2028 723d 7665 7274 7329 206c 6574  or (r=verts) let
+00029120: 2876 3d72 5b30 5d29 205b 762e 782c 2076  (v=r[0]) [v.x, v
+00029130: 2e79 2c20 626f 7474 6f6d 5d5d 2c0a 2020  .y, bottom]],.  
+00029140: 2020 2020 2020 2020 2020 2020 2020 5b66                [f
+00029150: 6f72 2028 723d 7665 7274 7329 206c 6574  or (r=verts) let
+00029160: 2876 3d72 5b30 5d29 2076 5d2c 0a20 2020  (v=r[0]) v],.   
+00029170: 2020 2020 2020 2020 205d 292c 0a20 2020           ]),.   
+00029180: 2020 2020 2020 2020 2076 6e66 5f76 6572           vnf_ver
+00029190: 7465 785f 6172 7261 7928 5b0a 2020 2020  tex_array([.    
+000291a0: 2020 2020 2020 2020 2020 2020 5b66 6f72              [for
+000291b0: 2028 723d 7665 7274 7329 206c 6574 2876   (r=verts) let(v
+000291c0: 3d72 5b78 636e 742d 315d 2920 765d 2c0a  =r[xcnt-1]) v],.
+000291d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000291e0: 5b66 6f72 2028 723d 7665 7274 7329 206c  [for (r=verts) l
+000291f0: 6574 2876 3d72 5b78 636e 742d 315d 2920  et(v=r[xcnt-1]) 
+00029200: 5b76 2e78 2c20 762e 792c 2062 6f74 746f  [v.x, v.y, botto
+00029210: 6d5d 5d2c 0a20 2020 2020 2020 2020 2020  m]],.           
+00029220: 205d 292c 0a20 2020 2020 2020 2020 2020   ]),.           
+00029230: 2076 6e66 5f76 6572 7465 785f 6172 7261   vnf_vertex_arra
+00029240: 7928 5b0a 2020 2020 2020 2020 2020 2020  y([.            
+00029250: 2020 2020 5b0a 2020 2020 2020 2020 2020      [.          
+00029260: 2020 2020 2020 2020 2020 666f 7220 2876            for (v
+00029270: 3d76 6572 7473 5b30 5d29 205b 762e 782c  =verts[0]) [v.x,
+00029280: 2076 2e79 2c20 626f 7474 6f6d 5d2c 0a20   v.y, bottom],. 
+00029290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000292a0: 2020 2066 6f72 2028 723d 7665 7274 7329     for (r=verts)
+000292b0: 206c 6574 2876 3d72 5b78 636e 742d 315d   let(v=r[xcnt-1]
+000292c0: 2920 5b76 2e78 2c20 762e 792c 2062 6f74  ) [v.x, v.y, bot
+000292d0: 746f 6d5d 2c0a 2020 2020 2020 2020 2020  tom],.          
+000292e0: 2020 2020 2020 5d2c 205b 0a20 2020 2020        ], [.     
+000292f0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00029300: 6f72 2028 723d 7665 7274 7329 206c 6574  or (r=verts) let
+00029310: 2876 3d72 5b30 5d29 205b 762e 782c 2076  (v=r[0]) [v.x, v
+00029320: 2e79 2c20 626f 7474 6f6d 5d2c 0a20 2020  .y, bottom],.   
+00029330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00029340: 2066 6f72 2028 763d 7665 7274 735b 7963   for (v=verts[yc
+00029350: 6e74 2d31 5d29 205b 762e 782c 2076 2e79  nt-1]) [v.x, v.y
+00029360: 2c20 626f 7474 6f6d 5d2c 0a20 2020 2020  , bottom],.     
+00029370: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+00029380: 2020 2020 2020 2020 205d 290a 2020 2020           ]).    
+00029390: 2020 2020 5d29 0a20 2020 2029 2072 656f      ]).    ) reo
+000293a0: 7269 656e 7428 616e 6368 6f72 2c73 7069  rient(anchor,spi
+000293b0: 6e2c 6f72 6965 6e74 2c20 766e 663d 766e  n,orient, vnf=vn
+000293c0: 662c 2070 3d76 6e66 293b 0a0a 0a2f 2f20  f, p=vnf);...// 
+000293d0: 4675 6e63 7469 6f6e 264d 6f64 756c 653a  Function&Module:
+000293e0: 2063 796c 696e 6472 6963 616c 5f68 6569   cylindrical_hei
+000293f0: 6768 7466 6965 6c64 2829 0a2f 2f20 5379  ghtfield().// Sy
+00029400: 6e6f 7073 6973 3a20 4765 6e65 7261 7465  nopsis: Generate
+00029410: 7320 6120 6379 6c69 6e64 7269 6361 6c20  s a cylindrical 
+00029420: 3364 2073 7572 6661 6365 2066 726f 6d20  3d surface from 
+00029430: 6120 3244 2067 7269 6420 6f66 2076 616c  a 2D grid of val
+00029440: 7565 732c 206f 7220 7265 7475 726e 7320  ues, or returns 
+00029450: 6120 766e 662e 0a2f 2f20 546f 7069 6373  a vnf..// Topics
+00029460: 3a20 4578 7472 7573 696f 6e2c 2054 6578  : Extrusion, Tex
+00029470: 7475 7265 732c 204b 6e75 726c 696e 672c  tures, Knurling,
+00029480: 2048 6569 6768 7466 6965 6c64 0a2f 2f20   Heightfield.// 
+00029490: 5365 6520 416c 736f 3a20 6865 6967 6874  See Also: height
+000294a0: 6669 656c 6428 290a 2f2f 2055 7361 6765  field().// Usage
+000294b0: 3a20 4173 2046 756e 6374 696f 6e0a 2f2f  : As Function.//
+000294c0: 2020 2076 6e66 203d 2063 796c 696e 6472     vnf = cylindr
+000294d0: 6963 616c 5f68 6569 6768 7466 6965 6c64  ical_heightfield
+000294e0: 2864 6174 612c 206c 7c6c 656e 6774 683d  (data, l|length=
+000294f0: 7c68 3d7c 6865 6967 6874 3d2c 2072 7c64  |h=|height=, r|d
+00029500: 3d2c 205b 6261 7365 3d5d 2c20 5b74 7261  =, [base=], [tra
+00029510: 6e73 706f 7365 3d5d 2c20 5b61 7370 6563  nspose=], [aspec
+00029520: 743d 5d29 3b0a 2f2f 2055 7361 6765 3a20  t=]);.// Usage: 
+00029530: 4173 204d 6f64 756c 650a 2f2f 2020 2063  As Module.//   c
+00029540: 796c 696e 6472 6963 616c 5f68 6569 6768  ylindrical_heigh
+00029550: 7466 6965 6c64 2864 6174 612c 206c 7c6c  tfield(data, l|l
+00029560: 656e 6774 683d 7c68 3d7c 6865 6967 6874  ength=|h=|height
+00029570: 3d2c 2072 7c64 3d2c 205b 6261 7365 3d5d  =, r|d=, [base=]
+00029580: 2c20 5b74 7261 6e73 706f 7365 3d5d 2c20  , [transpose=], 
+00029590: 5b61 7370 6563 743d 5d29 205b 4154 5441  [aspect=]) [ATTA
+000295a0: 4348 4d45 4e54 535d 3b0a 2f2f 2044 6573  CHMENTS];.// Des
+000295b0: 6372 6970 7469 6f6e 3a0a 2f2f 2020 2047  cription:.//   G
+000295c0: 6976 656e 2061 2072 6567 756c 6172 2072  iven a regular r
+000295d0: 6563 7461 6e67 756c 6172 2032 4420 6772  ectangular 2D gr
+000295e0: 6964 206f 6620 7363 616c 6172 2076 616c  id of scalar val
+000295f0: 7565 732c 206f 7220 6120 6675 6e63 7469  ues, or a functi
+00029600: 6f6e 206c 6974 6572 616c 206f 6620 7369  on literal of si
+00029610: 676e 6174 7572 6520 2878 2c79 292c 2067  gnature (x,y), g
+00029620: 656e 6572 6174 6573 0a2f 2f20 2020 6120  enerates.//   a 
+00029630: 6379 6c69 6e64 7269 6361 6c20 3344 2073  cylindrical 3D s
+00029640: 7572 6661 6365 2077 6865 7265 2074 6865  urface where the
+00029650: 2068 6569 6768 7420 6174 2061 6e79 2067   height at any g
+00029660: 6976 656e 2070 6f69 6e74 2061 626f 7665  iven point above
+00029670: 2074 6865 2072 6164 6975 7320 6072 3d60   the radius `r=`
+00029680: 2c20 6973 2074 6865 2073 6361 6c61 7220  , is the scalar 
+00029690: 7661 6c75 650a 2f2f 2020 2066 6f72 2074  value.//   for t
+000296a0: 6861 7420 706f 7369 7469 6f6e 2e0a 2f2f  hat position..//
+000296b0: 2020 204f 6e65 2073 6372 6970 7420 746f     One script to
+000296c0: 2063 6f6e 7665 7274 2061 2067 7261 7973   convert a grays
+000296d0: 6361 6c65 2069 6d61 6765 2074 6f20 6120  cale image to a 
+000296e0: 6865 6967 6874 6669 656c 6420 6172 7261  heightfield arra
+000296f0: 7920 696e 2061 202e 7363 6164 2066 696c  y in a .scad fil
+00029700: 6520 6361 6e20 6265 2066 6f75 6e64 2061  e can be found a
+00029710: 743a 0a2f 2f20 2020 6874 7470 733a 2f2f  t:.//   https://
+00029720: 7261 772e 6769 7468 7562 7573 6572 636f  raw.githubuserco
+00029730: 6e74 656e 742e 636f 6d2f 7265 7661 7262  ntent.com/revarb
+00029740: 6174 2f42 4f53 4c32 2f6d 6173 7465 722f  at/BOSL2/master/
+00029750: 7363 7269 7074 732f 696d 6732 7363 6164  scripts/img2scad
+00029760: 2e70 790a 2f2f 2041 7267 756d 656e 7473  .py.// Arguments
+00029770: 3a0a 2f2f 2020 2064 6174 6120 3d20 5468  :.//   data = Th
+00029780: 6973 2069 7320 6569 7468 6572 2074 6865  is is either the
+00029790: 2032 4420 7265 6374 616e 6775 6c61 7220   2D rectangular 
+000297a0: 6172 7261 7920 6f66 2068 6569 6768 7473  array of heights
+000297b0: 2c20 6f72 2061 2066 756e 6374 696f 6e20  , or a function 
+000297c0: 6c69 7465 7261 6c20 6f66 2073 6967 6e61  literal of signa
+000297d0: 7475 7265 2060 2878 2c20 7929 602e 0a2f  ture `(x, y)`../
+000297e0: 2f20 2020 6c20 2f20 6c65 6e67 7468 202f  /   l / length /
+000297f0: 2068 202f 2068 6569 6768 7420 3d20 5468   h / height = Th
+00029800: 6520 6c65 6e67 7468 206f 6620 7468 6520  e length of the 
+00029810: 6379 6c69 6e64 6572 2074 6f20 7772 6170  cylinder to wrap
+00029820: 2061 726f 756e 642e 0a2f 2f20 2020 7220   around..//   r 
+00029830: 3d20 5468 6520 7261 6469 7573 206f 6620  = The radius of 
+00029840: 7468 6520 6379 6c69 6e64 6572 2074 6f20  the cylinder to 
+00029850: 7772 6170 2061 726f 756e 642e 0a2f 2f20  wrap around..// 
+00029860: 2020 2d2d 2d0a 2f2f 2020 2072 3120 3d20    ---.//   r1 = 
+00029870: 5468 6520 7261 6469 7573 206f 6620 7468  The radius of th
+00029880: 6520 626f 7474 6f6d 206f 6620 7468 6520  e bottom of the 
+00029890: 6379 6c69 6e64 6572 2074 6f20 7772 6170  cylinder to wrap
+000298a0: 2061 726f 756e 642e 0a2f 2f20 2020 7232   around..//   r2
+000298b0: 203d 2054 6865 2072 6164 6975 7320 6f66   = The radius of
+000298c0: 2074 6865 2074 6f70 206f 6620 7468 6520   the top of the 
+000298d0: 6379 6c69 6e64 6572 2074 6f20 7772 6170  cylinder to wrap
+000298e0: 2061 726f 756e 642e 0a2f 2f20 2020 6420   around..//   d 
+000298f0: 3d20 5468 6520 6469 616d 6574 6572 206f  = The diameter o
+00029900: 6620 7468 6520 6379 6c69 6e64 6572 2074  f the cylinder t
+00029910: 6f20 7772 6170 2061 726f 756e 642e 0a2f  o wrap around../
+00029920: 2f20 2020 6431 203d 2054 6865 2064 6961  /   d1 = The dia
+00029930: 6d65 7465 7220 6f66 2074 6865 2062 6f74  meter of the bot
+00029940: 746f 6d20 6f66 2074 6865 2063 796c 696e  tom of the cylin
+00029950: 6465 7220 746f 2077 7261 7020 6172 6f75  der to wrap arou
+00029960: 6e64 2e0a 2f2f 2020 2064 3220 3d20 5468  nd..//   d2 = Th
+00029970: 6520 6469 616d 6574 6572 206f 6620 7468  e diameter of th
+00029980: 6520 746f 7020 6f66 2074 6865 2063 796c  e top of the cyl
+00029990: 696e 6465 7220 746f 2077 7261 7020 6172  inder to wrap ar
+000299a0: 6f75 6e64 2e0a 2f2f 2020 2062 6173 6520  ound..//   base 
+000299b0: 3d20 5468 6520 7261 6469 7573 2066 6f72  = The radius for
+000299c0: 2074 6865 2062 6f74 746f 6d20 6f66 2074   the bottom of t
+000299d0: 6865 2068 6569 6768 7466 6965 6c64 206f  he heightfield o
+000299e0: 626a 6563 7420 746f 2063 7265 6174 652e  bject to create.
+000299f0: 2020 416e 7920 6865 6967 6874 7320 736d    Any heights sm
+00029a00: 616c 6c65 7220 7468 616e 2074 6869 7320  aller than this 
+00029a10: 7769 6c6c 2062 6520 7472 756e 6361 7465  will be truncate
+00029a20: 6420 746f 2076 6572 7920 736c 6967 6874  d to very slight
+00029a30: 6c79 2061 626f 7665 2074 6869 7320 6865  ly above this he
+00029a40: 6967 6874 2e20 2044 6566 6175 6c74 3a20  ight.  Default: 
+00029a50: 2d32 300a 2f2f 2020 2074 7261 6e73 706f  -20.//   transpo
+00029a60: 7365 203d 2049 6620 7472 7565 2c20 7377  se = If true, sw
+00029a70: 6170 7320 7468 6520 7261 6469 616c 2061  aps the radial a
+00029a80: 6e64 206c 656e 6774 6820 6178 6573 206f  nd length axes o
+00029a90: 6620 7468 6520 6461 7461 2e20 2044 6566  f the data.  Def
+00029aa0: 6175 6c74 3a20 6661 6c73 650a 2f2f 2020  ault: false.//  
+00029ab0: 2061 7370 6563 7420 3d20 5468 6520 6173   aspect = The as
+00029ac0: 7065 6374 2072 6174 696f 206f 6620 7468  pect ratio of th
+00029ad0: 6520 6765 6e65 7261 7465 6420 6865 6967  e generated heig
+00029ae0: 6874 6669 656c 6420 6174 2074 6865 2073  htfield at the s
+00029af0: 7572 6661 6365 206f 6620 7468 6520 6379  urface of the cy
+00029b00: 6c69 6e64 6572 2e20 2044 6566 6175 6c74  linder.  Default
+00029b10: 3a20 310a 2f2f 2020 2078 7261 6e67 6520  : 1.//   xrange 
+00029b20: 3d20 4120 7261 6e67 6520 6f66 2076 616c  = A range of val
+00029b30: 7565 7320 746f 2069 7465 7261 7465 2058  ues to iterate X
+00029b40: 206f 7665 7220 7768 656e 2063 616c 6375   over when calcu
+00029b50: 6c61 7469 6e67 2061 2073 7572 6661 6365  lating a surface
+00029b60: 2066 726f 6d20 6120 6675 6e63 7469 6f6e   from a function
+00029b70: 206c 6974 6572 616c 2e20 2044 6566 6175   literal.  Defau
+00029b80: 6c74 3a20 5b2d 3120 3a20 302e 3031 203a  lt: [-1 : 0.01 :
+00029b90: 2031 5d0a 2f2f 2020 2079 7261 6e67 6520   1].//   yrange 
+00029ba0: 3d20 4120 7261 6e67 6520 6f66 2076 616c  = A range of val
+00029bb0: 7565 7320 746f 2069 7465 7261 7465 2059  ues to iterate Y
+00029bc0: 206f 7665 7220 7768 656e 2063 616c 6375   over when calcu
+00029bd0: 6c61 7469 6e67 2061 2073 7572 6661 6365  lating a surface
+00029be0: 2066 726f 6d20 6120 6675 6e63 7469 6f6e   from a function
+00029bf0: 206c 6974 6572 616c 2e20 2044 6566 6175   literal.  Defau
+00029c00: 6c74 3a20 5b2d 3120 3a20 302e 3031 203a  lt: [-1 : 0.01 :
+00029c10: 2031 5d0a 2f2f 2020 206d 6178 6820 3d20   1].//   maxh = 
+00029c20: 5468 6520 6d61 7869 6d75 6d20 6865 6967  The maximum heig
+00029c30: 6874 2061 626f 7665 2074 6865 2072 6164  ht above the rad
+00029c40: 6975 7320 746f 206d 6f64 656c 2e20 2054  ius to model.  T
+00029c50: 7275 6e63 6174 6573 2061 6e79 7468 696e  runcates anythin
+00029c60: 6720 7461 6c6c 6572 2074 6f20 7468 6973  g taller to this
+00029c70: 2068 6569 6768 742e 2020 4465 6661 756c   height.  Defaul
+00029c80: 743a 2039 390a 2f2f 2020 2073 7479 6c65  t: 99.//   style
+00029c90: 203d 2054 6865 2073 7479 6c65 206f 6620   = The style of 
+00029ca0: 7375 6264 6976 6964 696e 6720 7468 6520  subdividing the 
+00029cb0: 7175 6164 7320 696e 746f 2066 6163 6573  quads into faces
+00029cc0: 2e20 2056 616c 6964 206f 7074 696f 6e73  .  Valid options
+00029cd0: 2061 7265 2022 6465 6661 756c 7422 2c20   are "default", 
+00029ce0: 2261 6c74 222c 2061 6e64 2022 7175 696e  "alt", and "quin
+00029cf0: 6375 6e78 222e 2020 4465 6661 756c 743a  cunx".  Default:
+00029d00: 2022 6465 6661 756c 7422 0a2f 2f20 2020   "default".//   
+00029d10: 636f 6e76 6578 6974 7920 3d20 4d61 7820  convexity = Max 
+00029d20: 6e75 6d62 6572 206f 6620 7469 6d65 7320  number of times 
+00029d30: 6120 6c69 6e65 2063 6f75 6c64 2069 6e74  a line could int
+00029d40: 6572 7365 6374 2061 2077 616c 6c20 6f66  ersect a wall of
+00029d50: 2074 6865 2073 7572 6661 6365 2062 6569   the surface bei
+00029d60: 6e67 2066 6f72 6d65 642e 204d 6f64 756c  ng formed. Modul
+00029d70: 6520 6f6e 6c79 2e20 2044 6566 6175 6c74  e only.  Default
+00029d80: 3a20 3130 0a2f 2f20 2020 616e 6368 6f72  : 10.//   anchor
+00029d90: 203d 2054 7261 6e73 6c61 7465 2073 6f20   = Translate so 
+00029da0: 616e 6368 6f72 2070 6f69 6e74 2069 7320  anchor point is 
+00029db0: 6174 206f 7269 6769 6e20 2830 2c30 2c30  at origin (0,0,0
+00029dc0: 292e 2020 5365 6520 5b61 6e63 686f 725d  ).  See [anchor]
+00029dd0: 2861 7474 6163 686d 656e 7473 2e73 6361  (attachments.sca
+00029de0: 6423 7375 6273 6563 7469 6f6e 2d61 6e63  d#subsection-anc
+00029df0: 686f 7229 2e20 2044 6566 6175 6c74 3a20  hor).  Default: 
+00029e00: 6043 454e 5445 5260 0a2f 2f20 2020 7370  `CENTER`.//   sp
+00029e10: 696e 203d 2052 6f74 6174 6520 7468 6973  in = Rotate this
+00029e20: 206d 616e 7920 6465 6772 6565 7320 6172   many degrees ar
+00029e30: 6f75 6e64 2074 6865 205a 2061 7869 732e  ound the Z axis.
+00029e40: 2020 5365 6520 5b73 7069 6e5d 2861 7474    See [spin](att
+00029e50: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+00029e60: 6273 6563 7469 6f6e 2d73 7069 6e29 2e20  bsection-spin). 
+00029e70: 2044 6566 6175 6c74 3a20 6030 600a 2f2f   Default: `0`.//
+00029e80: 2020 206f 7269 656e 7420 3d20 5665 6374     orient = Vect
+00029e90: 6f72 2074 6f20 726f 7461 7465 2074 6f70  or to rotate top
+00029ea0: 2074 6f77 6172 6473 2e20 2053 6565 205b   towards.  See [
+00029eb0: 6f72 6965 6e74 5d28 6174 7461 6368 6d65  orient](attachme
+00029ec0: 6e74 732e 7363 6164 2373 7562 7365 6374  nts.scad#subsect
+00029ed0: 696f 6e2d 6f72 6965 6e74 292e 2020 4465  ion-orient).  De
+00029ee0: 6661 756c 743a 2060 5550 600a 2f2f 2045  fault: `UP`.// E
+00029ef0: 7861 6d70 6c65 2856 5044 3d34 3030 3b56  xample(VPD=400;V
+00029f00: 5052 3d5b 3535 2c30 2c31 3530 5d29 3a0a  PR=[55,0,150]):.
+00029f10: 2f2f 2020 2063 796c 696e 6472 6963 616c  //   cylindrical
+00029f20: 5f68 6569 6768 7466 6965 6c64 286c 3d31  _heightfield(l=1
+00029f30: 3030 2c20 723d 3330 2c20 6261 7365 3d35  00, r=30, base=5
+00029f40: 2c20 6461 7461 3d5b 0a2f 2f20 2020 2020  , data=[.//     
+00029f50: 2020 666f 7220 2879 3d5b 2d31 3830 3a34    for (y=[-180:4
+00029f60: 3a31 3830 5d29 205b 0a2f 2f20 2020 2020  :180]) [.//     
+00029f70: 2020 2020 2020 666f 7228 783d 5b2d 3138        for(x=[-18
+00029f80: 303a 343a 3138 305d 290a 2f2f 2020 2020  0:4:180]).//    
+00029f90: 2020 2020 2020 2035 2a63 6f73 2835 2a6e         5*cos(5*n
+00029fa0: 6f72 6d28 5b78 2c79 5d29 292b 350a 2f2f  orm([x,y]))+5.//
+00029fb0: 2020 2020 2020 205d 0a2f 2f20 2020 5d29         ].//   ])
+00029fc0: 3b0a 2f2f 2045 7861 6d70 6c65 2856 5044  ;.// Example(VPD
+00029fd0: 3d34 3030 3b56 5052 3d5b 3535 2c30 2c31  =400;VPR=[55,0,1
+00029fe0: 3530 5d29 3a0a 2f2f 2020 2063 796c 696e  50]):.//   cylin
+00029ff0: 6472 6963 616c 5f68 6569 6768 7466 6965  drical_heightfie
+0002a000: 6c64 286c 3d31 3030 2c20 7231 3d36 302c  ld(l=100, r1=60,
+0002a010: 2072 323d 3330 2c20 6261 7365 3d35 2c20   r2=30, base=5, 
+0002a020: 6461 7461 3d5b 0a2f 2f20 2020 2020 2020  data=[.//       
+0002a030: 666f 7220 2879 3d5b 2d31 3830 3a34 3a31  for (y=[-180:4:1
+0002a040: 3830 5d29 205b 0a2f 2f20 2020 2020 2020  80]) [.//       
+0002a050: 2020 2020 666f 7228 783d 5b2d 3138 303a      for(x=[-180:
+0002a060: 343a 3138 305d 290a 2f2f 2020 2020 2020  4:180]).//      
+0002a070: 2020 2020 2035 2a63 6f73 2835 2a6e 6f72       5*cos(5*nor
+0002a080: 6d28 5b78 2c79 5d29 292b 350a 2f2f 2020  m([x,y]))+5.//  
+0002a090: 2020 2020 205d 0a2f 2f20 2020 5d29 3b0a       ].//   ]);.
+0002a0a0: 2f2f 2045 7861 6d70 6c65 2856 5044 3d34  // Example(VPD=4
+0002a0b0: 3030 3b56 5052 3d5b 3535 2c30 2c31 3530  00;VPR=[55,0,150
+0002a0c0: 5d29 3a20 4865 6967 6874 6669 656c 6420  ]): Heightfield 
+0002a0d0: 6279 2046 756e 6374 696f 6e0a 2f2f 2020  by Function.//  
+0002a0e0: 2066 6e20 3d20 6675 6e63 7469 6f6e 2028   fn = function (
+0002a0f0: 782c 7929 2035 2a73 696e 2878 2a33 3630  x,y) 5*sin(x*360
+0002a100: 292a 636f 7328 792a 3336 3029 2b35 3b0a  )*cos(y*360)+5;.
+0002a110: 2f2f 2020 2063 796c 696e 6472 6963 616c  //   cylindrical
+0002a120: 5f68 6569 6768 7466 6965 6c64 286c 3d31  _heightfield(l=1
+0002a130: 3030 2c20 723d 3330 2c20 6461 7461 3d66  00, r=30, data=f
+0002a140: 6e29 3b0a 2f2f 2045 7861 6d70 6c65 2856  n);.// Example(V
+0002a150: 5044 3d34 3030 3b56 5052 3d5b 3535 2c30  PD=400;VPR=[55,0
+0002a160: 2c31 3530 5d29 3a20 4865 6967 6874 6669  ,150]): Heightfi
+0002a170: 656c 6420 6279 2046 756e 6374 696f 6e2c  eld by Function,
+0002a180: 2077 6974 6820 5370 6563 6966 6963 2052   with Specific R
+0002a190: 616e 6765 730a 2f2f 2020 2066 6e20 3d20  anges.//   fn = 
+0002a1a0: 6675 6e63 7469 6f6e 2028 782c 7929 2032  function (x,y) 2
+0002a1b0: 2a63 6f73 2835 2a6e 6f72 6d28 5b78 2c79  *cos(5*norm([x,y
+0002a1c0: 5d29 293b 0a2f 2f20 2020 6379 6c69 6e64  ]));.//   cylind
+0002a1d0: 7269 6361 6c5f 6865 6967 6874 6669 656c  rical_heightfiel
+0002a1e0: 6428 0a2f 2f20 2020 2020 2020 6c3d 3130  d(.//       l=10
+0002a1f0: 302c 2072 3d33 302c 2062 6173 653d 352c  0, r=30, base=5,
+0002a200: 2064 6174 613d 666e 2c0a 2f2f 2020 2020   data=fn,.//    
+0002a210: 2020 2078 7261 6e67 653d 5b2d 3138 303a     xrange=[-180:
+0002a220: 323a 3138 305d 2c20 7972 616e 6765 3d5b  2:180], yrange=[
+0002a230: 2d31 3830 3a32 3a31 3830 5d0a 2f2f 2020  -180:2:180].//  
+0002a240: 2029 3b0a 0a66 756e 6374 696f 6e20 6379   );..function cy
+0002a250: 6c69 6e64 7269 6361 6c5f 6865 6967 6874  lindrical_height
+0002a260: 6669 656c 6428 0a20 2020 2064 6174 612c  field(.    data,
+0002a270: 206c 2c20 722c 2062 6173 653d 312c 0a20   l, r, base=1,. 
+0002a280: 2020 2074 7261 6e73 706f 7365 3d66 616c     transpose=fal
+0002a290: 7365 2c20 6173 7065 6374 3d31 2c0a 2020  se, aspect=1,.  
+0002a2a0: 2020 7374 796c 653d 226d 696e 5f65 6467    style="min_edg
+0002a2b0: 6522 2c20 6d61 7868 3d39 392c 0a20 2020  e", maxh=99,.   
+0002a2c0: 2078 7261 6e67 653d 5b2d 313a 302e 3031   xrange=[-1:0.01
+0002a2d0: 3a31 5d2c 0a20 2020 2079 7261 6e67 653d  :1],.    yrange=
+0002a2e0: 5b2d 313a 302e 3031 3a31 5d2c 0a20 2020  [-1:0.01:1],.   
+0002a2f0: 2072 312c 2072 322c 2064 2c20 6431 2c20   r1, r2, d, d1, 
+0002a300: 6432 2c20 682c 2068 6569 6768 742c 206c  d2, h, height, l
+0002a310: 656e 6774 682c 200a 2020 2020 616e 6368  ength, .    anch
+0002a320: 6f72 3d43 5452 2c20 7370 696e 3d30 2c20  or=CTR, spin=0, 
+0002a330: 6f72 6965 6e74 3d55 500a 2920 3d0a 2020  orient=UP.) =.  
+0002a340: 2020 6c65 7428 0a20 2020 2020 2020 206c    let(.        l
+0002a350: 203d 206f 6e65 5f64 6566 696e 6564 285b   = one_defined([
+0002a360: 6c2c 2068 2c20 6865 6967 6874 2c20 6c65  l, h, height, le
+0002a370: 6e67 7468 5d2c 2022 6c2c 682c 6865 6967  ngth], "l,h,heig
+0002a380: 6874 2c6c 2229 2c0a 2020 2020 2020 2020  ht,l"),.        
+0002a390: 7231 203d 2067 6574 5f72 6164 6975 7328  r1 = get_radius(
+0002a3a0: 7231 3d72 312c 2072 3d72 2c20 6431 3d64  r1=r1, r=r, d1=d
+0002a3b0: 312c 2064 3d64 292c 0a20 2020 2020 2020  1, d=d),.       
+0002a3c0: 2072 3220 3d20 6765 745f 7261 6469 7573   r2 = get_radius
+0002a3d0: 2872 313d 7232 2c20 723d 722c 2064 313d  (r1=r2, r=r, d1=
+0002a3e0: 6432 2c20 643d 6429 0a20 2020 2029 0a20  d2, d=d).    ). 
+0002a3f0: 2020 2061 7373 6572 7428 6973 5f66 696e     assert(is_fin
+0002a400: 6974 6528 6c29 2026 2620 6c3e 302c 2022  ite(l) && l>0, "
+0002a410: 4d75 7374 2073 7570 706c 7920 6f6e 6520  Must supply one 
+0002a420: 6f66 206c 3d2c 2068 3d2c 206f 7220 6865  of l=, h=, or he
+0002a430: 6967 6874 3d20 6173 2061 2066 696e 6974  ight= as a finit
+0002a440: 6520 706f 7369 7469 7665 206e 756d 6265  e positive numbe
+0002a450: 722e 2229 0a20 2020 2061 7373 6572 7428  r.").    assert(
+0002a460: 6973 5f66 696e 6974 6528 7231 2920 2626  is_finite(r1) &&
+0002a470: 2072 313e 302c 2022 4d75 7374 2073 7570   r1>0, "Must sup
+0002a480: 706c 7920 6f6e 6520 6f66 2072 3d2c 2072  ply one of r=, r
+0002a490: 313d 2c20 643d 2c20 6f72 2064 313d 2061  1=, d=, or d1= a
+0002a4a0: 7320 6120 6669 6e69 7465 2070 6f73 6974  s a finite posit
+0002a4b0: 6976 6520 6e75 6d62 6572 2e22 290a 2020  ive number.").  
+0002a4c0: 2020 6173 7365 7274 2869 735f 6669 6e69    assert(is_fini
+0002a4d0: 7465 2872 3229 2026 2620 7232 3e30 2c20  te(r2) && r2>0, 
+0002a4e0: 224d 7573 7420 7375 7070 6c79 206f 6e65  "Must supply one
+0002a4f0: 206f 6620 723d 2c20 7232 3d2c 2064 3d2c   of r=, r2=, d=,
+0002a500: 206f 7220 6432 3d20 6173 2061 2066 696e   or d2= as a fin
+0002a510: 6974 6520 706f 7369 7469 7665 206e 756d  ite positive num
+0002a520: 6265 722e 2229 0a20 2020 2061 7373 6572  ber.").    asser
+0002a530: 7428 6973 5f66 696e 6974 6528 6261 7365  t(is_finite(base
+0002a540: 2920 2626 2062 6173 653e 302c 2022 4d75  ) && base>0, "Mu
+0002a550: 7374 2073 7570 706c 7920 6261 7365 3d20  st supply base= 
+0002a560: 6173 2061 2066 696e 6974 6520 706f 7369  as a finite posi
+0002a570: 7469 7665 206e 756d 6265 722e 2229 0a20  tive number."). 
+0002a580: 2020 2061 7373 6572 7428 6973 5f6d 6174     assert(is_mat
+0002a590: 7269 7828 6461 7461 297c 7c69 735f 6675  rix(data)||is_fu
+0002a5a0: 6e63 7469 6f6e 2864 6174 6129 2c20 2264  nction(data), "d
+0002a5b0: 6174 613d 206d 7573 7420 6265 2061 2066  ata= must be a f
+0002a5c0: 756e 6374 696f 6e20 6c69 7465 7261 6c2c  unction literal,
+0002a5d0: 206f 7220 636f 6e74 6169 6e20 6120 3244   or contain a 2D
+0002a5e0: 2061 7272 6179 206f 6620 6e75 6d62 6572   array of number
+0002a5f0: 732e 2229 0a20 2020 206c 6574 280a 2020  s.").    let(.  
+0002a600: 2020 2020 2020 7876 616c 7320 3d20 6973        xvals = is
+0002a610: 5f6c 6973 7428 6461 7461 293f 205b 666f  _list(data)? [fo
+0002a620: 7220 2878 203d 2069 6478 2864 6174 615b  r (x = idx(data[
+0002a630: 305d 2929 2078 5d20 3a0a 2020 2020 2020  0])) x] :.      
+0002a640: 2020 2020 2020 6973 5f72 616e 6765 2878        is_range(x
+0002a650: 7261 6e67 6529 3f20 5b66 6f72 2028 7820  range)? [for (x 
+0002a660: 3d20 7872 616e 6765 2920 785d 203a 0a20  = xrange) x] :. 
+0002a670: 2020 2020 2020 2020 2020 2061 7373 6572             asser
+0002a680: 7428 6661 6c73 652c 2022 7872 616e 6765  t(false, "xrange
+0002a690: 3d20 6d75 7374 2062 6520 6769 7665 6e20  = must be given 
+0002a6a0: 6173 2061 2072 616e 6765 2069 6620 6461  as a range if da
+0002a6b0: 7461 3d20 6973 2061 2066 756e 6374 696f  ta= is a functio
+0002a6c0: 6e20 6c69 7465 7261 6c2e 2229 2c0a 2020  n literal."),.  
+0002a6d0: 2020 2020 2020 7976 616c 7320 3d20 6973        yvals = is
+0002a6e0: 5f6c 6973 7428 6461 7461 293f 205b 666f  _list(data)? [fo
+0002a6f0: 7220 2879 203d 2069 6478 2864 6174 6129  r (y = idx(data)
+0002a700: 2920 795d 203a 0a20 2020 2020 2020 2020  ) y] :.         
+0002a710: 2020 2069 735f 7261 6e67 6528 7972 616e     is_range(yran
+0002a720: 6765 293f 205b 666f 7220 2879 203d 2079  ge)? [for (y = y
+0002a730: 7261 6e67 6529 2079 5d20 3a0a 2020 2020  range) y] :.    
+0002a740: 2020 2020 2020 2020 6173 7365 7274 2866          assert(f
+0002a750: 616c 7365 2c20 2279 7261 6e67 653d 206d  alse, "yrange= m
+0002a760: 7573 7420 6265 2067 6976 656e 2061 7320  ust be given as 
+0002a770: 6120 7261 6e67 6520 6966 2064 6174 613d  a range if data=
+0002a780: 2069 7320 6120 6675 6e63 7469 6f6e 206c   is a function l
+0002a790: 6974 6572 616c 2e22 292c 0a20 2020 2020  iteral."),.     
+0002a7a0: 2020 2078 6c65 6e20 3d20 6c65 6e28 7876     xlen = len(xv
+0002a7b0: 616c 7329 2c0a 2020 2020 2020 2020 796c  als),.        yl
+0002a7c0: 656e 203d 206c 656e 2879 7661 6c73 292c  en = len(yvals),
+0002a7d0: 0a20 2020 2020 2020 2073 7465 7079 203d  .        stepy =
+0002a7e0: 206c 202f 2028 796c 656e 2d31 292c 0a20   l / (ylen-1),. 
+0002a7f0: 2020 2020 2020 2073 7465 7078 203d 2073         stepx = s
+0002a800: 7465 7079 202a 2061 7370 6563 742c 0a20  tepy * aspect,. 
+0002a810: 2020 2020 2020 206d 6178 7220 3d20 6d61         maxr = ma
+0002a820: 7828 7231 2c72 3229 2c0a 2020 2020 2020  x(r1,r2),.      
+0002a830: 2020 6369 7263 203d 2032 202a 2050 4920    circ = 2 * PI 
+0002a840: 2a20 6d61 7872 2c0a 2020 2020 2020 2020  * maxr,.        
+0002a850: 6173 7465 7020 3d20 3336 3020 2f20 6369  astep = 360 / ci
+0002a860: 7263 202a 2073 7465 7078 2c0a 2020 2020  rc * stepx,.    
+0002a870: 2020 2020 6172 6320 3d20 6173 7465 7020      arc = astep 
+0002a880: 2a20 2878 6c65 6e2d 3129 2c0a 2020 2020  * (xlen-1),.    
+0002a890: 2020 2020 6273 7465 7073 203d 2072 6f75      bsteps = rou
+0002a8a0: 6e64 2873 6567 7328 6d61 7872 2d62 6173  nd(segs(maxr-bas
+0002a8b0: 6529 202a 2061 7263 202f 2033 3630 292c  e) * arc / 360),
+0002a8c0: 0a20 2020 2020 2020 2062 7374 6570 203d  .        bstep =
+0002a8d0: 2061 7263 202f 2062 7374 6570 730a 2020   arc / bsteps.  
+0002a8e0: 2020 290a 2020 2020 6173 7365 7274 2873    ).    assert(s
+0002a8f0: 7465 7078 2a78 6c65 6e20 3c3d 2063 6972  tepx*xlen <= cir
+0002a900: 632c 2073 7472 2822 6865 6967 6874 6669  c, str("heightfi
+0002a910: 656c 6420 2822 2c78 6c65 6e2c 2220 7820  eld (",xlen," x 
+0002a920: 222c 796c 656e 2c22 2920 6e65 6564 7320  ",ylen,") needs 
+0002a930: 6120 7261 6469 7573 206f 6620 6174 206c  a radius of at l
+0002a940: 6561 7374 2022 2c6d 6178 722a 7374 6570  east ",maxr*step
+0002a950: 782a 786c 656e 2f63 6972 6329 290a 2020  x*xlen/circ)).  
+0002a960: 2020 6c65 7428 0a20 2020 2020 2020 2076    let(.        v
+0002a970: 6572 7473 203d 205b 0a20 2020 2020 2020  erts = [.       
+0002a980: 2020 2020 2066 6f72 2028 7969 203d 2069       for (yi = i
+0002a990: 6478 2879 7661 6c73 2929 206c 6574 280a  dx(yvals)) let(.
+0002a9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002a9b0: 7a20 3d20 7969 202a 2073 7465 7079 202d  z = yi * stepy -
+0002a9c0: 206c 2f32 2c0a 2020 2020 2020 2020 2020   l/2,.          
+0002a9d0: 2020 2020 2020 7272 203d 206c 6572 7028        rr = lerp(
+0002a9e0: 7231 2c20 7232 2c20 7969 2f28 796c 656e  r1, r2, yi/(ylen
+0002a9f0: 2d31 2929 0a20 2020 2020 2020 2020 2020  -1)).           
+0002aa00: 2029 205b 0a20 2020 2020 2020 2020 2020   ) [.           
+0002aa10: 2020 2020 2063 796c 696e 6472 6963 616c       cylindrical
+0002aa20: 5f74 6f5f 7879 7a28 7272 2d62 6173 652c  _to_xyz(rr-base,
+0002aa30: 202d 6172 632f 322c 207a 292c 0a20 2020   -arc/2, z),.   
+0002aa40: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+0002aa50: 2028 7869 203d 2069 6478 2878 7661 6c73   (xi = idx(xvals
+0002aa60: 2929 206c 6574 2820 6120 3d20 7869 2a61  )) let( a = xi*a
+0002aa70: 7374 6570 2029 0a20 2020 2020 2020 2020  step ).         
+0002aa80: 2020 2020 2020 2020 2020 206c 6574 280a             let(.
+0002aa90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002aaa0: 2020 2020 2020 2020 7261 6420 3d20 7472          rad = tr
+0002aab0: 616e 7370 6f73 653f 2028 0a20 2020 2020  anspose? (.     
+0002aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002aad0: 2020 2020 2020 2020 2020 2069 735f 6c69             is_li
+0002aae0: 7374 2864 6174 6129 3f20 6461 7461 5b78  st(data)? data[x
+0002aaf0: 695d 5b79 695d 203a 2064 6174 6128 7976  i][yi] : data(yv
+0002ab00: 616c 735b 7969 5d2c 7876 616c 735b 7869  als[yi],xvals[xi
+0002ab10: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0002ab20: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0002ab30: 203a 2028 0a20 2020 2020 2020 2020 2020   : (.           
+0002ab40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002ab50: 2020 2020 2069 735f 6c69 7374 2864 6174       is_list(dat
+0002ab60: 6129 3f20 6461 7461 5b79 695d 5b78 695d  a)? data[yi][xi]
+0002ab70: 203a 2064 6174 6128 7876 616c 735b 7869   : data(xvals[xi
+0002ab80: 5d2c 7976 616c 735b 7969 5d29 0a20 2020  ],yvals[yi]).   
+0002ab90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002aba0: 2020 2020 2020 2020 2029 2c0a 2020 2020           ),.    
+0002abb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002abc0: 2020 2020 7261 6432 203d 2063 6f6e 7374      rad2 = const
+0002abd0: 7261 696e 2872 6164 2c20 302e 3031 2d62  rain(rad, 0.01-b
+0002abe0: 6173 652c 206d 6178 6829 0a20 2020 2020  ase, maxh).     
+0002abf0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0002ac00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002ac10: 2020 2020 2063 796c 696e 6472 6963 616c       cylindrical
+0002ac20: 5f74 6f5f 7879 7a28 7272 2b72 6164 322c  _to_xyz(rr+rad2,
+0002ac30: 2061 2d61 7263 2f32 2c20 7a29 2c0a 2020   a-arc/2, z),.  
+0002ac40: 2020 2020 2020 2020 2020 2020 2020 6379                cy
+0002ac50: 6c69 6e64 7269 6361 6c5f 746f 5f78 797a  lindrical_to_xyz
+0002ac60: 2872 722d 6261 7365 2c20 6172 632f 322c  (rr-base, arc/2,
+0002ac70: 207a 292c 0a20 2020 2020 2020 2020 2020   z),.           
+0002ac80: 2020 2020 2066 6f72 2028 6220 3d20 5b31       for (b = [1
+0002ac90: 3a31 3a62 7374 6570 732d 315d 2920 6c65  :1:bsteps-1]) le
+0002aca0: 7428 2061 203d 2061 7263 2f32 2d62 2a62  t( a = arc/2-b*b
+0002acb0: 7374 6570 2029 0a20 2020 2020 2020 2020  step ).         
+0002acc0: 2020 2020 2020 2020 2020 2063 796c 696e             cylin
+0002acd0: 6472 6963 616c 5f74 6f5f 7879 7a28 287a  drical_to_xyz((z
+0002ace0: 3e30 3f72 323a 7231 292d 6261 7365 2c20  >0?r2:r1)-base, 
+0002acf0: 612c 206c 2f32 2a28 7a3e 303f 313a 2d31  a, l/2*(z>0?1:-1
+0002ad00: 2929 2c0a 2020 2020 2020 2020 2020 2020  )),.            
+0002ad10: 5d0a 2020 2020 2020 2020 5d2c 0a20 2020  ].        ],.   
+0002ad20: 2020 2020 2076 6e66 203d 2076 6e66 5f76       vnf = vnf_v
+0002ad30: 6572 7465 785f 6172 7261 7928 7665 7274  ertex_array(vert
+0002ad40: 732c 2063 6170 733d 7472 7565 2c20 636f  s, caps=true, co
+0002ad50: 6c5f 7772 6170 3d74 7275 652c 2072 6576  l_wrap=true, rev
+0002ad60: 6572 7365 3d74 7275 652c 2073 7479 6c65  erse=true, style
+0002ad70: 3d73 7479 6c65 290a 2020 2020 2920 7265  =style).    ) re
+0002ad80: 6f72 6965 6e74 2861 6e63 686f 722c 7370  orient(anchor,sp
+0002ad90: 696e 2c6f 7269 656e 742c 2072 313d 7231  in,orient, r1=r1
+0002ada0: 2c20 7232 3d72 322c 206c 3d6c 2c20 703d  , r2=r2, l=l, p=
+0002adb0: 766e 6629 3b0a 0a0a 6d6f 6475 6c65 2063  vnf);...module c
+0002adc0: 796c 696e 6472 6963 616c 5f68 6569 6768  ylindrical_heigh
+0002add0: 7466 6965 6c64 280a 2020 2020 6461 7461  tfield(.    data
+0002ade0: 2c20 6c2c 2072 2c20 6261 7365 3d31 2c0a  , l, r, base=1,.
+0002adf0: 2020 2020 7472 616e 7370 6f73 653d 6661      transpose=fa
+0002ae00: 6c73 652c 2061 7370 6563 743d 312c 0a20  lse, aspect=1,. 
+0002ae10: 2020 2073 7479 6c65 3d22 6d69 6e5f 6564     style="min_ed
+0002ae20: 6765 222c 2063 6f6e 7665 7869 7479 3d31  ge", convexity=1
+0002ae30: 302c 0a20 2020 2078 7261 6e67 653d 5b2d  0,.    xrange=[-
+0002ae40: 313a 302e 3031 3a31 5d2c 2079 7261 6e67  1:0.01:1], yrang
+0002ae50: 653d 5b2d 313a 302e 3031 3a31 5d2c 0a20  e=[-1:0.01:1],. 
+0002ae60: 2020 206d 6178 683d 3939 2c20 7231 2c20     maxh=99, r1, 
+0002ae70: 7232 2c20 642c 2064 312c 2064 322c 2068  r2, d, d1, d2, h
+0002ae80: 2c20 6865 6967 6874 2c20 6c65 6e67 7468  , height, length
+0002ae90: 2c0a 2020 2020 616e 6368 6f72 3d43 5452  ,.    anchor=CTR
+0002aea0: 2c20 7370 696e 3d30 2c20 6f72 6965 6e74  , spin=0, orient
+0002aeb0: 3d55 500a 2920 7b0a 2020 2020 6c20 3d20  =UP.) {.    l = 
+0002aec0: 6f6e 655f 6465 6669 6e65 6428 5b6c 2c20  one_defined([l, 
+0002aed0: 682c 2068 6569 6768 742c 206c 656e 6774  h, height, lengt
+0002aee0: 685d 2c20 226c 2c68 2c68 6569 6768 742c  h], "l,h,height,
+0002aef0: 6c65 6e67 7468 2229 3b0a 2020 2020 7231  length");.    r1
+0002af00: 203d 2067 6574 5f72 6164 6975 7328 7231   = get_radius(r1
+0002af10: 3d72 312c 2072 3d72 2c20 6431 3d64 312c  =r1, r=r, d1=d1,
+0002af20: 2064 3d64 293b 0a20 2020 2072 3220 3d20   d=d);.    r2 = 
+0002af30: 6765 745f 7261 6469 7573 2872 313d 7232  get_radius(r1=r2
+0002af40: 2c20 723d 722c 2064 313d 6432 2c20 643d  , r=r, d1=d2, d=
+0002af50: 6429 3b0a 2020 2020 766e 6620 3d20 6379  d);.    vnf = cy
+0002af60: 6c69 6e64 7269 6361 6c5f 6865 6967 6874  lindrical_height
+0002af70: 6669 656c 6428 0a20 2020 2020 2020 2064  field(.        d
+0002af80: 6174 612c 206c 3d6c 2c20 7231 3d72 312c  ata, l=l, r1=r1,
+0002af90: 2072 323d 7232 2c20 6261 7365 3d62 6173   r2=r2, base=bas
+0002afa0: 652c 0a20 2020 2020 2020 2078 7261 6e67  e,.        xrang
+0002afb0: 653d 7872 616e 6765 2c20 7972 616e 6765  e=xrange, yrange
+0002afc0: 3d79 7261 6e67 652c 0a20 2020 2020 2020  =yrange,.       
+0002afd0: 206d 6178 683d 6d61 7868 2c20 7472 616e   maxh=maxh, tran
+0002afe0: 7370 6f73 653d 7472 616e 7370 6f73 652c  spose=transpose,
+0002aff0: 0a20 2020 2020 2020 2061 7370 6563 743d  .        aspect=
+0002b000: 6173 7065 6374 2c20 7374 796c 653d 7374  aspect, style=st
+0002b010: 796c 650a 2020 2020 293b 0a20 2020 2061  yle.    );.    a
+0002b020: 7474 6163 6861 626c 6528 616e 6368 6f72  ttachable(anchor
+0002b030: 2c73 7069 6e2c 6f72 6965 6e74 2c20 7231  ,spin,orient, r1
+0002b040: 3d72 312c 2072 323d 7232 2c20 6c3d 6c29  =r1, r2=r2, l=l)
+0002b050: 207b 0a20 2020 2020 2020 2076 6e66 5f70   {.        vnf_p
+0002b060: 6f6c 7968 6564 726f 6e28 766e 662c 2063  olyhedron(vnf, c
+0002b070: 6f6e 7665 7869 7479 3d63 6f6e 7665 7869  onvexity=convexi
+0002b080: 7479 293b 0a20 2020 2020 2020 2063 6869  ty);.        chi
+0002b090: 6c64 7265 6e28 293b 0a20 2020 207d 0a7d  ldren();.    }.}
+0002b0a0: 0a0a 0a2f 2f20 4d6f 6475 6c65 3a20 7275  ...// Module: ru
+0002b0b0: 6c65 7228 290a 2f2f 2053 796e 6f70 7369  ler().// Synopsi
+0002b0c0: 733a 2043 7265 6174 6573 2061 2072 756c  s: Creates a rul
+0002b0d0: 6572 2e0a 2f2f 2054 6f70 6963 733a 2044  er..// Topics: D
+0002b0e0: 6973 7461 6e63 650a 2f2f 2055 7361 6765  istance.// Usage
+0002b0f0: 3a0a 2f2f 2020 2072 756c 6572 286c 656e  :.//   ruler(len
+0002b100: 6774 682c 2077 6964 7468 2c20 5b74 6869  gth, width, [thi
+0002b110: 636b 6e65 7373 3d5d 2c20 5b64 6570 7468  ckness=], [depth
+0002b120: 3d5d 2c20 5b6c 6162 656c 733d 5d2c 205b  =], [labels=], [
+0002b130: 7069 7073 6361 6c65 3d5d 2c20 5b6d 6178  pipscale=], [max
+0002b140: 7363 616c 653d 5d2c 205b 636f 6c6f 7273  scale=], [colors
+0002b150: 3d5d 2c20 5b61 6c70 6861 3d5d 2c20 5b75  =], [alpha=], [u
+0002b160: 6e69 743d 5d2c 205b 696e 6368 3d5d 2920  nit=], [inch=]) 
+0002b170: 5b41 5454 4143 484d 454e 5453 5d3b 0a2f  [ATTACHMENTS];./
+0002b180: 2f20 4465 7363 7269 7074 696f 6e3a 0a2f  / Description:./
+0002b190: 2f20 2020 4372 6561 7465 7320 616e 2061  /   Creates an a
+0002b1a0: 7474 6163 6861 626c 6520 7275 6c65 7220  ttachable ruler 
+0002b1b0: 666f 7220 6368 6563 6b69 6e67 2064 696d  for checking dim
+0002b1c0: 656e 7369 6f6e 7320 6f66 2074 6865 206d  ensions of the m
+0002b1d0: 6f64 656c 2e0a 2f2f 2041 7267 756d 656e  odel..// Argumen
+0002b1e0: 7473 3a0a 2f2f 2020 206c 656e 6774 6820  ts:.//   length 
+0002b1f0: 3d20 6c65 6e67 7468 206f 6620 7468 6520  = length of the 
+0002b200: 7275 6c65 722e 2020 4465 6661 756c 7420  ruler.  Default 
+0002b210: 3130 300a 2f2f 2020 2077 6964 7468 203d  100.//   width =
+0002b220: 2077 6964 7468 206f 6620 7468 6520 7275   width of the ru
+0002b230: 6c65 722e 2020 4465 6661 756c 743a 2073  ler.  Default: s
+0002b240: 697a 6520 6f66 2074 6865 206c 6172 6765  ize of the large
+0002b250: 7374 2075 6e69 7420 6469 7669 7369 6f6e  st unit division
+0002b260: 0a2f 2f20 2020 2d2d 2d0a 2f2f 2020 2074  .//   ---.//   t
+0002b270: 6869 636b 6e65 7373 203d 2074 6869 636b  hickness = thick
+0002b280: 6e65 7373 206f 6620 7468 6520 7275 6c65  ness of the rule
+0002b290: 722e 2044 6566 6175 6c74 3a20 310a 2f2f  r. Default: 1.//
+0002b2a0: 2020 2064 6570 7468 203d 2074 6865 2064     depth = the d
+0002b2b0: 6570 7468 206f 6620 6d61 726b 2073 7562  epth of mark sub
+0002b2c0: 6469 7669 7369 6f6e 732e 2044 6566 6175  divisions. Defau
+0002b2d0: 6c74 3a20 330a 2f2f 2020 206c 6162 656c  lt: 3.//   label
+0002b2e0: 7320 3d20 6472 6177 206e 756d 6572 6963  s = draw numeric
+0002b2f0: 206c 6162 656c 7320 666f 7220 6465 7074   labels for dept
+0002b300: 6873 2077 6865 7265 206c 6162 656c 7320  hs where labels 
+0002b310: 6172 6520 6c61 7267 6572 2074 6861 6e20  are larger than 
+0002b320: 312e 2020 4465 6661 756c 743a 2066 616c  1.  Default: fal
+0002b330: 7365 0a2f 2f20 2020 7069 7073 6361 6c65  se.//   pipscale
+0002b340: 203d 2077 6964 7468 2073 6361 6c65 206f   = width scale o
+0002b350: 6620 7468 6520 7069 7073 2072 656c 6174  f the pips relat
+0002b360: 6976 6520 746f 2074 6865 206e 6578 7420  ive to the next 
+0002b370: 7369 7a65 2075 702e 2020 4465 6661 756c  size up.  Defaul
+0002b380: 743a 2031 2f33 0a2f 2f20 2020 6d61 7873  t: 1/3.//   maxs
+0002b390: 6361 6c65 203d 206c 6f67 3130 206f 6620  cale = log10 of 
+0002b3a0: 7468 6520 6d61 7869 6d75 6d20 7769 6474  the maximum widt
+0002b3b0: 6820 6469 7669 7369 6f6e 7320 746f 2064  h divisions to d
+0002b3c0: 6973 706c 6179 2e20 2044 6566 6175 6c74  isplay.  Default
+0002b3d0: 3a20 6261 7365 6420 6f6e 2069 6e70 7574  : based on input
+0002b3e0: 206c 656e 6774 680a 2f2f 2020 2063 6f6c   length.//   col
+0002b3f0: 6f72 7320 3d20 636f 6c6f 7273 2074 6f20  ors = colors to 
+0002b400: 7573 6520 666f 7220 7468 6520 7275 6c65  use for the rule
+0002b410: 722c 2061 206c 6973 7420 6f66 2074 776f  r, a list of two
+0002b420: 2076 616c 7565 732e 2020 4465 6661 756c   values.  Defaul
+0002b430: 743a 2060 5b22 626c 6163 6b22 2c22 7768  t: `["black","wh
+0002b440: 6974 6522 5d60 0a2f 2f20 2020 616c 7068  ite"]`.//   alph
+0002b450: 6120 3d20 7472 616e 7370 6172 656e 6379  a = transparency
+0002b460: 2076 616c 7565 2e20 2044 6566 6175 6c74   value.  Default
+0002b470: 3a20 312e 300a 2f2f 2020 2075 6e69 7420  : 1.0.//   unit 
+0002b480: 3d20 756e 6974 2074 6f20 6d61 726b 2e20  = unit to mark. 
+0002b490: 2053 6361 6c65 7320 7468 6520 7275 6c65   Scales the rule
+0002b4a0: 7220 6d61 726b 7320 746f 2061 2064 6966  r marks to a dif
+0002b4b0: 6665 7265 6e74 206c 656e 6774 682e 2020  ferent length.  
+0002b4c0: 4465 6661 756c 743a 2031 0a2f 2f20 2020  Default: 1.//   
+0002b4d0: 696e 6368 203d 2073 6574 2074 6f20 7472  inch = set to tr
+0002b4e0: 7565 2066 6f72 2061 2072 756c 6572 2073  ue for a ruler s
+0002b4f0: 6361 6c65 6420 746f 2069 6e63 6865 7320  caled to inches 
+0002b500: 2861 7373 756d 696e 6720 6261 7365 2064  (assuming base d
+0002b510: 696d 656e 7369 6f6e 2069 7320 6d6d 292e  imension is mm).
+0002b520: 2020 4465 6661 756c 743a 2066 616c 7365    Default: false
+0002b530: 0a2f 2f20 2020 616e 6368 6f72 203d 2054  .//   anchor = T
+0002b540: 7261 6e73 6c61 7465 2073 6f20 616e 6368  ranslate so anch
+0002b550: 6f72 2070 6f69 6e74 2069 7320 6174 206f  or point is at o
+0002b560: 7269 6769 6e20 2830 2c30 2c30 292e 2020  rigin (0,0,0).  
+0002b570: 5365 6520 5b61 6e63 686f 725d 2861 7474  See [anchor](att
+0002b580: 6163 686d 656e 7473 2e73 6361 6423 7375  achments.scad#su
+0002b590: 6273 6563 7469 6f6e 2d61 6e63 686f 7229  bsection-anchor)
+0002b5a0: 2e20 2044 6566 6175 6c74 3a20 604c 4546  .  Default: `LEF
+0002b5b0: 542b 4241 434b 2b54 4f50 600a 2f2f 2020  T+BACK+TOP`.//  
+0002b5c0: 2073 7069 6e20 3d20 526f 7461 7465 2074   spin = Rotate t
+0002b5d0: 6869 7320 6d61 6e79 2064 6567 7265 6573  his many degrees
+0002b5e0: 2061 726f 756e 6420 7468 6520 5a20 6178   around the Z ax
+0002b5f0: 6973 2e20 2053 6565 205b 7370 696e 5d28  is.  See [spin](
+0002b600: 6174 7461 6368 6d65 6e74 732e 7363 6164  attachments.scad
+0002b610: 2373 7562 7365 6374 696f 6e2d 7370 696e  #subsection-spin
+0002b620: 292e 2020 4465 6661 756c 743a 2060 3060  ).  Default: `0`
+0002b630: 0a2f 2f20 2020 6f72 6965 6e74 203d 2056  .//   orient = V
+0002b640: 6563 746f 7220 746f 2072 6f74 6174 6520  ector to rotate 
+0002b650: 746f 7020 746f 7761 7264 732e 2020 5365  top towards.  Se
+0002b660: 6520 5b6f 7269 656e 745d 2861 7474 6163  e [orient](attac
+0002b670: 686d 656e 7473 2e73 6361 6423 7375 6273  hments.scad#subs
+0002b680: 6563 7469 6f6e 2d6f 7269 656e 7429 2e20  ection-orient). 
+0002b690: 2044 6566 6175 6c74 3a20 6055 5060 0a2f   Default: `UP`./
+0002b6a0: 2f20 4578 616d 706c 6573 2832 442c 4269  / Examples(2D,Bi
+0002b6b0: 6729 3a0a 2f2f 2020 2072 756c 6572 2831  g):.//   ruler(1
+0002b6c0: 3030 2c64 6570 7468 3d33 293b 0a2f 2f20  00,depth=3);.// 
+0002b6d0: 2020 7275 6c65 7228 3130 302c 6465 7074    ruler(100,dept
+0002b6e0: 683d 332c 6c61 6265 6c73 3d74 7275 6529  h=3,labels=true)
+0002b6f0: 3b0a 2f2f 2020 2072 756c 6572 2832 3729  ;.//   ruler(27)
+0002b700: 3b0a 2f2f 2020 2072 756c 6572 2832 372c  ;.//   ruler(27,
+0002b710: 6d61 7873 6361 6c65 3d30 293b 0a2f 2f20  maxscale=0);.// 
+0002b720: 2020 7275 6c65 7228 3130 302c 7069 7073    ruler(100,pips
+0002b730: 6361 6c65 3d33 2f34 2c64 6570 7468 3d32  cale=3/4,depth=2
+0002b740: 293b 0a2f 2f20 2020 7275 6c65 7228 3130  );.//   ruler(10
+0002b750: 302c 7769 6474 683d 322c 6465 7074 683d  0,width=2,depth=
+0002b760: 3229 3b0a 2f2f 2045 7861 6d70 6c65 2832  2);.// Example(2
+0002b770: 442c 4269 6729 3a20 204d 6574 7269 6320  D,Big):  Metric 
+0002b780: 7673 2049 6d70 6572 6961 6c0a 2f2f 2020  vs Imperial.//  
+0002b790: 2072 756c 6572 2831 322c 7769 6474 683d   ruler(12,width=
+0002b7a0: 3530 2c69 6e63 683d 7472 7565 2c6c 6162  50,inch=true,lab
+0002b7b0: 656c 733d 7472 7565 2c6d 6178 7363 616c  els=true,maxscal
+0002b7c0: 653d 3029 3b0a 2f2f 2020 2066 7764 2835  e=0);.//   fwd(5
+0002b7d0: 3029 7275 6c65 7228 3330 302c 7769 6474  0)ruler(300,widt
+0002b7e0: 683d 3530 2c6c 6162 656c 733d 7472 7565  h=50,labels=true
+0002b7f0: 293b 0a0a 6d6f 6475 6c65 2072 756c 6572  );..module ruler
+0002b800: 286c 656e 6774 683d 3130 302c 2077 6964  (length=100, wid
+0002b810: 7468 2c20 7468 6963 6b6e 6573 733d 312c  th, thickness=1,
+0002b820: 2064 6570 7468 3d33 2c20 6c61 6265 6c73   depth=3, labels
+0002b830: 3d66 616c 7365 2c20 7069 7073 6361 6c65  =false, pipscale
+0002b840: 3d31 2f33 2c20 6d61 7873 6361 6c65 2c0a  =1/3, maxscale,.
+0002b850: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
+0002b860: 6f72 733d 5b22 626c 6163 6b22 2c22 7768  ors=["black","wh
+0002b870: 6974 6522 5d2c 2061 6c70 6861 3d31 2e30  ite"], alpha=1.0
+0002b880: 2c20 756e 6974 3d31 2c20 696e 6368 3d66  , unit=1, inch=f
+0002b890: 616c 7365 2c20 616e 6368 6f72 3d4c 4546  alse, anchor=LEF
+0002b8a0: 542b 4241 434b 2b54 4f50 2c20 7370 696e  T+BACK+TOP, spin
+0002b8b0: 3d30 2c20 6f72 6965 6e74 3d55 5029 0a7b  =0, orient=UP).{
+0002b8c0: 0a20 2020 2069 6e63 6866 6163 746f 7220  .    inchfactor 
+0002b8d0: 3d20 3235 2e34 3b0a 2020 2020 6368 6563  = 25.4;.    chec
+0002b8e0: 6b73 203d 0a20 2020 2020 2020 2061 7373  ks =.        ass
+0002b8f0: 6572 7428 6465 7074 683c 3d35 2c20 2243  ert(depth<=5, "C
+0002b900: 616e 6e6f 7420 7265 6e64 6572 2073 6361  annot render sca
+0002b910: 6c65 7320 736d 616c 6c65 7220 7468 616e  les smaller than
+0002b920: 2064 6570 7468 3d35 2229 0a20 2020 2020   depth=5").     
+0002b930: 2020 2061 7373 6572 7428 6c65 6e28 636f     assert(len(co
+0002b940: 6c6f 7273 293d 3d32 2c20 2263 6f6c 6f72  lors)==2, "color
+0002b950: 7320 6d75 7374 2063 6f6e 7461 696e 2061  s must contain a
+0002b960: 206c 6973 7420 6f66 2065 7861 6374 6c79   list of exactly
+0002b970: 2074 776f 2063 6f6c 6f72 732e 2229 3b0a   two colors.");.
+0002b980: 2020 2020 6c65 6e67 7468 203d 2069 6e63      length = inc
+0002b990: 6820 3f20 696e 6368 6661 6374 6f72 202a  h ? inchfactor *
+0002b9a0: 206c 656e 6774 6820 3a20 6c65 6e67 7468   length : length
+0002b9b0: 3b0a 2020 2020 756e 6974 203d 2069 6e63  ;.    unit = inc
+0002b9c0: 6820 3f20 696e 6368 6661 6374 6f72 2a75  h ? inchfactor*u
+0002b9d0: 6e69 7420 3a20 756e 6974 3b0a 2020 2020  nit : unit;.    
+0002b9e0: 6d61 7873 6361 6c65 203d 2069 735f 6465  maxscale = is_de
+0002b9f0: 6628 6d61 7873 6361 6c65 293f 206d 6178  f(maxscale)? max
+0002ba00: 7363 616c 6520 3a20 666c 6f6f 7228 6c6f  scale : floor(lo
+0002ba10: 6728 6c65 6e67 7468 2f75 6e69 742d 4550  g(length/unit-EP
+0002ba20: 5349 4c4f 4e29 293b 0a20 2020 2073 6361  SILON));.    sca
+0002ba30: 6c65 7320 3d20 756e 6974 202a 205b 666f  les = unit * [fo
+0002ba40: 7228 6c6f 6773 697a 6520 3d20 5b6d 6178  r(logsize = [max
+0002ba50: 7363 616c 653a 2d31 3a6d 6178 7363 616c  scale:-1:maxscal
+0002ba60: 652d 6465 7074 682b 315d 2920 706f 7728  e-depth+1]) pow(
+0002ba70: 3130 2c6c 6f67 7369 7a65 295d 3b0a 2020  10,logsize)];.  
+0002ba80: 2020 7769 6474 6866 6163 746f 7220 3d20    widthfactor = 
+0002ba90: 2831 2d70 6970 7363 616c 6529 202f 2028  (1-pipscale) / (
+0002baa0: 312d 706f 7728 7069 7073 6361 6c65 2c64  1-pow(pipscale,d
+0002bab0: 6570 7468 2929 3b0a 2020 2020 7769 6474  epth));.    widt
+0002bac0: 6820 3d20 6465 6661 756c 7428 7769 6474  h = default(widt
+0002bad0: 682c 2073 6361 6c65 735b 305d 293b 0a20  h, scales[0]);. 
+0002bae0: 2020 2077 6964 7468 7320 3d20 7769 6474     widths = widt
+0002baf0: 6820 2a20 7769 6474 6866 6163 746f 7220  h * widthfactor 
+0002bb00: 2a20 5b66 6f72 286c 6f67 7369 7a65 203d  * [for(logsize =
+0002bb10: 205b 303a 2d31 3a2d 6465 7074 682b 315d   [0:-1:-depth+1]
+0002bb20: 2920 706f 7728 7069 7073 6361 6c65 2c2d  ) pow(pipscale,-
+0002bb30: 6c6f 6773 697a 6529 5d3b 0a20 2020 206f  logsize)];.    o
+0002bb40: 6666 7365 7473 203d 2063 6f6e 6361 7428  ffsets = concat(
+0002bb50: 5b30 5d2c 6375 6d73 756d 2877 6964 7468  [0],cumsum(width
+0002bb60: 7329 293b 0a20 2020 2061 7474 6163 6861  s));.    attacha
+0002bb70: 626c 6528 616e 6368 6f72 2c73 7069 6e2c  ble(anchor,spin,
+0002bb80: 6f72 6965 6e74 2c20 7369 7a65 3d5b 6c65  orient, size=[le
+0002bb90: 6e67 7468 2c77 6964 7468 2c74 6869 636b  ngth,width,thick
+0002bba0: 6e65 7373 5d29 207b 0a20 2020 2020 2020  ness]) {.       
+0002bbb0: 2074 7261 6e73 6c61 7465 285b 2d6c 656e   translate([-len
+0002bbc0: 6774 682f 322c 202d 7769 6474 682f 322c  gth/2, -width/2,
+0002bbd0: 2030 5d29 0a20 2020 2020 2020 2066 6f72   0]).        for
+0002bbe0: 2869 3d5b 303a 313a 6c65 6e28 7363 616c  (i=[0:1:len(scal
+0002bbf0: 6573 292d 315d 2920 7b0a 2020 2020 2020  es)-1]) {.      
+0002bc00: 2020 2020 2020 636f 756e 7420 3d20 6365        count = ce
+0002bc10: 696c 286c 656e 6774 682f 7363 616c 6573  il(length/scales
+0002bc20: 5b69 5d29 3b0a 2020 2020 2020 2020 2020  [i]);.          
+0002bc30: 2020 666f 6e74 7369 7a65 203d 2030 2e35    fontsize = 0.5
+0002bc40: 2a6d 696e 2877 6964 7468 735b 695d 2c20  *min(widths[i], 
+0002bc50: 7363 616c 6573 5b69 5d2f 6365 696c 286c  scales[i]/ceil(l
+0002bc60: 6f67 2863 6f75 6e74 2a73 6361 6c65 735b  og(count*scales[
+0002bc70: 695d 2f75 6e69 7429 2929 3b0a 2020 2020  i]/unit)));.    
+0002bc80: 2020 2020 2020 2020 6261 636b 286f 6666          back(off
+0002bc90: 7365 7473 5b69 5d29 207b 0a20 2020 2020  sets[i]) {.     
+0002bca0: 2020 2020 2020 2020 2020 2078 636f 7069             xcopi
+0002bcb0: 6573 2873 6361 6c65 735b 695d 2c20 6e3d  es(scales[i], n=
+0002bcc0: 636f 756e 742c 2073 703d 5b30 2c30 2c30  count, sp=[0,0,0
+0002bcd0: 5d29 2075 6e69 6f6e 2829 207b 0a20 2020  ]) union() {.   
+0002bce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002bcf0: 2061 6374 6c65 6e20 3d20 2824 6964 783c   actlen = ($idx<
+0002bd00: 636f 756e 742d 3129 207c 7c20 6170 7072  count-1) || appr
+0002bd10: 6f78 286c 656e 6774 6825 7363 616c 6573  ox(length%scales
+0002bd20: 5b69 5d2c 3029 203f 2073 6361 6c65 735b  [i],0) ? scales[
+0002bd30: 695d 203a 206c 656e 6774 6820 2520 7363  i] : length % sc
+0002bd40: 616c 6573 5b69 5d3b 0a20 2020 2020 2020  ales[i];.       
+0002bd50: 2020 2020 2020 2020 2020 2020 2063 6f6c               col
+0002bd60: 6f72 2863 6f6c 6f72 735b 2469 6478 2532  or(colors[$idx%2
+0002bd70: 5d2c 2061 6c70 6861 3d61 6c70 6861 2920  ], alpha=alpha) 
+0002bd80: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+0002bd90: 2020 2020 2020 2020 2020 7720 3d20 693e            w = i>
+0002bda0: 3020 3f20 7175 616e 7475 7028 7769 6474  0 ? quantup(widt
+0002bdb0: 6873 5b69 5d2c 312f 3130 3234 2920 3a20  hs[i],1/1024) : 
+0002bdc0: 7769 6474 6873 5b69 5d3b 2020 2020 2f2f  widths[i];    //
+0002bdd0: 2057 6861 7420 6973 2074 6865 2069 3e30   What is the i>0
+0002bde0: 2074 6573 7420 7375 7070 6f73 6564 2074   test supposed t
+0002bdf0: 6f20 646f 2068 6572 653f 0a20 2020 2020  o do here?.     
+0002be00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002be10: 2020 2063 7562 6528 5b71 7561 6e74 7570     cube([quantup
+0002be20: 2861 6374 6c65 6e2c 312f 3130 3234 292c  (actlen,1/1024),
+0002be30: 7175 616e 7475 7028 772c 312f 3130 3234  quantup(w,1/1024
+0002be40: 292c 7468 6963 6b6e 6573 735d 2c20 616e  ),thickness], an
+0002be50: 6368 6f72 3d46 524f 4e54 2b4c 4546 5429  chor=FRONT+LEFT)
+0002be60: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+0002be70: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+0002be80: 2020 2020 2020 2020 2020 2020 6d61 726b              mark
+0002be90: 203d 0a20 2020 2020 2020 2020 2020 2020   =.             
+0002bea0: 2020 2020 2020 2020 2020 2069 203d 3d20             i == 
+0002beb0: 3020 2626 2024 6964 7820 2520 3130 203d  0 && $idx % 10 =
+0002bec0: 3d20 3020 2626 2024 6964 7820 213d 2030  = 0 && $idx != 0
+0002bed0: 203f 2030 203a 0a20 2020 2020 2020 2020   ? 0 :.         
+0002bee0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0002bef0: 203d 3d20 3020 2626 2024 6964 7820 2520   == 0 && $idx % 
+0002bf00: 3130 203d 3d20 3920 2626 2024 6964 7820  10 == 9 && $idx 
+0002bf10: 213d 2063 6f75 6e74 2d31 203f 2031 203a  != count-1 ? 1 :
+0002bf20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002bf30: 2020 2020 2020 2020 2024 6964 7820 2520           $idx % 
+0002bf40: 3130 203d 3d20 3420 3f20 3120 3a0a 2020  10 == 4 ? 1 :.  
+0002bf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002bf60: 2020 2020 2020 2469 6478 2025 2031 3020        $idx % 10 
+0002bf70: 3d3d 2035 203f 2030 203a 202d 313b 0a20  == 5 ? 0 : -1;. 
+0002bf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002bf90: 2020 2066 6c69 7020 3d20 312d 6d61 726b     flip = 1-mark
+0002bfa0: 2a32 3b0a 2020 2020 2020 2020 2020 2020  *2;.            
+0002bfb0: 2020 2020 2020 2020 6966 2028 6d61 726b          if (mark
+0002bfc0: 203e 3d20 3029 207b 0a20 2020 2020 2020   >= 0) {.       
+0002bfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002bfe0: 206d 6172 6b6c 656e 6774 6820 3d20 6d69   marklength = mi
+0002bff0: 6e28 7769 6474 6873 5b69 5d2f 322c 2073  n(widths[i]/2, s
+0002c000: 6361 6c65 735b 695d 2a32 293b 0a20 2020  cales[i]*2);.   
+0002c010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c020: 2020 2020 206d 6172 6b77 6964 7468 203d       markwidth =
+0002c030: 206d 6172 6b6c 656e 6774 682a 302e 343b   marklength*0.4;
+0002c040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002c050: 2020 2020 2020 2020 2074 7261 6e73 6c61           transla
+0002c060: 7465 285b 6d61 726b 2a73 6361 6c65 735b  te([mark*scales[
+0002c070: 695d 2c20 7769 6474 6873 5b69 5d2c 2030  i], widths[i], 0
+0002c080: 5d29 207b 0a20 2020 2020 2020 2020 2020  ]) {.           
+0002c090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c0a0: 2063 6f6c 6f72 2863 6f6c 6f72 735b 312d   color(colors[1-
+0002c0b0: 2469 6478 2532 5d2c 2061 6c70 6861 3d61  $idx%2], alpha=a
+0002c0c0: 6c70 6861 2920 7b0a 2020 2020 2020 2020  lpha) {.        
+0002c0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c0e0: 2020 2020 2020 2020 6c69 6e65 6172 5f65          linear_e
+0002c0f0: 7874 7275 6465 2868 6569 6768 743d 7468  xtrude(height=th
+0002c100: 6963 6b6e 6573 732b 7363 616c 6573 5b69  ickness+scales[i
+0002c110: 5d2f 3130 302c 2063 6f6e 7665 7869 7479  ]/100, convexity
+0002c120: 3d32 2c20 6365 6e74 6572 3d74 7275 6529  =2, center=true)
+0002c130: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0002c140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c150: 2020 2020 2020 2070 6f6c 7967 6f6e 2873         polygon(s
+0002c160: 6361 6c65 285b 666c 6970 2a6d 6172 6b77  cale([flip*markw
+0002c170: 6964 7468 2c20 6d61 726b 6c65 6e67 7468  idth, marklength
+0002c180: 5d2c 703d 5b5b 302c 305d 2c20 5b31 2c20  ],p=[[0,0], [1, 
+0002c190: 2d31 5d2c 205b 302c 2d30 2e39 5d5d 2929  -1], [0,-0.9]]))
+0002c1a0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+0002c1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c1c0: 2020 7d0a 2020 2020 2020 2020 2020 2020    }.            
+0002c1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c1e0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+0002c1f0: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+0002c200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c210: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+0002c220: 2020 2020 2020 6966 2028 6c61 6265 6c73        if (labels
+0002c230: 2026 2620 7363 616c 6573 5b69 5d2f 756e   && scales[i]/un
+0002c240: 6974 2b45 5053 494c 4f4e 203e 3d20 3129  it+EPSILON >= 1)
+0002c250: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0002c260: 2020 2020 2020 2020 2020 2063 6f6c 6f72             color
+0002c270: 2863 6f6c 6f72 735b 2824 6964 782b 3129  (colors[($idx+1)
+0002c280: 2532 5d2c 2061 6c70 6861 3d61 6c70 6861  %2], alpha=alpha
+0002c290: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+0002c2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c2b0: 6c69 6e65 6172 5f65 7874 7275 6465 2868  linear_extrude(h
+0002c2c0: 6569 6768 743d 7468 6963 6b6e 6573 732b  eight=thickness+
+0002c2d0: 7363 616c 6573 5b69 5d2f 3130 302c 2063  scales[i]/100, c
+0002c2e0: 6f6e 7665 7869 7479 3d32 2c20 6365 6e74  onvexity=2, cent
+0002c2f0: 6572 3d74 7275 6529 207b 0a20 2020 2020  er=true) {.     
+0002c300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c310: 2020 2020 2020 2020 2020 2062 6163 6b28             back(
+0002c320: 7363 616c 6573 5b69 5d2a 2e30 3229 207b  scales[i]*.02) {
+0002c330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002c340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c350: 2020 2020 2074 6578 7428 7465 7874 3d73       text(text=s
+0002c360: 7472 2820 2469 6478 202a 2073 6361 6c65  tr( $idx * scale
+0002c370: 735b 695d 202f 2075 6e69 7429 2c20 7369  s[i] / unit), si
+0002c380: 7a65 3d66 6f6e 7473 697a 652c 2068 616c  ze=fontsize, hal
+0002c390: 6967 6e3d 226c 6566 7422 2c20 7661 6c69  ign="left", vali
+0002c3a0: 676e 3d22 6261 7365 6c69 6e65 2229 3b0a  gn="baseline");.
+0002c3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c3d0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+0002c3e0: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+0002c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0002c400: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+0002c410: 2020 2020 2020 2020 2020 2020 2020 7d0a                }.
+0002c420: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0002c430: 207d 0a20 2020 2020 2020 2020 2020 207d   }.            }
+0002c440: 0a20 2020 2020 2020 207d 0a20 2020 2020  .        }.     
+0002c450: 2020 2063 6869 6c64 7265 6e28 293b 0a20     children();. 
+0002c460: 2020 207d 0a7d 0a0a 0a0a 0a0a 2f2f 2076     }.}......// v
+0002c470: 696d 3a20 6578 7061 6e64 7461 6220 7461  im: expandtab ta
+0002c480: 6273 746f 703d 3420 7368 6966 7477 6964  bstop=4 shiftwid
+0002c490: 7468 3d34 2073 6f66 7474 6162 7374 6f70  th=4 softtabstop
+0002c4a0: 3d34 206e 6f77 7261 700a                 =4 nowrap.
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/skin.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/skin.scad`

 * *Files 20% similar despite different names*

```diff
@@ -30,22 +30,22 @@
 //   [VNF structure](vnf.scad) `[VERTICES, FACES]`.  If called as a module, creates a polyhedron
 //    of the skinned profiles.
 //   .
 //   The profiles can be specified either as a list of 3d curves or they can be specified as
 //   2d curves with heights given in the `z` parameter.  It is your responsibility to ensure
 //   that the resulting polyhedron is free from self-intersections, which would make it invalid
 //   and can result in cryptic CGAL errors upon rendering with a second object present, even though the polyhedron appears
-//   OK during preview or when rendered by itself.  
+//   OK during preview or when rendered by itself.
 //   .
 //   For this operation to be well-defined, the profiles must all have the same vertex count and
 //   we must assume that profiles are aligned so that vertex `i` links to vertex `i` on all polygons.
 //   Many interesting cases do not comply with this restriction.  Two basic methods can handle
 //   these cases: either subdivide edges (insert additional points along edges)
 //   or duplicate vertcies (insert edges of length 0) so that both polygons have
-//   the same number of points. 
+//   the same number of points.
 //   Duplicating vertices allows two distinct points in one polygon to connect to a single point
 //   in the other one, creating
 //   triangular faces.  You can adjust non-matching polygons yourself
 //   either by resampling them using {{subdivide_path()}} or by duplicating vertices using
 //   `repeat_entries`.  It is OK to pass a polygon that has the same vertex repeated, such as
 //   a square with 5 points (two of which are identical), so that it can match up to a pentagon.
 //   Such a combination would create a triangular face at the location of the duplicated vertex.
@@ -55,23 +55,23 @@
 //   In order for skinned surfaces to look good it is usually necessary to use a fine sampling of
 //   points on all of the profiles, and a large number of extra interpolated slices between the
 //   profiles that you specify.  It is generally best if the triangles forming your polyhedron
 //   are approximately equilateral.  The `slices` parameter specifies the number of slices to insert
 //   between each pair of profiles, either a scalar to insert the same number everywhere, or a vector
 //   to insert a different number between each pair.
 //   .
-//   Resampling may occur, depending on the `method` parameter, to make profiles compatible.  
+//   Resampling may occur, depending on the `method` parameter, to make profiles compatible.
 //   To force (possibly additional) resampling of the profiles to increase the point density you can set `refine=N`, which
 //   will multiply the number of points on your profile by `N`.  You can choose between two resampling
 //   schemes using the `sampling` option, which you can set to `"length"` or `"segment"`.
 //   The length resampling method resamples proportional to length.
 //   The segment method divides each segment of a profile into the same number of points.
 //   This means that if you refine a profile with the "segment" method you will get N points
 //   on each edge, but if you refine a profile with the "length" method you will get new points
-//   distributed around the profile based on length, so small segments will get fewer new points than longer ones.  
+//   distributed around the profile based on length, so small segments will get fewer new points than longer ones.
 //   A uniform division may be impossible, in which case the code computes an approximation, which may result
 //   in arbitrary distribution of extra points.  See {{subdivide_path()}} for more details.
 //   Note that when dealing with continuous curves it is always better to adjust the
 //   sampling in your code to generate the desired sampling rather than using the `refine` argument.
 //   .
 //   You can choose from five methods for specifying alignment for incommensurate profiles.
 //   The available methods are `"distance"`, `"fast_distance"`, `"tangent"`, `"direct"` and `"reindex"`.
@@ -86,18 +86,18 @@
 //   method which will look for the index choice that will minimize the length of all of the edges
 //   in the polyhedron&mdash;it will produce the least twisted possible result.  This algorithm has quadratic
 //   run time so it can be slow with very large profiles.
 //   .
 //   When the profiles are incommensurate, the "direct" and "reindex" resample them to match.  As noted above,
 //   for continuous input curves, it is better to generate your curves directly at the desired sample size,
 //   but for mapping between a discrete profile like a hexagon and a circle, the hexagon must be resampled
-//   to match the circle.  When you use "direct" or "reindex" the default `sampling` value is 
+//   to match the circle.  When you use "direct" or "reindex" the default `sampling` value is
 //   of `sampling="length"` to approximate a uniform length sampling of the profile.  This will generally
 //   produce the natural result for connecting two continuously sampled profiles or a continuous
-//   profile and a polygonal one.  However depending on your particular case, 
+//   profile and a polygonal one.  However depending on your particular case,
 //   `sampling="segment"` may produce a more pleasing result.  These two approaches differ only when
 //   the segments of your input profiles have unequal length.
 //   .
 //   The "distance", "fast_distance" and "tangent" methods work by duplicating vertices to create
 //   triangular faces.  In the skined object created by two polygons, every vertex of a polygon must
 //   have an edge that connects to some vertex on the other one.  If you connect two squares this can be
 //   accomplished with four edges, but if you want to connect a square to a pentagon you must add a
@@ -108,15 +108,15 @@
 //   a small number of vertices.  It is computationally intensive (O(N^3)) and may be
 //   slow on large inputs.  The resulting surfaces generally have curved faces, so be
 //   sure to select a sufficiently large value for `slices` and `refine`.  Note that for
 //   this method, `sampling` must be set to `"segment"`, and hence this is the default setting.
 //   Using sampling by length would ignore the repeated vertices and ruin the alignment.
 //   The "fast_distance" method restricts the optimization by assuming that an edge should connect
 //   vertex 0 of the two polygons.  This reduces the run time to O(N^2) and makes
-//   the method usable on profiles with more points if you take care to index the inputs to match.  
+//   the method usable on profiles with more points if you take care to index the inputs to match.
 //   .
 //   The `"tangent"` method generally produces good results when
 //   connecting a discrete polygon to a convex, finely sampled curve.  Given a polygon and a curve, consider one edge
 //   on the polygon.  Find a plane passing through the edge that is tangent to the curve.  The endpoints of the edge and
 //   the point of tangency define a triangular face in the output polyhedron.  If you work your way around the polygon
 //   edges, you can establish a series of triangular faces in this way, with edges linking the polygon to the curve.
 //   You can then complete the edge assignment by connecting all the edges in between the triangular faces together,
@@ -127,23 +127,23 @@
 //   The "tangent" method may fail if the curved profile is non-convex, or doesn't have enough points to distinguish
 //   all of the tangent points from each other.    The algorithm treats whichever input profile has fewer points as the polygon
 //   and the other one as the curve.  Using `refine` with this method will have little effect on the model, so
 //   you should do it only for agreement with other profiles, and these models are linear, so extra slices also
 //   have no effect.  For best efficiency set `refine=1` and `slices=0`.  As with the "distance" method, refinement
 //   must be done using the "segment" sampling scheme to preserve alignment across duplicated points.
 //   Note that the "tangent" method produces similar results to the "distance" method on curved inputs.  If this
-//   method fails due to concavity, "fast_distance" may be a good option.  
+//   method fails due to concavity, "fast_distance" may be a good option.
 //   .
 //   It is possible to specify `method` and `refine` as arrays, but it is important to observe
 //   matching rules when you do this.  If a pair of profiles is connected using "tangent" or "distance"
 //   then the `refine` values for those two profiles must be equal.  If a profile is connected by
 //   a vertex duplicating method on one side and a resampling method on the other side, then
 //   `refine` must be set so that the resulting number of vertices matches the number that is
 //   used for the resampled profiles.  The best way to avoid confusion is to ensure that the
-//   profiles connected by "direct" or "realign" all have the same number of points and at the
+//   profiles connected by "direct" or "reindex" all have the same number of points and at the
 //   transition, the refined number of points matches.
 //   .
 // Arguments:
 //   profiles = list of 2d or 3d profiles to be skinned.  (If 2d must also give `z`.)
 //   slices = scalar or vector number of slices to insert between each pair of profiles.  Set to zero to use only the profiles you provided.  Recommend starting with a value around 10.
 //   ---
 //   refine = resample profiles to this number of points per edge.  Can be a list to give a refinement for each profile.  Recommend using a value above 10 when using the "distance" or "fast_distance" methods.  Default: 1.
@@ -151,28 +151,31 @@
 //   closed = set to true to connect first and last profile (to make a torus).  Default: false
 //   caps = true to create endcap faces when closed is false.  Can be a length 2 boolean array.  Default is true if closed is false.
 //   method = method for connecting profiles, one of "distance", "fast_distance", "tangent", "direct" or "reindex".  Default: "direct".
 //   z = array of height values for each profile if the profiles are 2d
 //   convexity = convexity setting for use with polyhedron.  (module only) Default: 10
 //   anchor = Translate so anchor point is at the origin.  Default: "origin"
 //   spin = Rotate this many degrees around Z axis after anchor.  Default: 0
-//   orient = Vector to rotate top towards after spin 
-//   atype = Select "hull" or "intersect anchor types. Default: "hull"
+//   orient = Vector to rotate top towards after spin
+//   atype = Select "hull" or "intersect" anchor types. Default: "hull"
 //   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
 //   style = vnf_vertex_array style.  Default: "min_edge"
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
 // Example:
 //   skin([octagon(4), circle($fn=70,r=2)], z=[0,3], slices=10);
 // Example: Rotating the pentagon place the zero index at different locations, giving a twist
 //   skin([rot(90,p=pentagon(4)), circle($fn=80,r=2)], z=[0,3], slices=10);
 // Example: You can untwist it with the "reindex" method
 //   skin([rot(90,p=pentagon(4)), circle($fn=80,r=2)], z=[0,3], slices=10, method="reindex");
 // Example: Offsetting the starting edge connects to circles in an interesting way:
 //   circ = circle($fn=80, r=3);
 //   skin([circ, rot(110,p=circ)], z=[0,5], slices=20);
-// Example(FlatSpin,VPD=20): 
+// Example(FlatSpin,VPD=20):
 //   skin([ yrot(37,p=path3d(circle($fn=128, r=4))), path3d(square(3),3)], method="reindex",slices=10);
 // Example(FlatSpin,VPD=16): Ellipses connected with twist
 //   ellipse = xscale(2.5,p=circle($fn=80));
 //   skin([ellipse, rot(45,p=ellipse)], z=[0,1.5], slices=10);
 // Example(FlatSpin,VPD=16): Ellipses connected without a twist.  (Note ellipses stay in the same position: just the connecting edges are different.)
 //   ellipse = xscale(2.5,p=circle($fn=80));
 //   skin([ellipse, rot(45,p=ellipse)], z=[0,1.5], slices=10, method="reindex");
@@ -258,15 +261,15 @@
 //   skin([regular_ngon(n=4, r=4), regular_ngon(n=5,r=5)], z=[0,4], refine=10, slices=10);
 // Example(FlatSpin,VPD=35): Connecting square to shifted pentagon using "direct" method.
 //   skin([regular_ngon(n=4, r=4), right(4,p=regular_ngon(n=5,r=5))], z=[0,4], refine=10, slices=10);
 // Example(FlatSpin,VPD=185): In this example reindexing does not fix the orientation of the triangle because it happens in 3d within skin(), so we have to reverse the triangle manually
 //   ellipse = yscale(3,circle(r=10, $fn=32));
 //   tri = move([-50/3,-9],[[0,0], [50,0], [0,27]]);
 //   skin([ellipse, reverse(tri)], z=[0,20], slices=20, method="reindex");
-// Example(FlatSpin,VPD=185): You can get a nicer transition by rotating the polygons for better alignment.  You have to resample yourself before calling `align_polygon`. The orientation is fixed so we do not need to reverse.  
+// Example(FlatSpin,VPD=185): You can get a nicer transition by rotating the polygons for better alignment.  You have to resample yourself before calling `align_polygon`. The orientation is fixed so we do not need to reverse.
 //   ellipse = yscale(3,circle(r=10, $fn=32));
 //   tri = move([-50/3,-9],
 //              subdivide_path([[0,0], [50,0], [0,27]], 32));
 //   aligned = align_polygon(ellipse,tri, [0:5:180]);
 //   skin([ellipse, aligned], z=[0,20], slices=20);
 // Example(FlatSpin,VPD=35): The "distance" method is a completely different approach.
 //   skin([regular_ngon(n=4, r=4), regular_ngon(n=5,r=5)], z=[0,4], refine=10, slices=10, method="distance");
@@ -275,20 +278,20 @@
 //   big = up(2,p=yrot( 0,p=path3d(circle(r=3, $fn=7), 6)));
 //   skin([small,big],method="distance", slices=10, refine=10);
 // Example(FlatSpin,VPD=35,VPT=[0,0,4]): But just a slight rotation of the top profile moves the two triangles to one end
 //   small = path3d(circle(r=3, $fn=5));
 //   big = up(2,p=yrot(14,p=path3d(circle(r=3, $fn=7), 6)));
 //   skin([small,big],method="distance", slices=10, refine=10);
 // Example(FlatSpin,VPD=32,VPT=[1.2,4.3,2]): Another "distance" example:
-//   off = [0,2]; 
+//   off = [0,2];
 //   shape = turtle(["right",45,"move", "left",45,"move", "left",45, "move", "jump", [.5+sqrt(2)/2,8]]);
 //   rshape = rot(180,cp=centroid(shape)+off, p=shape);
 //   skin([shape,rshape],z=[0,4], method="distance",slices=10,refine=15);
 // Example(FlatSpin,VPD=32,VPT=[1.2,4.3,2]): Slightly shifting the profile changes the optimal linkage
-//   off = [0,1]; 
+//   off = [0,1];
 //   shape = turtle(["right",45,"move", "left",45,"move", "left",45, "move", "jump", [.5+sqrt(2)/2,8]]);
 //   rshape = rot(180,cp=centroid(shape)+off, p=shape);
 //   skin([shape,rshape],z=[0,4], method="distance",slices=10,refine=15);
 // Example(FlatSpin,VPD=444,VPT=[0,0,50]): This optimal solution doesn't look terrible:
 //   prof1 = path3d([[-50,-50], [-50,50], [50,50], [25,25], [50,0], [25,-25], [50,-50]]);
 //   prof2 = path3d(regular_ngon(n=7, r=50),100);
 //   skin([prof1, prof2], method="distance", slices=10, refine=10);
@@ -338,30 +341,30 @@
 // Example: This model of two scutoids packed together is based on https://www.thingiverse.com/thing:3024272 by mathgrrl
 //   sidelen = 10;  // Side length of scutoid
 //   height = 25;   // Height of scutoid
 //   angle = -15;   // Angle (twists the entire form)
 //   push = -5;     // Push (translates the base away from the top)
 //   flare = 1;     // Flare (the two pieces will be different unless this is 1)
 //   midpoint = .5; // Height of the extra vertex (as a fraction of total height); the two pieces will be different unless this is .5)
-//   pushvec = rot(angle/2,p=push*RIGHT);  // Push direction is the the average of the top and bottom mating edges
+//   pushvec = rot(angle/2,p=push*RIGHT);  // Push direction is the average of the top and bottom mating edges
 //   pent = path3d(apply(move(pushvec)*rot(angle),pentagon(side=sidelen,align_side=RIGHT,anchor="side0")));
 //   hex = path3d(hexagon(side=flare*sidelen, align_side=RIGHT, anchor="side0"),height);
 //   pentmate = path3d(pentagon(side=flare*sidelen,align_side=LEFT,anchor="side0"),height);
 //             // Native index would require mapping first and last vertices together, which is not allowed, so shift
-//   hexmate = list_rotate(  
+//   hexmate = list_rotate(
 //                           path3d(apply(move(pushvec)*rot(angle),hexagon(side=sidelen,align_side=LEFT,anchor="side0"))),
 //                           -1);
 //   join_vertex = lerp(
 //                       mean(select(hex,1,2)),     // midpoint of "extra" hex edge
 //                       mean(select(hexmate,0,1)), // midpoint of "extra" hexmate edge
 //                       midpoint);
 //   augpent = repeat_entries(pent, [1,2,1,1,1]);         // Vertex 1 will split at the top forming a triangular face with the hexagon
 //   augpent_mate = repeat_entries(pentmate,[2,1,1,1,1]); // For mating pentagon it is vertex 0 that splits
 //              // Middle is the interpolation between top and bottom except for the join vertex, which is doubled because it splits
-//   middle = list_set(lerp(augpent,hex,midpoint),[1,2],[join_vertex,join_vertex]);  
+//   middle = list_set(lerp(augpent,hex,midpoint),[1,2],[join_vertex,join_vertex]);
 //   middle_mate = list_set(lerp(hexmate,augpent_mate,midpoint), [0,1], [join_vertex,join_vertex]);
 //   skin([augpent,middle,hex],  slices=10, refine=10, sampling="segment");
 //   color("green")skin([augpent_mate,middle_mate,hexmate],  slices=10,refine=10, sampling="segment");
 // Example: If you create a self-intersecting polyhedron the result is invalid.  In some cases self-intersection may be obvous.  Here is a more subtle example.
 //   skin([
 //          for (a = [0:30:180]) let(
 //              pos  = [-60*sin(a),     0, a    ],
@@ -383,19 +386,19 @@
 //          }
 //          up(160) zrot(25) fwd(130) xrot(75) {
 //              stroke(zrot(30, p=yscale(0.5, p=circle(d=120))),width=10,closed=true);
 //          }
 //      }
 module skin(profiles, slices, refine=1, method="direct", sampling, caps, closed=false, z, style="min_edge", convexity=10,
             anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull")
-{   
+{
     vnf = skin(profiles, slices, refine, method, sampling, caps, closed, z, style=style);
     vnf_polyhedron(vnf,convexity=convexity,spin=spin,anchor=anchor,orient=orient,atype=atype,cp=cp)
         children();
-}        
+}
 
 
 function skin(profiles, slices, refine=1, method="direct", sampling, caps, closed=false, z, style="min_edge",
               anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull") =
   assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
   assert(is_def(slices),"The slices argument must be specified.")
   assert(is_list(profiles) && len(profiles)>1, "Must provide at least two profiles")
@@ -420,44 +423,44 @@
     methodlistok = is_list(method) ? [for(i=idx(method)) if (!in_list(method[i], legal_methods)) i] : [],
     method = is_string(method) ? repeat(method, profcount) : method,
     // Define to be zero where a resampling method is used and 1 where a vertex duplicator is used
     RESAMPLING = 0,
     DUPLICATOR = 1,
     method_type = [for(m = method) m=="direct" || m=="reindex" ? 0 : 1],
     sampling = is_def(sampling) ? sampling :
-               in_list(DUPLICATOR,method_type) ? "segment" : "length" 
+               in_list(DUPLICATOR,method_type) ? "segment" : "length"
   )
   assert(len(refine)==len(profiles), "refine list is the wrong length")
   assert(len(slices)==profcount, str("slices list must have length ",profcount))
   assert(slicesOK==[],str("slices must be nonnegative integers"))
   assert(refineOK==[],str("refine must be postive integer"))
   assert(methodok,str("method must be one of ",legal_methods,". Got ",method))
   assert(methodlistok==[], str("method list contains invalid method at ",methodlistok))
   assert(len(method) == profcount,"Method list is the wrong length")
   assert(in_list(sampling,["length","segment"]), "sampling must be set to \"length\" or \"segment\"")
   assert(sampling=="segment" || (!in_list("distance",method) && !in_list("fast_distance",method) && !in_list("tangent",method)), "sampling is set to \"length\" which is only allowed with methods \"direct\" and \"reindex\"")
   assert(capsOK, "caps must be boolean or a list of two booleans")
   assert(!closed || !caps, "Cannot make closed shape with caps")
   let(
     profile_dim=list_shape(profiles,2),
-    profiles_zcheck = (profile_dim != 2) || (profile_dim==2 && is_list(z) && len(z)==len(profiles)), 
+    profiles_zcheck = (profile_dim != 2) || (profile_dim==2 && is_list(z) && len(z)==len(profiles)),
     profiles_ok = (profile_dim==2 && is_list(z) && len(z)==len(profiles)) || profile_dim==3
   )
   assert(profiles_zcheck, "z parameter is invalid or has the wrong length.")
   assert(profiles_ok,"Profiles must all be 3d or must all be 2d, with matching length z parameter.")
   assert(is_undef(z) || profile_dim==2, "Do not specify z with 3d profiles")
   assert(profile_dim==3 || len(z)==len(profiles),"Length of z does not match length of profiles.")
   let(
     // Adjoin Z coordinates to 2d profiles
     profiles = profile_dim==3 ? profiles :
                [for(i=idx(profiles)) path3d(profiles[i], z[i])],
     // True length (not counting repeated vertices) of profiles after refinement
     refined_len = [for(i=idx(profiles)) refine[i]*len(profiles[i])],
     // Define this to be 1 if a profile is used on either side by a resampling method, zero otherwise.
-    profile_resampled = [for(i=idx(profiles)) 
+    profile_resampled = [for(i=idx(profiles))
       1-(
            i==0 ?  method_type[0] * (closed? last(method_type) : 1) :
            i==len(profiles)-1 ? last(method_type) * (closed ? select(method_type,-2) : 1) :
          method_type[i] * method_type[i-1])],
     parts = search(1,[1,for(i=[0:1:len(profile_resampled)-2]) profile_resampled[i]!=profile_resampled[i+1] ? 1 : 0],0),
     plen = [for(i=idx(parts)) (i== len(parts)-1? len(refined_len) : parts[i+1]) - parts[i]],
     max_list = [for(i=idx(parts)) each repeat(max(select(refined_len, parts[i], parts[i]+plen[i]-1)), plen[i])],
@@ -466,28 +469,28 @@
   )
   assert(badind==[],str("Profile length mismatch at method transition at indices ",badind," in skin()"))
   let(
     full_list =    // If there are no duplicators then use more efficient where the whole input is treated together
       !in_list(DUPLICATOR,method_type) ?
          let(
              resampled = [for(i=idx(profiles)) subdivide_path(profiles[i], max_list[i], method=sampling)],
-             fixedprof = [for(i=idx(profiles)) 
+             fixedprof = [for(i=idx(profiles))
                              i==0 || method[i-1]=="direct" ? resampled[i]
                                                          : reindex_polygon(resampled[i-1],resampled[i])],
-             sliced = slice_profiles(fixedprof, slices, closed)            
+             sliced = slice_profiles(fixedprof, slices, closed)
             )
             [!closed ? sliced : concat(sliced,[sliced[0]])]
       :  // There are duplicators, so use approach where each pair is treated separately
       [for(i=[0:profcount-1])
         let(
-          pair = 
+          pair =
             method[i]=="distance" ? _skin_distance_match(profiles[i],select(profiles,i+1)) :
             method[i]=="fast_distance" ? _skin_aligned_distance_match(profiles[i], select(profiles,i+1)) :
             method[i]=="tangent" ? _skin_tangent_match(profiles[i],select(profiles,i+1)) :
-            /*method[i]=="reindex" || method[i]=="direct" ?*/ 
+            /*method[i]=="reindex" || method[i]=="direct" ?*/
                let( p1 = subdivide_path(profiles[i],max_list[i], method=sampling),
                     p2 = subdivide_path(select(profiles,i+1),max_list[i], method=sampling)
                ) (method[i]=="direct" ? [p1,p2] : [p1, reindex_polygon(p1, p2)]),
             nsamples =  method_type[i]==RESAMPLING ? len(pair[0]) :
                assert(refine[i]==select(refine,i+1),str("Refine value mismatch at indices ",[i,(i+1)%len(refine)],
                                                         ".  Method ",method[i]," requires equal values"))
                refine[i] * len(pair[0])
@@ -500,38 +503,52 @@
   )
   reorient(anchor,spin,orient,vnf=vnf,p=vnf,extent=atype=="hull",cp=cp);
 
 
 
 // Function&Module: linear_sweep()
 // Usage:
-//   linear_sweep(region, [height], [center=], [slices=], [twist=], [scale=], [style=], [convexity=]) [ATTACHMENTS];
+//   linear_sweep(region, [height], [center=], [slices=], [twist=], [scale=], [style=], [caps=], [convexity=]) [ATTACHMENTS];
+// Usage: With Texturing
+//   linear_sweep(region, [height], [center=], texture=, [tex_size=]|[tex_counts=], [tex_scale=], [style=], [tex_samples=], ...) [ATTACHMENTS];
 // Description:
 //   If called as a module, creates a polyhedron that is the linear extrusion of the given 2D region or polygon.
 //   If called as a function, returns a VNF that can be used to generate a polyhedron of the linear extrusion
 //   of the given 2D region or polygon.  The benefit of using this, over using `linear_extrude region(rgn)` is
 //   that it supports `anchor`, `spin`, `orient` and attachments.  You can also make more refined
 //   twisted extrusions by using `maxseg` to subsample flat faces.
 // Arguments:
 //   region = The 2D [Region](regions.scad) or polygon that is to be extruded.
-//   h / height = The height to extrude the region.  Default: 1
+//   h / height / l / length = The height to extrude the region.  Default: 1
 //   center = If true, the created polyhedron will be vertically centered.  If false, it will be extruded upwards from the XY plane.  Default: `false`
 //   ---
 //   twist = The number of degrees to rotate the top of the shape, clockwise around the Z axis, relative to the bottom.  Default: 0
 //   scale = The amount to scale the top of the shape, in the X and Y directions, relative to the size of the bottom.  Default: 1
 //   shift = The amount to shift the top of the shape, in the X and Y directions, relative to the position of the bottom.  Default: [0,0]
 //   slices = The number of slices to divide the shape into along the Z axis, to allow refinement of detail, especially when working with a twist.  Default: `twist/5`
 //   maxseg = If given, then any long segments of the region will be subdivided to be shorter than this length.  This can refine twisting flat faces a lot.  Default: `undef` (no subsampling)
+//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.
+//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
+//   tex_counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
+//   tex_inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
+//   tex_rot = If true, rotates the texture 90º.
+//   tex_scale = Scaling multiplier for the texture depth.
+//   tex_samples = Minimum number of "bend points" to have in VNF texture tiles.  Default: 8
 //   style = The style to use when triangulating the surface of the object.  Valid values are `"default"`, `"alt"`, or `"quincunx"`.
+//   caps = If false do not create end caps.  Can be a boolean vector.  Default: true
 //   convexity = Max number of surfaces any single ray could pass through.  Module use only.
 //   cp = Centerpoint for determining intersection anchors or centering the shape.  Determines the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: `"centroid"`
 //   atype = Set to "hull" or "intersect" to select anchor type.  Default: "hull"
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `"origin"`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
+//   "bbox" = Anchors to the bounding box of the extruded shape.
 // Extra Anchors:
 //   "origin" = Centers the extruded shape vertically only, but keeps the original path positions in the X and Y.  Oriented UP.
 //   "original_base" = Keeps the original path positions in the X and Y, but at the bottom of the extrusion.  Oriented UP.
 // Example: Extruding a Compound Region.
 //   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];
 //   rgn2 = [square(30,center=false)];
 //   rgn3 = [for (size=[10:10:20]) move([15,15],p=square(size=size, center=true))];
@@ -565,83 +582,212 @@
 //           rect(size=size)
 //       )
 //   ];
 //   mrgn = union(rgn1,rgn2);
 //   orgn = difference(mrgn,rgn3);
 //   linear_sweep(orgn,height=20,convexity=16)
 //       show_anchors();
+// Example: "diamonds" texture.
+//   path = glued_circles(r=15, spread=40, tangent=45);
+//   linear_sweep(
+//       path, texture="diamonds", tex_size=[5,10],
+//       h=40, style="concave");
+// Example: "pyramids" texture.
+//   linear_sweep(
+//       rect(50), texture="pyramids", tex_size=[10,10],
+//       h=40, style="convex");
+// Example: "bricks_vnf" texture.
+//   path = glued_circles(r=15, spread=40, tangent=45);
+//   linear_sweep(
+//       path, texture="bricks_vnf", tex_size=[10,10],
+//       tex_scale=0.25, h=40);
+// Example: User defined heightfield texture.
+//   path = ellipse(r=[20,10]);
+//   texture = [for (i=[0:9])
+//       [for (j=[0:9])
+//           1/max(0.5,norm([i,j]-[5,5])) ]];
+//   linear_sweep(
+//       path, texture=texture, tex_size=[5,5],
+//       h=40, style="min_edge", anchor=BOT);
+// Example: User defined VNF tile texture.
+//   path = ellipse(r=[20,10]);
+//   tex = let(n=16,m=0.25) [
+//        [
+//            each resample_path(path3d(square(1)),n),
+//            each move([0.5,0.5],
+//                p=path3d(circle(d=0.5,$fn=n),m)),
+//            [1/2,1/2,0],
+//        ], [
+//            for (i=[0:1:n-1]) each [
+//                [i,(i+1)%n,(i+3)%n+n],
+//                [i,(i+3)%n+n,(i+2)%n+n],
+//                [2*n,n+i,n+(i+1)%n],
+//            ]
+//        ]
+//   ];
+//   linear_sweep(path, texture=tex, tex_size=[5,5], h=40);
+// Example: As Function
+//   path = glued_circles(r=15, spread=40, tangent=45);
+//   vnf = linear_sweep(
+//       path, h=40, texture="trunc_pyramids", tex_size=[5,5],
+//       tex_scale=1, style="convex");
+//   vnf_polyhedron(vnf, convexity=10);
+// Example: VNF tile that has no top/bottom edges and produces a disconnected result
+//   shape = skin([rect(2/5),
+//                 rect(2/3),
+//                 rect(2/5)],
+//                z=[0,1/2,1],
+//                slices=0,
+//                caps=false);
+//   tile = move([0,1/2,2/3],yrot(90,shape));
+//   linear_sweep(circle(20), texture=tile,
+//                tex_size=[10,10],tex_scale=5,
+//                h=40,convexity=4);
+// Example: The same tile from above, turned 90 degrees, creates problems at the ends, because the end cap is not a connected polygon.  When the ends are disconnected you may find that some parts of the end cap are missing and spurious polygons included.  
+//  shape = skin([rect(2/5),
+//                rect(2/3),
+//                rect(2/5)],
+//               z=[0,1/2,1],
+//               slices=0,
+//               caps=false);
+//  tile = move([1/2,1,2/3],xrot(90,shape));
+//  linear_sweep(circle(20), texture=tile,
+//               tex_size=[30,20],tex_scale=15,
+//               h=40,convexity=4);
+// Example: This example shoes some endcap polygons missing and a spurious triangle
+//   shape = skin([rect(2/5),
+//                 rect(2/3),
+//                 rect(2/5)],
+//                z=[0,1/2,1],
+//                slices=0,
+//                caps=false);
+//   tile = xscale(.5,move([1/2,1,2/3],xrot(90,shape)));
+//   doubletile = vnf_join([tile, right(.5,tile)]);
+//   linear_sweep(circle(20), texture=doubletile,
+//                tex_size=[45,45],tex_scale=15, h=40);
+// Example: You can fix ends for disconnected cases using {{top_half()}} and {{bottom_half()}}
+//   shape = skin([rect(2/5),
+//                 rect(2/3),
+//                 rect(2/5)],
+//                z=[0,1/2,1],
+//                slices=0,
+//                caps=false);
+//   tile = move([1/2,1,2/3],xrot(90,shape));
+//   vnf_polyhedron(
+//     top_half(
+//       bottom_half(
+//         linear_sweep(circle(20), texture=tile,
+//                     tex_size=[30,20],tex_scale=15,
+//                     h=40.2,caps=false),
+//       z=20),
+//     z=-20)); 
+
 module linear_sweep(
     region, height, center,
     twist=0, scale=1, shift=[0,0],
-    slices, maxseg, style="default", convexity,
-    cp, atype="hull", h,
+    slices, maxseg, style="default", convexity, caps=true, 
+    texture, tex_size=[5,5], tex_counts,
+    tex_inset=false, tex_rot=false,
+    tex_scale=1, tex_samples,
+    cp, atype="hull", h,l,length,
     anchor, spin=0, orient=UP
 ) {
-    h = first_defined([h, height, 1]);
+    h = one_defined([h, height,l,length],"h,height,l,length",dflt=1);
     region = force_region(region);
     check = assert(is_region(region),"Input is not a region");
     anchor = center==true? "origin" :
         center == false? "original_base" :
         default(anchor, "original_base");
     vnf = linear_sweep(
-        region, height=h, style=style,
+        region, height=h, style=style, caps=caps, 
         twist=twist, scale=scale, shift=shift,
-        slices=slices, maxseg=maxseg,
+        texture=texture,
+        tex_size=tex_size,
+        tex_counts=tex_counts,
+        tex_inset=tex_inset,
+        tex_rot=tex_rot,
+        tex_scale=tex_scale,
+        tex_samples=tex_samples,
+        slices=slices,
+        maxseg=maxseg,
         anchor="origin"
     );
     anchors = [
         named_anchor("original_base", [0,0,-h/2], UP)
     ];
     cp = default(cp, "centroid");
-    geom = atype=="hull"? attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :
-        atype=="intersect"? attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :
-        assert(in_list(atype, ["hull", "intersect"]));
+    geom = atype=="hull"?  attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :
+        atype=="intersect"?  attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :
+        atype=="bbox"?
+            let(
+                bounds = pointlist_bounds(flatten(region)),
+                size = bounds[1] - bounds[0],
+                midpt = (bounds[0] + bounds[1])/2
+            )
+            attach_geom(cp=[0,0,0], size=point3d(size,h), offset=point3d(midpt), shift=shift, scale=scale, twist=twist, anchors=anchors) :
+        assert(in_list(atype, ["hull","intersect","bbox"]), "Anchor type must be \"hull\", \"intersect\", or \"bbox\".");
     attachable(anchor,spin,orient, geom=geom) {
         vnf_polyhedron(vnf, convexity=convexity);
         children();
     }
 }
 
 
 function linear_sweep(
     region, height, center,
     twist=0, scale=1, shift=[0,0],
-    slices, maxseg, style="default",
+    slices, maxseg, style="default", caps=true, 
     cp, atype="hull", h,
+    texture, tex_size=[5,5], tex_counts,
+    tex_inset=false, tex_rot=false,
+    tex_scale=1, tex_samples, h, l, length, 
     anchor, spin=0, orient=UP
 ) =
     let( region = force_region(region) )
     assert(is_region(region), "Input is not a region or polygon.")
     assert(is_num(scale) || is_vector(scale))
     assert(is_vector(shift, 2), str(shift))
+    assert(is_bool(caps) || is_bool_list(caps,2), "caps must be boolean or a list of two booleans")
+    let(
+        h = one_defined([h, height,l,length],"h,height,l,length",dflt=1)
+    )
+    !is_undef(texture)? _textured_linear_sweep(
+        region, h=h, caps=caps, 
+        texture=texture, tex_size=tex_size,
+        counts=tex_counts, inset=tex_inset,
+        rot=tex_rot, tex_scale=tex_scale,
+        twist=twist, scale=scale, shift=shift,
+        style=style, samples=tex_samples,
+        anchor=anchor, spin=spin, orient=orient
+    ) :
     let(
-        h = first_defined([h, height, 1]),
+        caps = is_bool(caps) ? [caps,caps] : caps, 
         anchor = center==true? "origin" :
             center == false? "original_base" :
             default(anchor, "original_base"),
         regions = region_parts(region),
         slices = default(slices, max(1,ceil(abs(twist)/5))),
         scale = is_num(scale)? [scale,scale] : point2d(scale),
         topmat = move(shift) * scale(scale) * rot(-twist),
         trgns = [
             for (rgn = regions) [
                 for (path = rgn) let(
-                    p = cleanup_path(path),
+                    p = list_unwrap(path),
                     path = is_undef(maxseg)? p : [
                         for (seg = pair(p,true)) each
                         let( steps = ceil(norm(seg.y - seg.x) / maxseg) )
                         lerpn(seg.x, seg.y, steps, false)
                     ]
                 ) apply(topmat, path)
             ]
         ],
         vnf = vnf_join([
             for (rgn = regions)
             for (pathnum = idx(rgn)) let(
-                p = cleanup_path(rgn[pathnum]),
+                p = list_unwrap(rgn[pathnum]),
                 path = is_undef(maxseg)? p : [
                     for (seg=pair(p,true)) each
                     let(steps=ceil(norm(seg.y-seg.x)/maxseg))
                     lerpn(seg.x, seg.y, steps, false)
                 ],
                 verts = [
                     for (i=[0:1:slices]) let(
@@ -649,162 +795,508 @@
                         scl = lerp([1,1], scale, u),
                         ang = lerp(0, -twist, u),
                         off = lerp([0,0,-h/2], point3d(shift,h/2), u),
                         m = move(off) * scale(scl) * rot(ang)
                     ) apply(m, path3d(path))
                 ]
             ) vnf_vertex_array(verts, caps=false, col_wrap=true, style=style),
-            for (rgn = regions) vnf_from_region(rgn, down(h/2), reverse=true),
-            for (rgn = trgns) vnf_from_region(rgn, up(h/2), reverse=false)
+            if (caps[0]) for (rgn = regions) vnf_from_region(rgn, down(h/2), reverse=true),
+            if (caps[1]) for (rgn = trgns) vnf_from_region(rgn, up(h/2), reverse=false)
         ]),
         anchors = [
             named_anchor("original_base", [0,0,-h/2], UP)
         ],
         cp = default(cp, "centroid"),
-        geom = atype=="hull"? attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :
-            atype=="intersect"? attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :
-            assert(in_list(atype, ["hull", "intersect"]))
+        geom = atype=="hull"?  attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :
+            atype=="intersect"?  attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :
+            atype=="bbox"?
+                let(
+                    bounds = pointlist_bounds(flatten(region)),
+                    size = bounds[1] - bounds[0],
+                    midpt = (bounds[0] + bounds[1])/2
+                )
+                attach_geom(cp=[0,0,0], size=point3d(size,h), offset=point3d(midpt), shift=shift, scale=scale, twist=twist, anchors=anchors) :
+            assert(in_list(atype, ["hull","intersect","bbox"]), "Anchor type must be \"hull\", \"intersect\", or \"bbox\".")
     ) reorient(anchor,spin,orient, geom=geom, p=vnf);
 
 
+// Function&Module: rotate_sweep()
+// Usage: As Function
+//   vnf = rotate_sweep(shape, [angle], ...);
+// Usage: As Module
+//   rotate_sweep(shape, [angle], ...) [ATTACHMENTS];
+// Usage: With Texturing
+//   rotate_sweep(shape, texture=, [tex_size=]|[tex_counts=], [tex_scale=], [tex_samples=], [tex_rot=], [tex_inset=], ...) [ATTACHMENTS];
+// Topics: Extrusion, Sweep, Revolution
+// Description:
+//   Takes a polygon or [region](regions.scad) and sweeps it in a rotation around the Z axis, with optional texturing.
+//   When called as a function, returns a [VNF](vnf.scad).
+//   When called as a module, creates the sweep as geometry.
+// Arguments:
+//   shape = The polygon or [region](regions.scad) to sweep around the Z axis.
+//   angle = If given, specifies the number of degrees to sweep the shape around the Z axis, counterclockwise from the X+ axis.  Default: 360 (full rotation)
+//   ---
+//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.
+//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
+//   tex_counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
+//   tex_inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
+//   tex_rot = If true, rotates the texture 90º.
+//   tex_scale = Scaling multiplier for the texture depth.
+//   tex_samples = Minimum number of "bend points" to have in VNF texture tiles.  Default: 8
+//   style = {{vnf_vertex_array()}} style.  Default: "min_edge"
+//   closed = If false, and shape is given as a path, then the revolved path will be sealed to the axis of rotation with untextured caps.  Default: `true`
+//   convexity = (Module only) Convexity setting for use with polyhedron.  Default: 10
+//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
+//   atype = Select "hull" or "intersect" anchor types.  Default: "hull"
+//   anchor = Translate so anchor point is at the origin. Default: "origin"
+//   spin = Rotate this many degrees around Z axis after anchor. Default: 0
+//   orient = Vector to rotate top towards after spin  (module only)
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
+// See Also: linear_sweep(), sweep()
+// Example:
+//   rgn = [
+//       for (a = [0, 120, 240]) let(
+//           cp = polar_to_xy(15, a) + [30,0]
+//       ) each [
+//           move(cp, p=circle(r=10)),
+//           move(cp, p=hexagon(d=15)),
+//       ]
+//   ];
+//   rotate_sweep(rgn, angle=240);
+// Example:
+//   rgn = right(30, p=union([for (a = [0, 90]) rot(a, p=rect([15,5]))]));
+//   rotate_sweep(rgn);
+// Example:
+//   path = right(50, p=circle(d=40));
+//   rotate_sweep(path, texture="bricks_vnf", tex_size=[10,10], tex_scale=0.5, style="concave");
+// Example:
+//   tex = [
+//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
+//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
+//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
+//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
+//       [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1],
+//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],
+//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],
+//       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1],
+//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
+//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
+//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
+//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
+//   ];
+//   path = arc(cp=[0,0], r=40, start=60, angle=-120);
+//   rotate_sweep(
+//       path, closed=false,
+//       texture=tex, tex_size=[20,20],
+//       tex_scale=1, style="concave");
+// Example:
+//   include <BOSL2/beziers.scad>
+//   bezpath = [
+//       [15, 30], [10,15],
+//       [10,  0], [20, 10], [30,12],
+//       [30,-12], [20,-10], [10, 0],
+//       [10,-15], [15,-30]
+//   ];
+//   path = bezpath_curve(bezpath, splinesteps=32);
+//   rotate_sweep(
+//       path, closed=false,
+//       texture="diamonds", tex_size=[10,10],
+//       tex_scale=1, style="concave");
+// Example:
+//   path = [
+//       [20, 30], [20, 20],
+//       each arc(r=20, corner=[[20,20],[10,0],[20,-20]]),
+//       [20,-20], [20,-30],
+//   ];
+//   vnf = rotate_sweep(
+//       path, closed=false,
+//       texture="trunc_pyramids",
+//       tex_size=[5,5], tex_scale=1,
+//       style="convex");
+//   vnf_polyhedron(vnf, convexity=10);
+// Example:
+//   rgn = [
+//       right(40, p=circle(d=50)),
+//       right(40, p=circle(d=40,$fn=6)),
+//   ];
+//   rotate_sweep(
+//       rgn, texture="diamonds",
+//       tex_size=[10,10], tex_scale=1,
+//       angle=240, style="concave");
+
+function rotate_sweep(
+    shape, angle=360,
+    texture, tex_size=[5,5], tex_counts,
+    tex_inset=false, tex_rot=false,
+    tex_scale=1, tex_samples,
+    tex_taper, shift=[0,0], closed=true,
+    style="min_edge", cp="centroid",
+    atype="hull", anchor="origin",
+    spin=0, orient=UP
+) =
+    let( region = force_region(shape) )
+    assert(is_region(region), "Input is not a region or polygon.")
+    let(
+        bounds = pointlist_bounds(flatten(region)),
+        min_x = bounds[0].x,
+        max_x = bounds[1].x,
+        min_y = bounds[0].y,
+        max_y = bounds[1].y,
+        h = max_y - min_y
+    )
+    assert(min_x>=0, "Input region must exist entirely in the X+ half-plane.")
+    !is_undef(texture)? _textured_revolution(
+        shape,
+        texture=texture,
+        tex_size=tex_size,
+        counts=tex_counts,
+        tex_scale=tex_scale,
+        inset=tex_inset,
+        rot=tex_rot,
+        samples=tex_samples,
+        taper=tex_taper,
+        shift=shift,
+        closed=closed,
+        angle=angle,
+        style=style
+    ) :
+    let(
+        steps = segs(max_x),
+        skmat = down(min_y) * skew(sxz=shift.x/h, syz=shift.y/h) * up(min_y),
+        transforms = [
+            if (angle==360) for (i=[0:1:steps-1]) skmat * rot([90,0,360-i*360/steps]),
+            if (angle<360) for (i=[0:1:steps-1]) skmat * rot([90,0,angle-i*angle/(steps-1)]),
+        ],
+        vnf = sweep(
+            region, transforms,
+            closed=angle==360,
+            caps=angle!=360,
+            style=style, cp=cp,
+            atype=atype, anchor=anchor,
+            spin=spin, orient=orient
+        )
+    ) vnf;
+
+
+module rotate_sweep(
+    shape, angle=360,
+    texture, tex_size=[5,5], tex_counts,
+    tex_inset=false, tex_rot=false,
+    tex_scale=1, tex_samples,
+    tex_taper, shift=[0,0],
+    style="min_edge",
+    closed=true,
+    cp="centroid",
+    convexity=10,
+    atype="hull",
+    anchor="origin",
+    spin=0,
+    orient=UP
+) {
+    region = force_region(shape);
+    check = assert(is_region(region), "Input is not a region or polygon.");
+    bounds = pointlist_bounds(flatten(region));
+    min_x = bounds[0].x;
+    max_x = bounds[1].x;
+    min_y = bounds[0].y;
+    max_y = bounds[1].y;
+    h = max_y - min_y;
+    check2 = assert(min_x>=0, "Input region must exist entirely in the X+ half-plane.");
+    steps = segs(max_x);
+    if (!is_undef(texture)) {
+        _textured_revolution(
+            shape,
+            texture=texture,
+            tex_size=tex_size,
+            counts=tex_counts,
+            tex_scale=tex_scale,
+            inset=tex_inset,
+            rot=tex_rot,
+            samples=tex_samples,
+            taper=tex_taper,
+            shift=shift,
+            closed=closed,
+            angle=angle,
+            style=style,
+            atype=atype, anchor=anchor,
+            spin=spin, orient=orient
+        ) children();
+    } else {
+        skmat = down(min_y) * skew(sxz=shift.x/h, syz=shift.y/h) * up(min_y);
+        transforms = [
+            if (angle==360) for (i=[0:1:steps-1]) skmat * rot([90,0,360-i*360/steps]),
+            if (angle<360) for (i=[0:1:steps-1]) skmat * rot([90,0,angle-i*angle/(steps-1)]),
+        ];
+        sweep(
+            region, transforms,
+            closed=angle==360,
+            caps=angle!=360,
+            style=style, cp=cp,
+            convexity=convexity,
+            atype=atype, anchor=anchor,
+            spin=spin, orient=orient
+        ) children();
+    }
+}
+
 
 // Function&Module: spiral_sweep()
-// Usage:
-//   spiral_sweep(poly, h, r, turns, [higbee=], [center=], [r1=], [r2=], [d=], [d1=], [d2=], [higbee1=], [higbee2=], [internal=], [anchor=], [spin=], [orient=])[ATTACHMENTS];
-//   vnf = spiral_sweep(poly, h, r, turns, ...);
+// Usage: As Module
+//   spiral_sweep(poly, h, r|d=, turns, [taper=], [center=], [taper1=], [taper2=], [internal=], ...)[ATTACHMENTS];
+//   spiral_sweep(poly, h, r1=|d1=, r2=|d2=, turns, [taper=], [center=], [taper1=], [taper2=], [internal=], ...)[ATTACHMENTS];
+// Usage: As Function
+//   vnf = spiral_sweep(poly, h, r|d=, turns, ...);
+//   vnf = spiral_sweep(poly, h, r1=|d1=, r1=|d2=, turns, ...);
+// Topics: Extrusion, Sweep
 // Description:
 //   Takes a closed 2D polygon path, centered on the XY plane, and sweeps/extrudes it along a 3D spiral path
 //   of a given radius, height and degrees of rotation.  The origin in the profile traces out the helix of the specified radius.
 //   If turns is positive the path will be right-handed;  if turns is negative the path will be left-handed.
+//   Such an extrusion can be used to make screw threads.  
 //   .
-//   Higbee specifies tapering applied to the ends of the extrusion and is given as the linear distance
-//   over which to taper.  
+//   The lead_in options specify a lead-in setiton where the ends of the spiral scale down to avoid a sharp cut face at the ends.
+//   You can specify the length of this scaling directly with the lead_in parameters or as an angle using the lead_in_ang parameters.
+//   If you give a positive value, the extrusion is lengthenend by the specified distance or angle; if you give a negative
+//   value then the scaled end is included in the extrusion length specified by `turns`.  If the value is zero then no scaled ends
+//   are produced.  The shape of the scaled ends can be controlled with the lead_in_shape parameter.  Supported options are "sqrt", "linear"
+//   "smooth" and "cut".  
+//   .
+//   The inside argument changes how the extrusion lead-in sections are formed.  If it is true then they scale
+//   towards the outside, like would be needed for internal threading.  If internal is fale then the lead-in sections scale
+//   towards the inside, like would be appropriate for external threads.  
 // Arguments:
 //   poly = Array of points of a polygon path, to be extruded.
-//   h = height of the spiral to extrude along.
-//   r = Radius of the spiral to extrude along. Default: 50
-//   turns = number of revolutions to spiral up along the height.
+//   h = height of the spiral extrusion path
+//   r = Radius of the spiral extrusion path
+//   turns = number of revolutions to include in the spiral
 //   ---
-//   d = Diameter of the spiral to extrude along.
-//   higbee = Length to taper thread ends over.
-//   higbee1 = Taper length at start
-//   higbee2 = Taper length at end
-//   internal = direction to taper the threads with higbee.  If true threads taper outward; if false they taper inward.   Default: false
+//   d = Diameter of the spiral extrusion path.
+//   d1/r1 = Bottom inside diameter or radius of spiral to extrude along.
+//   d2/r2 = Top inside diameter or radius of spiral to extrude along.
+//   lead_in = Specify linear length of the lead-in scaled section of the spiral.  Default: 0
+//   lead_in1 = Specify linear length of the lead-in scaled section of the spiral at the bottom
+//   lead_in2 = Specify linear length of the lead-in scaled section of the spiral at the top
+//   lead_in_ang = Specify angular  length of the lead-in scaled section of the spiral
+//   lead_in_ang1 = Specify angular length of the lead-in scaled section of the spiral at the bottom
+//   lead_in_ang2 = Specify angular length of the lead-in scaled section of the spiral at the top
+//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: "sqrt"
+//   lead_in_shape1 = Specify the shape of the thread lead-in at the bottom by giving a text string or function.  
+//   lead_in_shape2 = Specify the shape of the thread lead-in at the top by giving a text string or function.
+//   lead_in_sample = Factor to increase sample rate in the lead-in section.  Default: 10
+//   internal = if true make internal threads.  The only effect this has is to change how the extrusion lead-in section are formed. When true, the extrusion scales towards the outside; when false, it scales towards the inside.  Default: false
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=BOTTOM`.
+// See Also: sweep(), linear_sweep(), rotate_sweep(), path_sweep(), thread_helix()
 // Example:
 //   poly = [[-10,0], [-3,-5], [3,-5], [10,0], [0,-30]];
 //   spiral_sweep(poly, h=200, r=50, turns=3, $fn=36);
-function _taperfunc(x) =
-     let(higofs = pow(0.05,2))   // Smallest hig scale is the square root of this value
-     sqrt((1-higofs)*x+higofs);
+_leadin_ogive=function (x,L) 
+     let( minscale = .05,
+          r=(L^2+(1-minscale^2))/2/(1-minscale),
+          scale = sqrt(r^2-(L*(1-x))^2) -(r-1)
+     )
+     x>1 ? [1,1]
+   : x<0 ? [lerp(minscale,1,.25),0] 
+   : [lerp(scale,1,.25),scale];     
+
+_leadin_cut = function(x,L) x>0 ? [1,1] : [1,0];
+
+_leadin_sqrt = function(x,L)
+     let(end=0.05)   // Smallest scale at the end
+     x>1 ? [1,1]
+   : x<0 ? [lerp(end,1,.25),0]   
+   : let(  
+          s = sqrt(x + end^2 * (1-x))
+     )
+     [lerp(s,1,.25),s];    // thread width scale, thread height scale
+
+_leadin_linear = function(x,L)
+     let(minscale=.1)
+     x>1 ? [1,1]
+   : x<0 ? [lerp(minscale,1,.25),0]
+   : let(scale = lerp(minscale,1,x))
+     [lerp(scale,1,.25),scale];
+
+_lead_in_table = [
+     ["default", _leadin_sqrt],
+     ["sqrt", _leadin_sqrt],
+     ["cut", _leadin_cut],
+     ["smooth", _leadin_ogive],
+     ["linear", _leadin_linear]
+];
+
+      
 function _ss_polygon_r(N,theta) =
         let( alpha = 360/N )
         cos(alpha/2)/(cos(posmod(theta,alpha)-alpha/2));
-function spiral_sweep(poly, h, r, turns=1, higbee, center, r1, r2, d, d1, d2, higbee1, higbee2, internal=false, anchor=CENTER, spin=0, orient=UP) =
-    assert(is_num(turns) && turns != 0)
+function spiral_sweep(poly, h, r, turns=1, taper, r1, r2, d, d1, d2, internal=false,
+                      lead_in_shape,lead_in_shape1, lead_in_shape2,
+                      lead_in, lead_in1, lead_in2,
+                      lead_in_ang, lead_in_ang1, lead_in_ang2,
+                      height,l,length,
+                      lead_in_sample = 10,
+                      anchor=CENTER, spin=0, orient=UP) =
+    assert(is_num(turns) && turns != 0, "turns must be a nonzero number")
+    assert(all_positive([h]), "Spiral height must be a positive number")
     let(
-        twist = 360*turns, 
-        higsample = 10,         // Oversample factor for higbee tapering
+        dir = sign(turns),
+        r1 = get_radius(r1=r1, r=r, d1=d1, d=d),
+        r2 = get_radius(r1=r2, r=r, d1=d2, d=d),
         bounds = pointlist_bounds(poly),
         yctr = (bounds[0].y+bounds[1].y)/2,
         xmin = bounds[0].x,
         xmax = bounds[1].x,
         poly = path3d(clockwise_polygon(poly)),
-        anchor = get_anchor(anchor,center,BOT,BOT),
-        r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=50),
-        r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=50),
         sides = segs(max(r1,r2)),
-        dir = sign(twist),
-        ang_step = 360/sides*dir,
-        anglist = [for(ang = [0:ang_step:twist-EPSILON]) ang,
-                   twist],
-        higbee1 = first_defined([higbee1, higbee, 0]),
-        higbee2 = first_defined([higbee2, higbee, 0]),
-        higang1 = 360 * higbee1 / (2 * r1 * PI),
-        higang2 = 360 * higbee2 / (2 * r2 * PI)
+        ang_step = 360/sides,
+        turns = abs(turns),
+        lead_in1 = first_defined([lead_in1, lead_in]),
+        lead_in2 = first_defined([lead_in1, lead_in]),        
+        lead_in_ang1 =
+                      let(
+                           user_ang = first_defined([lead_in_ang1,lead_in_ang])
+                      )
+                      assert(is_undef(user_ang) || is_undef(lead_in1), "Cannot define lead_in/lead_in1 by both length and angle")
+                      is_def(user_ang) ? user_ang : default(lead_in1,0)*360/(2*PI*r1),
+        lead_in_ang2 =
+                      let(
+                           user_ang = first_defined([lead_in_ang2,lead_in_ang])
+                      )
+                      assert(is_undef(user_ang) || is_undef(lead_in2), "Cannot define lead_in/lead_in2 by both length and angle")
+                      is_def(user_ang) ? user_ang : default(lead_in2,0)*360/(2*PI*r2),
+        minang = -max(0,lead_in_ang1),
+        maxang = 360*turns + max(0,lead_in_ang2),
+        cut_ang1 = minang+abs(lead_in_ang1),
+        cut_ang2 = maxang-abs(lead_in_ang1),        
+        lead_in_shape1 = first_defined([lead_in_shape1, lead_in_shape, "default"]),
+        lead_in_shape2 = first_defined([lead_in_shape2, lead_in_shape, "default"]),             
+        lead_in_func1 = is_func(lead_in_shape1) ? lead_in_shape1
+                      : assert(is_string(lead_in_shape1),"lead_in_shape/lead_in_shape1 must be a function or string")
+                        let(ind = search([lead_in_shape1], _lead_in_table,0)[0])
+                        assert(ind!=[],str("Unknown lead_in_shape, \"",lead_in_shape1,"\""))
+                        _lead_in_table[ind[0]][1],
+        lead_in_func2 = is_func(lead_in_shape2) ? lead_in_shape2
+                      : assert(is_string(lead_in_shape2),"lead_in_shape/lead_in_shape2 must be a function or string")
+                        let(ind = search([lead_in_shape2], _lead_in_table,0)[0])
+                        assert(ind!=[],str("Unknown lead_in_shape, \"",lead_in_shape2,"\""))
+                        _lead_in_table[ind[0]][1]
     )
-    assert(higbee1>=0 && higbee2>=0)
-    assert(higang1 < dir*twist/2,"Higbee1 is more than half the threads")
-    assert(higang2 < dir*twist/2,"Higbee2 is more than half the threads")
+    assert( cut_ang1<cut_ang2, "Tapers are too long to fit")
+    assert( all_positive([r1,r2]), "Diameter/radius must be positive")
     let(
+  
+        // This complicated sampling scheme is designed to ensure that faceting always starts at angle zero
+        // for alignment with cylinders, and there is always a facet boundary at the $fn specified locations, 
+        // regardless of what kind of subsampling occurs for tapers.
+        orig_anglist = [
+            if (minang<0) minang,
+            each reverse([for(ang = [-ang_step:-ang_step:minang+EPSILON]) ang]),
+            for(ang = [0:ang_step:maxang-EPSILON]) ang,
+            maxang
+        ],
+        anglist = [
+           for(a=orig_anglist) if (a<cut_ang1-EPSILON) a,
+           cut_ang1,
+           for(a=orig_anglist) if (a>cut_ang1+EPSILON && a<cut_ang2-EPSILON) a,
+           cut_ang2,
+           for(a=orig_anglist) if (a>cut_ang2+EPSILON) a
+        ],
         interp_ang = [
-                      for(i=idx(anglist,e=-2))
+                      for(i=idx(anglist,e=-2)) 
                           each lerpn(anglist[i],anglist[i+1],
-                                     (higang1>0 && higang1>dir*anglist[i+1]
-                                      || (higang2>0 && higang2>dir*(twist-anglist[i]))) ? ceil((anglist[i+1]-anglist[i])/ang_step*higsample)
-                                                                                        : 1,
+                                         (lead_in_ang1!=0 && anglist[i+1]<=cut_ang1) || (lead_in_ang2!=0 && anglist[i]>=cut_ang2)
+                                            ? ceil((anglist[i+1]-anglist[i])/ang_step*lead_in_sample)
+                                            : 1,
                                      endpoint=false),
                       last(anglist)
                      ],
         skewmat = affine3d_skew_xz(xa=atan2(r2-r1,h)),
         points = [
             for (a = interp_ang) let (
-                hsc = dir*a<higang1 ? _taperfunc(dir*a/higang1)
-                    : dir*(twist-a)<higang2 ? _taperfunc(dir*(twist-a)/higang2)
-                    : 1,
-                u = a/twist,
+                hsc = a<cut_ang1 ? lead_in_func1((a-minang)/abs(lead_in_ang1),abs(lead_in_ang1)*2*PI*r1/360)
+                    : a>cut_ang2 ? lead_in_func2((maxang-a)/abs(lead_in_ang2),abs(lead_in_ang2)*2*PI*r2/360)
+                    : [1,1],
+                u = a/(360*turns), 
                 r = lerp(r1,r2,u),
-                mat = affine3d_zrot(a)
-                    * affine3d_translate([_ss_polygon_r(sides,a)*r, 0, h * (u-0.5)])
+                mat = affine3d_zrot(dir*a)
+                    * affine3d_translate([_ss_polygon_r(sides,dir*a)*r, 0, h * (u-0.5)])
                     * affine3d_xrot(90)
                     * skewmat
-                    * scale([hsc,lerp(hsc,1,0.25),1], cp=[internal ? xmax : xmin, yctr, 0]),
+                    * scale([hsc.y,hsc.x,1], cp=[internal ? xmax : xmin, yctr, 0]),
                 pts = apply(mat, poly)
             ) pts
         ],
         vnf = vnf_vertex_array(
-            points, col_wrap=true, caps=true, reverse=dir>0?true:false, 
-            style=higbee1>0 || higbee2>0 ? "quincunx" : "alt"
+            points, col_wrap=true, caps=true, reverse=dir>0,
+        //    style=higbee1>0 || higbee2>0 ? "quincunx" : "alt"
+            style="convex"
         )
     )
     reorient(anchor,spin,orient, vnf=vnf, r1=r1, r2=r2, l=h, p=vnf);
 
 
 
-module spiral_sweep(poly, h, r, turns=1, higbee, center, r1, r2, d, d1, d2, higbee1, higbee2, internal=false, anchor=CENTER, spin=0, orient=UP) {
-    vnf = spiral_sweep(poly, h, r, turns, higbee, center, r1, r2, d, d1, d2, higbee1, higbee2, internal);
-    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=50);
-    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=50);
+module spiral_sweep(poly, h, r, turns=1, taper, r1, r2, d, d1, d2, internal=false,
+                    lead_in_shape,lead_in_shape1, lead_in_shape2,
+                    lead_in, lead_in1, lead_in2,
+                    lead_in_ang, lead_in_ang1, lead_in_ang2,
+                    height,l,length,
+                    lead_in_sample=10,
+                    anchor=CENTER, spin=0, orient=UP)
+{
+    vnf = spiral_sweep(poly=poly, h=h, r=r, turns=turns, r1=r1, r2=r2, d=d, d1=d1, d2=d2, internal=internal,
+                       lead_in_shape=lead_in_shape,lead_in_shape1=lead_in_shape1, lead_in_shape2=lead_in_shape2,
+                       lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2,
+                       lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,
+                       height=height,l=length,length=length,
+                       lead_in_sample=lead_in_sample);
+    h = one_defined([h,height,length,l],"h,height,length,l");
+    r1 = get_radius(r1=r1, r=r, d1=d1, d=d);
+    r2 = get_radius(r1=r2, r=r, d1=d2, d=d);
+    lead_in1 = u_mul(first_defined([lead_in1,lead_in]),1/(2*PI*r1));
+    lead_in2 = u_mul(first_defined([lead_in2,lead_in]),1/(2*PI*r2));
+    lead_in_ang1 = first_defined([lead_in_ang1,lead_in_ang]);
+    lead_in_ang2 = first_defined([lead_in_ang2,lead_in_ang]);
+    extra_turns = max(0,first_defined([lead_in1,lead_in_ang1,0]))+max(0,first_defined([lead_in2,lead_in_ang2,0]));
     attachable(anchor,spin,orient, r1=r1, r2=r2, l=h) {
-        vnf_polyhedron(vnf, convexity=ceil(abs(2*turns)));
+        vnf_polyhedron(vnf, convexity=ceil(2*(abs(turns)+extra_turns)));
         children();
     }
 }
 
 
 
 // Function&Module: path_sweep()
 // Usage: As module
-//   path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [convexity=], [anchor=], [cp=], [spin=], [orient=], [atype=]) [ATTACHMENTS];
+//   path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [scale=], [scale_by_length=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [convexity=], [anchor=], [cp=], [spin=], [orient=], [atype=]) [ATTACHMENTS];
 // Usage: As function
-//   vnf = path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [transforms=], [anchor=], [cp=], [spin=], [orient=], [atype=]);
+//   vnf = path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [scale=], [scale_by_length=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [transforms=], [anchor=], [cp=], [spin=], [orient=], [atype=]);
 // Description:
 //   Takes as input `shape`, a 2D polygon path (list of points), and `path`, a 2d or 3d path (also a list of points)
 //   and constructs a polyhedron by sweeping the shape along the path. When run as a module returns the polyhedron geometry.
 //   When run as a function returns a VNF by default or if you set `transforms=true` then it returns a list of transformations suitable as input to `sweep`.
 //   .
 //   The sweeping process places one copy of the shape for each point in the path.  The origin in `shape` is translated to
 //   the point in `path`.  The normal vector of the shape, which points in the Z direction, is aligned with the tangent
 //   vector for the path, so this process is constructing a shape whose normal cross sections are equal to your specified shape.
 //   If you do not supply a list of tangent vectors then an approximate tangent vector is computed
-//   based on the path points you supply using {{path_tangents()}}.  
-//   .
-// Figure(3D,Big,VPR=[70,0,345],VPD=20,VPT=[5.5,10.8,-2.7],NoScales): This example shows how the shape, in this case the quadrilateral defined by `[[0, 0], [0, 1], [0.25, 1], [1, 0]]`, appears as the cross section of the swept polyhedron.  The blue line shows the path.  The normal vector to the shape is shown in black; it is based at the origin and points upwards in the Z direction.  The sweep aligns this normal vector with the blue path tangent, which in this case, flips the shape around.  Note that for a 2D path like this one, the Y direction in the shape is mapped to the Z direction in the sweep.   
+//   based on the path points you supply using {{path_tangents()}}.
+// Figure(3D,Big,VPR=[70,0,345],VPD=20,VPT=[5.5,10.8,-2.7],NoScales): This example shows how the shape, in this case the quadrilateral defined by `[[0, 0], [0, 1], [0.25, 1], [1, 0]]`, appears as the cross section of the swept polyhedron.  The blue line shows the path.  The normal vector to the shape is shown in black; it is based at the origin and points upwards in the Z direction.  The sweep aligns this normal vector with the blue path tangent, which in this case, flips the shape around.  Note that for a 2D path like this one, the Y direction in the shape is mapped to the Z direction in the sweep.
 //   tri= [[0, 0], [0, 1], [.25,1], [1, 0]];
 //   path = arc(r=5,n=81,angle=[-20,65]);
 //   % path_sweep(tri,path);
 //   T = path_sweep(tri,path,transforms=true);
 //   color("red")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);
 //   color("blue")stroke(path3d(arc(r=5,n=101,angle=[-20,80])),width=.1,endcap2="arrow2");
 //   color("red")stroke([path3d(tri)],width=.1);
 //   stroke([CENTER,UP], width=.07,endcap2="arrow2",color="black");
-// .
+// Continues:
 //   In the figure you can see that the swept polyhedron, shown in transparent gray, has the quadrilateral as its cross
 //   section.  The quadrilateral is positioned perpendicular to the path, which is shown in blue, so that the normal
 //   vector for the quadrilateral is parallel to the tangent vector for the path.  The origin for the shape is the point
 //   which follows the path.  For a 2D path, the Y axis of the shape is mapped to the Z axis and in this case,
 //   pointing the quadrilateral's normal vector (in black) along the tangent line of
 //   the path, which is going in the direction of the blue arrow, requires that the quadrilateral be "turned around".  If we
 //   reverse the order of points in the path we get a different result:
@@ -818,27 +1310,27 @@
 //   color("red")stroke([path3d(tri)],width=.1);
 //   stroke([CENTER,UP], width=.07,endcap2="arrow2",color="black");
 // Continues:
 //   If your shape is too large for the curves in the path you can create a situation where the shapes cross each
 //   other.  This results in an invalid polyhedron, which may appear OK when previewed or rendered alone, but will give rise
 //   to cryptic CGAL errors when rendered with a second object in your model.  You may be able to use {{path_sweep2d()}}
 //   to produce a valid model in cases like this.  You can debug models like this using the `profiles=true` option which will show all
-//   the cross sections in your polyhedron.  If any of them intersect, the polyhedron will be invalid.  
+//   the cross sections in your polyhedron.  If any of them intersect, the polyhedron will be invalid.
 // Figure(3D,Big,VPR=[47,0,325],VPD=23,VPT=[6.8,4,-3.8],NoScales): We have scaled the path to an ellipse and show a large triangle as the shape.  The triangle is sometimes bigger than the local radius of the path, leading to an invalid polyhedron, which you can identify because the red lines cross in the middle.
 //   tri= scale([4.5,2.5],[[0, 0], [0, 1], [1, 0]]);
 //   path = xscale(1.5,arc(r=5,n=81,angle=[-70,70]));
 //   % path_sweep(tri,path);
 //   T = path_sweep(tri,path,transforms=true);
 //   color("red")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);
 //   color("blue")stroke(path3d(xscale(1.5,arc(r=5,n=81,angle=[-70,80]))),width=.1,endcap2="arrow2");
 // Continues:
 //   During the sweep operation the shape's normal vector aligns with the tangent vector of the path.  Note that
 //   this leaves an ambiguity about how the shape is rotated as it sweeps along the path.
 //   For 2D paths, this ambiguity is resolved by aligning the Y axis of the shape to the Z axis of the swept polyhedron.
-//   You can can force the  shape to twist as it sweeps along the path using the `twist` parameter, which specifies the total
+//   You can force the  shape to twist as it sweeps along the path using the `twist` parameter, which specifies the total
 //   number of degrees to twist along the whole swept polyhedron.  This produces a result like the one shown below.
 // Figure(3D,Big,VPR=[66,0,14],VPD=20,VPT=[3.4,4.5,-0.8]): The shape twists as we sweep.  Note that it still aligns the origin in the shape with the path, and still aligns the normal vector with the path tangent vector.
 //   tri= [[0, 0], [0, 1], [.25,1],[1, 0]];
 //   path = arc(r=5,n=81,angle=[-20,65]);
 //   % path_sweep(tri,path,twist=-60);
 //   T = path_sweep(tri,path,transforms=true,twist=-60);
 //   color("red")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);
@@ -874,151 +1366,163 @@
 //   its basic form provides no guarantee that the start and end shapes match up.  To prevent a sudden twist at the last segment,
 //   the method calculates the required twist for a good match and distributes it over the whole model (as if you had specified a
 //   twist amount).  If you specify `symmetry` this may allow the algorithm to choose a smaller twist for this alignment.
 //   To start the algorithm, we need an initial condition.  This is supplied by
 //   using the `normal` argument to give a direction to align the Y axis of your shape.  By default the normal points UP if the path
 //   makes an angle of 45 deg or less with the xy plane and it points BACK if the path makes a higher angle with the XY plane.  You
 //   can also supply `last_normal` which provides an ending orientation constraint.  Be aware that the curve may still exhibit
-//   twisting in the middle.  This method is the default because it is the most robust, not because it generally produces the best result.  
+//   twisting in the middle.  This method is the default because it is the most robust, not because it generally produces the best result.
 //   .
 //   The "natural" method works by computing the Frenet frame at each point on the path.  This is defined by the tangent to the curve and
 //   the normal which lies in the plane defined by the curve at each point.  This normal points in the direction of curvature of the curve.
 //   The result is a very well behaved set of shape positions without any unexpected twisting&mdash;as long as the curvature never falls to zero.  At a
 //   point of zero curvature (a flat point), the curve does not define a plane and the natural normal is not defined.  Furthermore, even if
 //   you skip over this troublesome point so the normal is defined, it can change direction abruptly when the curvature is zero, leading to
 //   a nasty twist and an invalid model.  A simple example is a circular arc joined to another arc that curves the other direction.  Note
 //   that the X axis of the shape is aligned with the normal from the Frenet frame.
 //   .
 //   The "manual" method allows you to specify your desired normal either globally with a single vector, or locally with
 //   a list of normal vectors for every path point.  The normal you supply is projected to be orthogonal to the tangent to the
-//   path and the Y direction of your shape will be aligned with the projected normal.  (Note this is different from the "natural" method.)  
+//   path and the Y direction of your shape will be aligned with the projected normal.  (Note this is different from the "natural" method.)
 //   Careless choice of a normal may result in a twist in the shape, or an error if your normal is parallel to the path tangent.
 //   If you set `relax=true` then the condition that the cross sections are orthogonal to the path is relaxed and the swept object
 //   uses the actual specified normal.  In this case, the tangent is projected to be orthogonal to your supplied normal to define
 //   the cross section orientation.  Specifying a list of normal vectors gives you complete control over the orientation of your
 //   cross sections and can be useful if you want to position your model to be on the surface of some solid.
 //   .
+//   You can also apply scaling to the profile along the path.  You can give a list of scalar scale factors or a list of 2-vector scale. 
+//   In the latter scale the x and y scales of the profile are scaled separately before the profile is placed onto the path.  For non-closed
+//   paths you can also give a single scale value or a 2-vector which is treated as the final scale.  The intermediate sections
+//   are then scaled by linear interpolation either relative to length (if scale_by_length is true) or by point count otherwise.  
+//   .
 //   You can use set `transforms` to true to return a list of transformation matrices instead of the swept shape.  In this case, you can
 //   often omit shape entirely.  The exception is when `closed=true` and you are using the "incremental" method.  In this case, `path_sweep`
-//   uses the shape to correct for twist when the shape closes on itself, so you must include a valid shape.  
+//   uses the shape to correct for twist when the shape closes on itself, so you must include a valid shape.
 // Arguments:
 //   shape = A 2D polygon path or region describing the shape to be swept.
 //   path = 2D or 3D path giving the path to sweep over
 //   method = one of "incremental", "natural" or "manual".  Default: "incremental"
 //   ---
 //   normal = normal vector for initializing the incremental method, or for setting normals with method="manual".  Default: UP if the path makes an angle lower than 45 degrees to the xy plane, BACK otherwise.
 //   closed = path is a closed loop.  Default: false
 //   twist = amount of twist to add in degrees.  For closed sweeps must be a multiple of 360/symmetry.  Default: 0
+//   twist_by_length = if true then interpolate twist based on the path length of the path. If false interoplate based on point count.  Default: true
 //   symmetry = symmetry of the shape when closed=true.  Allows the shape to join with a 360/symmetry rotation instead of a full 360 rotation.  Default: 1
+//   scale = Amount to scale the profiles.  If you give a scalar the scale starts at 1 and ends at your specified value. The same is true for a 2-vector, but x and y are scaled separately.   You can also give a vector of values, one for each path point, and you can give a list of 2-vectors that give the x and y scales of your profile for every point on the path (a Nx2 matrix for a path of length N.  Default: 1 (no scaling)
+//   scale_by_length = if true then interpolate scale based on the path length of the path. If false interoplate based on point count.  Default: true
 //   last_normal = normal to last point in the path for the "incremental" method.  Constrains the orientation of the last cross section if you supply it.
 //   uniform = if set to false then compute tangents using the uniform=false argument, which may give better results when your path is non-uniformly sampled.  This argument is passed to {{path_tangents()}}.  Default: true
 //   tangent = a list of tangent vectors in case you need more accuracy (particularly at the end points of your curve)
 //   relaxed = set to true with the "manual" method to relax the orthogonality requirement of cross sections to the path tangent.  Default: false
 //   caps = Can be a boolean or vector of two booleans.  Set to false to disable caps at the two ends.  Default: true
 //   style = vnf_vertex_array style.  Default: "min_edge"
 //   profiles = if true then display all the cross section profiles instead of the solid shape.  Can help debug a sweep.  (module only) Default: false
 //   width = the width of lines used for profile display.  (module only) Default: 1
 //   transforms = set to true to return transforms instead of a VNF.  These transforms can be manipulated and passed to sweep().  (function only)  Default: false.
 //   convexity = convexity parameter for polyhedron().  (module only)  Default: 10
 //   anchor = Translate so anchor point is at the origin. Default: "origin"
 //   spin = Rotate this many degrees around Z axis after anchor. Default: 0
-//   orient = Vector to rotate top towards after spin  
+//   orient = Vector to rotate top towards after spin
 //   atype  = Select "hull" or "intersect" anchor types.  Default: "hull"
 //   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
+// See Also: sweep(), linear_sweep(), rotate_sweep(), spiral_sweep()
 // Example(NoScales): A simple sweep of a square along a sine wave:
 //   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];
 //   sq = square(6,center=true);
 //   path_sweep(sq,path);
 // Example(NoScales): If the square is not centered, then we get a different result because the shape is in a different place relative to the origin:
 //   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];
 //   sq = square(6);
 //   path_sweep(sq,path);
-// Example(Med,VPR=[34,0,8],NoScales): It may not be obvious, but the polyhedron in the previous example is invalid.  It will eventually give CGAL errors when you combine it with other shapes.  To see this, set profiles to true and look at the left side.  The profiles cross each other and intersect.  Any time this happens, your polyhedron is invalid, even if it seems to be working at first.  Another observation from the profile display is that we have more profiles than needed over a lot of the shape, so if the model is slow, using fewer profiles in the flat portion of the curve might speed up the calculation.  
+// Example(Med,VPR=[34,0,8],NoScales): It may not be obvious, but the polyhedron in the previous example is invalid.  It will eventually give CGAL errors when you combine it with other shapes.  To see this, set profiles to true and look at the left side.  The profiles cross each other and intersect.  Any time this happens, your polyhedron is invalid, even if it seems to be working at first.  Another observation from the profile display is that we have more profiles than needed over a lot of the shape, so if the model is slow, using fewer profiles in the flat portion of the curve might speed up the calculation.
 //   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];
 //   sq = square(6);
 //   path_sweep(sq,path,profiles=true,width=.1,$fn=8);
 // Example(2D): We'll use this shape in several examples
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   polygon(ushape);
 // Example(NoScales): Sweep along a clockwise elliptical arc, using default "incremental" method.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,00], r=30));  // Clockwise 
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,00], r=30));  // Clockwise
 //   path_sweep(ushape, path3d(elliptic_arc));
-// Example(NoScales): Sweep along a counter-clockwise elliptical arc.  Note that the orientation of the shape flips.  
+// Example(NoScales): Sweep along a counter-clockwise elliptical arc.  Note that the orientation of the shape flips.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));   // Counter-clockwise 
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));   // Counter-clockwise
 //   path_sweep(ushape, path3d(elliptic_arc));
 // Example(NoScales): Sweep along a clockwise elliptical arc, using "natural" method, which lines up the X axis of the shape with the direction of curvature.  This means the X axis will point inward, so a counterclockwise arc gives:
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));  // Counter-clockwise 
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));  // Counter-clockwise
 //   path_sweep(ushape, elliptic_arc, method="natural");
-// Example(NoScales): Sweep along a clockwise elliptical arc, using "natural" method.  If the curve is clockwise then the shape flips upside-down to align the X axis.  
+// Example(NoScales): Sweep along a clockwise elliptical arc, using "natural" method.  If the curve is clockwise then the shape flips upside-down to align the X axis.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise 
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise
 //   path_sweep(ushape, path3d(elliptic_arc), method="natural");
 // Example(NoScales): Sweep along a clockwise elliptical arc, using "manual" method.  You can orient the shape in a direction you choose (subject to the constraint that the profiles remain normal to the path):
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise 
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise
 //   path_sweep(ushape, path3d(elliptic_arc), method="manual", normal=UP+RIGHT);
 // Example(NoScales): Here we changed the ellipse to be more pointy, and with the same results as above we get a shape with an irregularity in the middle where it maintains the specified direction around the point of the ellipse.  If the ellipse were more pointy, this would result in a bad polyhedron:
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
-//   elliptic_arc = yscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise 
+//   elliptic_arc = yscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise
 //   path_sweep(ushape, path3d(elliptic_arc), method="manual", normal=UP+RIGHT);
-// Example(NoScales): It is easy to produce an invalid shape when your path has a smaller radius of curvature than the width of your shape.  The exact threshold where the shape becomes invalid depends on the density of points on your path.  The error may not be immediately obvious, as the swept shape appears fine when alone in your model, but adding a cube to the model reveals the problem.  In this case the pentagon is turned so its longest direction points inward to create the singularity.  
+// Example(NoScales): It is easy to produce an invalid shape when your path has a smaller radius of curvature than the width of your shape.  The exact threshold where the shape becomes invalid depends on the density of points on your path.  The error may not be immediately obvious, as the swept shape appears fine when alone in your model, but adding a cube to the model reveals the problem.  In this case the pentagon is turned so its longest direction points inward to create the singularity.
 //   qpath = [for(x=[-3:.01:3]) [x,x*x/1.8,0]];
 //   // Prints 0.9, but we use pentagon with radius of 1.0 > 0.9
 //   echo(radius_of_curvature = 1/max(path_curvature(qpath)));
 //   path_sweep(apply(rot(90),pentagon(r=1)), qpath, normal=BACK, method="manual");
 //   cube(0.5);    // Adding a small cube forces a CGAL computation which reveals
 //                 // the error by displaying nothing or giving a cryptic message
-// Example(NoScales): Using the `relax` option we allow the profiles to deviate from orthogonality to the path.  This eliminates the crease that broke the previous example because the sections are all parallel to each other.  
+// Example(NoScales): Using the `relax` option we allow the profiles to deviate from orthogonality to the path.  This eliminates the crease that broke the previous example because the sections are all parallel to each other.
 //   qpath = [for(x=[-3:.01:3]) [x,x*x/1.8,0]];
 //   path_sweep(apply(rot(90),pentagon(r=1)), qpath, normal=BACK, method="manual", relaxed=true);
 //   cube(0.5);    // Adding a small cube is not a problem with this valid model
-// Example(Med,VPR=[16,0,100],VPT=[0.05,0.6,0.6],VPD=25,NoScales): Using the `profiles=true` option can help debug bad polyhedra such as this one.  If any of the profiles intersect or cross each other, the polyhedron will be invalid.  In this case, you can see these intersections in the middle of the shape, which may give insight into how to fix your shape.   The profiles may also help you identify cases with a valid polyhedron where you have more profiles than needed to adequately define the shape.  
+// Example(Med,VPR=[16,0,100],VPT=[0.05,0.6,0.6],VPD=25,NoScales): Using the `profiles=true` option can help debug bad polyhedra such as this one.  If any of the profiles intersect or cross each other, the polyhedron will be invalid.  In this case, you can see these intersections in the middle of the shape, which may give insight into how to fix your shape.   The profiles may also help you identify cases with a valid polyhedron where you have more profiles than needed to adequately define the shape.
 //   tri= scale([4.5,2.5],[[0, 0], [0, 1], [1, 0]]);
 //   path = left(4,xscale(1.5,arc(r=5,n=25,angle=[-70,70])));
 //   path_sweep(tri,path,profiles=true,width=.1);
-// Example(NoScales):  This 3d arc produces a result that twists to an undefined angle.  By default the incremental method sets the starting normal to UP, but the ending normal is unconstrained.  
+// Example(NoScales):  This 3d arc produces a result that twists to an undefined angle.  By default the incremental method sets the starting normal to UP, but the ending normal is unconstrained.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));
 //   path_sweep(ushape, arc, method="incremental");
-// Example(NoScales): You can constrain the last normal as well.  Here we point it right, which produces a nice result.  
+// Example(NoScales): You can constrain the last normal as well.  Here we point it right, which produces a nice result.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));
 //   path_sweep(ushape, arc, method="incremental", last_normal=RIGHT);
-// Example(NoScales): Here we constrain the last normal to UP.  Be aware that the behavior in the middle is unconstrained.  
+// Example(NoScales): Here we constrain the last normal to UP.  Be aware that the behavior in the middle is unconstrained.
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));
 //   path_sweep(ushape, arc, method="incremental", last_normal=UP);
 // Example(NoScales): The "natural" method produces a very different result
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));
 //   path_sweep(ushape, arc, method="natural");
-// Example(NoScales): When the path starts at an angle of more that 45 deg to the xy plane the initial normal for "incremental" is BACK.  This produces the effect of the shape rising up out of the xy plane.  (Using UP for a vertical path is invalid, hence the need for a split in the defaults.)  
+// Example(NoScales): When the path starts at an angle of more that 45 deg to the xy plane the initial normal for "incremental" is BACK.  This produces the effect of the shape rising up out of the xy plane.  (Using UP for a vertical path is invalid, hence the need for a split in the defaults.)
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   arc = xrot(75, p=path3d(arc($fn=64, r=30, angle=[0,180])));
 //   path_sweep(ushape, arc, method="incremental");
 // Example(NoScales): Adding twist
-//   // Counter-clockwise 
-//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));   
+//   // Counter-clockwise
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));
 //   path_sweep(pentagon(r=1), path3d(elliptic_arc), twist=72);
 // Example(NoScales): Closed shape
-//   ellipse = xscale(2, p=circle($fn=64, r=3));  
+//   ellipse = xscale(2, p=circle($fn=64, r=3));
 //   path_sweep(pentagon(r=1), path3d(ellipse), closed=true);
 // Example(NoScales): Closed shape with added twist
 //   ellipse = xscale(2, p=circle($fn=64, r=3));
 //   // Looks better with finer sampling
-//   pentagon = subdivide_path(pentagon(r=1), 30);  
+//   pentagon = subdivide_path(pentagon(r=1), 30);
 //   path_sweep(pentagon, path3d(ellipse),
 //              closed=true, twist=360);
 // Example(NoScales): The last example was a lot of twist.  In order to use less twist you have to tell `path_sweep` that your shape has symmetry, in this case 5-fold.  Mobius strip with pentagon cross section:
 //   ellipse = xscale(2, p=circle($fn=64, r=3));
 //   // Looks better with finer sampling
-//   pentagon = subdivide_path(pentagon(r=1), 30);  
+//   pentagon = subdivide_path(pentagon(r=1), 30);
 //   path_sweep(pentagon, path3d(ellipse), closed=true,
 //              symmetry = 5, twist=2*360/5);
 // Example(Med,NoScales): A helical path reveals the big problem with the "incremental" method: it can introduce unexpected and extreme twisting.  (Note helix example came from list-comprehension-demos)
 //   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),
 //                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),
 //                         200 * (1 - t)];
 //   helix_steps = 200;
@@ -1037,15 +1541,15 @@
 //   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),
 //                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),
 //                         200 * (1 - t)];
 //   helix_steps = 200;
 //   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, helix, normal=UP, last_normal=UP, twist=360);
-// Example(Med,NoScales): To get a good result you must use a different method.  
+// Example(Med,NoScales): To get a good result you must use a different method.
 //   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),
 //                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),
 //                         200 * (1 - t)];
 //   helix_steps = 200;
 //   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, helix, method="natural");
@@ -1062,109 +1566,121 @@
 //                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),
 //                         200 * (1 - t)];
 //   helix_steps = 200;
 //   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];
 //   normals = [for(i=[0:helix_steps]) [-cos(6*360*i/helix_steps), -sin(6*360*i/helix_steps), 2.5]];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, helix, method="manual", normal=normals);
-// Example(NoScales): When using "manual" it is important to choose a normal that works for the whole path, producing a consistent result.  Here we have specified an upward normal, and indeed the shape is pointed up everywhere, but two abrupt transitional twists render the model invalid.  
+// Example(NoScales): When using "manual" it is important to choose a normal that works for the whole path, producing a consistent result.  Here we have specified an upward normal, and indeed the shape is pointed up everywhere, but two abrupt transitional twists render the model invalid.
 //   yzcircle = yrot(90,p=path3d(circle($fn=64, r=30)));
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, yzcircle, method="manual", normal=UP, closed=true);
-// Example(NoScales): The "natural" method will introduce twists when the curvature changes direction.  A warning is displayed.  
+// Example(NoScales): The "natural" method will introduce twists when the curvature changes direction.  A warning is displayed.
 //   arc1 = path3d(arc(angle=90, r=30));
 //   arc2 = xrot(-90, cp=[0,30],p=path3d(arc(angle=[90,180], r=30)));
 //   two_arcs = path_merge_collinear(concat(arc1,arc2));
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, two_arcs, method="natural");
 // Example(NoScales): The only simple way to get a good result is the "incremental" method:
 //   arc1 = path3d(arc(angle=90, r=30));
 //   arc2 = xrot(-90, cp=[0,30],p=path3d(arc(angle=[90,180], r=30)));
 //   arc3 = apply( translate([-30,60,30])*yrot(90), path3d(arc(angle=[270,180], r=30)));
 //   three_arcs = path_merge_collinear(concat(arc1,arc2,arc3));
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, three_arcs, method="incremental");
 // Example(Med,NoScales): knot example from list-comprehension-demos, "incremental" method
-//   function knot(a,b,t) =   // rolling knot 
-//        [ a * cos (3 * t) / (1 - b* sin (2 *t)), 
-//          a * sin( 3 * t) / (1 - b* sin (2 *t)), 
-//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))]; 
-//   a = 0.8; b = sqrt (1 - a * a); 
+//   function knot(a,b,t) =   // rolling knot
+//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),
+//          a * sin( 3 * t) / (1 - b* sin (2 *t)),
+//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];
+//   a = 0.8; b = sqrt (1 - a * a);
 //   ksteps = 400;
 //   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, knot_path, closed=true, method="incremental");
-// Example(Med,NoScales): knot example from list-comprehension-demos, "natural" method.  Which one do you like better? 
-//   function knot(a,b,t) =   // rolling knot 
-//        [ a * cos (3 * t) / (1 - b* sin (2 *t)), 
-//          a * sin( 3 * t) / (1 - b* sin (2 *t)), 
-//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))]; 
-//   a = 0.8; b = sqrt (1 - a * a); 
+// Example(Med,NoScales): knot example from list-comprehension-demos, "natural" method.  Which one do you like better?
+//   function knot(a,b,t) =   // rolling knot
+//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),
+//          a * sin( 3 * t) / (1 - b* sin (2 *t)),
+//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];
+//   a = 0.8; b = sqrt (1 - a * a);
 //   ksteps = 400;
 //   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   path_sweep(ushape, knot_path, closed=true, method="natural");
-// Example(Med,NoScales): knot with twist.  Note if you twist it the other direction the center section untwists because of the natural twist there.  Also compare to the "incremental" method which has less twist in the center.  
-//   function knot(a,b,t) =   // rolling knot 
-//        [ a * cos (3 * t) / (1 - b* sin (2 *t)), 
-//          a * sin( 3 * t) / (1 - b* sin (2 *t)), 
-//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))]; 
-//   a = 0.8; b = sqrt (1 - a * a); 
+// Example(Med,NoScales): knot with twist.  Note if you twist it the other direction the center section untwists because of the natural twist there.  Also compare to the "incremental" method which has less twist in the center.
+//   function knot(a,b,t) =   // rolling knot
+//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),
+//          a * sin( 3 * t) / (1 - b* sin (2 *t)),
+//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];
+//   a = 0.8; b = sqrt (1 - a * a);
 //   ksteps = 400;
 //   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];
 //   path_sweep(subdivide_path(pentagon(r=12),30), knot_path, closed=true,
 //              twist=-360*8, symmetry=5, method="natural");
 // Example(Med,NoScales): twisted knot with twist distributed by path sample points instead of by length using `twist_by_length=false`
-//   function knot(a,b,t) =   // rolling knot 
-//           [ a * cos (3 * t) / (1 - b* sin (2 *t)), 
-//             a * sin( 3 * t) / (1 - b* sin (2 *t)), 
-//           1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))]; 
-//   a = 0.8; b = sqrt (1 - a * a); 
+//   function knot(a,b,t) =   // rolling knot
+//           [ a * cos (3 * t) / (1 - b* sin (2 *t)),
+//             a * sin( 3 * t) / (1 - b* sin (2 *t)),
+//           1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];
+//   a = 0.8; b = sqrt (1 - a * a);
 //   ksteps = 400;
 //   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];
 //   path_sweep(subdivide_path(pentagon(r=12),30), knot_path, closed=true,
 //              twist=-360*8, symmetry=5, method="natural", twist_by_length=false);
-// Example(Big,NoScales): This torus knot example comes from list-comprehension-demos.  The knot lies on the surface of a torus.  When we use the "natural" method the swept figure is angled compared to the surface of the torus because the curve doesn't follow geodesics of the torus.  
-//   function knot(phi,R,r,p,q) = 
+// Example(Big,NoScales): This torus knot example comes from list-comprehension-demos.  The knot lies on the surface of a torus.  When we use the "natural" method the swept figure is angled compared to the surface of the torus because the curve doesn't follow geodesics of the torus.
+//   function knot(phi,R,r,p,q) =
 //       [ (r * cos(q * phi) + R) * cos(p * phi),
 //         (r * cos(q * phi) + R) * sin(p * phi),
 //          r * sin(q * phi) ];
 //   ushape = 3*[[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   points = 50;       // points per loop
 //   R = 400; r = 150;  // Torus size
 //   p = 2;  q = 5;     // Knot parameters
 //   %torus(r_maj=R,r_min=r);
-//   k = max(p,q) / gcd(p,q) * points; 
+//   k = max(p,q) / gcd(p,q) * points;
 //   knot_path   = [ for (i=[0:k-1]) knot(360*i/k/gcd(p,q),R,r,p,q) ];
 //   path_sweep(rot(90,p=ushape),knot_path,  method="natural", closed=true);
 // Example(Big,NoScales): By computing the normal to the torus at the path we can orient the path to lie on the surface of the torus:
-//   function knot(phi,R,r,p,q) = 
+//   function knot(phi,R,r,p,q) =
 //       [ (r * cos(q * phi) + R) * cos(p * phi),
 //         (r * cos(q * phi) + R) * sin(p * phi),
 //          r * sin(q * phi) ];
-//   function knot_normal(phi,R,r,p,q) =  
-//       knot(phi,R,r,p,q) 
+//   function knot_normal(phi,R,r,p,q) =
+//       knot(phi,R,r,p,q)
 //           - R*unit(knot(phi,R,r,p,q)
 //               - [0,0, knot(phi,R,r,p,q)[2]]) ;
 //   ushape = 3*[[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   points = 50;       // points per loop
 //   R = 400; r = 150;  // Torus size
 //   p = 2;  q = 5;     // Knot parameters
 //   %torus(r_maj=R,r_min=r);
-//   k = max(p,q) / gcd(p,q) * points; 
+//   k = max(p,q) / gcd(p,q) * points;
 //   knot_path   = [ for (i=[0:k-1]) knot(360*i/k/gcd(p,q),R,r,p,q) ];
 //   normals = [ for (i=[0:k-1]) knot_normal(360*i/k/gcd(p,q),R,r,p,q) ];
 //   path_sweep(ushape,knot_path,normal=normals, method="manual", closed=true);
-// Example(NoScales): You can request the transformations and manipulate them before passing them on to sweep.  Here we construct a tube that changes scale by first generating the transforms and then applying the scale factor and connecting the inside and outside.  Note that the wall thickness varies because it is produced by scaling.  
+// Example(NoScales): You can request the transformations and manipulate them before passing them on to sweep.  Here we construct a tube that changes scale by first generating the transforms and then applying the scale factor and connecting the inside and outside.  Note that the wall thickness varies because it is produced by scaling.
 //   shape = star(n=5, r=10, ir=5);
 //   rpath = arc(25, points=[[29,6,-4], [3,4,6], [1,1,7]]);
 //   trans = path_sweep(shape, rpath, transforms=true);
 //   outside = [for(i=[0:len(trans)-1]) trans[i]*scale(lerp(1,1.5,i/(len(trans)-1)))];
 //   inside = [for(i=[len(trans)-1:-1:0]) trans[i]*scale(lerp(1.1,1.4,i/(len(trans)-1)))];
 //   sweep(shape, concat(outside,inside),closed=true);
+// Example(NoScales): An easier way to scale your model is to use the scale parameter.
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));
+//   path_sweep(pentagon(r=1), path3d(elliptic_arc), scale=2);
+// Example(NoScales): Scaling only in the y direction of the profile (z direction in the model in this case)
+//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));
+//   path_sweep(rect(2), path3d(elliptic_arc), scale=[1,2]);
+// Example(NoScales): Specifying scale at every point for a closed path
+//   N=64;
+//   path = circle(r=5, $fn=64);
+//   theta = lerpn(0,360,N,endpoint=false);
+//   scale = [for(t=theta) sin(6*t)/5+1];
+//   path_sweep(rect(2), path3d(path), closed=true, scale=scale);
 // Example(Med,NoScales): Using path_sweep on a region
 //   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];
 //   rgn2 = [square(30,center=false)];
 //   rgn3 = [for (size=[10:10:20]) move([15,15],p=square(size=size, center=true))];
 //   mrgn = union(rgn1,rgn2);
 //   orgn = difference(mrgn,rgn3);
 //   path_sweep(orgn,arc(r=40,angle=180));
@@ -1177,50 +1693,50 @@
 //   $fn=90;
 //   r=8;
 //   thickness=1;
 //   len=21;
 //   curve = [for(theta=[0:4:359])
 //              [r*cos(theta), r*sin(theta), 10+sin(6*theta)]];
 //   difference(){
-//     cylinder(r=r, l=len);
-//     down(.5)cylinder(r=r-thickness, l=len+1);
+//     cylinder(r=r, h=len);
+//     down(.5)cylinder(r=r-thickness, h=len+1);
 //     path_sweep(left(.05,square([1.1,1])), curve, closed=true,
 //                method="manual", normal=UP);
 //   }
 
-module path_sweep(shape, path, method="incremental", normal, closed, twist=0, twist_by_length=true,
+module path_sweep(shape, path, method="incremental", normal, closed, twist=0, twist_by_length=true, scale=1, scale_by_length=true,
                     symmetry=1, last_normal, tangent, uniform=true, relaxed=false, caps, style="min_edge", convexity=10,
                     anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull",profiles=false,width=1)
 {
     dummy = assert(is_region(shape) || is_path(shape,2), "shape must be a 2D path or region");
-    vnf = path_sweep(shape, path, method, normal, closed, twist, twist_by_length,
+    vnf = path_sweep(shape, path, method, normal, closed, twist, twist_by_length, scale, scale_by_length,
                     symmetry, last_normal, tangent, uniform, relaxed, caps, style);
 
     if (profiles){
-        assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"");      
-        tran = path_sweep(shape, path, method, normal, closed, twist, twist_by_length,
+        assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"");
+        tran = path_sweep(shape, path, method, normal, closed, twist, twist_by_length, scale, scale_by_length, 
                           symmetry, last_normal, tangent, uniform, relaxed,transforms=true);
         rshape = is_path(shape) ? [path3d(shape)]
                                 : [for(s=shape) path3d(s)];
         attachable(anchor,spin,orient, vnf=vnf, extent=atype=="hull", cp=cp) {
-            for(T=tran) stroke([for(part=rshape)apply(T,part)],width=width);        
+            for(T=tran) stroke([for(part=rshape)apply(T,part)],width=width);
             children();
         }
     }
-    else 
+    else
       vnf_polyhedron(vnf,convexity=convexity,anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)
           children();
-}        
+}
 
 
-function path_sweep(shape, path, method="incremental", normal, closed, twist=0, twist_by_length=true,
+function path_sweep(shape, path, method="incremental", normal, closed, twist=0, twist_by_length=true, scale=1, scale_by_length=true, 
                     symmetry=1, last_normal, tangent, uniform=true, relaxed=false, caps, style="min_edge", transforms=false,
                     anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull") =
-  is_1region(path) ? path_sweep(shape=shape,path=path[0], method=method, normal=normal, closed=default(closed,true),
-                                twist=twist, twist_by_length=twist_by_length, symmetry=symmetry, last_normal=last_normal,
+  is_1region(path) ? path_sweep(shape=shape,path=path[0], method=method, normal=normal, closed=default(closed,true), 
+                                twist=twist, scale=scale, scale_by_length=scale_by_length, twist_by_length=twist_by_length, symmetry=symmetry, last_normal=last_normal,
                                 tangent=tangent, uniform=uniform, relaxed=relaxed, caps=caps, style=style, transforms=transforms,
                                 anchor=anchor, cp=cp, spin=spin, orient=orient, atype=atype) :
   let(closed=default(closed,false))
   assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
   assert(!closed || twist % (360/symmetry)==0, str("For a closed sweep, twist must be a multiple of 360/symmetry = ",360/symmetry))
   assert(closed || symmetry==1, "symmetry must be 1 when closed is false")
   assert(is_integer(symmetry) && symmetry>0, "symmetry must be a positive integer")
@@ -1231,149 +1747,178 @@
   let(
     path = path3d(path),
     caps = is_def(caps) ? caps :
            closed ? false : true,
     capsOK = is_bool(caps) || is_bool_list(caps,2),
     fullcaps = is_bool(caps) ? [caps,caps] : caps,
     normalOK = is_undef(normal) || (method!="natural" && is_vector(normal,3))
-                                || (method=="manual" && same_shape(normal,path))
+                                || (method=="manual" && same_shape(normal,path)),
+    scaleOK = scale==1 || ((is_num(scale) || is_vector(scale,2)) && !closed) || is_vector(scale,len(path)) || is_matrix(scale,len(path),2)
+    
   )
   assert(normalOK,  method=="natural" ? "Cannot specify normal with the \"natural\" method"
                   : method=="incremental" ? "Normal with \"incremental\" method must be a 3-vector"
                   : str("Incompatible normal given.  Must be a 3-vector or a list of ",len(path)," 3-vectors"))
   assert(capsOK, "caps must be boolean or a list of two booleans")
   assert(!closed || !caps, "Cannot make closed shape with caps")
   assert(is_undef(normal) || (is_vector(normal) && len(normal)==3) || (is_path(normal) && len(normal)==len(path) && len(normal[0])==3), "Invalid normal specified")
   assert(is_undef(tangent) || (is_path(tangent) && len(tangent)==len(path) && len(tangent[0])==3), "Invalid tangent specified")
+  assert(scaleOK,str("Incompatible or invalid scale",closed?" for closed path":"",": must be ", closed?"":"a scalar, a 2-vector, ",
+                     "a vector of length ",len(path)," or a ",len(path),"x2 matrix of scales"))
   let(
+    scale = !(is_num(scale) || is_vector(scale,2)) ? scale
+          : let(s=is_num(scale) ? [scale,scale] : scale)
+            !scale_by_length ? lerpn([1,1],s,len(path))
+          : lerp([1,1],s, path_length_fractions(path,false)),
+    scale_list = [for(s=scale) scale(s),if (closed) scale(scale[0])],
     tangents = is_undef(tangent) ? path_tangents(path,uniform=uniform,closed=closed) : [for(t=tangent) unit(t)],
     normal = is_path(normal) ? [for(n=normal) unit(n)] :
              is_def(normal) ? unit(normal) :
              method =="incremental" && abs(tangents[0].z) > 1/sqrt(2) ? BACK : UP,
     normals = is_path(normal) ? normal : repeat(normal,len(path)),
-    pathfrac = twist_by_length ? path_length_fractions(path, closed) : [for(i=[0:1:len(path)]) i / (len(path)-(closed?0:1))],
+    tpathfrac = twist_by_length ? path_length_fractions(path, closed) : [for(i=[0:1:len(path)]) i / (len(path)-(closed?0:1))],
+    spathfrac = scale_by_length ? path_length_fractions(path, closed) : [for(i=[0:1:len(path)]) i / (len(path)-(closed?0:1))],    
     L = len(path),
-    transform_list = 
-      method=="incremental" ?
-        let(rotations =
-               [for( i  = 0,
-                     ynormal = normal - (normal * tangents[0])*tangents[0],
-                     rotation = frame_map(y=ynormal, z=tangents[0]) 
-                       ;
-                     i < len(tangents) + (closed?1:0) ;
-                     rotation = i<len(tangents)-1+(closed?1:0)? rot(from=tangents[i],to=tangents[(i+1)%L])*rotation : undef,
-                     i=i+1
-                    )
-                 rotation],
-            // The mismatch is the inverse of the last transform times the first one for the closed case, or the inverse of the
-            // desired final transform times the realized final transform in the open case.  Note that when closed==true the last transform
-            // is a actually looped around and applies to the first point position, so if we got back exactly where we started
-            // then it will be the identity, but we might have accumulated some twist which will show up as a rotation around the
-            // X axis.  Similarly, in the closed==false case the desired and actual transformations can only differ in the twist,
-            // so we can need to calculate the twist angle so we can apply a correction, which we distribute uniformly over the whole path.
-            reference_rot = closed ? rotations[0] :   
-                         is_undef(last_normal) ? last(rotations) : 
-                           let(
-                               last_tangent = last(tangents),
-                               lastynormal = last_normal - (last_normal * last_tangent) * last_tangent
-                           )
-                         frame_map(y=lastynormal, z=last_tangent),
-            mismatch = transpose(last(rotations)) * reference_rot, 
-            correction_twist = atan2(mismatch[1][0], mismatch[0][0]),
-            // Spread out this extra twist over the whole sweep so that it doesn't occur
-            // abruptly as an artifact at the last step.  
-            twistfix = correction_twist%(360/symmetry),
-            adjusted_final = !closed ? undef :
-                          translate(path[0]) * rotations[0] * zrot(-correction_twist+correction_twist%(360/symmetry)-twist)
-        )  [for(i=idx(path)) translate(path[i]) * rotations[i] * zrot((twistfix-twist)*pathfrac[i]), if(closed) adjusted_final] :
-      method=="manual" ?
-            [for(i=[0:L-(closed?0:1)]) let(    
-                     ynormal = relaxed ? normals[i%L] : normals[i%L] - (normals[i%L] * tangents[i%L])*tangents[i%L],
-                     znormal = relaxed ? tangents[i%L] - (normals[i%L] * tangents[i%L])*normals[i%L] : tangents[i%L],
-                     rotation = frame_map(y=ynormal, z=znormal)
-                 )
-                 assert(approx(ynormal*znormal,0),str("Supplied normal is parallel to the path tangent at point ",i))
-                 translate(path[i%L])*rotation*zrot(-twist*pathfrac[i]),
-            ] :
-      method=="natural" ?   // map x axis of shape to the path normal, which points in direction of curvature
-            let (pathnormal = path_normals(path, tangents, closed))
-            assert(all_defined(pathnormal),"Natural normal vanishes on your curve, select a different method")
-            let( testnormals = [for(i=[0:len(pathnormal)-1-(closed?1:2)]) pathnormal[i]*select(pathnormal,i+2)],
-                 a=[for(i=idx(testnormals)) testnormals[i]<.5 ? echo(str("Big change at index ",i," pn=",pathnormal[i]," pn2= ",select(pathnormal,i+2))):0],
-                 dummy = min(testnormals) < .5 ? echo("WARNING: ***** Abrupt change in normal direction.  Consider a different method *****") :0
-               )
-            [for(i=[0:L-(closed?0:1)]) let(
-                     rotation = frame_map(x=pathnormal[i%L], z=tangents[i%L])
+    unscaled_transform_list =
+        method=="incremental" ?
+          let(rotations =
+                 [for( i  = 0,
+                       ynormal = normal - (normal * tangents[0])*tangents[0],
+                       rotation = frame_map(y=ynormal, z=tangents[0])
+                         ;
+                       i < len(tangents) + (closed?1:0) ;
+                       rotation = i<len(tangents)-1+(closed?1:0)? rot(from=tangents[i],to=tangents[(i+1)%L])*rotation : undef,
+                       i=i+1
+                      )
+                   rotation],
+              // The mismatch is the inverse of the last transform times the first one for the closed case, or the inverse of the
+              // desired final transform times the realized final transform in the open case.  Note that when closed==true the last transform
+              // is a actually looped around and applies to the first point position, so if we got back exactly where we started
+              // then it will be the identity, but we might have accumulated some twist which will show up as a rotation around the
+              // X axis.  Similarly, in the closed==false case the desired and actual transformations can only differ in the twist,
+              // so we can need to calculate the twist angle so we can apply a correction, which we distribute uniformly over the whole path.
+              reference_rot = closed ? rotations[0] :
+                           is_undef(last_normal) ? last(rotations) :
+                             let(
+                                 last_tangent = last(tangents),
+                                 lastynormal = last_normal - (last_normal * last_tangent) * last_tangent
+                             )
+                           frame_map(y=lastynormal, z=last_tangent),
+              mismatch = transpose(last(rotations)) * reference_rot,
+              correction_twist = atan2(mismatch[1][0], mismatch[0][0]),
+              // Spread out this extra twist over the whole sweep so that it doesn't occur
+              // abruptly as an artifact at the last step.
+              twistfix = correction_twist%(360/symmetry),
+              adjusted_final = !closed ? undef :
+                            translate(path[0]) * rotations[0] * zrot(-correction_twist+correction_twist%(360/symmetry)-twist)
+          )  [for(i=idx(path)) translate(path[i]) * rotations[i] * zrot((twistfix-twist)*tpathfrac[i]), if(closed) adjusted_final] 
+      : method=="manual" ?
+              [for(i=[0:L-(closed?0:1)]) let(
+                       ynormal = relaxed ? normals[i%L] : normals[i%L] - (normals[i%L] * tangents[i%L])*tangents[i%L],
+                       znormal = relaxed ? tangents[i%L] - (normals[i%L] * tangents[i%L])*normals[i%L] : tangents[i%L],
+                       rotation = frame_map(y=ynormal, z=znormal)
+                   )
+                   assert(approx(ynormal*znormal,0),str("Supplied normal is parallel to the path tangent at point ",i))
+                   translate(path[i%L])*rotation*zrot(-twist*tpathfrac[i])
+              ]
+      : method=="cross"?
+              let(
+                  crossnormal_mid = [for(i=[(closed?0:1):L-(closed?1:2)])
+                                       let(v=    cross(  select(path,i+1)-path[i], path[i]-select(path,i-1)),
+                                           f=assert(norm(v)>EPSILON)
+                                       )
+                                       v
+                                    ],
+                  crossnormal = closed ? crossnormal_mid : [crossnormal_mid[0], each crossnormal_mid, last(crossnormal_mid)]
+              )
+              [for(i=[0:L-(closed?0:1)]) let(
+                       rotation = frame_map(x=crossnormal[i%L], z=tangents[i%L])
+                   )
+                   translate(path[i%L])*rotation*zrot(-twist*tpathfrac[i])
+                 ] 
+      : method=="natural" ?   // map x axis of shape to the path normal, which points in direction of curvature
+              let (pathnormal = path_normals(path, tangents, closed))
+              assert(all_defined(pathnormal),"Natural normal vanishes on your curve, select a different method")
+              let( testnormals = [for(i=[0:len(pathnormal)-1-(closed?1:2)]) pathnormal[i]*select(pathnormal,i+2)],
+                   a=[for(i=idx(testnormals)) testnormals[i]<.5 ? echo(str("Big change at index ",i," pn=",pathnormal[i]," pn2= ",select(pathnormal,i+2))):0],
+                   dummy = min(testnormals) < .5 ? echo("WARNING: ***** Abrupt change in normal direction.  Consider a different method in path_sweep() *****") :0
                  )
-                 translate(path[i%L])*rotation*zrot(-twist*pathfrac[i])
-               ] :
-      assert(false,"Unknown method or no method given")[], // unknown method
-      ends_match = !closed ? true
+              [for(i=[0:L-(closed?0:1)]) let(
+                       rotation = frame_map(x=pathnormal[i%L], z=tangents[i%L])
+                   )
+                   translate(path[i%L])*rotation*zrot(-twist*tpathfrac[i])
+                 ] 
+      : assert(false,"Unknown method or no method given"), // unknown method
+    transform_list = v_mul(unscaled_transform_list, scale_list),
+    ends_match = !closed ? true
                  : let( rshape = is_path(shape) ? [path3d(shape)]
                                                 : [for(s=shape) path3d(s)]
                    )
                    are_regions_equal(apply(transform_list[0], rshape),
                                      apply(transform_list[L], rshape)),
-      dummy = ends_match ? 0 : echo("WARNING: ***** The points do not match when closing the model *****")
-    )
-    transforms ? transform_list
-               : sweep(is_path(shape)?clockwise_polygon(shape):shape, transform_list, closed=false, caps=fullcaps,style=style,
+    dummy = ends_match ? 0 : echo("WARNING: ***** The points do not match when closing the model in path_sweep() *****")
+  )
+  transforms ? transform_list
+             : sweep(is_path(shape)?clockwise_polygon(shape):shape, transform_list, closed=false, caps=fullcaps,style=style,
                        anchor=anchor,cp=cp,spin=spin,orient=orient,atype=atype);
 
 
 // Function&Module: path_sweep2d()
 // Usage: as module
 //   path_sweep2d(shape, path, [closed], [caps], [quality], [style], [convexity=], [anchor=], [spin=], [orient=], [atype=], [cp=]) [ATTACHMENTS];
 // Usage: as function
 //   vnf = path_sweep2d(shape, path, [closed], [caps], [quality], [style], [anchor=], [spin=], [orient=], [atype=], [cp=]);
 // Description:
 //   Takes an input 2D polygon (the shape) and a 2d path, and constructs a polyhedron by sweeping the shape along the path.
 //   When run as a module returns the polyhedron geometry.  When run as a function returns a VNF.
 //   .
-//   See {{path_sweep()}} for more details on how the sweep operation works and for introductory examples.  
+//   See {{path_sweep()}} for more details on how the sweep operation works and for introductory examples.
 //   This 2d version is different because local self-intersections (creases in the output) are allowed and do not produce CGAL errors.
 //   This is accomplished by using offset() calculations, which are more expensive than simply copying the shape along
 //   the path, so if you do not have local self-intersections, use {{path_sweep()}} instead.  If xmax is the largest x value (in absolute value)
 //   of the shape, then path_sweep2d() will work as long as the offset of `path` exists at `delta=xmax`.  If the offset vanishes, as in the
-//   case of a circle offset by more than its radius, then you will get an error about a degenerate offset.  
+//   case of a circle offset by more than its radius, then you will get an error about a degenerate offset.
 //   Note that global self-intersections will still give rise to CGAL errors.  You should be able to handle these by partitioning your model.  The y axis of the
-//   shape is mapped to the z axis in the swept polyhedron, and no twisting can occur.  
+//   shape is mapped to the z axis in the swept polyhedron, and no twisting can occur.
 //   The quality parameter is passed to offset to determine the offset quality.
 // Arguments:
 //   shape = a 2D polygon describing the shape to be swept
 //   path = a 2D path giving the path to sweep over
 //   closed = path is a closed loop.  Default: false
 //   caps = true to create endcap faces when closed is false.  Can be a length 2 boolean array.  Default is true if closed is false.
 //   quality = quality of offset used in calculation.  Default: 1
 //   style = vnf_vertex_array style.  Default: "min_edge"
 //   ---
 //   convexity = convexity parameter for polyhedron (module only)  Default: 10
 //   anchor = Translate so anchor point is at the origin.  Default: "origin"
 //   spin = Rotate this many degrees around Z axis after anchor.  Default: 0
-//   orient = Vector to rotate top towards after spin 
+//   orient = Vector to rotate top towards after spin
 //   atype = Select "hull" or "intersect" anchor types.  Default: "hull"
 //   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
-// Example: Sine wave example with self-intersections at each peak.  This would fail with path_sweep(). 
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
+// Example: Sine wave example with self-intersections at each peak.  This would fail with path_sweep().
 //   sinewave = [for(i=[-30:10:360*2+30]) [i/40,3*sin(i)]];
 //   path_sweep2d(circle(r=3,$fn=15), sinewave);
-// Example: The ends can look weird if they are in a place where self intersection occurs.  This is a natural result of how offset behaves at ends of a path.  
+// Example: The ends can look weird if they are in a place where self intersection occurs.  This is a natural result of how offset behaves at ends of a path.
 //   coswave = [for(i=[0:10:360*1.5]) [i/40,3*cos(i)]];
 //   zrot(-20)
 //     path_sweep2d( circle(r=3,$fn=15), coswave);
 // Example: This closed path example works ok as long as the hole in the center remains open.
 //   ellipse = yscale(3,p=circle(r=3,$fn=120));
 //   path_sweep2d(circle(r=2.5,$fn=32), reverse(ellipse), closed=true);
 // Example: When the hole is closed a global intersection renders the model invalid.  You can fix this by taking the union of the two (valid) halves.
 //   ellipse = yscale(3,p=circle(r=3,$fn=120));
 //   L = len(ellipse);
 //   path_sweep2d(circle(r=3.25, $fn=32), select(ellipse,floor(L*.2),ceil(L*.8)),closed=false);
 //   path_sweep2d(circle(r=3.25, $fn=32), select(ellipse,floor(L*.7),ceil(L*.3)),closed=false);
 
 function path_sweep2d(shape, path, closed=false, caps, quality=1, style="min_edge",
-                      anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull") = 
+                      anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull") =
    let(
         caps = is_def(caps) ? caps
              : closed ? false : true,
         capsOK = is_bool(caps) || is_bool_list(caps,2),
         fullcaps = is_bool(caps) ? [caps,caps] : caps,
         shape = force_path(shape,"shape"),
         path = force_path(path)
@@ -1384,18 +1929,18 @@
    assert(!closed || !caps, "Cannot make closed shape with caps")
    let(
         profile = ccw_polygon(shape),
         flip = closed && is_polygon_clockwise(path) ? -1 : 1,
         path = flip ? reverse(path) : path,
         proflist= transpose(
                      [for(pt = profile)
-                        let(  
+                        let(
                             ofs = offset(path, delta=-flip*pt.x, return_faces=true,closed=closed, quality=quality),
                             map = column(_ofs_vmap(ofs,closed=closed),1)
-                        ) 
+                        )
                         select(path3d(ofs[0],pt.y),map)
                       ]
                   ),
         vnf = vnf_vertex_array([
                          each proflist,
                          if (closed) proflist[0]
                         ],cap1=fullcaps[0],cap2=fullcaps[1],col_wrap=true,style=style)
@@ -1427,15 +1972,15 @@
     ];
 
 
 // Extract first (default) or second edge that connects the parent curve to its offset.  The first input
 // face is a list of 3 or 4 vertices as indices into the two curves where the parent curve vertices are
 // numbered from 0 to firstlen-1 and the offset from firstlen and up.  The firstlen pararameter is used
 // to determine which curve the vertices belong to and to remove the offset so that the return gives
-// the index into each curve with a 0 base.  
+// the index into each curve with a 0 base.
 function _ofs_face_edge(face,firstlen,second=false) =
    let(
        itry = min_index(face),
        i = select(face,itry-1)<firstlen ? itry-1:itry,
        edge1 = select(face,[i,i-1]),
        edge2 = select(face,i+1)<firstlen ? select(face,[i+1,i+2])
                                          : select(face,[i,i+1])
@@ -1458,28 +2003,31 @@
 //   As a function, returns the VNF for the polyhedron.  As a module, computes the polyhedron.
 //   .
 //   Note that this is a very powerful, general framework for producing polyhedra.  It is important
 //   to ensure that your resulting polyhedron does not include any self-intersections, or it will
 //   be invalid and will generate CGAL errors.  If you get such errors, most likely you have an
 //   overlooked self-intersection.  Note also that the errors will not occur when your shape is alone
 //   in your model, but will arise if you add a second object to the model.  This may mislead you into
-//   thinking the second object caused a problem.  Even adding a simple cube to the model will reveal the problem.  
+//   thinking the second object caused a problem.  Even adding a simple cube to the model will reveal the problem.
 // Arguments:
 //   shape = 2d path or region, describing the shape to be swept.
 //   transforms = list of 4x4 matrices to apply
 //   closed = set to true to form a closed (torus) model.  Default: false
 //   caps = true to create endcap faces when closed is false.  Can be a singe boolean to specify endcaps at both ends, or a length 2 boolean array.  Default is true if closed is false.
 //   style = vnf_vertex_array style.  Default: "min_edge"
 //   ---
 //   convexity = convexity setting for use with polyhedron.  (module only) Default: 10
+//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
+//   atype = Select "hull" or "intersect" anchor types.  Default: "hull"
 //   anchor = Translate so anchor point is at the origin. Default: "origin"
 //   spin = Rotate this many degrees around Z axis after anchor. Default: 0
 //   orient = Vector to rotate top towards after spin  (module only)
-//   atype = Select "hull" or "intersect" anchor types.  Default: "hull"
-//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
 // Example(VPR=[45,0,74],VPD=175,VPT=[-3.8,12.4,19]): A bent object that also changes shape along its length.
 //   radius = 75;
 //   angle = 40;
 //   shape = circle(r=5,$fn=32);
 //   T = [for(i=[0:25]) xrot(-angle*i/25,cp=[0,radius,0])*scale([1+i/25, 2-i/25,1])];
 //   sweep(shape,T);
 // Example: This is the "sweep-drop" example from list-comprehension-demos.
@@ -1493,22 +2041,22 @@
 //   function f(x) = 3 - 2.5 * x;
 //   function r(x) = 2 * 180 * x * x * x;
 //   pathstep = 1;
 //   height = 100;
 //   shape_points = subdivide_path(square(10),40,closed=true);
 //   path_transforms = [for (i=[0:pathstep:height]) let(t=i/height) up(i) * scale([f(t),f(t),i]) * zrot(r(t))];
 //   sweep(shape_points, path_transforms);
-// Example: Twisted container.  Note that this technique doesn't create a fixed container wall thickness.  
+// Example: Twisted container.  Note that this technique doesn't create a fixed container wall thickness.
 //   shape = subdivide_path(square(30,center=true), 40, closed=true);
 //   outside = [for(i=[0:24]) up(i)*rot(i)*scale(1.25*i/24+1)];
 //   inside = [for(i=[24:-1:2]) up(i)*rot(i)*scale(1.2*i/24+1)];
 //   sweep(shape, concat(outside,inside));
 
 function sweep(shape, transforms, closed=false, caps, style="min_edge",
-               anchor="origin", cp="centroid", spin=0, orient=UP, atype="hull") = 
+               anchor="origin", cp="centroid", spin=0, orient=UP, atype="hull") =
     assert(is_consistent(transforms, ident(4)), "Input transforms must be a list of numeric 4x4 matrices in sweep")
     assert(is_path(shape,2) || is_region(shape), "Input shape must be a 2d path or a region.")
     let(
         caps = is_def(caps) ? caps :
             closed ? false : true,
         capsOK = is_bool(caps) || is_bool_list(caps,2),
         fullcaps = is_bool(caps) ? [caps,caps] : caps
@@ -1534,18 +2082,18 @@
                      cap1=fullcaps[0],cap2=fullcaps[1],col_wrap=true,style=style);
 
 
 module sweep(shape, transforms, closed=false, caps, style="min_edge", convexity=10,
              anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull")
 {
     vnf = sweep(shape, transforms, closed, caps, style);
-    vnf_polyhedron(vnf,convexity=convexity,anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)
-         children();
-}    
-         
+    vnf_polyhedron(vnf, convexity=convexity, anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)
+        children();
+}
+
 
 
 // Section: Functions for resampling and slicing profile lists
 
 // Function: subdivide_and_slice()
 // Topics: Paths, Path Subdivision
 // Usage:
@@ -1569,15 +2117,15 @@
                 numpoints == "lcm" ? lcmlist([for(p=profiles) len(p)]) :
                 is_num(numpoints) ? round(numpoints) : undef
   )
   assert(is_def(numpoints), "Parameter numpoints must be \"max\", \"lcm\" or a positive number")
   assert(numpoints>=maxsize, "Number of points requested is smaller than largest profile")
   let(fixpoly = [for(poly=profiles) subdivide_path(poly, numpoints,method=method)])
   slice_profiles(fixpoly, slices, closed);
-  
+
 
 
 // Function: slice_profiles()
 // Topics: Paths, Path Subdivision
 // Usage:
 //   profs = slice_profiles(profiles, slices, [closed]);
 // Description:
@@ -1600,15 +2148,15 @@
   )
   concat(slicelist, closed?[]:[profiles[len(profiles)-1]]);
 
 
 
 function _closest_angle(alpha,beta) =
     is_vector(beta) ? [for(entry=beta) _closest_angle(alpha,entry)]
-  : beta-alpha > 180 ? beta - ceil((beta-alpha-180)/360) * 360 
+  : beta-alpha > 180 ? beta - ceil((beta-alpha-180)/360) * 360
   : beta-alpha < -180 ? beta + ceil((alpha-beta-180)/360) * 360
   : beta;
 
 
 // Smooth data with N point moving average.  If angle=true handles data as angles.
 // If closed=true assumes last point is adjacent to the first one.
 // If closed=false pads data with left/right value (probably wrong behavior...should do linear interp)
@@ -1649,27 +2197,27 @@
 //   rotation so it completes one full turn plus the additional rotation given my the transform.
 //   You can give long as a scalar or as a vector.  Finally if closed is true then the
 //   resampling will connect back to the beginning.
 //   .
 //   The default is to resample based on the length of the arc defined by each rotation operator.  This produces
 //   uniform sampling over all of the transformations.  It requires that each rotation has nonzero length.
 //   In this case n specifies the total number of samples.  If you set method to "count" then you get
-//   n samples for each transform.  You can set n to a vector to vary the samples at each step.  
+//   n samples for each transform.  You can set n to a vector to vary the samples at each step.
 // Arguments:
 //   rotlist = list of rotation operators in 3d to resample
 //   n = Number of rotations to produce as output when method is "length" or number for each transformation if method is "count".  Can be a vector when method is "count"
 //   ---
 //   method = sampling method, either "length" or "count"
 //   twist = scalar or vector giving twist to add overall or at each rotation.  Default: none
 //   scale = scalar or vector giving scale factor to add overall or at each rotation.  Default: none
 //   smoothlen = amount of smoothing to apply to scaling and twist.  Should be an odd integer.  Default: 1
 //   long = resample the "long way" around the rotation, a boolean or list of booleans.  Default: false
 //   turns = add extra turns.  If a scalar adds the turns to every rotation, or give a vector.  Default: 0
 //   closed = if true then the rotation list is treated as closed.  Default: false
-// Example(3D): Resampling the arc from a compound rotation with translations thrown in.  
+// Example(3D): Resampling the arc from a compound rotation with translations thrown in.
 //   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25);
 //   sweep(circle(r=1,$fn=3), tran);
 // Example(3D): Applying a scale factor
 //   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25, scale=2);
 //   sweep(circle(r=1,$fn=3), tran);
 // Example(3D): Applying twist
 //   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25, twist=60);
@@ -1709,34 +2257,34 @@
 //   rtran = rot_resample(tran,100,twist=[0,60],smoothlen=1);
 //   sweep(subdivide_path(rect([3,3]),40),rtran);
 // Example(3D): Here's the smoothed twist transition
 //   include<BOSL2/turtle3d.scad>
 //   tran = turtle3d(["arcsteps", 1, "arcup", 10, 90, "move", 10], transforms=true,state=[1,-.5,0]);
 //   rtran = rot_resample(tran,100,twist=[0,60],smoothlen=17);
 //   sweep(subdivide_path(rect([3,3]),40),rtran);
-// Example(3D): Toothed belt based on a list-comprehension-demos example.  This version has a smoothed twist transition.  Try changing smoothlen to 1 to see the more abrupt transition that occurs without smoothing.  
+// Example(3D): Toothed belt based on a list-comprehension-demos example.  This version has a smoothed twist transition.  Try changing smoothlen to 1 to see the more abrupt transition that occurs without smoothing.
 //   include<BOSL2/turtle3d.scad>
 //   r_small = 19;       // radius of small curve
 //   r_large = 46;       // radius of large curve
 //   flat_length = 100;  // length of flat belt section
 //   teeth=42;           // number of teeth
 //   belt_width = 12;
 //   tooth_height = 9;
 //   belt_thickness = 3;
 //   angle = 180 - 2*atan((r_large-r_small)/flat_length);
 //   beltprofile = path3d(subdivide_path(
 //                   square([belt_width, belt_thickness],anchor=FWD),
 //                   20));
 //   beltrots =
-//     turtle3d(["arcsteps",1,          
+//     turtle3d(["arcsteps",1,
 //               "move", flat_length,
 //               "arcleft", r_small, angle,
 //               "move", flat_length,
-//     // Closing path will be interpolated            
-//     //        "arcleft", r_large, 360-angle    
+//     // Closing path will be interpolated
+//     //        "arcleft", r_large, 360-angle
 //              ],transforms=true);
 //   beltpath = rot_resample(beltrots,teeth*4,
 //                           twist=[180,0,-180,0],
 //                           long=[false,false,false,true],
 //                           smoothlen=15,closed=true);
 //   belt = [for(i=idx(beltpath))
 //             let(tooth = floor((i+$t*4)/2)%2)
@@ -1754,28 +2302,28 @@
     assert(method=="count" || is_int(n), "n must be an integer when method is \"length\"")
     assert(is_int(n) || is_vector(n,tcount), str("n must be scalar or vector with length ",tcount))
     let(
           count = method=="length" ? (closed ? n+1 : n)
                                    : (is_vector(n) ? sum(n) : tcount*n)+1  //(closed?0:1)
     )
     assert(is_bool(long) || len(long)==tcount,str("Input long must be a scalar or have length ",tcount))
-    let(      
+    let(
         long = force_list(long,tcount),
         turns = force_list(turns,tcount),
         T = [for(i=[0:1:tcount-1]) rot_inverse(rotlist[i])*select(rotlist,i+1)],
         parms = [for(i=idx(T))
                     let(tparm = rot_decode(T[i],long[i]))
                     [tparm[0]+turns[i]*360,tparm[1],tparm[2],tparm[3]]
                 ],
         radius = [for(i=idx(parms)) norm(parms[i][2])],
         length = [for(i=idx(parms)) norm([norm(parms[i][3]), parms[i][0]/360*2*PI*radius[i]])]
     )
     assert(method=="count" || all_positive(length),
            "Rotation list includes a repeated entry or a rotation around the origin, not allowed when method=\"length\"")
-    let(   
+    let(
         cumlen = [0, each cumsum(length)],
         totlen = last(cumlen),
         stepsize = totlen/(count-1),
         samples = method=="count"
                   ? let( n = force_list(n,tcount))
                     [for(N=n) lerpn(0,1,N,endpoint=false)]
                   :[for(i=idx(parms))
@@ -1826,15 +2374,15 @@
 // possible indexings of the longer polygon.  The theoretical run time is quadratic in the longer polygon and
 // linear in the shorter one.
 //
 // The top level function, _skin_distance_match(), cycles through all the of the indexings of the larger
 // polygon, computes the optimal value for each indexing, and chooses the overall best result.  It uses
 // _dp_extract_map() to thread back through the dynamic programming array to determine the actual mapping, and
 // then converts the result to an index repetition count list, which is passed to repeat_entries().
-// 
+//
 // The function _dp_distance_array builds up the rows of the dynamic programming matrix with reference
 // to the previous rows, where `tdist` holds the total distance for a given mapping, and `map`
 // holds the information about which path was optimal for each position.
 //
 // The function _dp_distance_row constructs each row of the dynamic programming matrix in the usual
 // way where entries fill in based on the three entries above and to the left.  Note that we duplicate
 // entry zero so account for wrap-around at the ends, and we initialize the distance to zero to avoid
@@ -1897,15 +2445,15 @@
                               tdist[small_ind-1][big_ind]],   // up
        newrow = concat(newrow, [min(costs)+norm(big[big_ind%len(big)]-small[small_ind%len(small)])]),
        newmap = concat(newmap, [min_index(costs)]),
        big_ind = big_ind+1
    ) if (big_ind==len(big)+1) each [newrow,newmap]];
 
 
-function _dp_extract_map(map) =  
+function _dp_extract_map(map) =
       [for(
            i=len(map)-1,
            j=len(map[0])-1,
            smallmap=[],
            bigmap = []
               ;
            j >= 0
@@ -1914,15 +2462,15 @@
            advance_j = map[i][j]==_MAP_LEFT || map[i][j]==_MAP_DIAG,
            i = i - (advance_i ? 1 : 0),
            j = j - (advance_j ? 1 : 0),
            bigmap = concat( [j%(len(map[0])-1)] ,  bigmap),
            smallmap = concat( [i%(len(map)-1)]  , smallmap)
           )
         if (i==0 && j==0) each [smallmap,bigmap]];
-     
+
 
 /// Internal Function: _skin_distance_match(poly1,poly2)
 /// Usage:
 ///   polys = _skin_distance_match(poly1,poly2);
 /// Description:
 ///   Find a way of associating the vertices of poly1 and vertices of poly2
 ///   that minimizes the sum of the length of the edges that connect the two polygons.
@@ -1964,15 +2512,15 @@
       newbig = list_rotate(repeat_entries(map_poly[1],unique_count(bigmap)[1]),bigshift)
       )
       swap ? [newbig, newsmall] : [newsmall,newbig];
 
 
 // This function associates vertices but with the assumption that index 0 is associated between the
 // two inputs.  This gives only quadratic run time.  As above, output is pair of polygons with
-// vertices duplicated as suited to use as input to skin(). 
+// vertices duplicated as suited to use as input to skin().
 
 function _skin_aligned_distance_match(poly1, poly2) =
     let(
       result = _dp_distance_array(poly1, poly2, abort_thresh=1/0),
       map = _dp_extract_map(result[1]),
       shift0 = len(map[0]) - max(max_index(map[0],all=true))-1,
       shift1 = len(map[1]) - max(max_index(map[1],all=true))-1,
@@ -2011,15 +2559,15 @@
     swap ? [newbig, newsmall] : [newsmall, newbig];
 
 
 function _find_one_tangent(curve, edge, curve_offset=[0,0,0], closed=true) =
     let(
         angles = [
             for (i = [0:len(curve)-(closed?1:2)])
-            let( 
+            let(
                 plane = plane3pt( edge[0], edge[1], curve[i]),
                 tangent = [curve[i], select(curve,i+1)]
             ) plane_line_angle(plane,tangent)
         ],
         zero_cross = [
             for (i = [0:len(curve)-(closed?1:2)])
             if (sign(angles[i]) != sign(select(angles,i+1)))
@@ -2042,27 +2590,27 @@
 //   The output is a list of polygons that all have the same number of vertices with some duplicates.  You specify the vertex splitting
 //   using the `split` which is a list where each entry corresponds to a polygon: split[i] is a value or list specifying which vertices in polygon i to split.
 //   Give the empty list if you don't want a split for a particular polygon.  If you list a vertex once then it will be split and mapped to
 //   two vertices in the next polygon.  If you list it N times then N copies will be created to map to N+1 vertices in the next polygon.
 //   You must ensure that each mapping produces the correct number of vertices to exactly map onto every vertex of the next polygon.
 //   Note that if you split (only) vertex i of a polygon that means it will map to vertices i and i+1 of the next polygon.  Vertex 0 will always
 //   map to vertex 0 and the last vertices will always map to each other, so if you want something different than that you'll need to reindex
-//   your polygons.  
+//   your polygons.
 // Arguments:
 //   polygons = list of polygons to split
 //   split = list of lists of split vertices
 // Example(FlatSpin,VPD=17,VPT=[0,0,2]):  If you skin together a square and hexagon using the optimal distance method you get two triangular faces on opposite sides:
 //   sq = regular_ngon(4,side=2);
 //   hex = apply(rot(15),hexagon(side=2));
 //   skin([sq,hex], slices=10, refine=10, method="distance", z=[0,4]);
 // Example(FlatSpin,VPD=17,VPT=[0,0,2]):  Using associate_vertices you can change the location of the triangular faces.  Here they are connect to two adjacent vertices of the square:
 //   sq = regular_ngon(4,side=2);
 //   hex = apply(rot(15),hexagon(side=2));
 //   skin(associate_vertices([sq,hex],[[1,2]]), slices=10, refine=10, sampling="segment", z=[0,4]);
-// Example(FlatSpin,VPD=17,VPT=[0,0,2]): Here the two triangular faces connect to a single vertex on the square.  Note that we had to rotate the hexagon to line them up because the vertices match counting forward, so in this case vertex 0 of the square matches to vertices 0, 1, and 2 of the hexagon.  
+// Example(FlatSpin,VPD=17,VPT=[0,0,2]): Here the two triangular faces connect to a single vertex on the square.  Note that we had to rotate the hexagon to line them up because the vertices match counting forward, so in this case vertex 0 of the square matches to vertices 0, 1, and 2 of the hexagon.
 //   sq = regular_ngon(4,side=2);
 //   hex = apply(rot(60),hexagon(side=2));
 //   skin(associate_vertices([sq,hex],[[0,0]]), slices=10, refine=10, sampling="segment", z=[0,4]);
 // Example(3D): This example shows several polygons, with only a single vertex split at each step:
 //   sq = regular_ngon(4,side=2);
 //   pent = pentagon(side=2);
 //   hex = hexagon(side=2);
@@ -2093,486 +2641,1356 @@
       splitindex = sort(concat(count(polylen), cursplit)),
       newpoly = [for(i=[0:len(polygons)-1]) i<=curpoly ? select(polygons[i],splitindex) : polygons[i]]
     )
    associate_vertices(newpoly, split, curpoly+1);
 
 
 
+// DefineHeader(Table;Headers=Texture Name|Type|Description): Texture Values
+
 // Section: Texturing
-// DefineHeader(Table;Headers=Texture Name|Description): Texture Values
+// Some operations are able to add texture to the objects they create.  A texture can be any regularly repeated variation in the height of the surface.
+// To define a texture you need to specify how the height should vary over a rectangular block that will be repeated to tile the object.  Because textures
+// are based on rectangular tiling, this means adding textures to curved shapes may result in distortion of the basic texture unit.  For example, if you
+// texture a cone, the scale of the texture will be larger at the wide end of the cone and smaller at the narrower end of the cone.
+// .
+// You can specify a texture using to method: a height field or a VNF.  For each method you also must specify the scale of the texture, which
+// gives the size of the rectangular unit in your object that will correspond to one texture tile.  Note that this scale does not preserve
+// aspect ratio: you can stretch the texture as desired.  
+// Subsection: Height Field Texture Maps
+//   The simplest way to specify a texture map is to give a 2d array of
+//   height values which specify the height of the texture on a grid.
+//   Values in the height field should range from 0 to 1.  A zero height
+//   in the height field corresponds to the height of the surface and 1
+//   the heighest point in the texture.
+// Figure(2D,Big,NoScales): Here is a 2d texture described by a "grid" that just contains a single row.  Such a texture can be used to create ribbing. The texture is `[[0, 1, 1, 0]]`, and the fixture shows three repetitions of the basic texture unit.
+//   ftex1 = [0,1,1,0,0];
+//   stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);
+//   right(4)stroke( transpose([count(5),ftex1]), dots=true, width=.05,dots_color="red",color="blue",dots_width=3);
+//   right(8)stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);
+//   stroke([[4,-.3],[8,-.3]],width=.05,endcaps="arrow2",color="black");
+//   move([6,-.4])color("black")text("Texture Size", size=0.3,anchor=BACK);
+// Continues:
+//   Line segments connect the dots within the texture and also the dots between adjacent texture tiles.
+//   The size of the texture (specified with `tex_size`) includes the segment that connects the tile to the next one.
+//   Note that the grid is always uniformly spaced.  If you want to keep the texture the same size but make the slope
+//   steeper you need to add more points.  
+// Figure(2D,Big,NoScales):  
+//   ftex2 = xscale(4/11,transpose([count(12),[0,1,1,1,1,1,1,1,1,1,0,0]]));
+//   stroke( ftex2, dots=true, dots_width=3,width=.05);
+//   right(4)stroke( ftex2, dots=true, width=.05,dots_color="red",color="blue",dots_width=3);
+//   right(8)stroke( ftex2, dots=true, dots_width=3,width=.05);
+//   stroke([[4,-.3],[8,-.3]],width=.05,endcaps="arrow2",color="black");
+//   move([6,-.4])color("black")text("Texture Size", size=0.3,anchor=BACK);
+// Continues:
+//   A more serious limitation of height field textures is that some shapes, such as hexagons or circles, cannot be accurately represented because
+//   their points don't fall on a grid.  Trying to create such shapes is difficult and will require many points to approximate the
+//   true point positions for the desired shape.  This will make the texture slow to compute.  
+//   Another serious limitation is more subtle.  In the 2D examples above, it is obvious how to connect the
+//   dots together.  But in 3D example we need to triangulate the points on a grid, and this triangulation is not unique.
+//   The `style` argument lets you specify how the points are triangulated using the styles supported by {{vnf_vertex_array()}}.
+//   In the example below we have expanded the 2D example into 3D:
+//   ```openscad
+//       [[0,0,0,0],
+//        [0,1,1,0],
+//        [0,1,1,0],
+//        [0,0,0,0]]
+//   ```
+//   and we show the 3D triangulations produced by the different styles:
+// Figure(3D,Big,NoAxes,VPR=[39.2,0,13.3],VPT=[3.76242,-5.50969,4.51854],VPD=32.0275):
+//   tex = [
+//          [0,0,0,0,0],
+//          [0,1,1,0,0],
+//          [0,1,1,0,0],
+//          [0,0,0,0,0],
+//          [0,0,0,0,0]       
+//         ];
+//   hm = [for(i=[0:4]) [for(j=[0:4]) [i,-j,tex[i][j]]]];      
+//   types = ["quincunx", "convex", "concave","default","alt","min_edge"]; 
+//   grid2d(spacing=5, n=[3,2]){
+//     let(s = types[$row*3+$col]){
+//       vnf_polyhedron(vnf_vertex_array(hm,style=s));
+//       if ($row==1)
+//         back(.8)right(2)rotate($vpr)color("black")text(s,size=.5,anchor=CENTER);
+//       else
+//         fwd(4.7)right(2)rotate($vpr)color("black")text(s,size=.5,anchor=CENTER);    
+//     }
+//   }  
+// Continues:
+//   Note that of the six available styles, five produce a different result.  There may exist some concave shape where none of the styles
+//   produce the right result everywhere on the shape.  If this happens it would be another limitation of height field textures.  (If you have an
+//   example of such a texture and shape please let us know!)
+// Subsection: VNF Textures
+//   VNF textures overcome all of the limitations of height field textures, but with two costs.  They can be more difficult to construct than
+//   a simple array of height values, and they are significantly slower to compute for a tile with the same number of points.  Note, however, for
+//   textures that don't neatly lie on a grid, a VNF tile will be more efficient than a finely sampled height field.  With VNF textures you can create
+//   textures that have disconnected components, or concavities that cannot be expressed with a single valued height map.  However, you can also
+//   create invalid textures that fail to close at the ends, so care is required to ensure that your resulting shape is valid.  
+//   .
+//   A VNF texture is defined by defining the texture tile with a VNF whose projection onto the XY plane is contained in the unit square [0,1] x [0,1] so
+//   that the VNF can be tiled.   The VNF is tiled without a gap, matching the edges, so the vertices along corresponding edges must match to make a
+//   consistent triangulation possible.  The VNF cannot have any X or Y values outside the interval [0,1].  If you want a valid polyhedron
+//   that OpenSCAD will render then you need to take care with edges of the tiles that correspond to endcap faces in the textured object.
+//   So for example, in a linear sweep, the top and bottom edges of tiles end abruptly to form the end cap of the object.  You can make a valid object
+//   in two ways.  One way is to create a tile with a single, complete edge along Y=0, and of course a corresponding edges along Y=1.  The second way
+//   to make a valid object is to have no points at all on the Y=0 line, and of course none on Y=1.  In this case, the resulting texture produces
+//   a collection of disconnected objects.  Note that the Z coordinates of your tile can be anything, but for the dimensional settings on textures
+//   to work intuitively, you should construct your tile so that Z ranges from 0 to 1.
+// Figure(3D): This is the "hexgrid" VNF tile, which creates a hexagonal grid texture, something which doesn't work well with a height field because the edges of the hexagon don't align with the grid.  Note how the tile ranges between 0 and 1 in both X, Y and Z.  In fact, to get a proper aspect ratio in your final texture you need to use the `tex_size` parameter to introduct a sqrt(3) scale factor.  
+//   tex = texture("hex_grid");
+//   vnf_polyhedron(tex);
+// Figure(3D): This is an example of a tile that has no edges at the top or bottom, so it creates disconnected rings.  See {{linear_sweep()}} for examples showing this tile in use.
+//   shape = skin([
+//                 rect(2/5),
+//                 rect(2/3),
+//                 rect(2/5)
+//                ],
+//                z=[0,1/2,1],
+//                slices=0,
+//                caps=false);
+//   tile = move([0,1/2,2/3],yrot(90,shape));
+//   vnf_polyhedron(tile);
 
-function _get_texture(tex,n,m) =
-    tex=="ribs"? [[1,0]] :
-    tex=="trunc_ribs"? [[0, each repeat(1,default(n,1)), 1]] :
-    tex=="wave_ribs"? [[for(a=[0:360/default(n,8):359]) (cos(a)+1)/2]] :
-    tex=="diamonds"? [[1,0],[0,1]] :
-    tex=="pyramids"? [[0,0],[0,1]] :
-    tex=="trunc_pyramids"? let(n=default(n,2)) [repeat(0,n+1), each repeat([0, each repeat(1,n+1)], n+1)] :
-    tex=="dimpled_pyramids"? [[0,0,0,0],[0,1,1,1],[0,1,0,1],[0,1,1,1]] :
-    tex=="hills"? let(n=default(n,12)) [for (a=[0:360/n:359.999]) [for (b=[0:360/n:359.999]) (cos(a)*cos(b)+1)/2]] :
-    tex=="waves"? let(n=default(n,12)) [for (v=[0:360/n:359.999]) [for (h=[0:360/n:359.999]) max(0,cos(h+90*cos(v)))]] :
-    tex=="dots"? let(n=default(n,12), m=default(m,0)) [for (y=[0:1:n-1]) [for (x=[0:1:n-1]) max(0,cos(90*norm([n,n]/2-[x,y])*2/(n-m))) ]] :
-    tex=="cones"? let(n=default(n,12), m=default(m,0)) [for (y=[0:1:n-1]) [for (x=[0:1:n-1]) max(0,1-(norm([n,n]/2-[x,y])*2/(n-m))) ]] :
-    assert(false, str("Unrecognized texture name: ", tex));
 
 
-// Function&Module: textured_linear_sweep()
-// Usage: As Function
-//   vnf = textured_linear_sweep(path, texture, tex_size, h, ...);
-//   vnf = textured_linear_sweep(path, texture, counts=, h=, ...);
-// Usage: As Module
-//   textured_linear_sweep(path, texture, tex_size, h, ...) [ATTACHMENTS];
-//   textured_linear_sweep(path, texture, counts=, h=, ...) [ATTACHMENTS];
-// Topics: Sweep, Extrusion, Textures, Knurling
+// Function: texture()
+// Usage:
+//   tx = texture(tex, [n=], [inset=], [gap=], [roughness=]);
+// Topics: Textures, Knurling
 // Description:
-//   Given a single polygon path, creates a linear extrusion of that polygon vertically, with a given texture tiled evenly over the side surfaces.
-//   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:
-//   https://raw.githubusercontent.com/revarbat/BOSL2/master/scripts/img2scad.py
+//   Given a texture name, returns a texture.  Textures can come in two varieties:
+//   - Heightfield textures which are 2D arrays of scalars.  These are usually faster to render, but can be less precise and prone to triangulation errors.  The table below gives the recommended style for the best triangulation.  If results are still incorrect, switch to the similar VNF tile by adding the "_vnf" suffix.
+//   - VNF Tile textures, which are VNFs that cover the unit square [0,0] x [1,1].  These tend to be slower to render, but allow greater flexibility and precision for shapes that don't align with a grid.
+//   In the descriptions below, imagine the textures positioned on the XY plane, so "horizontal" refers to the "sideways" dimensions of the texture and
+//   "up" and "down" refer to the depth dimension.  If a texture is placed on a cylinder the "depth" will become the radial direction and the "horizontal"
+//   direction will be the vertical and tangential directions on the cylindrical surface.  All horizontal dimensions for VNF textures are relative to the unit square
+//   on which the textures are defined, so a value of 0.25 for a gap or inset will refer to 1/4 of the texture's full length and/or width.  All supported textures appear below in the examples.  
 // Arguments:
-//   path = The path to sweep/extrude.
-//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0) that define the texture to apply to vertical surfaces.
-//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
-//   h / l = The height to extrude/sweep the path.
+//   tex = The name of the texture to get.
 //   ---
-//   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
-//   inset = If numeric, lowers the texture into the surface by that amount, before the tscale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
-//   rot = If true, rotates the texture 90º.
-//   tscale = Scaling multiplier for the texture depth.
-//   twist = Degrees of twist for the top of the extrustion/sweep, compared to the bottom.  Default: 0
-//   scale = Scaling multiplier for the top of the extrustion/sweep, compared to the bottom.  Default: 1
-//   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]
-//   caps = (function only) If true, create endcaps for the extruded shape.
-//   col_wrap = (function only) If true, the path is considered a closed polygon.
-//   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Default: `"min_edge"`
-//   reverse = If the default faces are facing the wrong way, you can reverse them by setting this to `true`.  Default: `false`
-//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
-//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// Texture Values:
-//   "ribs" = Vertically aligned triangular ribs.
-//   "trunc_ribs" = Like "ribs" but with flat rib tips.
-//   "wave_ribs" = Vertically aligned wavy ribs.
-//   "diamonds" = Diamond shapes with tips aligned with the axes.  Useful for knurling.
-//   "pyramids" = Pyramids shapes with flat sides aligned with the axes.  Also useful for knurling.
-//   "trunc_pyramids" = Like "pyramids" but with flattened tips.
-//   "dimpled_pyramids" = Like "trunc_pyramids" but with dimples in the flat tips.
-//   "hills" = Wavy hills and valleys,
-//   "waves" = A raised sine-wave patten, oriented vertically.
-//   "dots" = Raised small round bumps.
-//   "cones" = Raised conical spikes.
-// Extra Anchors:
-//   centroid_top = The centroid of the top of the shape, oriented UP.
-//   centroid = The centroid of the center of the shape, oriented UP.
-//   centroid_bot = The centroid of the bottom of the shape, oriented DOWN.
-// See Also: textured_revolution(), textured_cylinder(), textured_linear_sweep(), heightfield(), cylindrical_heightfield()
-// Example: "ribs" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "ribs", tex_size=[3,5]);
-// Example: Rotated "ribs" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "ribs", tex_size=[3,5], rot=true);
-// Example: Truncated "trunc_ribs" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "trunc_ribs", tex_size=[3,5]);
-// Example: "wave_ribs" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "wave_ribs", tex_size=[3,5]);
-// Example: "diamonds" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "diamonds", tex_size=[5,10], h=40, style="concave");
-// Example: "pyramids" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "pyramids", tex_size=[5,5], style="convex");
-// Example: Inverted "pyramids" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "pyramids", tex_size=[5,5], tscale=-1, style="concave");
-// Example: "trunc_pyramids" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "trunc_pyramids", tex_size=[5,5], style="convex");
-// Example: "trunc_pyramids" with style="concave".
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "trunc_pyramids", tex_size=[5,5], style="concave");
-// Example: Inverted "trunc_pyramids" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "trunc_pyramids", tex_size=[5,5], tscale=-1, style="concave");
-// Example: "dimpled_pyramids" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, h=40, "dimpled_pyramids", tex_size=[5,5], style="convex");
-// Example: "hills" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "hills", tex_size=[5,5], h=40, style="quincunx");
-// Example: "waves" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "waves", tex_size=[5,10], h=40, style="min_edge");
-// Example: "dots" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "dots", tex_size=[5,5], h=40, style="concave");
-// Example: Inverted "dots" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "dots", tex_size=[5,5], tscale=-1, h=40, style="concave");
-// Example: "cones" texture.
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   textured_linear_sweep(path, "cones", tex_size=[5,5], h=40, style="concave");
-// Example: User defined texture.
-//   path = ellipse(r=[20,10]);
-//   texture = [for (i=[0:9]) [ for (j=[0:9]) 1/max(0.5,norm([i,j]-[5,5])) ]];
-//   textured_linear_sweep(path, texture, tex_size=[5,5], h=40, style="min_edge", anchor=BOT);
-// Example: As Function
-//   path = glued_circles(r=15, spread=40, tangent=45);
-//   vnf = textured_linear_sweep(path, h=40, "trunc_pyramids", tex_size=[5,5], tscale=1, style="convex");
-//   vnf_polyhedron(vnf, convexity=10);
-function textured_linear_sweep(
-    path, texture,
-    tex_size=[5,5], h, counts,
-    inset=false, rot=false, tscale=1,
-    caps=true, col_wrap=true,
-    twist, scale, shift,
-    style="min_edge", reverse=false, l,
+//   n = The general number of vertices to use to refine the resolution of the texture.
+//   inset = The amount to inset part of a VNF tile texture.  Generally between 0 and 0.5.
+//   gap = The gap between logically distinct parts of a VNF tile.  (ie: gap between bricks, gap between truncated ribs, etc.)
+//   roughness = The amount of roughness used on the surface of some heightfield textures.  Generally between 0 and 0.5.
+// See Also: heightfield(), cylindrical_heightfield(), texture()
+// Example(3D): **"bricks"** (Heightfield) = A brick-wall pattern.  Giving `n=` sets the number of heightfield samples to `n x n`.  Default: 24.  Giving `roughness=` adds a level of height randomization to add roughness to the texture.  Default: 0.05.  Use `style="convex"`.
+//   tex = texture("bricks");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"bricks_vnf"** (VNF) = VNF version of "bricks".  Giving `gap=` sets the "mortar" gap between adjacent bricks, default 0.05.  Giving `inset=` specifies that the top face of the brick is smaller than the bottom of the brick by `inset` on each of the four sides.  If `gap` is zero then an `inset` value close to 0.5 will cause bricks to come to a sharp pointed edge, with just a tiny flat top surface.  Note that `gap+inset` must be strictly smaller than 0.5.   Default is `inset=0.05`.  
+//   tex = texture("bricks_vnf");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "bricks_vnf" texture with large inset. 
+//   tex = texture("bricks_vnf",inset=0.25);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D,VPR=[84.4,0,4.7],VPT=[2.44496,6.53317,14.6135],VPD = 126): **"checkers"** (VNF) = A pattern of alternating checkerboard squares.  Giving `inset=` specifies that the top face of the checker surface is smaller than the bottom by `inset` on each of the four sides.  As `inset` approaches 0.5 the tops come to sharp corners.  You must set `inset` strictly between 0 and 0.5.  Default: 0.05.
+//   tex = texture("checkers");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D,VPR=[84.4,0,4.7],VPT=[2.44496,6.53317,14.6135],VPD = 126): "checkers" texture with large inset.  
+//   tex = texture("checkers",inset=0.25);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"cones"** (VNF) = Raised conical spikes.  Giving `n=` sets `$fn` for the cone (will be rounded to a multiple of 4).  Default: 16.  Giving `inset=` specifies the horizontal inset of the base of the cone, relative to the tile edges.  The `inset` value must be nonnegative and smaller than 0.5.  Default: 0.
+//   tex = texture("cones");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30, tex_scale=3,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"cubes"** (VNF) = Corner-cubes texture.  This texture needs to be scaled in vertically by sqrt(3) to have its correct aspect
+//   tex = texture("cubes");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "cubes" texture at the correct scale.  
+//   tex = texture("cubes");
+//   linear_sweep(
+//       rect(30), texture=tex, h=20*sqrt(3), tex_scale=3,
+//       tex_size=[10,10*sqrt(3)]
+//   );
+// Example(3D): **"diamonds"** (Heightfield) = Four-sided pyramid with the corners of the base aligned with the axes.  Compare to "pyramids".  Useful for knurling.  Giving `n=` sets the number of heightfield samples to `n x n`. Default: 2.  Use `style="concave"` for pointed bumps, or `style="default"` or `style="alt"` for a diagonal ribs.  
+//   tex = texture("diamonds");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="concave"
+//   );
+// Example(3D): "diamonds" texture can give diagonal ribbing with "default" style. 
+//   tex = texture("diamonds");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="default"
+//   );
+// Example(3D): "diamonds" texture gives diagonal ribbing the other direction with "alt" style.  
+//   tex = texture("diamonds");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="alt"
+//   );
+// Example(3D): **"diamonds_vnf"** (VNF) = VNF version of "diamonds".
+//   tex = texture("diamonds_vnf");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"dimples"** (VNF) = Round divots.  Giving `n=` sets `$fn` for the curve (will be rounded to a multiple of 4).  Default: 16.  Giving `inset=` specifies the horizontal distance of the flat region around the dimple relative to the edge of the tile.  Must be nonnegative and strictly less than 0.5.  Default: 0.05.  
+//   tex = texture("dimples");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30, 
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"dots"** (VNF) = Raised round bumps.  Giving `n=` sets `$fn` for the curve (will be rounded to a multiple of 4).  Default: 16.   Giving `inset=` specifies the horizontal inset of the dots, relative to the edge of the tile.  Must be nonnegative and strictly less than 0.5.  Default: 0.05.
+//   tex = texture("dots");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"hex_grid"** (VNF) = A hexagonal grid defined by V-grove borders.  Giving `inset=` specifies the horizontal inset of the left and right edges of the hexagonal tops, relative to their bottoms.  This means the V-groove top width for grooves running parallel to the Y axis will be double the inset value.  If the texture is scaled in the Y direction by sqrt(3) then the groove will be uniform on all six sides of the hexagon.  Inset must be strictly between 0 and 0.5, default: 0.1.
+//   tex = texture("hex_grid");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "hex_grid" texture with large inset
+//   tex = texture("hex_grid", inset=0.4);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "hex_grid" scaled in Y by sqrt(3) so hexagons are regular and grooves are all the same width.  Note height of cube is also scaled so tile fits without being automatically adjusted to fit, ruining our choice of scale.
+//   tex = texture("hex_grid",inset=.07);
+//   linear_sweep(
+//       rect(30), texture=tex, h=quantup(30,10*sqrt(3)),
+//       tex_size=[10,10*sqrt(3)], tex_scale=3
+//   );
+// Example(3D): "hex_grid" texture, with approximate scaling because 17 is close to sqrt(3) times 10.
+//   tex = texture("hex_grid");
+//   linear_sweep(
+//       rect(30), texture=tex, h=34,
+//       tex_size=[10,17]
+//   );
+// Example(3D): **"hills"** (Heightfield) = Wavy sine-wave hills and valleys,  Giving `n=` sets the number of heightfield samples to `n` x `n`.  Default: 12.  Set `style="quincunx"`.
+//   tex = texture("hills");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="quincunx"
+//   );
+// Example(3D): **"pyramids"** (Heightfield) = Four-sided pyramid with the edges of the base aligned with the axess.  Compare to "diamonds". Useful for knurling.  Giving `n=` sets the number of heightfield samples to `n` by `n`. Default: 2. Set style to "convex".  Note that style="concave" or style="min_edge" produce mini-diamonds with flat squares in between.
+//   tex = texture("pyramids");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="convex"
+//   );
+// Example(3D): "pyramids" texture, with "concave" produces a mini-diamond texture.  Note that "min_edge" also gives this result.
+//   tex = texture("pyramids");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="concave"
+//   );
+// Example(3D): **"pyramids_vnf"** (VNF) = VNF version of "pyramids".
+//   tex = texture("pyramids_vnf");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"ribs"** (Heightfield) = Vertically aligned triangular ribs.  Giving `n=` sets the number of heightfield samples to `n` by 1.  Default: 2.  The choice of style does not matter.
+//   tex = texture("ribs");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30, tex_scale=3,
+//       tex_size=[10,10], style="concave"
+//   );
+// Example(3D): **"rough"** (Heightfield) = A pseudo-randomized rough texture.  Giving `n=` sets the number of heightfield samples to `n` by `n`.  Default: 32.  The `roughness=` parameter specifies the height of the random texture.  Default: 0.2.
+//   tex = texture("rough");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="min_edge"
+//   );
+// Example(3D): **"tri_grid"** (VNF) = A triangular grid defined by V-groove borders  Giving `inset=` specifies the horizontal inset of the triangular tops, relative to their bottoms, along the horizontal edges (parallel to the X axis) of the triangles.  This means the V-groove top width of the grooves parallel to the X axis will be double the inset value.  (The other grooves are wider.) If the tile is scaled in the Y direction by sqrt(3) then the groove will be uniform on the three sides of the triangle.  The inset must be strictly between 0 and 1/6, default: 0.05.
+//   tex = texture("tri_grid");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "tri_grid" texture with large inset.  (Max inset for tri_grid is 1/6.)  
+//   tex = texture("tri_grid",inset=.12);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "tri_grid" texture scaled in Y by sqrt(3) so triangles are equilateral and grooves are all the same width.  Note we have to ensure the height evenly fits the scaled texture tiles.
+//   tex = texture("tri_grid",inset=.04);
+//   linear_sweep(
+//       rect(30), texture=tex, h=quantup(30,10*sqrt(3)),
+//       tex_size=[10,10*sqrt(3)], tex_scale=3
+//   );
+// Example(3D): "tri_grid" texture.  Here scale makes Y approximately sqrt(3) larger than X so triangles are close to equilateral.
+//   tex = texture("tri_grid");
+//   linear_sweep(
+//       rect(30), texture=tex, h=34,
+//       tex_size=[10,17]
+//   );
+// Example(3D): **"trunc_diamonds"** (VNF) = Truncated diamonds, four-sided pyramids with the base corners aligned with the axes and the top cut off.  Or you can interpret it as V-groove lines at 45º angles.  Giving `inset=` specifies the horizontal inset of the square top face compared to the bottom face along all four edges.  This means the V-groove top width will be double the inset value.  The inset must be strictly between 0 and sqrt(2)/4, which is about 0.35.  Default: 0.1.
+//   tex = texture("trunc_diamonds");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "trunc_diamonds" texture with large inset. 
+//   tex = texture("trunc_diamonds",inset=.25);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"trunc_pyramids"** (Heightfield) = Truncated pyramids, four sided pyramids with the base edges aligned to the axes and the top cut off.  Giving `n=` sets the number of heightfield samples to `n` by `n`.  Default: 6.  Set `style="convex"`.
+//   tex = texture("trunc_pyramids");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10], style="convex"
+//   );
+// Example(3D): **"trunc_pyramids_vnf"** (VNF) = Truncated pyramids, four sided pyramids with the base edges aligned to the axes and the top cut off.  You can also regard this as a grid of V-grooves.  Giving `inset=` specifies the horizontal inset of the flat square tops on all four sides relative to their bottoms.  This means the V-groove top width will be double the inset value.  The inset must be strictly between 0 and 0.5.  Default: 0.1.
+//   tex = texture("trunc_pyramids_vnf");
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): "trunc_pyramids_vnf" texture with large inset
+//   tex = texture("trunc_pyramids_vnf", inset=.4);
+//   linear_sweep(
+//       rect(30), texture=tex, h=30,
+//       tex_size=[10,10]
+//   );
+// Example(3D): **"trunc_ribs"** (Heightfield) = Truncated ribs.  Vertically aligned triangular ribs with the tops cut off, and with rib separation equal to the width of the flat tops.  Giving `n=` sets the number of heightfield samples to `n` by `1`.  Default: 4.  The style does not matter.
+//   tex = texture("trunc_ribs");
+//   linear_sweep(
+//       rect(30), h=30, texture=tex,
+//       tex_scale=3, tex_size=[10,10],
+//       style="concave"
+//   );
+// Example(3D): **"trunc_ribs_vnf"** (VNF) = Vertically aligned triangular ribs with the tops cut off.  Giving `gap=` sets the bottom gap between ribs.  Giving `inset=` specifies the horizontal inset of the rib top face, relative to the bottom on both sides.  In order to fit, gap+2*inset must be less than 1.  (This is because the gap is counted once but the inset counts on both sides.)  Defaults: gap=1/4, inset=1/4.
+//   tex = texture("trunc_ribs_vnf", gap=0.25, inset=1/6);
+//   linear_sweep(
+//       rect(30), h=30, texture=tex,
+//       tex_scale=3, tex_size=[10,10]
+//   );
+// Example(3D): **"wave_ribs"** (Heightfield) = Vertically aligned wavy ribs.  Giving `n=` sets the number of heightfield samples to `n` by `1`.  Default: 8.  The style does not matter.  
+//   tex = texture("wave_ribs");
+//   linear_sweep(
+//       rect(30), h=30, texture=tex, 
+//       tex_size=[10,10], tex_scale=3, style="concave"
+//   );
+
+function texture(tex, n, inset, gap, roughness) =
+    assert(is_undef(n) || all_positive([n]), "n must be a positive value if given")
+    assert(is_undef(inset) || is_finite(inset), "inset must be a number if given")
+    assert(is_undef(gap) || is_finite(gap), "gap must be a number if given")
+    assert(is_undef(roughness) || all_nonnegative([roughness]), "roughness must be a nonnegative value if given")  
+    tex=="ribs"?
+        assert(num_defined([gap, inset, roughness])==0, "ribs texture does not accept gap, inset or roughness")
+
+        let(
+            n = quantup(default(n,2),2)
+        ) [[
+            each lerpn(1,0,n/2,endpoint=false),
+            each lerpn(0,1,n/2,endpoint=false),
+        ]] :
+    tex=="trunc_ribs"?
+        assert(num_defined([gap, inset, roughness])==0, "trunc_ribs texture does not accept gap, inset or roughness")
+        let(
+            n = quantup(default(n,4),4)
+        ) [[
+            each repeat(0,n/4),
+            each lerpn(0,1,n/4,endpoint=false),
+            each repeat(1,n/4),
+            each lerpn(1,0,n/4,endpoint=false),
+        ]] :
+    tex=="trunc_ribs_vnf"?
+        assert(is_undef(n), "trunc_ribs_vnf texture does not accept n")
+        let(
+            inset = default(inset,1/4)*2,
+            gap = default(gap,1/4)
+        )
+        assert(all_nonnegative([inset,gap]), "trunc_ribs_vnf texture requires gap>=0 and inset>=0")
+        assert(gap+inset > 0, "trunc_ribs_vnf texture requires that gap+inset>0")
+        assert(gap+inset <= 1, "trunc_ribs_vnf texture requires that gap+2*inset<=1")
+        [
+            [
+               each move([0.5,0.5], p=path3d(rect([1-gap,1]),0)),
+               each move([0.5,0.5], p=path3d(rect([1-gap-inset,1]),1)),
+               each path3d(square(1)),
+            ], [
+                [1,2,6], [1,6,5], [0,4,3], [3,4,7],
+                if (gap+inset < 1-EPSILON) each [[4,5,6], [4,6,7]],
+                if (gap > EPSILON) each [[1,9,10], [1,10,2], [0,3,8], [3,11,8]],
+            ]
+        ] :
+    tex=="wave_ribs"?
+        assert(num_defined([gap, inset, roughness])==0, "wave_ribs texture does not accept gap, inset or roughness")  
+        let(
+            n = max(6,default(n,8))
+        ) [[
+            for(a=[0:360/n:360-EPSILON])
+            (cos(a)+1)/2
+        ]] :
+    tex=="diamonds"?
+        assert(num_defined([gap, inset, roughness])==0, "diamonds texture does not accept gap, inset or roughness")  
+        let(
+            n = quantup(default(n,2),2)
+        ) [
+            let(
+                path = [
+                    each lerpn(0,1,n/2,endpoint=false),
+                    each lerpn(1,0,n/2,endpoint=false),
+                ]
+            )
+            for (i=[0:1:n-1]) [
+                for (j=[0:1:n-1]) min(
+                    select(path,i+j),
+                    select(path,i-j)
+                )
+            ],
+        ] :
+    tex=="diamonds_vnf"?
+        assert(num_defined([n,gap, inset, roughness])==0, "diamonds_vnf texture does not accept n, gap, inset or roughness")
+        [
+            [
+                [0,   1, 1], [1/2,   1, 0], [1,   1, 1],
+                [0, 1/2, 0], [1/2, 1/2, 1], [1, 1/2, 0],
+                [0,   0, 1], [1/2,   0, 0], [1,   0, 1],
+            ], [
+                [0,1,3], [2,5,1], [8,7,5], [6,3,7],
+                [1,5,4], [5,7,4], [7,3,4], [4,3,1],
+            ]
+        ] :
+    tex=="pyramids"?
+        assert(num_defined([gap, inset, roughness])==0, "pyramids texture does not accept gap, inset or roughness")
+        let(
+            n = quantup(default(n,2),2)
+        ) [
+            for (i = [0:1:n-1]) [
+                for (j = [0:1:n-1])
+                1 - (max(abs(i-n/2), abs(j-n/2)) / (n/2))
+            ]
+        ] :
+    tex=="pyramids_vnf"?
+        assert(num_defined([n,gap, inset, roughness])==0, "pyramids_Vnf texture does not accept n, gap, inset or roughness")  
+        [
+            [ [0,1,0], [1,1,0], [1/2,1/2,1], [0,0,0], [1,0,0] ],
+            [ [2,0,1], [2,1,4], [2,4,3], [2,3,0] ]
+        ] :
+    tex=="trunc_pyramids"?
+        assert(num_defined([gap, inset, roughness])==0, "trunc_pyramids texture does not accept gap, inset or roughness")  
+        let(
+            n = quantup(default(n,6),3)
+        ) [
+            for (i = [0:1:n-1]) [
+                for (j = [0:1:n-1])
+                (1 - (max(n/6, abs(i-n/2), abs(j-n/2)) / (n/2))) * 1.5
+            ]
+        ] :
+    tex=="trunc_pyramids_vnf"?
+        assert(num_defined([gap, n, roughness])==0, "trunc_pyramids_vnf texture does not accept gap, n or roughness")
+        let(
+            inset = default(inset,0.1)
+        )
+        assert(inset>0 && inset<.5, "trunc_pyramids_vnf texture requires inset in (0,0.5)")
+        [
+            [
+                each path3d(square(1)),
+                each move([1/2,1/2,1], p=path3d(rect(1-2*inset))),
+            ], [
+                for (i=[0:3]) each [
+                    [i, (i+1)%4, i+4],
+                    [(i+1)%4, (i+1)%4+4, i+4],
+                ],
+                [4,5,6], [4,6,7],
+            ]
+        ] :
+    tex=="hills"?
+        assert(num_defined([gap, inset, roughness])==0, "hills texture does not accept gap, inset or roughness")  
+        let(
+            n = default(n,12)
+        ) [
+            for (a=[0:360/n:359.999]) [
+                for (b=[0:360/n:359.999])
+                (cos(a)*cos(b)+1)/2
+            ]
+        ] :
+    tex=="bricks"?
+        assert(num_defined([gap,inset])==0, "bricks texture does not accept gap or inset")  
+        let(
+            n = quantup(default(n,24),2),
+            rough = default(roughness,0.05)
+        ) [
+            for (y = [0:1:n-1])
+            rands(-rough/2, rough/2, n, seed=12345+y*678) + [
+                for (x = [0:1:n-1])
+                (y%(n/2) <= max(1,n/16))? 0 :
+                let( even = floor(y/(n/2))%2? n/2 : 0 )
+                (x+even) % n <= max(1,n/16)? 0 : 0.5
+            ]
+        ] :
+    tex=="bricks_vnf"?
+        assert(num_defined([n,roughness])==0, "bricks_vnf texture does not accept n or roughness")
+        let(
+            inset = default(inset,0.05),
+            gap = default(gap,0.05)
+        )
+        assert(inset>=0,"bricks_vnf texture requires nonnegative inset")
+        assert(gap>0, "bricks_vnf requires gap greater than 0")
+        assert(gap+inset<0.5, "bricks_vnf requires gap+inset<0.5")
+          [
+            [
+                each path3d(square(1)),
+                each move([gap/2, gap/2, 0], p=path3d(square([1-gap, 0.5-gap]))),
+                each move([gap/2+inset/2, gap/2+inset/2, 1], p=path3d(square([1-gap-inset, 0.5-gap-inset]))),
+                each move([0, 0.5+gap/2, 0], p=path3d(square([0.5-gap/2, 0.5-gap]))),
+                each move([0, 0.5+gap/2+inset/2, 1], p=path3d(square([0.5-gap/2-inset/2, 0.5-gap-inset]))),
+                each move([0.5+gap/2, 0.5+gap/2, 0], p=path3d(square([0.5-gap/2, 0.5-gap]))),
+                each move([0.5+gap/2+inset/2, 0.5+gap/2+inset/2, 1], p=path3d(square([0.5-gap/2-inset/2, 0.5-gap-inset]))),
+            ], [
+                [ 8, 9,10], [ 8,10,11], [16,17,18], [16,18,19], [24,25,26],
+                [24,26,27], [ 0, 1, 5], [ 0, 5, 4], [ 1,13, 6], [ 1, 6, 5],
+                [ 6,13,12], [ 6,12,21], [ 7,21,20], [ 6,21, 7], [ 0, 4, 7],
+                [ 0, 7,20], [21,12,15], [21,15,22], [ 3,23,22], [ 3,22,15],
+                [ 2,15,14], [ 2, 3,15], [23,27,26], [23,26,22], [21,22,26],
+                [21,26,25], [21,25,24], [21,24,20], [12,16,19], [12,19,15],
+                [14,15,19], [14,19,18], [13,17,16], [13,16,12], [ 6,10, 9],
+                [ 6, 9, 5], [ 5, 9, 8], [ 5, 8, 4], [ 4, 8,11], [ 4,11, 7],
+                [ 7,11,10], [ 7,10, 6],
+            ]
+        ] :
+    tex=="checkers"?
+        assert(num_defined([gap, n, roughness])==0, "checkers texture does not accept gap, n or roughness")
+        let(
+            inset = default(inset,0.05)
+        )
+        assert(inset>0 && inset<.5, "checkers texture requires inset in (0,0.5)")
+          [
+            [
+                each move([0,0], p=path3d(square(0.5-inset),1)),
+                each move([0,0.5], p=path3d(square(0.5-inset))),
+                each move([0.5,0], p=path3d(square(0.5-inset))),
+                each move([0.5,0.5], p=path3d(square(0.5-inset),1)),
+                [1/2-inset/2,1/2-inset/2,1/2], [0,1,1], [1/2-inset,1,1],
+                [1/2,1,0], [1-inset,1,0], [1,0,1], [1,1/2-inset,1],
+                [1,1/2,0], [1,1-inset,0], [1,1,1], [1/2-inset/2,1-inset/2,1/2],
+                [1-inset/2,1-inset/2,1/2], [1-inset/2,1/2-inset/2,1/2],
+            ], [
+                for (i=[0:4:12]) each [[i,i+1,i+2], [i, i+2, i+3]],
+                [10,13,11], [13,12,11], [2,5,4], [4,3,2],
+                [0,3,10], [10,9,0], [4,7,14], [4,14,13],
+                [4,13,16], [10,16,13], [10,3,16], [3,4,16],
+                [7,6,17], [7,17,18], [14,19,20], [14,20,15],
+                [8,11,22], [8,22,21], [12,15,24], [12,24,23],
+                [7,18,26], [7,26,14], [14,26,19], [18,19,26],
+                [15,20,27], [20,25,27], [24,27,25], [15,27,24],
+                [11,12,28], [12,23,28], [11,28,22], [23,22,28],
+            ]
+        ] :
+    tex=="cones"?
+        assert(num_defined([gap,roughness])==0, "cones texture does not accept gap or roughness")  
+        let(
+            n = quant(default(n,16),4),
+            inset = default(inset,0)
+        )
+        assert(inset>=0 && inset<0.5)
+        [
+            [
+                each move([1/2,1/2], p=path3d(circle(d=1-2*inset,$fn=n))),
+                [1/2,1/2,1],
+                each path3d(square(1)),
+            ], [
+                for (i=[0:1:n-1]) [i, (i+1)%n, n],
+                for (i=[0:1:3], j=[0:1:n/4-1]) [n+1+i, (i*n/4+j+1)%n, i*n/4+j],
+                if (inset > 0) for (i = [0:1:3]) [i+n+1, (i+1)%4+n+1, ((i+1)*n/4)%n],
+            ]
+        ] :
+    tex=="cubes"?
+        assert(num_defined([n, gap, inset, roughness])==0, "cubes texture does not accept n, gap, inset or roughness")  
+        [
+            [
+                [0,1,1/2], [1,1,1/2], [1/2,5/6,1], [0,4/6,0], [1,4/6,0],
+                [1/2,3/6,1/2], [0,2/6,1], [1,2/6,1], [1/2,1/6,0], [0,0,1/2],
+                [1,0,1/2],
+            ], [
+                [0,1,2], [0,2,3], [1,4,2], [2,5,3], [2,4,5],
+                [6,3,5], [4,7,5], [7,8,5], [6,5,8], [10,8,7],
+                [9,6,8], [10,9,8],
+            ]
+        ] :
+    tex=="trunc_diamonds"?
+        assert(num_defined([gap, n, roughness])==0, "trunc_diamonds texture does not accept gap, n or roughness")
+        let(
+            inset = default(inset,0.1)/sqrt(2)*2
+        )
+        assert(inset>0 && inset<0.5)
+        [
+            [
+                each move([1/2,1/2,0], p=path3d(circle(d=1,$fn=4))),
+                each move([1/2,1/2,1], p=path3d(circle(d=1-inset*2,$fn=4))),
+                for (a=[0:90:359]) each move([1/2,1/2], p=zrot(-a, p=[[1/2,inset,1], [inset,1/2,1], [1/2,1/2,1]]))
+            ], [
+                for (i=[0:3]) each let(j=i*3+8) [
+                    [i,(i+1)%4,(i+1)%4+4], [i,(i+1)%4+4,i+4],
+                    [j,j+1,j+2], [i, (i+3)%4, j], [(i+3)%4, j+1, j],
+                ],
+                [4,5,6], [4,6,7],
+            ]
+        ] :
+    tex=="dimples" || tex=="dots" ?
+        assert(num_defined([gap,roughness])==0, str(tex," texture does not accept gap or roughness"))
+        let(
+            n = quant(default(n,16),4),
+            inset = default(inset,0.05)
+        )
+        assert(inset>=0 && inset < 0.5)
+        let(
+            rows=ceil(n/4),
+            r=adj_ang_to_hyp(1/2-inset,45),
+            dots = tex=="dots",
+            cp = [1/2, 1/2, r*sin(45)*(dots?-1:1)],
+            sc = 1 / (r - abs(cp.z)),
+            uverts = [
+                each path3d(square(1)),
+                for (p=[0:1:rows-1], t=[0:360/n:359.999])
+                    cp + (
+                        dots? spherical_to_xyz(r, -t, 45-45*p/rows) :
+                        spherical_to_xyz(r, -t, 135+45*p/rows)
+                    ),
+                cp + r * (dots?UP:DOWN),
+            ],
+            verts = zscale(sc, p=uverts),
+            faces = [
+                for (i=[0:1:3], j=[0:1:n/4-1]) [i, 4+(i*n/4+j+1)%n, 4+i*n/4+j],
+                for (i=[0:1:rows-2], j=[0:1:n-1]) each [
+                    [4+i*n+j, 4+(i+1)*n+(j+1)%n, 4+(i+1)*n+j],
+                    [4+i*n+j, 4+i*n+(j+1)%n, 4+(i+1)*n+(j+1)%n],
+                ],
+                for (i=[0:1:n-1]) [4+(rows-1)*n+i, 4+(rows-1)*n+(i+1)%n, 4+rows*n],
+                if (inset>0) for (i=[0:3]) [i, (i+1)%4, 4+(i+1)%4*n/4]
+            ]
+        ) [verts, faces] :
+    tex=="tri_grid"?
+        assert(num_defined([gap, n, roughness])==0, str(tex," texture does not accept gap, n or roughness"))  
+        let(
+            inset = default(inset,0.05)*sqrt(3)
+        )
+        assert(inset>0 && inset<sqrt(3)/6, "tri_grid texture requires inset in (0,1/6)")
+        let(
+            adj = opp_ang_to_adj(inset, 30),
+            y1 = inset / adj_ang_to_opp(1,60),     // i/sqrt(3)
+            y2 = 2*y1,            // 2*i/sqrt(3)
+            y3 = 0.5 - y1,
+            y4 = 0.5 + y1,
+            y5 = 1 - y2,
+            y6 = 1 - y1
+        )
+        [
+            [
+                [0,0,0], [1,0,0],
+                [adj,y1,1], [1-adj,y1,1],
+                [0,y2,1], [1,y2,1],
+                [0.5,0.5-y2,1],
+                [0,y3,1], [0.5-adj,y3,1], [0.5+adj,y3,1], [1,y3,1],
+                [0,0.5,0], [0.5,0.5,0], [1,0.5,0],
+                [0,y4,1], [0.5-adj,y4,1], [0.5+adj,y4,1], [1,y4,1],
+                [0.5,0.5+y2,1],
+                [0,y5,1], [1,y5,1],
+                [adj,y6,1], [1-adj,y6,1],
+                [0,1,0], [1,1,0],
+            ], [
+               [0,2,3], [0,3,1], [2,6,3], [0,12,2], [2,12,6], [3,6,12], [3,12,1],
+               [0,4,8], [0,8,12], [4,7,8], [7,11,12], [7,12,8],
+               [1,12,9], [1,9,5], [5,9,10], [9,12,13], [9,13,10],
+               [11,14,15], [11,15,12], [19,15,14], [19,23,12], [19,12,15],
+               [12,16,13], [16,17,13], [16,20,17], [12,24,20], [12,20,16],
+               [21,22,18], [21,23,24], [21,24,22], [12,23,21], [12,21,18],
+               [12,18,22], [12,22,24],
+            ]
+        ] :
+    tex=="hex_grid"?
+        assert(num_defined([gap, n, roughness])==0, str(tex," texture does not accept gap, n or roughness"))
+        let(
+            inset=default(inset,0.1)
+        )
+        assert(inset>0 && inset<0.5)
+        let(
+            diag=opp_ang_to_hyp(inset,60),
+            side=adj_ang_to_opp(1,30),
+            hyp=adj_ang_to_hyp(0.5,30),
+            sc = 1/3/hyp,
+            hex=[ [1,2/6,0], [1/2,1/6,0], [0,2/6,0], [0,4/6,0], [1/2,5/6,0], [1,4/6,0] ]
+        ) [
+            [
+                each hex,
+                each move([0.5,0.5], p=yscale(sc, p=path3d(ellipse(d=1-2*inset, circum=true, spin=-30,$fn=6),1))),
+                hex[0]-[0,diag*sc,-1],
+                for (ang=[270+60,270-60]) hex[1]+yscale(sc, p=cylindrical_to_xyz(diag,ang,1)),
+                hex[2]-[0,diag*sc,-1],
+                [0,0,1], [0.5-inset,0,1], [0.5,0,0], [0.5+inset,0,1], [1,0,1],
+                hex[3]+[0,diag*sc,1],
+                for (ang=[90+60,90-60]) hex[4]+yscale(sc, p=cylindrical_to_xyz(diag,ang,1)),
+                hex[5]+[0,diag*sc,1],
+                [0,1,1], [0.5-inset,1,1], [0.5,1,0], [0.5+inset,1,1], [1,1,1],
+            ], [
+                for (i=[0:2:5]) let(b=6) [b+i, b+(i+1)%6, b+(i+2)%6], [6,8,10],
+                for (i=[0:1:5]) each [ [i, (i+1)%6, (i+1)%6+6], [i, (i+1)%6+6, i+6] ],
+                [19,13,12], [19,12,20], [17,16,15], [17,15,14],
+                [21,25,26], [21,26,22], [23,28,29], [23,29,24],
+                [0,12,13], [0,13,1], [1,14,15], [1,15,2],
+                [3,21,22], [3,22,4], [4,23,24], [4,24,5],
+                [1,13,19], [1,19,18], [1,18,17], [1,17,14],
+                [4,22,26], [4,26,27], [4,27,28], [4,28,23],
+            ]
+        ] :
+    tex=="rough"?
+        assert(num_defined([gap,inset])==0, str(tex," texture does not accept gap or inset"))
+        let(
+            n = default(n,32),
+            rough = default(roughness, 0.2)
+        ) [
+            for (y = [0:1:n-1])
+            rands(0, rough, n, seed=123456+29*y)
+        ] :
+    assert(false, str("Unrecognized texture name: ", tex));
+
+
+/// Function&Module: _textured_linear_sweep()
+/// Usage: As Function
+///   vnf = _textured_linear_sweep(region, texture, tex_size, h, ...);
+///   vnf = _textured_linear_sweep(region, texture, counts=, h=, ...);
+/// Usage: As Module
+///   _textured_linear_sweep(region, texture, tex_size, h, ...) [ATTACHMENTS];
+///   _textured_linear_sweep(region, texture, counts=, h=, ...) [ATTACHMENTS];
+/// Topics: Sweep, Extrusion, Textures, Knurling
+/// Description:
+///   Given a [[Region|regions.scad]], creates a linear extrusion of it vertically, optionally twisted, scaled, and/or shifted,
+///   with a given texture tiled evenly over the side surfaces.  The texture can be given in one of three ways:
+///   - As a texture name string. (See {{texture()}} for supported named textures.)
+///   - As a 2D array of evenly spread height values. (AKA a heightfield.)
+///   - As a VNF texture tile.  A VNF tile exactly defines a surface from `[0,0]` to `[1,1]`, with the Z coordinates
+///     being the height of the texture point from the surface.  VNF tiles MUST be able to tile in both X and Y
+///     directions with no gaps, with the front and back edges aligned exactly, and the left and right edges as well.
+///   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:
+///   https://raw.githubusercontent.com/revarbat/BOSL2/master/scripts/img2scad.py
+/// Arguments:
+///   region = The [[Region|regions.scad]] to sweep/extrude.
+///   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.
+///   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
+///   h / l = The height to extrude/sweep the path.
+///   ---
+///   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
+///   inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
+///   rot = If true, rotates the texture 90º.
+///   tex_scale = Scaling multiplier for the texture depth.
+///   twist = Degrees of twist for the top of the extrustion/sweep, compared to the bottom.  Default: 0
+///   scale = Scaling multiplier for the top of the extrustion/sweep, compared to the bottom.  Default: 1
+///   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]
+///   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Used only with heightfield type textures. Default: `"min_edge"`
+///   samples = Minimum number of "bend points" to have in VNF texture tiles.  Default: 8
+///   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+/// Extra Anchors:
+///   centroid_top = The centroid of the top of the shape, oriented UP.
+///   centroid = The centroid of the center of the shape, oriented UP.
+///   centroid_bot = The centroid of the bottom of the shape, oriented DOWN.
+/// See Also: heightfield(), cylindrical_heightfield(), texture()
+
+function _get_vnf_tile_edges(texture) =
+    let(
+        verts = texture[0],
+        faces = texture[1],
+        everts = [for (v = verts) (v.x==0 || v.y==0 || v.x==1 || v.y==1)],
+        uc = unique_count([
+            for (face = faces, i = idx(face))
+            let(edge = select(face,i,i+1), i1 = min(edge), i2 = max(edge))
+            if (everts[i1] && everts[i2])
+            [i1, i2]
+        ]),
+        edges = uc[0], counts = uc[1],
+        uedges = [for (i = idx(edges)) if (counts[i] == 1) edges[i] ]
+    ) uedges;
+
+
+function _validate_texture(texture) =
+    is_vnf(texture)
+      ? let( // Validate VNF tile texture
+            bounds = pointlist_bounds(texture[0]),
+            min_xy = point2d(bounds[0]),
+            max_xy = point2d(bounds[1])
+        )
+        //assert(min_xy==[0,0] && max_xy==[1,1],"VNF tiles must span exactly from [0,0] to [1,1] in the X and Y components."))
+        assert(all_nonnegative(concat(min_xy,[1,1]-max_xy)), "VNF tile X and Y components must be between 0 and 1.")
+        let(
+            verts = texture[0],
+            uedges = _get_vnf_tile_edges(texture),
+            edge_verts = [for (i = unique(flatten(uedges))) verts[i] ],
+            hverts = [for(v = edge_verts) if(v.x==0 || v.x==1) v],
+            vverts = [for(v = edge_verts) if(v.y==0 || v.y==1) v],
+            allgoodx = all(hverts, function(v) any(hverts, function(w) approx(w,[1-v.x, v.y, v.z]))),
+            allgoody = all(vverts, function(v) any(vverts, function(w) approx(w,[v.x, 1-v.y, v.z])))
+        )
+        assert(allgoodx && allgoody, "All VNF tile edge vertices must line up with a vertex on the opposite side of the tile.")
+        true
+      : // Validate heightfield texture.
+        assert(is_matrix(texture), "Malformed texture.")
+        let( tex_dim = list_shape(texture) )
+        assert(len(tex_dim) == 2, "Heightfield texture must be a 2D square array of scalar heights.")
+        assert(all_defined(tex_dim), "Heightfield texture must be a 2D square array of scalar heights.")
+        true;
+
+
+function _textured_linear_sweep(
+    region, texture, tex_size=[5,5],
+    h, counts, inset=false, rot=false,
+    tex_scale=1, twist, scale, shift,
+    style="min_edge", l, caps=true, 
+    height, length, samples,
     anchor=CENTER, spin=0, orient=UP
 ) =
-    assert(is_path(path,[2]))
-    assert(is_bool(caps))
-    assert(is_bool(reverse))
+    assert(is_path(region,[2]) || is_region(region))
+    assert(is_undef(samples) || is_int(samples))
     assert(counts==undef || is_vector(counts,2))
     assert(tex_size==undef || is_vector(tex_size,2))
+    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))
+    assert(is_bool(caps) || is_bool_list(caps,2))
     let(
-        tex = is_string(texture)? _get_texture(texture) : texture,
-        texture = rot? transpose(tex) : tex,
+        caps = is_bool(caps) ? [caps,caps] : caps,
+        regions = is_path(region,2)? [[region]] : region_parts(region),
+        tex = is_string(texture)? texture(texture) : texture,
+        texture = !rot? tex :
+            is_vnf(tex)? zrot(is_num(rot)?rot:90, cp=[1/2,1/2], p=tex) :
+            rot==180? reverse([for (row=tex) reverse(row)]) :
+            rot==270? [for (row=transpose(tex)) reverse(row)] :
+            reverse(transpose(tex)),
+        h = first_defined([h, l, height, length, 1]),
+        inset = is_num(inset)? inset : inset? 1 : 0,
         twist = default(twist, 0),
         shift = default(shift, [0,0]),
-        scale = scale==undef? [1,1,1] : is_num(scale)? [scale,scale,1] : scale,
-        h = first_defined([h, l, 1]),
-        plen = path_length(path, closed=col_wrap),
-        counts = is_vector(counts,2)? counts :
-            is_vector(tex_size,2)
-              ? [round(plen/tex_size.x), max(1,round(h/tex_size.y)), ]
-              : [30, 5],
-        texcnt = [len(texture[0]), len(texture)],
-        inset = is_num(inset)? inset : inset? 1 : 0,
-        xcnt = counts.x * texcnt.x,
-        ycnt = counts.y * texcnt.y,
-        bases = resample_path(path, n=xcnt+(col_wrap?0:1), closed=col_wrap),
-        norms = path_normals(bases, closed=col_wrap),
-        tiles = [
-            for (i = [0:1:ycnt])
+        scale = scale==undef? [1,1,1] :
+            is_num(scale)? [scale,scale,1] : scale,
+        samples = !is_vnf(texture)? len(texture[0]) :
+            is_num(samples)? samples : 8,
+        check_tex = _validate_texture(texture),
+        sorted_tile =
+            !is_vnf(texture)? texture :
             let(
-                u = i / ycnt,
-                row = texture[i % texcnt.y],
-                levpts = [
-                    for (j = [0:1:xcnt-(col_wrap?1:0)])
+                s = 1 / max(1, samples),
+                vnf = samples<=1? texture :
                     let(
-                        texh = (row[j % texcnt.x] - inset) * tscale,
-                        xy = bases[j] - norms[j] * texh,
-                        xyz = point3d(xy, (i/ycnt-0.5)*h)
-                    ) xyz
-                ]
-            ) apply(move(shift*u) * scale(lerp([1,1,1],scale,u)) * zrot(twist*u), levpts)
-        ],
-        vnf = vnf_vertex_array(
-            tiles, caps=caps, style=style, reverse=reverse,
-            col_wrap=col_wrap, row_wrap=false
-        ),
-        cent = centroid(path),
+                        vnft = vnf_slice(texture, "X", list([s:s:1-s/2])),
+                        zvnf = [
+                            [
+                                for (p=vnft[0]) [
+                                    approx(p.x,0)? 0 : approx(p.x,1)? 1 : p.x,
+                                    approx(p.y,0)? 0 : approx(p.y,1)? 1 : p.y,
+                                    p.z
+                                ]
+                            ],
+                            vnft[1]
+                        ]
+                    ) zvnf
+            ) _vnf_sort_vertices(vnf, idx=[1,0]),
+        vertzs = !is_vnf(sorted_tile)? undef :
+            group_sort(sorted_tile[0], idx=1),
+        tpath = is_vnf(sorted_tile)
+            ? _find_vnf_tile_edge_path(sorted_tile,0)
+            : let(
+                  row = sorted_tile[0],
+                  rlen = len(row)
+              ) [for (i = [0:1:rlen]) [i/rlen, row[i%rlen]]],
+        tmat = scale(scale) * zrot(twist) * up(h/2),
+        pre_skew_vnf = vnf_join([
+            for (rgn = regions) let(
+                walls_vnf = vnf_join([
+                    for (path = rgn) let(
+                        path = reverse(path),
+                        plen = path_length(path, closed=true),
+                        counts = is_vector(counts,2)? counts :
+                            is_vector(tex_size,2)
+                              ? [round(plen/tex_size.x), max(1,round(h/tex_size.y)), ]
+                              : [ceil(6*plen/h), 6],
+                        obases = resample_path(path, n=counts.x * samples, closed=true),
+                        onorms = path_normals(obases, closed=true),
+                        bases = list_wrap(obases),
+                        norms = list_wrap(onorms),
+                        vnf = is_vnf(texture)
+                          ? let( // VNF tile texture
+                                row_vnf = vnf_join([
+                                    for (j = [0:1:counts.x-1]) [
+                                        [
+                                            for (group = vertzs)
+                                            each [
+                                                for (vert = group) let(
+                                                    u = floor((j + vert.x) * samples),
+                                                    uu = ((j + vert.x) * samples) - u,
+                                                    texh = (vert.z - inset) * tex_scale,
+                                                    base = lerp(bases[u], select(bases,u+1), uu),
+                                                    norm = unit(lerp(norms[u], select(norms,u+1), uu)),
+                                                    xy = base + norm * texh
+                                                ) point3d(xy,vert.y)
+                                            ]
+                                        ],
+                                        sorted_tile[1]
+                                    ]
+                                ]),
+                                sorted_row = _vnf_sort_vertices(row_vnf, idx=[1,0]),
+                                rvertzs = group_sort(sorted_row[0], idx=1),
+                                vnf1 = vnf_join([
+                                    for (i = [0:1:counts.y-1]) [
+                                        [
+                                            for (group = rvertzs) let(
+                                                v = (i + group[0].z) / counts.y,
+                                                sc = lerp([1,1,1], scale, v),
+                                                mat = scale(sc) *
+                                                    zrot(twist*v) *
+                                                    up(((i/counts.y)-0.5)*h) *
+                                                    zscale(h/counts.y)
+                                            ) each apply(mat, group)
+                                        ],
+                                        sorted_row[1]
+                                    ]
+                                ])
+                            ) vnf1
+                          : let( // Heightfield texture
+                                texcnt = [len(texture[0]), len(texture)],
+                                tile_rows = [
+                                    for (ti = [0:1:texcnt.y-1])
+                                    path3d([
+                                        for (j = [0:1:counts.x])
+                                        for (tj = [0:1:texcnt.x-1])
+                                        if (j != counts.x || tj == 0)
+                                        let(
+                                            part = (j + (tj/texcnt.x)) * samples,
+                                            u = floor(part),
+                                            uu = part - u,
+                                            texh = (texture[ti][tj] - inset) * tex_scale,
+                                            base = lerp(bases[u], select(bases,u+1), uu),
+                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),
+                                            xy = base + norm * texh
+                                        ) xy
+                                    ])
+                                ],
+                                tiles = [
+                                    for (i = [0:1:counts.y], ti = [0:1:texcnt.y-1])
+                                    if (i != counts.y || ti == 0)
+                                    let(
+                                        v = (i + (ti/texcnt.y)) / counts.y,
+                                        sc = lerp([1, 1, 1], scale, v),
+                                        mat = up((v-0.5)*h) *
+                                              scale(sc) *
+                                              zrot(twist*v)
+                                    ) apply(mat, tile_rows[ti])
+                                ]
+                            ) vnf_vertex_array(
+                                tiles, caps=false, style=style,
+                                col_wrap=true, row_wrap=false
+                            )
+                    ) vnf
+                ]),
+                brgn = [
+                    for (path = rgn) let(
+                        path = reverse(path),
+                        plen = path_length(path, closed=true),
+                        counts = is_vector(counts,2)? counts :
+                            is_vector(tex_size,2)
+                              ? [round(plen/tex_size.x), max(1,round(h/tex_size.y)), ]
+                              : [ceil(6*plen/h), 6],
+                        obases = resample_path(path, n=counts.x * samples, closed=true),
+                        onorms = path_normals(obases, closed=true),
+                        bases = list_wrap(obases),
+                        norms = list_wrap(onorms),
+                        nupath = [
+                            for (j = [0:1:counts.x-1], vert = tpath) let(
+                                part = (j + vert.x) * samples,
+                                u = floor(part),
+                                uu = part - u,
+                                texh = (vert.y - inset) * tex_scale,
+                                base = lerp(bases[u], select(bases,u+1), uu),
+                                norm = unit(lerp(norms[u], select(norms,u+1), uu)),
+                                xy = base + norm * texh
+                            ) xy
+                        ]
+                    ) nupath
+                ],
+                bot_vnf = !caps[0] || brgn==[[]] ? EMPTY_VNF:vnf_from_region(brgn, down(h/2), reverse=true),
+                top_vnf = !caps[1] || brgn==[[]] ? EMPTY_VNF:vnf_from_region(brgn, tmat, reverse=false)
+            ) vnf_join([walls_vnf, bot_vnf, top_vnf])
+        ]),
+        skmat = down(h/2) * skew(sxz=shift.x/h, syz=shift.y/h) * up(h/2),
+        final_vnf = apply(skmat, pre_skew_vnf),
+        cent = centroid(region),
         anchors = [
             named_anchor("centroid_top", point3d(cent, h/2), UP),
             named_anchor("centroid",     point3d(cent),      UP),
             named_anchor("centroid_bot", point3d(cent,-h/2), DOWN)
         ]
-    ) reorient(anchor,spin,orient, vnf=vnf, extent=true, anchors=anchors, p=vnf);
+    ) reorient(anchor,spin,orient, vnf=final_vnf, extent=true, anchors=anchors, p=final_vnf);
 
 
-module textured_linear_sweep(
-    path, texture, tex_size=[5,5], h,
-    inset=false, rot=false, tscale=1,
-    twist, scale, shift,
-    style="min_edge", reverse=false, l, counts,
-    anchor=CENTER, spin=0, orient=UP,
-    convexity=10
-) {
-    h = first_defined([h, l]);
-    vnf = textured_linear_sweep(
-        path, texture, h=h,
-        tex_size=tex_size, counts=counts,
-        inset=inset, rot=rot, tscale=tscale,
-        twist=twist, scale=scale, shift=shift,
-        caps=true, col_wrap=true,
-        style=style, reverse=reverse,
-        anchor=CENTER, spin=0, orient=UP
-    );
-    cent = centroid(path);
-    anchors = [
-        named_anchor("centroid_top", point3d(cent, h/2), UP),
-        named_anchor("centroid",     point3d(cent),      UP),
-        named_anchor("centroid_bot", point3d(cent,-h/2), DOWN)
-    ];
-    attachable(anchor,spin,orient, vnf=vnf, extent=true, anchors=anchors) {
-        vnf_polyhedron(vnf, convexity=convexity);
-        children();
-    }
-}
-
 
-// Function&Module: textured_revolution()
-// Usage: As Function
-//   vnf = textured_revolution(path, texture, tex_size, [tscale=], ...);
-//   vnf = textured_revolution(path, texture, counts=, [tscale=], ...);
-// Usage: As Module
-//   textured_revolution(path, texture, tex_size, [tscale=], ...) [ATTACHMENTS];
-//   textured_revolution(path, texture, counts=, [tscale=], ...) [ATTACHMENTS];
-// Topics: Sweep, Extrusion, Textures, Knurling
-// Description:
-//   Given a single 2D path, fully in the X+ half-plane, revolves that path around the Z axis (after rotating its Y+ to Z+).
-//   This creates a solid from that surface of revolution, capped top and bottom, with the sides covered in a given tiled texture.
-//   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:
-//   https://raw.githubusercontent.com/revarbat/BOSL2/master/scripts/img2scad.py
-// Arguments:
-//   path = The path to sweep/extrude.
-//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0) that define the texture to apply to vertical surfaces.  See {{textured_linear_sweep()}} for what textures are supported.
-//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
-//   ---
-//   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]
-//   tscale = Scaling multiplier for the texture depth.
-//   inset = If numeric, lowers the texture into the surface by that amount, before the tscale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
-//   rot = If true, rotates the texture 90º.
-//   caps = (function only) If true, create endcaps for the extruded shape.  Default: `true`
-//   col_wrap = (function only) If true, the path is considered a closed polygon.  Useful mainly for things like making a textured torus.  Default: `false`
-//   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Default: `"min_edge"`
-//   reverse = If the default faces are facing the wrong way, you can reverse them by setting this to `true`.  Default: `false`
-//   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
-//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
-//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// Texture Values:
-//   "ribs" = Vertically aligned triangular ribs.
-//   "trunc_ribs" = Like "ribs" but with flat rib tips.
-//   "wave_ribs" = Vertically aligned wavy ribs.
-//   "diamonds" = Diamond shapes with tips aligned with the axes.  Useful for knurling.
-//   "pyramids" = Pyramids shapes with flat sides aligned with the axes.  Also useful for knurling.
-//   "trunc_pyramids" = Like "pyramids" but with flattened tips.
-//   "dimpled_pyramids" = Like "trunc_pyramids" but with dimples in the flat tips.
-//   "hills" = Wavy hills and valleys,
-//   "waves" = A raised sine-wave patten, oriented vertically.
-//   "dots" = Raised small round bumps.
-//   "cones" = Raised conical spikes.
-// See Also: textured_revolution(), textured_cylinder(), textured_linear_sweep(), heightfield(), cylindrical_heightfield()
-// Example:
-//   include <BOSL2/beziers.scad>
-//   bezpath = [
-//       [15, 30], [10,15],
-//       [10,  0], [20, 10], [30,12],
-//       [30,-12], [20,-10], [10, 0],
-//       [10,-15], [15,-30]
-//   ];
-//   path = bezpath_curve(bezpath, splinesteps=32);
-//   textured_revolution(path, "diamonds", tex_size=[5,5], tscale=1, style="concave");
-// Example:
-//   path = [
-//       [20, 30], [20, 20],
-//       each arc(r=20, corner=[[20,20],[10,0],[20,-20]]),
-//       [20,-20], [20,-30],
-//   ];
-//   vnf = textured_revolution(path, "trunc_pyramids", tex_size=[5,5], tscale=1, style="convex");
-//   vnf_polyhedron(vnf, convexity=10);
-function textured_revolution(
-    path, texture, tex_size,
-    tscale=1, inset=false, rot=false,
-    caps=true, wrap=false, shift=[0,0],
-    style="min_edge", reverse=false,
-    counts
+function _find_vnf_tile_edge_path(vnf, val) =
+    let(
+        verts = vnf[0],
+        fragments = [
+            for(edge = _get_vnf_tile_edges(vnf))
+            let(v0 = verts[edge[0]], v1 = verts[edge[1]])
+            if (approx(v0.y, val) && approx(v1.y, val))
+            v0.x <= v1.x? [[v0.x,v0.z], [v1.x,v1.z]] :
+            [[v1.x,v1.z], [v0.x,v0.z]]
+        ],
+        sfrags = sort(fragments, idx=[0,1]),
+        rpath = _assemble_a_path_from_fragments(sfrags)[0],
+        opath = rpath==[]? []
+              : rpath[0].x > last(rpath).x ? reverse(rpath)
+              : rpath
+    ) opath;
+
+
+/// Function&Module: _textured_revolution()
+/// Usage: As Function
+///   vnf = _textured_revolution(shape, texture, tex_size, [tex_scale=], ...);
+///   vnf = _textured_revolution(shape, texture, counts=, [tex_scale=], ...);
+/// Usage: As Module
+///   _textured_revolution(shape, texture, tex_size, [tex_scale=], ...) [ATTACHMENTS];
+///   _textured_revolution(shape, texture, counts=, [tex_scale=], ...) [ATTACHMENTS];
+/// Topics: Sweep, Extrusion, Textures, Knurling
+/// Description:
+///   Given a 2D region or path, fully in the X+ half-plane, revolves that shape around the Z axis (after rotating its Y+ to Z+).
+///   This creates a solid from that surface of revolution, possibly capped top and bottom, with the sides covered in a given tiled texture.
+///   The texture can be given in one of three ways:
+///   - As a texture name string. (See {{texture()}} for supported named textures.)
+///   - As a 2D array of evenly spread height values. (AKA a heightfield.)
+///   - As a VNF texture tile.  A VNF tile exactly defines a surface from `[0,0]` to `[1,1]`, with the Z coordinates
+///     being the height of the texture point from the surface.  VNF tiles MUST be able to tile in both X and Y
+///     directions with no gaps, with the front and back edges aligned exactly, and the left and right edges as well.
+///   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:
+///   https://raw.githubusercontent.com/revarbat/BOSL2/master/scripts/img2scad.py
+/// Arguments:
+///   shape = The path or region to sweep/extrude.
+///   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to the revolution surface.  See {{texture()}} for what named textures are supported.
+///   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
+///   tex_scale = Scaling multiplier for the texture depth.
+///   ---
+///   inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
+///   rot = If true, rotates the texture 90º.
+///   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]
+///   closed = If false, and shape is given as a path, then the revolved path will be sealed to the axis of rotation with untextured caps.  Default: `true`
+///   taper = If given, and `closed=false`, tapers the texture height to zero over the first and last given percentage of the path.  If given as a lookup table with indices between 0 and 100, uses the percentage lookup table to ramp the texture heights.  Default: `undef` (no taper)
+///   angle = The number of degrees counter-clockwise from X+ to revolve around the Z axis.  Default: `360`
+///   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Used only with heightfield type textures. Default: `"min_edge"`
+///   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
+///   samples = Minimum number of "bend points" to have in VNF texture tiles.  Default: 8
+///   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
+///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
+///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
+/// See Also: heightfield(), cylindrical_heightfield(), texture()
+/// Anchor Types:
+///   "hull" = Anchors to the virtual convex hull of the shape.
+///   "intersect" = Anchors to the surface of the shape.
+
+function _textured_revolution(
+    shape, texture, tex_size, tex_scale=1,
+    inset=false, rot=false, shift=[0,0],
+    taper, closed=true, angle=360,
+    counts, samples,
+    style="min_edge", atype="intersect",
+    anchor=CENTER, spin=0, orient=UP
 ) =
-    assert(is_path(path,[2]))
-    assert(is_bool(caps))
-    assert(is_bool(wrap))
-    assert(is_bool(reverse))
+    assert(angle>0 && angle<=360)
+    assert(is_path(shape,[2]) || is_region(shape))
+    assert(is_undef(samples) || is_int(samples))
+    assert(is_bool(closed))
     assert(counts==undef || is_vector(counts,2))
     assert(tex_size==undef || is_vector(tex_size,2))
+    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))
+    let( taper_is_ok = is_undef(taper) || (is_finite(taper) && taper>=0 && taper<50) || is_path(taper,2) )
+    assert(taper_is_ok, "Bad taper= value.")
+    assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
     let(
-        tex = is_string(texture)? _get_texture(texture) : texture,
-        texture = rot? transpose(tex) :  tex,
-        plen = path_length(path),
-        maxx = max(column(path,0)),
+        regions = !is_path(shape,2)? region_parts(shape) :
+            closed? region_parts([shape]) :
+            let(
+                clpoly = [[0,shape[0].y], each shape, [0,last(shape).y]],
+                dpoly = deduplicate(clpoly),
+                cwpoly = is_polygon_clockwise(dpoly) ? dpoly : reverse(dpoly)
+            )
+            [[ select(cwpoly,1,-2) ]],
+        checks = [
+            for (rgn=regions, path=rgn)
+            assert(all(path, function(pt) pt.x>=0))
+        ]
+    )
+    assert(closed || is_path(shape,2))
+    let(
+        tex = is_string(texture)? texture(texture) : texture,
+        texture = !rot? tex :
+            is_vnf(tex)? zrot(is_num(rot)?rot:90, cp=[1/2,1/2], p=tex) :
+            rot==180? reverse([for (row=tex) reverse(row)]) :
+            rot==270? [for (row=transpose(tex)) reverse(row)] :
+            reverse(transpose(tex)),
+        check_tex = _validate_texture(texture),
+        inset = is_num(inset)? inset : inset? 1 : 0,
+        samples = !is_vnf(texture)? len(texture) :
+            is_num(samples)? samples : 8,
+        bounds = pointlist_bounds(flatten(flatten(regions))),
+        maxx = bounds[1].x,
+        miny = bounds[0].y,
+        maxy = bounds[1].y,
+        h = maxy - miny,
         circumf = 2 * PI * maxx,
-        counts = is_vector(counts,2)? counts :
+        tile = !is_vnf(texture)? texture :
+            let(
+                utex = samples<=1? texture :
+                    let(
+                        s = 1 / samples,
+                        slices = list([s : s : 1-s/2]),
+                        vnfx = vnf_slice(texture, "X", slices),
+                        vnfy = vnf_slice(vnfx, "Y", slices),
+                        vnft = vnf_triangulate(vnfy),
+                        zvnf = [
+                            [
+                                for (p=vnft[0]) [
+                                    approx(p.x,0)? 0 : approx(p.x,1)? 1 : p.x,
+                                    approx(p.y,0)? 0 : approx(p.y,1)? 1 : p.y,
+                                    p.z
+                                ]
+                            ],
+                            vnft[1]
+                        ]
+                    ) zvnf
+            ) _vnf_sort_vertices(utex, idx=[0,1]),
+        vertzs = is_vnf(texture)? group_sort(tile[0], idx=0) : undef,
+        bpath = is_vnf(tile)
+            ? _find_vnf_tile_edge_path(tile,1)
+            : let(
+                  row = tile[0],
+                  rlen = len(row)
+              ) [for (i = [0:1:rlen]) [i/rlen, row[i%rlen]]],
+        counts_x = is_vector(counts,2)? counts.x :
             is_vector(tex_size,2)
-              ? [round(circumf/tex_size.x), round(plen/tex_size.y)]
-              : [30, 5],
-        texcnt = [len(texture[0]), len(texture)],
-        inset = is_num(inset)? inset : inset? 1 : 0,
-        xcnt = counts.x * texcnt.x,
-        ycnt = counts.y * texcnt.y,
-        bases = resample_path(path, n=ycnt+1, closed=false),
-        norms = path_normals(bases),
-        tiles = [
-            for (i = [0:1:ycnt])
-            let(row = texture[i % texcnt.y]) [
-                for (j = [0:1:xcnt-1])
-                let(
-                    tscale = !wrap && (i==0 || i==ycnt)? 0 : tscale,
-                    texh = tscale * (row[j % texcnt.x] - inset) * (bases[i].x/maxx),
-                    xy = bases[i] - texh * norms[i],
-                    xyz = lerp([0,0,0],point3d(shift),i/ycnt) + rot([90, 0, 360*j/xcnt], p=point3d(xy))
-                )
-                xyz
-            ]
-        ],
-        vnf = vnf_vertex_array(
-            tiles, caps=caps, style=style, reverse=reverse,
-            col_wrap=true, row_wrap=wrap
-        )
-    ) vnf;
+              ? max(1,round(angle/360*circumf/tex_size.x))
+              : ceil(6*angle/360*circumf/h),
+        taper_lup = closed || is_undef(taper)? [[-1,1],[2,1]] :
+            is_num(taper)? [[-1,0], [0,0], [taper/100+EPSILON,1], [1-taper/100-EPSILON,1], [1,0], [2,0]] :
+            is_path(taper,2)? let(
+                retaper = [
+                    for (t=taper)
+                    assert(t[0]>=0 && t[0]<=100, "taper lookup indices must be between 0 and 100 inclusive.")
+                    [t[0]/100, t[1]]
+                ],
+                taperout = [[-1,retaper[0][1]], each retaper, [2,last(retaper)[1]]]
+            ) taperout :
+            assert(false, "Bad taper= argument value."),
+        full_vnf = vnf_join([
+            for (rgn = regions) let(
+                rgn_wall_vnf = vnf_join([
+                    for (path = rgn) let(
+                        plen = path_length(path, closed=closed),
+                        counts_y = is_vector(counts,2)? counts.y :
+                            is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,
+                        obases = resample_path(path, n=counts_y * samples + (closed?0:1), closed=closed),
+                        onorms = path_normals(obases, closed=closed),
+                        rbases = closed? list_wrap(obases) : obases,
+                        rnorms = closed? list_wrap(onorms) : onorms,
+                        bases = xrot(90, p=path3d(rbases)),
+                        norms = xrot(90, p=path3d(rnorms)),
+                        vnf = is_vnf(texture)
+                          ? vnf_join([ // VNF tile texture
+                                for (j = [0:1:counts_y-1])
+                                [
+                                    [
+                                        for (group = vertzs) each [
+                                            for (vert = group) let(
+                                                part = (j + (1-vert.y)) * samples,
+                                                u = floor(part),
+                                                uu = part - u,
+                                                base = lerp(select(bases,u), select(bases,u+1), uu),
+                                                norm = unit(lerp(select(norms,u), select(norms,u+1), uu)),
+                                                tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),
+                                                texh = (vert.z - inset) * tex_scale * (base.x / maxx),
+                                                xyz = base - norm * texh
+                                            ) zrot(vert.x*angle/counts_x, p=xyz)
+                                        ]
+                                    ],
+                                    tile[1]
+                                ]
+                            ])
+                          : let( // Heightfield texture
+                                texcnt = [len(texture[0]), len(texture)],
+                                tiles = transpose([
+                                    for (j = [0,1], tj = [0:1:texcnt.x-1])
+                                    if (j == 0 || tj == 0)
+                                    let(
+                                        v = (j + (tj/texcnt.x)) / counts_x,
+                                        mat = zrot(v*angle)
+                                    ) apply(mat, [
+                                        for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])
+                                        if (i != counts_y || ti == 0)
+                                        let(
+                                            part = (i + (ti/texcnt.y)) * samples,
+                                            u = floor(part),
+                                            uu = part - u,
+                                            base = lerp(bases[u], select(bases,u+1), uu),
+                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),
+                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),
+                                            texh = (texture[ti][tj] - inset) * tex_scale * (base.x / maxx),
+                                            xyz = base - norm * texh
+                                        ) xyz
+                                    ])
+                                ])
+                            ) vnf_vertex_array(
+                                tiles, caps=false, style=style,
+                                col_wrap=false, row_wrap=closed
+                            )
+                    ) vnf
+                ]),
+                walls_vnf = vnf_join([
+                    for (i = [0:1:counts_x-1])
+                    zrot(i*angle/counts_x, rgn_wall_vnf)
+                ]),
+                endcap_vnf = angle == 360? EMPTY_VNF :
+                    let(
+                        cap_rgn = [
+                            for (path = rgn) let(
+                                plen = path_length(path, closed=closed),
+                                counts_y = is_vector(counts,2)? counts.y :
+                                    is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,
+                                obases = resample_path(path, n=counts_y * samples + (closed?0:1), closed=closed),
+                                onorms = path_normals(obases, closed=closed),
+                                bases = closed? list_wrap(obases) : obases,
+                                norms = closed? list_wrap(onorms) : onorms,
+                                ppath = is_vnf(texture)
+                                  ? [ // VNF tile texture
+                                        for (j = [0:1:counts_y-1])
+                                        for (group = vertzs, vert = reverse(group))
+                                        if (approx(vert.x, 0)) let(
+                                            part = (j + (1 - vert.y)) * samples,
+                                            u = floor(part),
+                                            uu = part - u,
+                                            base = lerp(select(bases,u), select(bases,u+1), uu),
+                                            norm = unit(lerp(select(norms,u), select(norms,u+1), uu)),
+                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),
+                                            texh = (vert.z - inset) * tex_scale * (base.x / maxx),
+                                            xyz = base - norm * texh
+                                        ) xyz
+                                    ]
+                                  : let( // Heightfield texture
+                                        texcnt = [len(texture[0]), len(texture)]
+                                    ) [
+                                        for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])
+                                        if (i != counts_y || ti == 0)
+                                        let(
+                                            part = (i + (ti/texcnt.y)) * samples,
+                                            u = floor(part),
+                                            uu = part - u,
+                                            base = lerp(bases[u], select(bases,u+1), uu),
+                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),
+                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),
+                                            texh = (texture[ti][0] - inset) * tex_scale * (base.x / maxx),
+                                            xyz = base - norm * texh
+                                        ) xyz
+                                    ],
+                                path = closed? ppath : [
+                                    [0, ppath[0].y],
+                                    each ppath,
+                                    [0, last(ppath).y],
+                                ]
+                            ) deduplicate(path, closed=closed)
+                        ],
+                        vnf2 = vnf_from_region(cap_rgn, xrot(90), reverse=false),
+                        vnf3 = vnf_from_region(cap_rgn, rot([90,0,angle]), reverse=true)
+                    ) vnf_join([vnf2, vnf3]),
+                allcaps_vnf = closed? EMPTY_VNF :
+                    let(
+                        plen = path_length(rgn[0], closed=closed),
+                        counts_y = is_vector(counts,2)? counts.y :
+                            is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,
+                        obases = resample_path(rgn[0], n=counts_y * samples + (closed?0:1), closed=closed),
+                        onorms = path_normals(obases, closed=closed),
+                        rbases = closed? list_wrap(obases) : obases,
+                        rnorms = closed? list_wrap(onorms) : onorms,
+                        bases = xrot(90, p=path3d(rbases)),
+                        norms = xrot(90, p=path3d(rnorms)),
+                        caps_vnf = vnf_join([
+                            for (j = [-1,0]) let(
+                                base = select(bases,j),
+                                norm = unit(select(norms,j)),
+                                ppath = [
+                                    for (vert = bpath) let(
+                                        uang = vert.x / counts_x,
+                                        tex_scale = tex_scale * lookup([0,1][j+1], taper_lup),
+                                        texh = (vert.y - inset) * tex_scale * (base.x / maxx),
+                                        xyz = base - norm * texh
+                                    ) zrot(angle*uang, p=xyz)
+                                ],
+                                pplen = len(ppath),
+                                zed = j<0? max(column(ppath,2)) :
+                                    min(column(ppath,2)),
+                                slice_vnf = [
+                                    [
+                                        each ppath,
+                                        [0, 0, zed],
+                                    ], [
+                                        for (i = [0:1:pplen-2])
+                                            j<0? [pplen, i, (i+1)%pplen] :
+                                            [pplen, (i+1)%pplen, i]
+                                    ]
+                                ],
+                                cap_vnf = vnf_join([
+                                    for (i = [0:1:counts_x-1])
+                                        zrot(i*angle/counts_x, p=slice_vnf)
+                                ])
+                            ) cap_vnf
+                        ])
+                    ) caps_vnf
+            ) vnf_join([walls_vnf, endcap_vnf, allcaps_vnf])
+        ]),
+        skmat = down(-miny) * skew(sxz=shift.x/h, syz=shift.y/h) * up(-miny),
+        skvnf = apply(skmat, full_vnf),
+        geom = atype=="intersect"
+              ? attach_geom(vnf=skvnf, extent=false)
+              : attach_geom(vnf=skvnf, extent=true)
+    ) reorient(anchor,spin,orient, geom=geom, p=skvnf);
 
 
-module textured_revolution(
-    path, texture, tex_size,
-    tscale=1, inset=false, rot=false,
-    caps=true, wrap=false, shift=[0,0],
-    style="min_edge", reverse=false,
-    atype="surface",
-    convexity=10, counts,
+module _textured_revolution(
+    shape, texture, tex_size, tex_scale=1,
+    inset=false, rot=false, shift=[0,0],
+    taper, closed=true, angle=360,
+    style="min_edge", atype="intersect",
+    convexity=10, counts, samples,
     anchor=CENTER, spin=0, orient=UP
 ) {
-    assert(in_list(atype, ["surface","extent"]));
-    vnf = textured_revolution(
-        path, texture, tex_size=tex_size,
-        tscale=tscale, inset=inset, rot=rot,
-        caps=caps, wrap=wrap, style=style,
-        reverse=reverse, shift=shift,
-        counts=counts
+    dummy = assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"");
+    vnf = _textured_revolution(
+        shape, texture, tex_size=tex_size,
+        tex_scale=tex_scale, inset=inset, rot=rot,
+        taper=taper, closed=closed, style=style,
+        shift=shift, angle=angle,
+        samples=samples, counts=counts
     );
-    geom = atype=="surface"
+    geom = atype=="intersect"
           ? attach_geom(vnf=vnf, extent=false)
           : attach_geom(vnf=vnf, extent=true);
     attachable(anchor,spin,orient, geom=geom) {
         vnf_polyhedron(vnf, convexity=convexity);
         children();
     }
 }
 
 
-// Function&Module: textured_cylinder()
-// Usage: As Function
-//   vnf = textured_cylinder(h|l=, r|d=, texture, tex_size|counts=, [tscale=], [inset=], [rot=], ...);
-//   vnf = textured_cylinder(h|l=, r1=|d1=, r2=|d2=, texture=, tex_size=|counts=, [tscale=], [inset=], [rot=], ...);
-// Usage: As Module
-//   textured_cylinder(h, r|d=, texture, tex_size|counts=, [tscale=], [inset=], [rot=], ...) [ATTACHMENTS];
-//   textured_cylinder(h, r1=|d1=, r2=|d2=, texture=, tex_size=|counts=, [tscale=], [inset=], [rot=], ...) [ATTACHMENTS];
-// Topics: Sweep, Extrusion, Textures, Knurling
-// Description:
-//   Creates a cylinder or cone with optional chamfers or roundings, covered in a textured surface.
-//   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:
-//   https://raw.githubusercontent.com/revarbat/BOSL2/master/scripts/img2scad.py
-// Arguments:
-//   h | l = The height of the cylinder.
-//   r = The radius of the cylinder.
-//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0) that define the texture to apply to vertical surfaces.  See {{textured_linear_sweep()}} for supported textures.
-//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
-//   ---
-//   r1 = The radius of the bottom of the cylinder.
-//   r2 = The radius of the top of the cylinder.
-//   d = The diameter of the cylinder.
-//   d1 = The diameter of the bottom of the cylinder.
-//   d2 = The diameter of the top of the cylinder.
-//   tscale = Scaling multiplier for the texture depth.
-//   inset = If numeric, lowers the texture into the surface by that amount, before the tscale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`
-//   rot = If true, rotates the texture 90º.
-//   caps = (function only) If true, create endcaps for the extruded shape.  Default: `true`
-//   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]
-//   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Default: `"min_edge"`
-//   reverse = If the default faces are facing the wrong way, you can reverse them by setting this to `true`.  Default: `false`
-//   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.
-//   chamfer = If given, chamfers the top and bottom of the cylinder by the given size.
-//   chamfer1 = If given, chamfers the bottom of the cylinder by the given size.
-//   chamfer2 = If given, chamfers the top of the cylinder by the given size.
-//   rounding = If given, rounds the top and bottom of the cylinder to the given radius.
-//   rounding1 = If given, rounds the bottom of the cylinder to the given radius.
-//   rounding2 = If given, rounds the top of the cylinder to the given radius.
-//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
-//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
-//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
-// Texture Values:
-//   "ribs" = Vertically aligned triangular ribs.
-//   "trunc_ribs" = Like "ribs" but with flat rib tips.
-//   "wave_ribs" = Vertically aligned wavy ribs.
-//   "diamonds" = Diamond shapes with tips aligned with the axes.  Useful for knurling.
-//   "pyramids" = Pyramids shapes with flat sides aligned with the axes.  Also useful for knurling.
-//   "trunc_pyramids" = Like "pyramids" but with flattened tips.
-//   "dimpled_pyramids" = Like "trunc_pyramids" but with dimples in the flat tips.
-//   "hills" = Wavy hills and valleys,
-//   "waves" = A raised sine-wave patten, oriented vertically.
-//   "dots" = Raised small round bumps.
-//   "cones" = Raised conical spikes.
-// See Also: textured_revolution(), textured_cylinder(), textured_linear_sweep(), heightfield(), cylindrical_heightfield()
-// Examples:
-//   textured_cylinder(h=40, r=20, texture="diamonds", tex_size=[5,5]);
-//   textured_cylinder(h=40, r1=20, r2=15, texture="pyramids", tex_size=[5,5], style="convex");
-//   textured_cylinder(h=40, r1=20, r2=15, texture="trunc_pyramids", tex_size=[5,5], chamfer=5, style="convex");
-//   textured_cylinder(h=40, r1=20, r2=15, texture="dots", tex_size=[5,5], rounding=8, style="convex");
-function textured_cylinder(
-    h, r, texture, tex_size=[1,1], counts,
-    tscale=1, inset=false, rot=false,
-    caps=true, style="min_edge",
-    reverse=false, shift=[0,0],
-    l, r1, r2, d, d1, d2,
-    chamfer, chamfer1, chamfer2,
-    rounding, rounding1, rounding2
-) =
-    let(
-        h = first_defined([h, l, 1]),
-        r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1),
-        r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1),
-        chamf1 = first_defined([chamfer1, chamfer]),
-        chamf2 = first_defined([chamfer2, chamfer]),
-        round1 = first_defined([rounding1, rounding]),
-        round2 = first_defined([rounding2, rounding]),
-        path = [
-            if (is_finite(chamf1)) each arc(n=2, r=chamf1, corner=[[0,-h/2],[r1,-h/2],[r2,h/2]])
-                else if (is_finite(round1)) each arc(r=round1, corner=[[0,-h/2],[r1,-h/2],[r2,h/2]])
-                else [r1,-h/2],
-            if (is_finite(chamf2)) each arc(n=2, r=chamf2, corner=[[r1,-h/2],[r2,h/2],[0,h/2]])
-                else if (is_finite(round2)) each arc(r=round2, corner=[[r1,-h/2],[r2,h/2],[0,h/2]])
-                else [r2,h/2],
-        ],
-        vnf = textured_revolution(
-            reverse(path), texture,
-            tex_size=tex_size, counts=counts,
-            tscale=tscale, inset=inset, rot=rot,
-            caps=caps, style=style, reverse=reverse,
-            shift=shift
-        )
-    ) vnf;
-
-
-module textured_cylinder(
-    h, r, texture, tex_size=[1,1],
-    counts, tscale=1, inset=false, rot=false,
-    style="min_edge", reverse=false, shift=[0,0],
-    l, r1, r2, d, d1, d2,
-    chamfer, chamfer1, chamfer2,
-    rounding, rounding1, rounding2,
-    convexity=10,
-    anchor=CENTER, spin=0, orient=UP
-) {
-    h = first_defined([h, l, 1]);
-    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);
-    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);
-    chamf1 = first_defined([chamfer1, chamfer]);
-    chamf2 = first_defined([chamfer2, chamfer]);
-    round1 = first_defined([rounding1, rounding]);
-    round2 = first_defined([rounding2, rounding]);
-    vnf = textured_cylinder(
-        texture=texture, h=h, r1=r1, r2=r2,
-        tscale=tscale, inset=inset, rot=rot,
-        counts=counts, tex_size=tex_size,
-        caps=true, style=style,
-        reverse=reverse, shift=shift,
-        chamfer1=chamf1, chamfer2=chamf2,
-        rounding1=round1, rounding2=round2
-    );
-    attachable(anchor,spin,orient, r1=r1, r2=r2, h=h, shift=shift) {
-        vnf_polyhedron(vnf, convexity=convexity);
-        children();
-    }
-}
-
-
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/sliders.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/sliders.scad`

 * *Files 3% similar despite different names*

```diff
@@ -9,18 +9,21 @@
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Modules
 
 
 // Module: slider()
-// Description:
-//   Creates a slider to match a V-groove rail.
+// Synopsis: Creates a V-groove slider.
+// Topics: Parts, Sliders
+// See Also: rail()
 // Usage:
 //   slider(l, w, h, [base=], [wall=], [ang=], [$slop=]) [ATTACHMENTS];
+// Description:
+//   Creates a slider to match a V-groove rail.
 // Arguments:
 //   l = Length (long axis) of slider.
 //   w = Width of slider.
 //   h = Height of slider.
 //   ---
 //   base = Height of slider base.
 //   wall = Width of wall behind each side of the slider.
@@ -59,25 +62,28 @@
         children();
     }
 }
 
 
 
 // Module: rail()
-// Description:
-//   Creates a V-groove rail.
+// Synopsis: Creates a V-groove rail.
+// Topics: Parts, Sliders
+// See Also: slider()
 // Usage:
 //   rail(l, w, h, [chamfer=], [ang=]) [ATTACHMENTS];
+// Description:
+//   Creates a V-groove rail.
 // Arguments:
 //   l = Length (long axis) of slider.
 //   w = Width of slider.
 //   h = Height of slider.
-//   ---
 //   chamfer = Size of chamfer at end of rail.
-//   ang = Overhang angle for slider, to facilitate supportless printig.
+//   ang = Overhang angle for slider, to facilitate supportless printing.
+//   ---
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 // Example:
 //   rail(l=100, w=10, h=10);
 function rail(l=30, w=10, h=10, chamfer=1.0, ang=30, anchor=BOTTOM, spin=0, orient=UP) = no_function("rail");
 module rail(l=30, w=10, h=10, chamfer=1.0, ang=30, anchor=BOTTOM, spin=0, orient=UP)
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/std.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/std.scad`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/strings.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/strings.scad`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Extracting substrings
 
 // Function: substr()
 // Usage:
-//   substr(str, [pos], [len])
+//   newstr = substr(str, [pos], [len]);
 // Description:
 //   Returns a substring from a string start at position `pos` with length `len`, or 
 //   if `len` isn't given, the rest of the string.  
 // Arguments:
 //   str = string to operate on
 //   pos = starting index of substring, or vector of first and last position.  Default: 0
 //   len = length of substring, or omit it to get the rest of the string.  If len is zero or less then the emptry string is returned.  
@@ -35,15 +35,15 @@
 function _substr(str,pos,len,substr="") = 
     len <= 0 || pos>=len(str) ? substr :
     _substr(str, pos+1, len-1, str(substr, str[pos]));
 
 
 // Function: suffix()
 // Usage:
-//   suffix(str,len)
+//   newstr = suffix(str,len);
 // Description:
 //   Returns the last `len` characters from the input string `str`.
 //   If `len` is longer than the length of `str`, then the entirety of `str` is returned.
 // Arguments:
 //   str = The string to get the suffix of.
 //   len = The number of characters of suffix to get.
 function suffix(str,len) =
@@ -52,15 +52,15 @@
 
 
 // Section: String Searching
 
 
 // Function: str_find()
 // Usage:
-//   str_find(str,pattern,[last=],[all=],[start=])
+//   ind = str_find(str,pattern,[last=],[all=],[start=]);
 // Description:
 //   Searches input string `str` for the string `pattern` and returns the index or indices of the matches in `str`.
 //   By default `str_find()` returns the index of the first match in `str`.  If `last` is true then it returns the index of the last match.
 //   If the pattern is the empty string the first match is at zero and the last match is the last character of the `str`.
 //   If `start` is set then the search begins at index start, working either forward and backward from that position.  If you set `start`
 //   and `last` is true then the search will find the pattern if it begins at index `start`.  If no match exists, returns `undef`.
 //   If you set `all` to true then `str_find()` returns all of the matches in a list, or an empty list if there are no matches.
@@ -90,78 +90,97 @@
     all? _str_find_all(str,pattern) :
     let( start = first_defined([start,last?len(str)-len(pattern):0]) )
     pattern==""? start :
     last? _str_find_last(str,pattern,start) :
     _str_find_first(str,pattern,len(str)-len(pattern),start);
 
 function _str_find_first(str,pattern,max_sindex,sindex) = 
-    sindex<=max_sindex && !_str_cmp(str,sindex, pattern)?
+    sindex<=max_sindex && !substr_match(str,sindex, pattern)?
         _str_find_first(str,pattern,max_sindex,sindex+1) :
         (sindex <= max_sindex ? sindex : undef);
 
 function _str_find_last(str,pattern,sindex) = 
-    sindex>=0 && !_str_cmp(str,sindex, pattern)?
+    sindex>=0 && !substr_match(str,sindex, pattern)?
         _str_find_last(str,pattern,sindex-1) :
         (sindex >=0 ? sindex : undef);
 
 function _str_find_all(str,pattern) =
     pattern == "" ? count(len(str)) :
-    [for(i=[0:1:len(str)-len(pattern)]) if (_str_cmp(str,i,pattern)) i];
+    [for(i=[0:1:len(str)-len(pattern)]) if (substr_match(str,i,pattern)) i];
+
+// Function: substr_match()
+// Usage
+//   bool = substr_match(str,start,pattern);
+// Description:
+//   Returns true if the string `pattern` matches the string `str` starting
+//   at `str[start]`.  If the string is too short for the pattern, or
+//   `start` is out of bounds---either negative or beyond the end of the
+//   string---then substr_match returns false. 
+// Arguments:
+//   str = String to search
+//   start = Starting index for search in str
+//   pattern = String pattern to search for
+// Examples:
+//   substr_match("abcde",2,"cd");   // Returns true
+//   substr_match("abcde",2,"cx");   // Returns false
+//   substr_match("abcde",2,"cdef"); // Returns false
+//   substr_match("abcde",-2,"cd");  // Returns false
+//   substr_match("abcde",19,"cd");  // Returns false
+//   substr_match("abc",1,"");       // Returns true
 
-// _str_cmp(str,sindex,pattern)
-//    returns true if the string pattern matches the string
-//    starting at index position sindex in the string.
 //
 //    This is carefully optimized for speed.  Precomputing the length
 //    cuts run time in half when the string is long.  Two other string
 //    comparison methods were slower.  
-function _str_cmp(str,sindex,pattern) =
-    len(str)-sindex <len(pattern)? false :
-    _str_cmp_recurse(str,sindex,pattern,len(pattern));
-
-function _str_cmp_recurse(str,sindex,pattern,plen,pindex=0,) = 
-    pindex < plen && pattern[pindex]==str[sindex] ? _str_cmp_recurse(str,sindex+1,pattern,plen,pindex+1): (pindex==plen);
+function substr_match(str,start,pattern) =
+     len(str)-start <len(pattern)? false
+   : _substr_match_recurse(str,start,pattern,len(pattern));
+
+function _substr_match_recurse(str,sindex,pattern,plen,pindex=0,) =
+    pindex < plen && pattern[pindex]==str[sindex]
+       ? _substr_match_recurse(str,sindex+1,pattern,plen,pindex+1)
+       : (pindex==plen);
 
 
 // Function: starts_with()
 // Usage:
-//    starts_with(str,pattern)
+//    bool = starts_with(str,pattern);
 // Description:
 //    Returns true if the input string `str` starts with the specified string pattern, `pattern`.
 //    Otherwise returns false.   
 // Arguments:
 //   str = String to search.
 //   pattern = String pattern to search for.
 // Example:
 //   starts_with("abcdef","abc");  // Returns true
 //   starts_with("abcdef","def");  // Returns false
 //   starts_with("abcdef","");     // Returns true
-function starts_with(str,pattern) = _str_cmp(str,0,pattern);
+function starts_with(str,pattern) = substr_match(str,0,pattern);
 
 
 // Function: ends_with()
 // Usage:
-//    ends_with(str,pattern)
+//    bool = ends_with(str,pattern);
 // Description:
 //    Returns true if the input string `str` ends with the specified string pattern, `pattern`.
 //    Otherwise returns false. 
 // Arguments:
 //   str = String to search.
 //   pattern = String pattern to search for.
 // Example:
 //   ends_with("abcdef","def");  // Returns true
 //   ends_with("abcdef","de");   // Returns false
 //   ends_with("abcdef","");     // Returns true
-function ends_with(str,pattern) = _str_cmp(str,len(str)-len(pattern),pattern);
+function ends_with(str,pattern) = substr_match(str,len(str)-len(pattern),pattern);
 
 
 
 // Function: str_split()
 // Usage:
-//   str_split(str, sep, [keep_nulls])
+//   string_list = str_split(str, sep, [keep_nulls]);
 // Description:
 //   Breaks an input string into substrings using a separator or list of separators.  If keep_nulls is true
 //   then two sequential separator characters produce an empty string in the output list.  If keep_nulls is false
 //   then no empty strings are included in the output list.
 //   .
 //   If sep is a single string then each character in sep is treated as a delimiting character and the input string is
 //   split at every delimiting character.  Empty strings can occur whenever two delimiting characters are sequential.
@@ -203,15 +222,15 @@
 
 
 // Section: String modification
 
 
 // Function: str_join()
 // Usage:
-//   str_join(list, [sep])
+//   str = str_join(list, [sep]);
 // Description:
 //   Returns the concatenation of a list of strings, optionally with a
 //   separator string inserted between each string on the list.
 // Arguments:
 //   list = list of strings to concatenate
 //   sep = separator string to insert.  Default: ""
 // Example:
@@ -222,15 +241,15 @@
     str_join(list,sep,_i+1,str(_result,list[_i],sep));
 
 
 
 
 // Function: str_strip()
 // Usage:
-//   str_strip(s,c,[start],[end]);
+//   str = str_strip(s,c,[start],[end]);
 // Description:
 //   Takes a string `s` and strips off all leading and/or trailing characters that exist in string `c`.
 //   By default strips both leading and trailing characters.  If you set start or end to true then
 //   it will strip only the leading or trailing characters respectively.  If you set start
 //   or end to false then it will strip only lthe trailing or leading characters.
 // Arguments:
 //   s = The string to strip leading or trailing characters from.
@@ -289,42 +308,42 @@
   )
   left ? str(padding,str) : str(str,padding);
 
 
 
 // Function: str_replace_char()
 // Usage:
-//   newstr = str_replace_char(str, char, replace)
+//   newstr = str_replace_char(str, char, replace);
 // Description:
 //   Replace every occurence of `char` in the input string with the string `replace` which
 //   can be any string.  
 function str_replace_char(str,char,replace) =
    assert(is_str(str))
    assert(is_str(char) && len(char)==1, "Search pattern 'char' must be a single character string")
    assert(is_str(replace))
    str_join([for(c=str) c==char ? replace : c]);
 
 
 // Function: downcase()
 // Usage:
-//   downcase(str)
+//   newstr = downcase(str);
 // Description:
 //   Returns the string with the standard ASCII upper case letters A-Z replaced
 //   by their lower case versions.
 // Arguments:
 //   str = String to convert.
 // Example:
 //   downcase("ABCdef");   // Returns "abcdef"
 function downcase(str) =
     str_join([for(char=str) let(code=ord(char)) code>=65 && code<=90 ? chr(code+32) : char]);
 
 
 // Function: upcase()
 // Usage:
-//   upcase(str)
+//   newstr = upcase(str);
 // Description:
 //   Returns the string with the standard ASCII lower case letters a-z replaced
 //   by their upper case versions.
 // Arguments:
 //   str = String to convert.
 // Example:
 //   upcase("ABCdef");   // Returns "ABCDEF"
@@ -349,15 +368,15 @@
 
 
 
 // Section: Parsing strings into numbers
 
 // Function: parse_int()
 // Usage:
-//   parse_int(str, [base])
+//   num = parse_int(str, [base])
 // Description:
 //   Converts a string into an integer with any base up to 16.  Returns NaN if 
 //   conversion fails.  Digits above 9 are represented using letters A-F in either
 //   upper case or lower case.  
 // Arguments:
 //   str = String to convert.
 //   base = Base for conversion, from 2-16.  Default: 10
@@ -385,15 +404,15 @@
         last_digit = digit == [] || digit[0] >= base ? (0/0) : digit[0]
     ) i==0 ? last_digit : 
     _parse_int_recurse(str,base,i-1)*base + last_digit;
 
 
 // Function: parse_float()
 // Usage:
-//   parse_float(str)
+//   num = parse_float(str);
 // Description:
 //   Converts a string to a floating point number.  Returns NaN if the
 //   conversion fails.
 // Arguments:
 //   str = String to convert.
 // Example:
 //   parse_float("44");       // Returns 44
@@ -413,15 +432,15 @@
     len(esplit)==2 ? parse_float(esplit[0]) * pow(10,parse_int(esplit[1])) :
     let( dsplit = str_split(str,["."]))
     parse_int(dsplit[0])+parse_int(dsplit[1])/pow(10,len(dsplit[1]));
 
 
 // Function: parse_frac()
 // Usage:
-//   parse_frac(str,[mixed=],[improper=],[signed=])
+//   num = parse_frac(str,[mixed=],[improper=],[signed=]);
 // Description:
 //   Converts a string fraction to a floating point number.  A string fraction has the form `[-][# ][#/#]` where each `#` is one or more of the
 //   digits 0-9, and there is an optional sign character at the beginning. 
 //   The full form is a sign character and an integer, followed by exactly one space, followed by two more
 //   integers separated by a "/" character.  The leading integer and 
 //   space can be omitted or the trailing fractional part can be omitted.  If you set `mixed` to false then the leading integer part is not
 //   accepted and the input must include a slash.  If you set `improper` to false then the fractional part must be a proper fraction, where
@@ -445,37 +464,36 @@
 //   parse_frac("0/0");     // Returns nan
 //   parse_frac("-77/9",improper=false);   // Returns nan
 //   parse_frac("-2 12/4",improper=false); // Returns nan
 //   parse_frac("-2 12/4",signed=false);   // Returns nan
 //   parse_frac("-2 12/4",mixed=false);    // Returns nan
 //   parse_frac("2 1/4",mixed=false);      // Returns nan
 function parse_frac(str,mixed=true,improper=true,signed=true) =
-    str == undef ? undef :
-    len(str)==0 ? 0 :
-    signed && str[0]=="-" ? -parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false) :
-    signed && str[0]=="+" ?  parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false) :
-    mixed ? (                      
-        !in_list(str_find(str," "), [undef,0]) || is_undef(str_find(str,"/"))? (
-            let(whole = str_split(str,[" "]))
-            _parse_int_recurse(whole[0],10,len(whole[0])-1) + parse_frac(whole[1], mixed=false, improper=improper, signed=false)
-        ) : parse_frac(str,mixed=false, improper=improper)
-    ) : (
-        let(split = str_split(str,"/"))
-        len(split)!=2 ? (0/0) :
-        let(
-            numerator =  _parse_int_recurse(split[0],10,len(split[0])-1),
-            denominator = _parse_int_recurse(split[1],10,len(split[1])-1)
-        ) !improper && numerator>=denominator? (0/0) :
-        denominator<0 ? (0/0) : numerator/denominator
-    );
+    str == undef ? undef
+  : len(str)==0 ? 0
+  : str[0]==" " ? NAN
+  : signed && str[0]=="-" ? -parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false)
+  : signed && str[0]=="+" ?  parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false)
+  : mixed && (str_find(str," ")!=undef || str_find(str,"/")==undef)?   // Mixed allowed and there is a space or no slash 
+        let(whole = str_split(str,[" "]))
+        _parse_int_recurse(whole[0],10,len(whole[0])-1) + parse_frac(whole[1], mixed=false, improper=improper, signed=false)
+  : let(split = str_split(str,"/"))
+    len(split)!=2 ? NAN
+  : let(
+        numerator =  _parse_int_recurse(split[0],10,len(split[0])-1),
+        denominator = _parse_int_recurse(split[1],10,len(split[1])-1)
+    )
+    !improper && numerator>=denominator? NAN
+  : denominator<0 ? NAN
+  : numerator/denominator;
 
 
 // Function: parse_num()
 // Usage:
-//   parse_num(str)
+//   num = parse_num(str);
 // Description:
 //   Converts a string to a number.  The string can be either a fraction (two integers separated by a "/") or a floating point number.
 //   Returns NaN if the conversion fails.
 // Example:
 //   parse_num("3/4");    // Returns 0.75
 //   parse_num("3.4e-2"); // Returns 0.034
 function parse_num(str) =
@@ -487,15 +505,15 @@
 
 
 
 // Section: Formatting numbers into strings
 
 // Function: format_int()
 // Usage:
-//   format_int(i, [mindigits]);
+//   str = format_int(i, [mindigits]);
 // Description:
 //   Formats an integer number into a string.  This can handle larger numbers than `str()`.
 // Arguments:
 //   i = The integer to make a string of.
 //   mindigits = If the number has fewer than this many digits, pad the front with zeros until it does.  Default: 1.
 // Example:
 //   str(123456789012345);  // Returns "1.23457e+14"
@@ -535,15 +553,15 @@
         whole = floor(scaled/sc),
         part = floor(scaled-(whole*sc))
     ) str(format_int(whole),".",format_int(part,digits));
 
 
 // Function: format_float()
 // Usage:
-//   format_float(f,[sig]);
+//   str = format_float(f,[sig]);
 // Description:
 //   Formats the given floating point number `f` into a string with `sig` significant digits.
 //   Strips trailing `0`s after the decimal point.  Strips trailing decimal point.
 //   If the number can be represented in `sig` significant digits without a mantissa, it will be.
 //   If given a list of numbers, recursively prints each item in the list, returning a string like `[3,4,5]`
 // Arguments:
 //   f = The floating point number to format.
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/structs.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/structs.scad`

 * *Files 11% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 //////////////////////////////////////////////////////////////////////
 // LibFile: structs.scad
 //   This file provides manipulation of "structs".  A "struct" is a data structure that
 //   associates arbitrary keys with values and allows you to get and set values
-//   by key.  
+//   by key.
 // Includes:
 //   include <BOSL2/std.scad>
 //   include <BOSL2/structs.scad>
 // FileGroup: Data Management
 // FileSummary: Structure/Dictionary Manipulation
 //////////////////////////////////////////////////////////////////////
 
@@ -15,32 +15,33 @@
 //
 // A struct is a data structure that associates arbitrary keys (of any type) with values (of any type).
 // Structures are implemented as lists of [key, value] pairs.
 //
 // An empty list `[]` is an empty structure and can be used wherever a structure input is required.
 
 // Function: struct_set()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   struct_set(struct, key, value, [grow=])
-//   struct_set(struct, [key1, value1, key2, value2, ...], [grow=])
+//   struct2 = struct_set(struct, key, value, [grow=]);
+//   struct2 = struct_set(struct, [key1, value1, key2, value2, ...], [grow=]);
 // Description:
-//   Sets the key(s) in the structure to the specified value(s), returning a new updated structure.  If a key
-//   exists its value is changed, otherwise the key is added to the structure.  If grow is set to false then
+//   Sets the key(s) in the structure to the specified value(s), returning a new updated structure.  If a
+//   key exists its value is changed, otherwise the key is added to the structure.  If `grow=false` then
 //   it is an error to set a key not already defined in the structure.  If you specify the same key twice
-//   that is also an error.  Note that key order will change when you change a key's value.   
+//   that is also an error.  Note that key order will change when you change a key's value.
 // Arguments:
 //   struct = input structure.
 //   key = key to set or list of key,value pairs to set
 //   value = value to set the key to (when giving a single key and value)
 //   ---
 //   grow = Set to true to allow structure to grow, or false for new keys to generate an error.  Default: true
 function struct_set(struct, key, value, grow=true) =
   is_def(value) ? struct_set(struct,[key,value],grow=grow)
   :
-  assert(is_list(key) && len(key)%2==0, "[key,value] pair list is not a list or has an odd length") 
+  assert(is_list(key) && len(key)%2==0, "[key,value] pair list is not a list or has an odd length")
   let(
       new_entries = [for(i=[0:1:len(key)/2-1]) [key[2*i], key[2*i+1]]],
       newkeys = column(new_entries,0),
       indlist = search(newkeys, struct,0,0),
       badkeys = grow ? (search([undef],new_entries,1,0)[0] != [] ? [undef] : [])
                      : [for(i=idx(indlist)) if (is_undef(newkeys[i]) || len(indlist[i])==0) newkeys[i]],
       ind = flatten(indlist),
@@ -50,57 +51,62 @@
   assert(badkeys==[], str("Unknown or bad key ",_format_key(badkeys[0])," in struct_set"))
   assert(dupkeys==[], str("Duplicate key ",_format_key(dupkeys[0])," for struct"))
   concat(list_remove(struct,ind), new_entries);
 
 function _format_key(key) = is_string(key) ? str("\"",key,"\""): key;
 
 // Function: struct_remove()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   struct_remove(struct, key)
+//   struct2 = struct_remove(struct, key);
 // Description:
 //   Remove key or list of keys from a structure.  If you want to remove a single key which is a list
 //   you must pass it as a singleton list, or struct_remove will attempt to remove the listed items as keys.
-//   If you list the same item multiple times for removal it will be removed without error.  
+//   If you list the same item multiple times for removal it will be removed without error.
 // Arguments:
 //   struct = input structure
-//   key = a single key or list of keys to remove.  
+//   key = a single key or list of keys to remove.
 function struct_remove(struct, key) =
-    !is_list(key) ? struct_remove(struct, [key]) :
+   !is_list(key) ? struct_remove(struct, [key]) :
     let(ind = search(key, struct))
-    list_remove(struct, ind);
+    list_remove(struct, [for(i=ind) if (i!=[]) i]);
 
 
 // Function: struct_val()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   struct_val(struct, key, default)
+//   val = struct_val(struct, key, default);
 // Description:
 //   Returns the value for the specified key in the structure, or default value if the key is not present
 // Arguments:
 //   struct = input structure
 //   key = key whose value to return
 //   default = default value to return if key is not present.  Default: undef
 function struct_val(struct, key, default=undef) =
     assert(is_def(key),"key is missing")
     let(ind = search([key],struct)[0])
     ind == [] ? default : struct[ind][1];
 
 
 // Function: struct_keys()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   keys = struct_keys(struct)
+//   keys = struct_keys(struct);
 // Description:
 //   Returns a list of the keys in a structure
 // Arguments:
 //   struct = input structure
 function struct_keys(struct) = column(struct,0);
 
 
 // Function&Module: echo_struct()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   echo_struct(struct, [name])
+//   echo_struct(struct, [name]);
+//   foo = echo_struct(struct, [name]);
 // Description:
 //   Displays a list of structure keys and values, one pair per line, for easier reading.
 // Arguments:
 //   struct = input structure
 //   name = optional structure name to list at the top of the output.  Default: ""
 function echo_struct(struct,name="") =
     let( keylist = [for(entry=struct) str("  ",entry[0],": ",entry[1],"\n")])
@@ -110,16 +116,17 @@
 module echo_struct(struct,name="") {
     no_children($children);
     dummy = echo_struct(struct,name);
 }
 
 
 // Function: is_struct()
+// Topics: Data Structures, Dictionaries
 // Usage:
-//   is_struct(struct)
+//   bool = is_struct(struct);
 // Description:
 //   Returns true if the input is a list of pairs, false otherwise.
 function is_struct(x) =
     is_list(x) && [for (xx=x) if(!(is_list(xx) && len(xx)==2)) 1] == [];
 
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/transforms.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/transforms.scad`

 * *Files 7% similar despite different names*

```diff
@@ -72,20 +72,21 @@
 //////////////////////////////////////////////////////////////////////
 
 // Function&Module: move()
 // Aliases: translate()
 //
 // Usage: As Module
 //   move(v) CHILDREN;
-// Usage: As a function to translate points, VNF, or Bezier patch
+// Usage: As a function to translate points, VNF, or Bezier patches
 //   pts = move(v, p);
 //   pts = move(STRING, p);
 // Usage: Get Translation Matrix
 //   mat = move(v);
 //
+// Synopsis: Translates children in an arbitrary direction.
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: left(), right(), fwd(), back(), down(), up(), spherical_to_xyz(), altaz_to_xyz(), cylindrical_to_xyz(), polar_to_xy()
 //
 // Description:
 //   Translates position by the given amount.
 //   * Called as a module, moves/translates all children.
 //   * Called as a function with a point in the `p` argument, returns the translated point.
@@ -163,14 +164,15 @@
 // Usage: As Module
 //   left(x) CHILDREN;
 // Usage: Translate Points
 //   pts = left(x, p);
 // Usage: Get Translation Matrix
 //   mat = left(x);
 //
+// Synopsis: Translates children leftwards (X-).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), right(), fwd(), back(), down(), up()
 //
 // Description:
 //   If called as a module, moves/translates all children left (in the X- direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -206,14 +208,15 @@
 // Usage: As Module
 //   right(x) CHILDREN;
 // Usage: Translate Points
 //   pts = right(x, p);
 // Usage: Get Translation Matrix
 //   mat = right(x);
 //
+// Synopsis: Translates children rightwards (X+).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), left(), fwd(), back(), down(), up()
 //
 // Description:
 //   If called as a module, moves/translates all children right (in the X+ direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -259,14 +262,15 @@
 // Usage: As Module
 //   fwd(y) CHILDREN;
 // Usage: Translate Points
 //   pts = fwd(y, p);
 // Usage: Get Translation Matrix
 //   mat = fwd(y);
 //
+// Synopsis: Translates children forwards (Y-).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), left(), right(), back(), down(), up()
 //
 // Description:
 //   If called as a module, moves/translates all children forward (in the Y- direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -302,14 +306,15 @@
 // Usage: As Module
 //   back(y) CHILDREN;
 // Usage: Translate Points
 //   pts = back(y, p);
 // Usage: Get Translation Matrix
 //   mat = back(y);
 //
+// Synopsis: Translates children backwards (Y+).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), left(), right(), fwd(), down(), up()
 //
 // Description:
 //   If called as a module, moves/translates all children back (in the Y+ direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -355,14 +360,15 @@
 // Usage: As Module
 //   down(z) CHILDREN;
 // Usage: Translate Points
 //   pts = down(z, p);
 // Usage: Get Translation Matrix
 //   mat = down(z);
 //
+// Synopsis: Translates children downwards (Z-).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), left(), right(), fwd(), back(), up()
 //
 // Description:
 //   If called as a module, moves/translates all children down (in the Z- direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -396,14 +402,15 @@
 // Usage: As Module
 //   up(z) CHILDREN;
 // Usage: Translate Points
 //   pts = up(z, p);
 // Usage: Get Translation Matrix
 //   mat = up(z);
 //
+// Synopsis: Translates children upwards (Z+).
 // Topics: Affine, Matrices, Transforms, Translation
 // See Also: move(), left(), right(), fwd(), back(), down()
 //
 // Description:
 //   If called as a module, moves/translates all children up (in the Z+ direction) by the given amount.
 //   If called as a function with the `p` argument, returns the translated point or list of points.
 //   If called as a function without the `p` argument, returns an affine3d translation matrix.
@@ -463,14 +470,15 @@
 //   pts = rot([a], from=, to=, p=, [reverse=]);
 // Usage: As a Function to return a transform matrix
 //   M = rot(a, [cp=], [reverse=]);
 //   M = rot([X,Y,Z], [cp=], [reverse=]);
 //   M = rot(a, v, [cp=], [reverse=]);
 //   M = rot(from=, to=, [a=], [reverse=]);
 //
+// Synopsis: Rotates children in various ways.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: xrot(), yrot(), zrot()
 //
 // Description:
 //   This is a shorthand version of the built-in `rotate()`, and operates similarly, with a few additional capabilities.
 //   You can specify the rotation to perform in one of several ways:
 //   * `rot(30)` or `rot(a=30)` rotates 30 degrees around the Z axis.
@@ -558,14 +566,15 @@
 // Usage: As Module
 //   xrot(a, [cp=]) CHILDREN;
 // Usage: As a function to rotate points
 //   rotated = xrot(a, p, [cp=]);
 // Usage: As a function to return rotation matrix
 //   mat = xrot(a, [cp=]);
 //
+// Synopsis: Rotates children around the X axis using the right-hand rule.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), yrot(), zrot()
 //
 // Description:
 //   Rotates around the X axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.
 //   * Called as a module, rotates all children.
 //   * Called as a function with a `p` argument containing a point, returns the rotated point.
@@ -604,14 +613,15 @@
 // Usage: As Module
 //   yrot(a, [cp=]) CHILDREN;
 // Usage: Rotate Points
 //   rotated = yrot(a, p, [cp=]);
 // Usage: Get Rotation Matrix
 //   mat = yrot(a, [cp=]);
 //
+// Synopsis: Rotates children around the Y axis using the right-hand rule.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), zrot()
 //
 // Description:
 //   Rotates around the Y axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.
 //   * Called as a module, rotates all children.
 //   * Called as a function with a `p` argument containing a point, returns the rotated point.
@@ -650,14 +660,15 @@
 // Usage: As Module
 //   zrot(a, [cp=]) CHILDREN;
 // Usage: As Function to rotate points
 //   rotated = zrot(a, p, [cp=]);
 // Usage: As Function to return rotation matrix
 //   mat = zrot(a, [cp=]);
 //
+// Synopsis: Rotates children around the Z axis using the right-hand rule.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot()
 //
 // Description:
 //   Rotates around the Z axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.
 //   * Called as a module, rotates all children.
 //   * Called as a function with a `p` argument containing a point, returns the rotated point.
@@ -701,14 +712,15 @@
 // Usage: As Module
 //   scale(SCALAR) CHILDREN;
 //   scale([X,Y,Z]) CHILDREN;
 // Usage: Scale Points
 //   pts = scale(v, p, [cp=]);
 // Usage: Get Scaling Matrix
 //   mat = scale(v, [cp=]);
+// Synopsis: Scales children arbitrarily.
 // Topics: Affine, Matrices, Transforms, Scaling
 // See Also: xscale(), yscale(), zscale()
 // Description:
 //   Scales by the [X,Y,Z] scaling factors given in `v`.  If `v` is given as a scalar number, all axes are scaled uniformly by that amount.
 //   * Called as the built-in module, scales all children.
 //   * Called as a function with a point in the `p` argument, returns the scaled point.
 //   * Called as a function with a list of points in the `p` argument, returns the list of scaled points.
@@ -744,22 +756,22 @@
             * affine3d_translate(point3d(-cp))
     )
     p==_NO_ARG? m : apply(m, p) ;
 
 
 // Function&Module: xscale()
 //
-//
 // Usage: As Module
 //   xscale(x, [cp=]) CHILDREN;
 // Usage: Scale Points
 //   scaled = xscale(x, p, [cp=]);
 // Usage: Get Affine Matrix
 //   mat = xscale(x, [cp=]);
 //
+// Synopsis: Scales children along the X axis.
 // Topics: Affine, Matrices, Transforms, Scaling
 // See Also: scale(), yscale(), zscale()
 //
 // Description:
 //   Scales along the X axis by the scaling factor `x`.
 //   * Called as the built-in module, scales all children.
 //   * Called as a function with a point in the `p` argument, returns the scaled point.
@@ -806,14 +818,15 @@
 // Usage: As Module
 //   yscale(y, [cp=]) CHILDREN;
 // Usage: Scale Points
 //   scaled = yscale(y, p, [cp=]);
 // Usage: Get Affine Matrix
 //   mat = yscale(y, [cp=]);
 //
+// Synopsis: Scales children along the Y axis.
 // Topics: Affine, Matrices, Transforms, Scaling
 // See Also: scale(), xscale(), zscale()
 //
 // Description:
 //   Scales along the Y axis by the scaling factor `y`.
 //   * Called as the built-in module, scales all children.
 //   * Called as a function with a point in the `p` argument, returns the scaled point.
@@ -860,14 +873,15 @@
 // Usage: As Module
 //   zscale(z, [cp=]) CHILDREN;
 // Usage: Scale Points
 //   scaled = zscale(z, p, [cp=]);
 // Usage: Get Affine Matrix
 //   mat = zscale(z, [cp=]);
 //
+// Synopsis: Scales children along the Z axis.
 // Topics: Affine, Matrices, Transforms, Scaling
 // See Also: scale(), xscale(), yscale()
 //
 // Description:
 //   Scales along the Z axis by the scaling factor `z`.
 //   * Called as the built-in module, scales all children.
 //   * Called as a function with a point in the `p` argument, returns the scaled point.
@@ -916,14 +930,15 @@
 // Function&Module: mirror()
 // Usage: As Module
 //   mirror(v) CHILDREN;
 // Usage: As Function
 //   pt = mirror(v, p);
 // Usage: Get Reflection/Mirror Matrix
 //   mat = mirror(v);
+// Synopsis: Reflects children across an arbitrary plane.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: xflip(), yflip(), zflip()
 // Description:
 //   Mirrors/reflects across the plane or line whose normal vector is given in `v`.
 //   * Called as the built-in module, mirrors all children across the line/plane.
 //   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.
 //   * Called as a function with a list of points in the `p` argument, returns the list of points, with each one mirrored across the line/plane.
@@ -987,14 +1002,15 @@
 // Usage: As Module
 //   xflip([x=]) CHILDREN;
 // Usage: As Function
 //   pt = xflip(p, [x]);
 // Usage: Get Affine Matrix
 //   mat = xflip([x=]);
 //
+// Synopsis: Reflects children across the YZ plane.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: mirror(), yflip(), zflip()
 //
 // Description:
 //   Mirrors/reflects across the origin [0,0,0], along the X axis.  If `x` is given, reflects across [x,0,0] instead.
 //   * Called as the built-in module, mirrors all children across the line/plane.
 //   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.
@@ -1041,14 +1057,15 @@
 // Usage: As Module
 //   yflip([y=]) CHILDREN;
 // Usage: As Function
 //   pt = yflip(p, [y]);
 // Usage: Get Affine Matrix
 //   mat = yflip([y=]);
 //
+// Synopsis: Reflects children across the XZ plane.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: mirror(), xflip(), zflip()
 //
 // Description:
 //   Mirrors/reflects across the origin [0,0,0], along the Y axis.  If `y` is given, reflects across [0,y,0] instead.
 //   * Called as the built-in module, mirrors all children across the line/plane.
 //   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.
@@ -1095,14 +1112,15 @@
 // Usage: As Module
 //   zflip([z=]) CHILDREN;
 // Usage: As Function
 //   pt = zflip(p, [z]);
 // Usage: Get Affine Matrix
 //   mat = zflip([z=]);
 //
+// Synopsis: Reflects children across the XY plane.
 // Topics: Affine, Matrices, Transforms, Reflection, Mirroring
 // See Also: mirror(), xflip(), yflip()
 //
 // Description:
 //   Mirrors/reflects across the origin [0,0,0], along the Z axis.  If `z` is given, reflects across [0,0,z] instead.
 //   * Called as the built-in module, mirrors all children across the line/plane.
 //   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.
@@ -1150,14 +1168,15 @@
 // Usage: As function to remap points
 //   transformed = frame_map(v1, v2, v3, p=points, [reverse=]);
 // Usage: As function to return a transformation matrix:
 //   map = frame_map(v1, v2, v3, [reverse=]);
 //   map = frame_map(x=VECTOR1, y=VECTOR2, [reverse=]);
 //   map = frame_map(x=VECTOR1, z=VECTOR2, [reverse=]);
 //   map = frame_map(y=VECTOR1, z=VECTOR2, [reverse=]);
+// Synopsis: Rotates and possibly skews children from one frame of reference to another.
 // Topics: Affine, Matrices, Transforms, Rotation
 // See Also: rot(), xrot(), yrot(), zrot()
 // Description:
 //   Maps one coordinate frame to another.  You must specify two or
 //   three of `x`, `y`, and `z`.  The specified axes are mapped to the vectors you supplied, so if you
 //   specify x=[1,1] then the x axis will be mapped to the line y=x.  If you
 //   give two inputs, the third vector is mapped to the appropriate normal to maintain a right hand
@@ -1230,20 +1249,21 @@
    multmatrix(frame_map(x,y,z,reverse=reverse))
        children();
 }
 
 
 // Function&Module: skew()
 // Usage: As Module
-//   skew([sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]) CHILDREN;
+//   skew([sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]) CHILDREN;
 // Usage: As Function
-//   pts = skew(p, [sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]);
+//   pts = skew(p, [sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]);
 // Usage: Get Affine Matrix
-//   mat = skew([sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]);
+//   mat = skew([sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]);
 // Topics: Affine, Matrices, Transforms, Skewing
+// Synopsis: Skews children along various axes.
 //
 // Description:
 //   Skews geometry by the given skew factors.
 //   * Called as the built-in module, skews all children.
 //   * Called as a function with a point in the `p` argument, returns the skewed point.
 //   * Called as a function with a list of points in the `p` argument, returns the list of skewed points.
 //   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the skewed patch.
@@ -1255,16 +1275,24 @@
 //   ---
 //   sxy = Skew factor multiplier for skewing along the X axis as you get farther from the Y axis.  Default: 0
 //   sxz = Skew factor multiplier for skewing along the X axis as you get farther from the Z axis.  Default: 0
 //   syx = Skew factor multiplier for skewing along the Y axis as you get farther from the X axis.  Default: 0
 //   syz = Skew factor multiplier for skewing along the Y axis as you get farther from the Z axis.  Default: 0
 //   szx = Skew factor multiplier for skewing along the Z axis as you get farther from the X axis.  Default: 0
 //   szy = Skew factor multiplier for skewing along the Z axis as you get farther from the Y axis.  Default: 0
+//   axy = Angle to skew along the X axis as you get farther from the Y axis.
+//   axz = Angle to skew along the X axis as you get farther from the Z axis.
+//   ayx = Angle to skew along the Y axis as you get farther from the X axis.
+//   ayz = Angle to skew along the Y axis as you get farther from the Z axis.
+//   azx = Angle to skew along the Z axis as you get farther from the X axis.
+//   azy = Angle to skew along the Z axis as you get farther from the Y axis.
 // Example(2D): Skew along the X axis in 2D.
 //   skew(sxy=0.5) square(40, center=true);
+// Example(2D): Skew along the X axis by 30º in 2D.
+//   skew(axy=30) square(40, center=true);
 // Example(2D): Skew along the Y axis in 2D.
 //   skew(syx=0.5) square(40, center=true);
 // Example: Skew along the X axis in 3D as a factor of Y coordinate.
 //   skew(sxy=0.5) cube(40, center=true);
 // Example: Skew along the X axis in 3D as a factor of Z coordinate.
 //   skew(sxz=0.5) cube(40, center=true);
 // Example: Skew along the Y axis in 3D as a factor of X coordinate.
@@ -1280,31 +1308,51 @@
 // Example(2D): Calling as a 2D Function
 //   pts = skew(p=square(40,center=true), sxy=0.5);
 //   color("yellow") stroke(pts, closed=true);
 //   color("blue") move_copies(pts) circle(d=3, $fn=8);
 // Example(FlatSpin,VPD=175): Calling as a 3D Function
 //   pts = skew(p=path3d(square(40,center=true)), szx=0.5, szy=0.3);
 //   stroke(pts,closed=true,dots=true,dots_color="blue");
-module skew(p, sxy=0, sxz=0, syx=0, syz=0, szx=0, szy=0)
+module skew(p, sxy, sxz, syx, syz, szx, szy, axy, axz, ayx, ayz, azx, azy)
 {
     req_children($children);          
-    assert(is_undef(p), "Module form `skew()` does not accept p= argument.")
-    multmatrix(
-        affine3d_skew(sxy=sxy, sxz=sxz, syx=syx, syz=syz, szx=szx, szy=szy)
-    ) children();
-}
-
-function skew(p=_NO_ARG, sxy=0, sxz=0, syx=0, syz=0, szx=0, szy=0) =
-    assert(is_finite(sxy))
-    assert(is_finite(sxz))
-    assert(is_finite(syx))
-    assert(is_finite(syz))
-    assert(is_finite(szx))
-    assert(is_finite(szy))
+    assert(is_undef(p), "Module form `skew()` does not accept p= argument.");
+    mat = skew(
+        sxy=sxy, sxz=sxz, syx=syx, syz=syz, szx=szx, szy=szy,
+        axy=axy, axz=axz, ayx=ayx, ayz=ayz, azx=azx, azy=azy
+    );
+    multmatrix(mat) children();
+}
+
+function skew(p=_NO_ARG, sxy, sxz, syx, syz, szx, szy, axy, axz, ayx, ayz, azx, azy) =
+    assert(num_defined([sxy,axy]) < 2)
+    assert(num_defined([sxz,axz]) < 2)
+    assert(num_defined([syx,ayx]) < 2)
+    assert(num_defined([syz,ayz]) < 2)
+    assert(num_defined([szx,azx]) < 2)
+    assert(num_defined([szy,azy]) < 2)
+    assert(sxy==undef || is_finite(sxy))
+    assert(sxz==undef || is_finite(sxz))
+    assert(syx==undef || is_finite(syx))
+    assert(syz==undef || is_finite(syz))
+    assert(szx==undef || is_finite(szx))
+    assert(szy==undef || is_finite(szy))
+    assert(axy==undef || is_finite(axy))
+    assert(axz==undef || is_finite(axz))
+    assert(ayx==undef || is_finite(ayx))
+    assert(ayz==undef || is_finite(ayz))
+    assert(azx==undef || is_finite(azx))
+    assert(azy==undef || is_finite(azy))
     let(
+        sxy = is_num(sxy)? sxy : is_num(axy)? tan(axy) : 0,
+        sxz = is_num(sxz)? sxz : is_num(axz)? tan(axz) : 0,
+        syx = is_num(syx)? syx : is_num(ayx)? tan(ayx) : 0,
+        syz = is_num(syz)? syz : is_num(ayz)? tan(ayz) : 0,
+        szx = is_num(szx)? szx : is_num(azx)? tan(azx) : 0,
+        szy = is_num(szy)? szy : is_num(azy)? tan(azy) : 0,
         m = affine3d_skew(sxy=sxy, sxz=sxz, syx=syx, syz=syz, szx=szx, szy=szy)
     )
     p==_NO_ARG? m : apply(m, p);
 
 
 // Section: Applying transformation matrices to data
 
@@ -1331,23 +1379,29 @@
 
 
 
 // Function: apply()
 // Usage:
 //   pts = apply(transform, points);
 // Topics: Affine, Matrices, Transforms
+// Synopsis: Applies a transformation matrix to a point, list of points, array of points, or VNF.
 // Description:
 //   Applies the specified transformation matrix `transform` to a point, point list, bezier patch or VNF.
 //   When `points` contains 2D or 3D points the transform matrix may be a 4x4 affine matrix or a 3x4 
 //   matrix&mdash;the 4x4 matrix with its final row removed.  When the data is 2D the matrix must not operate on the Z axis,
 //   except possibly by scaling it.  When points contains 2D data you can also supply the transform as
 //   a 3x3 affine transformation matrix or the corresponding 2x3 matrix with the last row deleted.
 //   .
 //   Any other combination of matrices will produce an error, including acting with a 2D matrix (3x3) on 3D data.
 //   The output of apply is always the same dimension as the input&mdash;projections are not supported.
+//   .
+//   Note that a matrix with a negative determinant such as any mirror reflection flips the orientation of faces.
+//   If the transform matrix is square then apply() checks the determinant and if it is negative, apply() reverses the face order so that
+//   the transformed VNF has faces with the same winding direction as the original VNF.  This adjustment applies
+//   only to VNFs, not to beziers or point lists.  
 // Arguments:
 //   transform = The 2D (3x3 or 2x3) or 3D (4x4 or 3x4) transformation matrix to apply.
 //   points = The point, point list, bezier patch, or VNF to apply the transformation to.
 // Example(3D):
 //   path1 = path3d(circle(r=40));
 //   tmat = xrot(45);
 //   path2 = apply(tmat, path1);
@@ -1363,15 +1417,15 @@
 //   path1 = circle(r=40);
 //   tmat = rot(30) * back(15) * scale([1.5,0.5,1]);
 //   path2 = apply(tmat, path1);
 //   #stroke(path1,closed=true);
 //   stroke(path2,closed=true);
 function apply(transform,points) =
     points==[] ? []
-  : is_vector(points) ? _apply(transform, [points])[0]     // point
+  : is_vector(points) ? _apply(transform, [points])[0]    // point
   : is_vnf(points) ?                                      // vnf
         let(
             newvnf = [_apply(transform, points[0]), points[1]],
             reverse = (len(transform)==len(transform[0])) && determinant(transform)<0
         )
         reverse ? vnf_reverse_faces(newvnf) : newvnf
   : is_list(points) && is_list(points[0]) && is_vector(points[0][0])    // bezier patch
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/trigonometry.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/trigonometry.scad`

 * *Files 0% similar despite different names*

```diff
@@ -247,15 +247,15 @@
 // Function: adj_opp_to_hyp()
 // Alias: opp_adj_to_hyp()
 // Usage:
 //   hyp = adj_opp_to_hyp(adj,opp);
 //   hyp = opp_adj_to_hyp(opp,adj);
 // Topics: Geometry, Trigonometry, Triangles
 // Description:
-//   Given the length of the adjacent and opposite sides of a right triangle, returns the length of thee hypotenuse.
+//   Given the length of the adjacent and opposite sides of a right triangle, returns the length of the hypotenuse.
 // Arguments:
 //   adj = The length of the side of the right triangle that is adjacent to the primary angle.
 //   opp = The length of the side of the right triangle that is opposite from the primary angle.
 // Example:
 //   hyp = adj_opp_to_hyp(3,4);  // Returns: 5
 function adj_opp_to_hyp(adj,opp) =
     assert(is_finite(opp) && opp>=0 && is_finite(adj) && adj>=0,
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/tripod_mounts.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/tripod_mounts.scad`

 * *Files 20% similar despite different names*

```diff
@@ -6,14 +6,16 @@
 //   include <BOSL2/tripod_mounts.scad>
 // FileGroup: Parts
 // FileSummary: Tripod mount plates: RC2
 //////////////////////////////////////////////////////////////////////////////////////////////
 
 
 // Module: manfrotto_rc2_plate()
+// Synopsis: Creates a Manfrotto RC2 tripod quick release mount plate.
+// Topics: Parts
 // Usage:
 //   manfrotto_rc2_plate([chamfer],[anchor],[orient],[spin]) [ATTACHMENTS];
 // Description:
 //   Creates a Manfrotto RC2 quick release mount plate to mount to a tripod.  The chamfer argument
 //   lets you control whether the model edges are chamfered.  By default all edges are chamfered,
 //   but you can set it to "bot" to chamfer only the bottom, so that connections to a model larger
 //   than the plate doin't have a V-groove at the junction.  The plate is 10.5 mm thick.
@@ -22,15 +24,15 @@
 // Examples:
 //   manfrotto_rc2_plate();
 //   manfrotto_rc2_plate("bot");
 module manfrotto_rc2_plate(chamfer="all",anchor,orient,spin)
 {
   chsize=0.5;
 
-  assert(in_list(chamfer, ["bot","bottom","all","none"]), "chamfer must be \"all\", \"bottom\", \"bot\", or \"none\"");
+  dummy = assert(in_list(chamfer, ["bot","bottom","all","none"]), "chamfer must be \"all\", \"bottom\", \"bot\", or \"none\"");
   chamf_top = chamfer=="all";
   chamf_bot = in_list(chamfer, ["bot","bottom","all"]);
 
   length = 52.5;
   innerlen=43;
   
   topwid = 37.4;
@@ -68,39 +70,41 @@
   facet = [
             back(-left_top,select(pts,-3)),
             each fwd(1.5,select(pts,-2,-1)),
             [-10,-left_top+select(pts,-1).y],
             left(10,back(-flat_height,select(pts,-3)))
           ];
 
-  tag_scope()
   attachable(anchor,spin,orient,size=[botwid,length,thickness],size2=[topwid,length],shift=[.64115/2,0]){
+    tag_scope()
     down(thickness/2)
     diff()
       linear_sweep(pts,h=length,convexity=4,orient=FWD,anchor=FWD){
-          zflip_copy()
-            down(.01)fwd(.01)left(.01)position(LEFT+FRONT+BOT)
-              cuboid([corner_space,(length-innerlen)/2,thickness+.02], chamfer=-chsize, $tag="remove",
-                     orient=FWD,anchor=TOP+LEFT+FWD,edges=chamf_top?"ALL":TOP);
-          fwd(left_top)position(LEFT+BACK)linear_sweep(h=cutout_len,facet,convexity=4,$tag="remove",anchor=RIGHT+BACK);
+          tag("remove"){
+            zflip_copy()
+              down(.01)fwd(.01)left(.01)position(LEFT+FRONT+BOT)
+                cuboid([corner_space,(length-innerlen)/2,thickness+.02], chamfer=-chsize,
+                       orient=FWD,anchor=TOP+LEFT+FWD,edges=chamf_top?"ALL":TOP);
+            fwd(left_top)position(LEFT+BACK)linear_sweep(h=cutout_len,facet,convexity=4,anchor=RIGHT+BACK);
+          }
           if (chamf_bot){
-            edge_mask(FRONT+LEFT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(FRONT+RIGHT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(FRONT+TOP)chamfer_edge_mask(length,chsize,$tag="remove");        
-            edge_mask(FRONT+BOT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(TOP+RIGHT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(BOT+RIGHT)chamfer_edge_mask(length,chsize,$tag="remove");
+            edge_mask(FRONT+LEFT)chamfer_edge_mask(length,chsize);
+            edge_mask(FRONT+RIGHT)chamfer_edge_mask(length,chsize);
+            edge_mask(FRONT+TOP)chamfer_edge_mask(length,chsize);        
+            edge_mask(FRONT+BOT)chamfer_edge_mask(length,chsize);
+            edge_mask(TOP+RIGHT)chamfer_edge_mask(length,chsize);
+            edge_mask(BOT+RIGHT)chamfer_edge_mask(length,chsize);
             zflip_copy(){
-               right(corner_space)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize,$tag="remove");
-               down((length-innerlen)/2)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize,$tag="remove");
+               right(corner_space)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize);
+               down((length-innerlen)/2)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize);
             }
           }
           if (chamf_top){
-            edge_mask(BACK+LEFT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(BACK+RIGHT)chamfer_edge_mask(length,chsize,$tag="remove");
-            edge_mask(BACK+TOP)chamfer_edge_mask(length,chsize,$tag="remove");        
-            edge_mask(BACK+BOT)chamfer_edge_mask(length,chsize,$tag="remove");
+            edge_mask(BACK+LEFT) chamfer_edge_mask(length,chsize);
+            edge_mask(BACK+RIGHT) chamfer_edge_mask(length,chsize);
+            edge_mask(BACK+TOP) chamfer_edge_mask(length,chsize);        
+            edge_mask(BACK+BOT) chamfer_edge_mask(length,chsize);
           }
         }
     children();
     }
 }
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/turtle3d.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/turtle3d.scad`

 * *Files 1% similar despite different names*

```diff
@@ -16,14 +16,17 @@
 function _transpart(T) = [for(row=[0:2]) T[row][3]];
 
 // The non-translation part of a matrix
 function _rotpart(T) = [for(i=[0:3]) [for(j=[0:3]) j<3 || i==3 ? T[i][j] : 0]];
 
 
 // Function: turtle3d()
+// Synopsis: Extends [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) to 3d. Generates a 3D path or returns a list of transforms.
+// Topics: Shapes (3D), Path Generators (3D), Mini-Language
+// See Also: turtle()
 // Usage:
 //   turtle3d(commands, [state], [transforms], [full_state], [repeat])
 // Description:
 //   Like the classic two dimensional turtle, the 3d turtle flies through space following a sequence
 //   of turtle graphics commands to generate either a sequence of transformations (suitable for input
 //   to sweep) or a 3d path.  The turtle state keeps track of the position and orientation (including twist)
 //   and scale of the turtle.  By default the turtle begins pointing along the X axis with the "right" direction
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/utility.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/utility.scad`

 * *Files 2% similar despite different names*

```diff
@@ -693,24 +693,27 @@
 // Topics: Argument Handling
 // See Also: get_anchor(), get_radius(), force_list()
 // Description:
 //   This is expands a scalar or a list with length less than 3 to a length 3 vector in the
 //   same way that OpenSCAD expands short vectors in some contexts, e.g. cube(10) or rotate([45,90]).  
 //   If `v` is a scalar, and `dflt==undef`, returns `[v, v, v]`.
 //   If `v` is a scalar, and `dflt!=undef`, returns `[v, dflt, dflt]`.
-//   If `v` is a vector, returns the first 3 items, with any missing values replaced by `dflt`.
+//   If `v` is a vector and dflt is defined, returns the first 3 items, with any missing values replaced by `dflt`.
+//   If `v` is a vector and dflt is undef, returns the first 3 items, with any missing values replaced by 0.
 //   If `v` is `undef`, returns `undef`.
 // Arguments:
 //   v = Value to return vector from.
 //   dflt = Default value to set empty vector parts from.
 // Example:
 //   vec = scalar_vec3(undef);      // Returns: undef
 //   vec = scalar_vec3(10);         // Returns: [10,10,10]
 //   vec = scalar_vec3(10,1);       // Returns: [10,1,1]
 //   vec = scalar_vec3([10,10],1);  // Returns: [10,10,1]
+//   vec = scalar_vec3([10,10]);    // Returns: [10,10,0]
+//   vec = scalar_vec3([10]);       // Returns: [10,0,0]
 function scalar_vec3(v, dflt) =
     is_undef(v)? undef :
     is_list(v)? [for (i=[0:2]) default(v[i], default(dflt, 0))] :
     !is_undef(dflt)? [v,dflt,dflt] : [v,v,v];
 
 
 // Function: segs()
@@ -797,14 +800,26 @@
 // Example:
 //   module foo() { no_module(); }
 module no_module() {
     assert(false, str("You called ",parent_module(1),"() as a module but it is available only as a function"));
 }    
   
 
+// Module: deprecate()
+// Usage:
+//   deprecate(new_name);
+// Description:
+//   Display info that the current module is deprecated and you should switch to a new name
+// Arguments:
+//   new_name = name of the new module that replaces the old one
+module deprecate(new_name)
+{
+   echo(str("***** Module ",parent_module(1),"() has been replaced by ",new_name,"() and will be removed in a future version *****"));
+}   
+
 
 // Section: Testing Helpers
 
 
 function _valstr(x) =
     is_string(x)? str("\"",str_replace_char(x, "\"", "\\\""),"\"") :
     is_list(x)? str("[",str_join([for (xx=x) _valstr(xx)],","),"]") :
@@ -916,15 +931,15 @@
                 }
             }
         }
     }
 }
 
 
-// Section: Looping Helpers
+// Section: C-Style For Loop Helpers
 //   You can use a list comprehension with a C-style for loop to iteratively make a calculation.
 //   .
 //   The syntax is: `[for (INIT; CONDITION; NEXT) RETVAL]` where:
 //   - INIT is zero or more `let()` style assignments that are evaluated exactly one time, before the first loop.
 //   - CONDITION is an expression evaluated at the start of each loop.  If true, continues with the loop.
 //   - RETVAL is an expression that returns a list item for each loop.
 //   - NEXT is one or more `let()` style assignments that is evaluated at the end of each loop.
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/vectors.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/vectors.scad`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 //////////////////////////////////////////////////////////////////////
 // LibFile: vectors.scad
 //   This file provides some mathematical operations that apply to each
-//   entry in a vector.  It provides normalizatoin and angle computation, and
+//   entry in a vector.  It provides normalization and angle computation, and
 //   it provides functions for searching lists of vectors for matches to
 //   a given vector.  
 // Includes:
 //   include <BOSL2/std.scad>
 // FileGroup: Math
 // FileSummary: Vector arithmetic, angle, and searching.
 // FileFootnotes: STD=Included in std.scad
@@ -280,14 +280,34 @@
               w2 = point3d(v2/norm(v2)),
               w3 = (norm(w1-w2) > eps && norm(w1+w2) > eps) ? w2 
                    : (norm(v_abs(w2)-UP) > eps)? UP 
                    : RIGHT
             ) unit(cross(w1,w3));
 
 
+// Function: vector_bisect()
+// Usage:
+//   newv = vector_bisect(v1,v2);
+// Description:
+//   Returns a unit vector that exactly bisects the minor angle between two given vectors.
+//   If given two vectors that are directly opposed, returns `undef`.
+function vector_bisect(v1,v2) =
+    assert(is_vector(v1))
+    assert(is_vector(v2))
+    assert(!approx(norm(v1),0), "Zero length vector.")
+    assert(!approx(norm(v2),0), "Zero length vector.")
+    assert(len(v1)==len(v2), "Vectors are of different sizes.")
+    let( v1 = unit(v1), v2 = unit(v2) )
+    approx(v1,-v2)? undef :
+    let(
+        axis = vector_axis(v1,v2),
+        ang = vector_angle(v1,v2),
+        v3 = rot(ang/2, v=axis, p=v1)
+    ) v3;
+
 
 
 // Section: Vector Searching
 
 
 // Function: pointlist_bounds()
 // Usage:
@@ -372,15 +392,15 @@
 //   queries = [for(i=[3,7],j=[3,7]) [i,j]];
 //   search_ind = vector_search(queries, points, 1);
 //   move_copies(points) circle(r=.08);
 //   for(i=idx(queries)){
 //       color("blue")stroke(move(queries[i],circle(r=1)), closed=true, width=.08);
 //       color("red") move_copies(select(points, search_ind[i])) circle(r=.08);
 //   }
-// Example: when a series of search with different radius are needed, its is faster to pre-compute the tree
+// Example: when a series of searches with different radius are needed, its is faster to pre-compute the tree
 //   $fn=32;
 //   k = 2000;
 //   points = list_to_matrix(rands(0,10,k*2),2,seed=13333);
 //   queries1 = [for(i=[3,7]) [i,i]];
 //   queries2 = [for(i=[3,7]) [10-i,i]];
 //   r1 = 1;
 //   r2 = .7;
@@ -415,16 +435,16 @@
         dim    = tgpts ? len(target[0]) : len(target[0][0]),
         simple = is_vector(query, dim)
         )
     assert( simple || is_matrix(query,undef,dim), 
             "The query points should be a list of points compatible with the target point list.")
     tgpts 
     ?   len(target)<=400
-        ?   simple ? [for(i=idx(target)) if(norm(target[i]-query)<r) i ] :
-            [for(q=query) [for(i=idx(target)) if(norm(target[i]-q)<r) i ] ]
+        ?   simple ? [for(i=idx(target)) if(norm(target[i]-query)<=r) i ] :
+            [for(q=query) [for(i=idx(target)) if(norm(target[i]-q)<=r) i ] ]
         :   let( tree = _bt_tree(target, count(len(target)), leafsize=25) )
             simple ? _bt_search(query, r, target, tree) :
             [for(q=query) _bt_search(q, r, target, tree)]
     :   simple ?  _bt_search(query, r, target[0], target[1]) :
         [for(q=query) _bt_search(q, r, target[0], target[1])];
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/version.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/version.scad`

 * *Files 15% similar despite different names*

```diff
@@ -12,55 +12,59 @@
 BOSL_VERSION = [2,0,652];
 
 
 // Section: BOSL Library Version Functions
 
 
 // Function: bosl_version()
+// Synopsis: Returns the BOSL2 version as a list.
+// Topics: Versioning
+// See Also: bosl_version_num(), bosl_version_str(), bosl_required()
 // Usage:
 //   ver = bosl_version();
-// Topics: Versioning
 // Description:
 //   Returns a list with three integer elements, [MAJOR,MINOR,REV],
 //   representing the Major, Minor, and Build Revision numbers.
 //   For example, version 2.1.43 will be returned as `[2,1,43]`.
-// See Also: bosl_version_num(), bosl_version_str()
 function bosl_version() = BOSL_VERSION;
 
 
 // Function: bosl_version_num()
+// Synopsis: Returns the BOSL2 version as a float.
+// Topics: Versioning
+// See Also: bosl_version(), bosl_version_str(), bosl_required()
 // Usage:
 //   ver = bosl_version_num();
-// Topics: Versioning
 // Description:
 //   Returns a floating point number of the version, formatted like M.mmrrrr where M is the major version number,
 //   each m is a zero-padded digit of the minor version number, and each r is a zero-padded digit of the build
 //   revision number.  For example, version 2.1.43 will be returned as `2.010043`.
-// See Also: bosl_version(), bosl_version_str()
 function bosl_version_num() = version_to_num(BOSL_VERSION);
 
 
 // Function: bosl_version_str()
+// Synopsis: Returns the BOSL2 version as a string.
+// Topics: Versioning
+// See Also: bosl_version(), bosl_version_num(), bosl_required()
 // Usage:
 //   ver = bosl_version_str();
-// Topics: Versioning
 // Description:
 //   Returns a string of the version, formatted like "MAJOR.MINOR.REV".
 //   For example, version 2.1.43 will be returned as `"2.1.43"`.
-// See Also: bosl_version(), bosl_version_num()
 function bosl_version_str() = version_to_str(BOSL_VERSION);
 
 
 // Module: bosl_required()
+// Synopsis: Asserts that the current version of the library is at least the given version.
+// Topics: Versioning
+// See Also: version_to_num(), version_to_str(), version_to_list(), version_cmp()
 // Usage:
 //   bosl_required(version);
-// Topics: Versioning
 // Description:
 //   Given a version as a list, number, or string, asserts that the currently installed BOSL library is at least the given version.
-// See Also: version_to_num(), version_to_str(), version_to_list(), version_cmp()
 // Arguments:
 //   version = version required
 module bosl_required(version) {
     no_children($children);
     assert(
         version_cmp(bosl_version(), version) >= 0,
         str(
@@ -81,20 +85,21 @@
         _out = numend? concat(_out, [_num]) : _out,
         _num = numend? 0 : (10*_num + cval)
     )
     _version_split_str(x, _i=_i+1, _out=_out, _num=_num);
 
 
 // Function: version_to_list()
+// Synopsis: Splits a version into a list of integer version parts.
+// Topics: Versioning
+// See Also: version_to_num(), version_to_str(), version_cmp(), bosl_required()
 // Usage:
 //   ver = version_to_list(x);
-// Topics: Versioning
 // Description:
 //   Given a version string, number, or list, returns the list of version integers [MAJOR,MINOR,REVISION].
-// See Also: version_to_num(), version_to_str(), version_cmp(), bosl_required()
 // Arguments:
 //   x = version to convert
 // Example:
 //   v1 = version_to_list("2.1.43");  // Returns: [2,1,43]
 //   v2 = version_to_list(2.120234);  // Returns: [2,12,234]
 //   v3 = version_to_list([2,3,4]);   // Returns: [2,3,4]
 //   v4 = version_to_list([2,3,4,5]); // Returns: [2,3,4]
@@ -102,59 +107,62 @@
     is_list(version)? [default(version[0],0), default(version[1],0), default(version[2],0)] :
     is_string(version)? _version_split_str(version) :
     is_num(version)? [floor(version), floor(version*100%100), floor(version*1000000%10000+0.5)] :
     assert(is_num(version) || is_vector(version) || is_string(version)) 0;
 
 
 // Function: version_to_str()
+// Synopsis: Coerces a version into a standard version string.
+// Topics: Versioning
+// See Also: version_to_num(), version_to_list(), version_cmp(), bosl_required()
 // Usage:
 //   str = version_to_str(version);
-// Topics: Versioning
 // Description:
 //   Takes a version string, number, or list, and returns the properly formatter version string for it.
-// See Also: version_to_num(), version_to_list(), version_cmp(), bosl_required()
 // Arguments:
 //   version = version to convert
 // Example:
 //   v1 = version_to_str([2,1,43]);  // Returns: "2.1.43"
 //   v2 = version_to_str(2.010043);  // Returns: "2.1.43"
 //   v3 = version_to_str(2.340789);  // Returns: "2.34.789"
 //   v4 = version_to_str("2.3.89");  // Returns: "2.3.89"
 function version_to_str(version) =
     let(version = version_to_list(version))
     str(version[0],".",version[1],".",version[2]);
 
 
 // Function: version_to_num()
+// Synopsis: Coerces a version into a standard version float.
+// Topics: Versioning
+// See Also: version_cmp(), version_to_str(), version_to_list(), bosl_required()
 // Usage:
 //   str = version_to_num(version);
-// Topics: Versioning
 // Description:
 //   Takes a version string, number, or list, and returns the properly formatter version number for it.
-// See Also: version_cmp(), version_to_str(), version_to_list(), bosl_required()
 // Arguments:
 //   version = version to convert
 // Example:
 //   v1 = version_to_num([2,1,43]);   // Returns: 2.010043
 //   v2 = version_to_num([2,34,567]); // Returns: 2.340567
 //   v3 = version_to_num(2.120567);   // Returns: 2.120567
 //   v4 = version_to_num("2.6.79");   // Returns: 2.060079
 function version_to_num(version) =
     let(version = version_to_list(version))
     (version[0]*1000000 + version[1]*10000 + version[2])/1000000;
 
 
 // Function: version_cmp()
+// Synopsis: Compares two versions.
+// Topics: Versioning
+// See Also: version_to_num(), version_to_str(), version_to_list(), bosl_required()
 // Usage:
 //   cmp = version_cmp(a,b);
-// Topics: Versioning
 // Description:
 //   Given a pair of versions, in any combination of string, integer, or list, compares them, and returns the relative value of them.
 //   Returns an integer <0 if a<b.  Returns 0 if a==b.  Returns an integer >0 if a>b.
-// See Also: version_to_num(), version_to_str(), version_to_list(), bosl_required()
 // Example:
 //   cmp1 = version_cmp(2.010034, "2.1.33");  // Returns: >0
 //   cmp2 = version_cmp(2.010034, "2.1.34");  // Returns: 0
 //   cmp3 = version_cmp(2.010034, "2.1.35");  // Returns: <0
 function version_cmp(a,b) =
     let(
         a = version_to_list(a),
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/vnf.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/vnf.scad`

 * *Files 14% similar despite different names*

```diff
@@ -19,32 +19,35 @@
 //   first item is a list of vertex points, and the second is a list of face indices into the vertex
 //   list.  Each VNF is self contained, with face indices referring only to its own vertex list.
 //   You can construct a `polyhedron()` in parts by describing each part in a self-contained VNF, then
 //   merge the various VNFs to get the completed polyhedron vertex list and faces.
 
 /// Constant: EMPTY_VNF
 /// Description:
-///   The empty VNF data structure.  Equal to `[[],[]]`.  
+///   The empty VNF data structure.  Equal to `[[],[]]`.
 EMPTY_VNF = [[],[]];  // The standard empty VNF with no vertices or faces.
 
 
 // Function: vnf_vertex_array()
+// Synopsis: Returns a VNF structure from a rectangular vertex list.
+// Topics: VNF Generators, Lists
+// See Also: vnf_tri_array(), vnf_join(), vnf_from_polygons(), vnf_from_region()
 // Usage:
 //   vnf = vnf_vertex_array(points, [caps=], [cap1=], [cap2=], [style=], [reverse=], [col_wrap=], [row_wrap=]);
 // Description:
 //   Creates a VNF structure from a rectangular vertex list, by dividing the vertices into columns and rows,
 //   adding faces to tile the surface.  You can optionally have faces added to wrap the last column
 //   back to the first column, or wrap the last row to the first.  Endcaps can be added to either
 //   the first and/or last rows.  The style parameter determines how the quadrilaterals are divided into
 //   triangles.  The default style is an arbitrary, systematic subdivision in the same direction.  The "alt" style
 //   is the uniform subdivision in the other (alternate) direction.  The "min_edge" style picks the shorter edge to
 //   subdivide for each quadrilateral, so the division may not be uniform across the shape.  The "quincunx" style
 //   adds a vertex in the center of each quadrilateral and creates four triangles, and the "convex" and "concave" styles
 //   chooses the locally convex/concave subdivision.  Degenerate faces
-//   are not included in the output, but if this results in unused vertices they will still appear in the output.  
+//   are not included in the output, but if this results in unused vertices they will still appear in the output.
 // Arguments:
 //   points = A list of vertices to divide into columns and rows.
 //   ---
 //   caps = If true, add endcap faces to the first AND last rows.
 //   cap1 = If true, add an endcap face to the first row.
 //   cap2 = If true, add an endcap face to the last row.
 //   col_wrap = If true, add faces to connect the last column to the first.
@@ -124,18 +127,18 @@
 function vnf_vertex_array(
     points,
     caps, cap1, cap2,
     col_wrap=false,
     row_wrap=false,
     reverse=false,
     style="default"
-) = 
+) =
     assert(!(any([caps,cap1,cap2]) && !col_wrap), "col_wrap must be true if caps are requested")
     assert(!(any([caps,cap1,cap2]) && row_wrap), "Cannot combine caps with row_wrap")
-    assert(in_list(style,["default","alt","quincunx", "convex","concave", "min_edge"]))
+    assert(in_list(style,["default","alt","quincunx", "convex","concave", "min_edge","min_area"]))
     assert(is_matrix(points[0], n=3),"Point array has the wrong shape or points are not 3d")
     assert(is_consistent(points), "Non-rectangular or invalid point array")
     let(
         pts = flatten(points),
         pcnt = len(pts),
         rows = len(points),
         cols = len(points[0])
@@ -144,16 +147,16 @@
     let(
         cap1 = first_defined([cap1,caps,false]),
         cap2 = first_defined([cap2,caps,false]),
         colcnt = cols - (col_wrap?0:1),
         rowcnt = rows - (row_wrap?0:1),
         verts = [
             each pts,
-            if (style=="quincunx") 
-                for (r = [0:1:rowcnt-1], c = [0:1:colcnt-1]) 
+            if (style=="quincunx")
+                for (r = [0:1:rowcnt-1], c = [0:1:colcnt-1])
                    let(
                        i1 = ((r+0)%rows)*cols + ((c+0)%cols),
                        i2 = ((r+1)%rows)*cols + ((c+0)%cols),
                        i3 = ((r+1)%rows)*cols + ((c+1)%cols),
                        i4 = ((r+0)%rows)*cols + ((c+1)%cols)
                    )
                    mean([pts[i1], pts[i2], pts[i3], pts[i4]])
@@ -165,67 +168,83 @@
                each
                let(
                    i1 = ((r+0)%rows)*cols + ((c+0)%cols),
                    i2 = ((r+1)%rows)*cols + ((c+0)%cols),
                    i3 = ((r+1)%rows)*cols + ((c+1)%cols),
                    i4 = ((r+0)%rows)*cols + ((c+1)%cols),
                    faces =
-                        style=="quincunx"? 
+                        style=="quincunx"?
                           let(i5 = pcnt + r*colcnt + c)
                           [[i1,i5,i2],[i2,i5,i3],[i3,i5,i4],[i4,i5,i1]]
-                      : style=="alt"? 
+                      : style=="alt"?
                           [[i1,i4,i2],[i2,i4,i3]]
+                      : style=="min_area"?
+                          let(
+                               area42 = norm(cross(pts[i2]-pts[i1], pts[14]-pts[i1]))+norm(cross(pts[i4]-pts[i3], pts[i2]-pts[i3])),
+                               area13 = norm(cross(pts[i1]-pts[i4], pts[i3]-pts[i4]))+norm(cross(pts[i3]-pts[i2], pts[i1]-pts[i2])),
+                               minarea_edge = area42 < area13 + EPSILON
+                                 ? [[i1,i4,i2],[i2,i4,i3]]
+                                 : [[i1,i3,i2],[i1,i4,i3]]
+                          )
+                          minarea_edge
                       : style=="min_edge"?
                           let(
                                d42=norm(pts[i4]-pts[i2]),
                                d13=norm(pts[i1]-pts[i3]),
-                               shortedge = d42<d13+EPSILON ? [[i1,i4,i2],[i2,i4,i3]]
-                                                    : [[i1,i3,i2],[i1,i4,i3]]
+                               shortedge = d42<d13+EPSILON
+                                 ? [[i1,i4,i2],[i2,i4,i3]]
+                                 : [[i1,i3,i2],[i1,i4,i3]]
                           )
                           shortedge
-                      : style=="convex"?  
+                      : style=="convex"?
                           let(   // Find normal for 3 of the points.  Is the other point above or below?
                               n = (reverse?-1:1)*cross(pts[i2]-pts[i1],pts[i3]-pts[i1]),
-                              convexfaces = n==0 ? [[i1,i4,i3]]
-                                          : n*pts[i4] > n*pts[i1] ? [[i1,i4,i2],[i2,i4,i3]]
-                                                                  : [[i1,i3,i2],[i1,i4,i3]]
+                              convexfaces = n==0
+                                ? [[i1,i4,i3]]
+                                : n*pts[i4] > n*pts[i1]
+                                    ? [[i1,i4,i2],[i2,i4,i3]]
+                                    : [[i1,i3,i2],[i1,i4,i3]]
                           )
                           convexfaces
-                      : style=="concave"?  
+                      : style=="concave"?
                           let(   // Find normal for 3 of the points.  Is the other point above or below?
                               n = (reverse?-1:1)*cross(pts[i2]-pts[i1],pts[i3]-pts[i1]),
-                              concavefaces = n==0 ? [[i1,i4,i3]]
-                                          : n*pts[i4] <= n*pts[i1] ? [[i1,i4,i2],[i2,i4,i3]]
-                                                                  : [[i1,i3,i2],[i1,i4,i3]]
+                              concavefaces = n==0
+                                ? [[i1,i4,i3]]
+                                : n*pts[i4] <= n*pts[i1]
+                                    ? [[i1,i4,i2],[i2,i4,i3]]
+                                    : [[i1,i3,i2],[i1,i4,i3]]
                           )
                           concavefaces
                       : [[i1,i3,i2],[i1,i4,i3]],
-                   // remove degenerate faces 
+                   // remove degenerate faces
                    culled_faces= [for(face=faces)
-                       if (norm(verts[face[0]]-verts[face[1]])>EPSILON &&
-                           norm(verts[face[1]]-verts[face[2]])>EPSILON && 
-                           norm(verts[face[2]]-verts[face[0]])>EPSILON) 
+                       if (norm(cross(verts[face[1]]-verts[face[0]],
+                                      verts[face[2]]-verts[face[0]]))>EPSILON)
                            face
                    ],
                    rfaces = reverse? [for (face=culled_faces) reverse(face)] : culled_faces
                )
                rfaces,
         ]
     )
     [verts,allfaces];
 
 
 // Function: vnf_tri_array()
+// Synopsis: Returns a VNF from an array of points.
+// Topics: VNF Generators, Lists
+// See Also: vnf_vertex_array(), vnf_join(), vnf_from_polygons(), vnf_from_region()
 // Usage:
 //   vnf = vnf_tri_array(points, [row_wrap], [reverse])
 // Description:
-//   Produces a vnf from an array of points where each row length can differ from the adjacent rows by up to 2 in length.  This enables
+//   Produces a VNF from an array of points where each row length can differ from the adjacent rows by up to 2 in length.  This enables
 //   the construction of triangular VNF patches.  The resulting VNF can be wrapped along the rows by setting `row_wrap` to true.
 //   You cannot wrap columns: if you need to do that you'll need to merge two VNF arrays that share edges.  Degenerate faces
-//   are not included in the output, but if this results in unused vertices they will still appear in the output.  
+//   are not included in the output, but if this results in unused vertices they will still appear in the output.
 // Arguments:
 //   points = List of point lists for each row
 //   row_wrap = If true then add faces connecting the first row and last row.  These rows must differ by at most 2 in length.
 //   reverse = Set this to reverse the direction of the faces
 // Example(3D,NoAxes): Each row has one more point than the preceeding one.
 //   pts = [for(y=[1:1:10]) [for(x=[0:y-1]) [x,y,y]]];
 //   vnf = vnf_tri_array(pts);
@@ -252,15 +271,15 @@
 //   vnf_polyhedron(vnf);
 // Example(3D,NoAxes): Point count can change irregularly
 //   lens = [10,9,7,5,6,8,8,10];
 //   pts = [for(y=idx(lens)) lerpn([-lens[y],y,y],[lens[y],y,y],lens[y])];
 //   vnf = vnf_tri_array(pts);
 //   vnf_wireframe(vnf,width=0.1);
 //   color("red")move_copies(flatten(pts)) sphere(r=.15,$fn=9);
-function vnf_tri_array(points, row_wrap=false, reverse=false) = 
+function vnf_tri_array(points, row_wrap=false, reverse=false) =
     let(
        lens = [for(row=points) len(row)],
        rowstarts = [0,each cumsum(lens)],
        faces =
           [for(i=[0:1:len(points) - 1 - (row_wrap ? 0 : 1)]) each
             let(
                 rowstart = rowstarts[i],
@@ -293,59 +312,62 @@
               ] :
             assert(false,str("Unsupported row length difference of ",delta, " between row ",i," and ",(i+1)%len(points)))
           ],
        verts = flatten(points),
        culled_faces=
            [for(face=faces)
                if (norm(verts[face[0]]-verts[face[1]])>EPSILON &&
-                   norm(verts[face[1]]-verts[face[2]])>EPSILON && 
-                   norm(verts[face[2]]-verts[face[0]])>EPSILON) 
+                   norm(verts[face[1]]-verts[face[2]])>EPSILON &&
+                   norm(verts[face[2]]-verts[face[0]])>EPSILON)
                    face
            ]
     )
     [flatten(points), culled_faces];
 
 
 
 // Function: vnf_join()
+// Synopsis: Returns a single VNF structure from a list of VNF structures.
+// Topics: VNF Generators, Lists
+// See Also: vnf_tri_array(), vnf_vertex_array(), vnf_from_polygons(), vnf_from_region()
 // Usage:
 //   vnf = vnf_join([VNF, VNF, VNF, ...]);
 // Description:
 //   Given a list of VNF structures, merges them all into a single VNF structure.
 //   Combines all the points of the input VNFs and labels the faces appropriately.
 //   All the points in the input VNFs will appear in the output, even if they are
 //   duplicates of each other.  It is valid to repeat points in a VNF, but if you
 //   with to remove the duplicates that will occur along joined edges, use {{vnf_merge_points()}}.
 //   .
 //   Note that this is a tool for manipulating polyhedron data.  It is for
 //   building up a full polyhedron from partial polyhedra.
-//   It is *not* a union operator for VNFs.  The VNFs to be joined must not intersect each other, 
+//   It is *not* a union operator for VNFs.  The VNFs to be joined must not intersect each other,
 //   except at edges, or the result will be an invalid polyhedron.  Similarly the
 //   result must not have any other illegal polyhedron characteristics, such as creating
-//   more than two faces sharing the same edge.  
+//   more than two faces sharing the same edge.
 //   If you want a valid result it is your responsibility to ensure that the polyhedron
 //   has no holes, no intersecting faces or edges, and obeys all the requirements
-//   that CGAL expects. 
+//   that CGAL expects.
 //   .
 //   For example, if you combine two pyramids to try to make an octahedron, the result will
 //   be invalid because of the two internal faces created by the pyramid bases.  A valid
 //   use would be to build a cube missing one face and a pyramid missing its base and
-//   then join them into a cube with a point.  
+//   then join them into a cube with a point.
 // Arguments:
 //   vnfs = a list of the VNFs to joint into one VNF.
-// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF where the top face is missing.  It is not a valid polyhedron like this, but we can use it as a building block to make a polyhedron.  
+// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF where the top face is missing.  It is not a valid polyhedron like this, but we can use it as a building block to make a polyhedron.
 //   bottom = vnf_vertex_array([path3d(rect(8)), path3d(rect(5),4)],col_wrap=true,cap1=true);
 //   vnf_polyhedron(bottom);
-// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF that also has a missing face.  
+// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF that also has a missing face.
 //   triangle = yrot(-90,path3d(regular_ngon(n=3,side=5,anchor=LEFT)));
 //   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),
 //                               right(6,triangle)
 //                               ], col_wrap=true, cap2=true));
 //   vnf_polyhedron(zrot(90,top));
-// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Using vnf_join combines the two VNFs into a single VNF.  Note that they share an edge.  But the result still isn't closed, so it is not yet a valid polyhedron.  
+// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Using vnf_join combines the two VNFs into a single VNF.  Note that they share an edge.  But the result still isn't closed, so it is not yet a valid polyhedron.
 //   bottom = vnf_vertex_array([path3d(rect(8)), path3d(rect(5),4)],col_wrap=true,cap1=true);
 //   triangle = yrot(-90,path3d(regular_ngon(n=3,side=5,anchor=LEFT)));
 //   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),
 //                                right(6,triangle)
 //                               ], col_wrap=true, cap2=true));
 //   full = vnf_join([bottom,zrot(90,top)]);
 //   vnf_polyhedron(full);
@@ -355,54 +377,57 @@
 //   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),
 //                                right(6,triangle)
 //                               ], col_wrap=true, cap2=true));
 //   full = vnf_join([bottom,
 //                     for(theta=[0:90:359]) zrot(theta,top)
 //                    ]);
 //   vnf_polyhedron(full);
-// Example(3D): The vnf_join function is not a union operator for polyhedra.  If any faces intersect, like they do in this example where we combine the faces of two cubes, the result is invalid and will give rise to CGAL errors when you add more objects into the model.  
+// Example(3D): The vnf_join function is not a union operator for polyhedra.  If any faces intersect, like they do in this example where we combine the faces of two cubes, the result is invalid and will give rise to CGAL errors when you add more objects into the model.
 //   cube1 = cube(5);
 //   cube2 = move([2,2,2],cube1);
 //   badvnf = vnf_join([cube1,cube2]);
 //   vnf_polyhedron(badvnf);
 //   right(2.5)up(3)color("red")
 //         text3d("Invalid",size=1,anchor=CENTER,
 //         orient=FRONT,h=.1);
-function vnf_join(vnfs) = 
+function vnf_join(vnfs) =
     assert(is_vnf_list(vnfs) , "Input must be a list of VNFs")
     len(vnfs)==1 ? vnfs[0]
     :
     let (
         offs  = cumsum([ 0, for (vnf = vnfs) len(vnf[0]) ]),
         verts = [for (vnf=vnfs) each vnf[0]],
         faces =
-            [ for (i = idx(vnfs)) 
+            [ for (i = idx(vnfs))
                 let( faces = vnfs[i][1] )
-                for (face = faces) 
+                for (face = faces)
                     if ( len(face) >= 3 )
-                        [ for (j = face) 
-                            assert( j>=0 && j<len(vnfs[i][0]), 
+                        [ for (j = face)
+                            assert( j>=0 && j<len(vnfs[i][0]),
                                     str("VNF number ", i, " has a face indexing an nonexistent vertex") )
                             offs[i] + j ]
             ]
     )
     [verts,faces];
 
 
 
 // Function: vnf_from_polygons()
+// Synopsis: Returns a VNF from a list of 3D polygons.
+// Topics: VNF Generators, Lists
+// See Also: vnf_tri_array(), vnf_join(), vnf_vertex_array(), vnf_from_region()
 // Usage:
 //   vnf = vnf_from_polygons(polygons);
 // Description:
-//   Given a list of 3d polygons, produces a VNF containing those polygons.  
+//   Given a list of 3D polygons, produces a VNF containing those polygons.
 //   It is up to the caller to make sure that the points are in the correct order to make the face
 //   normals point outwards.  No checking for duplicate vertices is done.  If you want to
 //   remove duplicate vertices use {{vnf_merge_points()}}.
 // Arguments:
-//   polygons = The list of 3d polygons to turn into a VNF
+//   polygons = The list of 3D polygons to turn into a VNF
 function vnf_from_polygons(polygons) =
    assert(is_list(polygons) && is_path(polygons[0]),"Input should be a list of polygons")
    let(
        offs = cumsum([0, for(p=polygons) len(p)]),
        faces = [for(i=idx(polygons))
                   [for (j=idx(polygons[i])) offs[i]+j]
                ]
@@ -427,160 +452,167 @@
         path2 = ccw_polygon(list_rotate(path2,v2))
     )
     [
         each path1,
         if (repeat_start) path1[0],
         each path2,
         if (repeat_start) path2[0],
-    ];                      
+    ];
+
 
-        
 /// Internal Function: _cleave_connected_region(region, eps)
 /// Description:
 ///   Given a region that is connected and has its outer border in region[0],
-///   produces a overlapping connected path to join internal holes to  
-///   the outer border without adding points. Output is a single non-simple polygon. 
+///   produces a overlapping connected path to join internal holes to
+///   the outer border without adding points. Output is a single non-simple polygon.
 /// Requirements:
-///   It expects that all region paths be simple closed paths, with region[0] CW and 
-///   the other paths CCW and encircled by region[0]. The input region paths are also 
-///   supposed to be disjoint except for common vertices and common edges but with 
+///   It expects that all region paths be simple closed paths, with region[0] CW and
+///   the other paths CCW and encircled by region[0]. The input region paths are also
+///   supposed to be disjoint except for common vertices and common edges but with
 ///   no crossings. It may return `undef` if these conditions are not met.
-///   This function implements an extension of the algorithm discussed in:  
+///   This function implements an extension of the algorithm discussed in:
 ///   https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
 function _cleave_connected_region(region, eps=EPSILON) =
     len(region)==1 ? region[0] :
-    let( 
-        outer   = deduplicate(region[0]),             // 
+    let(
+        outer   = deduplicate(region[0]),             //
         holes   = [for(i=[1:1:len(region)-1])         // deduplication possibly unneeded
                       deduplicate( region[i] ) ],     //
         extridx = [for(li=holes) max_index(column(li,0)) ],
         // the right extreme vertex for each hole sorted by decreasing x values
         extremes = sort( [for(i=idx(holes)) [ i, extridx[i], -holes[i][extridx[i]].x] ], idx=2 )
-    ) 
+    )
     _polyHoles(outer, holes, extremes, eps, 0);
 
 
 // connect the hole paths one at a time to the outer path.
 // 'extremes' is the list of the right extreme vertex of each hole sorted by decreasing abscissas
 // see: _cleave_connected_region(region, eps)
 function _polyHoles(outer, holes, extremes, eps=EPSILON, n=0) =
-    let( 
-        extr = extremes[n],    // 
+    let(
+        extr = extremes[n],    //
         hole = holes[extr[0]], // hole path to bridge to the outer path
         ipt  = extr[1],        // index of the hole point with maximum abscissa
         brdg = _bridge(hole[ipt], outer, eps)  // the index of a point in outer to bridge hole[ipt] to
     )
     brdg == undef ? undef :
     let(
         l  = len(outer),
         lh = len(hole),
         // the new outer polygon bridging the hole to the old outer
         npoly =
-            approx(outer[brdg], hole[ipt], eps) 
+            approx(outer[brdg], hole[ipt], eps)
             ?   [ for(i=[brdg:  1: brdg+l])   outer[i%l] ,
                   for(i=[ipt+1: 1: ipt+lh-1]) hole[i%lh] ]
             :   [ for(i=[brdg:  1: brdg+l])   outer[i%l] ,
                   for(i=[ipt:   1: ipt+lh])   hole[i%lh] ]
     )
-    n==len(holes)-1 ?  npoly : 
-    _polyHoles(npoly, holes, extremes, eps, n+1);          
-          
-// find a point in outer to be connected to pt in the interior of outer 
+    n==len(holes)-1 ?  npoly :
+    _polyHoles(npoly, holes, extremes, eps, n+1);
+
+// find a point in outer to be connected to pt in the interior of outer
 // by a segment that not cross or touch any non adjacente edge of outer.
 // return the index of a vertex in the outer path where the bridge should end
 // see _polyHoles(outer, holes, extremes, eps)
 function _bridge(pt, outer,eps) =
-    // find the intersection of a ray from pt to the right 
+    // find the intersection of a ray from pt to the right
     // with the boundary of the outer cycle
-    let(  
+    let(
         l    = len(outer),
-        crxs = 
+        crxs =
             let( edges = pair(outer,wrap=true) )
             [for( i = idx(edges) )
                 let( edge = edges[i] )
                 // consider just descending outer edges at right of pt crossing ordinate pt.y
-                if(    (edge[0].y >  pt.y) //+eps) 
-                    && (edge[1].y <= pt.y) 
-                    && _is_at_left(pt, [edge[1], edge[0]], eps) ) 
+                if(    (edge[0].y >  pt.y) //+eps)
+                    && (edge[1].y <= pt.y)
+                    && _is_at_left(pt, [edge[1], edge[0]], eps) )
                     [ i,
                       // the point of edge with ordinate pt.y
                       abs(pt.y-edge[1].y)<eps ? edge[1] :
                       let( u = (pt-edge[1]).y / (edge[0]-edge[1]).y )
                       (1-u)*edge[1] + u*edge[0]
                     ]
              ]
     )
     crxs == [] ? undef :
-    let( 
+    let(
         // the intersection point of the nearest edge to pt with minimum slope
         minX    = min([for(p=crxs) p[1].x]),
         crxcand = [for(crx=crxs) if(crx[1].x < minX+eps) crx ], // nearest edges
-        nearest = min_index([for(crx=crxcand) 
+        nearest = min_index([for(crx=crxcand)
                                 (outer[crx[0]].x - pt.x) / (outer[crx[0]].y - pt.y) ]), // minimum slope
         proj    = crxcand[nearest],
         vert0   = outer[proj[0]],    // the two vertices of the nearest crossing edge
         vert1   = outer[(proj[0]+1)%l],
         isect   = proj[1]            // the intersection point
     )
     norm(pt-vert1) < eps ? (proj[0]+1)%l : // if pt touches an outer vertex, return its index
-    // as vert0.y > pt.y then pt!=vert0 
+    // as vert0.y > pt.y then pt!=vert0
     norm(pt-isect) < eps ? undef :         // if pt touches the middle of an outer edge -> error
-    let( 
+    let(
         // the edge [vert0, vert1] necessarily satisfies vert0.y > vert1.y
         // indices of candidates to an outer bridge point
-        cand  = 
-            (vert0.x > pt.x) 
-            ?   [ proj[0], 
+        cand  =
+            (vert0.x > pt.x)
+            ?   [ proj[0],
                   // select reflex vertices inside of the triangle [pt, vert0, isect]
-                  for(i=idx(outer)) 
-                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0 
+                  for(i=idx(outer))
+                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0
                           && _pt_in_tri(outer[i], [pt, vert0, isect], eps)>=0 )
-                        i 
+                        i
                 ]
             :   [ (proj[0]+1)%l,
-                  // select reflex vertices inside of the triangle [pt, isect, vert1] 
-                  for(i=idx(outer)) 
-                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0 
+                  // select reflex vertices inside of the triangle [pt, isect, vert1]
+                  for(i=idx(outer))
+                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0
                           &&  _pt_in_tri(outer[i], [pt, isect, vert1], eps)>=0 )
-                        i 
+                        i
                 ],
         // choose the candidate outer[i] such that the line [pt, outer[i]] has minimum slope
         // among those with minimum slope choose the nearest to pt
         slopes  = [for(i=cand) 1-abs(outer[i].x-pt.x)/norm(outer[i]-pt) ],
         min_slp = min(slopes),
         cand2   = [for(i=idx(cand)) if(slopes[i]<=min_slp+eps) cand[i] ],
-        nearest = min_index([for(i=cand2) norm(pt-outer[i]) ]) 
+        nearest = min_index([for(i=cand2) norm(pt-outer[i]) ])
     )
     cand2[nearest];
 
 
 // Function: vnf_from_region()
+// Topics: VNF Generators, Lists
+// Synopsis: Returns a 3D VNF given a 2D region.
+// See Also: vnf_vertex_array(), vnf_tri_array(), vnf_join(), vnf_from_polygons()
 // Usage:
 //   vnf = vnf_from_region(region, [transform], [reverse]);
 // Description:
 //   Given a (two-dimensional) region, applies the given transformation matrix to it and makes a (three-dimensional) triangulated VNF of
-//   faces for that region, reversed if desired. 
+//   faces for that region, reversed if desired.
 // Arguments:
-//   region = The region to conver to a vnf.
+//   region = The region to convert to a vnf.
 //   transform = If given, a transformation matrix to apply to the faces generated from the region.  Default: No transformation applied.
 //   reverse = If true, reverse the normals of the faces generated from the region.  An untransformed region will have face normals pointing `UP`.  Default: false
 // Example(3D):
 //   region = [square([20,10],center=true),
 //             right(5,square(4,center=true)),
 //             left(5,square(6,center=true))];
 //   vnf = vnf_from_region(region);
 //   color("gray")down(.125)
 //        linear_extrude(height=.125)region(region);
 //   vnf_wireframe(vnf,width=.25);
 function vnf_from_region(region, transform, reverse=false) =
     let (
+        region = [for (path = region) deduplicate(path, closed=true)],
         regions = region_parts(force_region(region)),
         vnfs =
-            [ for (rgn = regions) 
-                let( cleaved = path3d(_cleave_connected_region(rgn)) ) 
+            [
+                for (rgn = regions)
+                let(
+                    cleaved = path3d(_cleave_connected_region(rgn))
+                )
                 assert( cleaved, "The region is invalid")
                 let(
                     face = is_undef(transform)? cleaved : apply(transform,cleaved),
                     faceidxs = reverse? [for (i=[len(face)-1:-1:0]) i] : [for (i=[0:1:len(face)-1]) i]
                 ) [face, [faceidxs]]
             ],
         outvnf = vnf_join(vnfs)
@@ -589,178 +621,234 @@
 
 
 
 // Section: VNF Testing and Access
 
 
 // Function: is_vnf()
+// Synopsis: Returns true given a VNF-like structure.
+// Topics: VNF Manipulation
+// See Also: is_vnf_list(), vnf_vertices(), vnf_faces()
 // Usage:
 //   bool = is_vnf(x);
 // Description:
 //   Returns true if the given value looks like a VNF structure.
 function is_vnf(x) =
     is_list(x) &&
     len(x)==2 &&
     is_list(x[0]) &&
     is_list(x[1]) &&
     (x[0]==[] || (len(x[0])>=3 && is_vector(x[0][0],3))) &&
     (x[1]==[] || is_vector(x[1][0]));
 
 
 // Function: is_vnf_list()
+// Synopsis: Returns true given a list of VNF-like structures.
+// Topics: VNF Manipulation
+// See Also: is_vnf(), vnf_vertices(), vnf_faces()
+//
 // Description: Returns true if the given value looks passingly like a list of VNF structures.
 function is_vnf_list(x) = is_list(x) && all([for (v=x) is_vnf(v)]);
 
 
 // Function: vnf_vertices()
+// Synopsis: Returns the list of vertex points from a VNF.
+// Topics: VNF Manipulation
+// See Also: is_vnf(), is_vnf_list(), vnf_faces()
 // Description: Given a VNF structure, returns the list of vertex points.
 function vnf_vertices(vnf) = vnf[0];
 
 
 // Function: vnf_faces()
+// Synopsis: Returns the list of faces from a VNF.
+// Topics: VNF Manipulation
+// See Also: is_vnf(), is_vnf_list(), vnf_vertices()
 // Description: Given a VNF structure, returns the list of faces, where each face is a list of indices into the VNF vertex list.
 function vnf_faces(vnf) = vnf[1];
 
 
 
 // Section: Altering the VNF Internals
 
 
 // Function: vnf_reverse_faces()
+// Synopsis: Reverses the faces of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice() 
 // Usage:
 //   rvnf = vnf_reverse_faces(vnf);
 // Description:
 //   Reverses the orientation of all the faces in the given VNF.
 function vnf_reverse_faces(vnf) =
     [vnf[0], [for (face=vnf[1]) reverse(face)]];
 
 
 // Function: vnf_quantize()
+// Synopsis: Quantizes the vertex coordinates of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_reverse_faces(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice() 
 // Usage:
 //   vnf2 = vnf_quantize(vnf,[q]);
 // Description:
 //   Quantizes the vertex coordinates of the VNF to the given quanta `q`.
 // Arguments:
 //   vnf = The VNF to quantize.
 //   q = The quanta to quantize the VNF coordinates to.
 function vnf_quantize(vnf,q=pow(2,-12)) =
     [[for (pt = vnf[0]) quant(pt,q)], vnf[1]];
 
 
 
 // Function: vnf_merge_points()
+// Synopsis: COnsolidates duplicate vertices of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice() 
 // Usage:
 //   new_vnf = vnf_merge_points(vnf, [eps]);
 // Description:
 //   Given a VNF, consolidates all duplicate vertices with a tolerance `eps`, relabeling the faces as necessary,
 //   and eliminating any face with fewer than 3 vertices.  Unreferenced vertices of the input VNF are not dropped.
-//   To remove such vertices uses {{vnf_drop_unused_points()}}.  
+//   To remove such vertices uses {{vnf_drop_unused_points()}}.
 // Arguments:
 //   vnf = a VNF to consolidate
 //   eps = the tolerance in finding duplicates. Default: EPSILON
-function vnf_merge_points(vnf,eps=EPSILON) = 
+function vnf_merge_points(vnf,eps=EPSILON) =
     let(
-        verts = vnf[0], 
+        verts = vnf[0],
         dedup  = vector_search(verts,eps,verts),                 // collect vertex duplicates
         map    = [for(i=idx(verts)) min(dedup[i]) ],             // remap duplic vertices
-        offset = cumsum([for(i=idx(verts)) map[i]==i ? 0 : 1 ]), // remaping face vertex offsets 
+        offset = cumsum([for(i=idx(verts)) map[i]==i ? 0 : 1 ]), // remaping face vertex offsets
         map2   = list(idx(verts))-offset,                        // map old vertex indices to new indices
         nverts = [for(i=idx(verts)) if(map[i]==i) verts[i] ],    // this doesn't eliminate unreferenced vertices
-        nfaces = 
-            [ for(face=vnf[1]) 
+        nfaces =
+            [ for(face=vnf[1])
                 let(
                     nface = [ for(vi=face) map2[map[vi]] ],
-                    dface = [for (i=idx(nface)) 
-                                if( nface[i]!=nface[(i+1)%len(nface)]) 
-                                    nface[i] ] 
+                    dface = [for (i=idx(nface))
+                                if( nface[i]!=nface[(i+1)%len(nface)])
+                                    nface[i] ]
                 )
-                if(len(dface) >= 3) dface 
+                if(len(dface) >= 3) dface
             ]
-    ) 
+    )
     [nverts, nfaces];
 
 
 // Function: vnf_drop_unused_points()
+// Synopsis: Removes unreferenced vertices from a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_triangulate(), vnf_slice() 
 // Usage:
 //   clean_vnf = vnf_drop_unused_points(vnf);
 // Description:
 //   Remove all unreferenced vertices from a VNF.  Note that in most
 //   cases unreferenced vertices cause no harm, and this function may
 //   be slow on large VNFs.
 function vnf_drop_unused_points(vnf) =
     let(
         flat = flatten(vnf[1]),
         ind  = _link_indicator(flat,0,len(vnf[0])-1),
-        verts = [for(i=idx(vnf[0])) if(ind[i]==1) vnf[0][i] ], 
-        map   = cumsum(ind) 
+        verts = [for(i=idx(vnf[0])) if(ind[i]==1) vnf[0][i] ],
+        map   = cumsum(ind)
     )
     [ verts, [for(face=vnf[1]) [for(v=face) map[v]-1 ] ] ];
 
 function _link_indicator(l,imin,imax) =
     len(l) == 0  ? repeat(imax-imin+1,0) :
-    imax-imin<100 || len(l)<400 ? [for(si=search(list([imin:1:imax]),l,1)) si!=[] ? 1: 0 ] : 
-    let( 
+    imax-imin<100 || len(l)<400 ? [for(si=search(list([imin:1:imax]),l,1)) si!=[] ? 1: 0 ] :
+    let(
         pivot   = floor((imax+imin)/2),
         lesser  = [ for(li=l) if( li< pivot) li ],
-        greater = [ for(li=l) if( li> pivot) li ] 
+        greater = [ for(li=l) if( li> pivot) li ]
     )
-    concat( _link_indicator(lesser ,imin,pivot-1), 
+    concat( _link_indicator(lesser ,imin,pivot-1),
             search(pivot,l,1) ? 1 : 0 ,
             _link_indicator(greater,pivot+1,imax) ) ;
 
 // Function: vnf_triangulate()
+// Synopsis: Triangulates the faces of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_slice() 
 // Usage:
 //   vnf2 = vnf_triangulate(vnf);
 // Description:
 //   Triangulates faces in the VNF that have more than 3 vertices.
 // Arguments:
-//   vnf = vnf to triangulate
+//   vnf = VNF to triangulate
 // Example(3D):
 //   include <BOSL2/polyhedra.scad>
 //   vnf = zrot(33,regular_polyhedron_info("vnf", "dodecahedron", side=12));
 //   vnf_polyhedron(vnf);
 //   triangulated = vnf_triangulate(vnf);
 //   color("red")vnf_wireframe(triangulated,width=.3);
 function vnf_triangulate(vnf) =
     let(
         verts = vnf[0],
-        faces = [for (face=vnf[1]) 
-                    each (len(face)==3 ? [face] : 
+        faces = [for (face=vnf[1])
+                    each (len(face)==3 ? [face] :
                     let( tris = polygon_triangulate(verts, face) )
                     assert( tris!=undef, "Some `vnf` face cannot be triangulated.")
                     tris ) ]
-    ) 
-    [verts, faces]; 
+    )
+    [verts, faces];
+
+
+
+function _vnf_sort_vertices(vnf, idx=[2,1,0]) =
+    let(
+        verts = vnf[0],
+        faces = vnf[1],
+        vidx = sortidx(verts, idx=idx),
+        rvidx = sortidx(vidx),
+        sorted_vnf = [
+            [ for (i = vidx) verts[i] ],
+            [ for (face = faces) [ for (i = face) rvidx[i] ] ],
+        ]
+    ) sorted_vnf;
 
 
 
 // Function: vnf_slice()
+// Synopsis: Slice the faces of a VNF along an axis.
+// Topics: VNF Manipulation
+// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate()
 // Usage:
 //   sliced = vnf_slice(vnf, dir, cuts);
 // Description:
-//   Slice the faces of a VNF along a specified axis direction at a given list
-//   of cut points.  The cut points can appear in any order.  You can use this to refine the faces of a VNF before applying
-//   a nonlinear transformation to its vertex set.
+//   Slice the faces of a VNF along a specified axis direction at a given list of cut points.
+//   The cut points can appear in any order.  You can use this to refine the faces of a VNF before
+//   applying a nonlinear transformation to its vertex set.
 // Arguments:
-//   vnf = vnf to slice
+//   vnf = VNF to slice
 //   dir = normal direction to the slices, either "X", "Y" or "Z"
 //   cuts = X, Y or Z values where cuts occur
 // Example(3D):
 //   include <BOSL2/polyhedra.scad>
 //   vnf = regular_polyhedron_info("vnf", "dodecahedron", side=12);
 //   vnf_polyhedron(vnf);
 //   sliced = vnf_slice(vnf, "X", [-6,-1,10]);
 //   color("red")vnf_wireframe(sliced,width=.3);
 function vnf_slice(vnf,dir,cuts) =
-  let(
-       vert = vnf[0],
-       faces = [for(face=vnf[1]) select(vert,face)],
-       poly_list = _slice_3dpolygons(faces, dir, cuts)
-  )
-  vnf_merge_points(vnf_from_polygons(poly_list));
+    let(
+        cuts = [for (cut=cuts) _shift_cut_plane(vnf,dir,cut)],
+        vert = vnf[0],
+        faces = [for(face=vnf[1]) select(vert,face)],
+        poly_list = _slice_3dpolygons(faces, dir, cuts)
+    )
+    vnf_merge_points(vnf_from_polygons(poly_list));
+
+
+function _shift_cut_plane(vnf,dir,cut,off=0.001) =
+    let(
+        I = ident(3),
+        dir_ind = ord(dir)-ord("X"),
+        verts = vnf[0],
+        on_cut = [for (x = verts * I[dir_ind]) if(approx(x,cut,eps=1e-4)) 1] != []
+    ) !on_cut? cut :
+    _shift_cut_plane(vnf,dir,cut+off);
 
 
 function _split_polygon_at_x(poly, x) =
     let(
         xs = column(poly,0)
     ) (min(xs) >= x || max(xs) <= x)? [poly] :
     let(
@@ -780,15 +868,15 @@
         ],
         out1 = [for (p = poly2) if(p.x <= x) p],
         out2 = [for (p = poly2) if(p.x >= x) p],
         out3 = [
             if (len(out1)>=3) each split_path_at_self_crossings(out1),
             if (len(out2)>=3) each split_path_at_self_crossings(out2),
         ],
-        out = [for (p=out3) if (len(p) > 2) cleanup_path(p)]
+        out = [for (p=out3) if (len(p) > 2) list_unwrap(p)]
     ) out;
 
 
 function _split_2dpolygons_at_each_x(polys, xs, _i=0) =
     _i>=len(xs)? polys :
     _split_2dpolygons_at_each_x(
         [
@@ -799,31 +887,30 @@
 
 /// Internal Function: _slice_3dpolygons()
 /// Usage:
 ///   splitpolys = _slice_3dpolygons(polys, dir, cuts);
 /// Topics: Geometry, Polygons, Intersections
 /// Description:
 ///   Given a list of 3D polygons, a choice of X, Y, or Z, and a cut list, `cuts`, splits all of the polygons where they cross
-///   X/Y/Z at any value given in cuts.  
+///   X/Y/Z at any value given in cuts.
 /// Arguments:
 ///   polys = A list of 3D polygons to split.
 ///   dir_ind = slice direction, 0=X, 1=Y, or 2=Z
 ///   cuts = A list of scalar values for locating the cuts
 function _slice_3dpolygons(polys, dir, cuts) =
     assert( [for (poly=polys) if (!is_path(poly,3)) 1] == [], "Expects list of 3D paths.")
     assert( is_vector(cuts), "The split list must be a vector.")
     assert( in_list(dir, ["X", "Y", "Z"]))
     let(
         I = ident(3),
         dir_ind = ord(dir)-ord("X")
     )
-    flatten([for (poly = polys)
-        let(
-            plane = plane_from_polygon(poly)
-        )
+    flatten([
+        for (poly = polys)
+        let( plane = plane_from_polygon(poly))
         assert(plane,"Found non-coplanar face.")
         let(
             normal = point3d(plane),
             pnormal = normal - (normal*I[dir_ind])*I[dir_ind]
         )
         approx(pnormal,[0,0,0]) ? [poly] :
         let (
@@ -845,45 +932,56 @@
 
 
 
 // Section: Turning a VNF into geometry
 
 
 // Module: vnf_polyhedron()
+// Synopsis: Returns a polyhedron from a VNF or list of VNFs.
+// Topics: VNF Manipulation
+// See Also: vnf_wireframe()
 // Usage:
 //   vnf_polyhedron(vnf) [ATTACHMENTS];
 //   vnf_polyhedron([VNF, VNF, VNF, ...]) [ATTACHMENTS];
 // Description:
 //   Given a VNF structure, or a list of VNF structures, creates a polyhedron from them.
 // Arguments:
 //   vnf = A VNF structure, or list of VNF structures.
 //   convexity = Max number of times a line could intersect a wall of the shape.
 //   extent = If true, calculate anchors by extents, rather than intersection.  Default: true.
 //   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
 //   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `"origin"`
 //   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
 //   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
 //   atype = Select "hull" or "intersect" anchor type.  Default: "hull"
+// Anchor Types:
+//   "hull" = Anchors to the virtual convex hull of the shape.
+//   "intersect" = Anchors to the surface of the shape.
+// Extra Anchors:
+//   "origin" = Anchor at the origin, oriented UP.
 module vnf_polyhedron(vnf, convexity=2, extent=true, cp="centroid", anchor="origin", spin=0, orient=UP, atype="hull") {
     vnf = is_vnf_list(vnf)? vnf_join(vnf) : vnf;
     assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"");
     attachable(anchor,spin,orient, vnf=vnf, extent=atype=="hull", cp=cp) {
         polyhedron(vnf[0], vnf[1], convexity=convexity);
         children();
     }
 }
 
 
 // Module: vnf_wireframe()
+// Synopsis: Creates a wireframe model from a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_polyhedron()
 // Usage:
 //   vnf_wireframe(vnf, [width]);
 // Description:
 //   Given a VNF, creates a wire frame ball-and-stick model of the polyhedron with a cylinder for
 //   each edge and a sphere at each vertex.  The width parameter specifies the width of the sticks
-//   that form the wire frame and the diameter of the balls.  
+//   that form the wire frame and the diameter of the balls.
 // Arguments:
 //   vnf = A vnf structure
 //   width = width of the cylinders forming the wire frame.  Default: 1
 // Example:
 //   $fn=32;
 //   ball = sphere(r=20, $fn=6);
 //   vnf_wireframe(ball,width=1);
@@ -904,21 +1002,24 @@
   vertex = vnf[0];
   edges = unique([for (face=vnf[1], i=idx(face))
                     sort([face[i], select(face,i+1)])
                  ]);
   for (e=edges) extrude_from_to(vertex[e[0]],vertex[e[1]]) circle(d=width);
   // Identify vertices actually used and draw them
   vertused = search(count(len(vertex)), flatten(edges), 1);
-  for(i=idx(vertex)) if(vertused[i]!=[]) move(vertex[i]) sphere(d=width); 
+  for(i=idx(vertex)) if(vertused[i]!=[]) move(vertex[i]) sphere(d=width);
 }
 
 
 // Section: Operations on VNFs
 
 // Function: vnf_volume()
+// Synopsis: Returns the volume of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_area(), vnf_halfspace(), vnf_bend() 
 // Usage:
 //   vol = vnf_volume(vnf);
 // Description:
 //   Returns the volume enclosed by the given manifold VNF.   The VNF must describe a valid polyhedron with consistent face direction and
 //   no holes; otherwise the results are undefined.  Returns a positive volume if face direction is clockwise and a negative volume
 //   if face direction is counter-clockwise.
 
@@ -928,35 +1029,38 @@
     sum([
          for(face=vnf[1], j=[1:1:len(face)-2])
              cross(verts[face[j+1]], verts[face[j]]) * verts[face[0]]
     ])/6;
 
 
 // Function: vnf_area()
+// Synopsis: Returns the surface area of a VNF.
+// Topics: VNF Manipulation
+// See Also: vnf_volume(), vnf_halfspace(), vnf_bend() 
 // Usage:
 //   area = vnf_area(vnf);
 // Description:
-//   Returns the surface area in any VNF by adding up the area of all its faces.  The VNF need not be a manifold.  
+//   Returns the surface area in any VNF by adding up the area of all its faces.  The VNF need not be a manifold.
 function vnf_area(vnf) =
     let(verts=vnf[0])
     sum([for(face=vnf[1]) polygon_area(select(verts,face))]);
 
 
 /// Internal Function: _vnf_centroid()
 /// Usage:
 ///   vol = _vnf_centroid(vnf);
 /// Description:
 ///   Returns the centroid of the given manifold VNF.  The VNF must describe a valid polyhedron with consistent face direction and
 ///   no holes; otherwise the results are undefined.
 
-/// Divide the solid up into tetrahedra with the origin as one vertex.  
+/// Divide the solid up into tetrahedra with the origin as one vertex.
 /// The centroid of a tetrahedron is the average of its vertices.
 /// The centroid of the total is the volume weighted average.
 function _vnf_centroid(vnf,eps=EPSILON) =
-    assert(is_vnf(vnf) && len(vnf[0])!=0 && len(vnf[1])!=0,"Invalid or empty VNF given to centroid") 
+    assert(is_vnf(vnf) && len(vnf[0])!=0 && len(vnf[1])!=0,"Invalid or empty VNF given to centroid")
     let(
         verts = vnf[0],
         pos = sum([
             for(face=vnf[1], j=[1:1:len(face)-2]) let(
                 v0  = verts[face[0]],
                 v1  = verts[face[j]],
                 v2  = verts[face[j+1]],
@@ -966,25 +1070,43 @@
         ])
     )
     assert(!approx(pos[0],0, eps), "The vnf has self-intersections.")
     pos[1]/pos[0]/4;
 
 
 // Function: vnf_halfspace()
+// Synopsis: Returns the intersection of the vnf with a half space.
+// Topics: VNF Manipulation
+// See Also: vnf_volume(), vnf_area(), vnf_bend() 
+
 // Usage:
-//   newvnf = vnf_halfspace(plane, vnf, [closed]);
+//   newvnf = vnf_halfspace(plane, vnf, [closed], [boundary]);
 // Description:
 //   Returns the intersection of the vnf with a half space.  The half space is defined by
 //   plane = [A,B,C,D], taking the side where the normal [A,B,C] points: Ax+By+Cz≥D.
 //   If closed is set to false then the cut face is not included in the vnf.  This could
-//   allow further extension of the vnf by merging with other vnfs.  
+//   allow further extension of the vnf by join with other vnfs using {{vnf_join()}}.
+//   Note that if your given VNF has holes (missing faces) or is not a complete polyhedron
+//   then closed=true is may produce invalid results when it tries to construct closing faces
+//   on the cut plane.  Set closed=false for such inputs.
+//   .
+//   If you set boundary to true then the return will be the pair [vnf,boundary] where vnf is the
+//   vnf as usual (with closed=false) and boundary is a list giving each connected component of the cut
+//   boundary surface.  Each entry in boundary is a list of index values that index into the vnf vertex list (vnf[0]).
+//   This makes it possible to construct mating shapes, e.g. with {{skin()}} or {{vnf_vertex_array()}} that
+//   can be combined using {{vnf_join()}} to make a valid polyhedron.
+//   .
+//   Note that the input to vnf_halfspace() does not need to be a closed, manifold polyhedron.
+//   Because it adds the faces on the cut surface, you can use vnf_halfspace() to cap off an open shape if you
+//   slice through a region that excludes all of the gaps in the input VNF.  
 // Arguments:
 //   plane = plane defining the boundary of the half space
-//   vnf = vnf to cut
-//   closed = if false do not return include cut face(s).  Default: true
+//   vnf = VNF to cut
+//   closed = if false do not return the cut face(s) in the returned VNF.  Default: true
+//   boundary = if true return a pair [vnf,boundary] where boundary is a list of paths on the cut boundary indexed into the VNF vertex list.  If boundary is true, then closed is set to false.  Default: false
 // Example(3D):
 //   vnf = cube(10,center=true);
 //   cutvnf = vnf_halfspace([-1,1,-1,0], vnf);
 //   vnf_polyhedron(cutvnf);
 // Example(3D):  Cut face has 2 components
 //   vnf = path_sweep(circle(r=4, $fn=16),
 //                    circle(r=20, $fn=64),closed=true);
@@ -992,62 +1114,113 @@
 //   vnf_polyhedron(cutvnf);
 // Example(3D): Cut face is not simply connected
 //   vnf = path_sweep(circle(r=4, $fn=16),
 //                    circle(r=20, $fn=64),closed=true);
 //   cutvnf = vnf_halfspace([0,0.7,-4,0], vnf);
 //   vnf_polyhedron(cutvnf);
 // Example(3D): Cut object has multiple components
-//   function knot(a,b,t) =   // rolling knot 
-//        [ a * cos (3 * t) / (1 - b* sin (2 *t)), 
-//          a * sin( 3 * t) / (1 - b* sin (2 *t)), 
-//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))]; 
-//   a = 0.8; b = sqrt (1 - a * a); 
+//   function knot(a,b,t) =   // rolling knot
+//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),
+//          a * sin( 3 * t) / (1 - b* sin (2 *t)),
+//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];
+//   a = 0.8; b = sqrt (1 - a * a);
 //   ksteps = 400;
 //   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];
 //   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];
 //   knot=path_sweep(ushape, knot_path, closed=true, method="incremental");
 //   cut_knot = vnf_halfspace([1,0,0,0], knot);
 //   vnf_polyhedron(cut_knot);
-function vnf_halfspace(plane, vnf, closed=true) =
+// Example(VPR=[80,0,15]): Cut a sphere with an arbitrary plane
+//   vnf1=sphere(r=50, style="icosa", $fn=16);
+//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);
+//   vnf_polyhedron(vnf2);
+// Example(VPR=[80,0,15]): Cut it again, but with closed=false to leave an open boundary. 
+//   vnf1=sphere(r=50, style="icosa", $fn=16);
+//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);
+//   vnf3=vnf_halfspace([0,0,-1,0], vnf2, closed=false);
+//   vnf_polyhedron(vnf3);
+// Example(VPR=[80,0,15]): Use {vnf_join()} to combine with a mating vnf, in this case a reflection of the part we made. 
+//   vnf1=sphere(r=50, style="icosa", $fn=16);
+//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);
+//   vnf3=vnf_halfspace([0,0,-1,0], vnf2, closed=false);
+//   vnf4=vnf_join([vnf3, zflip(vnf3,1)]);
+//   vnf_polyhedron(vnf4);
+// Example: When the input VNF is a surface with a boundary, if you use the default setting closed=true, then vnf_halfspace() tries to construct closing faces from the edges created by the cut.  These faces may be invalid, for example if the cut points are collinear.  In this example the constructed face is a valid face.
+//   include <BOSL2/beziers.scad>
+//   patch=[
+//          [[10,-10,0],[1,-1,0],[-1,-1,0],[-10,-10,0]],
+//          [[10,-10,20],[1,-1,20],[-1,-1,20],[-10,-10,20]]
+//         ];
+//   vnf=bezier_vnf(patch);
+//   vnfcut = vnf_halfspace([-.8,0,-1,-14],vnf);
+//   vnf_polyhedron(vnfcut);
+// Example: Setting closed to false eliminates this (possibly invalid) face:
+//   include <BOSL2/beziers.scad>
+//   patch=[
+//          [[10,-10,0],[1,-1,0],[-1,-1,0],[-10,-10,0]],
+//          [[10,-10,20],[1,-1,20],[-1,-1,20],[-10,-10,20]]
+//         ];
+//   vnf=bezier_vnf(patch);
+//   vnfcut = vnf_halfspace([-.8,0,-1,-14],vnf,closed=false);
+//   vnf_polyhedron(vnfcut);
+// Example: Here is a VNF that has holes, so it is not a valid manifold. 
+//   outside = linear_sweep(circle(r=30), h=100, caps=false);
+//   inside = yrot(7,linear_sweep(circle(r=10), h=120, caps=false));
+//   open_vnf=vnf_join([outside, vnf_reverse_faces(inside)]);
+//   vnf_polyhedron(open_vnf);
+// Example: By cutting it at each end we can create closing faces, resulting in a valid manifold without holes.
+//   outside = linear_sweep(circle(r=30), h=100, caps=false);
+//   inside = yrot(11,linear_sweep(circle(r=10), h=120, caps=false));
+//   open_vnf=vnf_join([outside, vnf_reverse_faces(inside)]);
+//   vnf = vnf_halfspace([0,0,1,5], vnf_halfspace([0,.7,-1,-75], open_vnf));
+//   vnf_polyhedron(vnf);
+// Example: If boundary=true then the return is a list with the VNF and boundary data.  
+//   vnf = path_sweep(circle(r=4, $fn=16),
+//                    circle(r=20, $fn=64),closed=true);
+//   cut_bnd = vnf_halfspace([-1,1,-4,0], vnf, boundary=true);*/
+//   cutvnf = cut_bnd[0];
+//   boundary = [for(b=cut_bnd[1]) select(cutvnf[0],b)];
+//   vnf_polyhedron(cutvnf);
+//   stroke(boundary,color="red");
+function vnf_halfspace(plane, vnf, closed=true, boundary=false) =
     assert(_valid_plane(plane), "Invalid plane")
     assert(is_vnf(vnf), "Invalid vnf")
     let(
-         inside = [for(x=vnf[0]) plane*[each x,-1] >= 0 ? 1 : 0],
+         inside = [for(x=vnf[0]) plane*[each x,-1] >= -EPSILON ? 1 : 0],
          vertexmap = [0,each cumsum(inside)],
          faces_edges_vertices = _vnfcut(plane, vnf[0],vertexmap,inside, vnf[1], last(vertexmap)),
          newvert = concat(bselect(vnf[0],inside), faces_edges_vertices[2])
     )
-    closed==false ? [newvert, faces_edges_vertices[0]] :
-    let(
+    closed==false && !boundary ? [newvert, faces_edges_vertices[0]]
+  : let(
         allpaths = _assemble_paths(newvert, faces_edges_vertices[1]),
         newpaths = [for(p=allpaths) if (len(p)>=3) p
                                     else assert(approx(p[0],p[1]),"Orphan edge found when assembling cut edges.")
            ]
     )
-    len(newpaths)<=1 ? [newvert, concat(faces_edges_vertices[0], newpaths)] 
-    :
-      let(
+    boundary ? [[newvert, faces_edges_vertices[0]], newpaths]
+  : len(newpaths)<=1 ? [newvert, concat(faces_edges_vertices[0], newpaths)]
+  : let(
            M = project_plane(plane),
            faceregion = [for(path=newpaths) path2d(apply(M,select(newvert,path)))],
            facevnf = vnf_from_region(faceregion,transform=rot_inverse(M),reverse=true)
       )
       vnf_join([[newvert, faces_edges_vertices[0]], facevnf]);
 
-
 function _assemble_paths(vertices, edges, paths=[],i=0) =
      i==len(edges) ? paths :
      norm(vertices[edges[i][0]]-vertices[edges[i][1]])<EPSILON ? _assemble_paths(vertices,edges,paths,i+1) :
      let(    // Find paths that connects on left side and right side of the edges (if one exists)
          left = [for(j=idx(paths)) if (approx(vertices[last(paths[j])],vertices[edges[i][0]])) j],
          right = [for(j=idx(paths)) if (approx(vertices[edges[i][1]],vertices[paths[j][0]])) j]
      )
      assert(len(left)<=1 && len(right)<=1)
-     let(              
+     let(
           keep_path = list_remove(paths,concat(left,right)),
-          update_path = left==[] && right==[] ? edges[i] 
+          update_path = left==[] && right==[] ? edges[i]
                       : left==[] ? concat([edges[i][0]],paths[right[0]])
                       : right==[] ?  concat(paths[left[0]],[edges[i][1]])
                       : left != right ? concat(paths[left[0]], paths[right[0]])
                       : paths[left[0]]
      )
      _assemble_paths(vertices, edges, concat(keep_path, [update_path]), i+1);
 
@@ -1074,15 +1247,15 @@
        ? _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount+2,
                  concat(newfaces, [newface]), concat(newedges,[[vertcount+1,vertcount]]),concat(newvertices,newvert),i+1)
    :len(newface)>3
        ? _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount+1,
                  concat(newfaces, [list_head(newface)]), newedges,concat(newvertices,[newvert[0]]),i+1)
    :
    _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount,newfaces, newedges, newvert, i+1);
- 
+
 
 
 
 function _triangulate_planar_convex_polygons(polys) =
     polys==[]? [] :
     let(
         tris = [for (poly=polys) if (len(poly)==3) poly],
@@ -1101,14 +1274,17 @@
 //    == [[[-1, -1], [ 0,  0], [0,  0]]
 //        [[-1, -1], [-1, -1], [0,  0]]
 //        [[ 1, -1], [-1, -1], [0,  0]]
 //        [[ 0,  0], [ 1,  1], [1, -1]] ]
 //
 
 // Function: vnf_bend()
+// Synopsis: Bends a VNF around an axis.
+// Topics: VNF Manipulation
+// See Also: vnf_volume(), vnf_area(), vnf_halfspace() 
 // Usage:
 //   bentvnf = vnf_bend(vnf,r|d=,[axis=]);
 // Description:
 //   Bend a VNF around the X, Y or Z axis, splitting up faces as necessary.  Returns the bent
 //   VNF.  For bending around the Z axis the input VNF must not cross the Y=0 plane.  For bending
 //   around the X or Y axes the VNF must not cross the Z=0 plane.  Note that if you wrap a VNF all the way around
 //   it may intersect itself, which produces an invalid polyhedron.  It is your responsibility to
@@ -1208,58 +1384,59 @@
         sliced = vnf_slice(vnf, slicedir, bend_at),
         coord = axis=="X" ? [0,sign(bmax.z),0] : axis=="Y" ? [sign(bmax.z),0,0] : [sign(bmax.y),0,0],
         new_vert = [for(p=sliced[0])
                        let(a=coord*p*180/(PI*r))
                        axis=="X"? [p.x, p.z*sin(a), p.z*cos(a)] :
                        axis=="Y"? [p.z*sin(a), p.y, p.z*cos(a)] :
                        [p.y*sin(a), p.y*cos(a), p.z]]
-                         
    ) [new_vert,sliced[1]];
 
 
 // Section: Debugging Polyhedrons
 
 /// Internal Module: _show_vertices()
 /// Usage:
-///   _show_vertices(vertices, [size])
+///   _show_vertices(vertices, [size], [filter=])
 /// Description:
 ///   Draws all the vertices in an array, at their 3D position, numbered by their
 ///   position in the vertex array.  Also draws any children of this module with
 ///   transparency.
 /// Arguments:
 ///   vertices = Array of point vertices.
 ///   size = The size of the text used to label the vertices.  Default: 1
 /// Example:
 ///   verts = [for (z=[-10,10], y=[-10,10], x=[-10,10]) [x,y,z]];
 ///   faces = [[0,1,2], [1,3,2], [0,4,5], [0,5,1], [1,5,7], [1,7,3], [3,7,6], [3,6,2], [2,6,4], [2,4,0], [4,6,7], [4,7,5]];
 ///   _show_vertices(vertices=verts, size=2) {
 ///       polyhedron(points=verts, faces=faces);
 ///   }
-module _show_vertices(vertices, size=1) {
+module _show_vertices(vertices, size=1, filter) {
     color("blue") {
         dups = vector_search(vertices, EPSILON, vertices);
-        for (ind = dups){
-            numstr = str_join([for(i=ind) str(i)],",");
-            v = vertices[ind[0]];
-            translate(v) {
-                rot($vpr) back(size/8){
-                   linear_extrude(height=size/10, center=true, convexity=10) {
-                      text(text=numstr, size=size, halign="center");
-                   }
+        for (ind = dups) {
+            if (is_undef(filter) || any(ind, filter)) {
+                numstr = str_join([for(i=ind) str(i)],",");
+                v = vertices[ind[0]];
+                translate(v) {
+                    rot($vpr) back(size/8){
+                       linear_extrude(height=size/10, center=true, convexity=10) {
+                          text(text=numstr, size=size, halign="center");
+                       }
+                    }
+                    sphere(size/10);
                 }
-                sphere(size/10);
             }
         }
     }
 }
 
 
 /// Internal Module: _show_faces()
 /// Usage:
-///   _show_faces(vertices, faces, [size=]);
+///   _show_faces(vertices, faces, [size=], [filter=]);
 /// Description:
 ///   Draws all the vertices at their 3D position, numbered in blue by their
 ///   position in the vertex array.  Each face will have their face number drawn
 ///   in red, aligned with the center of face.  All children of this module are drawn
 ///   with transparency.
 /// Arguments:
 ///   vertices = Array of point vertices.
@@ -1267,22 +1444,22 @@
 ///   size = The size of the text used to label the faces and vertices.  Default: 1
 /// Example(EdgesMed):
 ///   verts = [for (z=[-10,10], y=[-10,10], x=[-10,10]) [x,y,z]];
 ///   faces = [[0,1,2], [1,3,2], [0,4,5], [0,5,1], [1,5,7], [1,7,3], [3,7,6], [3,6,2], [2,6,4], [2,4,0], [4,6,7], [4,7,5]];
 ///   _show_faces(vertices=verts, faces=faces, size=2) {
 ///       polyhedron(points=verts, faces=faces);
 ///   }
-module _show_faces(vertices, faces, size=1) {
+module _show_faces(vertices, faces, size=1, filter) {
     vlen = len(vertices);
     color("red") {
         for (i = [0:1:len(faces)-1]) {
             face = faces[i];
             if (face[0] < 0 || face[1] < 0 || face[2] < 0 || face[0] >= vlen || face[1] >= vlen || face[2] >= vlen) {
                 echo("BAD FACE: ", vlen=vlen, face=face);
-            } else {
+            } else if (is_undef(filter) || any(face,filter)) {
                 verts = select(vertices,face);
                 c = mean(verts);
                 v0 = verts[0];
                 v1 = verts[1];
                 v2 = verts[2];
                 dv0 = unit(v1 - v0);
                 dv1 = unit(v2 - v0);
@@ -1306,145 +1483,157 @@
         }
     }
 }
 
 
 
 // Module: debug_vnf()
+// Synopsis: A replacement for `vnf_polyhedron()` to help with debugging.
+// Topics: VNF Manipulation, Debugging
+// See Also: vnf_validate()
 // Usage:
-//   debug_vnf(vnfs, [faces=], [vertices=], [opacity=], [size=], [convexity=]);
+//   debug_vnf(vnfs, [faces=], [vertices=], [opacity=], [size=], [convexity=], [filter=]);
 // Description:
 //   A drop-in module to replace `vnf_polyhedron()` to help debug vertices and faces.
 //   Draws all the vertices at their 3D position, numbered in blue by their
 //   position in the vertex array.  Each face will have its face number drawn
 //   in red, aligned with the center of face.  All given faces are drawn with
 //   transparency. All children of this module are drawn with transparency.
 //   Works best with Thrown-Together preview mode, to see reversed faces.
-//   You can set opacity to 0 if you want to supress the display of the polyhedron faces.  
+//   You can set opacity to 0 if you want to supress the display of the polyhedron faces.
 //   .
 //   The vertex numbers are shown rotated to face you.  As you rotate your polyhedron you
 //   can rerun the preview to display them oriented for viewing from a different viewpoint.
 // Topics: Polyhedra, Debugging
 // Arguments:
-//   vnf = vnf to display
+//   vnf = VNF to display
 //   ---
 //   faces = if true display face numbers.  Default: true
 //   vertices = if true display vertex numbers.  Default: true
 //   opacity = Opacity of the polyhedron faces.  Default: 0.5
 //   convexity = The max number of walls a ray can pass through the given polygon paths.
 //   size = The size of the text used to label the faces and vertices.  Default: 1
+//   filter = If given a function literal of signature `function(i)`, will only show labels for vertices and faces that have a vertex index that gets a true result from that function.  Default: no filter.
 // Example(EdgesMed):
 //   verts = [for (z=[-10,10], a=[0:120:359.9]) [10*cos(a),10*sin(a),z]];
 //   faces = [[0,1,2], [5,4,3], [0,3,4], [0,4,1], [1,4,5], [1,5,2], [2,5,3], [2,3,0]];
 //   debug_vnf([verts,faces], size=2);
-module debug_vnf(vnf, faces=true, vertices=true, opacity=0.5, size=1, convexity=6 ) {
+module debug_vnf(vnf, faces=true, vertices=true, opacity=0.5, size=1, convexity=6, filter ) {
     no_children($children);
     if (faces)
-      _show_faces(vertices=vnf[0], faces=vnf[1], size=size);
+      _show_faces(vertices=vnf[0], faces=vnf[1], size=size, filter=filter);
     if (vertices)
-      _show_vertices(vertices=vnf[0], size=size);
-    color([0.2, 1.0, 0, opacity])
-       vnf_polyhedron(vnf,convexity=convexity);
+      _show_vertices(vertices=vnf[0], size=size, filter=filter);
+    if (opacity > 0)
+      color([0.2, 1.0, 0, opacity])
+        vnf_polyhedron(vnf,convexity=convexity);
 }
 
 
-// Function&Module: vnf_validate()
-// Usage: As Function
-//   fails = vnf_validate(vnf);
-// Usage: As Module
-//   vnf_validate(vnf, [size], [check_isects]);
+// Module: vnf_validate()
+// Synopsis: Echos non-manifold VNF errors to the console.
+// Topics: VNF Manipulation, Debugging
+// See Also: debug_vnf()
+// 
+// Usage: 
+//   vnf_validate(vnf, [size], [show_warns=], [check_isects=], [opacity=], [adjacent=], [label_verts=], [label_faces=], [wireframe=]);
 // Description:
-//   When called as a function, returns a list of non-manifold errors with the given VNF.
-//   Each error has the format `[ERR_OR_WARN,CODE,MESG,POINTS,COLOR]`.
 //   When called as a module, echoes the non-manifold errors to the console, and color hilites the
 //   bad edges and vertices, overlaid on a transparent gray polyhedron of the VNF.
 //   .
 //   Currently checks for these problems:
 //   .
 //   Type    | Color    | Code         | Message
 //   ------- | -------- | ------------ | ---------------------------------
 //   WARNING | Yellow   | BIG_FACE     | Face has more than 3 vertices, and may confuse CGAL.
-//   WARNING | Brown    | NULL_FACE    | Face has zero area.
+//   WARNING | Blue     | NULL_FACE    | Face has zero area.
 //   ERROR   | Cyan     | NONPLANAR    | Face vertices are not coplanar.
 //   ERROR   | Brown    | DUP_FACE     | Multiple instances of the same face.
 //   ERROR   | Orange   | MULTCONN     | Multiply Connected Geometry. Too many faces attached at Edge.
 //   ERROR   | Violet   | REVERSAL     | Faces reverse across edge.
 //   ERROR   | Red      | T_JUNCTION   | Vertex is mid-edge on another Face.
-//   ERROR   | Blue     | FACE_ISECT   | Faces intersect.
+//   ERROR   | Brown    | FACE_ISECT   | Faces intersect.
 //   ERROR   | Magenta  | HOLE_EDGE    | Edge bounds Hole.
 //   .
 //   Still to implement:
 //   - Overlapping coplanar faces.
 // Arguments:
 //   vnf = The VNF to validate.
 //   size = The width of the lines and diameter of points used to highlight edges and vertices.  Module only.  Default: 1
-//   --
+//   ---
 //   show_warns = If true show warnings for non-triangular faces.  Default: true
 //   check_isects = If true, performs slow checks for intersecting faces.  Default: false
-// Example: BIG_FACE Warnings; Faces with More Than 3 Vertices.  CGAL often will fail to accept that a face is planar after a rotation, if it has more than 3 vertices.
+//   opacity = The opacity level to show the polyhedron itself with.    Default: 0.67
+//   label_verts = If true, shows labels at each vertex that show the vertex number.    Default: false
+//   label_faces = If true, shows labels at the center of each face that show the face number.    Default: false
+//   wireframe = If true, shows edges more clearly so you can see them in Thrown Together mode.    Default: false
+//   adjacent = If true, only display faces adjacent to a vertex listed in the errors.    Default: false
+// Example(3D,Edges): BIG_FACE Warnings; Faces with More Than 3 Vertices.  CGAL often will fail to accept that a face is planar after a rotation, if it has more than 3 vertices.
 //   vnf = skin([
 //       path3d(regular_ngon(n=3, d=100),0),
 //       path3d(regular_ngon(n=5, d=100),100)
 //   ], slices=0, caps=true, method="tangent");
 //   vnf_validate(vnf);
-// Example: NONPLANAR Errors; Face Vertices are Not Coplanar
+// Example(3D,Edges): NONPLANAR Errors; Face Vertices are Not Coplanar
 //   a = [  0,  0,-50];
 //   b = [-50,-50, 50];
 //   c = [-50, 50, 50];
 //   d = [ 50, 50, 60];
 //   e = [ 50,-50, 50];
 //   vnf = vnf_from_polygons([
 //       [a, b, e], [a, c, b], [a, d, c], [a, e, d], [b, c, d, e]
 //   ]);
 //   vnf_validate(vnf);
-// Example: MULTCONN Errors; More Than Two Faces Attached to the Same Edge.  This confuses CGAL, and can lead to failed renders.
+// Example(3D,Edges): MULTCONN Errors; More Than Two Faces Attached to the Same Edge.  This confuses CGAL, and can lead to failed renders.
 //   vnf = vnf_triangulate(linear_sweep(union(square(50), square(50,anchor=BACK+RIGHT)), height=50));
 //   vnf_validate(vnf);
-// Example: REVERSAL Errors; Faces Reversed Across Edge
+// Example(3D,Edges): REVERSAL Errors; Faces Reversed Across Edge
 //   vnf1 = skin([
 //       path3d(square(100,center=true),0),
 //       path3d(square(100,center=true),100),
 //   ], slices=0, caps=false);
 //   vnf = vnf_join([vnf1, vnf_from_polygons([
 //       [[-50,-50,  0], [ 50, 50,  0], [-50, 50,  0]],
 //       [[-50,-50,  0], [ 50,-50,  0], [ 50, 50,  0]],
 //       [[-50,-50,100], [-50, 50,100], [ 50, 50,100]],
 //       [[-50,-50,100], [ 50,-50,100], [ 50, 50,100]],
 //   ])]);
 //   vnf_validate(vnf);
-// Example: T_JUNCTION Errors; Vertex is Mid-Edge on Another Face.
-//   vnf1 = skin([
-//       path3d(square(100,center=true),0),
-//       path3d(square(100,center=true),100),
-//   ], slices=0, caps=false);
-//   vnf = vnf_join([vnf1, vnf_from_polygons([
-//       [[-50,-50,0], [50,50,0], [-50,50,0]],
-//       [[-50,-50,0], [50,-50,0], [50,50,0]],
-//       [[-50,-50,100], [-50,50,100], [0,50,100]],
-//       [[-50,-50,100], [0,50,100], [0,-50,100]],
-//       [[0,-50,100], [0,50,100], [50,50,100]],
-//       [[0,-50,100], [50,50,100], [50,-50,100]],
-//   ])]);
+// Example(3D,Edges): T_JUNCTION Errors; Vertex is Mid-Edge on Another Face.
+//   vnf = [
+//       [
+//           each path3d(square(100,center=true),0),
+//           each path3d(square(100,center=true),100),
+//           [0,-50,100],
+//       ], [
+//          [0,2,1], [0,3,2], [0,8,4], [0,1,8], [1,5,8],
+//          [0,4,3], [4,7,3], [1,2,5], [2,6,5], [3,7,6],
+//          [3,6,2], [4,5,6], [4,6,7],
+//       ]
+//   ];
 //   vnf_validate(vnf);
-// Example: FACE_ISECT Errors; Faces Intersect
+// Example(3D,Edges): FACE_ISECT Errors; Faces Intersect
 //   vnf = vnf_join([
 //       vnf_triangulate(linear_sweep(square(100,center=true), height=100)),
 //       move([75,35,30],p=vnf_triangulate(linear_sweep(square(100,center=true), height=100)))
 //   ]);
 //   vnf_validate(vnf,size=2,check_isects=true);
-// Example: HOLE_EDGE Errors; Edges Adjacent to Holes.
+// Example(3D,Edges): HOLE_EDGE Errors; Edges Adjacent to Holes.
 //   vnf = skin([
 //       path3d(regular_ngon(n=4, d=100),0),
 //       path3d(regular_ngon(n=5, d=100),100)
 //   ], slices=0, caps=false);
 //   vnf_validate(vnf,size=2);
-function vnf_validate(vnf, show_warns=true, check_isects=false) =
+
+
+//   Returns a list of non-manifold errors with the given VNF.
+//   Each error has the format `[ERR_OR_WARN,CODE,MESG,POINTS,COLOR]`.
+function _vnf_validate(vnf, show_warns=true, check_isects=false) =
     assert(is_vnf(vnf), "Invalid VNF")
     let(
-        vnf = vnf_merge_points(vnf),
         varr = vnf[0],
         faces = vnf[1],
         lvarr = len(varr),
         edges = sort([
             for (face=faces, edge=pair(face,true))
             edge[0]<edge[1]? edge : [edge[1],edge[0]]
         ]),
@@ -1463,24 +1652,23 @@
         uniq_edges = edgecnts[0],
         issues = []
     )
     let(
         big_faces = !show_warns? [] : [
             for (face = faces)
             if (len(face) > 3)
-            _vnf_validate_err("BIG_FACE", [for (i=face) varr[i]])
+            _vnf_validate_err("BIG_FACE", face)
         ],
         null_faces = !show_warns? [] : [
             for (i = idx(faces)) let(
                 face = faces[i],
-                area = face_areas[i],
-                faceverts = [for (k=face) varr[k]]
+                area = face_areas[i]
             )
             if (is_num(area) && abs(area) < EPSILON)
-            _vnf_validate_err("NULL_FACE", faceverts)
+            _vnf_validate_err("NULL_FACE", face)
         ],
         issues = concat(big_faces, null_faces)
     )
     let(
         bad_indices = [
             for (face = faces, idx = face)
             if (idx < 0 || idx >= lvarr)
@@ -1497,34 +1685,34 @@
             ) if (min(face1) == min(face2)) let(
                 min1 = min_index(face1),
                 min2 = min_index(face2)
             ) if (min1 == min2) let(
                 sface1 = list_rotate(face1,min1),
                 sface2 = list_rotate(face2,min2)
             ) if (sface1 == sface2)
-            _vnf_validate_err("DUP_FACE", [for (i=sface1) varr[i]])
+            _vnf_validate_err("DUP_FACE", sface1)
         ],
         issues = concat(issues, repeated_faces)
     ) repeated_faces? issues :
     let(
         multconn_edges = unique([
             for (i = idx(uniq_edges))
             if (edgecnts[1][i]>2)
-            _vnf_validate_err("MULTCONN", [for (i=uniq_edges[i]) varr[i]])
+            _vnf_validate_err("MULTCONN", uniq_edges[i])
         ]),
         issues = concat(issues, multconn_edges)
     ) multconn_edges? issues :
     let(
         reversals = unique([
             for(i = idx(dfaces), j = idx(dfaces)) if(i != j)
             for(edge1 = pair(faces[i],true))
             for(edge2 = pair(faces[j],true))
             if(edge1 == edge2)  // Valid adjacent faces will never have the same vertex ordering.
             if(_edge_not_reported(edge1, varr, multconn_edges))
-            _vnf_validate_err("REVERSAL", [for (i=edge1) varr[i]])
+            _vnf_validate_err("REVERSAL", edge1)
         ]),
         issues = concat(issues, reversals)
     ) reversals? issues :
     let(
         t_juncts = unique([
             for (v=idx(varr), edge=uniq_edges) let(
                 ia = edge[0],
@@ -1536,15 +1724,15 @@
                 b = varr[ib],
                 c = varr[ic]
             )
             if (!approx(a,b) && !approx(b,c) && !approx(a,c)) let(
                 pt = line_closest_point([a,c],b,SEGMENT)
             )
             if (approx(pt,b))
-            _vnf_validate_err("T_JUNCTION", [b])
+            _vnf_validate_err("T_JUNCTION", [ib])
         ]),
         issues = concat(issues, t_juncts)
     ) t_juncts? issues :
     let(
         isect_faces = !check_isects? [] : unique([
             for (i = [0:1:len(faces)-2]) let(
                 f1 = faces[i],
@@ -1588,28 +1776,28 @@
     ) isect_faces? issues :
     let(
         hole_edges = unique([
             for (i=idx(uniq_edges))
             if (edgecnts[1][i]<2)
             if (_pts_not_reported(uniq_edges[i], varr, t_juncts))
             if (_pts_not_reported(uniq_edges[i], varr, isect_faces))
-            _vnf_validate_err("HOLE_EDGE", [for (i=uniq_edges[i]) varr[i]])
+            _vnf_validate_err("HOLE_EDGE", uniq_edges[i])
         ]),
         issues = concat(issues, hole_edges)
     ) hole_edges? issues :
     let(
         nonplanars = unique([
             for (i = idx(faces)) let(
                 face = faces[i],
                 area = face_areas[i],
                 faceverts = [for (k=face) varr[k]]
             )
             if (is_num(area) && abs(area) > EPSILON)
             if (!is_coplanar(faceverts))
-            _vnf_validate_err("NONPLANAR", faceverts)
+            _vnf_validate_err("NONPLANAR", face)
         ]),
         issues = concat(issues, nonplanars)
     ) issues;
 
 
 _vnf_validate_errs = [
     ["BIG_FACE",    "WARNING", "cyan",    "Face has more than 3 vertices, and may confuse CGAL"],
@@ -1644,39 +1832,71 @@
     ) [
         for (report = reports) let(
             pts = sort(report[3])
         ) if (len(pts)==2 && edge == pts) 1
     ] == [];
 
 
-module vnf_validate(vnf, size=1, show_warns=true, check_isects=false) {
+module vnf_validate(vnf, size=1, show_warns=true, check_isects=false, opacity=0.67, adjacent=false, label_verts=false, label_faces=false, wireframe=false) {
     no_children($children);
-    faults = vnf_validate(
+    vcount = len(vnf[0]);
+    fcount = len(vnf[1]);
+    vnf = vnf_merge_points(vnf);
+    faults = _vnf_validate(
         vnf, show_warns=show_warns,
         check_isects=check_isects
     );
+    verts = vnf[0];
+    vnf_changed = len(verts)!=vcount || len(vnf[1])!=fcount;
+    if (!faults) {
+        echo("VNF appears valid.");
+    }
+    if (vnf_changed) echo("VNF changed when merging points; unable to display indices");
     for (fault = faults) {
         err = fault[0];
         typ = fault[1];
         clr = fault[2];
         msg = fault[3];
-        pts = fault[4];
-        echo(str(typ, " ", err, " (", clr ,"): ", msg, " at ", pts));
+        idxs = fault[4];
+        pts = err=="FACE_ISECT" ? idxs : [for (i=idxs) if(is_finite(i) && i>=0 && i<len(verts)) verts[i]];
+        if (vnf_changed || err=="FACE_ISECT")
+          echo(str(typ, " ", err, " (", clr ,"): ", msg, " at ", pts));
+        else
+          echo(str(typ, " ", err, " (", clr ,"): ", msg, " at ", pts, " indices: ", idxs));
         color(clr) {
             if (is_vector(pts[0])) {
                 if (len(pts)==2) {
-                    stroke(pts, width=size, closed=true, endcaps="butt", hull=false, $fn=8);
+                    stroke(pts, width=size, closed=true, endcaps="butt", $fn=8);
                 } else if (len(pts)>2) {
-                    stroke(pts, width=size, closed=true, hull=false, $fn=8);
+                    stroke(pts, width=size, closed=true, $fn=8);
                     polyhedron(pts,[[for (i=idx(pts)) i]]);
                 } else {
                     move_copies(pts) sphere(d=size*3, $fn=18);
                 }
             }
         }
     }
-    color([0.5,0.5,0.5,0.67]) vnf_polyhedron(vnf);
+    badverts = unique([for (fault=faults) each fault[4]]);
+    badverts2 = unique([for (j=idx(verts), i=badverts) if (i!=j && verts[i]==verts[j]) j]);
+    all_badverts = unique(concat(badverts, badverts2));
+    adjacent = !faults? false : adjacent;
+    filter_fn = !adjacent? undef : function(i) in_list(i,all_badverts);
+    adj_vnf = !adjacent? vnf : [
+        verts, [for (face=vnf[1]) if (any(face,filter_fn)) face]
+    ];
+    if (wireframe) {
+        vnf_wireframe(adj_vnf, width=size*0.25);
+    }
+    if (label_verts) {
+        debug_vnf(adj_vnf, size=size*3, opacity=0, faces=false, vertices=true, filter=filter_fn);
+    }
+    if (label_faces) {
+        debug_vnf(vnf, size=size*3, opacity=0, faces=true, vertices=false, filter=filter_fn);
+    }
+    if (opacity > 0) {
+        color([0.5,1,0.5,opacity]) vnf_polyhedron(adj_vnf);
+    }
 }
 
 
 
 // vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/walls.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/walls.scad`

 * *Files 8% similar despite different names*

```diff
@@ -9,20 +9,21 @@
 //////////////////////////////////////////////////////////////////////
 
 
 // Section: Walls
 
 
 // Module: sparse_wall()
+// Synopsis: Makes an open cross-braced rectangular wall.
+// Topics: FDM Optimized, Walls
+// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
 //
 // Usage:
 //   sparse_wall(h, l, thick, [maxang=], [strut=], [max_bridge=]) [ATTACHMENTS];
 //
-// Topics: FDM Optimized, Walls
-//
 // Description:
 //   Makes an open rectangular strut with X-shaped cross-bracing, designed to reduce
 //   the need for support material in 3D printing.
 //
 // Arguments:
 //   h = height of strut wall.
 //   l = length of strut wall.
@@ -82,20 +83,21 @@
         }
         children();
     }
 }
 
 
 // Module: corrugated_wall()
+// Synopsis: Makes a corrugated rectangular wall.
+// Topics: FDM Optimized, Walls
+// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
 //
 // Usage:
 //   corrugated_wall(h, l, thick, [strut=], [wall=]) [ATTACHMENTS];
 //
-// Topics: FDM Optimized, Walls
-//
 // Description:
 //   Makes a corrugated wall which relieves contraction stress while still
 //   providing support strength.  Designed with 3D printing in mind.
 //
 // Arguments:
 //   h = height of strut wall.
 //   l = length of strut wall.
@@ -140,20 +142,21 @@
         }
         children();
     }
 }
 
 
 // Module: thinning_wall()
+// Synopsis: Makes a rectangular wall with a thin middle.
+// Topics: FDM Optimized, Walls
+// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
 //
 // Usage:
 //   thinning_wall(h, l, thick, [ang=], [braces=], [strut=], [wall=]) [ATTACHMENTS];
 //
-// Topics: FDM Optimized, Walls
-//
 // Description:
 //   Makes a rectangular wall which thins to a smaller width in the center,
 //   with angled supports to prevent critical overhangs.
 //
 // Arguments:
 //   h = Height of wall.
 //   l = Length of wall.  If given as a vector of two numbers, specifies bottom and top lengths, respectively.
@@ -323,20 +326,21 @@
         }
         children();
     }
 }
 
 
 // Module: thinning_triangle()
+// Synopsis: Makes a triangular wall with a thin middle.
+// Topics: FDM Optimized, Walls
+// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
 //
 // Usage:
 //   thinning_triangle(h, l, thick, [ang=], [strut=], [wall=], [diagonly=], [center=]) [ATTACHMENTS];
 //
-// Topics: FDM Optimized, Walls
-//
 // Description:
 //   Makes a triangular wall with thick edges, which thins to a smaller width in
 //   the center, with angled supports to prevent critical overhangs.
 //
 // Arguments:
 //   h = height of wall.
 //   l = length of wall.
@@ -390,20 +394,21 @@
         }
         children();
     }
 }
 
 
 // Module: narrowing_strut()
+// Synopsis: Makes a strut like an extruded baseball home plate.
+// Topics: FDM Optimized
+// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
 //
 // Usage:
 //   narrowing_strut(w, l, wall, [ang=]) [ATTACHMENTS];
 //
-// Topics: FDM Optimized
-//
 // Description:
 //   Makes a rectangular strut with the top side narrowing in a triangle.
 //   The shape created may be likened to an extruded home plate from baseball.
 //   This is useful for constructing parts that minimize the need to support
 //   overhangs.
 //
 // Arguments:
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/BOSL2/wiring.scad` & `solidpython2-2.0.1/solid2/libs/BOSL2/wiring.scad`

 * *Files 6% similar despite different names*

```diff
@@ -50,14 +50,17 @@
 
 
 
 // Section: Modules
 
 
 // Module: wire_bundle()
+// Synopsis: Creates a wire bundle for a given number of wires.
+// Topics: Wiring
+// See Also: path_sweep(), path_sweep2d()
 // Usage:
 //   wire_bundle(path, wires, [wirediam], [rounding], [wirenum=], [corner_steps=]);
 // Description:
 //   Returns a 3D object representing a bundle of wires that follow a given path,
 //   with the corners rounded to a given radius.  There are 17 base wire colors.
 //   If you have more than 17 wires, colors will get re-used.
 // Arguments:
```

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/LICENSE` & `solidpython2-2.0.1/solid2/libs/py_scadparser/LICENSE`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/README.md` & `solidpython2-2.0.1/solid2/libs/py_scadparser/README.md`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/parsetab.py` & `solidpython2-2.0.1/solid2/libs/py_scadparser/parsetab.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_ast.py` & `solidpython2-2.0.1/solid2/libs/py_scadparser/scad_ast.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_parser.py` & `solidpython2-2.0.1/solid2/libs/py_scadparser/scad_parser.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/solid2/libs/py_scadparser/scad_tokens.py` & `solidpython2-2.0.1/solid2/libs/py_scadparser/scad_tokens.py`

 * *Files identical despite different names*

### Comparing `solidpython2-2.0.0b4/setup.py` & `solidpython2-2.0.1/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,31 +7,25 @@
  'solid2.core.builtins',
  'solid2.core.object_base',
  'solid2.examples',
  'solid2.extensions',
  'solid2.extensions.bosl2',
  'solid2.extensions.greedy_scad_interface',
  'solid2.libs',
- 'solid2.libs.BOSL2.scripts',
  'solid2.libs.py_scadparser']
 
 package_data = \
-{'': ['*'],
- 'solid2.examples': ['11-font/*'],
- 'solid2.libs': ['BOSL2/*',
-                 'BOSL2/images/*',
-                 'BOSL2/tests/*',
-                 'BOSL2/tutorials/*']}
+{'': ['*'], 'solid2.examples': ['11-font/*'], 'solid2.libs': ['BOSL2/*']}
 
 install_requires = \
 ['ply>=3.11,<4.0', 'setuptools>=65.6.3']
 
 setup_kwargs = {
     'name': 'solidpython2',
-    'version': '2.0.0b4',
+    'version': '2.0.1',
     'description': 'Python interface to the OpenSCAD declarative geometry language',
     'long_description': '\n.. image:: https://readthedocs.org/projects/solidpython2/badge/?version=latest\n    :target: http://solidpython2.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\n**If you switch from the regular SolidPython:master branch to this branch, have a\nlook at** `Version 2.x.x`_.\n\nSolidPython\n===========\n\n.. contents::\n   \nOpenSCAD for Python\n-------------------\n\nSolidPython is a generalization of Phillip Tiefenbacher\'s openscad\nmodule, found on `Thingiverse <http://www.thingiverse.com/thing:1481>`__. It\ngenerates valid OpenSCAD code from Python code with minimal overhead. Here\'s a\nsimple example:\n\nThis Python code:\n\n.. code:: python\n\n    from solid2 import *\n    d = difference()(\n        cube(10),\n        sphere(15)\n    )\n    d.as_scad()\n\nGenerates this OpenSCAD code:\n\n.. code:: python\n\n    difference(){\n        cube(10);\n        sphere(15);\n    }\n\nThat doesn\'t seem like such a savings, but the following SolidPython code is a\nlot shorter (and I think clearer) than the SCAD code it compiles to:\n\n.. code:: python\n\n    from solid2 import *\n    d = cube(5) + right(5)(sphere(5)) - cylinder(r=2, h=6)\n\nGenerates this OpenSCAD code:\n\n.. code::\n\n    difference(){\n        union(){\n            cube(5);\n            translate( [5, 0,0]){\n                sphere(5);\n            }\n        }\n        cylinder(r=2, h=6);\n    }\n\nAdvantages\n----------\n\nIn contrast to OpenSCAD -- which is a constrained domain specific language --\nPython is a full blown modern programming language and as such supports\npretty much all modern programming features. Furthermore a huge number of\nlibraries is available.\n\nSolidPython lets you use all these fancy python features to generate your\nconstructive solid geometry models.\n\nOn the one hand it makes the generation of your models a lot easier, because\nyou don\'t need to learn another domain specific language and you can use all\nthe programming technique you\'re already familiar with. On the other hand it\ngives you a lot more power, because you can use all the comprehensive python\nlibraries to generate your models.\n\nI would almost say this enables you to do what ever you want with ease.\nAs (maybe little uncommon) example, you could write a program that:\n\n  - looks up the mail adress of your actuall president (based on your ip address)\n  - writes a mail to him or her and asks for a portrait\n  - waits for a reply\n  - generates a heightmap from the picture you received and maps it onto a vase\n\nThis should be pretty straight forward with SolidPython but is impossible with\npure OpenSCAD.\n\nFurhtermore SolidPython 2.x.x is designed to be extendible. As such you can extend SolidPython itself using python. Actually parts of SolidPython itself are implemented as extensions (everything but the core one-to-one mapping of OpenScad to Python), these include operators, access style syntax, convenience functions, scad_interface and bosl2 support. Furthermore some of the SolidPython 1.x.x solid.utils features are also implemented as extensions (bill of material & part-hole).\n\nInstalling SolidPython\n----------------------\n\n-  Install latest release via\n   `PyPI <https://pypi.python.org/pypi/solidpython2>`__:\n\n   .. code:: bash\n\n       pip install solidpython2\n\n   (You may need to use ``sudo pip install solidpython2``, depending on\n   your environment. This is commonly discouraged though. You\'ll be happiest \n   working in a `virtual environment <https://docs.python.org/3/tutorial/venv.html>`__ \n   where you can easily control dependencies for a given project)\n\n- Install current master straight from Github:\n\n  .. code:: bash\n\n      pip install git+https://github.com/jeff-dh/SolidPython\n\nUsing SolidPython\n-----------------\n\n-  Include SolidPython at the top of your Python file:\n\n   .. code:: python\n\n       from solid2 import *\n\n   (See `this issue <https://github.com/SolidCode/SolidPython/issues/114>`__ for \n   a discussion of other import styles)\n\n-  OpenSCAD uses curly-brace blocks ({}) to create its tree. SolidPython\n   uses parentheses with comma-delimited lists. \n   \n   **OpenSCAD:**\n\n   .. code::\n\n       difference(){\n           cube(10);\n           sphere(15);\n       }\n\n   **SolidPython:**\n\n   .. code::\n\n       d = difference()(\n           cube(10),  # Note the comma between each element!\n           sphere(15)\n       )\n\n-  Call ``py_scad_obj.as_scad()`` to generate SCAD code. This returns\n   a string of valid OpenSCAD code.\n-  *or*: call ``py_scad_obj.save_as_scad("filepath.scad")`` to store\n   that code in a file.\n-  If ``filepath.scad`` is open in the OpenSCAD IDE and Design => \'Automatic\n   Reload and Compile\' is checked in the OpenSCAD IDE, running\n   ``py_scad_obj.save_as_scad()`` from Python will load the object in the\n   IDE.\n-  Alternately, you could call OpenSCAD\'s command line and render\n   straight to STL.\n\nImporting OpenSCAD code\n-----------------------\n\n- Use ``solid2.import_scad(path)`` to import OpenSCAD code. Relative paths will check the current location designated in `OpenSCAD library directories <https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Libraries>`__.\n\n**Ex:** \n\n``scadfile.scad``\n\n.. code::\n\n    module box(w,h,d){\n        cube([w,h,d]);\n    }\n\n``your_file.py``\n\n.. code:: python\n\n    from solid2 import *\n\n    scadfile = import_scad(\'/path/to/scadfile.scad\') \n    b = scadfile.box(2,4,6)\n    b.save_as_scad(\'out_file.scad\')\n\n- Recursively import OpenSCAD code by calling ``import_scad()`` with a directory argument.\n\n.. code:: python\n\n    from solid2 import *\n\n    # MCAD is OpenSCAD\'s most common utility library: https://github.com/openscad/MCAD\n    # If it\'s installed for OpenSCAD (on MacOS, at: ``$HOME/Documents/OpenSCAD/libraries``)\n    mcad = import_scad(\'MCAD\')\n\n    # MCAD contains about 15 separate packages, each included as its own namespace\n    print(dir(mcad)) # => [\'bearing\', \'bitmap\', \'boxes\', etc...]\n    mount = mcad.motors.stepper_motor_mount(nema_standard=17)\n    mount.save_as_scad(\'motor_mount_file.scad\')\n\n- OpenSCAD has the ``use()`` and ``include()`` statements for importing SCAD code, and SolidPython has them, too. They pollute the global namespace, though, and you may have better luck with ``import_scad()``,\n\n**Ex:**\n\n``scadfile.scad``\n\n.. code::\n\n    module box(w,h,d){\n        cube([w,h,d]);\n    }\n\n``your_file.py``\n\n.. code:: python\n\n    from solid2 import *\n\n    # use() puts the module `box()` into the global namespace\n    use(\'/path/to/scadfile.scad\') \n    b = box(2,4,6)\n    scad_render_to_file(b, \'out_file.scad\')\n\n\nExample Code\n------------\n\nThe best way to learn how SolidPython works is to look at the included\nexample code. If you\'ve installed SolidPython, the following line of\nPython will print (the location of) the examples directory:\n\n.. code:: python\n\n    import os, solid2; print(os.path.dirname(solid2.__file__) + \'/examples\')\n        \n\nOr browse the example code on Github\n`here <https://github.com/jeff-dh/SolidPython/tree/exp_solid/solid2/examples>`__\n\nExtra syntactic sugar\n=====================\n\nBasic operators\n---------------\n\nSolidPython overrides the basic operators + and | (union), - (difference), \\*\nand & (intersection) and ~ (debug). So\n\n.. code:: python\n\n    c = cylinder(r=10, h=5) + cylinder(r=2, h=30)\n\nis the same as:\n\n.. code:: python\n\n    c = union()(\n        cylinder(r=10, h=5),\n        cylinder(r=2, h=30)\n    )\n\nLikewise:\n\n.. code:: python\n\n    c = cylinder(r=10, h=5)\n    c -= cylinder(r=2, h=30)\n\nis the same as:\n\n.. code:: python\n\n    c = difference()(\n        cylinder(r=10, h=5),\n        cylinder(r=2, h=30)\n    )\n\nAccess Style Syntax\n-------------------\n\nSince at least some people (including me) don\'t like the OpenSCAD Syntax, SolidPython 2.x.x introduces the support for the so called "Access-Style-Syntax". This enables you to call some of the SolidPython / OpenSCAD functions as member functions of any OpenSCADObject instead of wrapping it in an instance of it.\n\nIn other words, e.g. code:\n\n.. code:: python\n\n  up(10)(cube(1))\n  #is equal to\n  cube(1).up(10)\n\nThe available member functions are the following:\n\n.. code:: python\n\n  union, difference, intersection, translate, scale, rotate, mirror, resize,\n  color, offset, hull, render, projection, surface, linear_extrude,\n  rotate_extrude, debug, background, root and disable\n\nAlso the convenience functions are available:\n\n.. code:: python\n\n  up, down, left, right, forward, fwd, back, translateX, translateY, translateZ,\n  rotateX, rotateY, rotateZ, mirrorX, mirrorY, mirrorZ, scaleX, scaleY, scaleZ,\n  resizeX, resizeY, resizeZ\n\nFurthermore you can chain these functions, because they all return the transformed OpenSCADObject, e.g.:\n\n.. code:: python\n\n  cube(1).up(10).back(20).rotate(10, 0, 5).mirror(1, 0, 0).color("green").root()\n\nConvenience functions\n---------------------\n\nSolidPython includes a number of convenience functions. Currently these\ninclude:\n\nDirections for arranging things:\n\n.. code:: python\n\n  up, down, left, right, forward, fwd, back\n\nTransformations per dimension:\n\n.. code:: python\n\n  translateX, translateY, translateZ, rotateX, rotateY, rotateZ, mirrorX,\n  mirrorY, mirrorZ, resizeX, resizeY, resizeZ, scaleX, scaleY, scaleZ\n\nFurthermore the operations `translate, scale, resize, mirror, rotate, cube and square` are overwritten in a way that they accept single integer or float values as first parameter. (`translate(1, 2, 3)` equals `translate([1, 2, 3])`)\n\n.. code:: python\n\n    cylinder().rotateY(90).up(10)\n\nseems a lot clearer to me than:\n\n.. code:: python\n\n    translate([0,0,10])(\n        rotate([0, 90, 0])(\n          cylinder()\n    ))\n\nFeatures\n========\n\nBOSL2\n-----\n\nSolidPython supports -- at least -- quite a lot of the **bosl2** library. You can use it by importing the ``solid2.extensions.bosl2``. Take a look at `bosl2 example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/07-libs-bosl2.py>`_ and `mazebox example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/16-mazebox-bosl2.py>`_ to get an idea how to use it and what\'s possible.\n\nI would suggest to use it as kind of a standard library for SolidPython.\nTake a look at their `Wiki <https://github.com/revarbat/BOSL2/wiki>`_ to get an idea about it\'s features.\n\n\nAnimation, Customizer, custom Fonts, ImplicitCad, Extensions\n------------------------------------------------------------\n\nSolidPython supports the following features\n\n* native **OpenSCAD customizer** support `customizer example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/10-customizer.py>`_ `greedy scad interface example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/17-greedy-scad-interface.py>`_\n* native **OpenSCAD animation** support `animation example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/12-animation.py>`_ and `animation example 2 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/13-animated-bouncing-ball.py>`_\n* **custom fonts** `fonts example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/11-fonts.py>`_\n* supports **ImplicitCAD** `implicitCAD example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/14-implicitCAD.py>`_ `implicitCAD example 2 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/15-implicitCAD2.py>`_\n* SolidPython is extendible `extensions example 1 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/08-extensions.py>`_  `extension example 2 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/09-code-attach-extension.py>`_\n\nJupyter Renderer\n================\n\nSolidPython can be rendered inside a Jupyter Notebook using ViewScad. Unfortunately the pypi version of ``viewscad`` seems to be not compatible with ``solid2``. @jreiberkyle created `this viewscad fork <https://github.com/jreiberkyle/ViewSCAD>`__ and made it work with `solid2` (`#7 <https://github.com/jeff-dh/SolidPython/issues/7>`__)\n\nVersion 2.x.x\n=============\n\nSolidPython 2.x.x is a refactored version of SolidPython 1.x.x.\nThe refactoring process was based on the following proposal:\nhttps://github.com/SolidCode/SolidPython/issues/169\n\nThe goal was to\n\n* extract the "core" from SolidPython\n* make a solid package that only contains the fundamentals (+ a few convenience features) \n* make it extendible\n* try to get complex libraries working properly (mcad, bosl, bosl2)\n* **KISS**: ``from solid2 import *`` -> imports only ~1000 lines of source code and has (almost?) all the feautres SolidPython 1.x.x has\n* be a drop in replacement for SolidPython 1.x.x -- as far as possible, see Backwards Compatibility Section\n* get all kinds of nice features working (see Features section)\n\nThe result is a refactored and in some parts rewritten version of SolidPython we would like to release as SolidPython 2.x.x. The major improvement is a code base that should be better maintainable and extendible.\n\nBesides these benefits SolidPython 2.x.x implemented quite a few nice new features (cf. Features section).\n\nFeatures\n--------\n\nSolidPython 2.x.x has support for the following new features:\n\n* **bosl2** - SolidPython is now able to handle bosl2 pretty well (don\'t know whether everything works, but quite a lot). `bosl2 example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/07-libs-bosl2.py>`_ and `mazebox example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/16-mazebox-bosl2.py>`_\n* native **OpenSCAD customizer** support `customizer example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/10-customizer.py>`_ and `greedy scad interface example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/17-greedy-scad-interface.py>`_\n* native **OpenSCAD animation** support `animation example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/12-animation.py>`_ and `animation example 2 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/13-animated-bouncing-ball.py>`_\n* **custom fonts** `fonts example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/11-fonts.py>`_\n* supports **ImplicitCAD** `implicitCAD example <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/14-implicitCAD.py>`_ and `implicitCAD example 2 <https://github.com/jeff-dh/SolidPython/blob/exp_solid/solid2/examples/15-implicitCAD2.py>`_\n\nFurthermore it has several minor improvements, like these which are based on ideas from *posts* from the SolidPython universe:\n\n* use invert operator (~) as # in OpenSCAD `#167 <https://github.com/SolidCode/SolidPython/pull/167>`_\n* convenience function including to pass sizes as integer parameters (``translate(10, 20, 30)``) `#63 <https://github.com/SolidCode/SolidPython/pull/63#issuecomment-688171416>`_\n* *access-style* syntax: ``cube(1).up(5).rotate(45, 0, 0)`` `#66 <https://github.com/SolidCode/SolidPython/pull/66>`_ This is additional! The OpenSCAD / SolidPython style syntax is still fully supported.\n\nAnother nice little feature especially to play around and debug it is that the ``__repr__`` operator of each "OpenSCADObject" now calls ``scad_render``. With this the python shell becomes pretty good in debuging and playing around with solid code and the library itself:\n\n.. code:: python\n\n  >>> from solid2 import *\n  >>> c = cube(5)\n  >>> c.up(5)\n  translate(v = [0, 0, 5]) {\n          cube(size = 5);\n  };\n  >>> c.up(5).save_as_scad()\n  \'/home/xxx/xxx/xxx/SolidPython/expsolid_out.scad\'\n  >>>\n\nBackwards compatibility\n-----------------------\n\nSolidPython 2.x.x should be a complete and mostly backwards compatible drop in\nreplacement for SolidPython 1.x.x.\nThe backwards compatibility is not 100% as depicted by the version number.\nSomethings (and even interfaces) changed. We tried to stay as backward\ncompatible as possible.  The package should behave 98% the same as SolidPython\nunless you do some "deep access" -- that\'s by 99% chance not backwards\ncompatible (like modifying OpenSCADObjects or import internal modules).\n\nAs long as you stick to:\n\n.. code:: python\n\n  from solid2 import *\n\nyou shoul be fine.\n\n**solid.utils**\n\n``solid.utils`` consisted of convenience functions and "modelling extensions" (kind of a small third party library like `mcad, bosl, bosl2`).\nThe convenience functions are now -- or the missing ones are supposed to be -- part of `solid2.extensions.convenience` and are automatically importet with the main package.\n\nConcerning the "modelling extensions" I would actually like to get rid of them as part of the SolidPython 2.x.x package. The resons are the following:\n\n* these modelling extensions (like `extrude_along_path, splines, screw_threads, part_hole,...`) don\'t align with the (core) purpose of SolidPython as I understand it (I think SolidPython is supposed to be a python "wrapper" / interface for OpenSCAD)\n* these modelling extensions are "yet another implementation" of common modelling task that need to be maintained. I would prefere a SolidPython design where these features are outsourced into a third party library\n* SolidPython 2.x.x has a pretty good **bosl2** support and bosl2 has all (?) the features provided by `solid.utils`:\n\n  * extrude_along_path: https://github.com/revarbat/BOSL2/wiki/mutators.scad#module-path_extrude\n  * First-class Negative Space (Holes): https://github.com/revarbat/BOSL2/wiki/attachments.scad#module-diff\n  * Splines / Bezier: https://github.com/revarbat/BOSL2/wiki/beziers.scad\n  * Screw threads: https://github.com/revarbat/BOSL2/wiki/screws.scad https://github.com/revarbat/BOSL2/wiki/metric_screws.scad https://github.com/revarbat/BOSL2/wiki/threading.scad\n  * distributors: https://github.com/revarbat/BOSL2/wiki/distributors.scad\n  * bouding boxes: https://github.com/revarbat/BOSL2/wiki/mutators.scad#module-bounding_box\n  * arcs, pie slices, tubes, ...: https://github.com/revarbat/BOSL2/wiki/shapes3d.scad https://github.com/revarbat/BOSL2/wiki/drawing.scad\n  * cut models in "half" / by a plane: https://github.com/revarbat/BOSL2/wiki/mutators.scad#functionmodule-half_of\n  * attachments: https://github.com/revarbat/BOSL2/wiki/attachments.scad\n\nAnd a looooot more.....\n\nI don\'t see why SolidPython should implement and maintain its own set of these features. Furthermore I assume a third party library (like `bosl2`) is probably able to provide more sophisticated implementations than we will ever be able to provide.\n\nPlease take a look at the `bosl2` implementations. I did some very basic tests in ``examples/07-libs-bosl2.py`` and -- at least -- was able to create basic examples for the core `solid.utils` features using bosl2.\n\nI would also be fine with a python third party library that implements these features, but I would like to seperate it from SolidPython itself. The reason is to achieve a SolidPython module which is independent from it (development, bugs, maintainance) with the goal to get an as solid and stable as possible SolidPython (core) package.\n\nBUT, since I assume quite a few people out there are using `solid.utils` up until now and simply getting rid of it might cause some brouhaha, my suggestion for a compromise is the `solid_legay` extension.\n\n**solid2_legacy**\n\nThe `solid2_legacy` extension is basicly everything that used to be `solid.utils`. Furhtermore it tries to "mimic" the SolidPython 1.x.x interface. This is the effort to become as backward compatible as possible. This might for example be useful when trying to get existing SolidPython 1.x.x code running.\n\nThe `solid2_legacy` extension got extracted into a seperate repo (and pip package). You should be able to just import the package if it is installed or somewhere in your import path.\n\nIf you want to use those features import the extension and take a look at it.\n\n.. code:: python\n\n  from solid2_legacy import *\n\nAnyway SolidPython 1.x.x `imports` do not work with SolidPython 2.x.x! (see Interface changes - imoprt paths have changed)\n\nI was able to get the SolidPython 1.x.x examples running just by changing the imports and they all (except for the splines example which seems to have an internal issue) worked "out of the box".\n\n\n**Interface changes**\n\n* OpenSCAD identifier escaping:\n        * all *illegal* python idetifiers are escape with a single prepending underscore\n        * special variables ``$fn -> _fn`` (*note*: ``segments`` still works)\n        * identifier starting with a digit ``module 12ptStar() -> _12ptStar()`` (*note*: ``__12ptStar`` still works)\n        * python keywords ``module import() -> _import()`` (*note*: ``import\\_``  still works)\n\n* import paths have changed (a lot)\n    * as long as you only import the root package it should be fine, otherwise probably not\n    \n    .. code:: python\n    \n            from solid2 import * #fine\n            from solid2 import objects #crash\n            from solid2 import solidpython #crash\n            from solid2 import splines #crash\n            from solid2 import utils #crash\n\n* all extensions have been moved:\n    * solid.utils has been moved to ``solid2_legacy``. If you want to use them import that extension\n    * there are some example implementations of the part / hole feature and\n      bill of materials in ``solid2_legacy``. They seem to work but are\n      not tested extensively. Take a look at ``examples/xx_legacy*``.\n    * please take a look at the bosl2 example. BOSL2 provides many features which\n      might be alternatives.\n\n* OpenSCADObject internally changed a lot\n    If you access it directly\n    (e.g. mycube.set_modifier) this might not work. But if you import\n    ``solid2_legacy`` some dummy methods will be monkey patched onto\n    OpenSCADObject so you might be able to at least run the code, but it\n    might render not correctly.\n\n* maybe some more things I can\'t remember. Some function signatures changed\n  slightly. But as long as as you stick to the regular public interface\n  everything should be fine.\n\n\nContact\n=======\n\nEnjoy!\n\nIf you have any questions or bug reports please report them to the SolidPython\n`GitHub page <https://github.com/jeff-dh/SolidPython>`__!\n\n\n\nCheers!\n\nLicense\n=======\n\nThis library is free software; you can redistribute it and/or modify it\nunder the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 2.1 of the License, or (at\nyour option) any later version.\n\nThis library is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser\nGeneral Public License for more details.\n\n`Full text of the\nlicense <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt>`__.\n\nSome class docstrings are derived from the `OpenSCAD User Manual\n<https://en.wikibooks.org/wiki/OpenSCAD_User_Manual>`__, so \nare available under the `Creative Commons Attribution-ShareAlike License\n<https://creativecommons.org/licenses/by-sa/3.0/>`__. \n\n',
     'author': 'jeff',
     'author_email': 'None',
     'maintainer': 'None',
     'maintainer_email': 'None',
     'url': 'https://github.com/jeff-dh/SolidPython',
```

### Comparing `solidpython2-2.0.0b4/PKG-INFO` & `solidpython2-2.0.1/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: solidpython2
-Version: 2.0.0b4
+Version: 2.0.1
 Summary: Python interface to the OpenSCAD declarative geometry language
 Home-page: https://github.com/jeff-dh/SolidPython
 License: LGPL-2.1
 Keywords: 3D,CAD,CSG,constructive solid geometry,geometry,modeling,OpenSCAD
 Author: jeff
 Requires-Python: >=3.7
 Classifier: Development Status :: 4 - Beta
```

